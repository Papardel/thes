{
  "bug_id": "104",
  "failed_tests": {
    "com.fasterxml.jackson.databind.ser.jdk.DateSerializationTest": [
      {
        "methodName": "testDateISO8601_10k",
        "error": "org.junit.ComparisonFailure",
        "message": "expected:<\"[+10]204-01-01T00:00:00.0...> but was:<\"[:]204-01-01T00:00:00.0...>",
        "fail_line": "        serialize(w, judate(10204, 1, 1,  00, 00, 00, 0, \"UTC\"),   \"+10204-01-01T00:00:00.000+0000\");",
        "test_source": "  public void testDateISO8601_10k() throws IOException {\n  ObjectWriter w = MAPPER.writer()\n  .without(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\n  serialize(w, judate(10204, 1, 1,  00, 00, 00, 0, \"UTC\"),  \"+10204-01-01T00:00:00.000+0000\");\n  // and although specification lacks for beyond 5 digits (well, actually even 5...), let's do our best:\n  serialize(w, judate(123456, 1, 1,  00, 00, 00, 0, \"UTC\"),  \"+123456-01-01T00:00:00.000+0000\");\n  }",
        "stack": [
          "DateSerializationTest.serialize line 366, DateSerializationTest.testDateISO8601_10k line 134"
        ]
      },
      {
        "methodName": "testDateISO8601_BCE",
        "error": "org.junit.ComparisonFailure",
        "message": "expected:<\"[+0000]-01-01T00:00:00.000+...> but was:<\"[0001]-01-01T00:00:00.000+...>",
        "fail_line": "        serialize(w, judate(0, 1, 1,  00, 00, 00, 0, \"UTC\"),   \"+0000-01-01T00:00:00.000+0000\");",
        "test_source": "  public void testDateISO8601_BCE() throws IOException {\n  ObjectWriter w = MAPPER.writer()\n  .without(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\n\n  // First: I _think_ BCE-1 is what you get with year 0, and should become \"+0000\"\n  // and from further back in time, it'll be \"-0001\" (BCE-2) etc)\n\n  serialize(w, judate(0, 1, 1,  00, 00, 00, 0, \"UTC\"),  \"+0000-01-01T00:00:00.000+0000\");\n  serialize(w, judate(-1, 1, 1,  00, 00, 00, 0, \"UTC\"),  \"-0001-01-01T00:00:00.000+0000\");\n  serialize(w, judate(-49, 1, 1,  00, 00, 00, 0, \"UTC\"),  \"-0049-01-01T00:00:00.000+0000\"); // All hail Caesar\n  serialize(w, judate(-264, 1, 1,  00, 00, 00, 0, \"UTC\"),  \"-0264-01-01T00:00:00.000+0000\"); // Carthage FTW?\n  }",
        "stack": [
          "DateSerializationTest.serialize line 366, DateSerializationTest.testDateISO8601_BCE line 148"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "com/fasterxml/jackson/databind/util/StdDateFormat.java",
      "buggy_full_code": "package com.fasterxml.jackson.databind.util;\n\nimport java.text.DateFormat;\nimport java.text.FieldPosition;\nimport java.text.ParseException;\nimport java.text.ParsePosition;\nimport java.text.SimpleDateFormat;\nimport java.util.*;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport com.fasterxml.jackson.core.io.NumberInput;\n\n\n@SuppressWarnings(\"serial\")\npublic class StdDateFormat extends DateFormat { protected final static String PATTERN_PLAIN_STR = \"\\\\d\\\\d\\\\d\\\\d[-]\\\\d\\\\d[-]\\\\d\\\\d\"; protected final static Pattern PATTERN_PLAIN = Pattern.compile(PATTERN_PLAIN_STR); protected final static Pattern PATTERN_ISO8601; static {\n        Pattern p = null;\n        try {\n            p = Pattern.compile(PATTERN_PLAIN_STR\n                    +\"[T]\\\\d\\\\d[:]\\\\d\\\\d(?:[:]\\\\d\\\\d)?\" \n                    +\"(\\\\.\\\\d+)?\" \n                    +\"(Z|[+-]\\\\d\\\\d(?:[:]?\\\\d\\\\d)?)?\" \n            );\n        } catch (Throwable t) {\n            throw new RuntimeException(t);\n        }\n        PATTERN_ISO8601 = p;\n    }\n\n    \n    public final static String DATE_FORMAT_STR_ISO8601 = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\"; protected final static String DATE_FORMAT_STR_PLAIN = \"yyyy-MM-dd\"; protected final static String DATE_FORMAT_STR_RFC1123 = \"EEE, dd MMM yyyy HH:mm:ss zzz\"; protected final static String[] ALL_FORMATS = new String[] { DATE_FORMAT_STR_ISO8601, \"yyyy-MM-dd'T'HH:mm:ss.SSS\", DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }; protected final static TimeZone DEFAULT_TIMEZONE; static { DEFAULT_TIMEZONE = TimeZone.getTimeZone(\"UTC\"); } protected final static Locale DEFAULT_LOCALE = Locale.US; protected final static DateFormat DATE_FORMAT_RFC1123; protected final static DateFormat DATE_FORMAT_ISO8601; static {\n        \n        \n        DATE_FORMAT_RFC1123 = new SimpleDateFormat(DATE_FORMAT_STR_RFC1123, DEFAULT_LOCALE);\n        DATE_FORMAT_RFC1123.setTimeZone(DEFAULT_TIMEZONE);\n        DATE_FORMAT_ISO8601 = new SimpleDateFormat(DATE_FORMAT_STR_ISO8601, DEFAULT_LOCALE);\n        DATE_FORMAT_ISO8601.setTimeZone(DEFAULT_TIMEZONE);\n    }\n\n    \n    public final static StdDateFormat instance = new StdDateFormat(); protected static final Calendar CALENDAR = new GregorianCalendar(DEFAULT_TIMEZONE, DEFAULT_LOCALE); protected transient TimeZone _timezone; protected final Locale _locale; protected Boolean _lenient; private transient Calendar _calendar; private transient DateFormat _formatRFC1123; private boolean _tzSerializedWithColon = false; public StdDateFormat() {\n        _locale = DEFAULT_LOCALE;\n    }\n\n    @Deprecated \n    public StdDateFormat(TimeZone tz, Locale loc) {\n        _timezone = tz;\n        _locale = loc;\n    }\n\n    protected StdDateFormat(TimeZone tz, Locale loc, Boolean lenient) {\n        this(tz, loc, lenient, false);\n    }\n\n    \n    protected StdDateFormat(TimeZone tz, Locale loc, Boolean lenient, boolean formatTzOffsetWithColon) {\n        _timezone = tz;\n        _locale = loc;\n        _lenient = lenient;\n        _tzSerializedWithColon = formatTzOffsetWithColon;\n    }\n    \n    public static TimeZone getDefaultTimeZone() {\n        return DEFAULT_TIMEZONE;\n    }\n    \n    \n    public StdDateFormat withTimeZone(TimeZone tz) {\n        if (tz == null) {\n            tz = DEFAULT_TIMEZONE;\n        }\n        if ((tz == _timezone) || tz.equals(_timezone)) {\n            return this;\n        }\n        return new StdDateFormat(tz, _locale, _lenient, _tzSerializedWithColon);\n    }\n\n    \n    public StdDateFormat withLocale(Locale loc) {\n        if (loc.equals(_locale)) {\n            return this;\n        }\n        return new StdDateFormat(_timezone, loc, _lenient, _tzSerializedWithColon);\n    }\n\n    \n    public StdDateFormat withLenient(Boolean b) {\n        if (_equals(b, _lenient)) {\n            return this;\n        }\n        return new StdDateFormat(_timezone, _locale, b, _tzSerializedWithColon);\n    }\n\n    \n    public StdDateFormat withColonInTimeZone(boolean b) {\n        if (_tzSerializedWithColon == b) {\n            return this;\n        }\n        return new StdDateFormat(_timezone, _locale, _lenient, b);\n     }\n    \n    @Override\n    public StdDateFormat clone() {\n        \n        \n        return new StdDateFormat(_timezone, _locale, _lenient, _tzSerializedWithColon);\n    }\n\n    \n    @Deprecated \n    public static DateFormat getISO8601Format(TimeZone tz, Locale loc) {\n        return _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, tz, loc, null);\n    }\n\n    \n    @Deprecated \n    public static DateFormat getRFC1123Format(TimeZone tz, Locale loc) {\n        return _cloneFormat(DATE_FORMAT_RFC1123, DATE_FORMAT_STR_RFC1123,\n                tz, loc, null);\n    }\n\n    \n\n    @Override \n    public TimeZone getTimeZone() {\n        return _timezone;\n    }\n\n    @Override\n    public void setTimeZone(TimeZone tz) {\n        \n        if (!tz.equals(_timezone)) {\n            _clearFormats();\n            _timezone = tz;\n        }\n    }\n\n    \n    @Override \n    public void setLenient(boolean enabled) {\n        Boolean newValue = Boolean.valueOf(enabled);\n        if (!_equals(newValue, _lenient)) {\n            _lenient = newValue;\n            \n            _clearFormats();\n        }\n    }\n\n    @Override \n    public boolean isLenient() {\n        \n        return (_lenient == null) || _lenient.booleanValue();\n    }\n\n    \n    public boolean isColonIncludedInTimeZone() {\n        return _tzSerializedWithColon;\n    }\n\n    \n\n    @Override\n    public Date parse(String dateStr) throws ParseException {\n        dateStr = dateStr.trim();\n        ParsePosition pos = new ParsePosition(0);\n        Date dt = _parseDate(dateStr, pos);\n        if (dt != null) {\n            return dt;\n        }\n        StringBuilder sb = new StringBuilder();\n        for (String f : ALL_FORMATS) {\n            if (sb.length() > 0) {\n                sb.append(\"\\\", \\\"\");\n            } else {\n                sb.append('\"');\n            }\n            sb.append(f);\n        }\n        sb.append('\"');\n        throw new ParseException\n            (String.format(\"Cannot parse date \\\"%s\\\": not compatible with any of standard forms (%s)\",\n                           dateStr, sb.toString()), pos.getErrorIndex());\n    }\n\n    \n    @Override\n    public Date parse(String dateStr, ParsePosition pos) {\n        try {\n            return _parseDate(dateStr, pos);\n        } catch (ParseException e) {\n            \n        }\n        return null;\n    }\n\n    protected Date _parseDate(String dateStr, ParsePosition pos) throws ParseException {\n        if (looksLikeISO8601(dateStr)) { \n            return parseAsISO8601(dateStr, pos);\n        }\n        \n        int i = dateStr.length();\n        while (--i >= 0) {\n            char ch = dateStr.charAt(i);\n            if (ch < '0' || ch > '9') {\n                \n                if (i > 0 || ch != '-') {\n                    break;\n                }\n            }\n        }\n        if ((i < 0)\n            \n                && (dateStr.charAt(0) == '-' || NumberInput.inLongRange(dateStr, false))) {\n            return _parseDateFromLong(dateStr, pos);\n        }\n        \n        return parseAsRFC1123(dateStr, pos);\n    }\n\n    \n    \n    @Override\n    public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition) {\n        TimeZone tz = _timezone;\n        if (tz == null) {\n            tz = DEFAULT_TIMEZONE;\n        }\n        _format(tz, _locale, date, toAppendTo);\n        return toAppendTo;\n    }\n    \n    protected void _format(TimeZone tz, Locale loc, Date date, StringBuffer buffer) {\n        Calendar cal = _getCalendar(tz);\n        cal.setTime(date);\n        \n        final int year = cal.get(Calendar.YEAR);\n\n        \n                \n                \n                \n                \n                \n            pad4(buffer, year);\n        buffer.append('-');\n        pad2(buffer, cal.get(Calendar.MONTH) + 1);\n        buffer.append('-');\n        pad2(buffer, cal.get(Calendar.DAY_OF_MONTH));\n        buffer.append('T');\n        pad2(buffer, cal.get(Calendar.HOUR_OF_DAY));\n        buffer.append(':');\n        pad2(buffer, cal.get(Calendar.MINUTE));\n        buffer.append(':');\n        pad2(buffer, cal.get(Calendar.SECOND));\n        buffer.append('.');\n        pad3(buffer, cal.get(Calendar.MILLISECOND));\n\n        int offset = tz.getOffset(cal.getTimeInMillis());\n        if (offset != 0) {\n            int hours = Math.abs((offset / (60 * 1000)) / 60);\n            int minutes = Math.abs((offset / (60 * 1000)) % 60);\n            buffer.append(offset < 0 ? '-' : '+');\n            pad2(buffer, hours);\n            if( _tzSerializedWithColon ) {\n            \t\tbuffer.append(':');\n            }\n            pad2(buffer, minutes);\n        } else {\n            \n            \n\n\t        \tif( _tzSerializedWithColon ) {\n\t            buffer.append(\"+00:00\");\n\t        \t}\n\t        \telse {\n\t        \t\tbuffer.append(\"+0000\");\n\t        \t}\n        }\n    }\n\n        \n        \n        \n        \n        \n\n    private static void pad2(StringBuffer buffer, int value) {\n        int tens = value / 10;\n        if (tens == 0) {\n            buffer.append('0');\n        } else {\n            buffer.append((char) ('0' + tens));\n            value -= 10 * tens;\n        }\n        buffer.append((char) ('0' + value));\n    }\n\n    private static void pad3(StringBuffer buffer, int value) {\n        int h = value / 100;\n        if (h == 0) {\n            buffer.append('0');\n        } else {\n            buffer.append((char) ('0' + h));\n            value -= (h * 100);\n        }\n        pad2(buffer, value);\n    }\n\n    private static void pad4(StringBuffer buffer, int value) {\n        int h = value / 100;\n        if (h == 0) {\n            buffer.append('0').append('0');\n        } else {\n                pad2(buffer, h);\n            value -= (100 * h);\n        }\n        pad2(buffer, value);\n    }\n    \n    \n\n    @Override\n    public String toString() {\n        return String.format(\"DateFormat %s: (timezone: %s, locale: %s, lenient: %s)\",\n                getClass().getName(), _timezone, _locale, _lenient);\n    }\n\n    public String toPattern() { \n        StringBuilder sb = new StringBuilder(100);\n        sb.append(\"[one of: '\")\n            .append(DATE_FORMAT_STR_ISO8601)\n            .append(\"', '\")\n            .append(DATE_FORMAT_STR_RFC1123)\n            .append(\"' (\")\n            ;\n        sb.append(Boolean.FALSE.equals(_lenient) ?\n                \"strict\" : \"lenient\")\n            .append(\")]\");\n        return sb.toString();\n    }\n\n    @Override \n    public boolean equals(Object o) {\n        return (o == this);\n    }\n\n    @Override \n    public int hashCode() {\n        return System.identityHashCode(this);\n    }\n\n    \n\n    \n    protected boolean looksLikeISO8601(String dateStr) {\n        if (dateStr.length() >= 7 \n            && Character.isDigit(dateStr.charAt(0))\n            && Character.isDigit(dateStr.charAt(3))\n            && dateStr.charAt(4) == '-'\n            && Character.isDigit(dateStr.charAt(5))\n            ) {\n            return true;\n        }\n        return false;\n    }\n\n    private Date _parseDateFromLong(String longStr, ParsePosition pos) throws ParseException {\n        long ts;\n        try {\n            ts = NumberInput.parseLong(longStr);\n        } catch (NumberFormatException e) {\n            throw new ParseException(String.format(\n                    \"Timestamp value %s out of 64-bit value range\", longStr),\n                    pos.getErrorIndex());\n        }\n        return new Date(ts);\n    }\n\n    protected Date parseAsISO8601(String dateStr, ParsePosition pos) throws ParseException {\n        try {\n            return _parseAsISO8601(dateStr, pos);\n        } catch (IllegalArgumentException e) {\n            throw new ParseException(String.format(\"Cannot parse date \\\"%s\\\", problem: %s\",\n                    dateStr, e.getMessage()),\n                    pos.getErrorIndex());\n        }\n    }\n\n    protected Date _parseAsISO8601(String dateStr, ParsePosition bogus) throws IllegalArgumentException, ParseException {\n        final int totalLen = dateStr.length();\n        \n        TimeZone tz = DEFAULT_TIMEZONE;\n        if ((_timezone != null) && ('Z' != dateStr.charAt(totalLen-1))) {\n            tz = _timezone;\n        }\n        Calendar cal = _getCalendar(tz);\n        cal.clear();\n        String formatStr;\n        if (totalLen <= 10) {\n            Matcher m = PATTERN_PLAIN.matcher(dateStr);\n            if (m.matches()) {\n                int year = _parse4D(dateStr, 0);\n                int month = _parse2D(dateStr, 5)-1;\n                int day = _parse2D(dateStr, 8);\n\n                cal.set(year, month, day, 0, 0, 0);\n                cal.set(Calendar.MILLISECOND, 0);\n                return cal.getTime();\n            }\n            formatStr = DATE_FORMAT_STR_PLAIN;\n        } else {\n            Matcher m = PATTERN_ISO8601.matcher(dateStr);\n            if (m.matches()) {\n                \n                \n                int start = m.start(2);\n                int end = m.end(2);\n                int len = end-start;\n                if (len > 1) { \n                    \n                    int offsetSecs = _parse2D(dateStr, start+1) * 3600; \n                    if (len >= 5) {\n                        offsetSecs += _parse2D(dateStr, end-2) * 60; \n                    }\n                    if (dateStr.charAt(start) == '-') {\n                        offsetSecs *= -1000;\n                    } else {\n                        offsetSecs *= 1000;\n                    }\n                    cal.set(Calendar.ZONE_OFFSET, offsetSecs);\n                    \n                    cal.set(Calendar.DST_OFFSET, 0);\n                }\n                \n                int year = _parse4D(dateStr, 0);\n                int month = _parse2D(dateStr, 5)-1;\n                int day = _parse2D(dateStr, 8);\n\n                \n                int hour = _parse2D(dateStr, 11);\n                int minute = _parse2D(dateStr, 14);\n\n                \n                int seconds;\n                if ((totalLen > 16) && dateStr.charAt(16) == ':') {\n                    seconds = _parse2D(dateStr, 17);\n                } else {\n                    seconds = 0;\n                }\n                cal.set(year, month, day, hour, minute, seconds);\n\n                \n                start = m.start(1) + 1;\n                end = m.end(1);\n                int msecs = 0;\n                if (start >= end) { \n                    cal.set(Calendar.MILLISECOND, 0);\n                } else {\n                    \n                    msecs = 0;\n                    final int fractLen = end-start;\n                    switch (fractLen) {\n                    default: \n\n                        if (fractLen > 9) { \n                            throw new ParseException(String.format(\n\"Cannot parse date \\\"%s\\\": invalid fractional seconds '%s'; can use at most 9 digits\",\n                                       dateStr, m.group(1).substring(1)\n                                       ), start);\n                        }\n                        \n                    case 3:\n                        msecs += (dateStr.charAt(start+2) - '0');\n                    case 2:\n                        msecs += 10 * (dateStr.charAt(start+1) - '0');\n                    case 1:\n                        msecs += 100 * (dateStr.charAt(start) - '0');\n                        break;\n                    case 0:\n                        break;\n                    }\n                    cal.set(Calendar.MILLISECOND, msecs);\n                }\n                return cal.getTime();\n            }\n            formatStr = DATE_FORMAT_STR_ISO8601;\n        }\n\n        throw new ParseException\n        (String.format(\"Cannot parse date \\\"%s\\\": while it seems to fit format '%s', parsing fails (leniency? %s)\",\n                       dateStr, formatStr, _lenient),\n                \n                \n                0);\n    }\n\n    private static int _parse4D(String str, int index) {\n        return (1000 * (str.charAt(index) - '0'))\n                + (100 * (str.charAt(index+1) - '0'))\n                + (10 * (str.charAt(index+2) - '0'))\n                + (str.charAt(index+3) - '0');\n    }\n\n    private static int _parse2D(String str, int index) {\n        return (10 * (str.charAt(index) - '0'))\n                + (str.charAt(index+1) - '0');\n    }\n\n    protected Date parseAsRFC1123(String dateStr, ParsePosition pos) {\n        if (_formatRFC1123 == null) {\n            _formatRFC1123 = _cloneFormat(DATE_FORMAT_RFC1123, DATE_FORMAT_STR_RFC1123,\n                    _timezone, _locale, _lenient);\n        }\n        return _formatRFC1123.parse(dateStr, pos);\n    }\n\n    \n\n    private final static DateFormat _cloneFormat(DateFormat df, String format, TimeZone tz, Locale loc, Boolean lenient) {\n        if (!loc.equals(DEFAULT_LOCALE)) {\n            df = new SimpleDateFormat(format, loc);\n            df.setTimeZone((tz == null) ? DEFAULT_TIMEZONE : tz);\n        } else {\n            df = (DateFormat) df.clone();\n            if (tz != null) {\n                df.setTimeZone(tz);\n            }\n        }\n        if (lenient != null) {\n            df.setLenient(lenient.booleanValue());\n        }\n        return df;\n    }\n\n    protected void _clearFormats() {\n        _formatRFC1123 = null;\n    }\n\n    protected Calendar _getCalendar(TimeZone tz) {\n        Calendar cal = _calendar;\n        if (cal == null ) {\n            _calendar = cal = (Calendar)CALENDAR.clone();\n        }\n        if (!cal.getTimeZone().equals(tz) ) {\n            cal.setTimeZone(tz);\n        }\n        cal.setLenient(isLenient());\n        return cal;\n    }\n    \n    protected static <T> boolean _equals(T value1, T value2) {\n        if (value1 == value2) {\n            return true;\n        }\n        return (value1 != null) && value1.equals(value2);\n    }\n}\n",
      "fixed_full_code": "package com.fasterxml.jackson.databind.util;\n\nimport java.text.DateFormat;\nimport java.text.FieldPosition;\nimport java.text.ParseException;\nimport java.text.ParsePosition;\nimport java.text.SimpleDateFormat;\nimport java.util.*;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport com.fasterxml.jackson.core.io.NumberInput;\n\n\n@SuppressWarnings(\"serial\")\npublic class StdDateFormat extends DateFormat { protected final static String PATTERN_PLAIN_STR = \"\\\\d\\\\d\\\\d\\\\d[-]\\\\d\\\\d[-]\\\\d\\\\d\"; protected final static Pattern PATTERN_PLAIN = Pattern.compile(PATTERN_PLAIN_STR); protected final static Pattern PATTERN_ISO8601; static {\n        Pattern p = null;\n        try {\n            p = Pattern.compile(PATTERN_PLAIN_STR\n                    +\"[T]\\\\d\\\\d[:]\\\\d\\\\d(?:[:]\\\\d\\\\d)?\" \n                    +\"(\\\\.\\\\d+)?\" \n                    +\"(Z|[+-]\\\\d\\\\d(?:[:]?\\\\d\\\\d)?)?\" \n            );\n        } catch (Throwable t) {\n            throw new RuntimeException(t);\n        }\n        PATTERN_ISO8601 = p;\n    }\n\n    \n    public final static String DATE_FORMAT_STR_ISO8601 = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\"; protected final static String DATE_FORMAT_STR_PLAIN = \"yyyy-MM-dd\"; protected final static String DATE_FORMAT_STR_RFC1123 = \"EEE, dd MMM yyyy HH:mm:ss zzz\"; protected final static String[] ALL_FORMATS = new String[] { DATE_FORMAT_STR_ISO8601, \"yyyy-MM-dd'T'HH:mm:ss.SSS\", DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }; protected final static TimeZone DEFAULT_TIMEZONE; static { DEFAULT_TIMEZONE = TimeZone.getTimeZone(\"UTC\"); } protected final static Locale DEFAULT_LOCALE = Locale.US; protected final static DateFormat DATE_FORMAT_RFC1123; protected final static DateFormat DATE_FORMAT_ISO8601; static {\n        \n        \n        DATE_FORMAT_RFC1123 = new SimpleDateFormat(DATE_FORMAT_STR_RFC1123, DEFAULT_LOCALE);\n        DATE_FORMAT_RFC1123.setTimeZone(DEFAULT_TIMEZONE);\n        DATE_FORMAT_ISO8601 = new SimpleDateFormat(DATE_FORMAT_STR_ISO8601, DEFAULT_LOCALE);\n        DATE_FORMAT_ISO8601.setTimeZone(DEFAULT_TIMEZONE);\n    }\n\n    \n    public final static StdDateFormat instance = new StdDateFormat(); protected static final Calendar CALENDAR = new GregorianCalendar(DEFAULT_TIMEZONE, DEFAULT_LOCALE); protected transient TimeZone _timezone; protected final Locale _locale; protected Boolean _lenient; private transient Calendar _calendar; private transient DateFormat _formatRFC1123; private boolean _tzSerializedWithColon = false; public StdDateFormat() {\n        _locale = DEFAULT_LOCALE;\n    }\n\n    @Deprecated \n    public StdDateFormat(TimeZone tz, Locale loc) {\n        _timezone = tz;\n        _locale = loc;\n    }\n\n    protected StdDateFormat(TimeZone tz, Locale loc, Boolean lenient) {\n        this(tz, loc, lenient, false);\n    }\n\n    \n    protected StdDateFormat(TimeZone tz, Locale loc, Boolean lenient, boolean formatTzOffsetWithColon) {\n        _timezone = tz;\n        _locale = loc;\n        _lenient = lenient;\n        _tzSerializedWithColon = formatTzOffsetWithColon;\n    }\n    \n    public static TimeZone getDefaultTimeZone() {\n        return DEFAULT_TIMEZONE;\n    }\n    \n    \n    public StdDateFormat withTimeZone(TimeZone tz) {\n        if (tz == null) {\n            tz = DEFAULT_TIMEZONE;\n        }\n        if ((tz == _timezone) || tz.equals(_timezone)) {\n            return this;\n        }\n        return new StdDateFormat(tz, _locale, _lenient, _tzSerializedWithColon);\n    }\n\n    \n    public StdDateFormat withLocale(Locale loc) {\n        if (loc.equals(_locale)) {\n            return this;\n        }\n        return new StdDateFormat(_timezone, loc, _lenient, _tzSerializedWithColon);\n    }\n\n    \n    public StdDateFormat withLenient(Boolean b) {\n        if (_equals(b, _lenient)) {\n            return this;\n        }\n        return new StdDateFormat(_timezone, _locale, b, _tzSerializedWithColon);\n    }\n\n    \n    public StdDateFormat withColonInTimeZone(boolean b) {\n        if (_tzSerializedWithColon == b) {\n            return this;\n        }\n        return new StdDateFormat(_timezone, _locale, _lenient, b);\n     }\n    \n    @Override\n    public StdDateFormat clone() {\n        \n        \n        return new StdDateFormat(_timezone, _locale, _lenient, _tzSerializedWithColon);\n    }\n\n    \n    @Deprecated \n    public static DateFormat getISO8601Format(TimeZone tz, Locale loc) {\n        return _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, tz, loc, null);\n    }\n\n    \n    @Deprecated \n    public static DateFormat getRFC1123Format(TimeZone tz, Locale loc) {\n        return _cloneFormat(DATE_FORMAT_RFC1123, DATE_FORMAT_STR_RFC1123,\n                tz, loc, null);\n    }\n\n    \n\n    @Override \n    public TimeZone getTimeZone() {\n        return _timezone;\n    }\n\n    @Override\n    public void setTimeZone(TimeZone tz) {\n        \n        if (!tz.equals(_timezone)) {\n            _clearFormats();\n            _timezone = tz;\n        }\n    }\n\n    \n    @Override \n    public void setLenient(boolean enabled) {\n        Boolean newValue = Boolean.valueOf(enabled);\n        if (!_equals(newValue, _lenient)) {\n            _lenient = newValue;\n            \n            _clearFormats();\n        }\n    }\n\n    @Override \n    public boolean isLenient() {\n        \n        return (_lenient == null) || _lenient.booleanValue();\n    }\n\n    \n    public boolean isColonIncludedInTimeZone() {\n        return _tzSerializedWithColon;\n    }\n\n    \n\n    @Override\n    public Date parse(String dateStr) throws ParseException {\n        dateStr = dateStr.trim();\n        ParsePosition pos = new ParsePosition(0);\n        Date dt = _parseDate(dateStr, pos);\n        if (dt != null) {\n            return dt;\n        }\n        StringBuilder sb = new StringBuilder();\n        for (String f : ALL_FORMATS) {\n            if (sb.length() > 0) {\n                sb.append(\"\\\", \\\"\");\n            } else {\n                sb.append('\"');\n            }\n            sb.append(f);\n        }\n        sb.append('\"');\n        throw new ParseException\n            (String.format(\"Cannot parse date \\\"%s\\\": not compatible with any of standard forms (%s)\",\n                           dateStr, sb.toString()), pos.getErrorIndex());\n    }\n\n    \n    @Override\n    public Date parse(String dateStr, ParsePosition pos) {\n        try {\n            return _parseDate(dateStr, pos);\n        } catch (ParseException e) {\n            \n        }\n        return null;\n    }\n\n    protected Date _parseDate(String dateStr, ParsePosition pos) throws ParseException {\n        if (looksLikeISO8601(dateStr)) { \n            return parseAsISO8601(dateStr, pos);\n        }\n        \n        int i = dateStr.length();\n        while (--i >= 0) {\n            char ch = dateStr.charAt(i);\n            if (ch < '0' || ch > '9') {\n                \n                if (i > 0 || ch != '-') {\n                    break;\n                }\n            }\n        }\n        if ((i < 0)\n            \n                && (dateStr.charAt(0) == '-' || NumberInput.inLongRange(dateStr, false))) {\n            return _parseDateFromLong(dateStr, pos);\n        }\n        \n        return parseAsRFC1123(dateStr, pos);\n    }\n\n    \n    \n    @Override\n    public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition) {\n        TimeZone tz = _timezone;\n        if (tz == null) {\n            tz = DEFAULT_TIMEZONE;\n        }\n        _format(tz, _locale, date, toAppendTo);\n        return toAppendTo;\n    }\n    \n    protected void _format(TimeZone tz, Locale loc, Date date, StringBuffer buffer) {\n        Calendar cal = _getCalendar(tz);\n        cal.setTime(date);\n        \n        final int year = cal.get(Calendar.YEAR);\n\n        \n        if (cal.get(Calendar.ERA) == GregorianCalendar.BC) {\n            _formatBCEYear(buffer, year);\n        } else {\n            if (year > 9999) {\n                \n                \n                \n                \n                \n                buffer.append('+');\n            }\n            pad4(buffer, year);\n        }\n        buffer.append('-');\n        pad2(buffer, cal.get(Calendar.MONTH) + 1);\n        buffer.append('-');\n        pad2(buffer, cal.get(Calendar.DAY_OF_MONTH));\n        buffer.append('T');\n        pad2(buffer, cal.get(Calendar.HOUR_OF_DAY));\n        buffer.append(':');\n        pad2(buffer, cal.get(Calendar.MINUTE));\n        buffer.append(':');\n        pad2(buffer, cal.get(Calendar.SECOND));\n        buffer.append('.');\n        pad3(buffer, cal.get(Calendar.MILLISECOND));\n\n        int offset = tz.getOffset(cal.getTimeInMillis());\n        if (offset != 0) {\n            int hours = Math.abs((offset / (60 * 1000)) / 60);\n            int minutes = Math.abs((offset / (60 * 1000)) % 60);\n            buffer.append(offset < 0 ? '-' : '+');\n            pad2(buffer, hours);\n            if( _tzSerializedWithColon ) {\n            \t\tbuffer.append(':');\n            }\n            pad2(buffer, minutes);\n        } else {\n            \n            \n\n\t        \tif( _tzSerializedWithColon ) {\n\t            buffer.append(\"+00:00\");\n\t        \t}\n\t        \telse {\n\t        \t\tbuffer.append(\"+0000\");\n\t        \t}\n        }\n    }\n\n    protected void _formatBCEYear(StringBuffer buffer, int bceYearNoSign) {\n        \n        \n        if (bceYearNoSign == 1) {\n            buffer.append(\"+0000\");\n            return;\n        }\n        final int isoYear = bceYearNoSign - 1;\n        buffer.append('-');\n        \n        \n        \n        pad4(buffer, isoYear);\n    }\n\n    private static void pad2(StringBuffer buffer, int value) {\n        int tens = value / 10;\n        if (tens == 0) {\n            buffer.append('0');\n        } else {\n            buffer.append((char) ('0' + tens));\n            value -= 10 * tens;\n        }\n        buffer.append((char) ('0' + value));\n    }\n\n    private static void pad3(StringBuffer buffer, int value) {\n        int h = value / 100;\n        if (h == 0) {\n            buffer.append('0');\n        } else {\n            buffer.append((char) ('0' + h));\n            value -= (h * 100);\n        }\n        pad2(buffer, value);\n    }\n\n    private static void pad4(StringBuffer buffer, int value) {\n        int h = value / 100;\n        if (h == 0) {\n            buffer.append('0').append('0');\n        } else {\n            if (h > 99) { \n                buffer.append(h);\n            } else {\n                pad2(buffer, h);\n            }\n            value -= (100 * h);\n        }\n        pad2(buffer, value);\n    }\n    \n    \n\n    @Override\n    public String toString() {\n        return String.format(\"DateFormat %s: (timezone: %s, locale: %s, lenient: %s)\",\n                getClass().getName(), _timezone, _locale, _lenient);\n    }\n\n    public String toPattern() { \n        StringBuilder sb = new StringBuilder(100);\n        sb.append(\"[one of: '\")\n            .append(DATE_FORMAT_STR_ISO8601)\n            .append(\"', '\")\n            .append(DATE_FORMAT_STR_RFC1123)\n            .append(\"' (\")\n            ;\n        sb.append(Boolean.FALSE.equals(_lenient) ?\n                \"strict\" : \"lenient\")\n            .append(\")]\");\n        return sb.toString();\n    }\n\n    @Override \n    public boolean equals(Object o) {\n        return (o == this);\n    }\n\n    @Override \n    public int hashCode() {\n        return System.identityHashCode(this);\n    }\n\n    \n\n    \n    protected boolean looksLikeISO8601(String dateStr) {\n        if (dateStr.length() >= 7 \n            && Character.isDigit(dateStr.charAt(0))\n            && Character.isDigit(dateStr.charAt(3))\n            && dateStr.charAt(4) == '-'\n            && Character.isDigit(dateStr.charAt(5))\n            ) {\n            return true;\n        }\n        return false;\n    }\n\n    private Date _parseDateFromLong(String longStr, ParsePosition pos) throws ParseException {\n        long ts;\n        try {\n            ts = NumberInput.parseLong(longStr);\n        } catch (NumberFormatException e) {\n            throw new ParseException(String.format(\n                    \"Timestamp value %s out of 64-bit value range\", longStr),\n                    pos.getErrorIndex());\n        }\n        return new Date(ts);\n    }\n\n    protected Date parseAsISO8601(String dateStr, ParsePosition pos) throws ParseException {\n        try {\n            return _parseAsISO8601(dateStr, pos);\n        } catch (IllegalArgumentException e) {\n            throw new ParseException(String.format(\"Cannot parse date \\\"%s\\\", problem: %s\",\n                    dateStr, e.getMessage()),\n                    pos.getErrorIndex());\n        }\n    }\n\n    protected Date _parseAsISO8601(String dateStr, ParsePosition bogus) throws IllegalArgumentException, ParseException {\n        final int totalLen = dateStr.length();\n        \n        TimeZone tz = DEFAULT_TIMEZONE;\n        if ((_timezone != null) && ('Z' != dateStr.charAt(totalLen-1))) {\n            tz = _timezone;\n        }\n        Calendar cal = _getCalendar(tz);\n        cal.clear();\n        String formatStr;\n        if (totalLen <= 10) {\n            Matcher m = PATTERN_PLAIN.matcher(dateStr);\n            if (m.matches()) {\n                int year = _parse4D(dateStr, 0);\n                int month = _parse2D(dateStr, 5)-1;\n                int day = _parse2D(dateStr, 8);\n\n                cal.set(year, month, day, 0, 0, 0);\n                cal.set(Calendar.MILLISECOND, 0);\n                return cal.getTime();\n            }\n            formatStr = DATE_FORMAT_STR_PLAIN;\n        } else {\n            Matcher m = PATTERN_ISO8601.matcher(dateStr);\n            if (m.matches()) {\n                \n                \n                int start = m.start(2);\n                int end = m.end(2);\n                int len = end-start;\n                if (len > 1) { \n                    \n                    int offsetSecs = _parse2D(dateStr, start+1) * 3600; \n                    if (len >= 5) {\n                        offsetSecs += _parse2D(dateStr, end-2) * 60; \n                    }\n                    if (dateStr.charAt(start) == '-') {\n                        offsetSecs *= -1000;\n                    } else {\n                        offsetSecs *= 1000;\n                    }\n                    cal.set(Calendar.ZONE_OFFSET, offsetSecs);\n                    \n                    cal.set(Calendar.DST_OFFSET, 0);\n                }\n                \n                int year = _parse4D(dateStr, 0);\n                int month = _parse2D(dateStr, 5)-1;\n                int day = _parse2D(dateStr, 8);\n\n                \n                int hour = _parse2D(dateStr, 11);\n                int minute = _parse2D(dateStr, 14);\n\n                \n                int seconds;\n                if ((totalLen > 16) && dateStr.charAt(16) == ':') {\n                    seconds = _parse2D(dateStr, 17);\n                } else {\n                    seconds = 0;\n                }\n                cal.set(year, month, day, hour, minute, seconds);\n\n                \n                start = m.start(1) + 1;\n                end = m.end(1);\n                int msecs = 0;\n                if (start >= end) { \n                    cal.set(Calendar.MILLISECOND, 0);\n                } else {\n                    \n                    msecs = 0;\n                    final int fractLen = end-start;\n                    switch (fractLen) {\n                    default: \n\n                        if (fractLen > 9) { \n                            throw new ParseException(String.format(\n\"Cannot parse date \\\"%s\\\": invalid fractional seconds '%s'; can use at most 9 digits\",\n                                       dateStr, m.group(1).substring(1)\n                                       ), start);\n                        }\n                        \n                    case 3:\n                        msecs += (dateStr.charAt(start+2) - '0');\n                    case 2:\n                        msecs += 10 * (dateStr.charAt(start+1) - '0');\n                    case 1:\n                        msecs += 100 * (dateStr.charAt(start) - '0');\n                        break;\n                    case 0:\n                        break;\n                    }\n                    cal.set(Calendar.MILLISECOND, msecs);\n                }\n                return cal.getTime();\n            }\n            formatStr = DATE_FORMAT_STR_ISO8601;\n        }\n\n        throw new ParseException\n        (String.format(\"Cannot parse date \\\"%s\\\": while it seems to fit format '%s', parsing fails (leniency? %s)\",\n                       dateStr, formatStr, _lenient),\n                \n                \n                0);\n    }\n\n    private static int _parse4D(String str, int index) {\n        return (1000 * (str.charAt(index) - '0'))\n                + (100 * (str.charAt(index+1) - '0'))\n                + (10 * (str.charAt(index+2) - '0'))\n                + (str.charAt(index+3) - '0');\n    }\n\n    private static int _parse2D(String str, int index) {\n        return (10 * (str.charAt(index) - '0'))\n                + (str.charAt(index+1) - '0');\n    }\n\n    protected Date parseAsRFC1123(String dateStr, ParsePosition pos) {\n        if (_formatRFC1123 == null) {\n            _formatRFC1123 = _cloneFormat(DATE_FORMAT_RFC1123, DATE_FORMAT_STR_RFC1123,\n                    _timezone, _locale, _lenient);\n        }\n        return _formatRFC1123.parse(dateStr, pos);\n    }\n\n    \n\n    private final static DateFormat _cloneFormat(DateFormat df, String format, TimeZone tz, Locale loc, Boolean lenient) {\n        if (!loc.equals(DEFAULT_LOCALE)) {\n            df = new SimpleDateFormat(format, loc);\n            df.setTimeZone((tz == null) ? DEFAULT_TIMEZONE : tz);\n        } else {\n            df = (DateFormat) df.clone();\n            if (tz != null) {\n                df.setTimeZone(tz);\n            }\n        }\n        if (lenient != null) {\n            df.setLenient(lenient.booleanValue());\n        }\n        return df;\n    }\n\n    protected void _clearFormats() {\n        _formatRFC1123 = null;\n    }\n\n    protected Calendar _getCalendar(TimeZone tz) {\n        Calendar cal = _calendar;\n        if (cal == null ) {\n            _calendar = cal = (Calendar)CALENDAR.clone();\n        }\n        if (!cal.getTimeZone().equals(tz) ) {\n            cal.setTimeZone(tz);\n        }\n        cal.setLenient(isLenient());\n        return cal;\n    }\n    \n    protected static <T> boolean _equals(T value1, T value2) {\n        if (value1 == value2) {\n            return true;\n        }\n        return (value1 != null) && value1.equals(value2);\n    }\n}\n",
      "buggy_signatures": [
        "public StdDateFormat(TimeZone tz, Locale loc)",
        "protected StdDateFormat(TimeZone tz, Locale loc, Boolean lenient)",
        "protected StdDateFormat(TimeZone tz, Locale loc, Boolean lenient, boolean formatTzOffsetWithColon)",
        "public static TimeZone getDefaultTimeZone()",
        "public StdDateFormat withTimeZone(TimeZone tz)",
        "public StdDateFormat withLocale(Locale loc)",
        "public StdDateFormat withLenient(Boolean b)",
        "public StdDateFormat withColonInTimeZone(boolean b)",
        "public StdDateFormat clone()",
        "public static DateFormat getISO8601Format(TimeZone tz, Locale loc)",
        "public static DateFormat getRFC1123Format(TimeZone tz, Locale loc)",
        "public TimeZone getTimeZone()",
        "public void setTimeZone(TimeZone tz)",
        "public void setLenient(boolean enabled)",
        "public boolean isLenient()",
        "public boolean isColonIncludedInTimeZone()",
        "public Date parse(String dateStr) throws ParseException",
        "public Date parse(String dateStr, ParsePosition pos)",
        "protected Date _parseDate(String dateStr, ParsePosition pos) throws ParseException",
        "public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition)",
        "protected void _format(TimeZone tz, Locale loc, Date date, StringBuffer buffer)",
        "private static void pad2(StringBuffer buffer, int value)",
        "private static void pad3(StringBuffer buffer, int value)",
        "private static void pad4(StringBuffer buffer, int value)",
        "public String toString()",
        "public String toPattern()",
        "public boolean equals(Object o)",
        "public int hashCode()",
        "protected boolean looksLikeISO8601(String dateStr)",
        "private Date _parseDateFromLong(String longStr, ParsePosition pos) throws ParseException",
        "protected Date parseAsISO8601(String dateStr, ParsePosition pos) throws ParseException",
        "protected Date _parseAsISO8601(String dateStr, ParsePosition bogus) throws IllegalArgumentException, ParseException",
        "private static int _parse4D(String str, int index)",
        "private static int _parse2D(String str, int index)",
        "protected Date parseAsRFC1123(String dateStr, ParsePosition pos)",
        "private final static DateFormat _cloneFormat(DateFormat df, String format, TimeZone tz, Locale loc, Boolean lenient)",
        "protected void _clearFormats()",
        "protected Calendar _getCalendar(TimeZone tz)",
        "protected static <T> boolean _equals(T value1, T value2)"
      ],
      "fixed_signatures": [
        "public StdDateFormat(TimeZone tz, Locale loc)",
        "protected StdDateFormat(TimeZone tz, Locale loc, Boolean lenient)",
        "protected StdDateFormat(TimeZone tz, Locale loc, Boolean lenient, boolean formatTzOffsetWithColon)",
        "public static TimeZone getDefaultTimeZone()",
        "public StdDateFormat withTimeZone(TimeZone tz)",
        "public StdDateFormat withLocale(Locale loc)",
        "public StdDateFormat withLenient(Boolean b)",
        "public StdDateFormat withColonInTimeZone(boolean b)",
        "public StdDateFormat clone()",
        "public static DateFormat getISO8601Format(TimeZone tz, Locale loc)",
        "public static DateFormat getRFC1123Format(TimeZone tz, Locale loc)",
        "public TimeZone getTimeZone()",
        "public void setTimeZone(TimeZone tz)",
        "public void setLenient(boolean enabled)",
        "public boolean isLenient()",
        "public boolean isColonIncludedInTimeZone()",
        "public Date parse(String dateStr) throws ParseException",
        "public Date parse(String dateStr, ParsePosition pos)",
        "protected Date _parseDate(String dateStr, ParsePosition pos) throws ParseException",
        "public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition)",
        "protected void _format(TimeZone tz, Locale loc, Date date, StringBuffer buffer)",
        "protected void _formatBCEYear(StringBuffer buffer, int bceYearNoSign)",
        "private static void pad2(StringBuffer buffer, int value)",
        "private static void pad3(StringBuffer buffer, int value)",
        "private static void pad4(StringBuffer buffer, int value)",
        "public String toString()",
        "public String toPattern()",
        "public boolean equals(Object o)",
        "public int hashCode()",
        "protected boolean looksLikeISO8601(String dateStr)",
        "private Date _parseDateFromLong(String longStr, ParsePosition pos) throws ParseException",
        "protected Date parseAsISO8601(String dateStr, ParsePosition pos) throws ParseException",
        "protected Date _parseAsISO8601(String dateStr, ParsePosition bogus) throws IllegalArgumentException, ParseException",
        "private static int _parse4D(String str, int index)",
        "private static int _parse2D(String str, int index)",
        "protected Date parseAsRFC1123(String dateStr, ParsePosition pos)",
        "private final static DateFormat _cloneFormat(DateFormat df, String format, TimeZone tz, Locale loc, Boolean lenient)",
        "protected void _clearFormats()",
        "protected Calendar _getCalendar(TimeZone tz)",
        "protected static <T> boolean _equals(T value1, T value2)"
      ],
      "methods": [
        {
          "buggy_method": "  protected void _format(TimeZone tz, Locale loc, Date date, StringBuffer buffer) {\n  Calendar cal = _getCalendar(tz);\n  cal.setTime(date);\n  \n  final int year = cal.get(Calendar.YEAR);\n\n  \n  \n  \n  \n  \n  \n  pad4(buffer, year);\n  buffer.append('-');\n  pad2(buffer, cal.get(Calendar.MONTH) + 1);\n  buffer.append('-');\n  pad2(buffer, cal.get(Calendar.DAY_OF_MONTH));\n  buffer.append('T');\n  pad2(buffer, cal.get(Calendar.HOUR_OF_DAY));\n  buffer.append(':');\n  pad2(buffer, cal.get(Calendar.MINUTE));\n  buffer.append(':');\n  pad2(buffer, cal.get(Calendar.SECOND));\n  buffer.append('.');\n  pad3(buffer, cal.get(Calendar.MILLISECOND));\n\n  int offset = tz.getOffset(cal.getTimeInMillis());\n  if (offset != 0) {\n  int hours = Math.abs((offset / (60 * 1000)) / 60);\n  int minutes = Math.abs((offset / (60 * 1000)) % 60);\n  buffer.append(offset < 0 ? '-' : '+');\n  pad2(buffer, hours);\n  if( _tzSerializedWithColon ) {\n  \t\tbuffer.append(':');\n  }\n  pad2(buffer, minutes);\n  } else {\n  \n  \n\n\t  \tif( _tzSerializedWithColon ) {\n\t  buffer.append(\"+00:00\");\n\t  \t}\n\t  \telse {\n\t  \t\tbuffer.append(\"+0000\");\n\t  \t}\n  }\n  }",
          "fixed_method": "  protected void _format(TimeZone tz, Locale loc, Date date, StringBuffer buffer) {\n  Calendar cal = _getCalendar(tz);\n  cal.setTime(date);\n  \n  final int year = cal.get(Calendar.YEAR);\n\n  \n  if (cal.get(Calendar.ERA) == GregorianCalendar.BC) {\n  _formatBCEYear(buffer, year);\n  } else {\n  if (year > 9999) {\n  \n  \n  \n  \n  \n  buffer.append('+');\n  }\n  pad4(buffer, year);\n  }\n  buffer.append('-');\n  pad2(buffer, cal.get(Calendar.MONTH) + 1);\n  buffer.append('-');\n  pad2(buffer, cal.get(Calendar.DAY_OF_MONTH));\n  buffer.append('T');\n  pad2(buffer, cal.get(Calendar.HOUR_OF_DAY));\n  buffer.append(':');\n  pad2(buffer, cal.get(Calendar.MINUTE));\n  buffer.append(':');\n  pad2(buffer, cal.get(Calendar.SECOND));\n  buffer.append('.');\n  pad3(buffer, cal.get(Calendar.MILLISECOND));\n\n  int offset = tz.getOffset(cal.getTimeInMillis());\n  if (offset != 0) {\n  int hours = Math.abs((offset / (60 * 1000)) / 60);\n  int minutes = Math.abs((offset / (60 * 1000)) % 60);\n  buffer.append(offset < 0 ? '-' : '+');\n  pad2(buffer, hours);\n  if( _tzSerializedWithColon ) {\n  \t\tbuffer.append(':');\n  }\n  pad2(buffer, minutes);\n  } else {\n  \n  \n\n\t  \tif( _tzSerializedWithColon ) {\n\t  buffer.append(\"+00:00\");\n\t  \t}\n\t  \telse {\n\t  \t\tbuffer.append(\"+0000\");\n\t  \t}\n  }\n  }",
          "diff": [
            "@@ -438,12 +438,19 @@",
            "         final int year = cal.get(Calendar.YEAR);\n",
            " \n",
            "         // Assuming GregorianCalendar, special handling needed for BCE (aka BC)\n",
            "+        if (cal.get(Calendar.ERA) == GregorianCalendar.BC) {\n",
            "+            _formatBCEYear(buffer, year);\n",
            "+        } else {\n",
            "+            if (year > 9999) {\n",
            "                 // 22-Nov-2018, tatu: Handling beyond 4-digits is not well specified wrt ISO-8601, but\n",
            "                 //   it seems that plus prefix IS mandated. Padding is an open question, but since agreeement\n",
            "                 //   for max length would be needed, we ewould need to limit to arbitrary length\n",
            "                 //   like five digits (erroring out if beyond or padding to that as minimum).\n",
            "                 //   Instead, let's just print number out as is and let decoder try to make sense of it.\n",
            "+                buffer.append('+');\n",
            "+            }\n",
            "             pad4(buffer, year);\n",
            "+        }\n",
            "         buffer.append('-');\n",
            "         pad2(buffer, cal.get(Calendar.MONTH) + 1);\n",
            "         buffer.append('-');\n"
          ],
          "changed_lines": 7
        },
        {
          "buggy_method": "  private static void pad2(StringBuffer buffer, int value) {\n  int tens = value / 10;\n  if (tens == 0) {\n  buffer.append('0');\n  } else {\n  buffer.append((char) ('0' + tens));\n  value -= 10 * tens;\n  }\n  buffer.append((char) ('0' + value));\n  }",
          "fixed_method": "  protected void _formatBCEYear(StringBuffer buffer, int bceYearNoSign) {\n  \n  \n  if (bceYearNoSign == 1) {\n  buffer.append(\"+0000\");\n  return;\n  }\n  final int isoYear = bceYearNoSign - 1;\n  buffer.append('-');\n  \n  \n  \n  pad4(buffer, isoYear);\n  }",
          "diff": [
            "@@ -480,11 +487,20 @@",
            "         }\n",
            "     }\n",
            " \n",
            "+    protected void _formatBCEYear(StringBuffer buffer, int bceYearNoSign) {\n",
            "         // Ok. First of all, BCE 1 output (given as value `1` in era BCE) needs to become\n",
            "         // \"+0000\", but rest (from `2` up, in that era) need minus sign.\n",
            "+        if (bceYearNoSign == 1) {\n",
            "+            buffer.append(\"+0000\");\n",
            "+            return;\n",
            "+        }\n",
            "+        final int isoYear = bceYearNoSign - 1;\n",
            "+        buffer.append('-');\n",
            "         // as with CE, 4 digit variant needs padding; beyond that not (although that part is\n",
            "         // open to debate, needs agreement with receiver)\n",
            "         // But `pad4()` deals with \"big\" numbers now so:\n",
            "+        pad4(buffer, isoYear);\n",
            "+    }\n",
            " \n",
            "     private static void pad2(StringBuffer buffer, int value) {\n",
            "         int tens = value / 10;\n"
          ],
          "changed_lines": 9
        },
        {
          "buggy_method": "  private static void pad4(StringBuffer buffer, int value) {\n  int h = value / 100;\n  if (h == 0) {\n  buffer.append('0').append('0');\n  } else {\n  pad2(buffer, h);\n  value -= (100 * h);\n  }\n  pad2(buffer, value);\n  }",
          "fixed_method": "  private static void pad4(StringBuffer buffer, int value) {\n  int h = value / 100;\n  if (h == 0) {\n  buffer.append('0').append('0');\n  } else {\n  if (h > 99) { \n  buffer.append(h);\n  } else {\n  pad2(buffer, h);\n  }\n  value -= (100 * h);\n  }\n  pad2(buffer, value);\n  }",
          "diff": [
            "@@ -513,7 +529,11 @@",
            "         if (h == 0) {\n",
            "             buffer.append('0').append('0');\n",
            "         } else {\n",
            "+            if (h > 99) { // [databind#2167]: handle above 9999 correctly\n",
            "+                buffer.append(h);\n",
            "+            } else {\n",
            "                 pad2(buffer, h);\n",
            "+            }\n",
            "             value -= (100 * h);\n",
            "         }\n",
            "         pad2(buffer, value);\n"
          ],
          "changed_lines": 4
        }
      ]
    }
  ]
}
