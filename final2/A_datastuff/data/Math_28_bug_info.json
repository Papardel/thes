{
  "bug_id": "28",
  "failed_tests": {
    "org.apache.commons.math3.optimization.linear.SimplexSolverTest": [
      {
        "methodName": "testMath828Cycle",
        "error": "org.apache.commons.math3.exception.MaxCountExceededException",
        "message": "illegal state: maximal count (100) exceeded",
        "fail_line": "        PointValuePair solution = new SimplexSolver().optimize(f, constraints, GoalType.MINIMIZE, true);",
        "test_source": "  public void testMath828Cycle() {\n  LinearObjectiveFunction f = new LinearObjectiveFunction(\n  new double[] { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}, 0.0);\n  \n  ArrayList <LinearConstraint>constraints = new ArrayList<LinearConstraint>();\n\n  constraints.add(new LinearConstraint(new double[] {0.0, 16.0, 14.0, 69.0, 1.0, 85.0, 52.0, 43.0, 64.0, 97.0, 14.0, 74.0, 89.0, 28.0, 94.0, 58.0, 13.0, 22.0, 21.0, 17.0, 30.0, 25.0, 1.0, 59.0, 91.0, 78.0, 12.0, 74.0, 56.0, 3.0, 88.0,}, Relationship.GEQ, 91.0));\n  constraints.add(new LinearConstraint(new double[] {0.0, 60.0, 40.0, 81.0, 71.0, 72.0, 46.0, 45.0, 38.0, 48.0, 40.0, 17.0, 33.0, 85.0, 64.0, 32.0, 84.0, 3.0, 54.0, 44.0, 71.0, 67.0, 90.0, 95.0, 54.0, 99.0, 99.0, 29.0, 52.0, 98.0, 9.0,}, Relationship.GEQ, 54.0));\n  constraints.add(new LinearConstraint(new double[] {0.0, 41.0, 12.0, 86.0, 90.0, 61.0, 31.0, 41.0, 23.0, 89.0, 17.0, 74.0, 44.0, 27.0, 16.0, 47.0, 80.0, 32.0, 11.0, 56.0, 68.0, 82.0, 11.0, 62.0, 62.0, 53.0, 39.0, 16.0, 48.0, 1.0, 63.0,}, Relationship.GEQ, 62.0));\n  constraints.add(new LinearConstraint(new double[] {83.0, -76.0, -94.0, -19.0, -15.0, -70.0, -72.0, -57.0, -63.0, -65.0, -22.0, -94.0, -22.0, -88.0, -86.0, -89.0, -72.0, -16.0, -80.0, -49.0, -70.0, -93.0, -95.0, -17.0, -83.0, -97.0, -31.0, -47.0, -31.0, -13.0, -23.0,}, Relationship.GEQ, 0.0));\n  constraints.add(new LinearConstraint(new double[] {41.0, -96.0, -41.0, -48.0, -70.0, -43.0, -43.0, -43.0, -97.0, -37.0, -85.0, -70.0, -45.0, -67.0, -87.0, -69.0, -94.0, -54.0, -54.0, -92.0, -79.0, -10.0, -35.0, -20.0, -41.0, -41.0, -65.0, -25.0, -12.0, -8.0, -46.0,}, Relationship.GEQ, 0.0));\n  constraints.add(new LinearConstraint(new double[] {27.0, -42.0, -65.0, -49.0, -53.0, -42.0, -17.0, -2.0, -61.0, -31.0, -76.0, -47.0, -8.0, -93.0, -86.0, -62.0, -65.0, -63.0, -22.0, -43.0, -27.0, -23.0, -32.0, -74.0, -27.0, -63.0, -47.0, -78.0, -29.0, -95.0, -73.0,}, Relationship.GEQ, 0.0));\n  constraints.add(new LinearConstraint(new double[] {15.0, -46.0, -41.0, -83.0, -98.0, -99.0, -21.0, -35.0, -7.0, -14.0, -80.0, -63.0, -18.0, -42.0, -5.0, -34.0, -56.0, -70.0, -16.0, -18.0, -74.0, -61.0, -47.0, -41.0, -15.0, -79.0, -18.0, -47.0, -88.0, -68.0, -55.0,}, Relationship.GEQ, 0.0));\n  \n  double epsilon = 1e-6;\n  PointValuePair solution = new SimplexSolver().optimize(f, constraints, GoalType.MINIMIZE, true);\n  Assert.assertEquals(1.0d, solution.getValue(), epsilon);\n  Assert.assertTrue(validSolution(solution, constraints, epsilon));  \n  }",
        "stack": [
          "AbstractLinearOptimizer.incrementIterationsCounter line 128, SimplexSolver.doIteration line 165, SimplexSolver.doOptimize line 227, AbstractLinearOptimizer.optimize line 147, SimplexSolverTest.testMath828Cycle line 70"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/math3/optimization/linear/SimplexSolver.java",
      "buggy_full_code": "\n\npackage org.apache.commons.math3.optimization.linear;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.math3.exception.MaxCountExceededException;\nimport org.apache.commons.math3.optimization.PointValuePair;\nimport org.apache.commons.math3.util.Precision;\n\n\n\npublic class SimplexSolver extends AbstractLinearOptimizer { private static final double DEFAULT_EPSILON = 1.0e-6; private static final int DEFAULT_ULPS = 10; private final double epsilon; private final int maxUlps; public SimplexSolver() {\n        this(DEFAULT_EPSILON, DEFAULT_ULPS);\n    }\n\n    \n    public SimplexSolver(final double epsilon, final int maxUlps) {\n        this.epsilon = epsilon;\n        this.maxUlps = maxUlps;\n    }\n\n    \n    private Integer getPivotColumn(SimplexTableau tableau) {\n        double minValue = 0;\n        Integer minPos = null;\n        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) {\n            final double entry = tableau.getEntry(0, i);\n            \n            \n            if (entry < minValue) {\n                minValue = entry;\n                minPos = i;\n            }\n        }\n        return minPos;\n    }\n\n    \n    private Integer getPivotRow(SimplexTableau tableau, final int col) {\n        \n        List<Integer> minRatioPositions = new ArrayList<Integer>();\n        double minRatio = Double.MAX_VALUE;\n        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n            final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n            final double entry = tableau.getEntry(i, col);\n\n            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n                final double ratio = rhs / entry;\n                \n                \n                final int cmp = Double.compare(ratio, minRatio);\n                if (cmp == 0) {\n                    minRatioPositions.add(i);\n                } else if (cmp < 0) {\n                    minRatio = ratio;\n                    minRatioPositions = new ArrayList<Integer>();\n                    minRatioPositions.add(i);\n                }\n            }\n        }\n\n        if (minRatioPositions.size() == 0) {\n            return null;\n        } else if (minRatioPositions.size() > 1) {\n            \n\n            \n                for (Integer row : minRatioPositions) {\n                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n                        int column = i + tableau.getArtificialVariableOffset();\n                        final double entry = tableau.getEntry(row, column);\n                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n                            return row;\n                        }\n                    }\n                }\n\n            \n            \n            \n            \n            \n            \n            \n            \n            \n                Integer minRow = null;\n                int minIndex = tableau.getWidth();\n                for (Integer row : minRatioPositions) {\n                    int i = tableau.getNumObjectiveFunctions();\n                    for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n                        if (row == tableau.getBasicRow(i)) {\n                            if (i < minIndex) {\n                                minIndex = i;\n                                minRow = row;\n                            }\n                        }\n                    }\n                }\n                return minRow;\n        }\n        return minRatioPositions.get(0);\n    }\n\n    \n    protected void doIteration(final SimplexTableau tableau) throws MaxCountExceededException, UnboundedSolutionException {\n\n        incrementIterationsCounter();\n\n        Integer pivotCol = getPivotColumn(tableau);\n        Integer pivotRow = getPivotRow(tableau, pivotCol);\n        if (pivotRow == null) {\n            throw new UnboundedSolutionException();\n        }\n\n        \n        double pivotVal = tableau.getEntry(pivotRow, pivotCol);\n        tableau.divideRow(pivotRow, pivotVal);\n\n        \n        for (int i = 0; i < tableau.getHeight(); i++) {\n            if (i != pivotRow) {\n                final double multiplier = tableau.getEntry(i, pivotCol);\n                tableau.subtractRow(i, pivotRow, multiplier);\n            }\n        }\n    }\n\n    \n    protected void solvePhase1(final SimplexTableau tableau) throws MaxCountExceededException, UnboundedSolutionException, NoFeasibleSolutionException {\n\n        \n        if (tableau.getNumArtificialVariables() == 0) {\n            return;\n        }\n\n        while (!tableau.isOptimal()) {\n            doIteration(tableau);\n        }\n\n        \n        if (!Precision.equals(tableau.getEntry(0, tableau.getRhsOffset()), 0d, epsilon)) {\n            throw new NoFeasibleSolutionException();\n        }\n    }\n\n    \n    @Override\n    public PointValuePair doOptimize() throws MaxCountExceededException, UnboundedSolutionException, NoFeasibleSolutionException {\n        final SimplexTableau tableau =\n            new SimplexTableau(getFunction(),\n                               getConstraints(),\n                               getGoalType(),\n                               restrictToNonNegative(),\n                               epsilon,\n                               maxUlps);\n\n        solvePhase1(tableau);\n        tableau.dropPhase1Objective();\n\n        while (!tableau.isOptimal()) {\n            doIteration(tableau);\n        }\n        return tableau.getSolution();\n    }\n\n}\n",
      "fixed_full_code": "\n\npackage org.apache.commons.math3.optimization.linear;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.math3.exception.MaxCountExceededException;\nimport org.apache.commons.math3.optimization.PointValuePair;\nimport org.apache.commons.math3.util.Precision;\n\n\n\npublic class SimplexSolver extends AbstractLinearOptimizer { private static final double DEFAULT_EPSILON = 1.0e-6; private static final int DEFAULT_ULPS = 10; private final double epsilon; private final int maxUlps; public SimplexSolver() {\n        this(DEFAULT_EPSILON, DEFAULT_ULPS);\n    }\n\n    \n    public SimplexSolver(final double epsilon, final int maxUlps) {\n        this.epsilon = epsilon;\n        this.maxUlps = maxUlps;\n    }\n\n    \n    private Integer getPivotColumn(SimplexTableau tableau) {\n        double minValue = 0;\n        Integer minPos = null;\n        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) {\n            final double entry = tableau.getEntry(0, i);\n            \n            \n            if (entry < minValue) {\n                minValue = entry;\n                minPos = i;\n            }\n        }\n        return minPos;\n    }\n\n    \n    private Integer getPivotRow(SimplexTableau tableau, final int col) {\n        \n        List<Integer> minRatioPositions = new ArrayList<Integer>();\n        double minRatio = Double.MAX_VALUE;\n        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n            final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n            final double entry = tableau.getEntry(i, col);\n\n            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n                final double ratio = rhs / entry;\n                \n                \n                final int cmp = Double.compare(ratio, minRatio);\n                if (cmp == 0) {\n                    minRatioPositions.add(i);\n                } else if (cmp < 0) {\n                    minRatio = ratio;\n                    minRatioPositions = new ArrayList<Integer>();\n                    minRatioPositions.add(i);\n                }\n            }\n        }\n\n        if (minRatioPositions.size() == 0) {\n            return null;\n        } else if (minRatioPositions.size() > 1) {\n            \n\n            \n            if (tableau.getNumArtificialVariables() > 0) {\n                for (Integer row : minRatioPositions) {\n                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n                        int column = i + tableau.getArtificialVariableOffset();\n                        final double entry = tableau.getEntry(row, column);\n                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n                            return row;\n                        }\n                    }\n                }\n            }\n\n            \n            \n            \n            \n            \n            \n            \n            \n            \n            if (getIterations() < getMaxIterations() / 2) {\n                Integer minRow = null;\n                int minIndex = tableau.getWidth();\n                for (Integer row : minRatioPositions) {\n                    int i = tableau.getNumObjectiveFunctions();\n                    for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n                        if (row == tableau.getBasicRow(i)) {\n                            if (i < minIndex) {\n                                minIndex = i;\n                                minRow = row;\n                            }\n                        }\n                    }\n                }\n                return minRow;\n            }\n        }\n        return minRatioPositions.get(0);\n    }\n\n    \n    protected void doIteration(final SimplexTableau tableau) throws MaxCountExceededException, UnboundedSolutionException {\n\n        incrementIterationsCounter();\n\n        Integer pivotCol = getPivotColumn(tableau);\n        Integer pivotRow = getPivotRow(tableau, pivotCol);\n        if (pivotRow == null) {\n            throw new UnboundedSolutionException();\n        }\n\n        \n        double pivotVal = tableau.getEntry(pivotRow, pivotCol);\n        tableau.divideRow(pivotRow, pivotVal);\n\n        \n        for (int i = 0; i < tableau.getHeight(); i++) {\n            if (i != pivotRow) {\n                final double multiplier = tableau.getEntry(i, pivotCol);\n                tableau.subtractRow(i, pivotRow, multiplier);\n            }\n        }\n    }\n\n    \n    protected void solvePhase1(final SimplexTableau tableau) throws MaxCountExceededException, UnboundedSolutionException, NoFeasibleSolutionException {\n\n        \n        if (tableau.getNumArtificialVariables() == 0) {\n            return;\n        }\n\n        while (!tableau.isOptimal()) {\n            doIteration(tableau);\n        }\n\n        \n        if (!Precision.equals(tableau.getEntry(0, tableau.getRhsOffset()), 0d, epsilon)) {\n            throw new NoFeasibleSolutionException();\n        }\n    }\n\n    \n    @Override\n    public PointValuePair doOptimize() throws MaxCountExceededException, UnboundedSolutionException, NoFeasibleSolutionException {\n        final SimplexTableau tableau =\n            new SimplexTableau(getFunction(),\n                               getConstraints(),\n                               getGoalType(),\n                               restrictToNonNegative(),\n                               epsilon,\n                               maxUlps);\n\n        solvePhase1(tableau);\n        tableau.dropPhase1Objective();\n\n        while (!tableau.isOptimal()) {\n            doIteration(tableau);\n        }\n        return tableau.getSolution();\n    }\n\n}\n",
      "buggy_signatures": [
        "public SimplexSolver(final double epsilon, final int maxUlps)",
        "private Integer getPivotColumn(SimplexTableau tableau)",
        "private Integer getPivotRow(SimplexTableau tableau, final int col)",
        "protected void doIteration(final SimplexTableau tableau) throws MaxCountExceededException, UnboundedSolutionException",
        "protected void solvePhase1(final SimplexTableau tableau) throws MaxCountExceededException, UnboundedSolutionException, NoFeasibleSolutionException",
        "public PointValuePair doOptimize() throws MaxCountExceededException, UnboundedSolutionException, NoFeasibleSolutionException"
      ],
      "fixed_signatures": [
        "public SimplexSolver(final double epsilon, final int maxUlps)",
        "private Integer getPivotColumn(SimplexTableau tableau)",
        "private Integer getPivotRow(SimplexTableau tableau, final int col)",
        "protected void doIteration(final SimplexTableau tableau) throws MaxCountExceededException, UnboundedSolutionException",
        "protected void solvePhase1(final SimplexTableau tableau) throws MaxCountExceededException, UnboundedSolutionException, NoFeasibleSolutionException",
        "public PointValuePair doOptimize() throws MaxCountExceededException, UnboundedSolutionException, NoFeasibleSolutionException"
      ],
      "methods": [
        {
          "buggy_method": "  private Integer getPivotRow(SimplexTableau tableau, final int col) {\n  \n  List<Integer> minRatioPositions = new ArrayList<Integer>();\n  double minRatio = Double.MAX_VALUE;\n  for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n  final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n  final double entry = tableau.getEntry(i, col);\n\n  if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n  final double ratio = rhs / entry;\n  \n  \n  final int cmp = Double.compare(ratio, minRatio);\n  if (cmp == 0) {\n  minRatioPositions.add(i);\n  } else if (cmp < 0) {\n  minRatio = ratio;\n  minRatioPositions = new ArrayList<Integer>();\n  minRatioPositions.add(i);\n  }\n  }\n  }\n\n  if (minRatioPositions.size() == 0) {\n  return null;\n  } else if (minRatioPositions.size() > 1) {\n  \n\n  \n  for (Integer row : minRatioPositions) {\n  for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n  int column = i + tableau.getArtificialVariableOffset();\n  final double entry = tableau.getEntry(row, column);\n  if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n  return row;\n  }\n  }\n  }\n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  Integer minRow = null;\n  int minIndex = tableau.getWidth();\n  for (Integer row : minRatioPositions) {\n  int i = tableau.getNumObjectiveFunctions();\n  for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n  if (row == tableau.getBasicRow(i)) {\n  if (i < minIndex) {\n  minIndex = i;\n  minRow = row;\n  }\n  }\n  }\n  }\n  return minRow;\n  }\n  return minRatioPositions.get(0);\n  }",
          "fixed_method": "  private Integer getPivotRow(SimplexTableau tableau, final int col) {\n  \n  List<Integer> minRatioPositions = new ArrayList<Integer>();\n  double minRatio = Double.MAX_VALUE;\n  for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n  final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n  final double entry = tableau.getEntry(i, col);\n\n  if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n  final double ratio = rhs / entry;\n  \n  \n  final int cmp = Double.compare(ratio, minRatio);\n  if (cmp == 0) {\n  minRatioPositions.add(i);\n  } else if (cmp < 0) {\n  minRatio = ratio;\n  minRatioPositions = new ArrayList<Integer>();\n  minRatioPositions.add(i);\n  }\n  }\n  }\n\n  if (minRatioPositions.size() == 0) {\n  return null;\n  } else if (minRatioPositions.size() > 1) {\n  \n\n  \n  if (tableau.getNumArtificialVariables() > 0) {\n  for (Integer row : minRatioPositions) {\n  for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n  int column = i + tableau.getArtificialVariableOffset();\n  final double entry = tableau.getEntry(row, column);\n  if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n  return row;\n  }\n  }\n  }\n  }\n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if (getIterations() < getMaxIterations() / 2) {\n  Integer minRow = null;\n  int minIndex = tableau.getWidth();\n  for (Integer row : minRatioPositions) {\n  int i = tableau.getNumObjectiveFunctions();\n  for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n  if (row == tableau.getBasicRow(i)) {\n  if (i < minIndex) {\n  minIndex = i;\n  minRow = row;\n  }\n  }\n  }\n  }\n  return minRow;\n  }\n  }\n  return minRatioPositions.get(0);\n  }",
          "diff": [
            "@@ -116,6 +116,7 @@",
            "             // there's a degeneracy as indicated by a tie in the minimum ratio test\n",
            " \n",
            "             // 1. check if there's an artificial variable that can be forced out of the basis\n",
            "+            if (tableau.getNumArtificialVariables() > 0) {\n",
            "                 for (Integer row : minRatioPositions) {\n",
            "                     for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n",
            "                         int column = i + tableau.getArtificialVariableOffset();\n",
            "@@ -125,6 +126,7 @@",
            "                         }\n",
            "                     }\n",
            "                 }\n",
            "+            }\n",
            " \n",
            "             // 2. apply Bland's rule to prevent cycling:\n",
            "             //    take the row for which the corresponding basic variable has the smallest index\n",
            "@@ -135,6 +137,7 @@",
            "             // Additional heuristic: if we did not get a solution after half of maxIterations\n",
            "             //                       revert to the simple case of just returning the top-most row\n",
            "             // This heuristic is based on empirical data gathered while investigating MATH-828.\n",
            "+            if (getIterations() < getMaxIterations() / 2) {\n",
            "                 Integer minRow = null;\n",
            "                 int minIndex = tableau.getWidth();\n",
            "                 for (Integer row : minRatioPositions) {\n",
            "@@ -149,6 +152,7 @@",
            "                     }\n",
            "                 }\n",
            "                 return minRow;\n",
            "+            }\n",
            "         }\n",
            "         return minRatioPositions.get(0);\n",
            "     }\n"
          ],
          "changed_lines": 4
        }
      ]
    }
  ]
}
