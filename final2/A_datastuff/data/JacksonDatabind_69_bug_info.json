{
  "bug_id": "69",
  "failed_tests": {
    "com.fasterxml.jackson.databind.creators.Creator1476Test": [
      {
        "methodName": "testConstructorChoice",
        "error": "com.fasterxml.jackson.databind.JsonMappingException",
        "message": "Could not find creator property with name 'stringField' (in class com.fasterxml.jackson.databind.creators.Creator1476Test$SimplePojo)",
        "fail_line": "        SimplePojo pojo = mapper.readValue(\"{ \\\"intField\\\": 1, \\\"stringField\\\": \\\"foo\\\" }\", SimplePojo.class);",
        "test_source": "  public void testConstructorChoice() throws Exception {\n  ObjectMapper mapper = new ObjectMapper();\n  SimplePojo pojo = mapper.readValue(\"{ \\\"intField\\\": 1, \\\"stringField\\\": \\\"foo\\\" }\", SimplePojo.class);\n\n  assertEquals(1, pojo.getIntField());\n  assertEquals(\"foo\", pojo.getStringField());\n  }",
        "stack": [
          "JsonMappingException.from line 256, DeserializationContext.mappingException line 993, BeanDeserializerFactory.addBeanProps line 539, BeanDeserializerFactory.buildBeanDeserializer line 228, BeanDeserializerFactory.createBeanDeserializer line 143, DeserializerCache._createDeserializer2 line 406, DeserializerCache._createDeserializer line 352, DeserializerCache._createAndCache2 line 264, DeserializerCache._createAndCacheValueDeserializer line 244, DeserializerCache.findValueDeserializer line 142, DeserializationContext.findRootValueDeserializer line 477, ObjectMapper._findRootDeserializer line 3908, ObjectMapper._readMapAndClose line 3803, ObjectMapper.readValue line 2797, Creator1476Test.testConstructorChoice line 38"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java",
      "buggy_full_code": "package com.fasterxml.jackson.databind.deser.impl;\n\nimport java.io.IOException;\nimport java.lang.reflect.Member;\nimport java.util.*;\n\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.cfg.MapperConfig;\nimport com.fasterxml.jackson.databind.deser.CreatorProperty;\nimport com.fasterxml.jackson.databind.deser.SettableBeanProperty;\nimport com.fasterxml.jackson.databind.deser.ValueInstantiator;\nimport com.fasterxml.jackson.databind.deser.std.StdValueInstantiator;\nimport com.fasterxml.jackson.databind.introspect.*;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\n\n\npublic class CreatorCollector { protected final static int C_DEFAULT = 0; protected final static int C_STRING = 1; protected final static int C_INT = 2; protected final static int C_LONG = 3; protected final static int C_DOUBLE = 4; protected final static int C_BOOLEAN = 5; protected final static int C_DELEGATE = 6; protected final static int C_PROPS = 7; protected final static int C_ARRAY_DELEGATE = 8; protected final static String[] TYPE_DESCS = new String[] { \"default\", \"String\", \"int\", \"long\", \"double\", \"boolean\", \"delegate\", \"property-based\" }; final protected BeanDescription _beanDesc; final protected boolean _canFixAccess; final protected boolean _forceAccess; protected final AnnotatedWithParams[] _creators = new AnnotatedWithParams[9]; protected int _explicitCreators = 0; protected boolean _hasNonDefaultCreator = false; protected SettableBeanProperty[] _delegateArgs; protected SettableBeanProperty[] _arrayDelegateArgs; protected SettableBeanProperty[] _propertyBasedArgs; protected AnnotatedParameter _incompleteParameter; public CreatorCollector(BeanDescription beanDesc, MapperConfig<?> config) {\n        _beanDesc = beanDesc;\n        _canFixAccess = config.canOverrideAccessModifiers();\n        _forceAccess = config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS);\n    }\n\n    public ValueInstantiator constructValueInstantiator(DeserializationConfig config) {\n        final JavaType delegateType = _computeDelegateType(_creators[C_DELEGATE], _delegateArgs);\n        final JavaType arrayDelegateType = _computeDelegateType(_creators[C_ARRAY_DELEGATE], _arrayDelegateArgs);\n        final JavaType type = _beanDesc.getType();\n\n        \n        \n        if (!_hasNonDefaultCreator) {\n            \n            final Class<?> rawType = type.getRawClass();\n            if (rawType == Collection.class || rawType == List.class || rawType == ArrayList.class) {\n                return new Vanilla(Vanilla.TYPE_COLLECTION);\n            }\n            if (rawType == Map.class || rawType == LinkedHashMap.class) {\n                return new Vanilla(Vanilla.TYPE_MAP);\n            }\n            if (rawType == HashMap.class) {\n                return new Vanilla(Vanilla.TYPE_HASH_MAP);\n            }\n        }\n        \n        StdValueInstantiator inst = new StdValueInstantiator(config, type);\n        inst.configureFromObjectSettings(_creators[C_DEFAULT],\n                _creators[C_DELEGATE], delegateType, _delegateArgs,\n                _creators[C_PROPS], _propertyBasedArgs);\n        inst.configureFromArraySettings(_creators[C_ARRAY_DELEGATE], arrayDelegateType, _arrayDelegateArgs);\n        inst.configureFromStringCreator(_creators[C_STRING]);\n        inst.configureFromIntCreator(_creators[C_INT]);\n        inst.configureFromLongCreator(_creators[C_LONG]);\n        inst.configureFromDoubleCreator(_creators[C_DOUBLE]);\n        inst.configureFromBooleanCreator(_creators[C_BOOLEAN]);\n        inst.configureIncompleteParameter(_incompleteParameter);\n        return inst;\n    }\n    \n    \n    \n    \n    public void setDefaultCreator(AnnotatedWithParams creator) {\n        _creators[C_DEFAULT] = _fixAccess(creator);\n    }\n    \n    public void addStringCreator(AnnotatedWithParams creator, boolean explicit) {\n        verifyNonDup(creator, C_STRING, explicit);\n    }\n    public void addIntCreator(AnnotatedWithParams creator, boolean explicit) {\n        verifyNonDup(creator, C_INT, explicit);\n    }\n    public void addLongCreator(AnnotatedWithParams creator, boolean explicit) {\n        verifyNonDup(creator, C_LONG, explicit);\n    }\n    public void addDoubleCreator(AnnotatedWithParams creator, boolean explicit) {\n        verifyNonDup(creator, C_DOUBLE, explicit);\n    }\n    public void addBooleanCreator(AnnotatedWithParams creator, boolean explicit) {\n        verifyNonDup(creator, C_BOOLEAN, explicit);\n    }\n\n    public void addDelegatingCreator(AnnotatedWithParams creator, boolean explicit, SettableBeanProperty[] injectables) {\n        if (creator.getParameterType(0).isCollectionLikeType()) {\n            verifyNonDup(creator, C_ARRAY_DELEGATE, explicit);\n                _arrayDelegateArgs = injectables;\n        } else {\n            verifyNonDup(creator, C_DELEGATE, explicit);\n                _delegateArgs = injectables;\n        }\n    }\n    \n    public void addPropertyCreator(AnnotatedWithParams creator, boolean explicit, SettableBeanProperty[] properties) {\n        verifyNonDup(creator, C_PROPS, explicit);\n            \n            if (properties.length > 1) {\n                HashMap<String,Integer> names = new HashMap<String,Integer>();\n                for (int i = 0, len = properties.length; i < len; ++i) {\n                    String name = properties[i].getName();\n                    \n                    if (name.length() == 0 && properties[i].getInjectableValueId() != null) {\n                        continue;\n                    }\n                    Integer old = names.put(name, Integer.valueOf(i));\n                    if (old != null) {\n                        throw new IllegalArgumentException(\"Duplicate creator property \\\"\"+name+\"\\\" (index \"+old+\" vs \"+i+\")\");\n                    }\n                }\n            }\n            _propertyBasedArgs = properties;\n    }\n\n    public void addIncompeteParameter(AnnotatedParameter parameter) {\n        if (_incompleteParameter == null) {\n            _incompleteParameter = parameter;\n        }\n    }\n\n    \n    \n    @Deprecated \n    public void addStringCreator(AnnotatedWithParams creator) {\n        addStringCreator(creator, false);\n    }\n    @Deprecated \n    public void addIntCreator(AnnotatedWithParams creator) {\n        addBooleanCreator(creator, false);\n    }\n    @Deprecated \n    public void addLongCreator(AnnotatedWithParams creator) {\n        addBooleanCreator(creator, false);\n    }\n    @Deprecated \n    public void addDoubleCreator(AnnotatedWithParams creator) {\n        addBooleanCreator(creator, false);\n    }\n    @Deprecated \n    public void addBooleanCreator(AnnotatedWithParams creator) {\n        addBooleanCreator(creator, false);\n    }\n\n    @Deprecated \n    public void addDelegatingCreator(AnnotatedWithParams creator, CreatorProperty[] injectables) {\n        addDelegatingCreator(creator, false, injectables);\n    }\n\n    @Deprecated \n    public void addPropertyCreator(AnnotatedWithParams creator, CreatorProperty[] properties) {\n        addPropertyCreator(creator, false, properties);\n    }\n\n    \n\n    \n    public boolean hasDefaultCreator() {\n        return _creators[C_DEFAULT] != null;\n    }\n\n    \n    public boolean hasDelegatingCreator() {\n        return _creators[C_DELEGATE] != null;\n    }\n\n    \n    public boolean hasPropertyBasedCreator() {\n        return _creators[C_PROPS] != null;\n    }\n    \n    \n\n    private JavaType _computeDelegateType(AnnotatedWithParams creator, SettableBeanProperty[] delegateArgs) {\n        if (!_hasNonDefaultCreator || (creator == null)) {\n            return null;\n        }\n        \n        int ix = 0;\n        if (delegateArgs != null) {\n            for (int i = 0, len = delegateArgs.length; i < len; ++i) {\n                if (delegateArgs[i] == null) { \n                    ix = i;\n                    break;\n                }\n            }\n        }\n        return creator.getParameterType(ix);\n    }\n\n    private <T extends AnnotatedMember> T _fixAccess(T member) {\n        if (member != null && _canFixAccess) {\n            ClassUtil.checkAndFixAccess((Member) member.getAnnotated(), _forceAccess);\n        }\n        return member;\n    }\n\n    \n    protected void verifyNonDup(AnnotatedWithParams newOne, int typeIndex, boolean explicit) {\n        final int mask = (1 << typeIndex);\n        _hasNonDefaultCreator = true;\n        AnnotatedWithParams oldOne = _creators[typeIndex];\n        \n        if (oldOne != null) {\n            boolean verify;\n            if ((_explicitCreators & mask) != 0) { \n                \n                if (!explicit) {\n                    return;\n                }\n                \n                verify = true;\n            } else {\n                \n                verify = !explicit;\n            }\n\n            \n            if (verify && (oldOne.getClass() == newOne.getClass())) {\n                \n                Class<?> oldType = oldOne.getRawParameterType(0);\n                Class<?> newType = newOne.getRawParameterType(0);\n\n                if (oldType == newType) {\n                    throw new IllegalArgumentException(\"Conflicting \"+TYPE_DESCS[typeIndex]\n                            +\" creators: already had explicitly marked \"+oldOne+\", encountered \"+newOne);\n                }\n                \n                if (newType.isAssignableFrom(oldType)) {\n                    \n                    return;\n                }\n                \n            }\n        }\n        if (explicit) {\n            _explicitCreators |= mask;\n        }\n        _creators[typeIndex] = _fixAccess(newOne);\n    }\n\n    \n\n    protected final static class Vanilla extends ValueInstantiator implements java.io.Serializable { private static final long serialVersionUID = 1L; public final static int TYPE_COLLECTION = 1; public final static int TYPE_MAP = 2; public final static int TYPE_HASH_MAP = 3; private final int _type; public Vanilla(int t) {\n            _type = t;\n        }\n        \n        \n        @Override\n        public String getValueTypeDesc() {\n            switch (_type) {\n            case TYPE_COLLECTION: return ArrayList.class.getName();\n            case TYPE_MAP: return LinkedHashMap.class.getName();\n            case TYPE_HASH_MAP: return HashMap.class.getName();\n            }\n            return Object.class.getName();\n        }\n\n        @Override\n        public boolean canInstantiate() { return true; }\n\n        @Override\n        public boolean canCreateUsingDefault() {  return true; }\n\n        @Override\n        public Object createUsingDefault(DeserializationContext ctxt) throws IOException {\n            switch (_type) {\n            case TYPE_COLLECTION: return new ArrayList<Object>();\n            case TYPE_MAP: return new LinkedHashMap<String,Object>();\n            case TYPE_HASH_MAP: return new HashMap<String,Object>();\n            }\n            throw new IllegalStateException(\"Unknown type \"+_type);\n        }\n    }\n}\n",
      "fixed_full_code": "package com.fasterxml.jackson.databind.deser.impl;\n\nimport java.io.IOException;\nimport java.lang.reflect.Member;\nimport java.util.*;\n\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.cfg.MapperConfig;\nimport com.fasterxml.jackson.databind.deser.CreatorProperty;\nimport com.fasterxml.jackson.databind.deser.SettableBeanProperty;\nimport com.fasterxml.jackson.databind.deser.ValueInstantiator;\nimport com.fasterxml.jackson.databind.deser.std.StdValueInstantiator;\nimport com.fasterxml.jackson.databind.introspect.*;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\n\n\npublic class CreatorCollector { protected final static int C_DEFAULT = 0; protected final static int C_STRING = 1; protected final static int C_INT = 2; protected final static int C_LONG = 3; protected final static int C_DOUBLE = 4; protected final static int C_BOOLEAN = 5; protected final static int C_DELEGATE = 6; protected final static int C_PROPS = 7; protected final static int C_ARRAY_DELEGATE = 8; protected final static String[] TYPE_DESCS = new String[] { \"default\", \"String\", \"int\", \"long\", \"double\", \"boolean\", \"delegate\", \"property-based\" }; final protected BeanDescription _beanDesc; final protected boolean _canFixAccess; final protected boolean _forceAccess; protected final AnnotatedWithParams[] _creators = new AnnotatedWithParams[9]; protected int _explicitCreators = 0; protected boolean _hasNonDefaultCreator = false; protected SettableBeanProperty[] _delegateArgs; protected SettableBeanProperty[] _arrayDelegateArgs; protected SettableBeanProperty[] _propertyBasedArgs; protected AnnotatedParameter _incompleteParameter; public CreatorCollector(BeanDescription beanDesc, MapperConfig<?> config) {\n        _beanDesc = beanDesc;\n        _canFixAccess = config.canOverrideAccessModifiers();\n        _forceAccess = config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS);\n    }\n\n    public ValueInstantiator constructValueInstantiator(DeserializationConfig config) {\n        final JavaType delegateType = _computeDelegateType(_creators[C_DELEGATE], _delegateArgs);\n        final JavaType arrayDelegateType = _computeDelegateType(_creators[C_ARRAY_DELEGATE], _arrayDelegateArgs);\n        final JavaType type = _beanDesc.getType();\n\n        \n        \n        if (!_hasNonDefaultCreator) {\n            \n            final Class<?> rawType = type.getRawClass();\n            if (rawType == Collection.class || rawType == List.class || rawType == ArrayList.class) {\n                return new Vanilla(Vanilla.TYPE_COLLECTION);\n            }\n            if (rawType == Map.class || rawType == LinkedHashMap.class) {\n                return new Vanilla(Vanilla.TYPE_MAP);\n            }\n            if (rawType == HashMap.class) {\n                return new Vanilla(Vanilla.TYPE_HASH_MAP);\n            }\n        }\n        \n        StdValueInstantiator inst = new StdValueInstantiator(config, type);\n        inst.configureFromObjectSettings(_creators[C_DEFAULT],\n                _creators[C_DELEGATE], delegateType, _delegateArgs,\n                _creators[C_PROPS], _propertyBasedArgs);\n        inst.configureFromArraySettings(_creators[C_ARRAY_DELEGATE], arrayDelegateType, _arrayDelegateArgs);\n        inst.configureFromStringCreator(_creators[C_STRING]);\n        inst.configureFromIntCreator(_creators[C_INT]);\n        inst.configureFromLongCreator(_creators[C_LONG]);\n        inst.configureFromDoubleCreator(_creators[C_DOUBLE]);\n        inst.configureFromBooleanCreator(_creators[C_BOOLEAN]);\n        inst.configureIncompleteParameter(_incompleteParameter);\n        return inst;\n    }\n    \n    \n    \n    \n    public void setDefaultCreator(AnnotatedWithParams creator) {\n        _creators[C_DEFAULT] = _fixAccess(creator);\n    }\n    \n    public void addStringCreator(AnnotatedWithParams creator, boolean explicit) {\n        verifyNonDup(creator, C_STRING, explicit);\n    }\n    public void addIntCreator(AnnotatedWithParams creator, boolean explicit) {\n        verifyNonDup(creator, C_INT, explicit);\n    }\n    public void addLongCreator(AnnotatedWithParams creator, boolean explicit) {\n        verifyNonDup(creator, C_LONG, explicit);\n    }\n    public void addDoubleCreator(AnnotatedWithParams creator, boolean explicit) {\n        verifyNonDup(creator, C_DOUBLE, explicit);\n    }\n    public void addBooleanCreator(AnnotatedWithParams creator, boolean explicit) {\n        verifyNonDup(creator, C_BOOLEAN, explicit);\n    }\n\n    public void addDelegatingCreator(AnnotatedWithParams creator, boolean explicit, SettableBeanProperty[] injectables) {\n        if (creator.getParameterType(0).isCollectionLikeType()) {\n            if (verifyNonDup(creator, C_ARRAY_DELEGATE, explicit)) {\n                _arrayDelegateArgs = injectables;\n            }\n        } else {\n            if (verifyNonDup(creator, C_DELEGATE, explicit)) {\n                _delegateArgs = injectables;\n            }\n        }\n    }\n    \n    public void addPropertyCreator(AnnotatedWithParams creator, boolean explicit, SettableBeanProperty[] properties) {\n        if (verifyNonDup(creator, C_PROPS, explicit)) {\n            \n            if (properties.length > 1) {\n                HashMap<String,Integer> names = new HashMap<String,Integer>();\n                for (int i = 0, len = properties.length; i < len; ++i) {\n                    String name = properties[i].getName();\n                    \n                    if (name.length() == 0 && properties[i].getInjectableValueId() != null) {\n                        continue;\n                    }\n                    Integer old = names.put(name, Integer.valueOf(i));\n                    if (old != null) {\n                        throw new IllegalArgumentException(\"Duplicate creator property \\\"\"+name+\"\\\" (index \"+old+\" vs \"+i+\")\");\n                    }\n                }\n            }\n            _propertyBasedArgs = properties;\n        }\n    }\n\n    public void addIncompeteParameter(AnnotatedParameter parameter) {\n        if (_incompleteParameter == null) {\n            _incompleteParameter = parameter;\n        }\n    }\n\n    \n    \n    @Deprecated \n    public void addStringCreator(AnnotatedWithParams creator) {\n        addStringCreator(creator, false);\n    }\n    @Deprecated \n    public void addIntCreator(AnnotatedWithParams creator) {\n        addBooleanCreator(creator, false);\n    }\n    @Deprecated \n    public void addLongCreator(AnnotatedWithParams creator) {\n        addBooleanCreator(creator, false);\n    }\n    @Deprecated \n    public void addDoubleCreator(AnnotatedWithParams creator) {\n        addBooleanCreator(creator, false);\n    }\n    @Deprecated \n    public void addBooleanCreator(AnnotatedWithParams creator) {\n        addBooleanCreator(creator, false);\n    }\n\n    @Deprecated \n    public void addDelegatingCreator(AnnotatedWithParams creator, CreatorProperty[] injectables) {\n        addDelegatingCreator(creator, false, injectables);\n    }\n\n    @Deprecated \n    public void addPropertyCreator(AnnotatedWithParams creator, CreatorProperty[] properties) {\n        addPropertyCreator(creator, false, properties);\n    }\n\n    \n\n    \n    public boolean hasDefaultCreator() {\n        return _creators[C_DEFAULT] != null;\n    }\n\n    \n    public boolean hasDelegatingCreator() {\n        return _creators[C_DELEGATE] != null;\n    }\n\n    \n    public boolean hasPropertyBasedCreator() {\n        return _creators[C_PROPS] != null;\n    }\n    \n    \n\n    private JavaType _computeDelegateType(AnnotatedWithParams creator, SettableBeanProperty[] delegateArgs) {\n        if (!_hasNonDefaultCreator || (creator == null)) {\n            return null;\n        }\n        \n        int ix = 0;\n        if (delegateArgs != null) {\n            for (int i = 0, len = delegateArgs.length; i < len; ++i) {\n                if (delegateArgs[i] == null) { \n                    ix = i;\n                    break;\n                }\n            }\n        }\n        return creator.getParameterType(ix);\n    }\n\n    private <T extends AnnotatedMember> T _fixAccess(T member) {\n        if (member != null && _canFixAccess) {\n            ClassUtil.checkAndFixAccess((Member) member.getAnnotated(), _forceAccess);\n        }\n        return member;\n    }\n\n    \n    protected boolean verifyNonDup(AnnotatedWithParams newOne, int typeIndex, boolean explicit) {\n        final int mask = (1 << typeIndex);\n        _hasNonDefaultCreator = true;\n        AnnotatedWithParams oldOne = _creators[typeIndex];\n        \n        if (oldOne != null) {\n            boolean verify;\n            if ((_explicitCreators & mask) != 0) { \n                \n                if (!explicit) {\n                    return false;\n                }\n                \n                verify = true;\n            } else {\n                \n                verify = !explicit;\n            }\n\n            \n            if (verify && (oldOne.getClass() == newOne.getClass())) {\n                \n                Class<?> oldType = oldOne.getRawParameterType(0);\n                Class<?> newType = newOne.getRawParameterType(0);\n\n                if (oldType == newType) {\n                    throw new IllegalArgumentException(\"Conflicting \"+TYPE_DESCS[typeIndex]\n                            +\" creators: already had explicitly marked \"+oldOne+\", encountered \"+newOne);\n                }\n                \n                if (newType.isAssignableFrom(oldType)) {\n                    \n                    return false;\n                }\n                \n            }\n        }\n        if (explicit) {\n            _explicitCreators |= mask;\n        }\n        _creators[typeIndex] = _fixAccess(newOne);\n        return true;\n    }\n\n    \n\n    protected final static class Vanilla extends ValueInstantiator implements java.io.Serializable { private static final long serialVersionUID = 1L; public final static int TYPE_COLLECTION = 1; public final static int TYPE_MAP = 2; public final static int TYPE_HASH_MAP = 3; private final int _type; public Vanilla(int t) {\n            _type = t;\n        }\n        \n        \n        @Override\n        public String getValueTypeDesc() {\n            switch (_type) {\n            case TYPE_COLLECTION: return ArrayList.class.getName();\n            case TYPE_MAP: return LinkedHashMap.class.getName();\n            case TYPE_HASH_MAP: return HashMap.class.getName();\n            }\n            return Object.class.getName();\n        }\n\n        @Override\n        public boolean canInstantiate() { return true; }\n\n        @Override\n        public boolean canCreateUsingDefault() {  return true; }\n\n        @Override\n        public Object createUsingDefault(DeserializationContext ctxt) throws IOException {\n            switch (_type) {\n            case TYPE_COLLECTION: return new ArrayList<Object>();\n            case TYPE_MAP: return new LinkedHashMap<String,Object>();\n            case TYPE_HASH_MAP: return new HashMap<String,Object>();\n            }\n            throw new IllegalStateException(\"Unknown type \"+_type);\n        }\n    }\n}\n",
      "buggy_signatures": [
        "public ValueInstantiator constructValueInstantiator(DeserializationConfig config)",
        "public void setDefaultCreator(AnnotatedWithParams creator)",
        "public void addStringCreator(AnnotatedWithParams creator, boolean explicit)",
        "public void addIntCreator(AnnotatedWithParams creator, boolean explicit)",
        "public void addLongCreator(AnnotatedWithParams creator, boolean explicit)",
        "public void addDoubleCreator(AnnotatedWithParams creator, boolean explicit)",
        "public void addBooleanCreator(AnnotatedWithParams creator, boolean explicit)",
        "public void addDelegatingCreator(AnnotatedWithParams creator, boolean explicit, SettableBeanProperty[] injectables)",
        "public void addPropertyCreator(AnnotatedWithParams creator, boolean explicit, SettableBeanProperty[] properties)",
        "public void addIncompeteParameter(AnnotatedParameter parameter)",
        "public void addStringCreator(AnnotatedWithParams creator)",
        "public void addIntCreator(AnnotatedWithParams creator)",
        "public void addLongCreator(AnnotatedWithParams creator)",
        "public void addDoubleCreator(AnnotatedWithParams creator)",
        "public void addBooleanCreator(AnnotatedWithParams creator)",
        "public void addDelegatingCreator(AnnotatedWithParams creator, CreatorProperty[] injectables)",
        "public void addPropertyCreator(AnnotatedWithParams creator, CreatorProperty[] properties)",
        "public boolean hasDefaultCreator()",
        "public boolean hasDelegatingCreator()",
        "public boolean hasPropertyBasedCreator()",
        "private JavaType _computeDelegateType(AnnotatedWithParams creator, SettableBeanProperty[] delegateArgs)",
        "private <T extends AnnotatedMember> T _fixAccess(T member)",
        "protected void verifyNonDup(AnnotatedWithParams newOne, int typeIndex, boolean explicit)",
        "public String getValueTypeDesc()",
        "public boolean canInstantiate()",
        "public boolean canCreateUsingDefault()",
        "public Object createUsingDefault(DeserializationContext ctxt) throws IOException"
      ],
      "fixed_signatures": [
        "public ValueInstantiator constructValueInstantiator(DeserializationConfig config)",
        "public void setDefaultCreator(AnnotatedWithParams creator)",
        "public void addStringCreator(AnnotatedWithParams creator, boolean explicit)",
        "public void addIntCreator(AnnotatedWithParams creator, boolean explicit)",
        "public void addLongCreator(AnnotatedWithParams creator, boolean explicit)",
        "public void addDoubleCreator(AnnotatedWithParams creator, boolean explicit)",
        "public void addBooleanCreator(AnnotatedWithParams creator, boolean explicit)",
        "public void addDelegatingCreator(AnnotatedWithParams creator, boolean explicit, SettableBeanProperty[] injectables)",
        "public void addPropertyCreator(AnnotatedWithParams creator, boolean explicit, SettableBeanProperty[] properties)",
        "public void addIncompeteParameter(AnnotatedParameter parameter)",
        "public void addStringCreator(AnnotatedWithParams creator)",
        "public void addIntCreator(AnnotatedWithParams creator)",
        "public void addLongCreator(AnnotatedWithParams creator)",
        "public void addDoubleCreator(AnnotatedWithParams creator)",
        "public void addBooleanCreator(AnnotatedWithParams creator)",
        "public void addDelegatingCreator(AnnotatedWithParams creator, CreatorProperty[] injectables)",
        "public void addPropertyCreator(AnnotatedWithParams creator, CreatorProperty[] properties)",
        "public boolean hasDefaultCreator()",
        "public boolean hasDelegatingCreator()",
        "public boolean hasPropertyBasedCreator()",
        "private JavaType _computeDelegateType(AnnotatedWithParams creator, SettableBeanProperty[] delegateArgs)",
        "private <T extends AnnotatedMember> T _fixAccess(T member)",
        "protected boolean verifyNonDup(AnnotatedWithParams newOne, int typeIndex, boolean explicit)",
        "public String getValueTypeDesc()",
        "public boolean canInstantiate()",
        "public boolean canCreateUsingDefault()",
        "public Object createUsingDefault(DeserializationContext ctxt) throws IOException"
      ],
      "methods": [
        {
          "buggy_method": "  public void addPropertyCreator(AnnotatedWithParams creator, boolean explicit, SettableBeanProperty[] properties) {\n  verifyNonDup(creator, C_PROPS, explicit);\n  \n  if (properties.length > 1) {\n  HashMap<String,Integer> names = new HashMap<String,Integer>();\n  for (int i = 0, len = properties.length; i < len; ++i) {\n  String name = properties[i].getName();\n  \n  if (name.length() == 0 && properties[i].getInjectableValueId() != null) {\n  continue;\n  }\n  Integer old = names.put(name, Integer.valueOf(i));\n  if (old != null) {\n  throw new IllegalArgumentException(\"Duplicate creator property \\\"\"+name+\"\\\" (index \"+old+\" vs \"+i+\")\");\n  }\n  }\n  }\n  _propertyBasedArgs = properties;\n  }",
          "fixed_method": "  public void addPropertyCreator(AnnotatedWithParams creator, boolean explicit, SettableBeanProperty[] properties) {\n  if (verifyNonDup(creator, C_PROPS, explicit)) {\n  \n  if (properties.length > 1) {\n  HashMap<String,Integer> names = new HashMap<String,Integer>();\n  for (int i = 0, len = properties.length; i < len; ++i) {\n  String name = properties[i].getName();\n  \n  if (name.length() == 0 && properties[i].getInjectableValueId() != null) {\n  continue;\n  }\n  Integer old = names.put(name, Integer.valueOf(i));\n  if (old != null) {\n  throw new IllegalArgumentException(\"Duplicate creator property \\\"\"+name+\"\\\" (index \"+old+\" vs \"+i+\")\");\n  }\n  }\n  }\n  _propertyBasedArgs = properties;\n  }\n  }",
          "diff": [
            "@@ -162,18 +162,20 @@",
            "             SettableBeanProperty[] injectables)\n",
            "     {\n",
            "         if (creator.getParameterType(0).isCollectionLikeType()) {\n",
            "-            verifyNonDup(creator, C_ARRAY_DELEGATE, explicit);\n",
            "+            if (verifyNonDup(creator, C_ARRAY_DELEGATE, explicit)) {\n",
            "                 _arrayDelegateArgs = injectables;\n",
            "+            }\n",
            "         } else {\n",
            "-            verifyNonDup(creator, C_DELEGATE, explicit);\n",
            "+            if (verifyNonDup(creator, C_DELEGATE, explicit)) {\n",
            "                 _delegateArgs = injectables;\n",
            "+            }\n",
            "         }\n",
            "     }\n",
            "     \n",
            "     public void addPropertyCreator(AnnotatedWithParams creator, boolean explicit,\n",
            "             SettableBeanProperty[] properties)\n",
            "     {\n",
            "-        verifyNonDup(creator, C_PROPS, explicit);\n",
            "+        if (verifyNonDup(creator, C_PROPS, explicit)) {\n",
            "             // Better ensure we have no duplicate names either...\n",
            "             if (properties.length > 1) {\n",
            "                 HashMap<String,Integer> names = new HashMap<String,Integer>();\n"
          ],
          "changed_lines": 8
        },
        {
          "buggy_method": "  public void addIncompeteParameter(AnnotatedParameter parameter) {\n  if (_incompleteParameter == null) {\n  _incompleteParameter = parameter;\n  }\n  }",
          "fixed_method": "  public void addIncompeteParameter(AnnotatedParameter parameter) {\n  if (_incompleteParameter == null) {\n  _incompleteParameter = parameter;\n  }\n  }",
          "diff": [
            "@@ -192,6 +194,7 @@",
            "                 }\n",
            "             }\n",
            "             _propertyBasedArgs = properties;\n",
            "+        }\n",
            "     }\n",
            " \n",
            "     public void addIncompeteParameter(AnnotatedParameter parameter) {\n"
          ],
          "changed_lines": 1
        },
        {
          "buggy_method": "  protected void verifyNonDup(AnnotatedWithParams newOne, int typeIndex, boolean explicit) {\n  final int mask = (1 << typeIndex);\n  _hasNonDefaultCreator = true;\n  AnnotatedWithParams oldOne = _creators[typeIndex];\n  \n  if (oldOne != null) {\n  boolean verify;\n  if ((_explicitCreators & mask) != 0) { \n  \n  if (!explicit) {\n  return;\n  }\n  \n  verify = true;\n  } else {\n  \n  verify = !explicit;\n  }\n\n  \n  if (verify && (oldOne.getClass() == newOne.getClass())) {\n  \n  Class<?> oldType = oldOne.getRawParameterType(0);\n  Class<?> newType = newOne.getRawParameterType(0);\n\n  if (oldType == newType) {\n  throw new IllegalArgumentException(\"Conflicting \"+TYPE_DESCS[typeIndex]\n  +\" creators: already had explicitly marked \"+oldOne+\", encountered \"+newOne);\n  }\n  \n  if (newType.isAssignableFrom(oldType)) {\n  \n  return;\n  }\n  \n  }\n  }\n  if (explicit) {\n  _explicitCreators |= mask;\n  }\n  _creators[typeIndex] = _fixAccess(newOne);\n  }",
          "fixed_method": "  protected boolean verifyNonDup(AnnotatedWithParams newOne, int typeIndex, boolean explicit) {\n  final int mask = (1 << typeIndex);\n  _hasNonDefaultCreator = true;\n  AnnotatedWithParams oldOne = _creators[typeIndex];\n  \n  if (oldOne != null) {\n  boolean verify;\n  if ((_explicitCreators & mask) != 0) { \n  \n  if (!explicit) {\n  return false;\n  }\n  \n  verify = true;\n  } else {\n  \n  verify = !explicit;\n  }\n\n  \n  if (verify && (oldOne.getClass() == newOne.getClass())) {\n  \n  Class<?> oldType = oldOne.getRawParameterType(0);\n  Class<?> newType = newOne.getRawParameterType(0);\n\n  if (oldType == newType) {\n  throw new IllegalArgumentException(\"Conflicting \"+TYPE_DESCS[typeIndex]\n  +\" creators: already had explicitly marked \"+oldOne+\", encountered \"+newOne);\n  }\n  \n  if (newType.isAssignableFrom(oldType)) {\n  \n  return false;\n  }\n  \n  }\n  }\n  if (explicit) {\n  _explicitCreators |= mask;\n  }\n  _creators[typeIndex] = _fixAccess(newOne);\n  return true;\n  }",
          "diff": [
            "@@ -296,7 +299,7 @@",
            "     /**\n",
            "      * @return True if specified Creator is to be used\n",
            "      */\n",
            "-    protected void verifyNonDup(AnnotatedWithParams newOne, int typeIndex, boolean explicit)\n",
            "+    protected boolean verifyNonDup(AnnotatedWithParams newOne, int typeIndex, boolean explicit)\n",
            "     {\n",
            "         final int mask = (1 << typeIndex);\n",
            "         _hasNonDefaultCreator = true;\n",
            "@@ -307,7 +310,7 @@",
            "             if ((_explicitCreators & mask) != 0) { // already had explicitly annotated, leave as-is\n",
            "                 // but skip, if new one not annotated\n",
            "                 if (!explicit) {\n",
            "-                    return;\n",
            "+                    return false;\n",
            "                 }\n",
            "                 // both explicit: verify\n",
            "                 verify = true;\n",
            "@@ -329,7 +332,7 @@",
            "                 // otherwise, which one to choose?\n",
            "                 if (newType.isAssignableFrom(oldType)) {\n",
            "                     // new type more generic, use old\n",
            "-                    return;\n",
            "+                    return false;\n",
            "                 }\n",
            "                 // new type more specific, use it\n",
            "             }\n",
            "@@ -338,6 +341,7 @@",
            "             _explicitCreators |= mask;\n",
            "         }\n",
            "         _creators[typeIndex] = _fixAccess(newOne);\n",
            "+        return true;\n",
            "     }\n",
            " \n",
            "     /*\n"
          ],
          "changed_lines": 7
        }
      ]
    }
  ]
}
