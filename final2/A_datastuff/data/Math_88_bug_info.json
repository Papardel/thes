{
  "bug_id": "88",
  "failed_tests": {
    "org.apache.commons.math.optimization.linear.SimplexSolverTest": [
      {
        "methodName": "testMath272",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<1.0> but was:<0.0>",
        "fail_line": "        assertEquals(1.0, solution.getPoint()[2], .0000001);",
        "test_source": "  public void testMath272() throws OptimizationException {\n  LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 2, 2, 1 }, 0);\n  Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();\n  constraints.add(new LinearConstraint(new double[] { 1, 1, 0 }, Relationship.GEQ,  1));\n  constraints.add(new LinearConstraint(new double[] { 1, 0, 1 }, Relationship.GEQ,  1));\n  constraints.add(new LinearConstraint(new double[] { 0, 1, 0 }, Relationship.GEQ,  1));\n\n  SimplexSolver solver = new SimplexSolver();\n  RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MINIMIZE, true);\n  \n  assertEquals(0.0, solution.getPoint()[0], .0000001);\n  assertEquals(1.0, solution.getPoint()[1], .0000001);\n  assertEquals(1.0, solution.getPoint()[2], .0000001);\n  assertEquals(3.0, solution.getValue(), .0000001);\n  }",
        "stack": [
          "SimplexSolverTest.testMath272 line 47"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/math/optimization/linear/SimplexTableau.java",
      "buggy_full_code": "\n\npackage org.apache.commons.math.optimization.linear;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\nimport org.apache.commons.math.linear.MatrixUtils;\nimport org.apache.commons.math.linear.RealMatrix;\nimport org.apache.commons.math.linear.RealMatrixImpl;\nimport org.apache.commons.math.linear.RealVector;\nimport org.apache.commons.math.optimization.GoalType;\nimport org.apache.commons.math.optimization.RealPointValuePair;\nimport org.apache.commons.math.util.MathUtils;\n\n\nclass SimplexTableau implements Serializable {\n\n    \n    private static final long serialVersionUID = -1369660067587938365L; private final LinearObjectiveFunction f; private final Collection<LinearConstraint> constraints; private final boolean restrictToNonNegative; protected transient RealMatrix tableau; protected final int numDecisionVariables; protected final int numSlackVariables; protected int numArtificialVariables; protected final double epsilon; SimplexTableau(final LinearObjectiveFunction f, final Collection<LinearConstraint> constraints, final GoalType goalType, final boolean restrictToNonNegative, final double epsilon) {\n        this.f                      = f;\n        this.constraints            = constraints;\n        this.restrictToNonNegative  = restrictToNonNegative;\n        this.epsilon                = epsilon;\n        this.numDecisionVariables   = getNumVariables() + (restrictToNonNegative ? 0 : 1);\n        this.numSlackVariables      = getConstraintTypeCounts(Relationship.LEQ) +\n                                      getConstraintTypeCounts(Relationship.GEQ);\n        this.numArtificialVariables = getConstraintTypeCounts(Relationship.EQ) +\n                                      getConstraintTypeCounts(Relationship.GEQ);\n        this.tableau = new RealMatrixImpl(createTableau(goalType == GoalType.MAXIMIZE));\n        initialize();\n    }\n\n    \n    protected double[][] createTableau(final boolean maximize) {\n\n        \n        List<LinearConstraint> constraints = getNormalizedConstraints();\n        int width = numDecisionVariables + numSlackVariables +\n        numArtificialVariables + getNumObjectiveFunctions() + 1; \n        int height = constraints.size() + getNumObjectiveFunctions();\n        double[][] matrix = new double[height][width];\n\n        \n        if (getNumObjectiveFunctions() == 2) {\n            matrix[0][0] = -1;\n        }\n        int zIndex = (getNumObjectiveFunctions() == 1) ? 0 : 1;\n        matrix[zIndex][zIndex] = maximize ? 1 : -1;\n        RealVector objectiveCoefficients =\n            maximize ? f.getCoefficients().mapMultiply(-1) : f.getCoefficients();\n            copyArray(objectiveCoefficients.getData(), matrix[zIndex], getNumObjectiveFunctions());\n            matrix[zIndex][width - 1] =\n                maximize ? f.getConstantTerm() : -1 * f.getConstantTerm();\n\n                if (!restrictToNonNegative) {\n                    matrix[zIndex][getSlackVariableOffset() - 1] =\n                        getInvertedCoeffiecientSum(objectiveCoefficients);\n                }\n\n                \n                int slackVar = 0;\n                int artificialVar = 0;\n                for (int i = 0; i < constraints.size(); i++) {\n                    LinearConstraint constraint = constraints.get(i);\n                    int row = getNumObjectiveFunctions() + i;\n\n                    \n                    copyArray(constraint.getCoefficients().getData(), matrix[row], 1);\n\n                    \n                    if (!restrictToNonNegative) {\n                        matrix[row][getSlackVariableOffset() - 1] =\n                            getInvertedCoeffiecientSum(constraint.getCoefficients());\n                    }\n\n                    \n                    matrix[row][width - 1] = constraint.getValue();\n\n                    \n                    if (constraint.getRelationship() == Relationship.LEQ) {\n                        matrix[row][getSlackVariableOffset() + slackVar++] = 1;  \n                    } else if (constraint.getRelationship() == Relationship.GEQ) {\n                        matrix[row][getSlackVariableOffset() + slackVar++] = -1; \n                    }\n\n                    \n                    if ((constraint.getRelationship() == Relationship.EQ) ||\n                        (constraint.getRelationship() == Relationship.GEQ)) {\n                        matrix[0][getArtificialVariableOffset() + artificialVar] = 1; \n                        matrix[row][getArtificialVariableOffset() + artificialVar++] = 1; \n                    }\n                }\n\n                return matrix;\n    }\n\n    \n    public int getNumVariables() {\n        return f.getCoefficients().getDimension();\n    }\n\n    \n    public List<LinearConstraint> getNormalizedConstraints() {\n        List<LinearConstraint> normalized = new ArrayList<LinearConstraint>();\n        for (LinearConstraint constraint : constraints) {\n            normalized.add(normalize(constraint));\n        }\n        return normalized;\n    }\n\n    \n    private LinearConstraint normalize(final LinearConstraint constraint) {\n        if (constraint.getValue() < 0) {\n            return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1),\n                                        constraint.getRelationship().oppositeRelationship(),\n                                        -1 * constraint.getValue());\n        }\n        return new LinearConstraint(constraint.getCoefficients(), \n                                    constraint.getRelationship(), constraint.getValue());\n    }\n\n    \n    protected final int getNumObjectiveFunctions() {\n        return this.numArtificialVariables > 0 ? 2 : 1;\n    }\n\n    \n    private int getConstraintTypeCounts(final Relationship relationship) {\n        int count = 0;\n        for (final LinearConstraint constraint : constraints) {\n            if (constraint.getRelationship() == relationship) {\n                ++count;\n            }\n        }\n        return count;\n    }\n\n    \n    private void initialize() {\n        for (int artificialVar = 0; artificialVar < numArtificialVariables; artificialVar++) {\n            int row = getBasicRow(getArtificialVariableOffset() + artificialVar);\n            subtractRow(0, row, 1.0);\n        }\n    }\n\n    \n    protected static double getInvertedCoeffiecientSum(final RealVector coefficients) {\n        double sum = 0;\n        for (double coefficient : coefficients.getData()) {\n            sum -= coefficient;\n        }\n        return sum;\n    }\n\n    \n    private Integer getBasicRow(final int col) {\n        Integer row = null;\n        for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) {\n            if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {\n                if (row == null) {\n                    row = i;\n                } else {\n                    return null;\n                }\n            }\n        }\n        return row;\n    }\n\n    \n    protected void discardArtificialVariables() {\n        if (numArtificialVariables == 0) {\n            return;\n        }\n        int width = getWidth() - numArtificialVariables - 1;\n        int height = getHeight() - 1;\n        double[][] matrix = new double[height][width];\n        for (int i = 0; i < height; i++) {\n            for (int j = 0; j < width - 1; j++) {\n                matrix[i][j] = getEntry(i + 1, j + 1);\n            }\n            matrix[i][width - 1] = getEntry(i + 1, getRhsOffset());\n        }\n        this.tableau = new RealMatrixImpl(matrix);\n        this.numArtificialVariables = 0;\n    }\n\n\n    \n    private void copyArray(final double[] src, final double[] dest, final int destPos) {\n        System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length); \n    }\n\n    \n    protected RealPointValuePair getSolution() {\n        double[] coefficients = new double[getOriginalNumDecisionVariables()];\n        Integer basicRow =\n            getBasicRow(getNumObjectiveFunctions() + getOriginalNumDecisionVariables());\n        double mostNegative = basicRow == null ? 0 : getEntry(basicRow, getRhsOffset());\n        for (int i = 0; i < coefficients.length; i++) {\n            basicRow = getBasicRow(getNumObjectiveFunctions() + i);\n                \n                \n                coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);\n            if (basicRow != null) {\n                for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n                    if (tableau.getEntry(basicRow, j) == 1) {\n                         coefficients[i] = 0;\n                    }\n                }\n            }\n        }\n        return new RealPointValuePair(coefficients, f.getValue(coefficients));\n    }\n\n    \n    protected void divideRow(final int dividendRow, final double divisor) {\n        for (int j = 0; j < getWidth(); j++) {\n            tableau.setEntry(dividendRow, j, tableau.getEntry(dividendRow, j) / divisor);\n        }\n    }\n\n    \n    protected void subtractRow(final int minuendRow, final int subtrahendRow, final double multiple) {\n        for (int j = 0; j < getWidth(); j++) {\n            tableau.setEntry(minuendRow, j, tableau.getEntry(minuendRow, j) -\n                             multiple * tableau.getEntry(subtrahendRow, j));\n        }\n    }\n\n    \n    protected final int getWidth() {\n        return tableau.getColumnDimension();\n    }\n\n    \n    protected final int getHeight() {\n        return tableau.getRowDimension();\n    }\n\n    \n    protected final double getEntry(final int row, final int column) {\n        return tableau.getEntry(row, column);\n    }\n\n    \n    protected final void setEntry(final int row, final int column, final double value) {\n        tableau.setEntry(row, column, value);\n    }\n\n    \n    protected final int getSlackVariableOffset() {\n        return getNumObjectiveFunctions() + numDecisionVariables;\n    }\n\n    \n    protected final int getArtificialVariableOffset() {\n        return getNumObjectiveFunctions() + numDecisionVariables + numSlackVariables;\n    }\n\n    \n    protected final int getRhsOffset() {\n        return getWidth() - 1;\n    }\n\n    \n    protected final int getNumDecisionVariables() {\n        return numDecisionVariables;\n    }\n\n    \n    protected final int getOriginalNumDecisionVariables() {\n        return restrictToNonNegative ? numDecisionVariables : numDecisionVariables - 1;\n    }\n\n    \n    protected final int getNumSlackVariables() {\n        return numSlackVariables;\n    }\n\n    \n    protected final int getNumArtificialVariables() {\n        return numArtificialVariables;\n    }\n\n    \n    protected final double[][] getData() {\n        return tableau.getData();\n    }\n\n    \n    @Override\n    public boolean equals(Object other) {\n\n      if (this == other) { \n        return true;\n      }\n\n      if (other == null) {\n        return false;\n      }\n\n      try {\n\n          SimplexTableau rhs = (SimplexTableau) other;\n          return (restrictToNonNegative  == rhs.restrictToNonNegative) &&\n                 (numDecisionVariables   == rhs.numDecisionVariables) &&\n                 (numSlackVariables      == rhs.numSlackVariables) &&\n                 (numArtificialVariables == rhs.numArtificialVariables) &&\n                 (epsilon                == rhs.epsilon) &&\n                 f.equals(rhs.f) &&\n                 constraints.equals(rhs.constraints) &&\n                 tableau.equals(rhs.tableau);\n\n      } catch (ClassCastException ex) {\n          \n          return false;\n      }\n\n    }\n    \n    \n    @Override\n    public int hashCode() {\n        return Boolean.valueOf(restrictToNonNegative).hashCode() ^\n               numDecisionVariables ^\n               numSlackVariables ^\n               numArtificialVariables ^\n               Double.valueOf(epsilon).hashCode() ^\n               f.hashCode() ^\n               constraints.hashCode() ^\n               tableau.hashCode();\n    }\n\n    \n    private void writeObject(ObjectOutputStream oos) throws IOException {\n        oos.defaultWriteObject();\n        MatrixUtils.serializeRealMatrix(tableau, oos);\n    }\n\n    \n    private void readObject(ObjectInputStream ois) throws ClassNotFoundException, IOException {\n        ois.defaultReadObject();\n        MatrixUtils.deserializeRealMatrix(this, \"tableau\", ois);\n    }\n}\n",
      "fixed_full_code": "\n\npackage org.apache.commons.math.optimization.linear;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\nimport org.apache.commons.math.linear.MatrixUtils;\nimport org.apache.commons.math.linear.RealMatrix;\nimport org.apache.commons.math.linear.RealMatrixImpl;\nimport org.apache.commons.math.linear.RealVector;\nimport org.apache.commons.math.optimization.GoalType;\nimport org.apache.commons.math.optimization.RealPointValuePair;\nimport org.apache.commons.math.util.MathUtils;\n\n\nclass SimplexTableau implements Serializable {\n\n    \n    private static final long serialVersionUID = -1369660067587938365L; private final LinearObjectiveFunction f; private final Collection<LinearConstraint> constraints; private final boolean restrictToNonNegative; protected transient RealMatrix tableau; protected final int numDecisionVariables; protected final int numSlackVariables; protected int numArtificialVariables; protected final double epsilon; SimplexTableau(final LinearObjectiveFunction f, final Collection<LinearConstraint> constraints, final GoalType goalType, final boolean restrictToNonNegative, final double epsilon) {\n        this.f                      = f;\n        this.constraints            = constraints;\n        this.restrictToNonNegative  = restrictToNonNegative;\n        this.epsilon                = epsilon;\n        this.numDecisionVariables   = getNumVariables() + (restrictToNonNegative ? 0 : 1);\n        this.numSlackVariables      = getConstraintTypeCounts(Relationship.LEQ) +\n                                      getConstraintTypeCounts(Relationship.GEQ);\n        this.numArtificialVariables = getConstraintTypeCounts(Relationship.EQ) +\n                                      getConstraintTypeCounts(Relationship.GEQ);\n        this.tableau = new RealMatrixImpl(createTableau(goalType == GoalType.MAXIMIZE));\n        initialize();\n    }\n\n    \n    protected double[][] createTableau(final boolean maximize) {\n\n        \n        List<LinearConstraint> constraints = getNormalizedConstraints();\n        int width = numDecisionVariables + numSlackVariables +\n        numArtificialVariables + getNumObjectiveFunctions() + 1; \n        int height = constraints.size() + getNumObjectiveFunctions();\n        double[][] matrix = new double[height][width];\n\n        \n        if (getNumObjectiveFunctions() == 2) {\n            matrix[0][0] = -1;\n        }\n        int zIndex = (getNumObjectiveFunctions() == 1) ? 0 : 1;\n        matrix[zIndex][zIndex] = maximize ? 1 : -1;\n        RealVector objectiveCoefficients =\n            maximize ? f.getCoefficients().mapMultiply(-1) : f.getCoefficients();\n            copyArray(objectiveCoefficients.getData(), matrix[zIndex], getNumObjectiveFunctions());\n            matrix[zIndex][width - 1] =\n                maximize ? f.getConstantTerm() : -1 * f.getConstantTerm();\n\n                if (!restrictToNonNegative) {\n                    matrix[zIndex][getSlackVariableOffset() - 1] =\n                        getInvertedCoeffiecientSum(objectiveCoefficients);\n                }\n\n                \n                int slackVar = 0;\n                int artificialVar = 0;\n                for (int i = 0; i < constraints.size(); i++) {\n                    LinearConstraint constraint = constraints.get(i);\n                    int row = getNumObjectiveFunctions() + i;\n\n                    \n                    copyArray(constraint.getCoefficients().getData(), matrix[row], 1);\n\n                    \n                    if (!restrictToNonNegative) {\n                        matrix[row][getSlackVariableOffset() - 1] =\n                            getInvertedCoeffiecientSum(constraint.getCoefficients());\n                    }\n\n                    \n                    matrix[row][width - 1] = constraint.getValue();\n\n                    \n                    if (constraint.getRelationship() == Relationship.LEQ) {\n                        matrix[row][getSlackVariableOffset() + slackVar++] = 1;  \n                    } else if (constraint.getRelationship() == Relationship.GEQ) {\n                        matrix[row][getSlackVariableOffset() + slackVar++] = -1; \n                    }\n\n                    \n                    if ((constraint.getRelationship() == Relationship.EQ) ||\n                        (constraint.getRelationship() == Relationship.GEQ)) {\n                        matrix[0][getArtificialVariableOffset() + artificialVar] = 1; \n                        matrix[row][getArtificialVariableOffset() + artificialVar++] = 1; \n                    }\n                }\n\n                return matrix;\n    }\n\n    \n    public int getNumVariables() {\n        return f.getCoefficients().getDimension();\n    }\n\n    \n    public List<LinearConstraint> getNormalizedConstraints() {\n        List<LinearConstraint> normalized = new ArrayList<LinearConstraint>();\n        for (LinearConstraint constraint : constraints) {\n            normalized.add(normalize(constraint));\n        }\n        return normalized;\n    }\n\n    \n    private LinearConstraint normalize(final LinearConstraint constraint) {\n        if (constraint.getValue() < 0) {\n            return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1),\n                                        constraint.getRelationship().oppositeRelationship(),\n                                        -1 * constraint.getValue());\n        }\n        return new LinearConstraint(constraint.getCoefficients(), \n                                    constraint.getRelationship(), constraint.getValue());\n    }\n\n    \n    protected final int getNumObjectiveFunctions() {\n        return this.numArtificialVariables > 0 ? 2 : 1;\n    }\n\n    \n    private int getConstraintTypeCounts(final Relationship relationship) {\n        int count = 0;\n        for (final LinearConstraint constraint : constraints) {\n            if (constraint.getRelationship() == relationship) {\n                ++count;\n            }\n        }\n        return count;\n    }\n\n    \n    private void initialize() {\n        for (int artificialVar = 0; artificialVar < numArtificialVariables; artificialVar++) {\n            int row = getBasicRow(getArtificialVariableOffset() + artificialVar);\n            subtractRow(0, row, 1.0);\n        }\n    }\n\n    \n    protected static double getInvertedCoeffiecientSum(final RealVector coefficients) {\n        double sum = 0;\n        for (double coefficient : coefficients.getData()) {\n            sum -= coefficient;\n        }\n        return sum;\n    }\n\n    \n    private Integer getBasicRow(final int col) {\n        Integer row = null;\n        for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) {\n            if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {\n                if (row == null) {\n                    row = i;\n                } else {\n                    return null;\n                }\n            }\n        }\n        return row;\n    }\n\n    \n    protected void discardArtificialVariables() {\n        if (numArtificialVariables == 0) {\n            return;\n        }\n        int width = getWidth() - numArtificialVariables - 1;\n        int height = getHeight() - 1;\n        double[][] matrix = new double[height][width];\n        for (int i = 0; i < height; i++) {\n            for (int j = 0; j < width - 1; j++) {\n                matrix[i][j] = getEntry(i + 1, j + 1);\n            }\n            matrix[i][width - 1] = getEntry(i + 1, getRhsOffset());\n        }\n        this.tableau = new RealMatrixImpl(matrix);\n        this.numArtificialVariables = 0;\n    }\n\n\n    \n    private void copyArray(final double[] src, final double[] dest, final int destPos) {\n        System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length); \n    }\n\n    \n    protected RealPointValuePair getSolution() {\n        double[] coefficients = new double[getOriginalNumDecisionVariables()];\n        Integer basicRow =\n            getBasicRow(getNumObjectiveFunctions() + getOriginalNumDecisionVariables());\n        double mostNegative = basicRow == null ? 0 : getEntry(basicRow, getRhsOffset());\n        Set<Integer> basicRows = new HashSet<Integer>();\n        for (int i = 0; i < coefficients.length; i++) {\n            basicRow = getBasicRow(getNumObjectiveFunctions() + i);\n            if (basicRows.contains(basicRow)) {\n                \n                \n                coefficients[i] = 0;\n            } else {\n                basicRows.add(basicRow);\n                coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);\n            }\n        }\n        return new RealPointValuePair(coefficients, f.getValue(coefficients));\n    }\n\n    \n    protected void divideRow(final int dividendRow, final double divisor) {\n        for (int j = 0; j < getWidth(); j++) {\n            tableau.setEntry(dividendRow, j, tableau.getEntry(dividendRow, j) / divisor);\n        }\n    }\n\n    \n    protected void subtractRow(final int minuendRow, final int subtrahendRow, final double multiple) {\n        for (int j = 0; j < getWidth(); j++) {\n            tableau.setEntry(minuendRow, j, tableau.getEntry(minuendRow, j) -\n                             multiple * tableau.getEntry(subtrahendRow, j));\n        }\n    }\n\n    \n    protected final int getWidth() {\n        return tableau.getColumnDimension();\n    }\n\n    \n    protected final int getHeight() {\n        return tableau.getRowDimension();\n    }\n\n    \n    protected final double getEntry(final int row, final int column) {\n        return tableau.getEntry(row, column);\n    }\n\n    \n    protected final void setEntry(final int row, final int column, final double value) {\n        tableau.setEntry(row, column, value);\n    }\n\n    \n    protected final int getSlackVariableOffset() {\n        return getNumObjectiveFunctions() + numDecisionVariables;\n    }\n\n    \n    protected final int getArtificialVariableOffset() {\n        return getNumObjectiveFunctions() + numDecisionVariables + numSlackVariables;\n    }\n\n    \n    protected final int getRhsOffset() {\n        return getWidth() - 1;\n    }\n\n    \n    protected final int getNumDecisionVariables() {\n        return numDecisionVariables;\n    }\n\n    \n    protected final int getOriginalNumDecisionVariables() {\n        return restrictToNonNegative ? numDecisionVariables : numDecisionVariables - 1;\n    }\n\n    \n    protected final int getNumSlackVariables() {\n        return numSlackVariables;\n    }\n\n    \n    protected final int getNumArtificialVariables() {\n        return numArtificialVariables;\n    }\n\n    \n    protected final double[][] getData() {\n        return tableau.getData();\n    }\n\n    \n    @Override\n    public boolean equals(Object other) {\n\n      if (this == other) { \n        return true;\n      }\n\n      if (other == null) {\n        return false;\n      }\n\n      try {\n\n          SimplexTableau rhs = (SimplexTableau) other;\n          return (restrictToNonNegative  == rhs.restrictToNonNegative) &&\n                 (numDecisionVariables   == rhs.numDecisionVariables) &&\n                 (numSlackVariables      == rhs.numSlackVariables) &&\n                 (numArtificialVariables == rhs.numArtificialVariables) &&\n                 (epsilon                == rhs.epsilon) &&\n                 f.equals(rhs.f) &&\n                 constraints.equals(rhs.constraints) &&\n                 tableau.equals(rhs.tableau);\n\n      } catch (ClassCastException ex) {\n          \n          return false;\n      }\n\n    }\n    \n    \n    @Override\n    public int hashCode() {\n        return Boolean.valueOf(restrictToNonNegative).hashCode() ^\n               numDecisionVariables ^\n               numSlackVariables ^\n               numArtificialVariables ^\n               Double.valueOf(epsilon).hashCode() ^\n               f.hashCode() ^\n               constraints.hashCode() ^\n               tableau.hashCode();\n    }\n\n    \n    private void writeObject(ObjectOutputStream oos) throws IOException {\n        oos.defaultWriteObject();\n        MatrixUtils.serializeRealMatrix(tableau, oos);\n    }\n\n    \n    private void readObject(ObjectInputStream ois) throws ClassNotFoundException, IOException {\n        ois.defaultReadObject();\n        MatrixUtils.deserializeRealMatrix(this, \"tableau\", ois);\n    }\n}\n",
      "buggy_signatures": [
        "protected double[][] createTableau(final boolean maximize)",
        "public int getNumVariables()",
        "public List<LinearConstraint> getNormalizedConstraints()",
        "private LinearConstraint normalize(final LinearConstraint constraint)",
        "protected final int getNumObjectiveFunctions()",
        "private int getConstraintTypeCounts(final Relationship relationship)",
        "private void initialize()",
        "protected static double getInvertedCoeffiecientSum(final RealVector coefficients)",
        "private Integer getBasicRow(final int col)",
        "protected void discardArtificialVariables()",
        "private void copyArray(final double[] src, final double[] dest, final int destPos)",
        "protected RealPointValuePair getSolution()",
        "protected void divideRow(final int dividendRow, final double divisor)",
        "protected void subtractRow(final int minuendRow, final int subtrahendRow, final double multiple)",
        "protected final int getWidth()",
        "protected final int getHeight()",
        "protected final double getEntry(final int row, final int column)",
        "protected final void setEntry(final int row, final int column, final double value)",
        "protected final int getSlackVariableOffset()",
        "protected final int getArtificialVariableOffset()",
        "protected final int getRhsOffset()",
        "protected final int getNumDecisionVariables()",
        "protected final int getOriginalNumDecisionVariables()",
        "protected final int getNumSlackVariables()",
        "protected final int getNumArtificialVariables()",
        "protected final double[][] getData()",
        "public boolean equals(Object other)",
        "public int hashCode()",
        "private void writeObject(ObjectOutputStream oos) throws IOException",
        "private void readObject(ObjectInputStream ois) throws ClassNotFoundException, IOException"
      ],
      "fixed_signatures": [
        "protected double[][] createTableau(final boolean maximize)",
        "public int getNumVariables()",
        "public List<LinearConstraint> getNormalizedConstraints()",
        "private LinearConstraint normalize(final LinearConstraint constraint)",
        "protected final int getNumObjectiveFunctions()",
        "private int getConstraintTypeCounts(final Relationship relationship)",
        "private void initialize()",
        "protected static double getInvertedCoeffiecientSum(final RealVector coefficients)",
        "private Integer getBasicRow(final int col)",
        "protected void discardArtificialVariables()",
        "private void copyArray(final double[] src, final double[] dest, final int destPos)",
        "protected RealPointValuePair getSolution()",
        "protected void divideRow(final int dividendRow, final double divisor)",
        "protected void subtractRow(final int minuendRow, final int subtrahendRow, final double multiple)",
        "protected final int getWidth()",
        "protected final int getHeight()",
        "protected final double getEntry(final int row, final int column)",
        "protected final void setEntry(final int row, final int column, final double value)",
        "protected final int getSlackVariableOffset()",
        "protected final int getArtificialVariableOffset()",
        "protected final int getRhsOffset()",
        "protected final int getNumDecisionVariables()",
        "protected final int getOriginalNumDecisionVariables()",
        "protected final int getNumSlackVariables()",
        "protected final int getNumArtificialVariables()",
        "protected final double[][] getData()",
        "public boolean equals(Object other)",
        "public int hashCode()",
        "private void writeObject(ObjectOutputStream oos) throws IOException",
        "private void readObject(ObjectInputStream ois) throws ClassNotFoundException, IOException"
      ],
      "methods": [
        {
          "buggy_method": "  protected RealPointValuePair getSolution() {\n  double[] coefficients = new double[getOriginalNumDecisionVariables()];\n  Integer basicRow =\n  getBasicRow(getNumObjectiveFunctions() + getOriginalNumDecisionVariables());\n  double mostNegative = basicRow == null ? 0 : getEntry(basicRow, getRhsOffset());\n  for (int i = 0; i < coefficients.length; i++) {\n  basicRow = getBasicRow(getNumObjectiveFunctions() + i);\n  \n  \n  coefficients[i] =\n  (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n  (restrictToNonNegative ? 0 : mostNegative);\n  if (basicRow != null) {\n  for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n  if (tableau.getEntry(basicRow, j) == 1) {\n  coefficients[i] = 0;\n  }\n  }\n  }\n  }\n  return new RealPointValuePair(coefficients, f.getValue(coefficients));\n  }",
          "fixed_method": "  protected RealPointValuePair getSolution() {\n  double[] coefficients = new double[getOriginalNumDecisionVariables()];\n  Integer basicRow =\n  getBasicRow(getNumObjectiveFunctions() + getOriginalNumDecisionVariables());\n  double mostNegative = basicRow == null ? 0 : getEntry(basicRow, getRhsOffset());\n  Set<Integer> basicRows = new HashSet<Integer>();\n  for (int i = 0; i < coefficients.length; i++) {\n  basicRow = getBasicRow(getNumObjectiveFunctions() + i);\n  if (basicRows.contains(basicRow)) {\n  \n  \n  coefficients[i] = 0;\n  } else {\n  basicRows.add(basicRow);\n  coefficients[i] =\n  (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n  (restrictToNonNegative ? 0 : mostNegative);\n  }\n  }\n  return new RealPointValuePair(coefficients, f.getValue(coefficients));\n  }",
          "diff": [
            "@@ -326,19 +326,18 @@",
            "         Integer basicRow =\n",
            "             getBasicRow(getNumObjectiveFunctions() + getOriginalNumDecisionVariables());\n",
            "         double mostNegative = basicRow == null ? 0 : getEntry(basicRow, getRhsOffset());\n",
            "+        Set<Integer> basicRows = new HashSet<Integer>();\n",
            "         for (int i = 0; i < coefficients.length; i++) {\n",
            "             basicRow = getBasicRow(getNumObjectiveFunctions() + i);\n",
            "+            if (basicRows.contains(basicRow)) {\n",
            "                 // if multiple variables can take a given value \n",
            "                 // then we choose the first and set the rest equal to 0\n",
            "+                coefficients[i] = 0;\n",
            "+            } else {\n",
            "+                basicRows.add(basicRow);\n",
            "                 coefficients[i] =\n",
            "                     (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n",
            "                     (restrictToNonNegative ? 0 : mostNegative);\n",
            "-            if (basicRow != null) {\n",
            "-                for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n",
            "-                    if (tableau.getEntry(basicRow, j) == 1) {\n",
            "-                         coefficients[i] = 0;\n",
            "-                    }\n",
            "-                }\n",
            "             }\n",
            "         }\n",
            "         return new RealPointValuePair(coefficients, f.getValue(coefficients));\n"
          ],
          "changed_lines": 11
        }
      ]
    }
  ]
}
