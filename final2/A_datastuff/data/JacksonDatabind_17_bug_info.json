{
  "bug_id": "17",
  "failed_tests": {
    "com.fasterxml.jackson.databind.node.TestJsonNode": [
      {
        "methodName": "testArrayWithDefaultTyping",
        "error": "com.fasterxml.jackson.databind.JsonMappingException",
        "message": "Unexpected token (VALUE_NUMBER_INT), expected VALUE_STRING: need JSON String that contains type id (for subtype of com.fasterxml.jackson.databind.JsonNode)",
        "fail_line": "        JsonNode array = mapper.readTree(\"[ 1, 2 ]\");",
        "test_source": "  public void testArrayWithDefaultTyping() throws Exception {\n  ObjectMapper mapper = new ObjectMapper()\n  .enableDefaultTyping();\n\n  JsonNode array = mapper.readTree(\"[ 1, 2 ]\");\n  assertTrue(array.isArray());\n  assertEquals(2, array.size());\n\n  JsonNode obj = mapper.readTree(\"{ \\\"a\\\" : 2 }\");\n  assertTrue(obj.isObject());\n  assertEquals(1, obj.size());\n  assertEquals(2, obj.path(\"a\").asInt());\n  }",
        "stack": [
          "JsonMappingException.from line 148, DeserializationContext.wrongTokenException line 854, AsArrayTypeDeserializer._locateTypeId line 134, AsArrayTypeDeserializer._deserialize line 93, AsArrayTypeDeserializer.deserializeTypedFromAny line 68, BaseNodeDeserializer.deserializeWithType line 144, JsonNodeDeserializer.deserializeWithType line 14, TypeWrappedDeserializer.deserialize line 41, ObjectMapper._readMapAndClose line 3070, ObjectMapper.readTree line 1837, TestJsonNode.testArrayWithDefaultTyping line 114"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "com/fasterxml/jackson/databind/ObjectMapper.java",
      "buggy_full_code": "package com.fasterxml.jackson.databind;\n\nimport java.io.*;\nimport java.lang.reflect.Type;\nimport java.net.URL;\nimport java.text.DateFormat;\nimport java.util.*;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport com.fasterxml.jackson.annotation.*;\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.io.CharacterEscapes;\nimport com.fasterxml.jackson.core.io.SegmentedStringWriter;\nimport com.fasterxml.jackson.core.type.ResolvedType;\nimport com.fasterxml.jackson.core.type.TypeReference;\nimport com.fasterxml.jackson.core.util.*;\nimport com.fasterxml.jackson.databind.cfg.BaseSettings;\nimport com.fasterxml.jackson.databind.cfg.ContextAttributes;\nimport com.fasterxml.jackson.databind.cfg.HandlerInstantiator;\nimport com.fasterxml.jackson.databind.cfg.MapperConfig;\nimport com.fasterxml.jackson.databind.deser.*;\nimport com.fasterxml.jackson.databind.introspect.*;\nimport com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\nimport com.fasterxml.jackson.databind.jsontype.*;\nimport com.fasterxml.jackson.databind.jsontype.impl.StdSubtypeResolver;\nimport com.fasterxml.jackson.databind.jsontype.impl.StdTypeResolverBuilder;\nimport com.fasterxml.jackson.databind.node.*;\nimport com.fasterxml.jackson.databind.ser.*;\nimport com.fasterxml.jackson.databind.type.*;\nimport com.fasterxml.jackson.databind.util.RootNameLookup;\nimport com.fasterxml.jackson.databind.util.StdDateFormat;\nimport com.fasterxml.jackson.databind.util.TokenBuffer;\n\n\npublic class ObjectMapper extends ObjectCodec implements Versioned, java.io.Serializable { private static final long serialVersionUID = 1L; public enum DefaultTyping { JAVA_LANG_OBJECT, OBJECT_AND_NON_CONCRETE, NON_CONCRETE_AND_ARRAYS, NON_FINAL } public static class DefaultTypeResolverBuilder extends StdTypeResolverBuilder implements java.io.Serializable { private static final long serialVersionUID = 1L; protected final DefaultTyping _appliesFor; public DefaultTypeResolverBuilder(DefaultTyping t) {\n            _appliesFor = t;\n        }\n\n        @Override\n        public TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes) {\n            return useForType(baseType) ? super.buildTypeDeserializer(config, baseType, subtypes) : null;\n        }\n\n        @Override\n        public TypeSerializer buildTypeSerializer(SerializationConfig config, JavaType baseType, Collection<NamedType> subtypes) {\n            return useForType(baseType) ? super.buildTypeSerializer(config, baseType, subtypes) : null;            \n        }\n\n        \n        public boolean useForType(JavaType t) {\n            switch (_appliesFor) {\n            case NON_CONCRETE_AND_ARRAYS:\n                while (t.isArrayType()) {\n                    t = t.getContentType();\n                }\n                \n            case OBJECT_AND_NON_CONCRETE:\n\n                return (t.getRawClass() == Object.class)\n                        || (!t.isConcrete()\n                                \n                        || TreeNode.class.isAssignableFrom(t.getRawClass()));\n\n            case NON_FINAL:\n                while (t.isArrayType()) {\n                    t = t.getContentType();\n                }\n                \n                return !t.isFinal() && !TreeNode.class.isAssignableFrom(t.getRawClass());\n            default:\n            \n\n                return (t.getRawClass() == Object.class);\n            }\n        }\n    }\n\n    \n    \n    \n    private final static JavaType JSON_NODE_TYPE = SimpleType.constructUnsafe(JsonNode.class); protected final static ClassIntrospector DEFAULT_INTROSPECTOR = BasicClassIntrospector.instance; protected final static AnnotationIntrospector DEFAULT_ANNOTATION_INTROSPECTOR = new JacksonAnnotationIntrospector(); protected final static VisibilityChecker<?> STD_VISIBILITY_CHECKER = VisibilityChecker.Std.defaultInstance(); protected final static PrettyPrinter _defaultPrettyPrinter = new DefaultPrettyPrinter(); protected final static BaseSettings DEFAULT_BASE = new BaseSettings(DEFAULT_INTROSPECTOR, DEFAULT_ANNOTATION_INTROSPECTOR, STD_VISIBILITY_CHECKER, null, TypeFactory.defaultInstance(), null, StdDateFormat.instance, null, Locale.getDefault(), TimeZone.getTimeZone(\"GMT\"), Base64Variants.getDefaultVariant() ); protected final JsonFactory _jsonFactory; protected TypeFactory _typeFactory; protected InjectableValues _injectableValues; protected SubtypeResolver _subtypeResolver; protected final RootNameLookup _rootNames; protected final HashMap<ClassKey,Class<?>> _mixInAnnotations; protected SerializationConfig _serializationConfig; protected DefaultSerializerProvider _serializerProvider; protected SerializerFactory _serializerFactory; protected DeserializationConfig _deserializationConfig; protected DefaultDeserializationContext _deserializationContext; final protected ConcurrentHashMap<JavaType, JsonDeserializer<Object>> _rootDeserializers = new ConcurrentHashMap<JavaType, JsonDeserializer<Object>>(64, 0.6f, 2); public ObjectMapper() {\n        this(null, null, null);\n    }\n\n    \n    public ObjectMapper(JsonFactory jf) {\n        this(jf, null, null);\n    }\n\n    \n    protected ObjectMapper(ObjectMapper src) {\n        _jsonFactory = src._jsonFactory.copy();\n        _jsonFactory.setCodec(this);\n        _subtypeResolver = src._subtypeResolver;\n        _rootNames = new RootNameLookup();\n        _typeFactory = src._typeFactory;\n        HashMap<ClassKey,Class<?>> mixins = new HashMap<ClassKey,Class<?>>(src._mixInAnnotations);\n        _mixInAnnotations = mixins;\n        _serializationConfig = new SerializationConfig(src._serializationConfig, mixins);\n        _deserializationConfig = new DeserializationConfig(src._deserializationConfig, mixins);\n        _serializerProvider = src._serializerProvider.copy();\n        _deserializationContext = src._deserializationContext.copy();\n\n        \n        _serializerFactory = src._serializerFactory;\n    }\n    \n    \n    public ObjectMapper(JsonFactory jf, DefaultSerializerProvider sp, DefaultDeserializationContext dc) {\n        \n        if (jf == null) {\n            _jsonFactory = new MappingJsonFactory(this);\n        } else {\n            _jsonFactory = jf;\n            if (jf.getCodec() == null) { \n                _jsonFactory.setCodec(this);\n            }\n        }\n        _subtypeResolver = new StdSubtypeResolver();\n        _rootNames = new RootNameLookup();\n        \n        _typeFactory = TypeFactory.defaultInstance();\n\n        HashMap<ClassKey,Class<?>> mixins = new HashMap<ClassKey,Class<?>>();\n        _mixInAnnotations = mixins;\n        _serializationConfig = new SerializationConfig(DEFAULT_BASE,\n                    _subtypeResolver, mixins);\n        _deserializationConfig = new DeserializationConfig(DEFAULT_BASE,\n                    _subtypeResolver, mixins);\n\n        \n        final boolean needOrder = _jsonFactory.requiresPropertyOrdering();\n        if (needOrder ^ _serializationConfig.isEnabled(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY)) {\n            configure(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY, needOrder);\n        }\n        \n        _serializerProvider = (sp == null) ? new DefaultSerializerProvider.Impl() : sp;\n        _deserializationContext = (dc == null) ?\n                new DefaultDeserializationContext.Impl(BeanDeserializerFactory.instance) : dc;\n\n        \n        _serializerFactory = BeanSerializerFactory.instance;\n    }\n\n    \n    public ObjectMapper copy() {\n        _checkInvalidCopy(ObjectMapper.class);\n        return new ObjectMapper(this);\n    }\n\n    \n    protected void _checkInvalidCopy(Class<?> exp) {\n        if (getClass() != exp) {\n            throw new IllegalStateException(\"Failed copy(): \"+getClass().getName()\n                    +\" (version: \"+version()+\") does not override copy(); it has to\");\n        }\n    }\n    \n    \n    \n    \n    @Override\n    public Version version() {\n        return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION;\n    }\n    \n    \n\n    \n    public ObjectMapper registerModule(Module module) {\n        \n        String name = module.getModuleName();\n        if (name == null) {\n            throw new IllegalArgumentException(\"Module without defined name\");\n        }\n        Version version = module.version();\n        if (version == null) {\n            throw new IllegalArgumentException(\"Module without defined version\");\n        }\n\n        final ObjectMapper mapper = this;\n        \n        \n        module.setupModule(new Module.SetupContext()\n        {\n            \n\n            @Override\n            public Version getMapperVersion() {\n                return version();\n            }\n\n            @SuppressWarnings(\"unchecked\")\n            @Override\n            public <C extends ObjectCodec> C getOwner() {\n                \n                return (C) mapper;\n            }\n\n            @Override\n            public TypeFactory getTypeFactory() {\n                return _typeFactory;\n            }\n            \n            @Override\n            public boolean isEnabled(MapperFeature f) {\n                return mapper.isEnabled(f);\n            }\n\n            @Override\n            public boolean isEnabled(DeserializationFeature f) {\n                return mapper.isEnabled(f);\n            }\n            \n            @Override\n            public boolean isEnabled(SerializationFeature f) {\n                return mapper.isEnabled(f);\n            }\n\n            @Override\n            public boolean isEnabled(JsonFactory.Feature f) {\n                return mapper.isEnabled(f);\n            }\n\n            @Override\n            public boolean isEnabled(JsonParser.Feature f) {\n                return mapper.isEnabled(f);\n            }\n            \n            @Override\n            public boolean isEnabled(JsonGenerator.Feature f) {\n                return mapper.isEnabled(f);\n            }\n            \n            \n            \n            @Override\n            public void addDeserializers(Deserializers d) {\n                DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalDeserializers(d);\n                mapper._deserializationContext = mapper._deserializationContext.with(df);\n            }\n\n            @Override\n            public void addKeyDeserializers(KeyDeserializers d) {\n                DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalKeyDeserializers(d);\n                mapper._deserializationContext = mapper._deserializationContext.with(df);\n            }\n\n            @Override\n            public void addBeanDeserializerModifier(BeanDeserializerModifier modifier) {\n                DeserializerFactory df = mapper._deserializationContext._factory.withDeserializerModifier(modifier);\n                mapper._deserializationContext = mapper._deserializationContext.with(df);\n            }\n            \n            \n            \n            @Override\n            public void addSerializers(Serializers s) {\n                mapper._serializerFactory = mapper._serializerFactory.withAdditionalSerializers(s);\n            }\n\n            @Override\n            public void addKeySerializers(Serializers s) {\n                mapper._serializerFactory = mapper._serializerFactory.withAdditionalKeySerializers(s);\n            }\n            \n            @Override\n            public void addBeanSerializerModifier(BeanSerializerModifier modifier) {\n                mapper._serializerFactory = mapper._serializerFactory.withSerializerModifier(modifier);\n            }\n\n            \n            \n            @Override\n            public void addAbstractTypeResolver(AbstractTypeResolver resolver) {\n                DeserializerFactory df = mapper._deserializationContext._factory.withAbstractTypeResolver(resolver);\n                mapper._deserializationContext = mapper._deserializationContext.with(df);\n            }\n\n            @Override\n            public void addTypeModifier(TypeModifier modifier) {\n                TypeFactory f = mapper._typeFactory;\n                f = f.withModifier(modifier);\n                mapper.setTypeFactory(f);\n            }\n\n            @Override\n            public void addValueInstantiators(ValueInstantiators instantiators) {\n                DeserializerFactory df = mapper._deserializationContext._factory.withValueInstantiators(instantiators);\n                mapper._deserializationContext = mapper._deserializationContext.with(df);\n            }\n\n            @Override\n            public void setClassIntrospector(ClassIntrospector ci) {\n                mapper._deserializationConfig = mapper._deserializationConfig.with(ci);\n                mapper._serializationConfig = mapper._serializationConfig.with(ci);\n            }\n\n            @Override\n            public void insertAnnotationIntrospector(AnnotationIntrospector ai) {\n                mapper._deserializationConfig = mapper._deserializationConfig.withInsertedAnnotationIntrospector(ai);\n                mapper._serializationConfig = mapper._serializationConfig.withInsertedAnnotationIntrospector(ai);\n            }\n            \n            @Override\n            public void appendAnnotationIntrospector(AnnotationIntrospector ai) {\n                mapper._deserializationConfig = mapper._deserializationConfig.withAppendedAnnotationIntrospector(ai);\n                mapper._serializationConfig = mapper._serializationConfig.withAppendedAnnotationIntrospector(ai);\n            }\n\n            @Override\n            public void registerSubtypes(Class<?>... subtypes) {\n                mapper.registerSubtypes(subtypes);\n            }\n\n            @Override\n            public void registerSubtypes(NamedType... subtypes) {\n                mapper.registerSubtypes(subtypes);\n            }\n            \n            @Override\n            public void setMixInAnnotations(Class<?> target, Class<?> mixinSource) {\n                mapper.addMixInAnnotations(target, mixinSource);\n            }\n            \n            @Override\n            public void addDeserializationProblemHandler(DeserializationProblemHandler handler) {\n                mapper.addHandler(handler);\n            }\n\n            @Override\n            public void setNamingStrategy(PropertyNamingStrategy naming) {\n                mapper.setPropertyNamingStrategy(naming);\n            }\n        });\n        return this;\n    }\n\n    \n    public ObjectMapper registerModules(Module... modules) {\n        for (Module module : modules) {\n            registerModule(module);\n        }\n        return this;\n    }\n\n    \n    public ObjectMapper registerModules(Iterable<com.fasterxml.jackson.databind.Module> modules) {\n        for (Module module : modules) {\n            registerModule(module);\n        }\n        return this;\n    }\n    \n    \n    public static List<com.fasterxml.jackson.databind.Module> findModules() {\n        return findModules(null);\n    }\n\n    \n    public static List<com.fasterxml.jackson.databind.Module> findModules(ClassLoader classLoader) {\n        ArrayList<com.fasterxml.jackson.databind.Module> modules = new ArrayList<Module>();\n        ServiceLoader<com.fasterxml.jackson.databind.Module> loader = (classLoader == null) ?\n                ServiceLoader.load(Module.class) : ServiceLoader.load(Module.class, classLoader);\n        for (Module module : loader) {\n            modules.add(module);\n        }\n        return modules;\n    }\n\n    \n    public ObjectMapper findAndRegisterModules() {\n        return registerModules(findModules());\n    }\n    \n    \n\n    \n    public SerializationConfig getSerializationConfig() {\n        return _serializationConfig;\n    }\n\n    \n    public DeserializationConfig getDeserializationConfig() {\n        return _deserializationConfig;\n    }\n    \n    \n    public DeserializationContext getDeserializationContext() {\n        return _deserializationContext;\n    }\n\n    \n    \n    \n    public ObjectMapper setSerializerFactory(SerializerFactory f) {\n        _serializerFactory = f;\n        return this;\n    }\n\n    \n    public SerializerFactory getSerializerFactory() {\n        return _serializerFactory;\n    }\n\n    \n    public ObjectMapper setSerializerProvider(DefaultSerializerProvider p) {\n        _serializerProvider = p;\n        return this;\n    }\n\n    public SerializerProvider getSerializerProvider() {\n        return _serializerProvider;\n    }\n    \n    \n    \n    \n    public final void setMixInAnnotations(Map<Class<?>, Class<?>> sourceMixins) {\n        _mixInAnnotations.clear();\n        if (sourceMixins != null && sourceMixins.size() > 0) {\n            for (Map.Entry<Class<?>,Class<?>> en : sourceMixins.entrySet()) {\n                _mixInAnnotations.put(new ClassKey(en.getKey()), en.getValue());\n            }\n        }\n    }\n\n    \n    public final void addMixInAnnotations(Class<?> target, Class<?> mixinSource) {\n        _mixInAnnotations.put(new ClassKey(target), mixinSource);\n    }\n\n    \n    public final ObjectMapper addMixIn(Class<?> target, Class<?> mixinSource) {\n        _mixInAnnotations.put(new ClassKey(target), mixinSource);\n        return this;\n    }\n\n    public final Class<?> findMixInClassFor(Class<?> cls) {\n        return (_mixInAnnotations == null) ? null : _mixInAnnotations.get(new ClassKey(cls));\n    }\n\n    public final int mixInCount() {\n        return (_mixInAnnotations == null) ? 0 : _mixInAnnotations.size();\n    }\n    \n    \n\n    \n    public VisibilityChecker<?> getVisibilityChecker() {\n        return _serializationConfig.getDefaultVisibilityChecker();\n    }\n\n        \n    public void setVisibilityChecker(VisibilityChecker<?> vc) {\n        _deserializationConfig = _deserializationConfig.with(vc);\n        _serializationConfig = _serializationConfig.with(vc);\n    }\n\n    \n    public ObjectMapper setVisibility(PropertyAccessor forMethod, JsonAutoDetect.Visibility visibility) {\n        _deserializationConfig = _deserializationConfig.withVisibility(forMethod, visibility);\n        _serializationConfig = _serializationConfig.withVisibility(forMethod, visibility);\n        return this;\n    }\n    \n    \n    public SubtypeResolver getSubtypeResolver() {\n        return _subtypeResolver;\n    }\n\n    \n    public ObjectMapper setSubtypeResolver(SubtypeResolver str) {\n        _subtypeResolver = str;\n        _deserializationConfig = _deserializationConfig.with(str);\n        _serializationConfig = _serializationConfig.with(str);\n        return this;\n    }\n\n    \n    public ObjectMapper setAnnotationIntrospector(AnnotationIntrospector ai) {\n        _serializationConfig = _serializationConfig.with(ai);\n        _deserializationConfig = _deserializationConfig.with(ai);\n        return this;\n    }\n\n    \n    public ObjectMapper setAnnotationIntrospectors(AnnotationIntrospector serializerAI, AnnotationIntrospector deserializerAI) {\n        _serializationConfig = _serializationConfig.with(serializerAI);\n        _deserializationConfig = _deserializationConfig.with(deserializerAI);\n        return this;\n    }\n    \n    \n    public ObjectMapper setPropertyNamingStrategy(PropertyNamingStrategy s) {\n        _serializationConfig = _serializationConfig.with(s);\n        _deserializationConfig = _deserializationConfig.with(s);\n        return this;\n    }\n\n    \n    public ObjectMapper setSerializationInclusion(JsonInclude.Include incl) {\n        _serializationConfig = _serializationConfig.withSerializationInclusion(incl);\n        return this;\n    }\n    \n    \n\n    \n    public ObjectMapper enableDefaultTyping() {\n        return enableDefaultTyping(DefaultTyping.OBJECT_AND_NON_CONCRETE);\n    }\n\n    \n    public ObjectMapper enableDefaultTyping(DefaultTyping dti) {\n        return enableDefaultTyping(dti, JsonTypeInfo.As.WRAPPER_ARRAY);\n    }\n\n    \n    public ObjectMapper enableDefaultTyping(DefaultTyping applicability, JsonTypeInfo.As includeAs) {\n        TypeResolverBuilder<?> typer = new DefaultTypeResolverBuilder(applicability);\n        \n        typer = typer.init(JsonTypeInfo.Id.CLASS, null);\n        typer = typer.inclusion(includeAs);\n        return setDefaultTyping(typer);\n    }\n\n    \n    public ObjectMapper enableDefaultTypingAsProperty(DefaultTyping applicability, String propertyName) {\n        TypeResolverBuilder<?> typer = new DefaultTypeResolverBuilder(applicability);\n        \n        typer = typer.init(JsonTypeInfo.Id.CLASS, null);\n        typer = typer.inclusion(JsonTypeInfo.As.PROPERTY);\n        typer = typer.typeProperty(propertyName);\n        return setDefaultTyping(typer);\n    }\n    \n    \n    public ObjectMapper disableDefaultTyping() {\n        return setDefaultTyping(null);\n    }\n\n    \n    public ObjectMapper setDefaultTyping(TypeResolverBuilder<?> typer) {\n        _deserializationConfig = _deserializationConfig.with(typer);\n        _serializationConfig = _serializationConfig.with(typer);\n        return this;\n    }\n\n    \n    public void registerSubtypes(Class<?>... classes) {\n        getSubtypeResolver().registerSubtypes(classes);\n    }\n\n    \n    public void registerSubtypes(NamedType... types) {\n        getSubtypeResolver().registerSubtypes(types);\n    }\n\n    \n\n    \n    public TypeFactory getTypeFactory() {\n        return _typeFactory;\n    }\n\n    \n    public ObjectMapper setTypeFactory(TypeFactory f) {\n        _typeFactory = f;\n        _deserializationConfig = _deserializationConfig.with(f);\n        _serializationConfig = _serializationConfig.with(f);\n        return this;\n    }\n    \n    \n    public JavaType constructType(Type t) {\n        return _typeFactory.constructType(t);\n    }\n    \n    \n    \n    \n    public ObjectMapper setNodeFactory(JsonNodeFactory f) {\n        _deserializationConfig = _deserializationConfig.with(f);\n        return this;\n    }\n\n    \n    public ObjectMapper addHandler(DeserializationProblemHandler h) {\n        _deserializationConfig = _deserializationConfig.withHandler(h);\n        return this;\n    }\n\n    \n    public ObjectMapper clearProblemHandlers() {\n        _deserializationConfig = _deserializationConfig.withNoProblemHandlers();\n        return this;\n    }\n\n    \n    public ObjectMapper setConfig(DeserializationConfig config) {\n    \t_deserializationConfig = config;\n    \treturn this;\n    }\n    \n    \n\n    \n    public void setFilters(FilterProvider filterProvider) {\n        _serializationConfig = _serializationConfig.withFilters(filterProvider);\n    }\n\n    \n    public ObjectMapper setBase64Variant(Base64Variant v) {\n        _serializationConfig = _serializationConfig.with(v);\n        _deserializationConfig = _deserializationConfig.with(v);\n        return this;\n    }\n\n    \n    public ObjectMapper setConfig(SerializationConfig config) {\n    \t_serializationConfig = config;\n    \treturn this;\n    }\n    \n    \n\n    \n    @Override\n    public JsonFactory getFactory() { return _jsonFactory; }\n    \n    \n    @Deprecated\n    @Override\n    public JsonFactory getJsonFactory() { return getFactory(); }\n\n    \n    public ObjectMapper setDateFormat(DateFormat dateFormat) {\n        _deserializationConfig = _deserializationConfig.with(dateFormat);\n        _serializationConfig = _serializationConfig.with(dateFormat);\n        return this;\n    }\n\n    \n    public Object setHandlerInstantiator(HandlerInstantiator hi) {\n        _deserializationConfig = _deserializationConfig.with(hi);\n        _serializationConfig = _serializationConfig.with(hi);\n        return this;\n    }\n    \n    \n    public ObjectMapper setInjectableValues(InjectableValues injectableValues) {\n        _injectableValues = injectableValues;\n        return this;\n    }\n    \n    \n    public ObjectMapper setLocale(Locale l) {\n        _deserializationConfig = _deserializationConfig.with(l);\n        _serializationConfig = _serializationConfig.with(l);\n        return this;\n    }\n\n    \n    public ObjectMapper setTimeZone(TimeZone tz) {\n        _deserializationConfig = _deserializationConfig.with(tz);\n        _serializationConfig = _serializationConfig.with(tz);\n        return this;\n    }\n    \n    \n\n    \n    public ObjectMapper configure(MapperFeature f, boolean state) {\n        _serializationConfig = state ?\n                _serializationConfig.with(f) : _serializationConfig.without(f);\n        _deserializationConfig = state ?\n                _deserializationConfig.with(f) : _deserializationConfig.without(f);\n        return this;\n    }\n    \n    \n    public ObjectMapper configure(SerializationFeature f, boolean state) {\n        _serializationConfig = state ?\n                _serializationConfig.with(f) : _serializationConfig.without(f);\n        return this;\n    }\n\n    \n    public ObjectMapper configure(DeserializationFeature f, boolean state) {\n        _deserializationConfig = state ?\n                _deserializationConfig.with(f) : _deserializationConfig.without(f);\n        return this;\n    }\n\n    \n    public ObjectMapper configure(JsonParser.Feature f, boolean state) {\n        _jsonFactory.configure(f, state);\n        return this;\n    }\n\n    \n    public ObjectMapper configure(JsonGenerator.Feature f, boolean state) {\n        _jsonFactory.configure(f, state);\n        return this;\n    }\n\n    \n    public ObjectMapper enable(MapperFeature... f) {\n        _deserializationConfig = _deserializationConfig.with(f);\n        _serializationConfig = _serializationConfig.with(f);\n        return this;\n    }\n\n    \n    public ObjectMapper disable(MapperFeature... f) {\n        _deserializationConfig = _deserializationConfig.without(f);\n        _serializationConfig = _serializationConfig.without(f);\n        return this;\n    }\n    \n    \n    public ObjectMapper enable(DeserializationFeature feature) {\n        _deserializationConfig = _deserializationConfig.with(feature);\n        return this;\n    }\n\n    \n    public ObjectMapper enable(DeserializationFeature first, DeserializationFeature... f) {\n        _deserializationConfig = _deserializationConfig.with(first, f);\n        return this;\n    }\n    \n    \n    public ObjectMapper disable(DeserializationFeature feature) {\n        _deserializationConfig = _deserializationConfig.without(feature);\n        return this;\n    }\n\n    \n    public ObjectMapper disable(DeserializationFeature first, DeserializationFeature... f) {\n        _deserializationConfig = _deserializationConfig.without(first, f);\n        return this;\n    }\n    \n    \n    public ObjectMapper enable(SerializationFeature f) {\n        _serializationConfig = _serializationConfig.with(f);\n        return this;\n    }\n\n    \n    public ObjectMapper enable(SerializationFeature first, SerializationFeature... f) {\n        _serializationConfig = _serializationConfig.with(first, f);\n        return this;\n    }\n    \n    \n    public ObjectMapper disable(SerializationFeature f) {\n        _serializationConfig = _serializationConfig.without(f);\n        return this;\n    }\n\n    \n    public ObjectMapper disable(SerializationFeature first, SerializationFeature... f) {\n        _serializationConfig = _serializationConfig.without(first, f);\n        return this;\n    }\n\n    \n    public boolean isEnabled(MapperFeature f) {\n        \n        return _serializationConfig.isEnabled(f);\n    }\n\n    \n    public boolean isEnabled(SerializationFeature f) {\n        return _serializationConfig.isEnabled(f);\n    }\n    \n    \n    public boolean isEnabled(DeserializationFeature f) {\n        return _deserializationConfig.isEnabled(f);\n    }\n\n    \n    public boolean isEnabled(JsonFactory.Feature f) {\n        return _jsonFactory.isEnabled(f);\n    }\n\n    \n    public boolean isEnabled(JsonParser.Feature f) {\n        return _jsonFactory.isEnabled(f);\n    }\n    \n    \n    public boolean isEnabled(JsonGenerator.Feature f) {\n        return _jsonFactory.isEnabled(f);\n    }\n    \n    \n    public JsonNodeFactory getNodeFactory() {\n        return _deserializationConfig.getNodeFactory();\n    }\n\n    \n\n    \n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(JsonParser jp, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readValue(getDeserializationConfig(), jp, _typeFactory.constructType(valueType));\n    } \n\n    \n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(JsonParser jp, TypeReference<?> valueTypeRef) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readValue(getDeserializationConfig(), jp, _typeFactory.constructType(valueTypeRef));\n    }\n\n    \n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public final <T> T readValue(JsonParser jp, ResolvedType valueType) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readValue(getDeserializationConfig(), jp, (JavaType) valueType);\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(JsonParser jp, JavaType valueType) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readValue(getDeserializationConfig(), jp, valueType);\n    }\n    \n    \n    @Override\n    public <T extends TreeNode> T readTree(JsonParser jp) throws IOException, JsonProcessingException {\n        \n        \n        DeserializationConfig cfg = getDeserializationConfig();\n        JsonToken t = jp.getCurrentToken();\n        if (t == null) {\n            t = jp.nextToken();\n            if (t == null) {\n                return null;\n            }\n        }\n        JsonNode n = (JsonNode) _readValue(cfg, jp, JSON_NODE_TYPE);\n        if (n == null) {\n            n = getNodeFactory().nullNode();\n        }\n        @SuppressWarnings(\"unchecked\")\n        T result = (T) n;\n        return result;\n    }\n\n    \n    @Override\n    public <T> MappingIterator<T> readValues(JsonParser jp, ResolvedType valueType) throws IOException, JsonProcessingException {\n        return readValues(jp, (JavaType) valueType);\n    }\n\n    \n    public <T> MappingIterator<T> readValues(JsonParser jp, JavaType valueType) throws IOException, JsonProcessingException {\n        DeserializationConfig config = getDeserializationConfig();\n        DeserializationContext ctxt = createDeserializationContext(jp, config);\n        JsonDeserializer<?> deser = _findRootDeserializer(ctxt, valueType);\n        \n        return new MappingIterator<T>(valueType, jp, ctxt, deser,\n                false, null);\n    }\n\n    \n    @Override\n    public <T> MappingIterator<T> readValues(JsonParser jp, Class<T> valueType) throws IOException, JsonProcessingException {\n        return readValues(jp, _typeFactory.constructType(valueType));\n    }\n\n    \n    @Override\n    public <T> MappingIterator<T> readValues(JsonParser jp, TypeReference<?> valueTypeRef) throws IOException, JsonProcessingException {\n        return readValues(jp, _typeFactory.constructType(valueTypeRef));\n    }\n    \n    \n\n    \n    public JsonNode readTree(InputStream in) throws IOException, JsonProcessingException {\n        JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(in), JSON_NODE_TYPE);\n        return (n == null) ? NullNode.instance : n;\n    }\n\n    \n    public JsonNode readTree(Reader r) throws IOException, JsonProcessingException {\n        JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(r), JSON_NODE_TYPE);\n        return (n == null) ? NullNode.instance : n;\n    }\n\n    \n    public JsonNode readTree(String content) throws IOException, JsonProcessingException {\n        JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(content), JSON_NODE_TYPE);\n        return (n == null) ? NullNode.instance : n;\n    }\n\n    \n    public JsonNode readTree(byte[] content) throws IOException, JsonProcessingException {\n        JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(content), JSON_NODE_TYPE);\n        return (n == null) ? NullNode.instance : n;\n    }\n    \n    \n    public JsonNode readTree(File file) throws IOException, JsonProcessingException {\n        JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(file), JSON_NODE_TYPE);\n        return (n == null) ? NullNode.instance : n;\n    }\n\n    \n    public JsonNode readTree(URL source) throws IOException, JsonProcessingException {\n        JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(source), JSON_NODE_TYPE);\n        return (n == null) ? NullNode.instance : n;\n    }\n\n    \n\n    \n    @Override\n    public void writeValue(JsonGenerator jgen, Object value) throws IOException, JsonGenerationException, JsonMappingException {\n        SerializationConfig config = getSerializationConfig();\n        \n        if (config.isEnabled(SerializationFeature.INDENT_OUTPUT)) {\n            jgen.useDefaultPrettyPrinter();\n        }\n        if (config.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) {\n            _writeCloseableValue(jgen, value, config);\n        } else {\n            _serializerProvider(config).serializeValue(jgen, value);\n            if (config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) {\n                jgen.flush();\n            }\n        }\n    }\n\n    \n\n    @Override\n    public void writeTree(JsonGenerator jgen, TreeNode rootNode) throws IOException, JsonProcessingException {\n        SerializationConfig config = getSerializationConfig();\n        _serializerProvider(config).serializeValue(jgen, rootNode);\n        if (config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) {\n            jgen.flush();\n        }\n    }\n    \n    \n    public void writeTree(JsonGenerator jgen, JsonNode rootNode) throws IOException, JsonProcessingException {\n        SerializationConfig config = getSerializationConfig();\n        _serializerProvider(config).serializeValue(jgen, rootNode);\n        if (config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) {\n            jgen.flush();\n        }\n    }\n    \n    \n    @Override    \n    public ObjectNode createObjectNode() {\n        return _deserializationConfig.getNodeFactory().objectNode();\n    }\n\n    \n    @Override\n    public ArrayNode createArrayNode() {\n        return _deserializationConfig.getNodeFactory().arrayNode();\n    }\n\n    \n    @Override\n    public JsonParser treeAsTokens(TreeNode n) {\n        return new TreeTraversingParser((JsonNode) n, this);\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public <T> T treeToValue(TreeNode n, Class<T> valueType) throws JsonProcessingException {\n        try {\n            \n            \n            if (valueType != Object.class && valueType.isAssignableFrom(n.getClass())) {\n                return (T) n;\n            }\n            return readValue(treeAsTokens(n), valueType);\n        } catch (JsonProcessingException e) {\n            throw e;\n        } catch (IOException e) { \n            throw new IllegalArgumentException(e.getMessage(), e);\n        }\n    }\n\n    \n    @SuppressWarnings({ \"unchecked\", \"resource\" })\n    public <T extends JsonNode> T valueToTree(Object fromValue) throws IllegalArgumentException {\n        if (fromValue == null) return null;\n        TokenBuffer buf = new TokenBuffer(this, false);\n        JsonNode result;\n        try {\n            writeValue(buf, fromValue);\n            JsonParser jp = buf.asParser();\n            result = readTree(jp);\n            jp.close();\n        } catch (IOException e) { \n            throw new IllegalArgumentException(e.getMessage(), e);\n        }\n        return (T) result;\n    } \n    \n    \n\n    \n    public boolean canSerialize(Class<?> type) {\n        return _serializerProvider(getSerializationConfig()).hasSerializerFor(type, null);\n    }\n\n    \n    public boolean canSerialize(Class<?> type, AtomicReference<Throwable> cause) {\n        return _serializerProvider(getSerializationConfig()).hasSerializerFor(type, cause);\n    }\n    \n    \n    public boolean canDeserialize(JavaType type) {\n        return createDeserializationContext(null,\n                getDeserializationConfig()).hasValueDeserializerFor(type, null);\n    }\n\n    \n    public boolean canDeserialize(JavaType type, AtomicReference<Throwable> cause) {\n        return createDeserializationContext(null,\n                getDeserializationConfig()).hasValueDeserializerFor(type, cause);\n    }\n    \n    \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(File src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueType));\n    } \n\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(File src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueTypeRef));\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(File src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType);\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(URL src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException {\n     \n\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueType));\n    } \n\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(URL src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueTypeRef));\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(URL src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType);\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(String content, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException {\n     \n\n        return (T) _readMapAndClose(_jsonFactory.createParser(content), _typeFactory.constructType(valueType));\n    } \n\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(String content, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(content), _typeFactory.constructType(valueTypeRef));\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(String content, JavaType valueType) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(content), valueType);\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(Reader src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException {\n     \n\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueType));\n    } \n\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(Reader src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueTypeRef));\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(Reader src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType);\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(InputStream src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException {\n     \n\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueType));\n    } \n\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(InputStream src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueTypeRef));\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(InputStream src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType);\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(byte[] src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException {\n     \n\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueType));\n    } \n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(byte[] src, int offset, int len, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException {\n     \n\n        return (T) _readMapAndClose(_jsonFactory.createParser(src, offset, len), _typeFactory.constructType(valueType));\n    } \n\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(byte[] src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueTypeRef));\n    } \n    \n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(byte[] src, int offset, int len, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src, offset, len), _typeFactory.constructType(valueTypeRef));\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(byte[] src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType);\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(byte[] src, int offset, int len, JavaType valueType) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src, offset, len), valueType);\n    } \n    \n    \n\n    \n    public void writeValue(File resultFile, Object value) throws IOException, JsonGenerationException, JsonMappingException {\n        _configAndWriteValue(_jsonFactory.createGenerator(resultFile, JsonEncoding.UTF8), value);\n    }\n\n    \n    public void writeValue(OutputStream out, Object value) throws IOException, JsonGenerationException, JsonMappingException {\n        _configAndWriteValue(_jsonFactory.createGenerator(out, JsonEncoding.UTF8), value);\n    }\n\n    \n    public void writeValue(Writer w, Object value) throws IOException, JsonGenerationException, JsonMappingException {\n        _configAndWriteValue(_jsonFactory.createGenerator(w), value);\n    }\n\n    \n    @SuppressWarnings(\"resource\")\n    public String writeValueAsString(Object value) throws JsonProcessingException {        \n        \n        SegmentedStringWriter sw = new SegmentedStringWriter(_jsonFactory._getBufferRecycler());\n        try {\n            _configAndWriteValue(_jsonFactory.createGenerator(sw), value);\n        } catch (JsonProcessingException e) { \n            throw e;\n        } catch (IOException e) { \n            throw JsonMappingException.fromUnexpectedIOE(e);\n        }\n        return sw.getAndClear();\n    }\n    \n    \n    @SuppressWarnings(\"resource\")\n    public byte[] writeValueAsBytes(Object value) throws JsonProcessingException {\n        ByteArrayBuilder bb = new ByteArrayBuilder(_jsonFactory._getBufferRecycler());\n        try {\n            _configAndWriteValue(_jsonFactory.createGenerator(bb, JsonEncoding.UTF8), value);\n        } catch (JsonProcessingException e) { \n            throw e;\n        } catch (IOException e) { \n            throw JsonMappingException.fromUnexpectedIOE(e);\n        }\n        byte[] result = bb.toByteArray();\n        bb.release();\n        return result;\n    }\n\n    \n\n    \n    public ObjectWriter writer() {\n        return new ObjectWriter(this, getSerializationConfig());\n    }\n\n    \n    public ObjectWriter writer(SerializationFeature feature) {\n        return new ObjectWriter(this, getSerializationConfig().with(feature));\n    }\n\n    \n    public ObjectWriter writer(SerializationFeature first, SerializationFeature... other) {\n        return new ObjectWriter(this, getSerializationConfig().with(first, other));\n    }\n    \n    \n    public ObjectWriter writer(DateFormat df) {\n        return new ObjectWriter(this, getSerializationConfig().with(df));\n    }\n    \n    \n    public ObjectWriter writerWithView(Class<?> serializationView) {\n        return new ObjectWriter(this, getSerializationConfig().withView(serializationView));\n    }\n    \n    \n    public ObjectWriter writerWithType(Class<?> rootType) {\n        return new ObjectWriter(this, getSerializationConfig(),\n                \n                ((rootType == null) ? null :_typeFactory.constructType(rootType)),\n                null);\n    }\n\n    \n    public ObjectWriter writerWithType(TypeReference<?> rootType) {\n        return new ObjectWriter(this, getSerializationConfig(),\n                \n                ((rootType == null) ? null : _typeFactory.constructType(rootType)),\n                null);\n    }\n\n    \n    public ObjectWriter writerWithType(JavaType rootType) {\n        return new ObjectWriter(this, getSerializationConfig(), rootType, null);\n    }\n    \n    \n    public ObjectWriter writer(PrettyPrinter pp) {\n        if (pp == null) { \n            pp = ObjectWriter.NULL_PRETTY_PRINTER;\n        }\n        return new ObjectWriter(this, getSerializationConfig(),  null, pp);\n    }\n    \n    \n    public ObjectWriter writerWithDefaultPrettyPrinter() {\n        return new ObjectWriter(this, getSerializationConfig(),\n                 null, _defaultPrettyPrinter());\n    }\n    \n    \n    public ObjectWriter writer(FilterProvider filterProvider) {\n        return new ObjectWriter(this,\n                getSerializationConfig().withFilters(filterProvider));\n    }\n    \n    \n    public ObjectWriter writer(FormatSchema schema) {\n        _verifySchemaType(schema);\n        return new ObjectWriter(this, getSerializationConfig(), schema);\n    }\n\n    \n    public ObjectWriter writer(Base64Variant defaultBase64) {\n        return new ObjectWriter(this, getSerializationConfig().with(defaultBase64));\n    }\n\n    \n    public ObjectWriter writer(CharacterEscapes escapes) {\n        return writer().with(escapes);\n    }\n\n    \n    public ObjectWriter writer(ContextAttributes attrs) {\n        return new ObjectWriter(this, getSerializationConfig().with(attrs));\n    }\n    \n    \n\n    \n    public ObjectReader reader() {\n        return new ObjectReader(this, getDeserializationConfig())\n            .with(_injectableValues);\n    }\n\n    \n    public ObjectReader reader(DeserializationFeature feature) {\n        return new ObjectReader(this, getDeserializationConfig().with(feature));\n    }\n\n    \n    public ObjectReader reader(DeserializationFeature first, DeserializationFeature... other) {\n        return new ObjectReader(this, getDeserializationConfig().with(first, other));\n    }\n    \n    \n    public ObjectReader readerForUpdating(Object valueToUpdate) {\n        JavaType t = _typeFactory.constructType(valueToUpdate.getClass());\n        return new ObjectReader(this, getDeserializationConfig(), t, valueToUpdate,\n                null, _injectableValues);\n    }\n\n    \n    public ObjectReader reader(JavaType type) {\n        return new ObjectReader(this, getDeserializationConfig(), type, null,\n                null, _injectableValues);\n    }\n\n    \n    public ObjectReader reader(Class<?> type) {\n        return reader(_typeFactory.constructType(type));\n    }\n\n    \n    public ObjectReader reader(TypeReference<?> type) {\n        return reader(_typeFactory.constructType(type));\n    }\n\n    \n    public ObjectReader reader(JsonNodeFactory f) {\n        return new ObjectReader(this, getDeserializationConfig()).with(f);\n    }\n\n    \n    public ObjectReader reader(FormatSchema schema) {\n        _verifySchemaType(schema);\n        return new ObjectReader(this, getDeserializationConfig(), null, null,\n                schema, _injectableValues);\n    }\n\n    \n    public ObjectReader reader(InjectableValues injectableValues) {\n        return new ObjectReader(this, getDeserializationConfig(), null, null,\n                null, injectableValues);\n    }\n\n    \n    public ObjectReader readerWithView(Class<?> view) {\n        return new ObjectReader(this, getDeserializationConfig().withView(view));\n    }\n\n    \n    public ObjectReader reader(Base64Variant defaultBase64) {\n        return new ObjectReader(this, getDeserializationConfig().with(defaultBase64));\n    }\n\n    \n    public ObjectReader reader(ContextAttributes attrs) {\n        return new ObjectReader(this, getDeserializationConfig().with(attrs));\n    }\n    \n    \n   \n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T convertValue(Object fromValue, Class<T> toValueType) throws IllegalArgumentException {\n        \n        if (fromValue == null) return null;\n        return (T) _convert(fromValue, _typeFactory.constructType(toValueType));\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T convertValue(Object fromValue, TypeReference<?> toValueTypeRef) throws IllegalArgumentException {\n        return (T) convertValue(fromValue, _typeFactory.constructType(toValueTypeRef));\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T convertValue(Object fromValue, JavaType toValueType) throws IllegalArgumentException {\n        \n        if (fromValue == null) return null;\n        return (T) _convert(fromValue, toValueType);\n    } \n\n    \n    @SuppressWarnings(\"resource\")\n    protected Object _convert(Object fromValue, JavaType toValueType) throws IllegalArgumentException {        \n        \n        \n        Class<?> targetType = toValueType.getRawClass();\n        if (targetType != Object.class\n                && !toValueType.hasGenericTypes()\n                && targetType.isAssignableFrom(fromValue.getClass())) {\n            return fromValue;\n        }\n        \n        \n        TokenBuffer buf = new TokenBuffer(this, false);\n        try {\n            \n            \n            SerializationConfig config = getSerializationConfig().without(SerializationFeature.WRAP_ROOT_VALUE);\n            \n            _serializerProvider(config).serializeValue(buf, fromValue);\n\n            \n            final JsonParser jp = buf.asParser();\n            Object result;\n            \n            final DeserializationConfig deserConfig = getDeserializationConfig();\n            JsonToken t = _initForReading(jp);\n            if (t == JsonToken.VALUE_NULL) {\n                DeserializationContext ctxt = createDeserializationContext(jp, deserConfig);\n                result = _findRootDeserializer(ctxt, toValueType).getNullValue();\n            } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {\n                result = null;\n            } else { \n                DeserializationContext ctxt = createDeserializationContext(jp, deserConfig);\n                JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, toValueType);\n                \n                result = deser.deserialize(jp, ctxt);\n            }\n            jp.close();\n            return result;\n        } catch (IOException e) { \n            throw new IllegalArgumentException(e.getMessage(), e);\n        }\n    }\n\n    \n\n    \n    @SuppressWarnings(\"deprecation\")\n    public com.fasterxml.jackson.databind.jsonschema.JsonSchema generateJsonSchema(Class<?> t) throws JsonMappingException {\n        return _serializerProvider(getSerializationConfig()).generateJsonSchema(t);\n    }\n\n    \n    public void acceptJsonFormatVisitor(Class<?> type, JsonFormatVisitorWrapper visitor) throws JsonMappingException {\n        acceptJsonFormatVisitor(_typeFactory.constructType(type), visitor);\n    }\n    \n    \n    public void acceptJsonFormatVisitor(JavaType type, JsonFormatVisitorWrapper visitor) throws JsonMappingException {\n        if (type == null) {\n            throw new IllegalArgumentException(\"type must be provided\");\n        }\n        _serializerProvider(getSerializationConfig()).acceptJsonFormatVisitor(type, visitor);\n    }\n    \n    \n\n    \n    protected DefaultSerializerProvider _serializerProvider(SerializationConfig config) {\n        return _serializerProvider.createInstance(config, _serializerFactory);\n    }\n    \n    \n    protected PrettyPrinter _defaultPrettyPrinter() {\n        return _defaultPrettyPrinter;\n    }\n    \n    \n    protected final void _configAndWriteValue(JsonGenerator jgen, Object value) throws IOException, JsonGenerationException, JsonMappingException {\n        SerializationConfig cfg = getSerializationConfig();\n        \n        if (cfg.isEnabled(SerializationFeature.INDENT_OUTPUT)) {\n            jgen.useDefaultPrettyPrinter();\n        }\n        \n        if (cfg.isEnabled(SerializationFeature.WRITE_BIGDECIMAL_AS_PLAIN)) {\n            jgen.enable(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN);\n        }\n        \n        if (cfg.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) {\n            _configAndWriteCloseable(jgen, value, cfg);\n            return;\n        }\n        boolean closed = false;\n        try {\n            _serializerProvider(cfg).serializeValue(jgen, value);\n            closed = true;\n            jgen.close();\n        } finally {\n            \n            if (!closed) {\n                \n                jgen.disable(JsonGenerator.Feature.AUTO_CLOSE_JSON_CONTENT);\n                try {\n                    jgen.close();\n                } catch (IOException ioe) { }\n            }\n        }\n    }\n\n    protected final void _configAndWriteValue(JsonGenerator jgen, Object value, Class<?> viewClass) throws IOException, JsonGenerationException, JsonMappingException {\n        SerializationConfig cfg = getSerializationConfig().withView(viewClass);\n        if (cfg.isEnabled(SerializationFeature.INDENT_OUTPUT)) {\n            jgen.useDefaultPrettyPrinter();\n        }\n        \n        if (cfg.isEnabled(SerializationFeature.WRITE_BIGDECIMAL_AS_PLAIN)) {\n            jgen.enable(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN);\n        }\n\n        \n        if (cfg.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) {\n            _configAndWriteCloseable(jgen, value, cfg);\n            return;\n        }\n        boolean closed = false;\n        try {\n            _serializerProvider(cfg).serializeValue(jgen, value);\n            closed = true;\n            jgen.close();\n        } finally {\n            if (!closed) {\n                \n                \n                jgen.disable(JsonGenerator.Feature.AUTO_CLOSE_JSON_CONTENT);\n                try {\n                    jgen.close();\n                } catch (IOException ioe) { }\n            }\n        }\n    }\n\n    \n    private final void _configAndWriteCloseable(JsonGenerator jgen, Object value, SerializationConfig cfg) throws IOException, JsonGenerationException, JsonMappingException {\n        Closeable toClose = (Closeable) value;\n        try {\n            _serializerProvider(cfg).serializeValue(jgen, value);\n            JsonGenerator tmpJgen = jgen;\n            jgen = null;\n            tmpJgen.close();\n            Closeable tmpToClose = toClose;\n            toClose = null;\n            tmpToClose.close();\n        } finally {\n            \n            if (jgen != null) {\n                \n                \n                jgen.disable(JsonGenerator.Feature.AUTO_CLOSE_JSON_CONTENT);\n                try {\n                    jgen.close();\n                } catch (IOException ioe) { }\n            }\n            if (toClose != null) {\n                try {\n                    toClose.close();\n                } catch (IOException ioe) { }\n            }\n        }\n    }\n    \n    \n    private final void _writeCloseableValue(JsonGenerator jgen, Object value, SerializationConfig cfg) throws IOException, JsonGenerationException, JsonMappingException {\n        Closeable toClose = (Closeable) value;\n        try {\n            _serializerProvider(cfg).serializeValue(jgen, value);\n            if (cfg.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) {\n                jgen.flush();\n            }\n            Closeable tmpToClose = toClose;\n            toClose = null;\n            tmpToClose.close();\n        } finally {\n            if (toClose != null) {\n                try {\n                    toClose.close();\n                } catch (IOException ioe) { }\n            }\n        }\n    }\n    \n    \n\n    \n    protected DefaultDeserializationContext createDeserializationContext(JsonParser jp, DeserializationConfig cfg) {\n        return _deserializationContext.createInstance(cfg,\n                jp, _injectableValues);\n    }\n    \n    \n    protected Object _readValue(DeserializationConfig cfg, JsonParser jp, JavaType valueType) throws IOException, JsonParseException, JsonMappingException {\n        \n        Object result;\n        JsonToken t = _initForReading(jp);\n        if (t == JsonToken.VALUE_NULL) {\n            \n            DeserializationContext ctxt = createDeserializationContext(jp, cfg);\n            result = _findRootDeserializer(ctxt, valueType).getNullValue();\n        } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {\n            result = null;\n        } else { \n            DeserializationContext ctxt = createDeserializationContext(jp, cfg);\n            JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, valueType);\n            \n            if (cfg.useRootWrapping()) {\n                result = _unwrapAndDeserialize(jp, ctxt, cfg, valueType, deser);\n            } else {\n                result = deser.deserialize(jp, ctxt);\n            }\n        }\n        \n        jp.clearCurrentToken();\n        return result;\n    }\n    \n    protected Object _readMapAndClose(JsonParser jp, JavaType valueType) throws IOException, JsonParseException, JsonMappingException {\n        try {\n            Object result;\n            JsonToken t = _initForReading(jp);\n            if (t == JsonToken.VALUE_NULL) {\n                \n                DeserializationContext ctxt = createDeserializationContext(jp,\n                        getDeserializationConfig());\n                result = _findRootDeserializer(ctxt, valueType).getNullValue();\n            } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {\n                result = null;\n            } else {\n                DeserializationConfig cfg = getDeserializationConfig();\n                DeserializationContext ctxt = createDeserializationContext(jp, cfg);\n                JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, valueType);\n                if (cfg.useRootWrapping()) {\n                    result = _unwrapAndDeserialize(jp, ctxt, cfg, valueType, deser);\n                } else {\n                    result = deser.deserialize(jp, ctxt);\n                }\n                ctxt.checkUnresolvedObjectId();\n            }\n            \n            jp.clearCurrentToken();\n            return result;\n        } finally {\n            try {\n                jp.close();\n            } catch (IOException ioe) { }\n        }\n    }\n    \n    \n    protected JsonToken _initForReading(JsonParser jp) throws IOException, JsonParseException, JsonMappingException {\n        \n        JsonToken t = jp.getCurrentToken();\n        if (t == null) {\n            \n            t = jp.nextToken();\n            if (t == null) {\n                \n                throw JsonMappingException.from(jp, \"No content to map due to end-of-input\");\n            }\n        }\n        return t;\n    }\n\n    protected Object _unwrapAndDeserialize(JsonParser jp, DeserializationContext ctxt, DeserializationConfig config, JavaType rootType, JsonDeserializer<Object> deser) throws IOException, JsonParseException, JsonMappingException {\n        String expName = config.getRootName();\n        if (expName == null) {\n            PropertyName pname = _rootNames.findRootName(rootType, config);\n            expName = pname.getSimpleName();\n        }\n        if (jp.getCurrentToken() != JsonToken.START_OBJECT) {\n            throw JsonMappingException.from(jp, \"Current token not START_OBJECT (needed to unwrap root name '\"\n                    +expName+\"'), but \"+jp.getCurrentToken());\n        }\n        if (jp.nextToken() != JsonToken.FIELD_NAME) {\n            throw JsonMappingException.from(jp, \"Current token not FIELD_NAME (to contain expected root name '\"\n                    +expName+\"'), but \"+jp.getCurrentToken());\n        }\n        String actualName = jp.getCurrentName();\n        if (!expName.equals(actualName)) {\n            throw JsonMappingException.from(jp, \"Root name '\"+actualName+\"' does not match expected ('\"\n                    +expName+\"') for type \"+rootType);\n        }\n        \n        jp.nextToken();\n        Object result = deser.deserialize(jp, ctxt);\n        \n        if (jp.nextToken() != JsonToken.END_OBJECT) {\n            throw JsonMappingException.from(jp, \"Current token not END_OBJECT (to match wrapper object with root name '\"\n                    +expName+\"'), but \"+jp.getCurrentToken());\n        }\n        return result;\n    }\n    \n    \n\n    \n    protected JsonDeserializer<Object> _findRootDeserializer(DeserializationContext ctxt, JavaType valueType) throws JsonMappingException {\n        \n        JsonDeserializer<Object> deser = _rootDeserializers.get(valueType);\n        if (deser != null) {\n            return deser;\n        }\n        \n        deser = ctxt.findRootValueDeserializer(valueType);\n        if (deser == null) { \n            throw new JsonMappingException(\"Can not find a deserializer for type \"+valueType);\n        }\n        _rootDeserializers.put(valueType, deser);\n        return deser;\n    }\n\n    \n    protected void _verifySchemaType(FormatSchema schema) {\n        if (schema != null) {\n            if (!_jsonFactory.canUseSchema(schema)) {\n                    throw new IllegalArgumentException(\"Can not use FormatSchema of type \"+schema.getClass().getName()\n                            +\" for format \"+_jsonFactory.getFormatName());\n            }\n        }\n    }\n}\n",
      "fixed_full_code": "package com.fasterxml.jackson.databind;\n\nimport java.io.*;\nimport java.lang.reflect.Type;\nimport java.net.URL;\nimport java.text.DateFormat;\nimport java.util.*;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport com.fasterxml.jackson.annotation.*;\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.io.CharacterEscapes;\nimport com.fasterxml.jackson.core.io.SegmentedStringWriter;\nimport com.fasterxml.jackson.core.type.ResolvedType;\nimport com.fasterxml.jackson.core.type.TypeReference;\nimport com.fasterxml.jackson.core.util.*;\nimport com.fasterxml.jackson.databind.cfg.BaseSettings;\nimport com.fasterxml.jackson.databind.cfg.ContextAttributes;\nimport com.fasterxml.jackson.databind.cfg.HandlerInstantiator;\nimport com.fasterxml.jackson.databind.cfg.MapperConfig;\nimport com.fasterxml.jackson.databind.deser.*;\nimport com.fasterxml.jackson.databind.introspect.*;\nimport com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\nimport com.fasterxml.jackson.databind.jsontype.*;\nimport com.fasterxml.jackson.databind.jsontype.impl.StdSubtypeResolver;\nimport com.fasterxml.jackson.databind.jsontype.impl.StdTypeResolverBuilder;\nimport com.fasterxml.jackson.databind.node.*;\nimport com.fasterxml.jackson.databind.ser.*;\nimport com.fasterxml.jackson.databind.type.*;\nimport com.fasterxml.jackson.databind.util.RootNameLookup;\nimport com.fasterxml.jackson.databind.util.StdDateFormat;\nimport com.fasterxml.jackson.databind.util.TokenBuffer;\n\n\npublic class ObjectMapper extends ObjectCodec implements Versioned, java.io.Serializable { private static final long serialVersionUID = 1L; public enum DefaultTyping { JAVA_LANG_OBJECT, OBJECT_AND_NON_CONCRETE, NON_CONCRETE_AND_ARRAYS, NON_FINAL } public static class DefaultTypeResolverBuilder extends StdTypeResolverBuilder implements java.io.Serializable { private static final long serialVersionUID = 1L; protected final DefaultTyping _appliesFor; public DefaultTypeResolverBuilder(DefaultTyping t) {\n            _appliesFor = t;\n        }\n\n        @Override\n        public TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes) {\n            return useForType(baseType) ? super.buildTypeDeserializer(config, baseType, subtypes) : null;\n        }\n\n        @Override\n        public TypeSerializer buildTypeSerializer(SerializationConfig config, JavaType baseType, Collection<NamedType> subtypes) {\n            return useForType(baseType) ? super.buildTypeSerializer(config, baseType, subtypes) : null;            \n        }\n\n        \n        public boolean useForType(JavaType t) {\n            switch (_appliesFor) {\n            case NON_CONCRETE_AND_ARRAYS:\n                while (t.isArrayType()) {\n                    t = t.getContentType();\n                }\n                \n            case OBJECT_AND_NON_CONCRETE:\n\n                return (t.getRawClass() == Object.class)\n                        || (!t.isConcrete()\n                                \n                                && !TreeNode.class.isAssignableFrom(t.getRawClass()));\n\n            case NON_FINAL:\n                while (t.isArrayType()) {\n                    t = t.getContentType();\n                }\n                \n                return !t.isFinal() && !TreeNode.class.isAssignableFrom(t.getRawClass());\n            default:\n            \n\n                return (t.getRawClass() == Object.class);\n            }\n        }\n    }\n\n    \n    \n    \n    private final static JavaType JSON_NODE_TYPE = SimpleType.constructUnsafe(JsonNode.class); protected final static ClassIntrospector DEFAULT_INTROSPECTOR = BasicClassIntrospector.instance; protected final static AnnotationIntrospector DEFAULT_ANNOTATION_INTROSPECTOR = new JacksonAnnotationIntrospector(); protected final static VisibilityChecker<?> STD_VISIBILITY_CHECKER = VisibilityChecker.Std.defaultInstance(); protected final static PrettyPrinter _defaultPrettyPrinter = new DefaultPrettyPrinter(); protected final static BaseSettings DEFAULT_BASE = new BaseSettings(DEFAULT_INTROSPECTOR, DEFAULT_ANNOTATION_INTROSPECTOR, STD_VISIBILITY_CHECKER, null, TypeFactory.defaultInstance(), null, StdDateFormat.instance, null, Locale.getDefault(), TimeZone.getTimeZone(\"GMT\"), Base64Variants.getDefaultVariant() ); protected final JsonFactory _jsonFactory; protected TypeFactory _typeFactory; protected InjectableValues _injectableValues; protected SubtypeResolver _subtypeResolver; protected final RootNameLookup _rootNames; protected final HashMap<ClassKey,Class<?>> _mixInAnnotations; protected SerializationConfig _serializationConfig; protected DefaultSerializerProvider _serializerProvider; protected SerializerFactory _serializerFactory; protected DeserializationConfig _deserializationConfig; protected DefaultDeserializationContext _deserializationContext; final protected ConcurrentHashMap<JavaType, JsonDeserializer<Object>> _rootDeserializers = new ConcurrentHashMap<JavaType, JsonDeserializer<Object>>(64, 0.6f, 2); public ObjectMapper() {\n        this(null, null, null);\n    }\n\n    \n    public ObjectMapper(JsonFactory jf) {\n        this(jf, null, null);\n    }\n\n    \n    protected ObjectMapper(ObjectMapper src) {\n        _jsonFactory = src._jsonFactory.copy();\n        _jsonFactory.setCodec(this);\n        _subtypeResolver = src._subtypeResolver;\n        _rootNames = new RootNameLookup();\n        _typeFactory = src._typeFactory;\n        HashMap<ClassKey,Class<?>> mixins = new HashMap<ClassKey,Class<?>>(src._mixInAnnotations);\n        _mixInAnnotations = mixins;\n        _serializationConfig = new SerializationConfig(src._serializationConfig, mixins);\n        _deserializationConfig = new DeserializationConfig(src._deserializationConfig, mixins);\n        _serializerProvider = src._serializerProvider.copy();\n        _deserializationContext = src._deserializationContext.copy();\n\n        \n        _serializerFactory = src._serializerFactory;\n    }\n    \n    \n    public ObjectMapper(JsonFactory jf, DefaultSerializerProvider sp, DefaultDeserializationContext dc) {\n        \n        if (jf == null) {\n            _jsonFactory = new MappingJsonFactory(this);\n        } else {\n            _jsonFactory = jf;\n            if (jf.getCodec() == null) { \n                _jsonFactory.setCodec(this);\n            }\n        }\n        _subtypeResolver = new StdSubtypeResolver();\n        _rootNames = new RootNameLookup();\n        \n        _typeFactory = TypeFactory.defaultInstance();\n\n        HashMap<ClassKey,Class<?>> mixins = new HashMap<ClassKey,Class<?>>();\n        _mixInAnnotations = mixins;\n        _serializationConfig = new SerializationConfig(DEFAULT_BASE,\n                    _subtypeResolver, mixins);\n        _deserializationConfig = new DeserializationConfig(DEFAULT_BASE,\n                    _subtypeResolver, mixins);\n\n        \n        final boolean needOrder = _jsonFactory.requiresPropertyOrdering();\n        if (needOrder ^ _serializationConfig.isEnabled(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY)) {\n            configure(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY, needOrder);\n        }\n        \n        _serializerProvider = (sp == null) ? new DefaultSerializerProvider.Impl() : sp;\n        _deserializationContext = (dc == null) ?\n                new DefaultDeserializationContext.Impl(BeanDeserializerFactory.instance) : dc;\n\n        \n        _serializerFactory = BeanSerializerFactory.instance;\n    }\n\n    \n    public ObjectMapper copy() {\n        _checkInvalidCopy(ObjectMapper.class);\n        return new ObjectMapper(this);\n    }\n\n    \n    protected void _checkInvalidCopy(Class<?> exp) {\n        if (getClass() != exp) {\n            throw new IllegalStateException(\"Failed copy(): \"+getClass().getName()\n                    +\" (version: \"+version()+\") does not override copy(); it has to\");\n        }\n    }\n    \n    \n    \n    \n    @Override\n    public Version version() {\n        return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION;\n    }\n    \n    \n\n    \n    public ObjectMapper registerModule(Module module) {\n        \n        String name = module.getModuleName();\n        if (name == null) {\n            throw new IllegalArgumentException(\"Module without defined name\");\n        }\n        Version version = module.version();\n        if (version == null) {\n            throw new IllegalArgumentException(\"Module without defined version\");\n        }\n\n        final ObjectMapper mapper = this;\n        \n        \n        module.setupModule(new Module.SetupContext()\n        {\n            \n\n            @Override\n            public Version getMapperVersion() {\n                return version();\n            }\n\n            @SuppressWarnings(\"unchecked\")\n            @Override\n            public <C extends ObjectCodec> C getOwner() {\n                \n                return (C) mapper;\n            }\n\n            @Override\n            public TypeFactory getTypeFactory() {\n                return _typeFactory;\n            }\n            \n            @Override\n            public boolean isEnabled(MapperFeature f) {\n                return mapper.isEnabled(f);\n            }\n\n            @Override\n            public boolean isEnabled(DeserializationFeature f) {\n                return mapper.isEnabled(f);\n            }\n            \n            @Override\n            public boolean isEnabled(SerializationFeature f) {\n                return mapper.isEnabled(f);\n            }\n\n            @Override\n            public boolean isEnabled(JsonFactory.Feature f) {\n                return mapper.isEnabled(f);\n            }\n\n            @Override\n            public boolean isEnabled(JsonParser.Feature f) {\n                return mapper.isEnabled(f);\n            }\n            \n            @Override\n            public boolean isEnabled(JsonGenerator.Feature f) {\n                return mapper.isEnabled(f);\n            }\n            \n            \n            \n            @Override\n            public void addDeserializers(Deserializers d) {\n                DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalDeserializers(d);\n                mapper._deserializationContext = mapper._deserializationContext.with(df);\n            }\n\n            @Override\n            public void addKeyDeserializers(KeyDeserializers d) {\n                DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalKeyDeserializers(d);\n                mapper._deserializationContext = mapper._deserializationContext.with(df);\n            }\n\n            @Override\n            public void addBeanDeserializerModifier(BeanDeserializerModifier modifier) {\n                DeserializerFactory df = mapper._deserializationContext._factory.withDeserializerModifier(modifier);\n                mapper._deserializationContext = mapper._deserializationContext.with(df);\n            }\n            \n            \n            \n            @Override\n            public void addSerializers(Serializers s) {\n                mapper._serializerFactory = mapper._serializerFactory.withAdditionalSerializers(s);\n            }\n\n            @Override\n            public void addKeySerializers(Serializers s) {\n                mapper._serializerFactory = mapper._serializerFactory.withAdditionalKeySerializers(s);\n            }\n            \n            @Override\n            public void addBeanSerializerModifier(BeanSerializerModifier modifier) {\n                mapper._serializerFactory = mapper._serializerFactory.withSerializerModifier(modifier);\n            }\n\n            \n            \n            @Override\n            public void addAbstractTypeResolver(AbstractTypeResolver resolver) {\n                DeserializerFactory df = mapper._deserializationContext._factory.withAbstractTypeResolver(resolver);\n                mapper._deserializationContext = mapper._deserializationContext.with(df);\n            }\n\n            @Override\n            public void addTypeModifier(TypeModifier modifier) {\n                TypeFactory f = mapper._typeFactory;\n                f = f.withModifier(modifier);\n                mapper.setTypeFactory(f);\n            }\n\n            @Override\n            public void addValueInstantiators(ValueInstantiators instantiators) {\n                DeserializerFactory df = mapper._deserializationContext._factory.withValueInstantiators(instantiators);\n                mapper._deserializationContext = mapper._deserializationContext.with(df);\n            }\n\n            @Override\n            public void setClassIntrospector(ClassIntrospector ci) {\n                mapper._deserializationConfig = mapper._deserializationConfig.with(ci);\n                mapper._serializationConfig = mapper._serializationConfig.with(ci);\n            }\n\n            @Override\n            public void insertAnnotationIntrospector(AnnotationIntrospector ai) {\n                mapper._deserializationConfig = mapper._deserializationConfig.withInsertedAnnotationIntrospector(ai);\n                mapper._serializationConfig = mapper._serializationConfig.withInsertedAnnotationIntrospector(ai);\n            }\n            \n            @Override\n            public void appendAnnotationIntrospector(AnnotationIntrospector ai) {\n                mapper._deserializationConfig = mapper._deserializationConfig.withAppendedAnnotationIntrospector(ai);\n                mapper._serializationConfig = mapper._serializationConfig.withAppendedAnnotationIntrospector(ai);\n            }\n\n            @Override\n            public void registerSubtypes(Class<?>... subtypes) {\n                mapper.registerSubtypes(subtypes);\n            }\n\n            @Override\n            public void registerSubtypes(NamedType... subtypes) {\n                mapper.registerSubtypes(subtypes);\n            }\n            \n            @Override\n            public void setMixInAnnotations(Class<?> target, Class<?> mixinSource) {\n                mapper.addMixInAnnotations(target, mixinSource);\n            }\n            \n            @Override\n            public void addDeserializationProblemHandler(DeserializationProblemHandler handler) {\n                mapper.addHandler(handler);\n            }\n\n            @Override\n            public void setNamingStrategy(PropertyNamingStrategy naming) {\n                mapper.setPropertyNamingStrategy(naming);\n            }\n        });\n        return this;\n    }\n\n    \n    public ObjectMapper registerModules(Module... modules) {\n        for (Module module : modules) {\n            registerModule(module);\n        }\n        return this;\n    }\n\n    \n    public ObjectMapper registerModules(Iterable<com.fasterxml.jackson.databind.Module> modules) {\n        for (Module module : modules) {\n            registerModule(module);\n        }\n        return this;\n    }\n    \n    \n    public static List<com.fasterxml.jackson.databind.Module> findModules() {\n        return findModules(null);\n    }\n\n    \n    public static List<com.fasterxml.jackson.databind.Module> findModules(ClassLoader classLoader) {\n        ArrayList<com.fasterxml.jackson.databind.Module> modules = new ArrayList<Module>();\n        ServiceLoader<com.fasterxml.jackson.databind.Module> loader = (classLoader == null) ?\n                ServiceLoader.load(Module.class) : ServiceLoader.load(Module.class, classLoader);\n        for (Module module : loader) {\n            modules.add(module);\n        }\n        return modules;\n    }\n\n    \n    public ObjectMapper findAndRegisterModules() {\n        return registerModules(findModules());\n    }\n    \n    \n\n    \n    public SerializationConfig getSerializationConfig() {\n        return _serializationConfig;\n    }\n\n    \n    public DeserializationConfig getDeserializationConfig() {\n        return _deserializationConfig;\n    }\n    \n    \n    public DeserializationContext getDeserializationContext() {\n        return _deserializationContext;\n    }\n\n    \n    \n    \n    public ObjectMapper setSerializerFactory(SerializerFactory f) {\n        _serializerFactory = f;\n        return this;\n    }\n\n    \n    public SerializerFactory getSerializerFactory() {\n        return _serializerFactory;\n    }\n\n    \n    public ObjectMapper setSerializerProvider(DefaultSerializerProvider p) {\n        _serializerProvider = p;\n        return this;\n    }\n\n    public SerializerProvider getSerializerProvider() {\n        return _serializerProvider;\n    }\n    \n    \n    \n    \n    public final void setMixInAnnotations(Map<Class<?>, Class<?>> sourceMixins) {\n        _mixInAnnotations.clear();\n        if (sourceMixins != null && sourceMixins.size() > 0) {\n            for (Map.Entry<Class<?>,Class<?>> en : sourceMixins.entrySet()) {\n                _mixInAnnotations.put(new ClassKey(en.getKey()), en.getValue());\n            }\n        }\n    }\n\n    \n    public final void addMixInAnnotations(Class<?> target, Class<?> mixinSource) {\n        _mixInAnnotations.put(new ClassKey(target), mixinSource);\n    }\n\n    \n    public final ObjectMapper addMixIn(Class<?> target, Class<?> mixinSource) {\n        _mixInAnnotations.put(new ClassKey(target), mixinSource);\n        return this;\n    }\n\n    public final Class<?> findMixInClassFor(Class<?> cls) {\n        return (_mixInAnnotations == null) ? null : _mixInAnnotations.get(new ClassKey(cls));\n    }\n\n    public final int mixInCount() {\n        return (_mixInAnnotations == null) ? 0 : _mixInAnnotations.size();\n    }\n    \n    \n\n    \n    public VisibilityChecker<?> getVisibilityChecker() {\n        return _serializationConfig.getDefaultVisibilityChecker();\n    }\n\n        \n    public void setVisibilityChecker(VisibilityChecker<?> vc) {\n        _deserializationConfig = _deserializationConfig.with(vc);\n        _serializationConfig = _serializationConfig.with(vc);\n    }\n\n    \n    public ObjectMapper setVisibility(PropertyAccessor forMethod, JsonAutoDetect.Visibility visibility) {\n        _deserializationConfig = _deserializationConfig.withVisibility(forMethod, visibility);\n        _serializationConfig = _serializationConfig.withVisibility(forMethod, visibility);\n        return this;\n    }\n    \n    \n    public SubtypeResolver getSubtypeResolver() {\n        return _subtypeResolver;\n    }\n\n    \n    public ObjectMapper setSubtypeResolver(SubtypeResolver str) {\n        _subtypeResolver = str;\n        _deserializationConfig = _deserializationConfig.with(str);\n        _serializationConfig = _serializationConfig.with(str);\n        return this;\n    }\n\n    \n    public ObjectMapper setAnnotationIntrospector(AnnotationIntrospector ai) {\n        _serializationConfig = _serializationConfig.with(ai);\n        _deserializationConfig = _deserializationConfig.with(ai);\n        return this;\n    }\n\n    \n    public ObjectMapper setAnnotationIntrospectors(AnnotationIntrospector serializerAI, AnnotationIntrospector deserializerAI) {\n        _serializationConfig = _serializationConfig.with(serializerAI);\n        _deserializationConfig = _deserializationConfig.with(deserializerAI);\n        return this;\n    }\n    \n    \n    public ObjectMapper setPropertyNamingStrategy(PropertyNamingStrategy s) {\n        _serializationConfig = _serializationConfig.with(s);\n        _deserializationConfig = _deserializationConfig.with(s);\n        return this;\n    }\n\n    \n    public ObjectMapper setSerializationInclusion(JsonInclude.Include incl) {\n        _serializationConfig = _serializationConfig.withSerializationInclusion(incl);\n        return this;\n    }\n    \n    \n\n    \n    public ObjectMapper enableDefaultTyping() {\n        return enableDefaultTyping(DefaultTyping.OBJECT_AND_NON_CONCRETE);\n    }\n\n    \n    public ObjectMapper enableDefaultTyping(DefaultTyping dti) {\n        return enableDefaultTyping(dti, JsonTypeInfo.As.WRAPPER_ARRAY);\n    }\n\n    \n    public ObjectMapper enableDefaultTyping(DefaultTyping applicability, JsonTypeInfo.As includeAs) {\n        TypeResolverBuilder<?> typer = new DefaultTypeResolverBuilder(applicability);\n        \n        typer = typer.init(JsonTypeInfo.Id.CLASS, null);\n        typer = typer.inclusion(includeAs);\n        return setDefaultTyping(typer);\n    }\n\n    \n    public ObjectMapper enableDefaultTypingAsProperty(DefaultTyping applicability, String propertyName) {\n        TypeResolverBuilder<?> typer = new DefaultTypeResolverBuilder(applicability);\n        \n        typer = typer.init(JsonTypeInfo.Id.CLASS, null);\n        typer = typer.inclusion(JsonTypeInfo.As.PROPERTY);\n        typer = typer.typeProperty(propertyName);\n        return setDefaultTyping(typer);\n    }\n    \n    \n    public ObjectMapper disableDefaultTyping() {\n        return setDefaultTyping(null);\n    }\n\n    \n    public ObjectMapper setDefaultTyping(TypeResolverBuilder<?> typer) {\n        _deserializationConfig = _deserializationConfig.with(typer);\n        _serializationConfig = _serializationConfig.with(typer);\n        return this;\n    }\n\n    \n    public void registerSubtypes(Class<?>... classes) {\n        getSubtypeResolver().registerSubtypes(classes);\n    }\n\n    \n    public void registerSubtypes(NamedType... types) {\n        getSubtypeResolver().registerSubtypes(types);\n    }\n\n    \n\n    \n    public TypeFactory getTypeFactory() {\n        return _typeFactory;\n    }\n\n    \n    public ObjectMapper setTypeFactory(TypeFactory f) {\n        _typeFactory = f;\n        _deserializationConfig = _deserializationConfig.with(f);\n        _serializationConfig = _serializationConfig.with(f);\n        return this;\n    }\n    \n    \n    public JavaType constructType(Type t) {\n        return _typeFactory.constructType(t);\n    }\n    \n    \n    \n    \n    public ObjectMapper setNodeFactory(JsonNodeFactory f) {\n        _deserializationConfig = _deserializationConfig.with(f);\n        return this;\n    }\n\n    \n    public ObjectMapper addHandler(DeserializationProblemHandler h) {\n        _deserializationConfig = _deserializationConfig.withHandler(h);\n        return this;\n    }\n\n    \n    public ObjectMapper clearProblemHandlers() {\n        _deserializationConfig = _deserializationConfig.withNoProblemHandlers();\n        return this;\n    }\n\n    \n    public ObjectMapper setConfig(DeserializationConfig config) {\n    \t_deserializationConfig = config;\n    \treturn this;\n    }\n    \n    \n\n    \n    public void setFilters(FilterProvider filterProvider) {\n        _serializationConfig = _serializationConfig.withFilters(filterProvider);\n    }\n\n    \n    public ObjectMapper setBase64Variant(Base64Variant v) {\n        _serializationConfig = _serializationConfig.with(v);\n        _deserializationConfig = _deserializationConfig.with(v);\n        return this;\n    }\n\n    \n    public ObjectMapper setConfig(SerializationConfig config) {\n    \t_serializationConfig = config;\n    \treturn this;\n    }\n    \n    \n\n    \n    @Override\n    public JsonFactory getFactory() { return _jsonFactory; }\n    \n    \n    @Deprecated\n    @Override\n    public JsonFactory getJsonFactory() { return getFactory(); }\n\n    \n    public ObjectMapper setDateFormat(DateFormat dateFormat) {\n        _deserializationConfig = _deserializationConfig.with(dateFormat);\n        _serializationConfig = _serializationConfig.with(dateFormat);\n        return this;\n    }\n\n    \n    public Object setHandlerInstantiator(HandlerInstantiator hi) {\n        _deserializationConfig = _deserializationConfig.with(hi);\n        _serializationConfig = _serializationConfig.with(hi);\n        return this;\n    }\n    \n    \n    public ObjectMapper setInjectableValues(InjectableValues injectableValues) {\n        _injectableValues = injectableValues;\n        return this;\n    }\n    \n    \n    public ObjectMapper setLocale(Locale l) {\n        _deserializationConfig = _deserializationConfig.with(l);\n        _serializationConfig = _serializationConfig.with(l);\n        return this;\n    }\n\n    \n    public ObjectMapper setTimeZone(TimeZone tz) {\n        _deserializationConfig = _deserializationConfig.with(tz);\n        _serializationConfig = _serializationConfig.with(tz);\n        return this;\n    }\n    \n    \n\n    \n    public ObjectMapper configure(MapperFeature f, boolean state) {\n        _serializationConfig = state ?\n                _serializationConfig.with(f) : _serializationConfig.without(f);\n        _deserializationConfig = state ?\n                _deserializationConfig.with(f) : _deserializationConfig.without(f);\n        return this;\n    }\n    \n    \n    public ObjectMapper configure(SerializationFeature f, boolean state) {\n        _serializationConfig = state ?\n                _serializationConfig.with(f) : _serializationConfig.without(f);\n        return this;\n    }\n\n    \n    public ObjectMapper configure(DeserializationFeature f, boolean state) {\n        _deserializationConfig = state ?\n                _deserializationConfig.with(f) : _deserializationConfig.without(f);\n        return this;\n    }\n\n    \n    public ObjectMapper configure(JsonParser.Feature f, boolean state) {\n        _jsonFactory.configure(f, state);\n        return this;\n    }\n\n    \n    public ObjectMapper configure(JsonGenerator.Feature f, boolean state) {\n        _jsonFactory.configure(f, state);\n        return this;\n    }\n\n    \n    public ObjectMapper enable(MapperFeature... f) {\n        _deserializationConfig = _deserializationConfig.with(f);\n        _serializationConfig = _serializationConfig.with(f);\n        return this;\n    }\n\n    \n    public ObjectMapper disable(MapperFeature... f) {\n        _deserializationConfig = _deserializationConfig.without(f);\n        _serializationConfig = _serializationConfig.without(f);\n        return this;\n    }\n    \n    \n    public ObjectMapper enable(DeserializationFeature feature) {\n        _deserializationConfig = _deserializationConfig.with(feature);\n        return this;\n    }\n\n    \n    public ObjectMapper enable(DeserializationFeature first, DeserializationFeature... f) {\n        _deserializationConfig = _deserializationConfig.with(first, f);\n        return this;\n    }\n    \n    \n    public ObjectMapper disable(DeserializationFeature feature) {\n        _deserializationConfig = _deserializationConfig.without(feature);\n        return this;\n    }\n\n    \n    public ObjectMapper disable(DeserializationFeature first, DeserializationFeature... f) {\n        _deserializationConfig = _deserializationConfig.without(first, f);\n        return this;\n    }\n    \n    \n    public ObjectMapper enable(SerializationFeature f) {\n        _serializationConfig = _serializationConfig.with(f);\n        return this;\n    }\n\n    \n    public ObjectMapper enable(SerializationFeature first, SerializationFeature... f) {\n        _serializationConfig = _serializationConfig.with(first, f);\n        return this;\n    }\n    \n    \n    public ObjectMapper disable(SerializationFeature f) {\n        _serializationConfig = _serializationConfig.without(f);\n        return this;\n    }\n\n    \n    public ObjectMapper disable(SerializationFeature first, SerializationFeature... f) {\n        _serializationConfig = _serializationConfig.without(first, f);\n        return this;\n    }\n\n    \n    public boolean isEnabled(MapperFeature f) {\n        \n        return _serializationConfig.isEnabled(f);\n    }\n\n    \n    public boolean isEnabled(SerializationFeature f) {\n        return _serializationConfig.isEnabled(f);\n    }\n    \n    \n    public boolean isEnabled(DeserializationFeature f) {\n        return _deserializationConfig.isEnabled(f);\n    }\n\n    \n    public boolean isEnabled(JsonFactory.Feature f) {\n        return _jsonFactory.isEnabled(f);\n    }\n\n    \n    public boolean isEnabled(JsonParser.Feature f) {\n        return _jsonFactory.isEnabled(f);\n    }\n    \n    \n    public boolean isEnabled(JsonGenerator.Feature f) {\n        return _jsonFactory.isEnabled(f);\n    }\n    \n    \n    public JsonNodeFactory getNodeFactory() {\n        return _deserializationConfig.getNodeFactory();\n    }\n\n    \n\n    \n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(JsonParser jp, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readValue(getDeserializationConfig(), jp, _typeFactory.constructType(valueType));\n    } \n\n    \n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(JsonParser jp, TypeReference<?> valueTypeRef) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readValue(getDeserializationConfig(), jp, _typeFactory.constructType(valueTypeRef));\n    }\n\n    \n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public final <T> T readValue(JsonParser jp, ResolvedType valueType) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readValue(getDeserializationConfig(), jp, (JavaType) valueType);\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(JsonParser jp, JavaType valueType) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readValue(getDeserializationConfig(), jp, valueType);\n    }\n    \n    \n    @Override\n    public <T extends TreeNode> T readTree(JsonParser jp) throws IOException, JsonProcessingException {\n        \n        \n        DeserializationConfig cfg = getDeserializationConfig();\n        JsonToken t = jp.getCurrentToken();\n        if (t == null) {\n            t = jp.nextToken();\n            if (t == null) {\n                return null;\n            }\n        }\n        JsonNode n = (JsonNode) _readValue(cfg, jp, JSON_NODE_TYPE);\n        if (n == null) {\n            n = getNodeFactory().nullNode();\n        }\n        @SuppressWarnings(\"unchecked\")\n        T result = (T) n;\n        return result;\n    }\n\n    \n    @Override\n    public <T> MappingIterator<T> readValues(JsonParser jp, ResolvedType valueType) throws IOException, JsonProcessingException {\n        return readValues(jp, (JavaType) valueType);\n    }\n\n    \n    public <T> MappingIterator<T> readValues(JsonParser jp, JavaType valueType) throws IOException, JsonProcessingException {\n        DeserializationConfig config = getDeserializationConfig();\n        DeserializationContext ctxt = createDeserializationContext(jp, config);\n        JsonDeserializer<?> deser = _findRootDeserializer(ctxt, valueType);\n        \n        return new MappingIterator<T>(valueType, jp, ctxt, deser,\n                false, null);\n    }\n\n    \n    @Override\n    public <T> MappingIterator<T> readValues(JsonParser jp, Class<T> valueType) throws IOException, JsonProcessingException {\n        return readValues(jp, _typeFactory.constructType(valueType));\n    }\n\n    \n    @Override\n    public <T> MappingIterator<T> readValues(JsonParser jp, TypeReference<?> valueTypeRef) throws IOException, JsonProcessingException {\n        return readValues(jp, _typeFactory.constructType(valueTypeRef));\n    }\n    \n    \n\n    \n    public JsonNode readTree(InputStream in) throws IOException, JsonProcessingException {\n        JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(in), JSON_NODE_TYPE);\n        return (n == null) ? NullNode.instance : n;\n    }\n\n    \n    public JsonNode readTree(Reader r) throws IOException, JsonProcessingException {\n        JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(r), JSON_NODE_TYPE);\n        return (n == null) ? NullNode.instance : n;\n    }\n\n    \n    public JsonNode readTree(String content) throws IOException, JsonProcessingException {\n        JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(content), JSON_NODE_TYPE);\n        return (n == null) ? NullNode.instance : n;\n    }\n\n    \n    public JsonNode readTree(byte[] content) throws IOException, JsonProcessingException {\n        JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(content), JSON_NODE_TYPE);\n        return (n == null) ? NullNode.instance : n;\n    }\n    \n    \n    public JsonNode readTree(File file) throws IOException, JsonProcessingException {\n        JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(file), JSON_NODE_TYPE);\n        return (n == null) ? NullNode.instance : n;\n    }\n\n    \n    public JsonNode readTree(URL source) throws IOException, JsonProcessingException {\n        JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(source), JSON_NODE_TYPE);\n        return (n == null) ? NullNode.instance : n;\n    }\n\n    \n\n    \n    @Override\n    public void writeValue(JsonGenerator jgen, Object value) throws IOException, JsonGenerationException, JsonMappingException {\n        SerializationConfig config = getSerializationConfig();\n        \n        if (config.isEnabled(SerializationFeature.INDENT_OUTPUT)) {\n            jgen.useDefaultPrettyPrinter();\n        }\n        if (config.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) {\n            _writeCloseableValue(jgen, value, config);\n        } else {\n            _serializerProvider(config).serializeValue(jgen, value);\n            if (config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) {\n                jgen.flush();\n            }\n        }\n    }\n\n    \n\n    @Override\n    public void writeTree(JsonGenerator jgen, TreeNode rootNode) throws IOException, JsonProcessingException {\n        SerializationConfig config = getSerializationConfig();\n        _serializerProvider(config).serializeValue(jgen, rootNode);\n        if (config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) {\n            jgen.flush();\n        }\n    }\n    \n    \n    public void writeTree(JsonGenerator jgen, JsonNode rootNode) throws IOException, JsonProcessingException {\n        SerializationConfig config = getSerializationConfig();\n        _serializerProvider(config).serializeValue(jgen, rootNode);\n        if (config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) {\n            jgen.flush();\n        }\n    }\n    \n    \n    @Override    \n    public ObjectNode createObjectNode() {\n        return _deserializationConfig.getNodeFactory().objectNode();\n    }\n\n    \n    @Override\n    public ArrayNode createArrayNode() {\n        return _deserializationConfig.getNodeFactory().arrayNode();\n    }\n\n    \n    @Override\n    public JsonParser treeAsTokens(TreeNode n) {\n        return new TreeTraversingParser((JsonNode) n, this);\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public <T> T treeToValue(TreeNode n, Class<T> valueType) throws JsonProcessingException {\n        try {\n            \n            \n            if (valueType != Object.class && valueType.isAssignableFrom(n.getClass())) {\n                return (T) n;\n            }\n            return readValue(treeAsTokens(n), valueType);\n        } catch (JsonProcessingException e) {\n            throw e;\n        } catch (IOException e) { \n            throw new IllegalArgumentException(e.getMessage(), e);\n        }\n    }\n\n    \n    @SuppressWarnings({ \"unchecked\", \"resource\" })\n    public <T extends JsonNode> T valueToTree(Object fromValue) throws IllegalArgumentException {\n        if (fromValue == null) return null;\n        TokenBuffer buf = new TokenBuffer(this, false);\n        JsonNode result;\n        try {\n            writeValue(buf, fromValue);\n            JsonParser jp = buf.asParser();\n            result = readTree(jp);\n            jp.close();\n        } catch (IOException e) { \n            throw new IllegalArgumentException(e.getMessage(), e);\n        }\n        return (T) result;\n    } \n    \n    \n\n    \n    public boolean canSerialize(Class<?> type) {\n        return _serializerProvider(getSerializationConfig()).hasSerializerFor(type, null);\n    }\n\n    \n    public boolean canSerialize(Class<?> type, AtomicReference<Throwable> cause) {\n        return _serializerProvider(getSerializationConfig()).hasSerializerFor(type, cause);\n    }\n    \n    \n    public boolean canDeserialize(JavaType type) {\n        return createDeserializationContext(null,\n                getDeserializationConfig()).hasValueDeserializerFor(type, null);\n    }\n\n    \n    public boolean canDeserialize(JavaType type, AtomicReference<Throwable> cause) {\n        return createDeserializationContext(null,\n                getDeserializationConfig()).hasValueDeserializerFor(type, cause);\n    }\n    \n    \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(File src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueType));\n    } \n\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(File src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueTypeRef));\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(File src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType);\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(URL src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException {\n     \n\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueType));\n    } \n\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(URL src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueTypeRef));\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(URL src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType);\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(String content, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException {\n     \n\n        return (T) _readMapAndClose(_jsonFactory.createParser(content), _typeFactory.constructType(valueType));\n    } \n\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(String content, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(content), _typeFactory.constructType(valueTypeRef));\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(String content, JavaType valueType) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(content), valueType);\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(Reader src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException {\n     \n\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueType));\n    } \n\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(Reader src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueTypeRef));\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(Reader src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType);\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(InputStream src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException {\n     \n\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueType));\n    } \n\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(InputStream src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueTypeRef));\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(InputStream src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType);\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(byte[] src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException {\n     \n\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueType));\n    } \n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(byte[] src, int offset, int len, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException {\n     \n\n        return (T) _readMapAndClose(_jsonFactory.createParser(src, offset, len), _typeFactory.constructType(valueType));\n    } \n\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(byte[] src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueTypeRef));\n    } \n    \n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(byte[] src, int offset, int len, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src, offset, len), _typeFactory.constructType(valueTypeRef));\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(byte[] src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType);\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(byte[] src, int offset, int len, JavaType valueType) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src, offset, len), valueType);\n    } \n    \n    \n\n    \n    public void writeValue(File resultFile, Object value) throws IOException, JsonGenerationException, JsonMappingException {\n        _configAndWriteValue(_jsonFactory.createGenerator(resultFile, JsonEncoding.UTF8), value);\n    }\n\n    \n    public void writeValue(OutputStream out, Object value) throws IOException, JsonGenerationException, JsonMappingException {\n        _configAndWriteValue(_jsonFactory.createGenerator(out, JsonEncoding.UTF8), value);\n    }\n\n    \n    public void writeValue(Writer w, Object value) throws IOException, JsonGenerationException, JsonMappingException {\n        _configAndWriteValue(_jsonFactory.createGenerator(w), value);\n    }\n\n    \n    @SuppressWarnings(\"resource\")\n    public String writeValueAsString(Object value) throws JsonProcessingException {        \n        \n        SegmentedStringWriter sw = new SegmentedStringWriter(_jsonFactory._getBufferRecycler());\n        try {\n            _configAndWriteValue(_jsonFactory.createGenerator(sw), value);\n        } catch (JsonProcessingException e) { \n            throw e;\n        } catch (IOException e) { \n            throw JsonMappingException.fromUnexpectedIOE(e);\n        }\n        return sw.getAndClear();\n    }\n    \n    \n    @SuppressWarnings(\"resource\")\n    public byte[] writeValueAsBytes(Object value) throws JsonProcessingException {\n        ByteArrayBuilder bb = new ByteArrayBuilder(_jsonFactory._getBufferRecycler());\n        try {\n            _configAndWriteValue(_jsonFactory.createGenerator(bb, JsonEncoding.UTF8), value);\n        } catch (JsonProcessingException e) { \n            throw e;\n        } catch (IOException e) { \n            throw JsonMappingException.fromUnexpectedIOE(e);\n        }\n        byte[] result = bb.toByteArray();\n        bb.release();\n        return result;\n    }\n\n    \n\n    \n    public ObjectWriter writer() {\n        return new ObjectWriter(this, getSerializationConfig());\n    }\n\n    \n    public ObjectWriter writer(SerializationFeature feature) {\n        return new ObjectWriter(this, getSerializationConfig().with(feature));\n    }\n\n    \n    public ObjectWriter writer(SerializationFeature first, SerializationFeature... other) {\n        return new ObjectWriter(this, getSerializationConfig().with(first, other));\n    }\n    \n    \n    public ObjectWriter writer(DateFormat df) {\n        return new ObjectWriter(this, getSerializationConfig().with(df));\n    }\n    \n    \n    public ObjectWriter writerWithView(Class<?> serializationView) {\n        return new ObjectWriter(this, getSerializationConfig().withView(serializationView));\n    }\n    \n    \n    public ObjectWriter writerWithType(Class<?> rootType) {\n        return new ObjectWriter(this, getSerializationConfig(),\n                \n                ((rootType == null) ? null :_typeFactory.constructType(rootType)),\n                null);\n    }\n\n    \n    public ObjectWriter writerWithType(TypeReference<?> rootType) {\n        return new ObjectWriter(this, getSerializationConfig(),\n                \n                ((rootType == null) ? null : _typeFactory.constructType(rootType)),\n                null);\n    }\n\n    \n    public ObjectWriter writerWithType(JavaType rootType) {\n        return new ObjectWriter(this, getSerializationConfig(), rootType, null);\n    }\n    \n    \n    public ObjectWriter writer(PrettyPrinter pp) {\n        if (pp == null) { \n            pp = ObjectWriter.NULL_PRETTY_PRINTER;\n        }\n        return new ObjectWriter(this, getSerializationConfig(),  null, pp);\n    }\n    \n    \n    public ObjectWriter writerWithDefaultPrettyPrinter() {\n        return new ObjectWriter(this, getSerializationConfig(),\n                 null, _defaultPrettyPrinter());\n    }\n    \n    \n    public ObjectWriter writer(FilterProvider filterProvider) {\n        return new ObjectWriter(this,\n                getSerializationConfig().withFilters(filterProvider));\n    }\n    \n    \n    public ObjectWriter writer(FormatSchema schema) {\n        _verifySchemaType(schema);\n        return new ObjectWriter(this, getSerializationConfig(), schema);\n    }\n\n    \n    public ObjectWriter writer(Base64Variant defaultBase64) {\n        return new ObjectWriter(this, getSerializationConfig().with(defaultBase64));\n    }\n\n    \n    public ObjectWriter writer(CharacterEscapes escapes) {\n        return writer().with(escapes);\n    }\n\n    \n    public ObjectWriter writer(ContextAttributes attrs) {\n        return new ObjectWriter(this, getSerializationConfig().with(attrs));\n    }\n    \n    \n\n    \n    public ObjectReader reader() {\n        return new ObjectReader(this, getDeserializationConfig())\n            .with(_injectableValues);\n    }\n\n    \n    public ObjectReader reader(DeserializationFeature feature) {\n        return new ObjectReader(this, getDeserializationConfig().with(feature));\n    }\n\n    \n    public ObjectReader reader(DeserializationFeature first, DeserializationFeature... other) {\n        return new ObjectReader(this, getDeserializationConfig().with(first, other));\n    }\n    \n    \n    public ObjectReader readerForUpdating(Object valueToUpdate) {\n        JavaType t = _typeFactory.constructType(valueToUpdate.getClass());\n        return new ObjectReader(this, getDeserializationConfig(), t, valueToUpdate,\n                null, _injectableValues);\n    }\n\n    \n    public ObjectReader reader(JavaType type) {\n        return new ObjectReader(this, getDeserializationConfig(), type, null,\n                null, _injectableValues);\n    }\n\n    \n    public ObjectReader reader(Class<?> type) {\n        return reader(_typeFactory.constructType(type));\n    }\n\n    \n    public ObjectReader reader(TypeReference<?> type) {\n        return reader(_typeFactory.constructType(type));\n    }\n\n    \n    public ObjectReader reader(JsonNodeFactory f) {\n        return new ObjectReader(this, getDeserializationConfig()).with(f);\n    }\n\n    \n    public ObjectReader reader(FormatSchema schema) {\n        _verifySchemaType(schema);\n        return new ObjectReader(this, getDeserializationConfig(), null, null,\n                schema, _injectableValues);\n    }\n\n    \n    public ObjectReader reader(InjectableValues injectableValues) {\n        return new ObjectReader(this, getDeserializationConfig(), null, null,\n                null, injectableValues);\n    }\n\n    \n    public ObjectReader readerWithView(Class<?> view) {\n        return new ObjectReader(this, getDeserializationConfig().withView(view));\n    }\n\n    \n    public ObjectReader reader(Base64Variant defaultBase64) {\n        return new ObjectReader(this, getDeserializationConfig().with(defaultBase64));\n    }\n\n    \n    public ObjectReader reader(ContextAttributes attrs) {\n        return new ObjectReader(this, getDeserializationConfig().with(attrs));\n    }\n    \n    \n   \n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T convertValue(Object fromValue, Class<T> toValueType) throws IllegalArgumentException {\n        \n        if (fromValue == null) return null;\n        return (T) _convert(fromValue, _typeFactory.constructType(toValueType));\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T convertValue(Object fromValue, TypeReference<?> toValueTypeRef) throws IllegalArgumentException {\n        return (T) convertValue(fromValue, _typeFactory.constructType(toValueTypeRef));\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T convertValue(Object fromValue, JavaType toValueType) throws IllegalArgumentException {\n        \n        if (fromValue == null) return null;\n        return (T) _convert(fromValue, toValueType);\n    } \n\n    \n    @SuppressWarnings(\"resource\")\n    protected Object _convert(Object fromValue, JavaType toValueType) throws IllegalArgumentException {        \n        \n        \n        Class<?> targetType = toValueType.getRawClass();\n        if (targetType != Object.class\n                && !toValueType.hasGenericTypes()\n                && targetType.isAssignableFrom(fromValue.getClass())) {\n            return fromValue;\n        }\n        \n        \n        TokenBuffer buf = new TokenBuffer(this, false);\n        try {\n            \n            \n            SerializationConfig config = getSerializationConfig().without(SerializationFeature.WRAP_ROOT_VALUE);\n            \n            _serializerProvider(config).serializeValue(buf, fromValue);\n\n            \n            final JsonParser jp = buf.asParser();\n            Object result;\n            \n            final DeserializationConfig deserConfig = getDeserializationConfig();\n            JsonToken t = _initForReading(jp);\n            if (t == JsonToken.VALUE_NULL) {\n                DeserializationContext ctxt = createDeserializationContext(jp, deserConfig);\n                result = _findRootDeserializer(ctxt, toValueType).getNullValue();\n            } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {\n                result = null;\n            } else { \n                DeserializationContext ctxt = createDeserializationContext(jp, deserConfig);\n                JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, toValueType);\n                \n                result = deser.deserialize(jp, ctxt);\n            }\n            jp.close();\n            return result;\n        } catch (IOException e) { \n            throw new IllegalArgumentException(e.getMessage(), e);\n        }\n    }\n\n    \n\n    \n    @SuppressWarnings(\"deprecation\")\n    public com.fasterxml.jackson.databind.jsonschema.JsonSchema generateJsonSchema(Class<?> t) throws JsonMappingException {\n        return _serializerProvider(getSerializationConfig()).generateJsonSchema(t);\n    }\n\n    \n    public void acceptJsonFormatVisitor(Class<?> type, JsonFormatVisitorWrapper visitor) throws JsonMappingException {\n        acceptJsonFormatVisitor(_typeFactory.constructType(type), visitor);\n    }\n    \n    \n    public void acceptJsonFormatVisitor(JavaType type, JsonFormatVisitorWrapper visitor) throws JsonMappingException {\n        if (type == null) {\n            throw new IllegalArgumentException(\"type must be provided\");\n        }\n        _serializerProvider(getSerializationConfig()).acceptJsonFormatVisitor(type, visitor);\n    }\n    \n    \n\n    \n    protected DefaultSerializerProvider _serializerProvider(SerializationConfig config) {\n        return _serializerProvider.createInstance(config, _serializerFactory);\n    }\n    \n    \n    protected PrettyPrinter _defaultPrettyPrinter() {\n        return _defaultPrettyPrinter;\n    }\n    \n    \n    protected final void _configAndWriteValue(JsonGenerator jgen, Object value) throws IOException, JsonGenerationException, JsonMappingException {\n        SerializationConfig cfg = getSerializationConfig();\n        \n        if (cfg.isEnabled(SerializationFeature.INDENT_OUTPUT)) {\n            jgen.useDefaultPrettyPrinter();\n        }\n        \n        if (cfg.isEnabled(SerializationFeature.WRITE_BIGDECIMAL_AS_PLAIN)) {\n            jgen.enable(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN);\n        }\n        \n        if (cfg.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) {\n            _configAndWriteCloseable(jgen, value, cfg);\n            return;\n        }\n        boolean closed = false;\n        try {\n            _serializerProvider(cfg).serializeValue(jgen, value);\n            closed = true;\n            jgen.close();\n        } finally {\n            \n            if (!closed) {\n                \n                jgen.disable(JsonGenerator.Feature.AUTO_CLOSE_JSON_CONTENT);\n                try {\n                    jgen.close();\n                } catch (IOException ioe) { }\n            }\n        }\n    }\n\n    protected final void _configAndWriteValue(JsonGenerator jgen, Object value, Class<?> viewClass) throws IOException, JsonGenerationException, JsonMappingException {\n        SerializationConfig cfg = getSerializationConfig().withView(viewClass);\n        if (cfg.isEnabled(SerializationFeature.INDENT_OUTPUT)) {\n            jgen.useDefaultPrettyPrinter();\n        }\n        \n        if (cfg.isEnabled(SerializationFeature.WRITE_BIGDECIMAL_AS_PLAIN)) {\n            jgen.enable(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN);\n        }\n\n        \n        if (cfg.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) {\n            _configAndWriteCloseable(jgen, value, cfg);\n            return;\n        }\n        boolean closed = false;\n        try {\n            _serializerProvider(cfg).serializeValue(jgen, value);\n            closed = true;\n            jgen.close();\n        } finally {\n            if (!closed) {\n                \n                \n                jgen.disable(JsonGenerator.Feature.AUTO_CLOSE_JSON_CONTENT);\n                try {\n                    jgen.close();\n                } catch (IOException ioe) { }\n            }\n        }\n    }\n\n    \n    private final void _configAndWriteCloseable(JsonGenerator jgen, Object value, SerializationConfig cfg) throws IOException, JsonGenerationException, JsonMappingException {\n        Closeable toClose = (Closeable) value;\n        try {\n            _serializerProvider(cfg).serializeValue(jgen, value);\n            JsonGenerator tmpJgen = jgen;\n            jgen = null;\n            tmpJgen.close();\n            Closeable tmpToClose = toClose;\n            toClose = null;\n            tmpToClose.close();\n        } finally {\n            \n            if (jgen != null) {\n                \n                \n                jgen.disable(JsonGenerator.Feature.AUTO_CLOSE_JSON_CONTENT);\n                try {\n                    jgen.close();\n                } catch (IOException ioe) { }\n            }\n            if (toClose != null) {\n                try {\n                    toClose.close();\n                } catch (IOException ioe) { }\n            }\n        }\n    }\n    \n    \n    private final void _writeCloseableValue(JsonGenerator jgen, Object value, SerializationConfig cfg) throws IOException, JsonGenerationException, JsonMappingException {\n        Closeable toClose = (Closeable) value;\n        try {\n            _serializerProvider(cfg).serializeValue(jgen, value);\n            if (cfg.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) {\n                jgen.flush();\n            }\n            Closeable tmpToClose = toClose;\n            toClose = null;\n            tmpToClose.close();\n        } finally {\n            if (toClose != null) {\n                try {\n                    toClose.close();\n                } catch (IOException ioe) { }\n            }\n        }\n    }\n    \n    \n\n    \n    protected DefaultDeserializationContext createDeserializationContext(JsonParser jp, DeserializationConfig cfg) {\n        return _deserializationContext.createInstance(cfg,\n                jp, _injectableValues);\n    }\n    \n    \n    protected Object _readValue(DeserializationConfig cfg, JsonParser jp, JavaType valueType) throws IOException, JsonParseException, JsonMappingException {\n        \n        Object result;\n        JsonToken t = _initForReading(jp);\n        if (t == JsonToken.VALUE_NULL) {\n            \n            DeserializationContext ctxt = createDeserializationContext(jp, cfg);\n            result = _findRootDeserializer(ctxt, valueType).getNullValue();\n        } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {\n            result = null;\n        } else { \n            DeserializationContext ctxt = createDeserializationContext(jp, cfg);\n            JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, valueType);\n            \n            if (cfg.useRootWrapping()) {\n                result = _unwrapAndDeserialize(jp, ctxt, cfg, valueType, deser);\n            } else {\n                result = deser.deserialize(jp, ctxt);\n            }\n        }\n        \n        jp.clearCurrentToken();\n        return result;\n    }\n    \n    protected Object _readMapAndClose(JsonParser jp, JavaType valueType) throws IOException, JsonParseException, JsonMappingException {\n        try {\n            Object result;\n            JsonToken t = _initForReading(jp);\n            if (t == JsonToken.VALUE_NULL) {\n                \n                DeserializationContext ctxt = createDeserializationContext(jp,\n                        getDeserializationConfig());\n                result = _findRootDeserializer(ctxt, valueType).getNullValue();\n            } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {\n                result = null;\n            } else {\n                DeserializationConfig cfg = getDeserializationConfig();\n                DeserializationContext ctxt = createDeserializationContext(jp, cfg);\n                JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, valueType);\n                if (cfg.useRootWrapping()) {\n                    result = _unwrapAndDeserialize(jp, ctxt, cfg, valueType, deser);\n                } else {\n                    result = deser.deserialize(jp, ctxt);\n                }\n                ctxt.checkUnresolvedObjectId();\n            }\n            \n            jp.clearCurrentToken();\n            return result;\n        } finally {\n            try {\n                jp.close();\n            } catch (IOException ioe) { }\n        }\n    }\n    \n    \n    protected JsonToken _initForReading(JsonParser jp) throws IOException, JsonParseException, JsonMappingException {\n        \n        JsonToken t = jp.getCurrentToken();\n        if (t == null) {\n            \n            t = jp.nextToken();\n            if (t == null) {\n                \n                throw JsonMappingException.from(jp, \"No content to map due to end-of-input\");\n            }\n        }\n        return t;\n    }\n\n    protected Object _unwrapAndDeserialize(JsonParser jp, DeserializationContext ctxt, DeserializationConfig config, JavaType rootType, JsonDeserializer<Object> deser) throws IOException, JsonParseException, JsonMappingException {\n        String expName = config.getRootName();\n        if (expName == null) {\n            PropertyName pname = _rootNames.findRootName(rootType, config);\n            expName = pname.getSimpleName();\n        }\n        if (jp.getCurrentToken() != JsonToken.START_OBJECT) {\n            throw JsonMappingException.from(jp, \"Current token not START_OBJECT (needed to unwrap root name '\"\n                    +expName+\"'), but \"+jp.getCurrentToken());\n        }\n        if (jp.nextToken() != JsonToken.FIELD_NAME) {\n            throw JsonMappingException.from(jp, \"Current token not FIELD_NAME (to contain expected root name '\"\n                    +expName+\"'), but \"+jp.getCurrentToken());\n        }\n        String actualName = jp.getCurrentName();\n        if (!expName.equals(actualName)) {\n            throw JsonMappingException.from(jp, \"Root name '\"+actualName+\"' does not match expected ('\"\n                    +expName+\"') for type \"+rootType);\n        }\n        \n        jp.nextToken();\n        Object result = deser.deserialize(jp, ctxt);\n        \n        if (jp.nextToken() != JsonToken.END_OBJECT) {\n            throw JsonMappingException.from(jp, \"Current token not END_OBJECT (to match wrapper object with root name '\"\n                    +expName+\"'), but \"+jp.getCurrentToken());\n        }\n        return result;\n    }\n    \n    \n\n    \n    protected JsonDeserializer<Object> _findRootDeserializer(DeserializationContext ctxt, JavaType valueType) throws JsonMappingException {\n        \n        JsonDeserializer<Object> deser = _rootDeserializers.get(valueType);\n        if (deser != null) {\n            return deser;\n        }\n        \n        deser = ctxt.findRootValueDeserializer(valueType);\n        if (deser == null) { \n            throw new JsonMappingException(\"Can not find a deserializer for type \"+valueType);\n        }\n        _rootDeserializers.put(valueType, deser);\n        return deser;\n    }\n\n    \n    protected void _verifySchemaType(FormatSchema schema) {\n        if (schema != null) {\n            if (!_jsonFactory.canUseSchema(schema)) {\n                    throw new IllegalArgumentException(\"Can not use FormatSchema of type \"+schema.getClass().getName()\n                            +\" for format \"+_jsonFactory.getFormatName());\n            }\n        }\n    }\n}\n",
      "buggy_signatures": [
        "public TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes)",
        "public TypeSerializer buildTypeSerializer(SerializationConfig config, JavaType baseType, Collection<NamedType> subtypes)",
        "public boolean useForType(JavaType t)",
        "public ObjectMapper(JsonFactory jf)",
        "protected ObjectMapper(ObjectMapper src)",
        "public ObjectMapper(JsonFactory jf, DefaultSerializerProvider sp, DefaultDeserializationContext dc)",
        "public ObjectMapper copy()",
        "protected void _checkInvalidCopy(Class<?> exp)",
        "public Version version()",
        "public ObjectMapper registerModule(Module module)",
        "public Version getMapperVersion()",
        "public <C extends ObjectCodec> C getOwner()",
        "public TypeFactory getTypeFactory()",
        "public boolean isEnabled(MapperFeature f)",
        "public boolean isEnabled(DeserializationFeature f)",
        "public boolean isEnabled(SerializationFeature f)",
        "public boolean isEnabled(JsonFactory.Feature f)",
        "public boolean isEnabled(JsonParser.Feature f)",
        "public boolean isEnabled(JsonGenerator.Feature f)",
        "public void addDeserializers(Deserializers d)",
        "public void addKeyDeserializers(KeyDeserializers d)",
        "public void addBeanDeserializerModifier(BeanDeserializerModifier modifier)",
        "public void addSerializers(Serializers s)",
        "public void addKeySerializers(Serializers s)",
        "public void addBeanSerializerModifier(BeanSerializerModifier modifier)",
        "public void addAbstractTypeResolver(AbstractTypeResolver resolver)",
        "public void addTypeModifier(TypeModifier modifier)",
        "public void addValueInstantiators(ValueInstantiators instantiators)",
        "public void setClassIntrospector(ClassIntrospector ci)",
        "public void insertAnnotationIntrospector(AnnotationIntrospector ai)",
        "public void appendAnnotationIntrospector(AnnotationIntrospector ai)",
        "public void registerSubtypes(Class<?>... subtypes)",
        "public void registerSubtypes(NamedType... subtypes)",
        "public void setMixInAnnotations(Class<?> target, Class<?> mixinSource)",
        "public void addDeserializationProblemHandler(DeserializationProblemHandler handler)",
        "public void setNamingStrategy(PropertyNamingStrategy naming)",
        "public ObjectMapper registerModules(Module... modules)",
        "public ObjectMapper registerModules(Iterable<com.fasterxml.jackson.databind.Module> modules)",
        "public static List<com.fasterxml.jackson.databind.Module> findModules()",
        "public static List<com.fasterxml.jackson.databind.Module> findModules(ClassLoader classLoader)",
        "public ObjectMapper findAndRegisterModules()",
        "public SerializationConfig getSerializationConfig()",
        "public DeserializationConfig getDeserializationConfig()",
        "public DeserializationContext getDeserializationContext()",
        "public ObjectMapper setSerializerFactory(SerializerFactory f)",
        "public SerializerFactory getSerializerFactory()",
        "public ObjectMapper setSerializerProvider(DefaultSerializerProvider p)",
        "public SerializerProvider getSerializerProvider()",
        "public final void setMixInAnnotations(Map<Class<?>, Class<?>> sourceMixins)",
        "public final void addMixInAnnotations(Class<?> target, Class<?> mixinSource)",
        "public final ObjectMapper addMixIn(Class<?> target, Class<?> mixinSource)",
        "public final Class<?> findMixInClassFor(Class<?> cls)",
        "public final int mixInCount()",
        "public VisibilityChecker<?> getVisibilityChecker()",
        "public void setVisibilityChecker(VisibilityChecker<?> vc)",
        "public ObjectMapper setVisibility(PropertyAccessor forMethod, JsonAutoDetect.Visibility visibility)",
        "public SubtypeResolver getSubtypeResolver()",
        "public ObjectMapper setSubtypeResolver(SubtypeResolver str)",
        "public ObjectMapper setAnnotationIntrospector(AnnotationIntrospector ai)",
        "public ObjectMapper setAnnotationIntrospectors(AnnotationIntrospector serializerAI, AnnotationIntrospector deserializerAI)",
        "public ObjectMapper setPropertyNamingStrategy(PropertyNamingStrategy s)",
        "public ObjectMapper setSerializationInclusion(JsonInclude.Include incl)",
        "public ObjectMapper enableDefaultTyping()",
        "public ObjectMapper enableDefaultTyping(DefaultTyping dti)",
        "public ObjectMapper enableDefaultTyping(DefaultTyping applicability, JsonTypeInfo.As includeAs)",
        "public ObjectMapper enableDefaultTypingAsProperty(DefaultTyping applicability, String propertyName)",
        "public ObjectMapper disableDefaultTyping()",
        "public ObjectMapper setDefaultTyping(TypeResolverBuilder<?> typer)",
        "public void registerSubtypes(Class<?>... classes)",
        "public void registerSubtypes(NamedType... types)",
        "public TypeFactory getTypeFactory()",
        "public ObjectMapper setTypeFactory(TypeFactory f)",
        "public JavaType constructType(Type t)",
        "public ObjectMapper setNodeFactory(JsonNodeFactory f)",
        "public ObjectMapper addHandler(DeserializationProblemHandler h)",
        "public ObjectMapper clearProblemHandlers()",
        "public ObjectMapper setConfig(DeserializationConfig config)",
        "public void setFilters(FilterProvider filterProvider)",
        "public ObjectMapper setBase64Variant(Base64Variant v)",
        "public ObjectMapper setConfig(SerializationConfig config)",
        "public JsonFactory getFactory()",
        "public JsonFactory getJsonFactory()",
        "public ObjectMapper setDateFormat(DateFormat dateFormat)",
        "public Object setHandlerInstantiator(HandlerInstantiator hi)",
        "public ObjectMapper setInjectableValues(InjectableValues injectableValues)",
        "public ObjectMapper setLocale(Locale l)",
        "public ObjectMapper setTimeZone(TimeZone tz)",
        "public ObjectMapper configure(MapperFeature f, boolean state)",
        "public ObjectMapper configure(SerializationFeature f, boolean state)",
        "public ObjectMapper configure(DeserializationFeature f, boolean state)",
        "public ObjectMapper configure(JsonParser.Feature f, boolean state)",
        "public ObjectMapper configure(JsonGenerator.Feature f, boolean state)",
        "public ObjectMapper enable(MapperFeature... f)",
        "public ObjectMapper disable(MapperFeature... f)",
        "public ObjectMapper enable(DeserializationFeature feature)",
        "public ObjectMapper enable(DeserializationFeature first, DeserializationFeature... f)",
        "public ObjectMapper disable(DeserializationFeature feature)",
        "public ObjectMapper disable(DeserializationFeature first, DeserializationFeature... f)",
        "public ObjectMapper enable(SerializationFeature f)",
        "public ObjectMapper enable(SerializationFeature first, SerializationFeature... f)",
        "public ObjectMapper disable(SerializationFeature f)",
        "public ObjectMapper disable(SerializationFeature first, SerializationFeature... f)",
        "public boolean isEnabled(MapperFeature f)",
        "public boolean isEnabled(SerializationFeature f)",
        "public boolean isEnabled(DeserializationFeature f)",
        "public boolean isEnabled(JsonFactory.Feature f)",
        "public boolean isEnabled(JsonParser.Feature f)",
        "public boolean isEnabled(JsonGenerator.Feature f)",
        "public JsonNodeFactory getNodeFactory()",
        "public <T> T readValue(JsonParser jp, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(JsonParser jp, TypeReference<?> valueTypeRef) throws IOException, JsonParseException, JsonMappingException",
        "public final <T> T readValue(JsonParser jp, ResolvedType valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(JsonParser jp, JavaType valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T extends TreeNode> T readTree(JsonParser jp) throws IOException, JsonProcessingException",
        "public <T> MappingIterator<T> readValues(JsonParser jp, ResolvedType valueType) throws IOException, JsonProcessingException",
        "public <T> MappingIterator<T> readValues(JsonParser jp, JavaType valueType) throws IOException, JsonProcessingException",
        "public <T> MappingIterator<T> readValues(JsonParser jp, Class<T> valueType) throws IOException, JsonProcessingException",
        "public <T> MappingIterator<T> readValues(JsonParser jp, TypeReference<?> valueTypeRef) throws IOException, JsonProcessingException",
        "public JsonNode readTree(InputStream in) throws IOException, JsonProcessingException",
        "public JsonNode readTree(Reader r) throws IOException, JsonProcessingException",
        "public JsonNode readTree(String content) throws IOException, JsonProcessingException",
        "public JsonNode readTree(byte[] content) throws IOException, JsonProcessingException",
        "public JsonNode readTree(File file) throws IOException, JsonProcessingException",
        "public JsonNode readTree(URL source) throws IOException, JsonProcessingException",
        "public void writeValue(JsonGenerator jgen, Object value) throws IOException, JsonGenerationException, JsonMappingException",
        "public void writeTree(JsonGenerator jgen, TreeNode rootNode) throws IOException, JsonProcessingException",
        "public void writeTree(JsonGenerator jgen, JsonNode rootNode) throws IOException, JsonProcessingException",
        "public ObjectNode createObjectNode()",
        "public ArrayNode createArrayNode()",
        "public JsonParser treeAsTokens(TreeNode n)",
        "public <T> T treeToValue(TreeNode n, Class<T> valueType) throws JsonProcessingException",
        "public <T extends JsonNode> T valueToTree(Object fromValue) throws IllegalArgumentException",
        "public boolean canSerialize(Class<?> type)",
        "public boolean canSerialize(Class<?> type, AtomicReference<Throwable> cause)",
        "public boolean canDeserialize(JavaType type)",
        "public boolean canDeserialize(JavaType type, AtomicReference<Throwable> cause)",
        "public <T> T readValue(File src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(File src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(File src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(URL src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(URL src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(URL src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(String content, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(String content, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(String content, JavaType valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(Reader src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(Reader src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(Reader src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(InputStream src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(InputStream src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(InputStream src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(byte[] src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(byte[] src, int offset, int len, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(byte[] src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(byte[] src, int offset, int len, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(byte[] src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(byte[] src, int offset, int len, JavaType valueType) throws IOException, JsonParseException, JsonMappingException",
        "public void writeValue(File resultFile, Object value) throws IOException, JsonGenerationException, JsonMappingException",
        "public void writeValue(OutputStream out, Object value) throws IOException, JsonGenerationException, JsonMappingException",
        "public void writeValue(Writer w, Object value) throws IOException, JsonGenerationException, JsonMappingException",
        "public String writeValueAsString(Object value) throws JsonProcessingException",
        "public byte[] writeValueAsBytes(Object value) throws JsonProcessingException",
        "public ObjectWriter writer()",
        "public ObjectWriter writer(SerializationFeature feature)",
        "public ObjectWriter writer(SerializationFeature first, SerializationFeature... other)",
        "public ObjectWriter writer(DateFormat df)",
        "public ObjectWriter writerWithView(Class<?> serializationView)",
        "public ObjectWriter writerWithType(Class<?> rootType)",
        "public ObjectWriter writerWithType(TypeReference<?> rootType)",
        "public ObjectWriter writerWithType(JavaType rootType)",
        "public ObjectWriter writer(PrettyPrinter pp)",
        "public ObjectWriter writerWithDefaultPrettyPrinter()",
        "public ObjectWriter writer(FilterProvider filterProvider)",
        "public ObjectWriter writer(FormatSchema schema)",
        "public ObjectWriter writer(Base64Variant defaultBase64)",
        "public ObjectWriter writer(CharacterEscapes escapes)",
        "public ObjectWriter writer(ContextAttributes attrs)",
        "public ObjectReader reader()",
        "public ObjectReader reader(DeserializationFeature feature)",
        "public ObjectReader reader(DeserializationFeature first, DeserializationFeature... other)",
        "public ObjectReader readerForUpdating(Object valueToUpdate)",
        "public ObjectReader reader(JavaType type)",
        "public ObjectReader reader(Class<?> type)",
        "public ObjectReader reader(TypeReference<?> type)",
        "public ObjectReader reader(JsonNodeFactory f)",
        "public ObjectReader reader(FormatSchema schema)",
        "public ObjectReader reader(InjectableValues injectableValues)",
        "public ObjectReader readerWithView(Class<?> view)",
        "public ObjectReader reader(Base64Variant defaultBase64)",
        "public ObjectReader reader(ContextAttributes attrs)",
        "public <T> T convertValue(Object fromValue, Class<T> toValueType) throws IllegalArgumentException",
        "public <T> T convertValue(Object fromValue, TypeReference<?> toValueTypeRef) throws IllegalArgumentException",
        "public <T> T convertValue(Object fromValue, JavaType toValueType) throws IllegalArgumentException",
        "protected Object _convert(Object fromValue, JavaType toValueType) throws IllegalArgumentException",
        "public com.fasterxml.jackson.databind.jsonschema.JsonSchema generateJsonSchema(Class<?> t) throws JsonMappingException",
        "public void acceptJsonFormatVisitor(Class<?> type, JsonFormatVisitorWrapper visitor) throws JsonMappingException",
        "public void acceptJsonFormatVisitor(JavaType type, JsonFormatVisitorWrapper visitor) throws JsonMappingException",
        "protected DefaultSerializerProvider _serializerProvider(SerializationConfig config)",
        "protected PrettyPrinter _defaultPrettyPrinter()",
        "protected final void _configAndWriteValue(JsonGenerator jgen, Object value) throws IOException, JsonGenerationException, JsonMappingException",
        "protected final void _configAndWriteValue(JsonGenerator jgen, Object value, Class<?> viewClass) throws IOException, JsonGenerationException, JsonMappingException",
        "private final void _configAndWriteCloseable(JsonGenerator jgen, Object value, SerializationConfig cfg) throws IOException, JsonGenerationException, JsonMappingException",
        "private final void _writeCloseableValue(JsonGenerator jgen, Object value, SerializationConfig cfg) throws IOException, JsonGenerationException, JsonMappingException",
        "protected DefaultDeserializationContext createDeserializationContext(JsonParser jp, DeserializationConfig cfg)",
        "protected Object _readValue(DeserializationConfig cfg, JsonParser jp, JavaType valueType) throws IOException, JsonParseException, JsonMappingException",
        "protected Object _readMapAndClose(JsonParser jp, JavaType valueType) throws IOException, JsonParseException, JsonMappingException",
        "protected JsonToken _initForReading(JsonParser jp) throws IOException, JsonParseException, JsonMappingException",
        "protected Object _unwrapAndDeserialize(JsonParser jp, DeserializationContext ctxt, DeserializationConfig config, JavaType rootType, JsonDeserializer<Object> deser) throws IOException, JsonParseException, JsonMappingException",
        "protected JsonDeserializer<Object> _findRootDeserializer(DeserializationContext ctxt, JavaType valueType) throws JsonMappingException",
        "protected void _verifySchemaType(FormatSchema schema)"
      ],
      "fixed_signatures": [
        "public TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes)",
        "public TypeSerializer buildTypeSerializer(SerializationConfig config, JavaType baseType, Collection<NamedType> subtypes)",
        "public boolean useForType(JavaType t)",
        "public ObjectMapper(JsonFactory jf)",
        "protected ObjectMapper(ObjectMapper src)",
        "public ObjectMapper(JsonFactory jf, DefaultSerializerProvider sp, DefaultDeserializationContext dc)",
        "public ObjectMapper copy()",
        "protected void _checkInvalidCopy(Class<?> exp)",
        "public Version version()",
        "public ObjectMapper registerModule(Module module)",
        "public Version getMapperVersion()",
        "public <C extends ObjectCodec> C getOwner()",
        "public TypeFactory getTypeFactory()",
        "public boolean isEnabled(MapperFeature f)",
        "public boolean isEnabled(DeserializationFeature f)",
        "public boolean isEnabled(SerializationFeature f)",
        "public boolean isEnabled(JsonFactory.Feature f)",
        "public boolean isEnabled(JsonParser.Feature f)",
        "public boolean isEnabled(JsonGenerator.Feature f)",
        "public void addDeserializers(Deserializers d)",
        "public void addKeyDeserializers(KeyDeserializers d)",
        "public void addBeanDeserializerModifier(BeanDeserializerModifier modifier)",
        "public void addSerializers(Serializers s)",
        "public void addKeySerializers(Serializers s)",
        "public void addBeanSerializerModifier(BeanSerializerModifier modifier)",
        "public void addAbstractTypeResolver(AbstractTypeResolver resolver)",
        "public void addTypeModifier(TypeModifier modifier)",
        "public void addValueInstantiators(ValueInstantiators instantiators)",
        "public void setClassIntrospector(ClassIntrospector ci)",
        "public void insertAnnotationIntrospector(AnnotationIntrospector ai)",
        "public void appendAnnotationIntrospector(AnnotationIntrospector ai)",
        "public void registerSubtypes(Class<?>... subtypes)",
        "public void registerSubtypes(NamedType... subtypes)",
        "public void setMixInAnnotations(Class<?> target, Class<?> mixinSource)",
        "public void addDeserializationProblemHandler(DeserializationProblemHandler handler)",
        "public void setNamingStrategy(PropertyNamingStrategy naming)",
        "public ObjectMapper registerModules(Module... modules)",
        "public ObjectMapper registerModules(Iterable<com.fasterxml.jackson.databind.Module> modules)",
        "public static List<com.fasterxml.jackson.databind.Module> findModules()",
        "public static List<com.fasterxml.jackson.databind.Module> findModules(ClassLoader classLoader)",
        "public ObjectMapper findAndRegisterModules()",
        "public SerializationConfig getSerializationConfig()",
        "public DeserializationConfig getDeserializationConfig()",
        "public DeserializationContext getDeserializationContext()",
        "public ObjectMapper setSerializerFactory(SerializerFactory f)",
        "public SerializerFactory getSerializerFactory()",
        "public ObjectMapper setSerializerProvider(DefaultSerializerProvider p)",
        "public SerializerProvider getSerializerProvider()",
        "public final void setMixInAnnotations(Map<Class<?>, Class<?>> sourceMixins)",
        "public final void addMixInAnnotations(Class<?> target, Class<?> mixinSource)",
        "public final ObjectMapper addMixIn(Class<?> target, Class<?> mixinSource)",
        "public final Class<?> findMixInClassFor(Class<?> cls)",
        "public final int mixInCount()",
        "public VisibilityChecker<?> getVisibilityChecker()",
        "public void setVisibilityChecker(VisibilityChecker<?> vc)",
        "public ObjectMapper setVisibility(PropertyAccessor forMethod, JsonAutoDetect.Visibility visibility)",
        "public SubtypeResolver getSubtypeResolver()",
        "public ObjectMapper setSubtypeResolver(SubtypeResolver str)",
        "public ObjectMapper setAnnotationIntrospector(AnnotationIntrospector ai)",
        "public ObjectMapper setAnnotationIntrospectors(AnnotationIntrospector serializerAI, AnnotationIntrospector deserializerAI)",
        "public ObjectMapper setPropertyNamingStrategy(PropertyNamingStrategy s)",
        "public ObjectMapper setSerializationInclusion(JsonInclude.Include incl)",
        "public ObjectMapper enableDefaultTyping()",
        "public ObjectMapper enableDefaultTyping(DefaultTyping dti)",
        "public ObjectMapper enableDefaultTyping(DefaultTyping applicability, JsonTypeInfo.As includeAs)",
        "public ObjectMapper enableDefaultTypingAsProperty(DefaultTyping applicability, String propertyName)",
        "public ObjectMapper disableDefaultTyping()",
        "public ObjectMapper setDefaultTyping(TypeResolverBuilder<?> typer)",
        "public void registerSubtypes(Class<?>... classes)",
        "public void registerSubtypes(NamedType... types)",
        "public TypeFactory getTypeFactory()",
        "public ObjectMapper setTypeFactory(TypeFactory f)",
        "public JavaType constructType(Type t)",
        "public ObjectMapper setNodeFactory(JsonNodeFactory f)",
        "public ObjectMapper addHandler(DeserializationProblemHandler h)",
        "public ObjectMapper clearProblemHandlers()",
        "public ObjectMapper setConfig(DeserializationConfig config)",
        "public void setFilters(FilterProvider filterProvider)",
        "public ObjectMapper setBase64Variant(Base64Variant v)",
        "public ObjectMapper setConfig(SerializationConfig config)",
        "public JsonFactory getFactory()",
        "public JsonFactory getJsonFactory()",
        "public ObjectMapper setDateFormat(DateFormat dateFormat)",
        "public Object setHandlerInstantiator(HandlerInstantiator hi)",
        "public ObjectMapper setInjectableValues(InjectableValues injectableValues)",
        "public ObjectMapper setLocale(Locale l)",
        "public ObjectMapper setTimeZone(TimeZone tz)",
        "public ObjectMapper configure(MapperFeature f, boolean state)",
        "public ObjectMapper configure(SerializationFeature f, boolean state)",
        "public ObjectMapper configure(DeserializationFeature f, boolean state)",
        "public ObjectMapper configure(JsonParser.Feature f, boolean state)",
        "public ObjectMapper configure(JsonGenerator.Feature f, boolean state)",
        "public ObjectMapper enable(MapperFeature... f)",
        "public ObjectMapper disable(MapperFeature... f)",
        "public ObjectMapper enable(DeserializationFeature feature)",
        "public ObjectMapper enable(DeserializationFeature first, DeserializationFeature... f)",
        "public ObjectMapper disable(DeserializationFeature feature)",
        "public ObjectMapper disable(DeserializationFeature first, DeserializationFeature... f)",
        "public ObjectMapper enable(SerializationFeature f)",
        "public ObjectMapper enable(SerializationFeature first, SerializationFeature... f)",
        "public ObjectMapper disable(SerializationFeature f)",
        "public ObjectMapper disable(SerializationFeature first, SerializationFeature... f)",
        "public boolean isEnabled(MapperFeature f)",
        "public boolean isEnabled(SerializationFeature f)",
        "public boolean isEnabled(DeserializationFeature f)",
        "public boolean isEnabled(JsonFactory.Feature f)",
        "public boolean isEnabled(JsonParser.Feature f)",
        "public boolean isEnabled(JsonGenerator.Feature f)",
        "public JsonNodeFactory getNodeFactory()",
        "public <T> T readValue(JsonParser jp, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(JsonParser jp, TypeReference<?> valueTypeRef) throws IOException, JsonParseException, JsonMappingException",
        "public final <T> T readValue(JsonParser jp, ResolvedType valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(JsonParser jp, JavaType valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T extends TreeNode> T readTree(JsonParser jp) throws IOException, JsonProcessingException",
        "public <T> MappingIterator<T> readValues(JsonParser jp, ResolvedType valueType) throws IOException, JsonProcessingException",
        "public <T> MappingIterator<T> readValues(JsonParser jp, JavaType valueType) throws IOException, JsonProcessingException",
        "public <T> MappingIterator<T> readValues(JsonParser jp, Class<T> valueType) throws IOException, JsonProcessingException",
        "public <T> MappingIterator<T> readValues(JsonParser jp, TypeReference<?> valueTypeRef) throws IOException, JsonProcessingException",
        "public JsonNode readTree(InputStream in) throws IOException, JsonProcessingException",
        "public JsonNode readTree(Reader r) throws IOException, JsonProcessingException",
        "public JsonNode readTree(String content) throws IOException, JsonProcessingException",
        "public JsonNode readTree(byte[] content) throws IOException, JsonProcessingException",
        "public JsonNode readTree(File file) throws IOException, JsonProcessingException",
        "public JsonNode readTree(URL source) throws IOException, JsonProcessingException",
        "public void writeValue(JsonGenerator jgen, Object value) throws IOException, JsonGenerationException, JsonMappingException",
        "public void writeTree(JsonGenerator jgen, TreeNode rootNode) throws IOException, JsonProcessingException",
        "public void writeTree(JsonGenerator jgen, JsonNode rootNode) throws IOException, JsonProcessingException",
        "public ObjectNode createObjectNode()",
        "public ArrayNode createArrayNode()",
        "public JsonParser treeAsTokens(TreeNode n)",
        "public <T> T treeToValue(TreeNode n, Class<T> valueType) throws JsonProcessingException",
        "public <T extends JsonNode> T valueToTree(Object fromValue) throws IllegalArgumentException",
        "public boolean canSerialize(Class<?> type)",
        "public boolean canSerialize(Class<?> type, AtomicReference<Throwable> cause)",
        "public boolean canDeserialize(JavaType type)",
        "public boolean canDeserialize(JavaType type, AtomicReference<Throwable> cause)",
        "public <T> T readValue(File src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(File src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(File src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(URL src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(URL src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(URL src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(String content, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(String content, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(String content, JavaType valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(Reader src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(Reader src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(Reader src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(InputStream src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(InputStream src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(InputStream src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(byte[] src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(byte[] src, int offset, int len, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(byte[] src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(byte[] src, int offset, int len, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(byte[] src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(byte[] src, int offset, int len, JavaType valueType) throws IOException, JsonParseException, JsonMappingException",
        "public void writeValue(File resultFile, Object value) throws IOException, JsonGenerationException, JsonMappingException",
        "public void writeValue(OutputStream out, Object value) throws IOException, JsonGenerationException, JsonMappingException",
        "public void writeValue(Writer w, Object value) throws IOException, JsonGenerationException, JsonMappingException",
        "public String writeValueAsString(Object value) throws JsonProcessingException",
        "public byte[] writeValueAsBytes(Object value) throws JsonProcessingException",
        "public ObjectWriter writer()",
        "public ObjectWriter writer(SerializationFeature feature)",
        "public ObjectWriter writer(SerializationFeature first, SerializationFeature... other)",
        "public ObjectWriter writer(DateFormat df)",
        "public ObjectWriter writerWithView(Class<?> serializationView)",
        "public ObjectWriter writerWithType(Class<?> rootType)",
        "public ObjectWriter writerWithType(TypeReference<?> rootType)",
        "public ObjectWriter writerWithType(JavaType rootType)",
        "public ObjectWriter writer(PrettyPrinter pp)",
        "public ObjectWriter writerWithDefaultPrettyPrinter()",
        "public ObjectWriter writer(FilterProvider filterProvider)",
        "public ObjectWriter writer(FormatSchema schema)",
        "public ObjectWriter writer(Base64Variant defaultBase64)",
        "public ObjectWriter writer(CharacterEscapes escapes)",
        "public ObjectWriter writer(ContextAttributes attrs)",
        "public ObjectReader reader()",
        "public ObjectReader reader(DeserializationFeature feature)",
        "public ObjectReader reader(DeserializationFeature first, DeserializationFeature... other)",
        "public ObjectReader readerForUpdating(Object valueToUpdate)",
        "public ObjectReader reader(JavaType type)",
        "public ObjectReader reader(Class<?> type)",
        "public ObjectReader reader(TypeReference<?> type)",
        "public ObjectReader reader(JsonNodeFactory f)",
        "public ObjectReader reader(FormatSchema schema)",
        "public ObjectReader reader(InjectableValues injectableValues)",
        "public ObjectReader readerWithView(Class<?> view)",
        "public ObjectReader reader(Base64Variant defaultBase64)",
        "public ObjectReader reader(ContextAttributes attrs)",
        "public <T> T convertValue(Object fromValue, Class<T> toValueType) throws IllegalArgumentException",
        "public <T> T convertValue(Object fromValue, TypeReference<?> toValueTypeRef) throws IllegalArgumentException",
        "public <T> T convertValue(Object fromValue, JavaType toValueType) throws IllegalArgumentException",
        "protected Object _convert(Object fromValue, JavaType toValueType) throws IllegalArgumentException",
        "public com.fasterxml.jackson.databind.jsonschema.JsonSchema generateJsonSchema(Class<?> t) throws JsonMappingException",
        "public void acceptJsonFormatVisitor(Class<?> type, JsonFormatVisitorWrapper visitor) throws JsonMappingException",
        "public void acceptJsonFormatVisitor(JavaType type, JsonFormatVisitorWrapper visitor) throws JsonMappingException",
        "protected DefaultSerializerProvider _serializerProvider(SerializationConfig config)",
        "protected PrettyPrinter _defaultPrettyPrinter()",
        "protected final void _configAndWriteValue(JsonGenerator jgen, Object value) throws IOException, JsonGenerationException, JsonMappingException",
        "protected final void _configAndWriteValue(JsonGenerator jgen, Object value, Class<?> viewClass) throws IOException, JsonGenerationException, JsonMappingException",
        "private final void _configAndWriteCloseable(JsonGenerator jgen, Object value, SerializationConfig cfg) throws IOException, JsonGenerationException, JsonMappingException",
        "private final void _writeCloseableValue(JsonGenerator jgen, Object value, SerializationConfig cfg) throws IOException, JsonGenerationException, JsonMappingException",
        "protected DefaultDeserializationContext createDeserializationContext(JsonParser jp, DeserializationConfig cfg)",
        "protected Object _readValue(DeserializationConfig cfg, JsonParser jp, JavaType valueType) throws IOException, JsonParseException, JsonMappingException",
        "protected Object _readMapAndClose(JsonParser jp, JavaType valueType) throws IOException, JsonParseException, JsonMappingException",
        "protected JsonToken _initForReading(JsonParser jp) throws IOException, JsonParseException, JsonMappingException",
        "protected Object _unwrapAndDeserialize(JsonParser jp, DeserializationContext ctxt, DeserializationConfig config, JavaType rootType, JsonDeserializer<Object> deser) throws IOException, JsonParseException, JsonMappingException",
        "protected JsonDeserializer<Object> _findRootDeserializer(DeserializationContext ctxt, JavaType valueType) throws JsonMappingException",
        "protected void _verifySchemaType(FormatSchema schema)"
      ],
      "methods": [
        {
          "buggy_method": "  public boolean useForType(JavaType t) {\n  switch (_appliesFor) {\n  case NON_CONCRETE_AND_ARRAYS:\n  while (t.isArrayType()) {\n  t = t.getContentType();\n  }\n  \n  case OBJECT_AND_NON_CONCRETE:\n\n  return (t.getRawClass() == Object.class)\n  || (!t.isConcrete()\n  \n  || TreeNode.class.isAssignableFrom(t.getRawClass()));\n\n  case NON_FINAL:\n  while (t.isArrayType()) {\n  t = t.getContentType();\n  }\n  \n  return !t.isFinal() && !TreeNode.class.isAssignableFrom(t.getRawClass());\n  default:\n  \n\n  return (t.getRawClass() == Object.class);\n  }\n  }",
          "fixed_method": "  public boolean useForType(JavaType t) {\n  switch (_appliesFor) {\n  case NON_CONCRETE_AND_ARRAYS:\n  while (t.isArrayType()) {\n  t = t.getContentType();\n  }\n  \n  case OBJECT_AND_NON_CONCRETE:\n\n  return (t.getRawClass() == Object.class)\n  || (!t.isConcrete()\n  \n  && !TreeNode.class.isAssignableFrom(t.getRawClass()));\n\n  case NON_FINAL:\n  while (t.isArrayType()) {\n  t = t.getContentType();\n  }\n  \n  return !t.isFinal() && !TreeNode.class.isAssignableFrom(t.getRawClass());\n  default:\n  \n\n  return (t.getRawClass() == Object.class);\n  }\n  }",
          "diff": [
            "@@ -177,7 +177,7 @@",
            "                 return (t.getRawClass() == Object.class)\n",
            "                         || (!t.isConcrete()\n",
            "                                 // [databind#88] Should not apply to JSON tree models:\n",
            "-                        || TreeNode.class.isAssignableFrom(t.getRawClass()));\n",
            "+                                && !TreeNode.class.isAssignableFrom(t.getRawClass()));\n",
            " \n",
            "             case NON_FINAL:\n",
            "                 while (t.isArrayType()) {\n"
          ],
          "changed_lines": 2
        }
      ]
    }
  ]
}
