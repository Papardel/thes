{
  "bug_id": "60",
  "failed_tests": {
    "org.apache.commons.lang.text.StrBuilderTest": [
      {
        "methodName": "testLang295",
        "error": "junit.framework.AssertionFailedError",
        "message": "The contains(char) method is looking beyond the end of the string",
        "fail_line": "        assertFalse( \"The contains(char) method is looking beyond the end of the string\", sb.contains('h'));",
        "test_source": "  public void testLang295() {\n  StrBuilder sb = new StrBuilder(\"onetwothree\");\n  sb.deleteFirst(\"three\");\n  assertFalse( \"The contains(char) method is looking beyond the end of the string\", sb.contains('h'));\n  assertEquals( \"The indexOf(char) method is looking beyond the end of the string\", -1, sb.indexOf('h'));\n  }",
        "stack": [
          "StrBuilderTest.testLang295 line 1748"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/lang/text/StrBuilder.java",
      "buggy_full_code": "\npackage org.apache.commons.lang.text;\n\nimport java.io.Reader;\nimport java.io.Writer;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport org.apache.commons.lang.ArrayUtils;\nimport org.apache.commons.lang.SystemUtils;\n\n\npublic class StrBuilder implements Cloneable { static final int CAPACITY = 32; private static final long serialVersionUID = 7628716375283629643L; protected char[] buffer; protected int size; private String newLine; private String nullText; public StrBuilder() {\n        this(CAPACITY);\n    }\n\n    \n    public StrBuilder(int initialCapacity) {\n        super();\n        if (initialCapacity <= 0) {\n            initialCapacity = CAPACITY;\n        }\n        buffer = new char[initialCapacity];\n    }\n\n    \n    public StrBuilder(String str) {\n        super();\n        if (str == null) {\n            buffer = new char[CAPACITY];\n        } else {\n            buffer = new char[str.length() + CAPACITY];\n            append(str);\n        }\n    }\n\n    \n    \n    public String getNewLineText() {\n        return newLine;\n    }\n\n    \n    public StrBuilder setNewLineText(String newLine) {\n        this.newLine = newLine;\n        return this;\n    }\n\n    \n    \n    public String getNullText() {\n        return nullText;\n    }\n\n    \n    public StrBuilder setNullText(String nullText) {\n        if (nullText != null && nullText.length() == 0) {\n            nullText = null;\n        }\n        this.nullText = nullText;\n        return this;\n    }\n\n    \n    \n    public int length() {\n        return size;\n    }\n\n    \n    public StrBuilder setLength(int length) {\n        if (length < 0) {\n            throw new StringIndexOutOfBoundsException(length);\n        }\n        if (length < size) {\n            size = length;\n        } else if (length > size) {\n            ensureCapacity(length);\n            int oldEnd = size;\n            int newEnd = length;\n            size = length;\n            for (int i = oldEnd; i < newEnd; i++) {\n                buffer[i] = '\\0';\n            }\n        }\n        return this;\n    }\n\n    \n    \n    public int capacity() {\n        return buffer.length;\n    }\n\n    \n    public StrBuilder ensureCapacity(int capacity) {\n        if (capacity > buffer.length) {\n            char[] old = buffer;\n            buffer = new char[capacity];\n            System.arraycopy(old, 0, buffer, 0, size);\n        }\n        return this;\n    }\n\n    \n    public StrBuilder minimizeCapacity() {\n        if (buffer.length > length()) {\n            char[] old = buffer;\n            buffer = new char[length()];\n            System.arraycopy(old, 0, buffer, 0, size);\n        }\n        return this;\n    }\n\n    \n    \n    public int size() {\n        return size;\n    }\n\n    \n    public boolean isEmpty() {\n        return size == 0;\n    }\n\n    \n    public StrBuilder clear() {\n        size = 0;\n        return this;\n    }\n\n    \n    \n    public char charAt(int index) {\n        if (index < 0 || index >= length()) {\n            throw new StringIndexOutOfBoundsException(index);\n        }\n        return buffer[index];\n    }\n\n    \n    public StrBuilder setCharAt(int index, char ch) {\n        if (index < 0 || index >= length()) {\n            throw new StringIndexOutOfBoundsException(index);\n        }\n        buffer[index] = ch;\n        return this;\n    }\n\n    \n    public StrBuilder deleteCharAt(int index) {\n        if (index < 0 || index >= size) {\n            throw new StringIndexOutOfBoundsException(index);\n        }\n        deleteImpl(index, index + 1, 1);\n        return this;\n    }\n\n    \n    \n    public char[] toCharArray() {\n        if (size == 0) {\n            return ArrayUtils.EMPTY_CHAR_ARRAY;\n        }\n        char chars[] = new char[size];\n        System.arraycopy(buffer, 0, chars, 0, size);\n        return chars;\n    }\n\n    \n    public char[] toCharArray(int startIndex, int endIndex) {\n        endIndex = validateRange(startIndex, endIndex);\n        int len = endIndex - startIndex;\n        if (len == 0) {\n            return ArrayUtils.EMPTY_CHAR_ARRAY;\n        }\n        char chars[] = new char[len];\n        System.arraycopy(buffer, startIndex, chars, 0, len);\n        return chars;\n    }\n\n    \n    public char[] getChars(char[] destination) {\n        int len = length();\n        if (destination == null || destination.length < len) {\n            destination = new char[len];\n        }\n        System.arraycopy(buffer, 0, destination, 0, len);\n        return destination;\n    }\n\n    \n    public void getChars(int startIndex, int endIndex, char destination[], int destinationIndex) {\n        if (startIndex < 0) {\n            throw new StringIndexOutOfBoundsException(startIndex);\n        }\n        if (endIndex < 0 || endIndex > length()) {\n            throw new StringIndexOutOfBoundsException(endIndex);\n        }\n        if (startIndex > endIndex) {\n            throw new StringIndexOutOfBoundsException(\"end < start\");\n        }\n        System.arraycopy(buffer, startIndex, destination, destinationIndex, endIndex - startIndex);\n    }\n\n    \n    \n    public StrBuilder appendNewLine() {\n        if (newLine == null)  {\n            append(SystemUtils.LINE_SEPARATOR);\n            return this;\n        }\n        return append(newLine);\n    }\n\n    \n    public StrBuilder appendNull() {\n        if (nullText == null)  {\n            return this;\n        }\n        return append(nullText);\n    }\n\n    \n    public StrBuilder append(Object obj) {\n        if (obj == null) {\n            return appendNull();\n        } \n        return append(obj.toString());        \n    }\n\n    \n    public StrBuilder append(String str) {\n        if (str == null) {\n            return appendNull();\n        }\n        int strLen = str.length();\n        if (strLen > 0) {\n            int len = length();\n            ensureCapacity(len + strLen);\n            str.getChars(0, strLen, buffer, len);\n            size += strLen;\n        }\n        return this;\n    }\n\n    \n    public StrBuilder append(String str, int startIndex, int length) {\n        if (str == null) {\n            return appendNull();\n        }\n        if (startIndex < 0 || startIndex > str.length()) {\n            throw new StringIndexOutOfBoundsException(\"startIndex must be valid\");\n        }\n        if (length < 0 || (startIndex + length) > str.length()) {\n            throw new StringIndexOutOfBoundsException(\"length must be valid\");\n        }\n        if (length > 0) {\n            int len = length();\n            ensureCapacity(len + length);\n            str.getChars(startIndex, startIndex + length, buffer, len);\n            size += length;\n        }\n        return this;\n    }\n\n    \n    public StrBuilder append(StringBuffer str) {\n        if (str == null) {\n            return appendNull();\n        }\n        int strLen = str.length();\n        if (strLen > 0) {\n            int len = length();\n            ensureCapacity(len + strLen);\n            str.getChars(0, strLen, buffer, len);\n            size += strLen;\n        }\n        return this;\n    }\n\n    \n    public StrBuilder append(StringBuffer str, int startIndex, int length) {\n        if (str == null) {\n            return appendNull();\n        }\n        if (startIndex < 0 || startIndex > str.length()) {\n            throw new StringIndexOutOfBoundsException(\"startIndex must be valid\");\n        }\n        if (length < 0 || (startIndex + length) > str.length()) {\n            throw new StringIndexOutOfBoundsException(\"length must be valid\");\n        }\n        if (length > 0) {\n            int len = length();\n            ensureCapacity(len + length);\n            str.getChars(startIndex, startIndex + length, buffer, len);\n            size += length;\n        }\n        return this;\n    }\n\n    \n    public StrBuilder append(StrBuilder str) {\n        if (str == null) {\n            return appendNull();\n        }\n        int strLen = str.length();\n        if (strLen > 0) {\n            int len = length();\n            ensureCapacity(len + strLen);\n            System.arraycopy(str.buffer, 0, buffer, len, strLen);\n            size += strLen;\n        }\n        return this;\n    }\n\n    \n    public StrBuilder append(StrBuilder str, int startIndex, int length) {\n        if (str == null) {\n            return appendNull();\n        }\n        if (startIndex < 0 || startIndex > str.length()) {\n            throw new StringIndexOutOfBoundsException(\"startIndex must be valid\");\n        }\n        if (length < 0 || (startIndex + length) > str.length()) {\n            throw new StringIndexOutOfBoundsException(\"length must be valid\");\n        }\n        if (length > 0) {\n            int len = length();\n            ensureCapacity(len + length);\n            str.getChars(startIndex, startIndex + length, buffer, len);\n            size += length;\n        }\n        return this;\n    }\n\n    \n    public StrBuilder append(char[] chars) {\n        if (chars == null) {\n            return appendNull();\n        }\n        int strLen = chars.length;\n        if (strLen > 0) {\n            int len = length();\n            ensureCapacity(len + strLen);\n            System.arraycopy(chars, 0, buffer, len, strLen);\n            size += strLen;\n        }\n        return this;\n    }\n\n    \n    public StrBuilder append(char[] chars, int startIndex, int length) {\n        if (chars == null) {\n            return appendNull();\n        }\n        if (startIndex < 0 || startIndex > chars.length) {\n            throw new StringIndexOutOfBoundsException(\"Invalid startIndex: \" + length);\n        }\n        if (length < 0 || (startIndex + length) > chars.length) {\n            throw new StringIndexOutOfBoundsException(\"Invalid length: \" + length);\n        }\n        if (length > 0) {\n            int len = length();\n            ensureCapacity(len + length);\n            System.arraycopy(chars, startIndex, buffer, len, length);\n            size += length;\n        }\n        return this;\n    }\n\n    \n    public StrBuilder append(boolean value) {\n        if (value) {\n            ensureCapacity(size + 4);\n            buffer[size++] = 't';\n            buffer[size++] = 'r';\n            buffer[size++] = 'u';\n            buffer[size++] = 'e';\n        } else {\n            ensureCapacity(size + 5);\n            buffer[size++] = 'f';\n            buffer[size++] = 'a';\n            buffer[size++] = 'l';\n            buffer[size++] = 's';\n            buffer[size++] = 'e';\n        }\n        return this;\n    }\n\n    \n    public StrBuilder append(char ch) {\n        int len = length();\n        ensureCapacity(len + 1);\n        buffer[size++] = ch;\n        return this;\n    }\n\n    \n    public StrBuilder append(int value) {\n        return append(String.valueOf(value));\n    }\n\n    \n    public StrBuilder append(long value) {\n        return append(String.valueOf(value));\n    }\n\n    \n    public StrBuilder append(float value) {\n        return append(String.valueOf(value));\n    }\n\n    \n    public StrBuilder append(double value) {\n        return append(String.valueOf(value));\n    }\n\n    \n    \n    public StrBuilder appendWithSeparators(Object[] array, String separator) {\n        if (array != null && array.length > 0) {\n            separator = (separator == null ? \"\" : separator);\n            append(array[0]);\n            for (int i = 1; i < array.length; i++) {\n                append(separator);\n                append(array[i]);\n            }\n        }\n        return this;\n    }\n\n    \n    public StrBuilder appendWithSeparators(Collection coll, String separator) {\n        if (coll != null && coll.size() > 0) {\n            separator = (separator == null ? \"\" : separator);\n            Iterator it = coll.iterator();\n            while (it.hasNext()) {\n                append(it.next());\n                if (it.hasNext()) {\n                    append(separator);\n                }\n            }\n        }\n        return this;\n    }\n\n    \n    public StrBuilder appendWithSeparators(Iterator it, String separator) {\n        if (it != null) {\n            separator = (separator == null ? \"\" : separator);\n            while (it.hasNext()) {\n                append(it.next());\n                if (it.hasNext()) {\n                    append(separator);\n                }\n            }\n        }\n        return this;\n    }\n\n    \n    \n    public StrBuilder appendPadding(int length, char padChar) {\n        if (length >= 0) {\n            ensureCapacity(size + length);\n            for (int i = 0; i < length; i++) {\n                buffer[size++] = padChar;\n            }\n        }\n        return this;\n    }\n\n    \n    \n    public StrBuilder appendFixedWidthPadLeft(Object obj, int width, char padChar) {\n        if (width > 0) {\n            ensureCapacity(size + width);\n            String str = (obj == null ? getNullText() : obj.toString());\n            int strLen = str.length();\n            if (strLen >= width) {\n                str.getChars(strLen - width, strLen, buffer, size);\n            } else {\n                int padLen = width - strLen;\n                for (int i = 0; i < padLen; i++) {\n                    buffer[size + i] = padChar;\n                }\n                str.getChars(0, strLen, buffer, size + padLen);\n            }\n            size += width;\n        }\n        return this;\n    }\n\n    \n    public StrBuilder appendFixedWidthPadLeft(int value, int width, char padChar) {\n        return appendFixedWidthPadLeft(String.valueOf(value), width, padChar);\n    }\n\n    \n    public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n        if (width > 0) {\n            ensureCapacity(size + width);\n            String str = (obj == null ? getNullText() : obj.toString());\n            int strLen = str.length();\n            if (strLen >= width) {\n                str.getChars(0, strLen, buffer, size);\n            } else {\n                int padLen = width - strLen;\n                str.getChars(0, strLen, buffer, size);\n                for (int i = 0; i < padLen; i++) {\n                    buffer[size + strLen + i] = padChar;\n                }\n            }\n            size += width;\n        }\n        return this;\n    }\n\n    \n    public StrBuilder appendFixedWidthPadRight(int value, int width, char padChar) {\n        return appendFixedWidthPadRight(String.valueOf(value), width, padChar);\n    }\n\n    \n    \n    public StrBuilder insert(int index, Object obj) {\n        if (obj == null) {\n            return insert(index, nullText);\n        }\n        return insert(index, obj.toString());\n    }\n\n    \n    public StrBuilder insert(int index, String str) {\n        validateIndex(index);\n        if (str == null) {\n            str = nullText;\n        }\n        int strLen = (str == null ? 0 : str.length());\n        if (strLen > 0) {\n            int newSize = size + strLen;\n            ensureCapacity(newSize);\n            System.arraycopy(buffer, index, buffer, index + strLen, size - index);\n            size = newSize;\n            str.getChars(0, strLen, buffer, index);\n        }\n        return this;\n    }\n\n    \n    public StrBuilder insert(int index, char chars[]) {\n        validateIndex(index);\n        if (chars == null) {\n            return insert(index, nullText);\n        }\n        int len = chars.length;\n        if (len > 0) {\n            ensureCapacity(size + len);\n            System.arraycopy(buffer, index, buffer, index + len, size - index);\n            System.arraycopy(chars, 0, buffer, index, len);\n            size += len;\n        }\n        return this;\n    }\n\n    \n    public StrBuilder insert(int index, char chars[], int offset, int length) {\n        validateIndex(index);\n        if (chars == null) {\n            return insert(index, nullText);\n        }\n        if (offset < 0 || offset > chars.length) {\n            throw new StringIndexOutOfBoundsException(\"Invalid offset: \" + offset);\n        }\n        if (length < 0 || offset + length > chars.length) {\n            throw new StringIndexOutOfBoundsException(\"Invalid length: \" + length);\n        }\n        if (length > 0) {\n            ensureCapacity(size + length);\n            System.arraycopy(buffer, index, buffer, index + length, size - index);\n            System.arraycopy(chars, offset, buffer, index, length);\n            size += length;\n        }\n        return this;\n    }\n\n    \n    public StrBuilder insert(int index, boolean value) {\n        validateIndex(index);\n        if (value) {\n            ensureCapacity(size + 4);\n            System.arraycopy(buffer, index, buffer, index + 4, size - index);\n            buffer[index++] = 't';\n            buffer[index++] = 'r';\n            buffer[index++] = 'u';\n            buffer[index] = 'e';\n            size += 4;\n        } else {\n            ensureCapacity(size + 5);\n            System.arraycopy(buffer, index, buffer, index + 5, size - index);\n            buffer[index++] = 'f';\n            buffer[index++] = 'a';\n            buffer[index++] = 'l';\n            buffer[index++] = 's';\n            buffer[index] = 'e';\n            size += 5;\n        }\n        return this;\n    }\n\n    \n    public StrBuilder insert(int index, char value) {\n        validateIndex(index);\n        ensureCapacity(size + 1);\n        System.arraycopy(buffer, index, buffer, index + 1, size - index);\n        buffer[index] = value;\n        size++;\n        return this;\n    }\n\n    \n    public StrBuilder insert(int index, int value) {\n        return insert(index, String.valueOf(value));\n    }\n\n    \n    public StrBuilder insert(int index, long value) {\n        return insert(index, String.valueOf(value));\n    }\n\n    \n    public StrBuilder insert(int index, float value) {\n        return insert(index, String.valueOf(value));\n    }\n\n    \n    public StrBuilder insert(int index, double value) {\n        return insert(index, String.valueOf(value));\n    }\n\n    \n    \n    private void deleteImpl(int startIndex, int endIndex, int len) {\n        System.arraycopy(buffer, endIndex, buffer, startIndex, size - endIndex);\n        size -= len;\n    }\n\n    \n    public StrBuilder delete(int startIndex, int endIndex) {\n        endIndex = validateRange(startIndex, endIndex);\n        int len = endIndex - startIndex;\n        if (len > 0) {\n            deleteImpl(startIndex, endIndex, len);\n        }\n        return this;\n    }\n\n    \n    \n    public StrBuilder deleteAll(char ch) {\n        for (int i = 0; i < size; i++) {\n            if (buffer[i] == ch) {\n                int start = i;\n                while (++i < size) {\n                    if (buffer[i] != ch) {\n                        break;\n                    }\n                }\n                int len = i - start;\n                deleteImpl(start, i, len);\n                i -= len;\n            }\n        }\n        return this;\n    }\n\n    \n    public StrBuilder deleteFirst(char ch) {\n        for (int i = 0; i < size; i++) {\n            if (buffer[i] == ch) {\n                deleteImpl(i, i + 1, 1);\n                break;\n            }\n        }\n        return this;\n    }\n\n    \n    \n    public StrBuilder deleteAll(String str) {\n        int len = (str == null ? 0 : str.length());\n        if (len > 0) {\n            int index = indexOf(str, 0);\n            while (index >= 0) {\n                deleteImpl(index, index + len, len);\n                index = indexOf(str, index);\n            }\n        }\n        return this;\n    }\n\n    \n    public StrBuilder deleteFirst(String str) {\n        int len = (str == null ? 0 : str.length());\n        if (len > 0) {\n            int index = indexOf(str, 0);\n            if (index >= 0) {\n                deleteImpl(index, index + len, len);\n            }\n        }\n        return this;\n    }\n\n    \n    \n    public StrBuilder deleteAll(StrMatcher matcher) {\n        return replace(matcher, null, 0, size, -1);\n    }\n\n    \n    public StrBuilder deleteFirst(StrMatcher matcher) {\n        return replace(matcher, null, 0, size, 1);\n    }\n\n    \n    \n    private void replaceImpl(int startIndex, int endIndex, int removeLen, String insertStr, int insertLen) {\n        int newSize = size - removeLen + insertLen;\n        if (insertLen != removeLen) {\n            ensureCapacity(newSize);\n            System.arraycopy(buffer, endIndex, buffer, startIndex + insertLen, size - endIndex);\n            size = newSize;\n        }\n        if (insertLen > 0) {\n            insertStr.getChars(0, insertLen, buffer, startIndex);\n        }\n    }\n\n    \n    public StrBuilder replace(int startIndex, int endIndex, String replaceStr) {\n        endIndex = validateRange(startIndex, endIndex);\n        int insertLen = (replaceStr == null ? 0 : replaceStr.length());\n        replaceImpl(startIndex, endIndex, endIndex - startIndex, replaceStr, insertLen);\n        return this;\n    }\n\n    \n    \n    public StrBuilder replaceAll(char search, char replace) {\n        if (search != replace) {\n            for (int i = 0; i < size; i++) {\n                if (buffer[i] == search) {\n                    buffer[i] = replace;\n                }\n            }\n        }\n        return this;\n    }\n\n    \n    public StrBuilder replaceFirst(char search, char replace) {\n        if (search != replace) {\n            for (int i = 0; i < size; i++) {\n                if (buffer[i] == search) {\n                    buffer[i] = replace;\n                    break;\n                }\n            }\n        }\n        return this;\n    }\n\n    \n    \n    public StrBuilder replaceAll(String searchStr, String replaceStr) {\n        int searchLen = (searchStr == null ? 0 : searchStr.length());\n        if (searchLen > 0) {\n            int replaceLen = (replaceStr == null ? 0 : replaceStr.length());\n            int index = indexOf(searchStr, 0);\n            while (index >= 0) {\n                replaceImpl(index, index + searchLen, searchLen, replaceStr, replaceLen);\n                index = indexOf(searchStr, index + replaceLen);\n            }\n        }\n        return this;\n    }\n\n    \n    public StrBuilder replaceFirst(String searchStr, String replaceStr) {\n        int searchLen = (searchStr == null ? 0 : searchStr.length());\n        if (searchLen > 0) {\n            int index = indexOf(searchStr, 0);\n            if (index >= 0) {\n                int replaceLen = (replaceStr == null ? 0 : replaceStr.length());\n                replaceImpl(index, index + searchLen, searchLen, replaceStr, replaceLen);\n            }\n        }\n        return this;\n    }\n\n    \n    \n    public StrBuilder replaceAll(StrMatcher matcher, String replaceStr) {\n        return replace(matcher, replaceStr, 0, size, -1);\n    }\n\n    \n    public StrBuilder replaceFirst(StrMatcher matcher, String replaceStr) {\n        return replace(matcher, replaceStr, 0, size, 1);\n    }\n\n    \n    \n    public StrBuilder replace( StrMatcher matcher, String replaceStr, int startIndex, int endIndex, int replaceCount) {\n        endIndex = validateRange(startIndex, endIndex);\n        return replaceImpl(matcher, replaceStr, startIndex, endIndex, replaceCount);\n    }\n\n    \n    private StrBuilder replaceImpl( StrMatcher matcher, String replaceStr, int from, int to, int replaceCount) {\n        if (matcher == null || size == 0) {\n            return this;\n        }\n        int replaceLen = (replaceStr == null ? 0 : replaceStr.length());\n        char[] buf = buffer;\n        for (int i = from; i < to && replaceCount != 0; i++) {\n            int removeLen = matcher.isMatch(buf, i, from, to);\n            if (removeLen > 0) {\n                replaceImpl(i, i + removeLen, removeLen, replaceStr, replaceLen);\n                to = to - removeLen + replaceLen;\n                i = i + replaceLen - 1;\n                if (replaceCount > 0) {\n                    replaceCount--;\n                }\n            }\n        }\n        return this;\n    }\n\n    \n    \n    public StrBuilder reverse() {\n        if (size == 0) {\n            return this;\n        }\n        \n        int half = size / 2;\n        char[] buf = buffer;\n        for (int leftIdx = 0, rightIdx = size - 1; leftIdx < half; leftIdx++,rightIdx--) {\n            char swap = buf[leftIdx];\n            buf[leftIdx] = buf[rightIdx];\n            buf[rightIdx] = swap;\n        }\n        return this;\n    }\n\n    \n    \n    public StrBuilder trim() {\n        if (size == 0) {\n            return this;\n        }\n        int len = size;\n        char[] buf = buffer;\n        int pos = 0;\n        while (pos < len && buf[pos] <= ' ') {\n            pos++;\n        }\n        while (pos < len && buf[len - 1] <= ' ') {\n            len--;\n        }\n        if (len < size) {\n            delete(len, size);\n        }\n        if (pos > 0) {\n            delete(0, pos);\n        }\n        return this;\n    }\n\n    \n    \n    public boolean startsWith(String str) {\n        if (str == null) {\n            return false;\n        }\n        int len = str.length();\n        if (len == 0) {\n            return true;\n        }\n        if (len > size) {\n            return false;\n        }\n        for (int i = 0; i < len; i++) {\n            if (buffer[i] != str.charAt(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public boolean endsWith(String str) {\n        if (str == null) {\n            return false;\n        }\n        int len = str.length();\n        if (len == 0) {\n            return true;\n        }\n        if (len > size) {\n            return false;\n        }\n        int pos = size - len;\n        for (int i = 0; i < len; i++,pos++) {\n            if (buffer[pos] != str.charAt(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    \n    public String substring(int start) {\n        return substring(start, size);\n    }\n\n    \n    public String substring(int startIndex, int endIndex) {\n        endIndex = validateRange(startIndex, endIndex);\n        return new String(buffer, startIndex, endIndex - startIndex);\n    }\n\n    \n    public String leftString(int length) {\n        if (length <= 0) {\n            return \"\";\n        } else if (length >= size) {\n            return new String(buffer, 0, size);\n        } else {\n            return new String(buffer, 0, length);\n        }\n    }\n\n    \n    public String rightString(int length) {\n        if (length <= 0) {\n            return \"\";\n        } else if (length >= size) {\n            return new String(buffer, 0, size);\n        } else {\n            return new String(buffer, size - length, length);\n        }\n    }\n\n    \n    public String midString(int index, int length) {\n        if (index < 0) {\n            index = 0;\n        }\n        if (length <= 0 || index >= size) {\n            return \"\";\n        }\n        if (size <= index + length) {\n            return new String(buffer, index, size - index);\n        } else {\n            return new String(buffer, index, length);\n        }\n    }\n\n    \n    \n    public boolean contains(char ch) {\n        char[] thisBuf = buffer;\n        for (int i = 0; i < thisBuf.length; i++) {\n            if (thisBuf[i] == ch) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    \n    public boolean contains(String str) {\n        return indexOf(str, 0) >= 0;\n    }\n\n    \n    public boolean contains(StrMatcher matcher) {\n        return indexOf(matcher, 0) >= 0;\n    }\n\n    \n    \n    public int indexOf(char ch) {\n        return indexOf(ch, 0);\n    }\n\n    \n    public int indexOf(char ch, int startIndex) {\n        startIndex = (startIndex < 0 ? 0 : startIndex);\n        if (startIndex >= size) {\n            return -1;\n        }\n        char[] thisBuf = buffer;\n        for (int i = startIndex; i < thisBuf.length; i++) {\n            if (thisBuf[i] == ch) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    \n    public int indexOf(String str) {\n        return indexOf(str, 0);\n    }\n\n    \n    public int indexOf(String str, int startIndex) {\n        startIndex = (startIndex < 0 ? 0 : startIndex);\n        if (str == null || startIndex >= size) {\n            return -1;\n        }\n        int strLen = str.length();\n        if (strLen == 1) {\n            return indexOf(str.charAt(0), startIndex);\n        }\n        if (strLen == 0) {\n            return startIndex;\n        }\n        if (strLen > size) {\n            return -1;\n        }\n        char[] thisBuf = buffer;\n        int len = size - strLen + 1;\n        outer:\n        for (int i = startIndex; i < len; i++) {\n            for (int j = 0; j < strLen; j++) {\n                if (str.charAt(j) != thisBuf[i + j]) {\n                    continue outer;\n                }\n            }\n            return i;\n        }\n        return -1;\n    }\n\n    \n    public int indexOf(StrMatcher matcher) {\n        return indexOf(matcher, 0);\n    }\n\n    \n    public int indexOf(StrMatcher matcher, int startIndex) {\n        startIndex = (startIndex < 0 ? 0 : startIndex);\n        if (matcher == null || startIndex >= size) {\n            return -1;\n        }\n        int len = size;\n        char[] buf = buffer;\n        for (int i = startIndex; i < len; i++) {\n            if (matcher.isMatch(buf, i, startIndex, len) > 0) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    \n    \n    public int lastIndexOf(char ch) {\n        return lastIndexOf(ch, size - 1);\n    }\n\n    \n    public int lastIndexOf(char ch, int startIndex) {\n        startIndex = (startIndex >= size ? size - 1 : startIndex);\n        if (startIndex < 0) {\n            return -1;\n        }\n        for (int i = startIndex; i >= 0; i--) {\n            if (buffer[i] == ch) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    \n    public int lastIndexOf(String str) {\n        return lastIndexOf(str, size - 1);\n    }\n\n    \n    public int lastIndexOf(String str, int startIndex) {\n        startIndex = (startIndex >= size ? size - 1 : startIndex);\n        if (str == null || startIndex < 0) {\n            return -1;\n        }\n        int strLen = str.length();\n        if (strLen > 0 && strLen <= size) {\n            if (strLen == 1) {\n                return lastIndexOf(str.charAt(0), startIndex);\n            }\n\n            outer:\n            for (int i = startIndex - strLen + 1; i >= 0; i--) {\n                for (int j = 0; j < strLen; j++) {\n                    if (str.charAt(j) != buffer[i + j]) {\n                        continue outer;\n                    }\n                }\n                return i;\n            }\n            \n        } else if (strLen == 0) {\n            return startIndex;\n        }\n        return -1;\n    }\n\n    \n    public int lastIndexOf(StrMatcher matcher) {\n        return lastIndexOf(matcher, size);\n    }\n\n    \n    public int lastIndexOf(StrMatcher matcher, int startIndex) {\n        startIndex = (startIndex >= size ? size - 1 : startIndex);\n        if (matcher == null || startIndex < 0) {\n            return -1;\n        }\n        char[] buf = buffer;\n        int endIndex = startIndex + 1;\n        for (int i = startIndex; i >= 0; i--) {\n            if (matcher.isMatch(buf, i, 0, endIndex) > 0) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    \n    \n    public StrTokenizer asTokenizer() {\n        return new StrBuilderTokenizer();\n    }\n\n    \n    \n    public Reader asReader() {\n        return new StrBuilderReader();\n    }\n\n    \n    \n    public Writer asWriter() {\n        return new StrBuilderWriter();\n    }\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n    \n    public boolean equalsIgnoreCase(StrBuilder other) {\n        if (this == other) {\n            return true;\n        }\n        if (this.size != other.size) {\n            return false;\n        }\n        char thisBuf[] = this.buffer;\n        char otherBuf[] = other.buffer;\n        for (int i = size - 1; i >= 0; i--) {\n            char c1 = thisBuf[i];\n            char c2 = otherBuf[i];\n            if (c1 != c2 && Character.toUpperCase(c1) != Character.toUpperCase(c2)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public boolean equals(StrBuilder other) {\n        if (this == other) {\n            return true;\n        }\n        if (this.size != other.size) {\n            return false;\n        }\n        char thisBuf[] = this.buffer;\n        char otherBuf[] = other.buffer;\n        for (int i = size - 1; i >= 0; i--) {\n            if (thisBuf[i] != otherBuf[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public boolean equals(Object obj) {\n        if (obj instanceof StrBuilder) {\n            return equals((StrBuilder) obj);\n        }\n        return false;\n    }\n\n    \n    public int hashCode() {\n        char buf[] = buffer;\n        int hash = 0;\n        for (int i = size - 1; i >= 0; i--) {\n            hash = 31 * hash + buf[i];\n        }\n        return hash;\n    }\n\n    \n    \n    public String toString() {\n        return new String(buffer, 0, size);\n    }\n\n    \n    public StringBuffer toStringBuffer() {\n        return new StringBuffer(size).append(buffer, 0, size);\n    }\n\n    \n    \n    protected int validateRange(int startIndex, int endIndex) {\n        if (startIndex < 0) {\n            throw new StringIndexOutOfBoundsException(startIndex);\n        }\n        if (endIndex > size) {\n            endIndex = size;\n        }\n        if (startIndex > endIndex) {\n            throw new StringIndexOutOfBoundsException(\"end < start\");\n        }\n        return endIndex;\n    }\n\n    \n    protected void validateIndex(int index) {\n        if (index < 0 || index > size) {\n            throw new StringIndexOutOfBoundsException(index);\n        }\n    }\n\n    \n    \n    class StrBuilderTokenizer extends StrTokenizer {\n\n        \n        StrBuilderTokenizer() {\n            super();\n        }\n\n        \n        protected List tokenize(char[] chars, int offset, int count) {\n            if (chars == null) {\n                return super.tokenize(StrBuilder.this.buffer, 0, StrBuilder.this.size());\n            } else {\n                return super.tokenize(chars, offset, count);\n            }\n        }\n\n        \n        public String getContent() {\n            String str = super.getContent();\n            if (str == null) {\n                return StrBuilder.this.toString();\n            } else {\n                return str;\n            }\n        }\n    }\n\n    \n    \n    class StrBuilderReader extends Reader {\n        \n        private int pos; private int mark; StrBuilderReader() {\n            super();\n        }\n\n        \n        public void close() {\n            \n        }\n\n        \n        public int read() {\n            if (ready() == false) {\n                return -1;\n            }\n            return StrBuilder.this.charAt(pos++);\n        }\n\n        \n        public int read(char b[], int off, int len) {\n            if (off < 0 || len < 0 || off > b.length ||\n                    (off + len) > b.length || (off + len) < 0) {\n                throw new IndexOutOfBoundsException();\n            }\n            if (len == 0) {\n                return 0;\n            }\n            if (pos >= StrBuilder.this.size()) {\n                return -1;\n            }\n            if (pos + len > size()) {\n                len = StrBuilder.this.size() - pos;\n            }\n            StrBuilder.this.getChars(pos, pos + len, b, off);\n            pos += len;\n            return len;\n        }\n\n        \n        public long skip(long n) {\n            if (pos + n > StrBuilder.this.size()) {\n                n = StrBuilder.this.size() - pos;\n            }\n            if (n < 0) {\n                return 0;\n            }\n            pos += n;\n            return n;\n        }\n\n        \n        public boolean ready() {\n            return pos < StrBuilder.this.size();\n        }\n\n        \n        public boolean markSupported() {\n            return true;\n        }\n\n        \n        public void mark(int readAheadLimit) {\n            mark = pos;\n        }\n\n        \n        public void reset() {\n            pos = mark;\n        }\n    }\n\n    \n    \n    class StrBuilderWriter extends Writer {\n\n        \n        StrBuilderWriter() {\n            super();\n        }\n\n        \n        public void close() {\n            \n        }\n\n        \n        public void flush() {\n            \n        }\n\n        \n        public void write(int c) {\n            StrBuilder.this.append((char) c);\n        }\n\n        \n        public void write(char[] cbuf) {\n            StrBuilder.this.append(cbuf);\n        }\n\n        \n        public void write(char[] cbuf, int off, int len) {\n            StrBuilder.this.append(cbuf, off, len);\n        }\n\n        \n        public void write(String str) {\n            StrBuilder.this.append(str);\n        }\n\n        \n        public void write(String str, int off, int len) {\n            StrBuilder.this.append(str, off, len);\n        }\n    }\n\n}\n",
      "fixed_full_code": "\npackage org.apache.commons.lang.text;\n\nimport java.io.Reader;\nimport java.io.Writer;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport org.apache.commons.lang.ArrayUtils;\nimport org.apache.commons.lang.SystemUtils;\n\n\npublic class StrBuilder implements Cloneable { static final int CAPACITY = 32; private static final long serialVersionUID = 7628716375283629643L; protected char[] buffer; protected int size; private String newLine; private String nullText; public StrBuilder() {\n        this(CAPACITY);\n    }\n\n    \n    public StrBuilder(int initialCapacity) {\n        super();\n        if (initialCapacity <= 0) {\n            initialCapacity = CAPACITY;\n        }\n        buffer = new char[initialCapacity];\n    }\n\n    \n    public StrBuilder(String str) {\n        super();\n        if (str == null) {\n            buffer = new char[CAPACITY];\n        } else {\n            buffer = new char[str.length() + CAPACITY];\n            append(str);\n        }\n    }\n\n    \n    \n    public String getNewLineText() {\n        return newLine;\n    }\n\n    \n    public StrBuilder setNewLineText(String newLine) {\n        this.newLine = newLine;\n        return this;\n    }\n\n    \n    \n    public String getNullText() {\n        return nullText;\n    }\n\n    \n    public StrBuilder setNullText(String nullText) {\n        if (nullText != null && nullText.length() == 0) {\n            nullText = null;\n        }\n        this.nullText = nullText;\n        return this;\n    }\n\n    \n    \n    public int length() {\n        return size;\n    }\n\n    \n    public StrBuilder setLength(int length) {\n        if (length < 0) {\n            throw new StringIndexOutOfBoundsException(length);\n        }\n        if (length < size) {\n            size = length;\n        } else if (length > size) {\n            ensureCapacity(length);\n            int oldEnd = size;\n            int newEnd = length;\n            size = length;\n            for (int i = oldEnd; i < newEnd; i++) {\n                buffer[i] = '\\0';\n            }\n        }\n        return this;\n    }\n\n    \n    \n    public int capacity() {\n        return buffer.length;\n    }\n\n    \n    public StrBuilder ensureCapacity(int capacity) {\n        if (capacity > buffer.length) {\n            char[] old = buffer;\n            buffer = new char[capacity];\n            System.arraycopy(old, 0, buffer, 0, size);\n        }\n        return this;\n    }\n\n    \n    public StrBuilder minimizeCapacity() {\n        if (buffer.length > length()) {\n            char[] old = buffer;\n            buffer = new char[length()];\n            System.arraycopy(old, 0, buffer, 0, size);\n        }\n        return this;\n    }\n\n    \n    \n    public int size() {\n        return size;\n    }\n\n    \n    public boolean isEmpty() {\n        return size == 0;\n    }\n\n    \n    public StrBuilder clear() {\n        size = 0;\n        return this;\n    }\n\n    \n    \n    public char charAt(int index) {\n        if (index < 0 || index >= length()) {\n            throw new StringIndexOutOfBoundsException(index);\n        }\n        return buffer[index];\n    }\n\n    \n    public StrBuilder setCharAt(int index, char ch) {\n        if (index < 0 || index >= length()) {\n            throw new StringIndexOutOfBoundsException(index);\n        }\n        buffer[index] = ch;\n        return this;\n    }\n\n    \n    public StrBuilder deleteCharAt(int index) {\n        if (index < 0 || index >= size) {\n            throw new StringIndexOutOfBoundsException(index);\n        }\n        deleteImpl(index, index + 1, 1);\n        return this;\n    }\n\n    \n    \n    public char[] toCharArray() {\n        if (size == 0) {\n            return ArrayUtils.EMPTY_CHAR_ARRAY;\n        }\n        char chars[] = new char[size];\n        System.arraycopy(buffer, 0, chars, 0, size);\n        return chars;\n    }\n\n    \n    public char[] toCharArray(int startIndex, int endIndex) {\n        endIndex = validateRange(startIndex, endIndex);\n        int len = endIndex - startIndex;\n        if (len == 0) {\n            return ArrayUtils.EMPTY_CHAR_ARRAY;\n        }\n        char chars[] = new char[len];\n        System.arraycopy(buffer, startIndex, chars, 0, len);\n        return chars;\n    }\n\n    \n    public char[] getChars(char[] destination) {\n        int len = length();\n        if (destination == null || destination.length < len) {\n            destination = new char[len];\n        }\n        System.arraycopy(buffer, 0, destination, 0, len);\n        return destination;\n    }\n\n    \n    public void getChars(int startIndex, int endIndex, char destination[], int destinationIndex) {\n        if (startIndex < 0) {\n            throw new StringIndexOutOfBoundsException(startIndex);\n        }\n        if (endIndex < 0 || endIndex > length()) {\n            throw new StringIndexOutOfBoundsException(endIndex);\n        }\n        if (startIndex > endIndex) {\n            throw new StringIndexOutOfBoundsException(\"end < start\");\n        }\n        System.arraycopy(buffer, startIndex, destination, destinationIndex, endIndex - startIndex);\n    }\n\n    \n    \n    public StrBuilder appendNewLine() {\n        if (newLine == null)  {\n            append(SystemUtils.LINE_SEPARATOR);\n            return this;\n        }\n        return append(newLine);\n    }\n\n    \n    public StrBuilder appendNull() {\n        if (nullText == null)  {\n            return this;\n        }\n        return append(nullText);\n    }\n\n    \n    public StrBuilder append(Object obj) {\n        if (obj == null) {\n            return appendNull();\n        } \n        return append(obj.toString());        \n    }\n\n    \n    public StrBuilder append(String str) {\n        if (str == null) {\n            return appendNull();\n        }\n        int strLen = str.length();\n        if (strLen > 0) {\n            int len = length();\n            ensureCapacity(len + strLen);\n            str.getChars(0, strLen, buffer, len);\n            size += strLen;\n        }\n        return this;\n    }\n\n    \n    public StrBuilder append(String str, int startIndex, int length) {\n        if (str == null) {\n            return appendNull();\n        }\n        if (startIndex < 0 || startIndex > str.length()) {\n            throw new StringIndexOutOfBoundsException(\"startIndex must be valid\");\n        }\n        if (length < 0 || (startIndex + length) > str.length()) {\n            throw new StringIndexOutOfBoundsException(\"length must be valid\");\n        }\n        if (length > 0) {\n            int len = length();\n            ensureCapacity(len + length);\n            str.getChars(startIndex, startIndex + length, buffer, len);\n            size += length;\n        }\n        return this;\n    }\n\n    \n    public StrBuilder append(StringBuffer str) {\n        if (str == null) {\n            return appendNull();\n        }\n        int strLen = str.length();\n        if (strLen > 0) {\n            int len = length();\n            ensureCapacity(len + strLen);\n            str.getChars(0, strLen, buffer, len);\n            size += strLen;\n        }\n        return this;\n    }\n\n    \n    public StrBuilder append(StringBuffer str, int startIndex, int length) {\n        if (str == null) {\n            return appendNull();\n        }\n        if (startIndex < 0 || startIndex > str.length()) {\n            throw new StringIndexOutOfBoundsException(\"startIndex must be valid\");\n        }\n        if (length < 0 || (startIndex + length) > str.length()) {\n            throw new StringIndexOutOfBoundsException(\"length must be valid\");\n        }\n        if (length > 0) {\n            int len = length();\n            ensureCapacity(len + length);\n            str.getChars(startIndex, startIndex + length, buffer, len);\n            size += length;\n        }\n        return this;\n    }\n\n    \n    public StrBuilder append(StrBuilder str) {\n        if (str == null) {\n            return appendNull();\n        }\n        int strLen = str.length();\n        if (strLen > 0) {\n            int len = length();\n            ensureCapacity(len + strLen);\n            System.arraycopy(str.buffer, 0, buffer, len, strLen);\n            size += strLen;\n        }\n        return this;\n    }\n\n    \n    public StrBuilder append(StrBuilder str, int startIndex, int length) {\n        if (str == null) {\n            return appendNull();\n        }\n        if (startIndex < 0 || startIndex > str.length()) {\n            throw new StringIndexOutOfBoundsException(\"startIndex must be valid\");\n        }\n        if (length < 0 || (startIndex + length) > str.length()) {\n            throw new StringIndexOutOfBoundsException(\"length must be valid\");\n        }\n        if (length > 0) {\n            int len = length();\n            ensureCapacity(len + length);\n            str.getChars(startIndex, startIndex + length, buffer, len);\n            size += length;\n        }\n        return this;\n    }\n\n    \n    public StrBuilder append(char[] chars) {\n        if (chars == null) {\n            return appendNull();\n        }\n        int strLen = chars.length;\n        if (strLen > 0) {\n            int len = length();\n            ensureCapacity(len + strLen);\n            System.arraycopy(chars, 0, buffer, len, strLen);\n            size += strLen;\n        }\n        return this;\n    }\n\n    \n    public StrBuilder append(char[] chars, int startIndex, int length) {\n        if (chars == null) {\n            return appendNull();\n        }\n        if (startIndex < 0 || startIndex > chars.length) {\n            throw new StringIndexOutOfBoundsException(\"Invalid startIndex: \" + length);\n        }\n        if (length < 0 || (startIndex + length) > chars.length) {\n            throw new StringIndexOutOfBoundsException(\"Invalid length: \" + length);\n        }\n        if (length > 0) {\n            int len = length();\n            ensureCapacity(len + length);\n            System.arraycopy(chars, startIndex, buffer, len, length);\n            size += length;\n        }\n        return this;\n    }\n\n    \n    public StrBuilder append(boolean value) {\n        if (value) {\n            ensureCapacity(size + 4);\n            buffer[size++] = 't';\n            buffer[size++] = 'r';\n            buffer[size++] = 'u';\n            buffer[size++] = 'e';\n        } else {\n            ensureCapacity(size + 5);\n            buffer[size++] = 'f';\n            buffer[size++] = 'a';\n            buffer[size++] = 'l';\n            buffer[size++] = 's';\n            buffer[size++] = 'e';\n        }\n        return this;\n    }\n\n    \n    public StrBuilder append(char ch) {\n        int len = length();\n        ensureCapacity(len + 1);\n        buffer[size++] = ch;\n        return this;\n    }\n\n    \n    public StrBuilder append(int value) {\n        return append(String.valueOf(value));\n    }\n\n    \n    public StrBuilder append(long value) {\n        return append(String.valueOf(value));\n    }\n\n    \n    public StrBuilder append(float value) {\n        return append(String.valueOf(value));\n    }\n\n    \n    public StrBuilder append(double value) {\n        return append(String.valueOf(value));\n    }\n\n    \n    \n    public StrBuilder appendWithSeparators(Object[] array, String separator) {\n        if (array != null && array.length > 0) {\n            separator = (separator == null ? \"\" : separator);\n            append(array[0]);\n            for (int i = 1; i < array.length; i++) {\n                append(separator);\n                append(array[i]);\n            }\n        }\n        return this;\n    }\n\n    \n    public StrBuilder appendWithSeparators(Collection coll, String separator) {\n        if (coll != null && coll.size() > 0) {\n            separator = (separator == null ? \"\" : separator);\n            Iterator it = coll.iterator();\n            while (it.hasNext()) {\n                append(it.next());\n                if (it.hasNext()) {\n                    append(separator);\n                }\n            }\n        }\n        return this;\n    }\n\n    \n    public StrBuilder appendWithSeparators(Iterator it, String separator) {\n        if (it != null) {\n            separator = (separator == null ? \"\" : separator);\n            while (it.hasNext()) {\n                append(it.next());\n                if (it.hasNext()) {\n                    append(separator);\n                }\n            }\n        }\n        return this;\n    }\n\n    \n    \n    public StrBuilder appendPadding(int length, char padChar) {\n        if (length >= 0) {\n            ensureCapacity(size + length);\n            for (int i = 0; i < length; i++) {\n                buffer[size++] = padChar;\n            }\n        }\n        return this;\n    }\n\n    \n    \n    public StrBuilder appendFixedWidthPadLeft(Object obj, int width, char padChar) {\n        if (width > 0) {\n            ensureCapacity(size + width);\n            String str = (obj == null ? getNullText() : obj.toString());\n            int strLen = str.length();\n            if (strLen >= width) {\n                str.getChars(strLen - width, strLen, buffer, size);\n            } else {\n                int padLen = width - strLen;\n                for (int i = 0; i < padLen; i++) {\n                    buffer[size + i] = padChar;\n                }\n                str.getChars(0, strLen, buffer, size + padLen);\n            }\n            size += width;\n        }\n        return this;\n    }\n\n    \n    public StrBuilder appendFixedWidthPadLeft(int value, int width, char padChar) {\n        return appendFixedWidthPadLeft(String.valueOf(value), width, padChar);\n    }\n\n    \n    public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n        if (width > 0) {\n            ensureCapacity(size + width);\n            String str = (obj == null ? getNullText() : obj.toString());\n            int strLen = str.length();\n            if (strLen >= width) {\n                str.getChars(0, strLen, buffer, size);\n            } else {\n                int padLen = width - strLen;\n                str.getChars(0, strLen, buffer, size);\n                for (int i = 0; i < padLen; i++) {\n                    buffer[size + strLen + i] = padChar;\n                }\n            }\n            size += width;\n        }\n        return this;\n    }\n\n    \n    public StrBuilder appendFixedWidthPadRight(int value, int width, char padChar) {\n        return appendFixedWidthPadRight(String.valueOf(value), width, padChar);\n    }\n\n    \n    \n    public StrBuilder insert(int index, Object obj) {\n        if (obj == null) {\n            return insert(index, nullText);\n        }\n        return insert(index, obj.toString());\n    }\n\n    \n    public StrBuilder insert(int index, String str) {\n        validateIndex(index);\n        if (str == null) {\n            str = nullText;\n        }\n        int strLen = (str == null ? 0 : str.length());\n        if (strLen > 0) {\n            int newSize = size + strLen;\n            ensureCapacity(newSize);\n            System.arraycopy(buffer, index, buffer, index + strLen, size - index);\n            size = newSize;\n            str.getChars(0, strLen, buffer, index);\n        }\n        return this;\n    }\n\n    \n    public StrBuilder insert(int index, char chars[]) {\n        validateIndex(index);\n        if (chars == null) {\n            return insert(index, nullText);\n        }\n        int len = chars.length;\n        if (len > 0) {\n            ensureCapacity(size + len);\n            System.arraycopy(buffer, index, buffer, index + len, size - index);\n            System.arraycopy(chars, 0, buffer, index, len);\n            size += len;\n        }\n        return this;\n    }\n\n    \n    public StrBuilder insert(int index, char chars[], int offset, int length) {\n        validateIndex(index);\n        if (chars == null) {\n            return insert(index, nullText);\n        }\n        if (offset < 0 || offset > chars.length) {\n            throw new StringIndexOutOfBoundsException(\"Invalid offset: \" + offset);\n        }\n        if (length < 0 || offset + length > chars.length) {\n            throw new StringIndexOutOfBoundsException(\"Invalid length: \" + length);\n        }\n        if (length > 0) {\n            ensureCapacity(size + length);\n            System.arraycopy(buffer, index, buffer, index + length, size - index);\n            System.arraycopy(chars, offset, buffer, index, length);\n            size += length;\n        }\n        return this;\n    }\n\n    \n    public StrBuilder insert(int index, boolean value) {\n        validateIndex(index);\n        if (value) {\n            ensureCapacity(size + 4);\n            System.arraycopy(buffer, index, buffer, index + 4, size - index);\n            buffer[index++] = 't';\n            buffer[index++] = 'r';\n            buffer[index++] = 'u';\n            buffer[index] = 'e';\n            size += 4;\n        } else {\n            ensureCapacity(size + 5);\n            System.arraycopy(buffer, index, buffer, index + 5, size - index);\n            buffer[index++] = 'f';\n            buffer[index++] = 'a';\n            buffer[index++] = 'l';\n            buffer[index++] = 's';\n            buffer[index] = 'e';\n            size += 5;\n        }\n        return this;\n    }\n\n    \n    public StrBuilder insert(int index, char value) {\n        validateIndex(index);\n        ensureCapacity(size + 1);\n        System.arraycopy(buffer, index, buffer, index + 1, size - index);\n        buffer[index] = value;\n        size++;\n        return this;\n    }\n\n    \n    public StrBuilder insert(int index, int value) {\n        return insert(index, String.valueOf(value));\n    }\n\n    \n    public StrBuilder insert(int index, long value) {\n        return insert(index, String.valueOf(value));\n    }\n\n    \n    public StrBuilder insert(int index, float value) {\n        return insert(index, String.valueOf(value));\n    }\n\n    \n    public StrBuilder insert(int index, double value) {\n        return insert(index, String.valueOf(value));\n    }\n\n    \n    \n    private void deleteImpl(int startIndex, int endIndex, int len) {\n        System.arraycopy(buffer, endIndex, buffer, startIndex, size - endIndex);\n        size -= len;\n    }\n\n    \n    public StrBuilder delete(int startIndex, int endIndex) {\n        endIndex = validateRange(startIndex, endIndex);\n        int len = endIndex - startIndex;\n        if (len > 0) {\n            deleteImpl(startIndex, endIndex, len);\n        }\n        return this;\n    }\n\n    \n    \n    public StrBuilder deleteAll(char ch) {\n        for (int i = 0; i < size; i++) {\n            if (buffer[i] == ch) {\n                int start = i;\n                while (++i < size) {\n                    if (buffer[i] != ch) {\n                        break;\n                    }\n                }\n                int len = i - start;\n                deleteImpl(start, i, len);\n                i -= len;\n            }\n        }\n        return this;\n    }\n\n    \n    public StrBuilder deleteFirst(char ch) {\n        for (int i = 0; i < size; i++) {\n            if (buffer[i] == ch) {\n                deleteImpl(i, i + 1, 1);\n                break;\n            }\n        }\n        return this;\n    }\n\n    \n    \n    public StrBuilder deleteAll(String str) {\n        int len = (str == null ? 0 : str.length());\n        if (len > 0) {\n            int index = indexOf(str, 0);\n            while (index >= 0) {\n                deleteImpl(index, index + len, len);\n                index = indexOf(str, index);\n            }\n        }\n        return this;\n    }\n\n    \n    public StrBuilder deleteFirst(String str) {\n        int len = (str == null ? 0 : str.length());\n        if (len > 0) {\n            int index = indexOf(str, 0);\n            if (index >= 0) {\n                deleteImpl(index, index + len, len);\n            }\n        }\n        return this;\n    }\n\n    \n    \n    public StrBuilder deleteAll(StrMatcher matcher) {\n        return replace(matcher, null, 0, size, -1);\n    }\n\n    \n    public StrBuilder deleteFirst(StrMatcher matcher) {\n        return replace(matcher, null, 0, size, 1);\n    }\n\n    \n    \n    private void replaceImpl(int startIndex, int endIndex, int removeLen, String insertStr, int insertLen) {\n        int newSize = size - removeLen + insertLen;\n        if (insertLen != removeLen) {\n            ensureCapacity(newSize);\n            System.arraycopy(buffer, endIndex, buffer, startIndex + insertLen, size - endIndex);\n            size = newSize;\n        }\n        if (insertLen > 0) {\n            insertStr.getChars(0, insertLen, buffer, startIndex);\n        }\n    }\n\n    \n    public StrBuilder replace(int startIndex, int endIndex, String replaceStr) {\n        endIndex = validateRange(startIndex, endIndex);\n        int insertLen = (replaceStr == null ? 0 : replaceStr.length());\n        replaceImpl(startIndex, endIndex, endIndex - startIndex, replaceStr, insertLen);\n        return this;\n    }\n\n    \n    \n    public StrBuilder replaceAll(char search, char replace) {\n        if (search != replace) {\n            for (int i = 0; i < size; i++) {\n                if (buffer[i] == search) {\n                    buffer[i] = replace;\n                }\n            }\n        }\n        return this;\n    }\n\n    \n    public StrBuilder replaceFirst(char search, char replace) {\n        if (search != replace) {\n            for (int i = 0; i < size; i++) {\n                if (buffer[i] == search) {\n                    buffer[i] = replace;\n                    break;\n                }\n            }\n        }\n        return this;\n    }\n\n    \n    \n    public StrBuilder replaceAll(String searchStr, String replaceStr) {\n        int searchLen = (searchStr == null ? 0 : searchStr.length());\n        if (searchLen > 0) {\n            int replaceLen = (replaceStr == null ? 0 : replaceStr.length());\n            int index = indexOf(searchStr, 0);\n            while (index >= 0) {\n                replaceImpl(index, index + searchLen, searchLen, replaceStr, replaceLen);\n                index = indexOf(searchStr, index + replaceLen);\n            }\n        }\n        return this;\n    }\n\n    \n    public StrBuilder replaceFirst(String searchStr, String replaceStr) {\n        int searchLen = (searchStr == null ? 0 : searchStr.length());\n        if (searchLen > 0) {\n            int index = indexOf(searchStr, 0);\n            if (index >= 0) {\n                int replaceLen = (replaceStr == null ? 0 : replaceStr.length());\n                replaceImpl(index, index + searchLen, searchLen, replaceStr, replaceLen);\n            }\n        }\n        return this;\n    }\n\n    \n    \n    public StrBuilder replaceAll(StrMatcher matcher, String replaceStr) {\n        return replace(matcher, replaceStr, 0, size, -1);\n    }\n\n    \n    public StrBuilder replaceFirst(StrMatcher matcher, String replaceStr) {\n        return replace(matcher, replaceStr, 0, size, 1);\n    }\n\n    \n    \n    public StrBuilder replace( StrMatcher matcher, String replaceStr, int startIndex, int endIndex, int replaceCount) {\n        endIndex = validateRange(startIndex, endIndex);\n        return replaceImpl(matcher, replaceStr, startIndex, endIndex, replaceCount);\n    }\n\n    \n    private StrBuilder replaceImpl( StrMatcher matcher, String replaceStr, int from, int to, int replaceCount) {\n        if (matcher == null || size == 0) {\n            return this;\n        }\n        int replaceLen = (replaceStr == null ? 0 : replaceStr.length());\n        char[] buf = buffer;\n        for (int i = from; i < to && replaceCount != 0; i++) {\n            int removeLen = matcher.isMatch(buf, i, from, to);\n            if (removeLen > 0) {\n                replaceImpl(i, i + removeLen, removeLen, replaceStr, replaceLen);\n                to = to - removeLen + replaceLen;\n                i = i + replaceLen - 1;\n                if (replaceCount > 0) {\n                    replaceCount--;\n                }\n            }\n        }\n        return this;\n    }\n\n    \n    \n    public StrBuilder reverse() {\n        if (size == 0) {\n            return this;\n        }\n        \n        int half = size / 2;\n        char[] buf = buffer;\n        for (int leftIdx = 0, rightIdx = size - 1; leftIdx < half; leftIdx++,rightIdx--) {\n            char swap = buf[leftIdx];\n            buf[leftIdx] = buf[rightIdx];\n            buf[rightIdx] = swap;\n        }\n        return this;\n    }\n\n    \n    \n    public StrBuilder trim() {\n        if (size == 0) {\n            return this;\n        }\n        int len = size;\n        char[] buf = buffer;\n        int pos = 0;\n        while (pos < len && buf[pos] <= ' ') {\n            pos++;\n        }\n        while (pos < len && buf[len - 1] <= ' ') {\n            len--;\n        }\n        if (len < size) {\n            delete(len, size);\n        }\n        if (pos > 0) {\n            delete(0, pos);\n        }\n        return this;\n    }\n\n    \n    \n    public boolean startsWith(String str) {\n        if (str == null) {\n            return false;\n        }\n        int len = str.length();\n        if (len == 0) {\n            return true;\n        }\n        if (len > size) {\n            return false;\n        }\n        for (int i = 0; i < len; i++) {\n            if (buffer[i] != str.charAt(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public boolean endsWith(String str) {\n        if (str == null) {\n            return false;\n        }\n        int len = str.length();\n        if (len == 0) {\n            return true;\n        }\n        if (len > size) {\n            return false;\n        }\n        int pos = size - len;\n        for (int i = 0; i < len; i++,pos++) {\n            if (buffer[pos] != str.charAt(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    \n    public String substring(int start) {\n        return substring(start, size);\n    }\n\n    \n    public String substring(int startIndex, int endIndex) {\n        endIndex = validateRange(startIndex, endIndex);\n        return new String(buffer, startIndex, endIndex - startIndex);\n    }\n\n    \n    public String leftString(int length) {\n        if (length <= 0) {\n            return \"\";\n        } else if (length >= size) {\n            return new String(buffer, 0, size);\n        } else {\n            return new String(buffer, 0, length);\n        }\n    }\n\n    \n    public String rightString(int length) {\n        if (length <= 0) {\n            return \"\";\n        } else if (length >= size) {\n            return new String(buffer, 0, size);\n        } else {\n            return new String(buffer, size - length, length);\n        }\n    }\n\n    \n    public String midString(int index, int length) {\n        if (index < 0) {\n            index = 0;\n        }\n        if (length <= 0 || index >= size) {\n            return \"\";\n        }\n        if (size <= index + length) {\n            return new String(buffer, index, size - index);\n        } else {\n            return new String(buffer, index, length);\n        }\n    }\n\n    \n    \n    public boolean contains(char ch) {\n        char[] thisBuf = buffer;\n        for (int i = 0; i < this.size; i++) {\n            if (thisBuf[i] == ch) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    \n    public boolean contains(String str) {\n        return indexOf(str, 0) >= 0;\n    }\n\n    \n    public boolean contains(StrMatcher matcher) {\n        return indexOf(matcher, 0) >= 0;\n    }\n\n    \n    \n    public int indexOf(char ch) {\n        return indexOf(ch, 0);\n    }\n\n    \n    public int indexOf(char ch, int startIndex) {\n        startIndex = (startIndex < 0 ? 0 : startIndex);\n        if (startIndex >= size) {\n            return -1;\n        }\n        char[] thisBuf = buffer;\n        for (int i = startIndex; i < size; i++) {\n            if (thisBuf[i] == ch) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    \n    public int indexOf(String str) {\n        return indexOf(str, 0);\n    }\n\n    \n    public int indexOf(String str, int startIndex) {\n        startIndex = (startIndex < 0 ? 0 : startIndex);\n        if (str == null || startIndex >= size) {\n            return -1;\n        }\n        int strLen = str.length();\n        if (strLen == 1) {\n            return indexOf(str.charAt(0), startIndex);\n        }\n        if (strLen == 0) {\n            return startIndex;\n        }\n        if (strLen > size) {\n            return -1;\n        }\n        char[] thisBuf = buffer;\n        int len = size - strLen + 1;\n        outer:\n        for (int i = startIndex; i < len; i++) {\n            for (int j = 0; j < strLen; j++) {\n                if (str.charAt(j) != thisBuf[i + j]) {\n                    continue outer;\n                }\n            }\n            return i;\n        }\n        return -1;\n    }\n\n    \n    public int indexOf(StrMatcher matcher) {\n        return indexOf(matcher, 0);\n    }\n\n    \n    public int indexOf(StrMatcher matcher, int startIndex) {\n        startIndex = (startIndex < 0 ? 0 : startIndex);\n        if (matcher == null || startIndex >= size) {\n            return -1;\n        }\n        int len = size;\n        char[] buf = buffer;\n        for (int i = startIndex; i < len; i++) {\n            if (matcher.isMatch(buf, i, startIndex, len) > 0) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    \n    \n    public int lastIndexOf(char ch) {\n        return lastIndexOf(ch, size - 1);\n    }\n\n    \n    public int lastIndexOf(char ch, int startIndex) {\n        startIndex = (startIndex >= size ? size - 1 : startIndex);\n        if (startIndex < 0) {\n            return -1;\n        }\n        for (int i = startIndex; i >= 0; i--) {\n            if (buffer[i] == ch) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    \n    public int lastIndexOf(String str) {\n        return lastIndexOf(str, size - 1);\n    }\n\n    \n    public int lastIndexOf(String str, int startIndex) {\n        startIndex = (startIndex >= size ? size - 1 : startIndex);\n        if (str == null || startIndex < 0) {\n            return -1;\n        }\n        int strLen = str.length();\n        if (strLen > 0 && strLen <= size) {\n            if (strLen == 1) {\n                return lastIndexOf(str.charAt(0), startIndex);\n            }\n\n            outer:\n            for (int i = startIndex - strLen + 1; i >= 0; i--) {\n                for (int j = 0; j < strLen; j++) {\n                    if (str.charAt(j) != buffer[i + j]) {\n                        continue outer;\n                    }\n                }\n                return i;\n            }\n            \n        } else if (strLen == 0) {\n            return startIndex;\n        }\n        return -1;\n    }\n\n    \n    public int lastIndexOf(StrMatcher matcher) {\n        return lastIndexOf(matcher, size);\n    }\n\n    \n    public int lastIndexOf(StrMatcher matcher, int startIndex) {\n        startIndex = (startIndex >= size ? size - 1 : startIndex);\n        if (matcher == null || startIndex < 0) {\n            return -1;\n        }\n        char[] buf = buffer;\n        int endIndex = startIndex + 1;\n        for (int i = startIndex; i >= 0; i--) {\n            if (matcher.isMatch(buf, i, 0, endIndex) > 0) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    \n    \n    public StrTokenizer asTokenizer() {\n        return new StrBuilderTokenizer();\n    }\n\n    \n    \n    public Reader asReader() {\n        return new StrBuilderReader();\n    }\n\n    \n    \n    public Writer asWriter() {\n        return new StrBuilderWriter();\n    }\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n    \n    public boolean equalsIgnoreCase(StrBuilder other) {\n        if (this == other) {\n            return true;\n        }\n        if (this.size != other.size) {\n            return false;\n        }\n        char thisBuf[] = this.buffer;\n        char otherBuf[] = other.buffer;\n        for (int i = size - 1; i >= 0; i--) {\n            char c1 = thisBuf[i];\n            char c2 = otherBuf[i];\n            if (c1 != c2 && Character.toUpperCase(c1) != Character.toUpperCase(c2)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public boolean equals(StrBuilder other) {\n        if (this == other) {\n            return true;\n        }\n        if (this.size != other.size) {\n            return false;\n        }\n        char thisBuf[] = this.buffer;\n        char otherBuf[] = other.buffer;\n        for (int i = size - 1; i >= 0; i--) {\n            if (thisBuf[i] != otherBuf[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public boolean equals(Object obj) {\n        if (obj instanceof StrBuilder) {\n            return equals((StrBuilder) obj);\n        }\n        return false;\n    }\n\n    \n    public int hashCode() {\n        char buf[] = buffer;\n        int hash = 0;\n        for (int i = size - 1; i >= 0; i--) {\n            hash = 31 * hash + buf[i];\n        }\n        return hash;\n    }\n\n    \n    \n    public String toString() {\n        return new String(buffer, 0, size);\n    }\n\n    \n    public StringBuffer toStringBuffer() {\n        return new StringBuffer(size).append(buffer, 0, size);\n    }\n\n    \n    \n    protected int validateRange(int startIndex, int endIndex) {\n        if (startIndex < 0) {\n            throw new StringIndexOutOfBoundsException(startIndex);\n        }\n        if (endIndex > size) {\n            endIndex = size;\n        }\n        if (startIndex > endIndex) {\n            throw new StringIndexOutOfBoundsException(\"end < start\");\n        }\n        return endIndex;\n    }\n\n    \n    protected void validateIndex(int index) {\n        if (index < 0 || index > size) {\n            throw new StringIndexOutOfBoundsException(index);\n        }\n    }\n\n    \n    \n    class StrBuilderTokenizer extends StrTokenizer {\n\n        \n        StrBuilderTokenizer() {\n            super();\n        }\n\n        \n        protected List tokenize(char[] chars, int offset, int count) {\n            if (chars == null) {\n                return super.tokenize(StrBuilder.this.buffer, 0, StrBuilder.this.size());\n            } else {\n                return super.tokenize(chars, offset, count);\n            }\n        }\n\n        \n        public String getContent() {\n            String str = super.getContent();\n            if (str == null) {\n                return StrBuilder.this.toString();\n            } else {\n                return str;\n            }\n        }\n    }\n\n    \n    \n    class StrBuilderReader extends Reader {\n        \n        private int pos; private int mark; StrBuilderReader() {\n            super();\n        }\n\n        \n        public void close() {\n            \n        }\n\n        \n        public int read() {\n            if (ready() == false) {\n                return -1;\n            }\n            return StrBuilder.this.charAt(pos++);\n        }\n\n        \n        public int read(char b[], int off, int len) {\n            if (off < 0 || len < 0 || off > b.length ||\n                    (off + len) > b.length || (off + len) < 0) {\n                throw new IndexOutOfBoundsException();\n            }\n            if (len == 0) {\n                return 0;\n            }\n            if (pos >= StrBuilder.this.size()) {\n                return -1;\n            }\n            if (pos + len > size()) {\n                len = StrBuilder.this.size() - pos;\n            }\n            StrBuilder.this.getChars(pos, pos + len, b, off);\n            pos += len;\n            return len;\n        }\n\n        \n        public long skip(long n) {\n            if (pos + n > StrBuilder.this.size()) {\n                n = StrBuilder.this.size() - pos;\n            }\n            if (n < 0) {\n                return 0;\n            }\n            pos += n;\n            return n;\n        }\n\n        \n        public boolean ready() {\n            return pos < StrBuilder.this.size();\n        }\n\n        \n        public boolean markSupported() {\n            return true;\n        }\n\n        \n        public void mark(int readAheadLimit) {\n            mark = pos;\n        }\n\n        \n        public void reset() {\n            pos = mark;\n        }\n    }\n\n    \n    \n    class StrBuilderWriter extends Writer {\n\n        \n        StrBuilderWriter() {\n            super();\n        }\n\n        \n        public void close() {\n            \n        }\n\n        \n        public void flush() {\n            \n        }\n\n        \n        public void write(int c) {\n            StrBuilder.this.append((char) c);\n        }\n\n        \n        public void write(char[] cbuf) {\n            StrBuilder.this.append(cbuf);\n        }\n\n        \n        public void write(char[] cbuf, int off, int len) {\n            StrBuilder.this.append(cbuf, off, len);\n        }\n\n        \n        public void write(String str) {\n            StrBuilder.this.append(str);\n        }\n\n        \n        public void write(String str, int off, int len) {\n            StrBuilder.this.append(str, off, len);\n        }\n    }\n\n}\n",
      "buggy_signatures": [
        "public StrBuilder(int initialCapacity)",
        "public StrBuilder(String str)",
        "public String getNewLineText()",
        "public StrBuilder setNewLineText(String newLine)",
        "public String getNullText()",
        "public StrBuilder setNullText(String nullText)",
        "public int length()",
        "public StrBuilder setLength(int length)",
        "public int capacity()",
        "public StrBuilder ensureCapacity(int capacity)",
        "public StrBuilder minimizeCapacity()",
        "public int size()",
        "public boolean isEmpty()",
        "public StrBuilder clear()",
        "public char charAt(int index)",
        "public StrBuilder setCharAt(int index, char ch)",
        "public StrBuilder deleteCharAt(int index)",
        "public char[] toCharArray()",
        "public char[] toCharArray(int startIndex, int endIndex)",
        "public char[] getChars(char[] destination)",
        "public void getChars(int startIndex, int endIndex, char destination[], int destinationIndex)",
        "public StrBuilder appendNewLine()",
        "public StrBuilder appendNull()",
        "public StrBuilder append(Object obj)",
        "public StrBuilder append(String str)",
        "public StrBuilder append(String str, int startIndex, int length)",
        "public StrBuilder append(StringBuffer str)",
        "public StrBuilder append(StringBuffer str, int startIndex, int length)",
        "public StrBuilder append(StrBuilder str)",
        "public StrBuilder append(StrBuilder str, int startIndex, int length)",
        "public StrBuilder append(char[] chars)",
        "public StrBuilder append(char[] chars, int startIndex, int length)",
        "public StrBuilder append(boolean value)",
        "public StrBuilder append(char ch)",
        "public StrBuilder append(int value)",
        "public StrBuilder append(long value)",
        "public StrBuilder append(float value)",
        "public StrBuilder append(double value)",
        "public StrBuilder appendWithSeparators(Object[] array, String separator)",
        "public StrBuilder appendWithSeparators(Collection coll, String separator)",
        "public StrBuilder appendWithSeparators(Iterator it, String separator)",
        "public StrBuilder appendPadding(int length, char padChar)",
        "public StrBuilder appendFixedWidthPadLeft(Object obj, int width, char padChar)",
        "public StrBuilder appendFixedWidthPadLeft(int value, int width, char padChar)",
        "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar)",
        "public StrBuilder appendFixedWidthPadRight(int value, int width, char padChar)",
        "public StrBuilder insert(int index, Object obj)",
        "public StrBuilder insert(int index, String str)",
        "public StrBuilder insert(int index, char chars[])",
        "public StrBuilder insert(int index, char chars[], int offset, int length)",
        "public StrBuilder insert(int index, boolean value)",
        "public StrBuilder insert(int index, char value)",
        "public StrBuilder insert(int index, int value)",
        "public StrBuilder insert(int index, long value)",
        "public StrBuilder insert(int index, float value)",
        "public StrBuilder insert(int index, double value)",
        "private void deleteImpl(int startIndex, int endIndex, int len)",
        "public StrBuilder delete(int startIndex, int endIndex)",
        "public StrBuilder deleteAll(char ch)",
        "public StrBuilder deleteFirst(char ch)",
        "public StrBuilder deleteAll(String str)",
        "public StrBuilder deleteFirst(String str)",
        "public StrBuilder deleteAll(StrMatcher matcher)",
        "public StrBuilder deleteFirst(StrMatcher matcher)",
        "private void replaceImpl(int startIndex, int endIndex, int removeLen, String insertStr, int insertLen)",
        "public StrBuilder replace(int startIndex, int endIndex, String replaceStr)",
        "public StrBuilder replaceAll(char search, char replace)",
        "public StrBuilder replaceFirst(char search, char replace)",
        "public StrBuilder replaceAll(String searchStr, String replaceStr)",
        "public StrBuilder replaceFirst(String searchStr, String replaceStr)",
        "public StrBuilder replaceAll(StrMatcher matcher, String replaceStr)",
        "public StrBuilder replaceFirst(StrMatcher matcher, String replaceStr)",
        "public StrBuilder replace( StrMatcher matcher, String replaceStr, int startIndex, int endIndex, int replaceCount)",
        "private StrBuilder replaceImpl( StrMatcher matcher, String replaceStr, int from, int to, int replaceCount)",
        "public StrBuilder reverse()",
        "public StrBuilder trim()",
        "public boolean startsWith(String str)",
        "public boolean endsWith(String str)",
        "public String substring(int start)",
        "public String substring(int startIndex, int endIndex)",
        "public String leftString(int length)",
        "public String rightString(int length)",
        "public String midString(int index, int length)",
        "public boolean contains(char ch)",
        "public boolean contains(String str)",
        "public boolean contains(StrMatcher matcher)",
        "public int indexOf(char ch)",
        "public int indexOf(char ch, int startIndex)",
        "public int indexOf(String str)",
        "public int indexOf(String str, int startIndex)",
        "public int indexOf(StrMatcher matcher)",
        "public int indexOf(StrMatcher matcher, int startIndex)",
        "public int lastIndexOf(char ch)",
        "public int lastIndexOf(char ch, int startIndex)",
        "public int lastIndexOf(String str)",
        "public int lastIndexOf(String str, int startIndex)",
        "public int lastIndexOf(StrMatcher matcher)",
        "public int lastIndexOf(StrMatcher matcher, int startIndex)",
        "public StrTokenizer asTokenizer()",
        "public Reader asReader()",
        "public Writer asWriter()",
        "public boolean equalsIgnoreCase(StrBuilder other)",
        "public boolean equals(StrBuilder other)",
        "public boolean equals(Object obj)",
        "public int hashCode()",
        "public String toString()",
        "public StringBuffer toStringBuffer()",
        "protected int validateRange(int startIndex, int endIndex)",
        "protected void validateIndex(int index)",
        "protected List tokenize(char[] chars, int offset, int count)",
        "public String getContent()",
        "private int pos; private int mark; StrBuilderReader()",
        "public void close()",
        "public int read()",
        "public int read(char b[], int off, int len)",
        "public long skip(long n)",
        "public boolean ready()",
        "public boolean markSupported()",
        "public void mark(int readAheadLimit)",
        "public void reset()",
        "public void close()",
        "public void flush()",
        "public void write(int c)",
        "public void write(char[] cbuf)",
        "public void write(char[] cbuf, int off, int len)",
        "public void write(String str)",
        "public void write(String str, int off, int len)"
      ],
      "fixed_signatures": [
        "public StrBuilder(int initialCapacity)",
        "public StrBuilder(String str)",
        "public String getNewLineText()",
        "public StrBuilder setNewLineText(String newLine)",
        "public String getNullText()",
        "public StrBuilder setNullText(String nullText)",
        "public int length()",
        "public StrBuilder setLength(int length)",
        "public int capacity()",
        "public StrBuilder ensureCapacity(int capacity)",
        "public StrBuilder minimizeCapacity()",
        "public int size()",
        "public boolean isEmpty()",
        "public StrBuilder clear()",
        "public char charAt(int index)",
        "public StrBuilder setCharAt(int index, char ch)",
        "public StrBuilder deleteCharAt(int index)",
        "public char[] toCharArray()",
        "public char[] toCharArray(int startIndex, int endIndex)",
        "public char[] getChars(char[] destination)",
        "public void getChars(int startIndex, int endIndex, char destination[], int destinationIndex)",
        "public StrBuilder appendNewLine()",
        "public StrBuilder appendNull()",
        "public StrBuilder append(Object obj)",
        "public StrBuilder append(String str)",
        "public StrBuilder append(String str, int startIndex, int length)",
        "public StrBuilder append(StringBuffer str)",
        "public StrBuilder append(StringBuffer str, int startIndex, int length)",
        "public StrBuilder append(StrBuilder str)",
        "public StrBuilder append(StrBuilder str, int startIndex, int length)",
        "public StrBuilder append(char[] chars)",
        "public StrBuilder append(char[] chars, int startIndex, int length)",
        "public StrBuilder append(boolean value)",
        "public StrBuilder append(char ch)",
        "public StrBuilder append(int value)",
        "public StrBuilder append(long value)",
        "public StrBuilder append(float value)",
        "public StrBuilder append(double value)",
        "public StrBuilder appendWithSeparators(Object[] array, String separator)",
        "public StrBuilder appendWithSeparators(Collection coll, String separator)",
        "public StrBuilder appendWithSeparators(Iterator it, String separator)",
        "public StrBuilder appendPadding(int length, char padChar)",
        "public StrBuilder appendFixedWidthPadLeft(Object obj, int width, char padChar)",
        "public StrBuilder appendFixedWidthPadLeft(int value, int width, char padChar)",
        "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar)",
        "public StrBuilder appendFixedWidthPadRight(int value, int width, char padChar)",
        "public StrBuilder insert(int index, Object obj)",
        "public StrBuilder insert(int index, String str)",
        "public StrBuilder insert(int index, char chars[])",
        "public StrBuilder insert(int index, char chars[], int offset, int length)",
        "public StrBuilder insert(int index, boolean value)",
        "public StrBuilder insert(int index, char value)",
        "public StrBuilder insert(int index, int value)",
        "public StrBuilder insert(int index, long value)",
        "public StrBuilder insert(int index, float value)",
        "public StrBuilder insert(int index, double value)",
        "private void deleteImpl(int startIndex, int endIndex, int len)",
        "public StrBuilder delete(int startIndex, int endIndex)",
        "public StrBuilder deleteAll(char ch)",
        "public StrBuilder deleteFirst(char ch)",
        "public StrBuilder deleteAll(String str)",
        "public StrBuilder deleteFirst(String str)",
        "public StrBuilder deleteAll(StrMatcher matcher)",
        "public StrBuilder deleteFirst(StrMatcher matcher)",
        "private void replaceImpl(int startIndex, int endIndex, int removeLen, String insertStr, int insertLen)",
        "public StrBuilder replace(int startIndex, int endIndex, String replaceStr)",
        "public StrBuilder replaceAll(char search, char replace)",
        "public StrBuilder replaceFirst(char search, char replace)",
        "public StrBuilder replaceAll(String searchStr, String replaceStr)",
        "public StrBuilder replaceFirst(String searchStr, String replaceStr)",
        "public StrBuilder replaceAll(StrMatcher matcher, String replaceStr)",
        "public StrBuilder replaceFirst(StrMatcher matcher, String replaceStr)",
        "public StrBuilder replace( StrMatcher matcher, String replaceStr, int startIndex, int endIndex, int replaceCount)",
        "private StrBuilder replaceImpl( StrMatcher matcher, String replaceStr, int from, int to, int replaceCount)",
        "public StrBuilder reverse()",
        "public StrBuilder trim()",
        "public boolean startsWith(String str)",
        "public boolean endsWith(String str)",
        "public String substring(int start)",
        "public String substring(int startIndex, int endIndex)",
        "public String leftString(int length)",
        "public String rightString(int length)",
        "public String midString(int index, int length)",
        "public boolean contains(char ch)",
        "public boolean contains(String str)",
        "public boolean contains(StrMatcher matcher)",
        "public int indexOf(char ch)",
        "public int indexOf(char ch, int startIndex)",
        "public int indexOf(String str)",
        "public int indexOf(String str, int startIndex)",
        "public int indexOf(StrMatcher matcher)",
        "public int indexOf(StrMatcher matcher, int startIndex)",
        "public int lastIndexOf(char ch)",
        "public int lastIndexOf(char ch, int startIndex)",
        "public int lastIndexOf(String str)",
        "public int lastIndexOf(String str, int startIndex)",
        "public int lastIndexOf(StrMatcher matcher)",
        "public int lastIndexOf(StrMatcher matcher, int startIndex)",
        "public StrTokenizer asTokenizer()",
        "public Reader asReader()",
        "public Writer asWriter()",
        "public boolean equalsIgnoreCase(StrBuilder other)",
        "public boolean equals(StrBuilder other)",
        "public boolean equals(Object obj)",
        "public int hashCode()",
        "public String toString()",
        "public StringBuffer toStringBuffer()",
        "protected int validateRange(int startIndex, int endIndex)",
        "protected void validateIndex(int index)",
        "protected List tokenize(char[] chars, int offset, int count)",
        "public String getContent()",
        "private int pos; private int mark; StrBuilderReader()",
        "public void close()",
        "public int read()",
        "public int read(char b[], int off, int len)",
        "public long skip(long n)",
        "public boolean ready()",
        "public boolean markSupported()",
        "public void mark(int readAheadLimit)",
        "public void reset()",
        "public void close()",
        "public void flush()",
        "public void write(int c)",
        "public void write(char[] cbuf)",
        "public void write(char[] cbuf, int off, int len)",
        "public void write(String str)",
        "public void write(String str, int off, int len)"
      ],
      "methods": [
        {
          "buggy_method": "  public boolean contains(char ch) {\n  char[] thisBuf = buffer;\n  for (int i = 0; i < thisBuf.length; i++) {\n  if (thisBuf[i] == ch) {\n  return true;\n  }\n  }\n  return false;\n  }",
          "fixed_method": "  public boolean contains(char ch) {\n  char[] thisBuf = buffer;\n  for (int i = 0; i < this.size; i++) {\n  if (thisBuf[i] == ch) {\n  return true;\n  }\n  }\n  return false;\n  }",
          "diff": [
            "@@ -1670,7 +1670,7 @@",
            "      */\n",
            "     public boolean contains(char ch) {\n",
            "         char[] thisBuf = buffer;\n",
            "-        for (int i = 0; i < thisBuf.length; i++) {\n",
            "+        for (int i = 0; i < this.size; i++) {\n",
            "             if (thisBuf[i] == ch) {\n",
            "                 return true;\n",
            "             }\n"
          ],
          "changed_lines": 2
        },
        {
          "buggy_method": "  public int indexOf(char ch, int startIndex) {\n  startIndex = (startIndex < 0 ? 0 : startIndex);\n  if (startIndex >= size) {\n  return -1;\n  }\n  char[] thisBuf = buffer;\n  for (int i = startIndex; i < thisBuf.length; i++) {\n  if (thisBuf[i] == ch) {\n  return i;\n  }\n  }\n  return -1;\n  }",
          "fixed_method": "  public int indexOf(char ch, int startIndex) {\n  startIndex = (startIndex < 0 ? 0 : startIndex);\n  if (startIndex >= size) {\n  return -1;\n  }\n  char[] thisBuf = buffer;\n  for (int i = startIndex; i < size; i++) {\n  if (thisBuf[i] == ch) {\n  return i;\n  }\n  }\n  return -1;\n  }",
          "diff": [
            "@@ -1727,7 +1727,7 @@",
            "             return -1;\n",
            "         }\n",
            "         char[] thisBuf = buffer;\n",
            "-        for (int i = startIndex; i < thisBuf.length; i++) {\n",
            "+        for (int i = startIndex; i < size; i++) {\n",
            "             if (thisBuf[i] == ch) {\n",
            "                 return i;\n",
            "             }\n"
          ],
          "changed_lines": 2
        }
      ]
    }
  ]
}
