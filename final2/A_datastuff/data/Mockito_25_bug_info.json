{
  "bug_id": "25",
  "failed_tests": {
    "org.mockito.internal.stubbing.defaultanswers.ReturnsGenericDeepStubsTest": [
      {
        "methodName": "will_return_default_value_on_non_mockable_nested_generic",
        "error": "java.lang.ClassCastException",
        "message": "class org.mockito.internal.creation.jmock.ClassImposterizer$ClassWithSuperclassToWorkAroundCglibBug$$EnhancerByMockitoWithCGLIB$$948bf228 cannot be cast to class java.lang.String (org.mockito.internal.creation.jmock.ClassImposterizer$ClassWithSuperclassToWorkAroundCglibBug$$EnhancerByMockitoWithCGLIB$$948bf228 is in unnamed module of loader org.apache.tools.ant.loader.AntClassLoader5 @f019fec; java.lang.String is in module java.base of loader 'bootstrap')",
        "fail_line": "        assertThat(genericsNest.returningNonMockableNestedGeneric().keySet().iterator().next()).isNull();",
        "test_source": "  public void will_return_default_value_on_non_mockable_nested_generic() throws Exception {\n  GenericsNest<?> genericsNest = mock(GenericsNest.class, RETURNS_DEEP_STUBS);\n  ListOfInteger listOfInteger = mock(ListOfInteger.class, RETURNS_DEEP_STUBS);\n\n  assertThat(genericsNest.returningNonMockableNestedGeneric().keySet().iterator().next()).isNull();\n  assertThat(listOfInteger.get(25)).isEqualTo(0);\n  }",
        "stack": [
          "ReturnsGenericDeepStubsTest.will_return_default_value_on_non_mockable_nested_generic line 97"
        ]
      },
      {
        "methodName": "can_create_mock_from_multiple_type_variable_bounds_when_return_type_of_parameterized_method_is_a_typevar_that_is_referencing_a_typevar_on_class",
        "error": "java.lang.ClassCastException",
        "message": "class $java.lang.Comparable$$EnhancerByMockitoWithCGLIB$$b6556ee8 cannot be cast to class java.lang.Cloneable ($java.lang.Comparable$$EnhancerByMockitoWithCGLIB$$b6556ee8 is in unnamed module of loader org.apache.tools.ant.loader.AntClassLoader5 @f019fec; java.lang.Cloneable is in module java.base of loader 'bootstrap')",
        "fail_line": "        Cloneable cloneable_bound_of_typevar_K_referenced_by_typevar_O = (Cloneable) mock.typeVarWithTypeParams();",
        "test_source": "  public void can_create_mock_from_multiple_type_variable_bounds_when_return_type_of_parameterized_method_is_a_typevar_that_is_referencing_a_typevar_on_class() throws Exception {\n  GenericsNest<?> mock = mock(GenericsNest.class, RETURNS_DEEP_STUBS);\n\n  Cloneable cloneable_bound_of_typevar_K_referenced_by_typevar_O = (Cloneable) mock.typeVarWithTypeParams();\n  Comparable<?> comparable_bound_of_typevar_K_referenced_by_typevar_O = (Comparable) mock.typeVarWithTypeParams();\n  }",
        "stack": [
          "ReturnsGenericDeepStubsTest.can_create_mock_from_multiple_type_variable_bounds_when_return_type_of_parameterized_method_is_a_typevar_that_is_referencing_a_typevar_on_class line 71"
        ]
      },
      {
        "methodName": "can_create_mock_from_return_types_declared_with_a_bounded_wildcard",
        "error": "java.lang.ClassCastException",
        "message": "class org.mockito.internal.creation.jmock.ClassImposterizer$ClassWithSuperclassToWorkAroundCglibBug$$EnhancerByMockitoWithCGLIB$$948bf228 cannot be cast to class java.lang.Number (org.mockito.internal.creation.jmock.ClassImposterizer$ClassWithSuperclassToWorkAroundCglibBug$$EnhancerByMockitoWithCGLIB$$948bf228 is in unnamed module of loader org.apache.tools.ant.loader.AntClassLoader5 @f019fec; java.lang.Number is in module java.base of loader 'bootstrap')",
        "fail_line": "        Number type_that_is_the_upper_bound_of_the_wildcard = (Number) mock.returningWildcard().get(45);",
        "test_source": "  public void can_create_mock_from_return_types_declared_with_a_bounded_wildcard() throws Exception {\n  GenericsNest<?> mock = mock(GenericsNest.class, RETURNS_DEEP_STUBS);\n\n  List<? super Integer> objects = mock.returningWildcard();\n  Number type_that_is_the_upper_bound_of_the_wildcard = (Number) mock.returningWildcard().get(45);\n  type_that_is_the_upper_bound_of_the_wildcard.floatValue();\n  }",
        "stack": [
          "ReturnsGenericDeepStubsTest.can_create_mock_from_return_types_declared_with_a_bounded_wildcard line 80"
        ]
      },
      {
        "methodName": "can_create_mock_from_multiple_type_variable_bounds_when_return_type_of_parameterized_method_is_a_parameterizedtype_that_is_referencing_a_typevar_on_class",
        "error": "java.lang.ClassCastException",
        "message": "class org.mockito.internal.creation.jmock.ClassImposterizer$ClassWithSuperclassToWorkAroundCglibBug$$EnhancerByMockitoWithCGLIB$$948bf228 cannot be cast to class java.lang.Cloneable (org.mockito.internal.creation.jmock.ClassImposterizer$ClassWithSuperclassToWorkAroundCglibBug$$EnhancerByMockitoWithCGLIB$$948bf228 is in unnamed module of loader org.apache.tools.ant.loader.AntClassLoader5 @f019fec; java.lang.Cloneable is in module java.base of loader 'bootstrap')",
        "fail_line": "                mock.paramTypeWithTypeParams().get(0);",
        "test_source": "  public void can_create_mock_from_multiple_type_variable_bounds_when_return_type_of_parameterized_method_is_a_parameterizedtype_that_is_referencing_a_typevar_on_class() throws Exception {\n  GenericsNest<?> mock = mock(GenericsNest.class, RETURNS_DEEP_STUBS);\n\n  Cloneable cloneable_bound_that_is_declared_on_typevar_K_in_the_class_which_is_referenced_by_typevar_O_declared_on_the_method =\n  mock.paramTypeWithTypeParams().get(0);\n  Comparable<?> comparable_bound_that_is_declared_on_typevar_K_in_the_class_which_is_referenced_by_typevar_O_declared_on_the_method =\n  mock.paramTypeWithTypeParams().get(0);\n  }",
        "stack": [
          "ReturnsGenericDeepStubsTest.can_create_mock_from_multiple_type_variable_bounds_when_return_type_of_parameterized_method_is_a_parameterizedtype_that_is_referencing_a_typevar_on_class line 54"
        ]
      },
      {
        "methodName": "generic_deep_mock_frenzy__look_at_these_chained_calls",
        "error": "java.lang.ClassCastException",
        "message": "class org.mockito.internal.creation.jmock.ClassImposterizer$ClassWithSuperclassToWorkAroundCglibBug$$EnhancerByMockitoWithCGLIB$$948bf228 cannot be cast to class java.util.Map$Entry (org.mockito.internal.creation.jmock.ClassImposterizer$ClassWithSuperclassToWorkAroundCglibBug$$EnhancerByMockitoWithCGLIB$$948bf228 is in unnamed module of loader org.apache.tools.ant.loader.AntClassLoader5 @f019fec; java.util.Map$Entry is in module java.base of loader 'bootstrap')",
        "fail_line": "        Map.Entry<? extends Cloneable, Set<Number>> nextEntry = mock.entrySet().iterator().next();",
        "test_source": "  public void generic_deep_mock_frenzy__look_at_these_chained_calls() throws Exception {\n  GenericsNest<?> mock = mock(GenericsNest.class, RETURNS_DEEP_STUBS);\n\n  Set<? extends Map.Entry<? extends Cloneable, Set<Number>>> entries = mock.entrySet();\n  Iterator<? extends Map.Entry<? extends Cloneable,Set<Number>>> entriesIterator = mock.entrySet().iterator();\n  Map.Entry<? extends Cloneable, Set<Number>> nextEntry = mock.entrySet().iterator().next();\n\n  Cloneable cloneableKey = mock.entrySet().iterator().next().getKey();\n  Comparable<?> comparableKey = mock.entrySet().iterator().next().getKey();\n\n  Set<Number> value = mock.entrySet().iterator().next().getValue();\n  Iterator<Number> numbersIterator = mock.entrySet().iterator().next().getValue().iterator();\n  Number number = mock.entrySet().iterator().next().getValue().iterator().next();\n  }",
        "stack": [
          "ReturnsGenericDeepStubsTest.generic_deep_mock_frenzy__look_at_these_chained_calls line 39"
        ]
      },
      {
        "methodName": "can_create_mock_from_multiple_type_variable_bounds_when_method_return_type_is_referencing_a_typevar_on_class",
        "error": "java.lang.ClassCastException",
        "message": "class $java.lang.Comparable$$EnhancerByMockitoWithCGLIB$$b6556ee8 cannot be cast to class java.lang.Cloneable ($java.lang.Comparable$$EnhancerByMockitoWithCGLIB$$b6556ee8 is in unnamed module of loader org.apache.tools.ant.loader.AntClassLoader5 @f019fec; java.lang.Cloneable is in module java.base of loader 'bootstrap')",
        "fail_line": "        Cloneable cloneable_bound_of_typevar_K = mock.returningK();",
        "test_source": "  public void can_create_mock_from_multiple_type_variable_bounds_when_method_return_type_is_referencing_a_typevar_on_class() throws Exception {\n  GenericsNest<?> mock = mock(GenericsNest.class, RETURNS_DEEP_STUBS);\n\n  Cloneable cloneable_bound_of_typevar_K = mock.returningK();\n  Comparable<?> comparable_bound_of_typevar_K = mock.returningK();\n  }",
        "stack": [
          "ReturnsGenericDeepStubsTest.can_create_mock_from_multiple_type_variable_bounds_when_method_return_type_is_referencing_a_typevar_on_class line 63"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java",
      "buggy_full_code": "\npackage org.mockito.internal.stubbing.defaultanswers;\n\nimport org.mockito.internal.InternalMockHandler;\nimport org.mockito.internal.creation.settings.CreationSettings;\nimport org.mockito.internal.stubbing.InvocationContainerImpl;\nimport org.mockito.internal.stubbing.StubbedInvocationMatcher;\nimport org.mockito.internal.util.MockCreationValidator;\nimport org.mockito.internal.util.MockUtil;\nimport org.mockito.internal.util.reflection.GenericMetadataSupport;\nimport org.mockito.invocation.InvocationOnMock;\nimport org.mockito.stubbing.Answer;\n\nimport java.io.Serializable;\n\n\n\npublic class ReturnsDeepStubs implements Answer<Object>, Serializable { private static final long serialVersionUID = -7105341425736035847L; private ReturnsEmptyValues delegate = new ReturnsEmptyValues(); public Object answer(InvocationOnMock invocation) throws Throwable {\n        GenericMetadataSupport returnTypeGenericMetadata =\n                actualParameterizedType(invocation.getMock()).resolveGenericReturnType(invocation.getMethod());\n\n        Class<?> rawType = returnTypeGenericMetadata.rawType();\n        if (!new MockCreationValidator().isTypeMockable(rawType)) {\n            return delegate.returnValueFor(rawType);\n        }\n\n        return getMock(invocation);\n    }\n\n    private Object getMock(InvocationOnMock invocation) throws Throwable {\n    \tInternalMockHandler<Object> handler = new MockUtil().getMockHandler(invocation.getMock());\n    \tInvocationContainerImpl container = (InvocationContainerImpl) handler.getInvocationContainer();\n\n        \n        for (StubbedInvocationMatcher stubbedInvocationMatcher : container.getStubbedInvocations()) {\n    \t\tif(container.getInvocationForStubbing().matches(stubbedInvocationMatcher.getInvocation())) {\n    \t\t\treturn stubbedInvocationMatcher.answer(invocation);\n    \t\t}\n\t\t}\n\n        \n        return recordDeepStubMock(invocation, container);\n    }\n\n    \n\n\n\n\n    private Object recordDeepStubMock(InvocationOnMock invocation, InvocationContainerImpl container) {\n        Class<?> clz = invocation.getMethod().getReturnType();\n        final Object mock = org.mockito.Mockito.mock(clz, this);\n\n        container.addAnswer(new Answer<Object>() {\n            public Object answer(InvocationOnMock invocation) throws Throwable {\n                return mock;\n            }\n        }, false);\n\n        return mock;\n    }\n\n    protected GenericMetadataSupport actualParameterizedType(Object mock) {\n        CreationSettings mockSettings = (CreationSettings) new MockUtil().getMockHandler(mock).getMockSettings();\n        return GenericMetadataSupport.inferFrom(mockSettings.getTypeToMock());\n    }\n}\n",
      "fixed_full_code": "\npackage org.mockito.internal.stubbing.defaultanswers;\n\nimport org.mockito.MockSettings;\nimport org.mockito.internal.InternalMockHandler;\nimport org.mockito.internal.creation.settings.CreationSettings;\nimport org.mockito.internal.stubbing.InvocationContainerImpl;\nimport org.mockito.internal.stubbing.StubbedInvocationMatcher;\nimport org.mockito.internal.util.MockCreationValidator;\nimport org.mockito.internal.util.MockUtil;\nimport org.mockito.internal.util.reflection.GenericMetadataSupport;\nimport org.mockito.invocation.InvocationOnMock;\nimport org.mockito.stubbing.Answer;\n\nimport java.io.Serializable;\n\nimport static org.mockito.Mockito.mock; import static org.mockito.Mockito.withSettings; public class ReturnsDeepStubs implements Answer<Object>, Serializable { private static final long serialVersionUID = -7105341425736035847L; private ReturnsEmptyValues delegate = new ReturnsEmptyValues(); public Object answer(InvocationOnMock invocation) throws Throwable {\n        GenericMetadataSupport returnTypeGenericMetadata =\n                actualParameterizedType(invocation.getMock()).resolveGenericReturnType(invocation.getMethod());\n\n        Class<?> rawType = returnTypeGenericMetadata.rawType();\n        if (!new MockCreationValidator().isTypeMockable(rawType)) {\n            return delegate.returnValueFor(rawType);\n        }\n\n        return getMock(invocation, returnTypeGenericMetadata);\n    }\n\n    private Object getMock(InvocationOnMock invocation, GenericMetadataSupport returnTypeGenericMetadata) throws Throwable {\n    \tInternalMockHandler<Object> handler = new MockUtil().getMockHandler(invocation.getMock());\n    \tInvocationContainerImpl container = (InvocationContainerImpl) handler.getInvocationContainer();\n\n        \n        for (StubbedInvocationMatcher stubbedInvocationMatcher : container.getStubbedInvocations()) {\n    \t\tif(container.getInvocationForStubbing().matches(stubbedInvocationMatcher.getInvocation())) {\n    \t\t\treturn stubbedInvocationMatcher.answer(invocation);\n    \t\t}\n\t\t}\n\n        \n        return recordDeepStubMock(createNewDeepStubMock(returnTypeGenericMetadata), container);\n    }\n\n    \n    private Object createNewDeepStubMock(GenericMetadataSupport returnTypeGenericMetadata) {\n        return mock(\n                returnTypeGenericMetadata.rawType(),\n                withSettingsUsing(returnTypeGenericMetadata)\n        );\n    }\n\n    private MockSettings withSettingsUsing(GenericMetadataSupport returnTypeGenericMetadata) {\n        MockSettings mockSettings =\n                returnTypeGenericMetadata.rawExtraInterfaces().length > 0 ?\n                withSettings().extraInterfaces(returnTypeGenericMetadata.rawExtraInterfaces())\n                : withSettings();\n\n        return mockSettings\n                .defaultAnswer(returnsDeepStubsAnswerUsing(returnTypeGenericMetadata));\n    }\n\n    private ReturnsDeepStubs returnsDeepStubsAnswerUsing(final GenericMetadataSupport returnTypeGenericMetadata) {\n        return new ReturnsDeepStubs() {\n            @Override\n            protected GenericMetadataSupport actualParameterizedType(Object mock) {\n                return returnTypeGenericMetadata;\n            }\n        };\n    }\n\n    private Object recordDeepStubMock(final Object mock, InvocationContainerImpl container) throws Throwable {\n\n        container.addAnswer(new Answer<Object>() {\n            public Object answer(InvocationOnMock invocation) throws Throwable {\n                return mock;\n            }\n        }, false);\n\n        return mock;\n    }\n\n    protected GenericMetadataSupport actualParameterizedType(Object mock) {\n        CreationSettings mockSettings = (CreationSettings) new MockUtil().getMockHandler(mock).getMockSettings();\n        return GenericMetadataSupport.inferFrom(mockSettings.getTypeToMock());\n    }\n}\n",
      "buggy_signatures": [
        "private Object getMock(InvocationOnMock invocation) throws Throwable",
        "private Object recordDeepStubMock(InvocationOnMock invocation, InvocationContainerImpl container)",
        "public Object answer(InvocationOnMock invocation) throws Throwable",
        "protected GenericMetadataSupport actualParameterizedType(Object mock)"
      ],
      "fixed_signatures": [
        "private Object getMock(InvocationOnMock invocation, GenericMetadataSupport returnTypeGenericMetadata) throws Throwable",
        "private Object createNewDeepStubMock(GenericMetadataSupport returnTypeGenericMetadata)",
        "private MockSettings withSettingsUsing(GenericMetadataSupport returnTypeGenericMetadata)",
        "private ReturnsDeepStubs returnsDeepStubsAnswerUsing(final GenericMetadataSupport returnTypeGenericMetadata)",
        "protected GenericMetadataSupport actualParameterizedType(Object mock)",
        "private Object recordDeepStubMock(final Object mock, InvocationContainerImpl container) throws Throwable",
        "public Object answer(InvocationOnMock invocation) throws Throwable",
        "protected GenericMetadataSupport actualParameterizedType(Object mock)"
      ],
      "methods": [
        {
          "buggy_method": "",
          "fixed_method": "",
          "diff": [
            "@@ -4,6 +4,7 @@",
            "  */\n",
            " package org.mockito.internal.stubbing.defaultanswers;\n",
            " \n",
            "+import org.mockito.MockSettings;\n",
            " import org.mockito.internal.InternalMockHandler;\n",
            " import org.mockito.internal.creation.settings.CreationSettings;\n",
            " import org.mockito.internal.stubbing.InvocationContainerImpl;\n"
          ],
          "changed_lines": 1
        },
        {
          "buggy_method": "",
          "fixed_method": "",
          "diff": [
            "@@ -16,6 +17,8 @@",
            " \n",
            " import java.io.Serializable;\n",
            " \n",
            "+import static org.mockito.Mockito.mock;\n",
            "+import static org.mockito.Mockito.withSettings;\n",
            " \n",
            " /**\n",
            "  * Returning deep stub implementation.\n"
          ],
          "changed_lines": 2
        },
        {
          "buggy_method": "  private Object getMock(InvocationOnMock invocation) throws Throwable {\n  \tInternalMockHandler<Object> handler = new MockUtil().getMockHandler(invocation.getMock());\n  \tInvocationContainerImpl container = (InvocationContainerImpl) handler.getInvocationContainer();\n\n  \n  for (StubbedInvocationMatcher stubbedInvocationMatcher : container.getStubbedInvocations()) {\n  \t\tif(container.getInvocationForStubbing().matches(stubbedInvocationMatcher.getInvocation())) {\n  \t\t\treturn stubbedInvocationMatcher.answer(invocation);\n  \t\t}\n\t\t}\n\n  \n  return recordDeepStubMock(invocation, container);\n  }",
          "fixed_method": "  private Object getMock(InvocationOnMock invocation, GenericMetadataSupport returnTypeGenericMetadata) throws Throwable {\n  \tInternalMockHandler<Object> handler = new MockUtil().getMockHandler(invocation.getMock());\n  \tInvocationContainerImpl container = (InvocationContainerImpl) handler.getInvocationContainer();\n\n  \n  for (StubbedInvocationMatcher stubbedInvocationMatcher : container.getStubbedInvocations()) {\n  \t\tif(container.getInvocationForStubbing().matches(stubbedInvocationMatcher.getInvocation())) {\n  \t\t\treturn stubbedInvocationMatcher.answer(invocation);\n  \t\t}\n\t\t}\n\n  \n  return recordDeepStubMock(createNewDeepStubMock(returnTypeGenericMetadata), container);\n  }",
          "diff": [
            "@@ -50,10 +53,10 @@",
            "             return delegate.returnValueFor(rawType);\n",
            "         }\n",
            " \n",
            "-        return getMock(invocation);\n",
            "+        return getMock(invocation, returnTypeGenericMetadata);\n",
            "     }\n",
            " \n",
            "-    private Object getMock(InvocationOnMock invocation) throws Throwable {\n",
            "+    private Object getMock(InvocationOnMock invocation, GenericMetadataSupport returnTypeGenericMetadata) throws Throwable {\n",
            "     \tInternalMockHandler<Object> handler = new MockUtil().getMockHandler(invocation.getMock());\n",
            "     \tInvocationContainerImpl container = (InvocationContainerImpl) handler.getInvocationContainer();\n",
            " \n",
            "@@ -65,7 +68,7 @@",
            " \t\t}\n",
            " \n",
            "         // deep stub\n",
            "-        return recordDeepStubMock(invocation, container);\n",
            "+        return recordDeepStubMock(createNewDeepStubMock(returnTypeGenericMetadata), container);\n",
            "     }\n",
            " \n",
            "     /**\n"
          ],
          "changed_lines": 6
        },
        {
          "buggy_method": "  private Object recordDeepStubMock(InvocationOnMock invocation, InvocationContainerImpl container) {\n  Class<?> clz = invocation.getMethod().getReturnType();\n  final Object mock = org.mockito.Mockito.mock(clz, this);\n\n  container.addAnswer(new Answer<Object>() {\n  public Object answer(InvocationOnMock invocation) throws Throwable {\n  return mock;\n  }\n  }, false);\n\n  return mock;\n  }",
          "fixed_method": "  private MockSettings withSettingsUsing(GenericMetadataSupport returnTypeGenericMetadata) {\n  MockSettings mockSettings =\n  returnTypeGenericMetadata.rawExtraInterfaces().length > 0 ?\n  withSettings().extraInterfaces(returnTypeGenericMetadata.rawExtraInterfaces())\n  : withSettings();\n\n  return mockSettings\n  .defaultAnswer(returnsDeepStubsAnswerUsing(returnTypeGenericMetadata));\n  }",
          "diff": [
            "@@ -74,13 +77,33 @@",
            "      * @param returnTypeGenericMetadata The metadata to use to create the new mock.\n",
            "      * @return The mock\n",
            "      */\n",
            "+    private Object createNewDeepStubMock(GenericMetadataSupport returnTypeGenericMetadata) {\n",
            "+        return mock(\n",
            "+                returnTypeGenericMetadata.rawType(),\n",
            "+                withSettingsUsing(returnTypeGenericMetadata)\n",
            "+        );\n",
            "+    }\n",
            " \n",
            "+    private MockSettings withSettingsUsing(GenericMetadataSupport returnTypeGenericMetadata) {\n",
            "+        MockSettings mockSettings =\n",
            "+                returnTypeGenericMetadata.rawExtraInterfaces().length > 0 ?\n",
            "+                withSettings().extraInterfaces(returnTypeGenericMetadata.rawExtraInterfaces())\n",
            "+                : withSettings();\n",
            " \n",
            "+        return mockSettings\n",
            "+                .defaultAnswer(returnsDeepStubsAnswerUsing(returnTypeGenericMetadata));\n",
            "+    }\n",
            " \n",
            "+    private ReturnsDeepStubs returnsDeepStubsAnswerUsing(final GenericMetadataSupport returnTypeGenericMetadata) {\n",
            "+        return new ReturnsDeepStubs() {\n",
            "+            @Override\n",
            "+            protected GenericMetadataSupport actualParameterizedType(Object mock) {\n",
            "+                return returnTypeGenericMetadata;\n",
            "+            }\n",
            "+        };\n",
            "+    }\n",
            " \n",
            "-    private Object recordDeepStubMock(InvocationOnMock invocation, InvocationContainerImpl container) {\n",
            "-        Class<?> clz = invocation.getMethod().getReturnType();\n",
            "-        final Object mock = org.mockito.Mockito.mock(clz, this);\n",
            "+    private Object recordDeepStubMock(final Object mock, InvocationContainerImpl container) throws Throwable {\n",
            " \n",
            "         container.addAnswer(new Answer<Object>() {\n",
            "             public Object answer(InvocationOnMock invocation) throws Throwable {\n"
          ],
          "changed_lines": 26
        }
      ]
    }
  ]
}
