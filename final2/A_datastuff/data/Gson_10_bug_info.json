{
  "bug_id": "10",
  "failed_tests": {
    "com.google.gson.functional.JsonAdapterAnnotationOnFieldsTest": [
      {
        "methodName": "testPrimitiveFieldAnnotationTakesPrecedenceOverDefault",
        "error": "junit.framework.ComparisonFailure",
        "message": "expected:<{\"part\":[\"42\"]}> but was:<{\"part\":[42]}>",
        "fail_line": "    assertEquals(\"{\\\"part\\\":\\\"42\\\"}\", json);",
        "test_source": "  public void testPrimitiveFieldAnnotationTakesPrecedenceOverDefault() {\n  Gson gson = new Gson();\n  String json = gson.toJson(new GadgetWithPrimitivePart(42));\n  assertEquals(\"{\\\"part\\\":\\\"42\\\"}\", json);\n  GadgetWithPrimitivePart gadget = gson.fromJson(json, GadgetWithPrimitivePart.class);\n  assertEquals(42, gadget.part);\n  }",
        "stack": [
          "JsonAdapterAnnotationOnFieldsTest.testPrimitiveFieldAnnotationTakesPrecedenceOverDefault line 236"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
      "buggy_full_code": "\n\npackage com.google.gson.internal.bind;\n\nimport com.google.gson.FieldNamingStrategy;\nimport com.google.gson.Gson;\nimport com.google.gson.JsonSyntaxException;\nimport com.google.gson.TypeAdapter;\nimport com.google.gson.TypeAdapterFactory;\nimport com.google.gson.annotations.JsonAdapter;\nimport com.google.gson.annotations.SerializedName;\nimport com.google.gson.internal.$Gson$Types;\nimport com.google.gson.internal.ConstructorConstructor;\nimport com.google.gson.internal.Excluder;\nimport com.google.gson.internal.ObjectConstructor;\nimport com.google.gson.internal.Primitives;\nimport com.google.gson.reflect.TypeToken;\nimport com.google.gson.stream.JsonReader;\nimport com.google.gson.stream.JsonToken;\nimport com.google.gson.stream.JsonWriter;\n\nimport java.io.IOException;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Type;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport static com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory.getTypeAdapter; public final class ReflectiveTypeAdapterFactory implements TypeAdapterFactory { private final ConstructorConstructor constructorConstructor; private final FieldNamingStrategy fieldNamingPolicy; private final Excluder excluder; public ReflectiveTypeAdapterFactory(ConstructorConstructor constructorConstructor, FieldNamingStrategy fieldNamingPolicy, Excluder excluder) {\n    this.constructorConstructor = constructorConstructor;\n    this.fieldNamingPolicy = fieldNamingPolicy;\n    this.excluder = excluder;\n  }\n\n  public boolean excludeField(Field f, boolean serialize) {\n    return excludeField(f, serialize, excluder);\n  }\n\n  static boolean excludeField(Field f, boolean serialize, Excluder excluder) {\n    return !excluder.excludeClass(f.getType(), serialize) && !excluder.excludeField(f, serialize);\n  }\n\n  \n  private List<String> getFieldNames(Field f) {\n    SerializedName annotation = f.getAnnotation(SerializedName.class);\n    if (annotation == null) {\n      String name = fieldNamingPolicy.translateName(f);\n      return Collections.singletonList(name);\n    }\n\n    String serializedName = annotation.value();\n    String[] alternates = annotation.alternate();\n    if (alternates.length == 0) {\n      return Collections.singletonList(serializedName);\n    }\n\n    List<String> fieldNames = new ArrayList<String>(alternates.length + 1);\n    fieldNames.add(serializedName);\n    for (String alternate : alternates) {\n      fieldNames.add(alternate);\n    }\n    return fieldNames;\n  }\n\n  @Override public <T> TypeAdapter<T> create(Gson gson, final TypeToken<T> type) {\n    Class<? super T> raw = type.getRawType();\n\n    if (!Object.class.isAssignableFrom(raw)) {\n      return null; \n    }\n\n    ObjectConstructor<T> constructor = constructorConstructor.get(type);\n    return new Adapter<T>(constructor, getBoundFields(gson, type, raw));\n  }\n\n  private ReflectiveTypeAdapterFactory.BoundField createBoundField( final Gson context, final Field field, final String name, final TypeToken<?> fieldType, boolean serialize, boolean deserialize) {\n    final boolean isPrimitive = Primitives.isPrimitive(fieldType.getRawType());\n    \n    JsonAdapter annotation = field.getAnnotation(JsonAdapter.class);\n    TypeAdapter<?> mapped = null;\n    if (annotation != null) {\n      mapped = getTypeAdapter(constructorConstructor, context, fieldType, annotation);\n    }\n    final boolean jsonAdapterPresent = mapped != null;\n    if (mapped == null) mapped = context.getAdapter(fieldType);\n\n    final TypeAdapter<?> typeAdapter = mapped;\n    return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n      @SuppressWarnings({\"unchecked\", \"rawtypes\"}) \n      @Override void write(JsonWriter writer, Object value)\n          throws IOException, IllegalAccessException {\n        Object fieldValue = field.get(value);\n        TypeAdapter t =\n          new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\n        t.write(writer, fieldValue);\n      }\n      @Override void read(JsonReader reader, Object value)\n          throws IOException, IllegalAccessException {\n        Object fieldValue = typeAdapter.read(reader);\n        if (fieldValue != null || !isPrimitive) {\n          field.set(value, fieldValue);\n        }\n      }\n      @Override public boolean writeField(Object value) throws IOException, IllegalAccessException {\n        if (!serialized) return false;\n        Object fieldValue = field.get(value);\n        return fieldValue != value; \n      }\n    };\n  }\n\n  private Map<String, BoundField> getBoundFields(Gson context, TypeToken<?> type, Class<?> raw) {\n    Map<String, BoundField> result = new LinkedHashMap<String, BoundField>();\n    if (raw.isInterface()) {\n      return result;\n    }\n\n    Type declaredType = type.getType();\n    while (raw != Object.class) {\n      Field[] fields = raw.getDeclaredFields();\n      for (Field field : fields) {\n        boolean serialize = excludeField(field, true);\n        boolean deserialize = excludeField(field, false);\n        if (!serialize && !deserialize) {\n          continue;\n        }\n        field.setAccessible(true);\n        Type fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType());\n        List<String> fieldNames = getFieldNames(field);\n        BoundField previous = null;\n        for (int i = 0; i < fieldNames.size(); ++i) {\n          String name = fieldNames.get(i);\n          if (i != 0) serialize = false; \n          BoundField boundField = createBoundField(context, field, name,\n              TypeToken.get(fieldType), serialize, deserialize);\n          BoundField replaced = result.put(name, boundField);\n          if (previous == null) previous = replaced;\n        }\n        if (previous != null) {\n          throw new IllegalArgumentException(declaredType\n              + \" declares multiple JSON fields named \" + previous.name);\n        }\n      }\n      type = TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass()));\n      raw = type.getRawType();\n    }\n    return result;\n  }\n\n  static abstract class BoundField { final String name; final boolean serialized; final boolean deserialized; protected BoundField(String name, boolean serialized, boolean deserialized) {\n      this.name = name;\n      this.serialized = serialized;\n      this.deserialized = deserialized;\n    }\n    abstract boolean writeField(Object value) throws IOException, IllegalAccessException; abstract void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException; abstract void read(JsonReader reader, Object value) throws IOException, IllegalAccessException; } public static final class Adapter<T> extends TypeAdapter<T> {\n    private final ObjectConstructor<T> constructor; private final Map<String, BoundField> boundFields; Adapter(ObjectConstructor<T> constructor, Map<String, BoundField> boundFields) {\n      this.constructor = constructor;\n      this.boundFields = boundFields;\n    }\n\n    @Override public T read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n\n      T instance = constructor.construct();\n\n      try {\n        in.beginObject();\n        while (in.hasNext()) {\n          String name = in.nextName();\n          BoundField field = boundFields.get(name);\n          if (field == null || !field.deserialized) {\n            in.skipValue();\n          } else {\n            field.read(in, instance);\n          }\n        }\n      } catch (IllegalStateException e) {\n        throw new JsonSyntaxException(e);\n      } catch (IllegalAccessException e) {\n        throw new AssertionError(e);\n      }\n      in.endObject();\n      return instance;\n    }\n\n    @Override public void write(JsonWriter out, T value) throws IOException {\n      if (value == null) {\n        out.nullValue();\n        return;\n      }\n\n      out.beginObject();\n      try {\n        for (BoundField boundField : boundFields.values()) {\n          if (boundField.writeField(value)) {\n            out.name(boundField.name);\n            boundField.write(out, value);\n          }\n        }\n      } catch (IllegalAccessException e) {\n        throw new AssertionError(e);\n      }\n      out.endObject();\n    }\n  }\n}\n",
      "fixed_full_code": "\n\npackage com.google.gson.internal.bind;\n\nimport com.google.gson.FieldNamingStrategy;\nimport com.google.gson.Gson;\nimport com.google.gson.JsonSyntaxException;\nimport com.google.gson.TypeAdapter;\nimport com.google.gson.TypeAdapterFactory;\nimport com.google.gson.annotations.JsonAdapter;\nimport com.google.gson.annotations.SerializedName;\nimport com.google.gson.internal.$Gson$Types;\nimport com.google.gson.internal.ConstructorConstructor;\nimport com.google.gson.internal.Excluder;\nimport com.google.gson.internal.ObjectConstructor;\nimport com.google.gson.internal.Primitives;\nimport com.google.gson.reflect.TypeToken;\nimport com.google.gson.stream.JsonReader;\nimport com.google.gson.stream.JsonToken;\nimport com.google.gson.stream.JsonWriter;\n\nimport java.io.IOException;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Type;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport static com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory.getTypeAdapter; public final class ReflectiveTypeAdapterFactory implements TypeAdapterFactory { private final ConstructorConstructor constructorConstructor; private final FieldNamingStrategy fieldNamingPolicy; private final Excluder excluder; public ReflectiveTypeAdapterFactory(ConstructorConstructor constructorConstructor, FieldNamingStrategy fieldNamingPolicy, Excluder excluder) {\n    this.constructorConstructor = constructorConstructor;\n    this.fieldNamingPolicy = fieldNamingPolicy;\n    this.excluder = excluder;\n  }\n\n  public boolean excludeField(Field f, boolean serialize) {\n    return excludeField(f, serialize, excluder);\n  }\n\n  static boolean excludeField(Field f, boolean serialize, Excluder excluder) {\n    return !excluder.excludeClass(f.getType(), serialize) && !excluder.excludeField(f, serialize);\n  }\n\n  \n  private List<String> getFieldNames(Field f) {\n    SerializedName annotation = f.getAnnotation(SerializedName.class);\n    if (annotation == null) {\n      String name = fieldNamingPolicy.translateName(f);\n      return Collections.singletonList(name);\n    }\n\n    String serializedName = annotation.value();\n    String[] alternates = annotation.alternate();\n    if (alternates.length == 0) {\n      return Collections.singletonList(serializedName);\n    }\n\n    List<String> fieldNames = new ArrayList<String>(alternates.length + 1);\n    fieldNames.add(serializedName);\n    for (String alternate : alternates) {\n      fieldNames.add(alternate);\n    }\n    return fieldNames;\n  }\n\n  @Override public <T> TypeAdapter<T> create(Gson gson, final TypeToken<T> type) {\n    Class<? super T> raw = type.getRawType();\n\n    if (!Object.class.isAssignableFrom(raw)) {\n      return null; \n    }\n\n    ObjectConstructor<T> constructor = constructorConstructor.get(type);\n    return new Adapter<T>(constructor, getBoundFields(gson, type, raw));\n  }\n\n  private ReflectiveTypeAdapterFactory.BoundField createBoundField( final Gson context, final Field field, final String name, final TypeToken<?> fieldType, boolean serialize, boolean deserialize) {\n    final boolean isPrimitive = Primitives.isPrimitive(fieldType.getRawType());\n    \n    JsonAdapter annotation = field.getAnnotation(JsonAdapter.class);\n    TypeAdapter<?> mapped = null;\n    if (annotation != null) {\n      mapped = getTypeAdapter(constructorConstructor, context, fieldType, annotation);\n    }\n    final boolean jsonAdapterPresent = mapped != null;\n    if (mapped == null) mapped = context.getAdapter(fieldType);\n\n    final TypeAdapter<?> typeAdapter = mapped;\n    return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n      @SuppressWarnings({\"unchecked\", \"rawtypes\"}) \n      @Override void write(JsonWriter writer, Object value)\n          throws IOException, IllegalAccessException {\n        Object fieldValue = field.get(value);\n        TypeAdapter t = jsonAdapterPresent ? typeAdapter\n            : new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\n        t.write(writer, fieldValue);\n      }\n      @Override void read(JsonReader reader, Object value)\n          throws IOException, IllegalAccessException {\n        Object fieldValue = typeAdapter.read(reader);\n        if (fieldValue != null || !isPrimitive) {\n          field.set(value, fieldValue);\n        }\n      }\n      @Override public boolean writeField(Object value) throws IOException, IllegalAccessException {\n        if (!serialized) return false;\n        Object fieldValue = field.get(value);\n        return fieldValue != value; \n      }\n    };\n  }\n\n  private Map<String, BoundField> getBoundFields(Gson context, TypeToken<?> type, Class<?> raw) {\n    Map<String, BoundField> result = new LinkedHashMap<String, BoundField>();\n    if (raw.isInterface()) {\n      return result;\n    }\n\n    Type declaredType = type.getType();\n    while (raw != Object.class) {\n      Field[] fields = raw.getDeclaredFields();\n      for (Field field : fields) {\n        boolean serialize = excludeField(field, true);\n        boolean deserialize = excludeField(field, false);\n        if (!serialize && !deserialize) {\n          continue;\n        }\n        field.setAccessible(true);\n        Type fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType());\n        List<String> fieldNames = getFieldNames(field);\n        BoundField previous = null;\n        for (int i = 0; i < fieldNames.size(); ++i) {\n          String name = fieldNames.get(i);\n          if (i != 0) serialize = false; \n          BoundField boundField = createBoundField(context, field, name,\n              TypeToken.get(fieldType), serialize, deserialize);\n          BoundField replaced = result.put(name, boundField);\n          if (previous == null) previous = replaced;\n        }\n        if (previous != null) {\n          throw new IllegalArgumentException(declaredType\n              + \" declares multiple JSON fields named \" + previous.name);\n        }\n      }\n      type = TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass()));\n      raw = type.getRawType();\n    }\n    return result;\n  }\n\n  static abstract class BoundField { final String name; final boolean serialized; final boolean deserialized; protected BoundField(String name, boolean serialized, boolean deserialized) {\n      this.name = name;\n      this.serialized = serialized;\n      this.deserialized = deserialized;\n    }\n    abstract boolean writeField(Object value) throws IOException, IllegalAccessException; abstract void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException; abstract void read(JsonReader reader, Object value) throws IOException, IllegalAccessException; } public static final class Adapter<T> extends TypeAdapter<T> {\n    private final ObjectConstructor<T> constructor; private final Map<String, BoundField> boundFields; Adapter(ObjectConstructor<T> constructor, Map<String, BoundField> boundFields) {\n      this.constructor = constructor;\n      this.boundFields = boundFields;\n    }\n\n    @Override public T read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n\n      T instance = constructor.construct();\n\n      try {\n        in.beginObject();\n        while (in.hasNext()) {\n          String name = in.nextName();\n          BoundField field = boundFields.get(name);\n          if (field == null || !field.deserialized) {\n            in.skipValue();\n          } else {\n            field.read(in, instance);\n          }\n        }\n      } catch (IllegalStateException e) {\n        throw new JsonSyntaxException(e);\n      } catch (IllegalAccessException e) {\n        throw new AssertionError(e);\n      }\n      in.endObject();\n      return instance;\n    }\n\n    @Override public void write(JsonWriter out, T value) throws IOException {\n      if (value == null) {\n        out.nullValue();\n        return;\n      }\n\n      out.beginObject();\n      try {\n        for (BoundField boundField : boundFields.values()) {\n          if (boundField.writeField(value)) {\n            out.name(boundField.name);\n            boundField.write(out, value);\n          }\n        }\n      } catch (IllegalAccessException e) {\n        throw new AssertionError(e);\n      }\n      out.endObject();\n    }\n  }\n}\n",
      "buggy_signatures": [
        "static com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory.getTypeAdapter; public final class ReflectiveTypeAdapterFactory implements TypeAdapterFactory { private final ConstructorConstructor constructorConstructor; private final FieldNamingStrategy fieldNamingPolicy; private final Excluder excluder; public ReflectiveTypeAdapterFactory(ConstructorConstructor constructorConstructor, FieldNamingStrategy fieldNamingPolicy, Excluder excluder)",
        "public boolean excludeField(Field f, boolean serialize)",
        "static boolean excludeField(Field f, boolean serialize, Excluder excluder)",
        "private List<String> getFieldNames(Field f)",
        "public <T> TypeAdapter<T> create(Gson gson, final TypeToken<T> type)",
        "private ReflectiveTypeAdapterFactory.BoundField createBoundField( final Gson context, final Field field, final String name, final TypeToken<?> fieldType, boolean serialize, boolean deserialize)",
        "public boolean writeField(Object value) throws IOException, IllegalAccessException",
        "private Map<String, BoundField> getBoundFields(Gson context, TypeToken<?> type, Class<?> raw)",
        "static abstract class BoundField { final String name; final boolean serialized; final boolean deserialized; protected BoundField(String name, boolean serialized, boolean deserialized)",
        "abstract boolean writeField(Object value) throws IOException, IllegalAccessException; abstract void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException; abstract void read(JsonReader reader, Object value) throws IOException, IllegalAccessException; } public static final class Adapter<T> extends TypeAdapter<T>",
        "private final ObjectConstructor<T> constructor; private final Map<String, BoundField> boundFields; Adapter(ObjectConstructor<T> constructor, Map<String, BoundField> boundFields)",
        "public T read(JsonReader in) throws IOException",
        "public void write(JsonWriter out, T value) throws IOException"
      ],
      "fixed_signatures": [
        "static com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory.getTypeAdapter; public final class ReflectiveTypeAdapterFactory implements TypeAdapterFactory { private final ConstructorConstructor constructorConstructor; private final FieldNamingStrategy fieldNamingPolicy; private final Excluder excluder; public ReflectiveTypeAdapterFactory(ConstructorConstructor constructorConstructor, FieldNamingStrategy fieldNamingPolicy, Excluder excluder)",
        "public boolean excludeField(Field f, boolean serialize)",
        "static boolean excludeField(Field f, boolean serialize, Excluder excluder)",
        "private List<String> getFieldNames(Field f)",
        "public <T> TypeAdapter<T> create(Gson gson, final TypeToken<T> type)",
        "private ReflectiveTypeAdapterFactory.BoundField createBoundField( final Gson context, final Field field, final String name, final TypeToken<?> fieldType, boolean serialize, boolean deserialize)",
        "public boolean writeField(Object value) throws IOException, IllegalAccessException",
        "private Map<String, BoundField> getBoundFields(Gson context, TypeToken<?> type, Class<?> raw)",
        "static abstract class BoundField { final String name; final boolean serialized; final boolean deserialized; protected BoundField(String name, boolean serialized, boolean deserialized)",
        "abstract boolean writeField(Object value) throws IOException, IllegalAccessException; abstract void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException; abstract void read(JsonReader reader, Object value) throws IOException, IllegalAccessException; } public static final class Adapter<T> extends TypeAdapter<T>",
        "private final ObjectConstructor<T> constructor; private final Map<String, BoundField> boundFields; Adapter(ObjectConstructor<T> constructor, Map<String, BoundField> boundFields)",
        "public T read(JsonReader in) throws IOException",
        "public void write(JsonWriter out, T value) throws IOException"
      ],
      "methods": [
        {
          "buggy_method": "  private ReflectiveTypeAdapterFactory.BoundField createBoundField( final Gson context, final Field field, final String name, final TypeToken<?> fieldType, boolean serialize, boolean deserialize) {\n  final boolean isPrimitive = Primitives.isPrimitive(fieldType.getRawType());\n  \n  JsonAdapter annotation = field.getAnnotation(JsonAdapter.class);\n  TypeAdapter<?> mapped = null;\n  if (annotation != null) {\n  mapped = getTypeAdapter(constructorConstructor, context, fieldType, annotation);\n  }\n  final boolean jsonAdapterPresent = mapped != null;\n  if (mapped == null) mapped = context.getAdapter(fieldType);\n\n  final TypeAdapter<?> typeAdapter = mapped;\n  return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n  @SuppressWarnings({\"unchecked\", \"rawtypes\"}) \n  @Override void write(JsonWriter writer, Object value)\n  throws IOException, IllegalAccessException {\n  Object fieldValue = field.get(value);\n  TypeAdapter t =\n  new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\n  t.write(writer, fieldValue);\n  }\n  @Override void read(JsonReader reader, Object value)\n  throws IOException, IllegalAccessException {\n  Object fieldValue = typeAdapter.read(reader);\n  if (fieldValue != null || !isPrimitive) {\n  field.set(value, fieldValue);\n  }\n  }\n  @Override public boolean writeField(Object value) throws IOException, IllegalAccessException {\n  if (!serialized) return false;\n  Object fieldValue = field.get(value);\n  return fieldValue != value; \n  }\n  };\n  }",
          "fixed_method": "  private ReflectiveTypeAdapterFactory.BoundField createBoundField( final Gson context, final Field field, final String name, final TypeToken<?> fieldType, boolean serialize, boolean deserialize) {\n  final boolean isPrimitive = Primitives.isPrimitive(fieldType.getRawType());\n  \n  JsonAdapter annotation = field.getAnnotation(JsonAdapter.class);\n  TypeAdapter<?> mapped = null;\n  if (annotation != null) {\n  mapped = getTypeAdapter(constructorConstructor, context, fieldType, annotation);\n  }\n  final boolean jsonAdapterPresent = mapped != null;\n  if (mapped == null) mapped = context.getAdapter(fieldType);\n\n  final TypeAdapter<?> typeAdapter = mapped;\n  return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n  @SuppressWarnings({\"unchecked\", \"rawtypes\"}) \n  @Override void write(JsonWriter writer, Object value)\n  throws IOException, IllegalAccessException {\n  Object fieldValue = field.get(value);\n  TypeAdapter t = jsonAdapterPresent ? typeAdapter\n  : new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\n  t.write(writer, fieldValue);\n  }\n  @Override void read(JsonReader reader, Object value)\n  throws IOException, IllegalAccessException {\n  Object fieldValue = typeAdapter.read(reader);\n  if (fieldValue != null || !isPrimitive) {\n  field.set(value, fieldValue);\n  }\n  }\n  @Override public boolean writeField(Object value) throws IOException, IllegalAccessException {\n  if (!serialized) return false;\n  Object fieldValue = field.get(value);\n  return fieldValue != value; \n  }\n  };\n  }",
          "diff": [
            "@@ -119,8 +119,8 @@",
            "       @Override void write(JsonWriter writer, Object value)\n",
            "           throws IOException, IllegalAccessException {\n",
            "         Object fieldValue = field.get(value);\n",
            "-        TypeAdapter t =\n",
            "-          new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\n",
            "+        TypeAdapter t = jsonAdapterPresent ? typeAdapter\n",
            "+            : new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\n",
            "         t.write(writer, fieldValue);\n",
            "       }\n",
            "       @Override void read(JsonReader reader, Object value)\n"
          ],
          "changed_lines": 4
        }
      ]
    }
  ]
}
