{
  "bug_id": "18",
  "failed_tests": {
    "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest": [
      {
        "methodName": "testWriteNonAsciiDirectoryNamePosixMode",
        "error": "java.io.IOException",
        "message": "request to write '15' bytes exceeds size in header of '0' bytes for entry './PaxHeaders.X/fvv/'",
        "fail_line": "        tos.putArchiveEntry(t);",
        "test_source": "  public void testWriteNonAsciiDirectoryNamePosixMode() throws Exception {\n  String n = \"f\\u00f6\\u00f6/\";\n  TarArchiveEntry t = new TarArchiveEntry(n);\n  ByteArrayOutputStream bos = new ByteArrayOutputStream();\n  TarArchiveOutputStream tos = new TarArchiveOutputStream(bos);\n  tos.setAddPaxHeadersForNonAsciiNames(true);\n  tos.putArchiveEntry(t);\n  tos.closeArchiveEntry();\n  tos.close();\n  byte[] data = bos.toByteArray();\n  TarArchiveInputStream tin =\n  new TarArchiveInputStream(new ByteArrayInputStream(data));\n  TarArchiveEntry e = tin.getNextTarEntry();\n  assertEquals(n, e.getName());\n  assertTrue(e.isDirectory());\n  tin.close();\n  }",
        "stack": [
          "TarArchiveOutputStream.write line 387, TarArchiveOutputStream.writePaxHeaders line 489, TarArchiveOutputStream.putArchiveEntry line 314, TarArchiveOutputStreamTest.testWriteNonAsciiDirectoryNamePosixMode line 418"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java",
      "buggy_full_code": "\npackage org.apache.commons.compress.archivers.tar;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.StringWriter;\nimport java.nio.ByteBuffer;\nimport java.util.HashMap;\nimport java.util.Map;\nimport org.apache.commons.compress.archivers.ArchiveEntry;\nimport org.apache.commons.compress.archivers.ArchiveOutputStream;\nimport org.apache.commons.compress.archivers.zip.ZipEncoding;\nimport org.apache.commons.compress.archivers.zip.ZipEncodingHelper;\nimport org.apache.commons.compress.utils.CharsetNames;\nimport org.apache.commons.compress.utils.CountingOutputStream;\n\n\npublic class TarArchiveOutputStream extends ArchiveOutputStream { public static final int LONGFILE_ERROR = 0; public static final int LONGFILE_TRUNCATE = 1; public static final int LONGFILE_GNU = 2; public static final int LONGFILE_POSIX = 3; public static final int BIGNUMBER_ERROR = 0; public static final int BIGNUMBER_STAR = 1; public static final int BIGNUMBER_POSIX = 2; private long currSize; private String currName; private long currBytes; private final byte[] recordBuf; private int assemLen; private final byte[] assemBuf; protected final TarBuffer buffer; private int longFileMode = LONGFILE_ERROR; private int bigNumberMode = BIGNUMBER_ERROR; private boolean closed = false; private boolean haveUnclosedEntry = false; private boolean finished = false; private final OutputStream out; private final ZipEncoding encoding; private boolean addPaxHeadersForNonAsciiNames = false; private static final ZipEncoding ASCII = ZipEncodingHelper.getZipEncoding(\"ASCII\"); public TarArchiveOutputStream(OutputStream os) {\n        this(os, TarBuffer.DEFAULT_BLKSIZE, TarBuffer.DEFAULT_RCDSIZE);\n    }\n\n    \n    public TarArchiveOutputStream(OutputStream os, String encoding) {\n        this(os, TarBuffer.DEFAULT_BLKSIZE, TarBuffer.DEFAULT_RCDSIZE, encoding);\n    }\n\n    \n    public TarArchiveOutputStream(OutputStream os, int blockSize) {\n        this(os, blockSize, TarBuffer.DEFAULT_RCDSIZE);\n    }\n\n    \n    public TarArchiveOutputStream(OutputStream os, int blockSize, String encoding) {\n        this(os, blockSize, TarBuffer.DEFAULT_RCDSIZE, encoding);\n    }\n\n    \n    public TarArchiveOutputStream(OutputStream os, int blockSize, int recordSize) {\n        this(os, blockSize, recordSize, null);\n    }\n\n    \n    public TarArchiveOutputStream(OutputStream os, int blockSize, int recordSize, String encoding) {\n        out = new CountingOutputStream(os);\n        this.encoding = ZipEncodingHelper.getZipEncoding(encoding);\n\n        this.buffer = new TarBuffer(out, blockSize, recordSize);\n        this.assemLen = 0;\n        this.assemBuf = new byte[recordSize];\n        this.recordBuf = new byte[recordSize];\n    }\n\n    \n    public void setLongFileMode(int longFileMode) {\n        this.longFileMode = longFileMode;\n    }\n\n    \n    public void setBigNumberMode(int bigNumberMode) {\n        this.bigNumberMode = bigNumberMode;\n    }\n\n    \n    public void setAddPaxHeadersForNonAsciiNames(boolean b) {\n        addPaxHeadersForNonAsciiNames = b;\n    }\n\n    @Deprecated\n    @Override\n    public int getCount() {\n        return (int) getBytesWritten();\n    }\n\n    @Override\n    public long getBytesWritten() {\n        return ((CountingOutputStream) out).getBytesWritten();\n    }\n\n    \n    @Override\n    public void finish() throws IOException {\n        if (finished) {\n            throw new IOException(\"This archive has already been finished\");\n        }\n\n        if (haveUnclosedEntry) {\n            throw new IOException(\"This archives contains unclosed entries.\");\n        }\n        writeEOFRecord();\n        writeEOFRecord();\n        buffer.flushBlock();\n        finished = true;\n    }\n\n    \n    @Override\n    public void close() throws IOException {\n        if(!finished) {\n            finish();\n        }\n\n        if (!closed) {\n            buffer.close();\n            out.close();\n            closed = true;\n        }\n    }\n\n    \n    public int getRecordSize() {\n        return buffer.getRecordSize();\n    }\n\n    \n    @Override\n    public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException {\n        if(finished) {\n            throw new IOException(\"Stream has already been finished\");\n        }\n        TarArchiveEntry entry = (TarArchiveEntry) archiveEntry;\n        Map<String, String> paxHeaders = new HashMap<String, String>();\n        final String entryName = entry.getName();\n        final ByteBuffer encodedName = encoding.encode(entryName);\n        final int nameLen = encodedName.limit() - encodedName.position();\n        boolean paxHeaderContainsPath = false;\n        if (nameLen >= TarConstants.NAMELEN) {\n\n            if (longFileMode == LONGFILE_POSIX) {\n                paxHeaders.put(\"path\", entryName);\n                paxHeaderContainsPath = true;\n            } else if (longFileMode == LONGFILE_GNU) {\n                \n                \n                TarArchiveEntry longLinkEntry = new TarArchiveEntry(TarConstants.GNU_LONGLINK,\n                                                                    TarConstants.LF_GNUTYPE_LONGNAME);\n\n                longLinkEntry.setSize(nameLen + 1); \n                putArchiveEntry(longLinkEntry);\n                write(encodedName.array(), encodedName.arrayOffset(), nameLen);\n                write(0); \n                closeArchiveEntry();\n            } else if (longFileMode != LONGFILE_TRUNCATE) {\n                throw new RuntimeException(\"file name '\" + entryName\n                                           + \"' is too long ( > \"\n                                           + TarConstants.NAMELEN + \" bytes)\");\n            }\n        }\n\n        if (bigNumberMode == BIGNUMBER_POSIX) {\n            addPaxHeadersForBigNumbers(paxHeaders, entry);\n        } else if (bigNumberMode != BIGNUMBER_STAR) {\n            failForBigNumbers(entry);\n        }\n\n        if (addPaxHeadersForNonAsciiNames && !paxHeaderContainsPath\n            && !ASCII.canEncode(entryName)) {\n            paxHeaders.put(\"path\", entryName);\n        }\n\n        if (addPaxHeadersForNonAsciiNames\n            && (entry.isLink() || entry.isSymbolicLink())\n            && !ASCII.canEncode(entry.getLinkName())) {\n            paxHeaders.put(\"linkpath\", entry.getLinkName());\n        }\n\n        if (paxHeaders.size() > 0) {\n            writePaxHeaders(entryName, paxHeaders);\n        }\n\n        entry.writeEntryHeader(recordBuf, encoding,\n                               bigNumberMode == BIGNUMBER_STAR);\n        buffer.writeRecord(recordBuf);\n\n        currBytes = 0;\n\n        if (entry.isDirectory()) {\n            currSize = 0;\n        } else {\n            currSize = entry.getSize();\n        }\n        currName = entryName;\n        haveUnclosedEntry = true;\n    }\n\n    \n    @Override\n    public void closeArchiveEntry() throws IOException {\n        if (finished) {\n            throw new IOException(\"Stream has already been finished\");\n        }\n        if (!haveUnclosedEntry){\n            throw new IOException(\"No current entry to close\");\n        }\n        if (assemLen > 0) {\n            for (int i = assemLen; i < assemBuf.length; ++i) {\n                assemBuf[i] = 0;\n            }\n\n            buffer.writeRecord(assemBuf);\n\n            currBytes += assemLen;\n            assemLen = 0;\n        }\n\n        if (currBytes < currSize) {\n            throw new IOException(\"entry '\" + currName + \"' closed at '\"\n                                  + currBytes\n                                  + \"' before the '\" + currSize\n                                  + \"' bytes specified in the header were written\");\n        }\n        haveUnclosedEntry = false;\n    }\n\n    \n    @Override\n    public void write(byte[] wBuf, int wOffset, int numToWrite) throws IOException {\n        if ((currBytes + numToWrite) > currSize) {\n            throw new IOException(\"request to write '\" + numToWrite\n                                  + \"' bytes exceeds size in header of '\"\n                                  + currSize + \"' bytes for entry '\"\n                                  + currName + \"'\");\n\n            \n            \n            \n            \n            \n            \n            \n        }\n\n        if (assemLen > 0) {\n            if ((assemLen + numToWrite) >= recordBuf.length) {\n                int aLen = recordBuf.length - assemLen;\n\n                System.arraycopy(assemBuf, 0, recordBuf, 0,\n                                 assemLen);\n                System.arraycopy(wBuf, wOffset, recordBuf,\n                                 assemLen, aLen);\n                buffer.writeRecord(recordBuf);\n\n                currBytes += recordBuf.length;\n                wOffset += aLen;\n                numToWrite -= aLen;\n                assemLen = 0;\n            } else {\n                System.arraycopy(wBuf, wOffset, assemBuf, assemLen,\n                                 numToWrite);\n\n                wOffset += numToWrite;\n                assemLen += numToWrite;\n                numToWrite = 0;\n            }\n        }\n\n        \n        \n        \n        \n        \n        while (numToWrite > 0) {\n            if (numToWrite < recordBuf.length) {\n                System.arraycopy(wBuf, wOffset, assemBuf, assemLen,\n                                 numToWrite);\n\n                assemLen += numToWrite;\n\n                break;\n            }\n\n            buffer.writeRecord(wBuf, wOffset);\n\n            int num = recordBuf.length;\n\n            currBytes += num;\n            numToWrite -= num;\n            wOffset += num;\n        }\n    }\n\n    \n    void writePaxHeaders(String entryName,\n                         Map<String, String> headers) throws IOException {\n        String name = \"./PaxHeaders.X/\" + stripTo7Bits(entryName);\n            \n            \n        if (name.length() >= TarConstants.NAMELEN) {\n            name = name.substring(0, TarConstants.NAMELEN - 1);\n        }\n        TarArchiveEntry pex = new TarArchiveEntry(name,\n                                                  TarConstants.LF_PAX_EXTENDED_HEADER_LC);\n\n        StringWriter w = new StringWriter();\n        for (Map.Entry<String, String> h : headers.entrySet()) {\n            String key = h.getKey();\n            String value = h.getValue();\n            int len = key.length() + value.length()\n                + 3 \n                + 2 ;\n            String line = len + \" \" + key + \"=\" + value + \"\\n\";\n            int actualLength = line.getBytes(CharsetNames.UTF_8).length;\n            while (len != actualLength) {\n                \n                \n                \n                \n                \n                len = actualLength;\n                line = len + \" \" + key + \"=\" + value + \"\\n\";\n                actualLength = line.getBytes(CharsetNames.UTF_8).length;\n            }\n            w.write(line);\n        }\n        byte[] data = w.toString().getBytes(CharsetNames.UTF_8);\n        pex.setSize(data.length);\n        putArchiveEntry(pex);\n        write(data);\n        closeArchiveEntry();\n    }\n\n    private String stripTo7Bits(String name) {\n        final int length = name.length();\n        StringBuffer result = new StringBuffer(length);\n        for (int i = 0; i < length; i++) {\n            char stripped = (char) (name.charAt(i) & 0x7F);\n            if (stripped != 0) { \n                result.append(stripped);\n            }\n        }\n        return result.toString();\n    }\n\n    \n    private void writeEOFRecord() throws IOException {\n        for (int i = 0; i < recordBuf.length; ++i) {\n            recordBuf[i] = 0;\n        }\n\n        buffer.writeRecord(recordBuf);\n    }\n\n    @Override\n    public void flush() throws IOException {\n        out.flush();\n    }\n\n    \n    @Override\n    public ArchiveEntry createArchiveEntry(File inputFile, String entryName) throws IOException {\n        if(finished) {\n            throw new IOException(\"Stream has already been finished\");\n        }\n        return new TarArchiveEntry(inputFile, entryName);\n    }\n\n    private void addPaxHeadersForBigNumbers(Map<String, String> paxHeaders, TarArchiveEntry entry) {\n        addPaxHeaderForBigNumber(paxHeaders, \"size\", entry.getSize(),\n                                 TarConstants.MAXSIZE);\n        addPaxHeaderForBigNumber(paxHeaders, \"gid\", entry.getGroupId(),\n                                 TarConstants.MAXID);\n        addPaxHeaderForBigNumber(paxHeaders, \"mtime\",\n                                 entry.getModTime().getTime() / 1000,\n                                 TarConstants.MAXSIZE);\n        addPaxHeaderForBigNumber(paxHeaders, \"uid\", entry.getUserId(),\n                                 TarConstants.MAXID);\n        \n        addPaxHeaderForBigNumber(paxHeaders, \"SCHILY.devmajor\",\n                                 entry.getDevMajor(), TarConstants.MAXID);\n        addPaxHeaderForBigNumber(paxHeaders, \"SCHILY.devminor\",\n                                 entry.getDevMinor(), TarConstants.MAXID);\n        \n        failForBigNumber(\"mode\", entry.getMode(), TarConstants.MAXID);\n    }\n\n    private void addPaxHeaderForBigNumber(Map<String, String> paxHeaders, String header, long value, long maxValue) {\n        if (value < 0 || value > maxValue) {\n            paxHeaders.put(header, String.valueOf(value));\n        }\n    }\n\n    private void failForBigNumbers(TarArchiveEntry entry) {\n        failForBigNumber(\"entry size\", entry.getSize(), TarConstants.MAXSIZE);\n        failForBigNumber(\"group id\", entry.getGroupId(), TarConstants.MAXID);\n        failForBigNumber(\"last modification time\",\n                         entry.getModTime().getTime() / 1000,\n                         TarConstants.MAXSIZE);\n        failForBigNumber(\"user id\", entry.getUserId(), TarConstants.MAXID);\n        failForBigNumber(\"mode\", entry.getMode(), TarConstants.MAXID);\n        failForBigNumber(\"major device number\", entry.getDevMajor(),\n                         TarConstants.MAXID);\n        failForBigNumber(\"minor device number\", entry.getDevMinor(),\n                         TarConstants.MAXID);\n    }\n\n    private void failForBigNumber(String field, long value, long maxValue) {\n        if (value < 0 || value > maxValue) {\n            throw new RuntimeException(field + \" '\" + value\n                                       + \"' is too big ( > \"\n                                       + maxValue + \" )\");\n        }\n    }\n}\n",
      "fixed_full_code": "\npackage org.apache.commons.compress.archivers.tar;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.StringWriter;\nimport java.nio.ByteBuffer;\nimport java.util.HashMap;\nimport java.util.Map;\nimport org.apache.commons.compress.archivers.ArchiveEntry;\nimport org.apache.commons.compress.archivers.ArchiveOutputStream;\nimport org.apache.commons.compress.archivers.zip.ZipEncoding;\nimport org.apache.commons.compress.archivers.zip.ZipEncodingHelper;\nimport org.apache.commons.compress.utils.CharsetNames;\nimport org.apache.commons.compress.utils.CountingOutputStream;\n\n\npublic class TarArchiveOutputStream extends ArchiveOutputStream { public static final int LONGFILE_ERROR = 0; public static final int LONGFILE_TRUNCATE = 1; public static final int LONGFILE_GNU = 2; public static final int LONGFILE_POSIX = 3; public static final int BIGNUMBER_ERROR = 0; public static final int BIGNUMBER_STAR = 1; public static final int BIGNUMBER_POSIX = 2; private long currSize; private String currName; private long currBytes; private final byte[] recordBuf; private int assemLen; private final byte[] assemBuf; protected final TarBuffer buffer; private int longFileMode = LONGFILE_ERROR; private int bigNumberMode = BIGNUMBER_ERROR; private boolean closed = false; private boolean haveUnclosedEntry = false; private boolean finished = false; private final OutputStream out; private final ZipEncoding encoding; private boolean addPaxHeadersForNonAsciiNames = false; private static final ZipEncoding ASCII = ZipEncodingHelper.getZipEncoding(\"ASCII\"); public TarArchiveOutputStream(OutputStream os) {\n        this(os, TarBuffer.DEFAULT_BLKSIZE, TarBuffer.DEFAULT_RCDSIZE);\n    }\n\n    \n    public TarArchiveOutputStream(OutputStream os, String encoding) {\n        this(os, TarBuffer.DEFAULT_BLKSIZE, TarBuffer.DEFAULT_RCDSIZE, encoding);\n    }\n\n    \n    public TarArchiveOutputStream(OutputStream os, int blockSize) {\n        this(os, blockSize, TarBuffer.DEFAULT_RCDSIZE);\n    }\n\n    \n    public TarArchiveOutputStream(OutputStream os, int blockSize, String encoding) {\n        this(os, blockSize, TarBuffer.DEFAULT_RCDSIZE, encoding);\n    }\n\n    \n    public TarArchiveOutputStream(OutputStream os, int blockSize, int recordSize) {\n        this(os, blockSize, recordSize, null);\n    }\n\n    \n    public TarArchiveOutputStream(OutputStream os, int blockSize, int recordSize, String encoding) {\n        out = new CountingOutputStream(os);\n        this.encoding = ZipEncodingHelper.getZipEncoding(encoding);\n\n        this.buffer = new TarBuffer(out, blockSize, recordSize);\n        this.assemLen = 0;\n        this.assemBuf = new byte[recordSize];\n        this.recordBuf = new byte[recordSize];\n    }\n\n    \n    public void setLongFileMode(int longFileMode) {\n        this.longFileMode = longFileMode;\n    }\n\n    \n    public void setBigNumberMode(int bigNumberMode) {\n        this.bigNumberMode = bigNumberMode;\n    }\n\n    \n    public void setAddPaxHeadersForNonAsciiNames(boolean b) {\n        addPaxHeadersForNonAsciiNames = b;\n    }\n\n    @Deprecated\n    @Override\n    public int getCount() {\n        return (int) getBytesWritten();\n    }\n\n    @Override\n    public long getBytesWritten() {\n        return ((CountingOutputStream) out).getBytesWritten();\n    }\n\n    \n    @Override\n    public void finish() throws IOException {\n        if (finished) {\n            throw new IOException(\"This archive has already been finished\");\n        }\n\n        if (haveUnclosedEntry) {\n            throw new IOException(\"This archives contains unclosed entries.\");\n        }\n        writeEOFRecord();\n        writeEOFRecord();\n        buffer.flushBlock();\n        finished = true;\n    }\n\n    \n    @Override\n    public void close() throws IOException {\n        if(!finished) {\n            finish();\n        }\n\n        if (!closed) {\n            buffer.close();\n            out.close();\n            closed = true;\n        }\n    }\n\n    \n    public int getRecordSize() {\n        return buffer.getRecordSize();\n    }\n\n    \n    @Override\n    public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException {\n        if(finished) {\n            throw new IOException(\"Stream has already been finished\");\n        }\n        TarArchiveEntry entry = (TarArchiveEntry) archiveEntry;\n        Map<String, String> paxHeaders = new HashMap<String, String>();\n        final String entryName = entry.getName();\n        final ByteBuffer encodedName = encoding.encode(entryName);\n        final int nameLen = encodedName.limit() - encodedName.position();\n        boolean paxHeaderContainsPath = false;\n        if (nameLen >= TarConstants.NAMELEN) {\n\n            if (longFileMode == LONGFILE_POSIX) {\n                paxHeaders.put(\"path\", entryName);\n                paxHeaderContainsPath = true;\n            } else if (longFileMode == LONGFILE_GNU) {\n                \n                \n                TarArchiveEntry longLinkEntry = new TarArchiveEntry(TarConstants.GNU_LONGLINK,\n                                                                    TarConstants.LF_GNUTYPE_LONGNAME);\n\n                longLinkEntry.setSize(nameLen + 1); \n                putArchiveEntry(longLinkEntry);\n                write(encodedName.array(), encodedName.arrayOffset(), nameLen);\n                write(0); \n                closeArchiveEntry();\n            } else if (longFileMode != LONGFILE_TRUNCATE) {\n                throw new RuntimeException(\"file name '\" + entryName\n                                           + \"' is too long ( > \"\n                                           + TarConstants.NAMELEN + \" bytes)\");\n            }\n        }\n\n        if (bigNumberMode == BIGNUMBER_POSIX) {\n            addPaxHeadersForBigNumbers(paxHeaders, entry);\n        } else if (bigNumberMode != BIGNUMBER_STAR) {\n            failForBigNumbers(entry);\n        }\n\n        if (addPaxHeadersForNonAsciiNames && !paxHeaderContainsPath\n            && !ASCII.canEncode(entryName)) {\n            paxHeaders.put(\"path\", entryName);\n        }\n\n        if (addPaxHeadersForNonAsciiNames\n            && (entry.isLink() || entry.isSymbolicLink())\n            && !ASCII.canEncode(entry.getLinkName())) {\n            paxHeaders.put(\"linkpath\", entry.getLinkName());\n        }\n\n        if (paxHeaders.size() > 0) {\n            writePaxHeaders(entryName, paxHeaders);\n        }\n\n        entry.writeEntryHeader(recordBuf, encoding,\n                               bigNumberMode == BIGNUMBER_STAR);\n        buffer.writeRecord(recordBuf);\n\n        currBytes = 0;\n\n        if (entry.isDirectory()) {\n            currSize = 0;\n        } else {\n            currSize = entry.getSize();\n        }\n        currName = entryName;\n        haveUnclosedEntry = true;\n    }\n\n    \n    @Override\n    public void closeArchiveEntry() throws IOException {\n        if (finished) {\n            throw new IOException(\"Stream has already been finished\");\n        }\n        if (!haveUnclosedEntry){\n            throw new IOException(\"No current entry to close\");\n        }\n        if (assemLen > 0) {\n            for (int i = assemLen; i < assemBuf.length; ++i) {\n                assemBuf[i] = 0;\n            }\n\n            buffer.writeRecord(assemBuf);\n\n            currBytes += assemLen;\n            assemLen = 0;\n        }\n\n        if (currBytes < currSize) {\n            throw new IOException(\"entry '\" + currName + \"' closed at '\"\n                                  + currBytes\n                                  + \"' before the '\" + currSize\n                                  + \"' bytes specified in the header were written\");\n        }\n        haveUnclosedEntry = false;\n    }\n\n    \n    @Override\n    public void write(byte[] wBuf, int wOffset, int numToWrite) throws IOException {\n        if ((currBytes + numToWrite) > currSize) {\n            throw new IOException(\"request to write '\" + numToWrite\n                                  + \"' bytes exceeds size in header of '\"\n                                  + currSize + \"' bytes for entry '\"\n                                  + currName + \"'\");\n\n            \n            \n            \n            \n            \n            \n            \n        }\n\n        if (assemLen > 0) {\n            if ((assemLen + numToWrite) >= recordBuf.length) {\n                int aLen = recordBuf.length - assemLen;\n\n                System.arraycopy(assemBuf, 0, recordBuf, 0,\n                                 assemLen);\n                System.arraycopy(wBuf, wOffset, recordBuf,\n                                 assemLen, aLen);\n                buffer.writeRecord(recordBuf);\n\n                currBytes += recordBuf.length;\n                wOffset += aLen;\n                numToWrite -= aLen;\n                assemLen = 0;\n            } else {\n                System.arraycopy(wBuf, wOffset, assemBuf, assemLen,\n                                 numToWrite);\n\n                wOffset += numToWrite;\n                assemLen += numToWrite;\n                numToWrite = 0;\n            }\n        }\n\n        \n        \n        \n        \n        \n        while (numToWrite > 0) {\n            if (numToWrite < recordBuf.length) {\n                System.arraycopy(wBuf, wOffset, assemBuf, assemLen,\n                                 numToWrite);\n\n                assemLen += numToWrite;\n\n                break;\n            }\n\n            buffer.writeRecord(wBuf, wOffset);\n\n            int num = recordBuf.length;\n\n            currBytes += num;\n            numToWrite -= num;\n            wOffset += num;\n        }\n    }\n\n    \n    void writePaxHeaders(String entryName,\n                         Map<String, String> headers) throws IOException {\n        String name = \"./PaxHeaders.X/\" + stripTo7Bits(entryName);\n        while (name.endsWith(\"/\")) {\n            \n            \n            name = name.substring(0, name.length() - 1);\n        }\n        if (name.length() >= TarConstants.NAMELEN) {\n            name = name.substring(0, TarConstants.NAMELEN - 1);\n        }\n        TarArchiveEntry pex = new TarArchiveEntry(name,\n                                                  TarConstants.LF_PAX_EXTENDED_HEADER_LC);\n\n        StringWriter w = new StringWriter();\n        for (Map.Entry<String, String> h : headers.entrySet()) {\n            String key = h.getKey();\n            String value = h.getValue();\n            int len = key.length() + value.length()\n                + 3 \n                + 2 ;\n            String line = len + \" \" + key + \"=\" + value + \"\\n\";\n            int actualLength = line.getBytes(CharsetNames.UTF_8).length;\n            while (len != actualLength) {\n                \n                \n                \n                \n                \n                len = actualLength;\n                line = len + \" \" + key + \"=\" + value + \"\\n\";\n                actualLength = line.getBytes(CharsetNames.UTF_8).length;\n            }\n            w.write(line);\n        }\n        byte[] data = w.toString().getBytes(CharsetNames.UTF_8);\n        pex.setSize(data.length);\n        putArchiveEntry(pex);\n        write(data);\n        closeArchiveEntry();\n    }\n\n    private String stripTo7Bits(String name) {\n        final int length = name.length();\n        StringBuffer result = new StringBuffer(length);\n        for (int i = 0; i < length; i++) {\n            char stripped = (char) (name.charAt(i) & 0x7F);\n            if (stripped != 0) { \n                result.append(stripped);\n            }\n        }\n        return result.toString();\n    }\n\n    \n    private void writeEOFRecord() throws IOException {\n        for (int i = 0; i < recordBuf.length; ++i) {\n            recordBuf[i] = 0;\n        }\n\n        buffer.writeRecord(recordBuf);\n    }\n\n    @Override\n    public void flush() throws IOException {\n        out.flush();\n    }\n\n    \n    @Override\n    public ArchiveEntry createArchiveEntry(File inputFile, String entryName) throws IOException {\n        if(finished) {\n            throw new IOException(\"Stream has already been finished\");\n        }\n        return new TarArchiveEntry(inputFile, entryName);\n    }\n\n    private void addPaxHeadersForBigNumbers(Map<String, String> paxHeaders, TarArchiveEntry entry) {\n        addPaxHeaderForBigNumber(paxHeaders, \"size\", entry.getSize(),\n                                 TarConstants.MAXSIZE);\n        addPaxHeaderForBigNumber(paxHeaders, \"gid\", entry.getGroupId(),\n                                 TarConstants.MAXID);\n        addPaxHeaderForBigNumber(paxHeaders, \"mtime\",\n                                 entry.getModTime().getTime() / 1000,\n                                 TarConstants.MAXSIZE);\n        addPaxHeaderForBigNumber(paxHeaders, \"uid\", entry.getUserId(),\n                                 TarConstants.MAXID);\n        \n        addPaxHeaderForBigNumber(paxHeaders, \"SCHILY.devmajor\",\n                                 entry.getDevMajor(), TarConstants.MAXID);\n        addPaxHeaderForBigNumber(paxHeaders, \"SCHILY.devminor\",\n                                 entry.getDevMinor(), TarConstants.MAXID);\n        \n        failForBigNumber(\"mode\", entry.getMode(), TarConstants.MAXID);\n    }\n\n    private void addPaxHeaderForBigNumber(Map<String, String> paxHeaders, String header, long value, long maxValue) {\n        if (value < 0 || value > maxValue) {\n            paxHeaders.put(header, String.valueOf(value));\n        }\n    }\n\n    private void failForBigNumbers(TarArchiveEntry entry) {\n        failForBigNumber(\"entry size\", entry.getSize(), TarConstants.MAXSIZE);\n        failForBigNumber(\"group id\", entry.getGroupId(), TarConstants.MAXID);\n        failForBigNumber(\"last modification time\",\n                         entry.getModTime().getTime() / 1000,\n                         TarConstants.MAXSIZE);\n        failForBigNumber(\"user id\", entry.getUserId(), TarConstants.MAXID);\n        failForBigNumber(\"mode\", entry.getMode(), TarConstants.MAXID);\n        failForBigNumber(\"major device number\", entry.getDevMajor(),\n                         TarConstants.MAXID);\n        failForBigNumber(\"minor device number\", entry.getDevMinor(),\n                         TarConstants.MAXID);\n    }\n\n    private void failForBigNumber(String field, long value, long maxValue) {\n        if (value < 0 || value > maxValue) {\n            throw new RuntimeException(field + \" '\" + value\n                                       + \"' is too big ( > \"\n                                       + maxValue + \" )\");\n        }\n    }\n}\n",
      "buggy_signatures": [
        "public TarArchiveOutputStream(OutputStream os, String encoding)",
        "public TarArchiveOutputStream(OutputStream os, int blockSize)",
        "public TarArchiveOutputStream(OutputStream os, int blockSize, String encoding)",
        "public TarArchiveOutputStream(OutputStream os, int blockSize, int recordSize)",
        "public TarArchiveOutputStream(OutputStream os, int blockSize, int recordSize, String encoding)",
        "public void setLongFileMode(int longFileMode)",
        "public void setBigNumberMode(int bigNumberMode)",
        "public void setAddPaxHeadersForNonAsciiNames(boolean b)",
        "public int getCount()",
        "public long getBytesWritten()",
        "public void finish() throws IOException",
        "public void close() throws IOException",
        "public int getRecordSize()",
        "public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException",
        "public void closeArchiveEntry() throws IOException",
        "public void write(byte[] wBuf, int wOffset, int numToWrite) throws IOException",
        "private String stripTo7Bits(String name)",
        "private void writeEOFRecord() throws IOException",
        "public void flush() throws IOException",
        "public ArchiveEntry createArchiveEntry(File inputFile, String entryName) throws IOException",
        "private void addPaxHeadersForBigNumbers(Map<String, String> paxHeaders, TarArchiveEntry entry)",
        "private void addPaxHeaderForBigNumber(Map<String, String> paxHeaders, String header, long value, long maxValue)",
        "private void failForBigNumbers(TarArchiveEntry entry)",
        "private void failForBigNumber(String field, long value, long maxValue)"
      ],
      "fixed_signatures": [
        "public TarArchiveOutputStream(OutputStream os, String encoding)",
        "public TarArchiveOutputStream(OutputStream os, int blockSize)",
        "public TarArchiveOutputStream(OutputStream os, int blockSize, String encoding)",
        "public TarArchiveOutputStream(OutputStream os, int blockSize, int recordSize)",
        "public TarArchiveOutputStream(OutputStream os, int blockSize, int recordSize, String encoding)",
        "public void setLongFileMode(int longFileMode)",
        "public void setBigNumberMode(int bigNumberMode)",
        "public void setAddPaxHeadersForNonAsciiNames(boolean b)",
        "public int getCount()",
        "public long getBytesWritten()",
        "public void finish() throws IOException",
        "public void close() throws IOException",
        "public int getRecordSize()",
        "public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException",
        "public void closeArchiveEntry() throws IOException",
        "public void write(byte[] wBuf, int wOffset, int numToWrite) throws IOException",
        "private String stripTo7Bits(String name)",
        "private void writeEOFRecord() throws IOException",
        "public void flush() throws IOException",
        "public ArchiveEntry createArchiveEntry(File inputFile, String entryName) throws IOException",
        "private void addPaxHeadersForBigNumbers(Map<String, String> paxHeaders, TarArchiveEntry entry)",
        "private void addPaxHeaderForBigNumber(Map<String, String> paxHeaders, String header, long value, long maxValue)",
        "private void failForBigNumbers(TarArchiveEntry entry)",
        "private void failForBigNumber(String field, long value, long maxValue)"
      ],
      "methods": [
        {
          "buggy_method": "  public void write(byte[] wBuf, int wOffset, int numToWrite) throws IOException {\n  if ((currBytes + numToWrite) > currSize) {\n  throw new IOException(\"request to write '\" + numToWrite\n  + \"' bytes exceeds size in header of '\"\n  + currSize + \"' bytes for entry '\"\n  + currName + \"'\");\n\n  \n  \n  \n  \n  \n  \n  \n  }\n\n  if (assemLen > 0) {\n  if ((assemLen + numToWrite) >= recordBuf.length) {\n  int aLen = recordBuf.length - assemLen;\n\n  System.arraycopy(assemBuf, 0, recordBuf, 0,\n  assemLen);\n  System.arraycopy(wBuf, wOffset, recordBuf,\n  assemLen, aLen);\n  buffer.writeRecord(recordBuf);\n\n  currBytes += recordBuf.length;\n  wOffset += aLen;\n  numToWrite -= aLen;\n  assemLen = 0;\n  } else {\n  System.arraycopy(wBuf, wOffset, assemBuf, assemLen,\n  numToWrite);\n\n  wOffset += numToWrite;\n  assemLen += numToWrite;\n  numToWrite = 0;\n  }\n  }\n\n  \n  \n  \n  \n  \n  while (numToWrite > 0) {\n  if (numToWrite < recordBuf.length) {\n  System.arraycopy(wBuf, wOffset, assemBuf, assemLen,\n  numToWrite);\n\n  assemLen += numToWrite;\n\n  break;\n  }\n\n  buffer.writeRecord(wBuf, wOffset);\n\n  int num = recordBuf.length;\n\n  currBytes += num;\n  numToWrite -= num;\n  wOffset += num;\n  }\n  }",
          "fixed_method": "  public void write(byte[] wBuf, int wOffset, int numToWrite) throws IOException {\n  if ((currBytes + numToWrite) > currSize) {\n  throw new IOException(\"request to write '\" + numToWrite\n  + \"' bytes exceeds size in header of '\"\n  + currSize + \"' bytes for entry '\"\n  + currName + \"'\");\n\n  \n  \n  \n  \n  \n  \n  \n  }\n\n  if (assemLen > 0) {\n  if ((assemLen + numToWrite) >= recordBuf.length) {\n  int aLen = recordBuf.length - assemLen;\n\n  System.arraycopy(assemBuf, 0, recordBuf, 0,\n  assemLen);\n  System.arraycopy(wBuf, wOffset, recordBuf,\n  assemLen, aLen);\n  buffer.writeRecord(recordBuf);\n\n  currBytes += recordBuf.length;\n  wOffset += aLen;\n  numToWrite -= aLen;\n  assemLen = 0;\n  } else {\n  System.arraycopy(wBuf, wOffset, assemBuf, assemLen,\n  numToWrite);\n\n  wOffset += numToWrite;\n  assemLen += numToWrite;\n  numToWrite = 0;\n  }\n  }\n\n  \n  \n  \n  \n  \n  while (numToWrite > 0) {\n  if (numToWrite < recordBuf.length) {\n  System.arraycopy(wBuf, wOffset, assemBuf, assemLen,\n  numToWrite);\n\n  assemLen += numToWrite;\n\n  break;\n  }\n\n  buffer.writeRecord(wBuf, wOffset);\n\n  int num = recordBuf.length;\n\n  currBytes += num;\n  numToWrite -= num;\n  wOffset += num;\n  }\n  }",
          "diff": [
            "@@ -454,8 +454,11 @@",
            "     void writePaxHeaders(String entryName,\n",
            "                          Map<String, String> headers) throws IOException {\n",
            "         String name = \"./PaxHeaders.X/\" + stripTo7Bits(entryName);\n",
            "+        while (name.endsWith(\"/\")) {\n",
            "             // TarEntry's constructor would think this is a directory\n",
            "             // and not allow any data to be written\n",
            "+            name = name.substring(0, name.length() - 1);\n",
            "+        }\n",
            "         if (name.length() >= TarConstants.NAMELEN) {\n",
            "             name = name.substring(0, TarConstants.NAMELEN - 1);\n",
            "         }\n"
          ],
          "changed_lines": 3
        }
      ]
    }
  ]
}
