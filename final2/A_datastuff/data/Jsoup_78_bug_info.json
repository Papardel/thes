{
  "bug_id": "78",
  "failed_tests": {
    "org.jsoup.integration.ConnectTest": [
      {
        "methodName": "handlesEmptyStreamDuringParseRead",
        "error": "org.jsoup.UncheckedIOException",
        "message": "java.io.IOException: Underlying input stream returned zero bytes",
        "fail_line": "            Document document = res.parse();",
        "test_source": "  public void handlesEmptyStreamDuringParseRead() throws IOException {\n  // this handles situations where the remote server sets a content length greater than it actually writes\n\n  Connection.Response res = Jsoup.connect(InterruptedServlet.Url)\n  .timeout(200)\n  .execute();\n\n  boolean threw = false;\n  try {\n  Document document = res.parse();\n  assertEquals(\"Something\", document.title());\n  } catch (IOException e) {\n  threw = true;\n  }\n  assertEquals(true, threw);\n  }",
        "stack": [
          "CharacterReader.bufferUp line 63, CharacterReader.current line 93, TokeniserState$1.read line 12, Tokeniser.read line 45, TreeBuilder.runParser line 51, TreeBuilder.parse line 45, Parser.parseInput line 39, DataUtil.parseInputStream line 151, HttpConnection$Response.parse line 837, ConnectTest.handlesEmptyStreamDuringParseRead line 400, CharacterReader.bufferUp line 53"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/jsoup/helper/DataUtil.java",
      "buggy_full_code": "package org.jsoup.helper;\n\nimport org.jsoup.internal.ConstrainableInputStream;\nimport org.jsoup.nodes.Document;\nimport org.jsoup.nodes.Element;\nimport org.jsoup.nodes.XmlDeclaration;\nimport org.jsoup.parser.Parser;\nimport org.jsoup.select.Elements;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.RandomAccessFile;\nimport java.nio.Buffer;\nimport java.nio.ByteBuffer;\nimport java.nio.charset.Charset;\nimport java.nio.charset.IllegalCharsetNameException;\nimport java.util.Locale;\nimport java.util.Random;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n\npublic final class DataUtil { private static final Pattern charsetPattern = Pattern.compile(\"(?i)\\\\bcharset=\\\\s*(?:[\\\"'])?([^\\\\s,;\\\"']*)\"); static final String defaultCharset = \"UTF-8\"; private static final int firstReadBufferSize = 1024 * 5; static final int bufferSize = 1024 * 32; private static final char[] mimeBoundaryChars = \"-_1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\".toCharArray(); static final int boundaryLength = 32; private DataUtil() {}\n\n    \n    public static Document load(File in, String charsetName, String baseUri) throws IOException {\n        return parseInputStream(new FileInputStream(in), charsetName, baseUri, Parser.htmlParser());\n    }\n\n    \n    public static Document load(InputStream in, String charsetName, String baseUri) throws IOException {\n        return parseInputStream(in, charsetName, baseUri, Parser.htmlParser());\n    }\n\n    \n    public static Document load(InputStream in, String charsetName, String baseUri, Parser parser) throws IOException {\n        return parseInputStream(in, charsetName, baseUri, parser);\n    }\n\n    \n    static void crossStreams(final InputStream in, final OutputStream out) throws IOException {\n        final byte[] buffer = new byte[bufferSize];\n        int len;\n        while ((len = in.read(buffer)) != -1) {\n            out.write(buffer, 0, len);\n        }\n    }\n\n    static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n        if (input == null) \n            return new Document(baseUri);\n        input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n\n        Document doc = null;\n        boolean fullyRead = false;\n\n        \n        input.mark(bufferSize);\n        ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1); \n        fullyRead = input.read() == -1;\n        input.reset();\n\n        \n        BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n        if (bomCharset != null) {\n            charsetName = bomCharset.charset;\n            input.skip(bomCharset.offset);\n        }\n\n        if (charsetName == null) { \n            String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n            doc = parser.parseInput(docData, baseUri);\n\n            \n            Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n            String foundCharset = null; \n            for (Element meta : metaElements) {\n                if (meta.hasAttr(\"http-equiv\"))\n                    foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n                if (foundCharset == null && meta.hasAttr(\"charset\"))\n                    foundCharset = meta.attr(\"charset\");\n                if (foundCharset != null)\n                    break;\n            }\n\n            \n            if (foundCharset == null && doc.childNodeSize() > 0 && doc.childNode(0) instanceof XmlDeclaration) {\n                XmlDeclaration prolog = (XmlDeclaration) doc.childNode(0);\n                if (prolog.name().equals(\"xml\"))\n                    foundCharset = prolog.attr(\"encoding\");\n            }\n            foundCharset = validateCharset(foundCharset);\n            if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) { \n                foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                charsetName = foundCharset;\n                doc = null;\n            } else if (!fullyRead) {\n                doc = null;\n            }\n        } else { \n            Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        }\n        if (doc == null) {\n            if (charsetName == null)\n                charsetName = defaultCharset;\n            BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n                doc = parser.parseInput(reader, baseUri);\n                \n            doc.outputSettings().charset(charsetName);\n        }\n        input.close();\n        return doc;\n    }\n\n    \n    public static ByteBuffer readToByteBuffer(InputStream inStream, int maxSize) throws IOException {\n        Validate.isTrue(maxSize >= 0, \"maxSize must be 0 (unlimited) or larger\");\n        final ConstrainableInputStream input = ConstrainableInputStream.wrap(inStream, bufferSize, maxSize);\n        return input.readToByteBuffer(maxSize);\n    }\n\n    static ByteBuffer readToByteBuffer(InputStream inStream) throws IOException {\n        return readToByteBuffer(inStream, 0);\n    }\n\n    static ByteBuffer readFileToByteBuffer(File file) throws IOException {\n        RandomAccessFile randomAccessFile = null;\n        try {\n            randomAccessFile = new RandomAccessFile(file, \"r\");\n            byte[] bytes = new byte[(int) randomAccessFile.length()];\n            randomAccessFile.readFully(bytes);\n            return ByteBuffer.wrap(bytes);\n        } finally {\n            if (randomAccessFile != null)\n                randomAccessFile.close();\n        }\n    }\n\n    static ByteBuffer emptyByteBuffer() {\n        return ByteBuffer.allocate(0);\n    }\n\n    \n    static String getCharsetFromContentType(String contentType) {\n        if (contentType == null) return null;\n        Matcher m = charsetPattern.matcher(contentType);\n        if (m.find()) {\n            String charset = m.group(1).trim();\n            charset = charset.replace(\"charset=\", \"\");\n            return validateCharset(charset);\n        }\n        return null;\n    }\n\n    private static String validateCharset(String cs) {\n        if (cs == null || cs.length() == 0) return null;\n        cs = cs.trim().replaceAll(\"[\\\"']\", \"\");\n        try {\n            if (Charset.isSupported(cs)) return cs;\n            cs = cs.toUpperCase(Locale.ENGLISH);\n            if (Charset.isSupported(cs)) return cs;\n        } catch (IllegalCharsetNameException e) {\n            \n        }\n        return null;\n    }\n\n    \n    static String mimeBoundary() {\n        final StringBuilder mime = new StringBuilder(boundaryLength);\n        final Random rand = new Random();\n        for (int i = 0; i < boundaryLength; i++) {\n            mime.append(mimeBoundaryChars[rand.nextInt(mimeBoundaryChars.length)]);\n        }\n        return mime.toString();\n    }\n\n    private static BomCharset detectCharsetFromBom(final ByteBuffer byteData) {\n        final Buffer buffer = byteData; \n        buffer.mark();\n        byte[] bom = new byte[4];\n        if (byteData.remaining() >= bom.length) {\n            byteData.get(bom);\n            buffer.rewind();\n        }\n        if (bom[0] == 0x00 && bom[1] == 0x00 && bom[2] == (byte) 0xFE && bom[3] == (byte) 0xFF || \n            bom[0] == (byte) 0xFF && bom[1] == (byte) 0xFE && bom[2] == 0x00 && bom[3] == 0x00) { \n            return new BomCharset(\"UTF-32\", 0); \n        } else if (bom[0] == (byte) 0xFE && bom[1] == (byte) 0xFF || \n            bom[0] == (byte) 0xFF && bom[1] == (byte) 0xFE) {\n            return new BomCharset(\"UTF-16\", 0); \n        } else if (bom[0] == (byte) 0xEF && bom[1] == (byte) 0xBB && bom[2] == (byte) 0xBF) {\n            return new BomCharset(\"UTF-8\", 3); \n            \n        }\n        return null;\n    }\n\n    private static class BomCharset { private final String charset; private final int offset; public BomCharset(String charset, int offset) {\n            this.charset = charset;\n            this.offset = offset;\n        }\n    }\n}\n",
      "fixed_full_code": "package org.jsoup.helper;\n\nimport org.jsoup.UncheckedIOException;\nimport org.jsoup.internal.ConstrainableInputStream;\nimport org.jsoup.nodes.Document;\nimport org.jsoup.nodes.Element;\nimport org.jsoup.nodes.XmlDeclaration;\nimport org.jsoup.parser.Parser;\nimport org.jsoup.select.Elements;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.RandomAccessFile;\nimport java.nio.Buffer;\nimport java.nio.ByteBuffer;\nimport java.nio.charset.Charset;\nimport java.nio.charset.IllegalCharsetNameException;\nimport java.util.Locale;\nimport java.util.Random;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n\npublic final class DataUtil { private static final Pattern charsetPattern = Pattern.compile(\"(?i)\\\\bcharset=\\\\s*(?:[\\\"'])?([^\\\\s,;\\\"']*)\"); static final String defaultCharset = \"UTF-8\"; private static final int firstReadBufferSize = 1024 * 5; static final int bufferSize = 1024 * 32; private static final char[] mimeBoundaryChars = \"-_1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\".toCharArray(); static final int boundaryLength = 32; private DataUtil() {}\n\n    \n    public static Document load(File in, String charsetName, String baseUri) throws IOException {\n        return parseInputStream(new FileInputStream(in), charsetName, baseUri, Parser.htmlParser());\n    }\n\n    \n    public static Document load(InputStream in, String charsetName, String baseUri) throws IOException {\n        return parseInputStream(in, charsetName, baseUri, Parser.htmlParser());\n    }\n\n    \n    public static Document load(InputStream in, String charsetName, String baseUri, Parser parser) throws IOException {\n        return parseInputStream(in, charsetName, baseUri, parser);\n    }\n\n    \n    static void crossStreams(final InputStream in, final OutputStream out) throws IOException {\n        final byte[] buffer = new byte[bufferSize];\n        int len;\n        while ((len = in.read(buffer)) != -1) {\n            out.write(buffer, 0, len);\n        }\n    }\n\n    static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n        if (input == null) \n            return new Document(baseUri);\n        input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n\n        Document doc = null;\n        boolean fullyRead = false;\n\n        \n        input.mark(bufferSize);\n        ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1); \n        fullyRead = input.read() == -1;\n        input.reset();\n\n        \n        BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n        if (bomCharset != null) {\n            charsetName = bomCharset.charset;\n            input.skip(bomCharset.offset);\n        }\n\n        if (charsetName == null) { \n            String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n            doc = parser.parseInput(docData, baseUri);\n\n            \n            Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n            String foundCharset = null; \n            for (Element meta : metaElements) {\n                if (meta.hasAttr(\"http-equiv\"))\n                    foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n                if (foundCharset == null && meta.hasAttr(\"charset\"))\n                    foundCharset = meta.attr(\"charset\");\n                if (foundCharset != null)\n                    break;\n            }\n\n            \n            if (foundCharset == null && doc.childNodeSize() > 0 && doc.childNode(0) instanceof XmlDeclaration) {\n                XmlDeclaration prolog = (XmlDeclaration) doc.childNode(0);\n                if (prolog.name().equals(\"xml\"))\n                    foundCharset = prolog.attr(\"encoding\");\n            }\n            foundCharset = validateCharset(foundCharset);\n            if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) { \n                foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                charsetName = foundCharset;\n                doc = null;\n            } else if (!fullyRead) {\n                doc = null;\n            }\n        } else { \n            Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        }\n        if (doc == null) {\n            if (charsetName == null)\n                charsetName = defaultCharset;\n            BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n            try {\n                doc = parser.parseInput(reader, baseUri);\n            } catch (UncheckedIOException e) {\n                \n                throw e.ioException();\n            }\n            doc.outputSettings().charset(charsetName);\n        }\n        input.close();\n        return doc;\n    }\n\n    \n    public static ByteBuffer readToByteBuffer(InputStream inStream, int maxSize) throws IOException {\n        Validate.isTrue(maxSize >= 0, \"maxSize must be 0 (unlimited) or larger\");\n        final ConstrainableInputStream input = ConstrainableInputStream.wrap(inStream, bufferSize, maxSize);\n        return input.readToByteBuffer(maxSize);\n    }\n\n    static ByteBuffer readToByteBuffer(InputStream inStream) throws IOException {\n        return readToByteBuffer(inStream, 0);\n    }\n\n    static ByteBuffer readFileToByteBuffer(File file) throws IOException {\n        RandomAccessFile randomAccessFile = null;\n        try {\n            randomAccessFile = new RandomAccessFile(file, \"r\");\n            byte[] bytes = new byte[(int) randomAccessFile.length()];\n            randomAccessFile.readFully(bytes);\n            return ByteBuffer.wrap(bytes);\n        } finally {\n            if (randomAccessFile != null)\n                randomAccessFile.close();\n        }\n    }\n\n    static ByteBuffer emptyByteBuffer() {\n        return ByteBuffer.allocate(0);\n    }\n\n    \n    static String getCharsetFromContentType(String contentType) {\n        if (contentType == null) return null;\n        Matcher m = charsetPattern.matcher(contentType);\n        if (m.find()) {\n            String charset = m.group(1).trim();\n            charset = charset.replace(\"charset=\", \"\");\n            return validateCharset(charset);\n        }\n        return null;\n    }\n\n    private static String validateCharset(String cs) {\n        if (cs == null || cs.length() == 0) return null;\n        cs = cs.trim().replaceAll(\"[\\\"']\", \"\");\n        try {\n            if (Charset.isSupported(cs)) return cs;\n            cs = cs.toUpperCase(Locale.ENGLISH);\n            if (Charset.isSupported(cs)) return cs;\n        } catch (IllegalCharsetNameException e) {\n            \n        }\n        return null;\n    }\n\n    \n    static String mimeBoundary() {\n        final StringBuilder mime = new StringBuilder(boundaryLength);\n        final Random rand = new Random();\n        for (int i = 0; i < boundaryLength; i++) {\n            mime.append(mimeBoundaryChars[rand.nextInt(mimeBoundaryChars.length)]);\n        }\n        return mime.toString();\n    }\n\n    private static BomCharset detectCharsetFromBom(final ByteBuffer byteData) {\n        final Buffer buffer = byteData; \n        buffer.mark();\n        byte[] bom = new byte[4];\n        if (byteData.remaining() >= bom.length) {\n            byteData.get(bom);\n            buffer.rewind();\n        }\n        if (bom[0] == 0x00 && bom[1] == 0x00 && bom[2] == (byte) 0xFE && bom[3] == (byte) 0xFF || \n            bom[0] == (byte) 0xFF && bom[1] == (byte) 0xFE && bom[2] == 0x00 && bom[3] == 0x00) { \n            return new BomCharset(\"UTF-32\", 0); \n        } else if (bom[0] == (byte) 0xFE && bom[1] == (byte) 0xFF || \n            bom[0] == (byte) 0xFF && bom[1] == (byte) 0xFE) {\n            return new BomCharset(\"UTF-16\", 0); \n        } else if (bom[0] == (byte) 0xEF && bom[1] == (byte) 0xBB && bom[2] == (byte) 0xBF) {\n            return new BomCharset(\"UTF-8\", 3); \n            \n        }\n        return null;\n    }\n\n    private static class BomCharset { private final String charset; private final int offset; public BomCharset(String charset, int offset) {\n            this.charset = charset;\n            this.offset = offset;\n        }\n    }\n}\n",
      "buggy_signatures": [
        "public static Document load(File in, String charsetName, String baseUri) throws IOException",
        "public static Document load(InputStream in, String charsetName, String baseUri) throws IOException",
        "public static Document load(InputStream in, String charsetName, String baseUri, Parser parser) throws IOException",
        "static void crossStreams(final InputStream in, final OutputStream out) throws IOException",
        "static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException",
        "public static ByteBuffer readToByteBuffer(InputStream inStream, int maxSize) throws IOException",
        "static ByteBuffer readToByteBuffer(InputStream inStream) throws IOException",
        "static ByteBuffer readFileToByteBuffer(File file) throws IOException",
        "static ByteBuffer emptyByteBuffer()",
        "static String getCharsetFromContentType(String contentType)",
        "private static String validateCharset(String cs)",
        "static String mimeBoundary()",
        "private static BomCharset detectCharsetFromBom(final ByteBuffer byteData)",
        "private static class BomCharset { private final String charset; private final int offset; public BomCharset(String charset, int offset)"
      ],
      "fixed_signatures": [
        "public static Document load(File in, String charsetName, String baseUri) throws IOException",
        "public static Document load(InputStream in, String charsetName, String baseUri) throws IOException",
        "public static Document load(InputStream in, String charsetName, String baseUri, Parser parser) throws IOException",
        "static void crossStreams(final InputStream in, final OutputStream out) throws IOException",
        "static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException",
        "public static ByteBuffer readToByteBuffer(InputStream inStream, int maxSize) throws IOException",
        "static ByteBuffer readToByteBuffer(InputStream inStream) throws IOException",
        "static ByteBuffer readFileToByteBuffer(File file) throws IOException",
        "static ByteBuffer emptyByteBuffer()",
        "static String getCharsetFromContentType(String contentType)",
        "private static String validateCharset(String cs)",
        "static String mimeBoundary()",
        "private static BomCharset detectCharsetFromBom(final ByteBuffer byteData)",
        "private static class BomCharset { private final String charset; private final int offset; public BomCharset(String charset, int offset)"
      ],
      "methods": [
        {
          "buggy_method": "",
          "fixed_method": "",
          "diff": [
            "@@ -1,5 +1,6 @@",
            " package org.jsoup.helper;\n",
            " \n",
            "+import org.jsoup.UncheckedIOException;\n",
            " import org.jsoup.internal.ConstrainableInputStream;\n",
            " import org.jsoup.nodes.Document;\n",
            " import org.jsoup.nodes.Element;\n"
          ],
          "changed_lines": 1
        },
        {
          "buggy_method": "  static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n  if (input == null) \n  return new Document(baseUri);\n  input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n\n  Document doc = null;\n  boolean fullyRead = false;\n\n  \n  input.mark(bufferSize);\n  ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1); \n  fullyRead = input.read() == -1;\n  input.reset();\n\n  \n  BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n  if (bomCharset != null) {\n  charsetName = bomCharset.charset;\n  input.skip(bomCharset.offset);\n  }\n\n  if (charsetName == null) { \n  String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n  doc = parser.parseInput(docData, baseUri);\n\n  \n  Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n  String foundCharset = null; \n  for (Element meta : metaElements) {\n  if (meta.hasAttr(\"http-equiv\"))\n  foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n  if (foundCharset == null && meta.hasAttr(\"charset\"))\n  foundCharset = meta.attr(\"charset\");\n  if (foundCharset != null)\n  break;\n  }\n\n  \n  if (foundCharset == null && doc.childNodeSize() > 0 && doc.childNode(0) instanceof XmlDeclaration) {\n  XmlDeclaration prolog = (XmlDeclaration) doc.childNode(0);\n  if (prolog.name().equals(\"xml\"))\n  foundCharset = prolog.attr(\"encoding\");\n  }\n  foundCharset = validateCharset(foundCharset);\n  if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) { \n  foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n  charsetName = foundCharset;\n  doc = null;\n  } else if (!fullyRead) {\n  doc = null;\n  }\n  } else { \n  Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n  }\n  if (doc == null) {\n  if (charsetName == null)\n  charsetName = defaultCharset;\n  BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n  doc = parser.parseInput(reader, baseUri);\n  \n  doc.outputSettings().charset(charsetName);\n  }\n  input.close();\n  return doc;\n  }",
          "fixed_method": "  static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n  if (input == null) \n  return new Document(baseUri);\n  input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n\n  Document doc = null;\n  boolean fullyRead = false;\n\n  \n  input.mark(bufferSize);\n  ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1); \n  fullyRead = input.read() == -1;\n  input.reset();\n\n  \n  BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n  if (bomCharset != null) {\n  charsetName = bomCharset.charset;\n  input.skip(bomCharset.offset);\n  }\n\n  if (charsetName == null) { \n  String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n  doc = parser.parseInput(docData, baseUri);\n\n  \n  Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n  String foundCharset = null; \n  for (Element meta : metaElements) {\n  if (meta.hasAttr(\"http-equiv\"))\n  foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n  if (foundCharset == null && meta.hasAttr(\"charset\"))\n  foundCharset = meta.attr(\"charset\");\n  if (foundCharset != null)\n  break;\n  }\n\n  \n  if (foundCharset == null && doc.childNodeSize() > 0 && doc.childNode(0) instanceof XmlDeclaration) {\n  XmlDeclaration prolog = (XmlDeclaration) doc.childNode(0);\n  if (prolog.name().equals(\"xml\"))\n  foundCharset = prolog.attr(\"encoding\");\n  }\n  foundCharset = validateCharset(foundCharset);\n  if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) { \n  foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n  charsetName = foundCharset;\n  doc = null;\n  } else if (!fullyRead) {\n  doc = null;\n  }\n  } else { \n  Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n  }\n  if (doc == null) {\n  if (charsetName == null)\n  charsetName = defaultCharset;\n  BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n  try {\n  doc = parser.parseInput(reader, baseUri);\n  } catch (UncheckedIOException e) {\n  \n  throw e.ioException();\n  }\n  doc.outputSettings().charset(charsetName);\n  }\n  input.close();\n  return doc;\n  }",
          "diff": [
            "@@ -148,8 +149,12 @@",
            "             if (charsetName == null)\n",
            "                 charsetName = defaultCharset;\n",
            "             BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n",
            "+            try {\n",
            "                 doc = parser.parseInput(reader, baseUri);\n",
            "+            } catch (UncheckedIOException e) {\n",
            "                 // io exception when parsing (not seen before because reading the stream as we go)\n",
            "+                throw e.ioException();\n",
            "+            }\n",
            "             doc.outputSettings().charset(charsetName);\n",
            "         }\n",
            "         input.close();\n"
          ],
          "changed_lines": 4
        }
      ]
    }
  ]
}
