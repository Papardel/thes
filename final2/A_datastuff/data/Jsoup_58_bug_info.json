{
  "bug_id": "58",
  "failed_tests": {
    "org.jsoup.safety.CleanerTest": [
      {
        "methodName": "testIsValidBodyHtml",
        "error": "junit.framework.AssertionFailedError",
        "message": "",
        "fail_line": "        assertFalse(Jsoup.isValid(nok4, Whitelist.basic()));",
        "test_source": "",
        "stack": [
          "CleanerTest.testIsValidBodyHtml line 160"
        ]
      },
      {
        "methodName": "testIsValidDocument",
        "error": "junit.framework.AssertionFailedError",
        "message": "",
        "fail_line": "        assertFalse(cleaner.isValid(Jsoup.parse(nok)));",
        "test_source": "",
        "stack": [
          "CleanerTest.testIsValidDocument line 175"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/jsoup/Jsoup.java",
      "buggy_full_code": "package org.jsoup;\n\nimport org.jsoup.nodes.Document;\nimport org.jsoup.parser.Parser;\nimport org.jsoup.safety.Cleaner;\nimport org.jsoup.safety.Whitelist;\nimport org.jsoup.helper.DataUtil;\nimport org.jsoup.helper.HttpConnection;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.URL;\n\n\npublic class Jsoup { private Jsoup() {}\n\n    \n    public static Document parse(String html, String baseUri) {\n        return Parser.parse(html, baseUri);\n    }\n\n    \n    public static Document parse(String html, String baseUri, Parser parser) {\n        return parser.parseInput(html, baseUri);\n    }\n\n    \n    public static Document parse(String html) {\n        return Parser.parse(html, \"\");\n    }\n\n    \n    public static Connection connect(String url) {\n        return HttpConnection.connect(url);\n    }\n\n    \n    public static Document parse(File in, String charsetName, String baseUri) throws IOException {\n        return DataUtil.load(in, charsetName, baseUri);\n    }\n\n    \n    public static Document parse(File in, String charsetName) throws IOException {\n        return DataUtil.load(in, charsetName, in.getAbsolutePath());\n    }\n\n     \n    public static Document parse(InputStream in, String charsetName, String baseUri) throws IOException {\n        return DataUtil.load(in, charsetName, baseUri);\n    }\n\n    \n    public static Document parse(InputStream in, String charsetName, String baseUri, Parser parser) throws IOException {\n        return DataUtil.load(in, charsetName, baseUri, parser);\n    }\n\n    \n    public static Document parseBodyFragment(String bodyHtml, String baseUri) {\n        return Parser.parseBodyFragment(bodyHtml, baseUri);\n    }\n\n    \n    public static Document parseBodyFragment(String bodyHtml) {\n        return Parser.parseBodyFragment(bodyHtml, \"\");\n    }\n\n    \n    public static Document parse(URL url, int timeoutMillis) throws IOException {\n        Connection con = HttpConnection.connect(url);\n        con.timeout(timeoutMillis);\n        return con.get();\n    }\n\n    \n    public static String clean(String bodyHtml, String baseUri, Whitelist whitelist) {\n        Document dirty = parseBodyFragment(bodyHtml, baseUri);\n        Cleaner cleaner = new Cleaner(whitelist);\n        Document clean = cleaner.clean(dirty);\n        return clean.body().html();\n    }\n\n    \n    public static String clean(String bodyHtml, Whitelist whitelist) {\n        return clean(bodyHtml, \"\", whitelist);\n    }\n\n    \n    public static String clean(String bodyHtml, String baseUri, Whitelist whitelist, Document.OutputSettings outputSettings) {\n        Document dirty = parseBodyFragment(bodyHtml, baseUri);\n        Cleaner cleaner = new Cleaner(whitelist);\n        Document clean = cleaner.clean(dirty);\n        clean.outputSettings(outputSettings);\n        return clean.body().html();\n    }\n\n    \n    public static boolean isValid(String bodyHtml, Whitelist whitelist) {\n        return new Cleaner(whitelist).isValid(parseBodyFragment(bodyHtml, \"\"));\n    }\n    \n}\n",
      "fixed_full_code": "package org.jsoup;\n\nimport org.jsoup.nodes.Document;\nimport org.jsoup.parser.Parser;\nimport org.jsoup.safety.Cleaner;\nimport org.jsoup.safety.Whitelist;\nimport org.jsoup.helper.DataUtil;\nimport org.jsoup.helper.HttpConnection;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.URL;\n\n\npublic class Jsoup { private Jsoup() {}\n\n    \n    public static Document parse(String html, String baseUri) {\n        return Parser.parse(html, baseUri);\n    }\n\n    \n    public static Document parse(String html, String baseUri, Parser parser) {\n        return parser.parseInput(html, baseUri);\n    }\n\n    \n    public static Document parse(String html) {\n        return Parser.parse(html, \"\");\n    }\n\n    \n    public static Connection connect(String url) {\n        return HttpConnection.connect(url);\n    }\n\n    \n    public static Document parse(File in, String charsetName, String baseUri) throws IOException {\n        return DataUtil.load(in, charsetName, baseUri);\n    }\n\n    \n    public static Document parse(File in, String charsetName) throws IOException {\n        return DataUtil.load(in, charsetName, in.getAbsolutePath());\n    }\n\n     \n    public static Document parse(InputStream in, String charsetName, String baseUri) throws IOException {\n        return DataUtil.load(in, charsetName, baseUri);\n    }\n\n    \n    public static Document parse(InputStream in, String charsetName, String baseUri, Parser parser) throws IOException {\n        return DataUtil.load(in, charsetName, baseUri, parser);\n    }\n\n    \n    public static Document parseBodyFragment(String bodyHtml, String baseUri) {\n        return Parser.parseBodyFragment(bodyHtml, baseUri);\n    }\n\n    \n    public static Document parseBodyFragment(String bodyHtml) {\n        return Parser.parseBodyFragment(bodyHtml, \"\");\n    }\n\n    \n    public static Document parse(URL url, int timeoutMillis) throws IOException {\n        Connection con = HttpConnection.connect(url);\n        con.timeout(timeoutMillis);\n        return con.get();\n    }\n\n    \n    public static String clean(String bodyHtml, String baseUri, Whitelist whitelist) {\n        Document dirty = parseBodyFragment(bodyHtml, baseUri);\n        Cleaner cleaner = new Cleaner(whitelist);\n        Document clean = cleaner.clean(dirty);\n        return clean.body().html();\n    }\n\n    \n    public static String clean(String bodyHtml, Whitelist whitelist) {\n        return clean(bodyHtml, \"\", whitelist);\n    }\n\n    \n    public static String clean(String bodyHtml, String baseUri, Whitelist whitelist, Document.OutputSettings outputSettings) {\n        Document dirty = parseBodyFragment(bodyHtml, baseUri);\n        Cleaner cleaner = new Cleaner(whitelist);\n        Document clean = cleaner.clean(dirty);\n        clean.outputSettings(outputSettings);\n        return clean.body().html();\n    }\n\n    \n    public static boolean isValid(String bodyHtml, Whitelist whitelist) {\n        return new Cleaner(whitelist).isValidBodyHtml(bodyHtml);\n    }\n    \n}\n",
      "buggy_signatures": [
        "public class Jsoup { private Jsoup()",
        "public static Document parse(String html, String baseUri)",
        "public static Document parse(String html, String baseUri, Parser parser)",
        "public static Document parse(String html)",
        "public static Connection connect(String url)",
        "public static Document parse(File in, String charsetName, String baseUri) throws IOException",
        "public static Document parse(File in, String charsetName) throws IOException",
        "public static Document parse(InputStream in, String charsetName, String baseUri) throws IOException",
        "public static Document parse(InputStream in, String charsetName, String baseUri, Parser parser) throws IOException",
        "public static Document parseBodyFragment(String bodyHtml, String baseUri)",
        "public static Document parseBodyFragment(String bodyHtml)",
        "public static Document parse(URL url, int timeoutMillis) throws IOException",
        "public static String clean(String bodyHtml, String baseUri, Whitelist whitelist)",
        "public static String clean(String bodyHtml, Whitelist whitelist)",
        "public static String clean(String bodyHtml, String baseUri, Whitelist whitelist, Document.OutputSettings outputSettings)",
        "public static boolean isValid(String bodyHtml, Whitelist whitelist)"
      ],
      "fixed_signatures": [
        "public class Jsoup { private Jsoup()",
        "public static Document parse(String html, String baseUri)",
        "public static Document parse(String html, String baseUri, Parser parser)",
        "public static Document parse(String html)",
        "public static Connection connect(String url)",
        "public static Document parse(File in, String charsetName, String baseUri) throws IOException",
        "public static Document parse(File in, String charsetName) throws IOException",
        "public static Document parse(InputStream in, String charsetName, String baseUri) throws IOException",
        "public static Document parse(InputStream in, String charsetName, String baseUri, Parser parser) throws IOException",
        "public static Document parseBodyFragment(String bodyHtml, String baseUri)",
        "public static Document parseBodyFragment(String bodyHtml)",
        "public static Document parse(URL url, int timeoutMillis) throws IOException",
        "public static String clean(String bodyHtml, String baseUri, Whitelist whitelist)",
        "public static String clean(String bodyHtml, Whitelist whitelist)",
        "public static String clean(String bodyHtml, String baseUri, Whitelist whitelist, Document.OutputSettings outputSettings)",
        "public static boolean isValid(String bodyHtml, Whitelist whitelist)"
      ],
      "methods": [
        {
          "buggy_method": "  public static boolean isValid(String bodyHtml, Whitelist whitelist) {\n  return new Cleaner(whitelist).isValid(parseBodyFragment(bodyHtml, \"\"));\n  }",
          "fixed_method": "  public static boolean isValid(String bodyHtml, Whitelist whitelist) {\n  return new Cleaner(whitelist).isValidBodyHtml(bodyHtml);\n  }",
          "diff": [
            "@@ -247,7 +247,7 @@",
            "      @see #clean(String, org.jsoup.safety.Whitelist) \n",
            "      */\n",
            "     public static boolean isValid(String bodyHtml, Whitelist whitelist) {\n",
            "-        return new Cleaner(whitelist).isValid(parseBodyFragment(bodyHtml, \"\"));\n",
            "+        return new Cleaner(whitelist).isValidBodyHtml(bodyHtml);\n",
            "     }\n",
            "     \n",
            " }\n"
          ],
          "changed_lines": 2
        }
      ]
    },
    {
      "name": "org/jsoup/parser/Parser.java",
      "buggy_full_code": "package org.jsoup.parser;\n\nimport org.jsoup.nodes.Document;\nimport org.jsoup.nodes.Element;\nimport org.jsoup.nodes.Node;\n\nimport java.util.List;\n\n\npublic class Parser { private static final int DEFAULT_MAX_ERRORS = 0; private TreeBuilder treeBuilder; private int maxErrors = DEFAULT_MAX_ERRORS; private ParseErrorList errors; private ParseSettings settings; public Parser(TreeBuilder treeBuilder) {\n        this.treeBuilder = treeBuilder;\n        settings = treeBuilder.defaultSettings();\n    }\n    \n    public Document parseInput(String html, String baseUri) {\n        errors = isTrackErrors() ? ParseErrorList.tracking(maxErrors) : ParseErrorList.noTracking();\n        return treeBuilder.parse(html, baseUri, errors, settings);\n    }\n\n    \n    \n    public TreeBuilder getTreeBuilder() {\n        return treeBuilder;\n    }\n\n    \n    public Parser setTreeBuilder(TreeBuilder treeBuilder) {\n        this.treeBuilder = treeBuilder;\n        return this;\n    }\n\n    \n    public boolean isTrackErrors() {\n        return maxErrors > 0;\n    }\n\n    \n    public Parser setTrackErrors(int maxErrors) {\n        this.maxErrors = maxErrors;\n        return this;\n    }\n\n    \n    public List<ParseError> getErrors() {\n        return errors;\n    }\n\n    public Parser settings(ParseSettings settings) {\n        this.settings = settings;\n        return this;\n    }\n\n    public ParseSettings settings() {\n        return settings;\n    }\n\n    \n    \n    public static Document parse(String html, String baseUri) {\n        TreeBuilder treeBuilder = new HtmlTreeBuilder();\n        return treeBuilder.parse(html, baseUri, ParseErrorList.noTracking(), treeBuilder.defaultSettings());\n    }\n\n    \n    public static List<Node> parseFragment(String fragmentHtml, Element context, String baseUri) {\n        HtmlTreeBuilder treeBuilder = new HtmlTreeBuilder();\n        return treeBuilder.parseFragment(fragmentHtml, context, baseUri, ParseErrorList.noTracking(), treeBuilder.defaultSettings());\n    }\n\n    \n\n    \n    public static List<Node> parseXmlFragment(String fragmentXml, String baseUri) {\n        XmlTreeBuilder treeBuilder = new XmlTreeBuilder();\n        return treeBuilder.parseFragment(fragmentXml, baseUri, ParseErrorList.noTracking(), treeBuilder.defaultSettings());\n    }\n\n    \n    public static Document parseBodyFragment(String bodyHtml, String baseUri) {\n        Document doc = Document.createShell(baseUri);\n        Element body = doc.body();\n        List<Node> nodeList = parseFragment(bodyHtml, body, baseUri);\n        Node[] nodes = nodeList.toArray(new Node[nodeList.size()]); \n        for (int i = nodes.length - 1; i > 0; i--) {\n            nodes[i].remove();\n        }\n        for (Node node : nodes) {\n            body.appendChild(node);\n        }\n        return doc;\n    }\n\n    \n    public static String unescapeEntities(String string, boolean inAttribute) {\n        Tokeniser tokeniser = new Tokeniser(new CharacterReader(string), ParseErrorList.noTracking());\n        return tokeniser.unescapeEntities(inAttribute);\n    }\n\n    \n    public static Document parseBodyFragmentRelaxed(String bodyHtml, String baseUri) {\n        return parse(bodyHtml, baseUri);\n    }\n    \n    \n\n    \n    public static Parser htmlParser() {\n        return new Parser(new HtmlTreeBuilder());\n    }\n\n    \n    public static Parser xmlParser() {\n        return new Parser(new XmlTreeBuilder());\n    }\n}\n",
      "fixed_full_code": "package org.jsoup.parser;\n\nimport org.jsoup.nodes.Document;\nimport org.jsoup.nodes.Element;\nimport org.jsoup.nodes.Node;\n\nimport java.util.List;\n\n\npublic class Parser { private static final int DEFAULT_MAX_ERRORS = 0; private TreeBuilder treeBuilder; private int maxErrors = DEFAULT_MAX_ERRORS; private ParseErrorList errors; private ParseSettings settings; public Parser(TreeBuilder treeBuilder) {\n        this.treeBuilder = treeBuilder;\n        settings = treeBuilder.defaultSettings();\n    }\n    \n    public Document parseInput(String html, String baseUri) {\n        errors = isTrackErrors() ? ParseErrorList.tracking(maxErrors) : ParseErrorList.noTracking();\n        return treeBuilder.parse(html, baseUri, errors, settings);\n    }\n\n    \n    \n    public TreeBuilder getTreeBuilder() {\n        return treeBuilder;\n    }\n\n    \n    public Parser setTreeBuilder(TreeBuilder treeBuilder) {\n        this.treeBuilder = treeBuilder;\n        return this;\n    }\n\n    \n    public boolean isTrackErrors() {\n        return maxErrors > 0;\n    }\n\n    \n    public Parser setTrackErrors(int maxErrors) {\n        this.maxErrors = maxErrors;\n        return this;\n    }\n\n    \n    public List<ParseError> getErrors() {\n        return errors;\n    }\n\n    public Parser settings(ParseSettings settings) {\n        this.settings = settings;\n        return this;\n    }\n\n    public ParseSettings settings() {\n        return settings;\n    }\n\n    \n    \n    public static Document parse(String html, String baseUri) {\n        TreeBuilder treeBuilder = new HtmlTreeBuilder();\n        return treeBuilder.parse(html, baseUri, ParseErrorList.noTracking(), treeBuilder.defaultSettings());\n    }\n\n    \n    public static List<Node> parseFragment(String fragmentHtml, Element context, String baseUri) {\n        HtmlTreeBuilder treeBuilder = new HtmlTreeBuilder();\n        return treeBuilder.parseFragment(fragmentHtml, context, baseUri, ParseErrorList.noTracking(), treeBuilder.defaultSettings());\n    }\n\n    \n    public static List<Node> parseFragment(String fragmentHtml, Element context, String baseUri, ParseErrorList errorList) {\n        HtmlTreeBuilder treeBuilder = new HtmlTreeBuilder();\n        return treeBuilder.parseFragment(fragmentHtml, context, baseUri, errorList, treeBuilder.defaultSettings());\n    }\n\n    \n    public static List<Node> parseXmlFragment(String fragmentXml, String baseUri) {\n        XmlTreeBuilder treeBuilder = new XmlTreeBuilder();\n        return treeBuilder.parseFragment(fragmentXml, baseUri, ParseErrorList.noTracking(), treeBuilder.defaultSettings());\n    }\n\n    \n    public static Document parseBodyFragment(String bodyHtml, String baseUri) {\n        Document doc = Document.createShell(baseUri);\n        Element body = doc.body();\n        List<Node> nodeList = parseFragment(bodyHtml, body, baseUri);\n        Node[] nodes = nodeList.toArray(new Node[nodeList.size()]); \n        for (int i = nodes.length - 1; i > 0; i--) {\n            nodes[i].remove();\n        }\n        for (Node node : nodes) {\n            body.appendChild(node);\n        }\n        return doc;\n    }\n\n    \n    public static String unescapeEntities(String string, boolean inAttribute) {\n        Tokeniser tokeniser = new Tokeniser(new CharacterReader(string), ParseErrorList.noTracking());\n        return tokeniser.unescapeEntities(inAttribute);\n    }\n\n    \n    public static Document parseBodyFragmentRelaxed(String bodyHtml, String baseUri) {\n        return parse(bodyHtml, baseUri);\n    }\n    \n    \n\n    \n    public static Parser htmlParser() {\n        return new Parser(new HtmlTreeBuilder());\n    }\n\n    \n    public static Parser xmlParser() {\n        return new Parser(new XmlTreeBuilder());\n    }\n}\n",
      "buggy_signatures": [
        "public Document parseInput(String html, String baseUri)",
        "public TreeBuilder getTreeBuilder()",
        "public Parser setTreeBuilder(TreeBuilder treeBuilder)",
        "public boolean isTrackErrors()",
        "public Parser setTrackErrors(int maxErrors)",
        "public List<ParseError> getErrors()",
        "public Parser settings(ParseSettings settings)",
        "public ParseSettings settings()",
        "public static Document parse(String html, String baseUri)",
        "public static List<Node> parseFragment(String fragmentHtml, Element context, String baseUri)",
        "public static List<Node> parseXmlFragment(String fragmentXml, String baseUri)",
        "public static Document parseBodyFragment(String bodyHtml, String baseUri)",
        "public static String unescapeEntities(String string, boolean inAttribute)",
        "public static Document parseBodyFragmentRelaxed(String bodyHtml, String baseUri)",
        "public static Parser htmlParser()",
        "public static Parser xmlParser()"
      ],
      "fixed_signatures": [
        "public Document parseInput(String html, String baseUri)",
        "public TreeBuilder getTreeBuilder()",
        "public Parser setTreeBuilder(TreeBuilder treeBuilder)",
        "public boolean isTrackErrors()",
        "public Parser setTrackErrors(int maxErrors)",
        "public List<ParseError> getErrors()",
        "public Parser settings(ParseSettings settings)",
        "public ParseSettings settings()",
        "public static Document parse(String html, String baseUri)",
        "public static List<Node> parseFragment(String fragmentHtml, Element context, String baseUri)",
        "public static List<Node> parseFragment(String fragmentHtml, Element context, String baseUri, ParseErrorList errorList)",
        "public static List<Node> parseXmlFragment(String fragmentXml, String baseUri)",
        "public static Document parseBodyFragment(String bodyHtml, String baseUri)",
        "public static String unescapeEntities(String string, boolean inAttribute)",
        "public static Document parseBodyFragmentRelaxed(String bodyHtml, String baseUri)",
        "public static Parser htmlParser()",
        "public static Parser xmlParser()"
      ],
      "methods": [
        {
          "buggy_method": "  public static List<Node> parseFragment(String fragmentHtml, Element context, String baseUri) {\n  HtmlTreeBuilder treeBuilder = new HtmlTreeBuilder();\n  return treeBuilder.parseFragment(fragmentHtml, context, baseUri, ParseErrorList.noTracking(), treeBuilder.defaultSettings());\n  }",
          "fixed_method": "  public static List<Node> parseFragment(String fragmentHtml, Element context, String baseUri, ParseErrorList errorList) {\n  HtmlTreeBuilder treeBuilder = new HtmlTreeBuilder();\n  return treeBuilder.parseFragment(fragmentHtml, context, baseUri, errorList, treeBuilder.defaultSettings());\n  }",
          "diff": [
            "@@ -126,6 +126,10 @@",
            "      *\n",
            "      * @return list of nodes parsed from the input HTML. Note that the context element, if supplied, is not modified.\n",
            "      */\n",
            "+    public static List<Node> parseFragment(String fragmentHtml, Element context, String baseUri, ParseErrorList errorList) {\n",
            "+        HtmlTreeBuilder treeBuilder = new HtmlTreeBuilder();\n",
            "+        return treeBuilder.parseFragment(fragmentHtml, context, baseUri, errorList, treeBuilder.defaultSettings());\n",
            "+    }\n",
            " \n",
            "     /**\n",
            "      * Parse a fragment of XML into a list of nodes.\n"
          ],
          "changed_lines": 4
        }
      ]
    },
    {
      "name": "org/jsoup/safety/Cleaner.java",
      "buggy_full_code": "package org.jsoup.safety;\n\nimport org.jsoup.helper.Validate;\nimport org.jsoup.nodes.Attribute;\nimport org.jsoup.nodes.Attributes;\nimport org.jsoup.nodes.DataNode;\nimport org.jsoup.nodes.Document;\nimport org.jsoup.nodes.Element;\nimport org.jsoup.nodes.Node;\nimport org.jsoup.nodes.TextNode;\nimport org.jsoup.parser.ParseErrorList;\nimport org.jsoup.parser.Parser;\nimport org.jsoup.parser.Tag;\nimport org.jsoup.select.NodeTraversor;\nimport org.jsoup.select.NodeVisitor;\n\n\n\n\npublic class Cleaner { private Whitelist whitelist; public Cleaner(Whitelist whitelist) {\n        Validate.notNull(whitelist);\n        this.whitelist = whitelist;\n    }\n\n    \n    public Document clean(Document dirtyDocument) {\n        Validate.notNull(dirtyDocument);\n\n        Document clean = Document.createShell(dirtyDocument.baseUri());\n        if (dirtyDocument.body() != null) \n            copySafeNodes(dirtyDocument.body(), clean.body());\n\n        return clean;\n    }\n\n    \n    public boolean isValid(Document dirtyDocument) {\n        Validate.notNull(dirtyDocument);\n\n        Document clean = Document.createShell(dirtyDocument.baseUri());\n        int numDiscarded = copySafeNodes(dirtyDocument.body(), clean.body());\n        return numDiscarded == 0;\n    }\n\n\n    \n    private final class CleaningVisitor implements NodeVisitor { private int numDiscarded = 0; private final Element root; private Element destination; private CleaningVisitor(Element root, Element destination) {\n            this.root = root;\n            this.destination = destination;\n        }\n\n        public void head(Node source, int depth) {\n            if (source instanceof Element) {\n                Element sourceEl = (Element) source;\n\n                if (whitelist.isSafeTag(sourceEl.tagName())) { \n                    ElementMeta meta = createSafeElement(sourceEl);\n                    Element destChild = meta.el;\n                    destination.appendChild(destChild);\n\n                    numDiscarded += meta.numAttribsDiscarded;\n                    destination = destChild;\n                } else if (source != root) { \n                    numDiscarded++;\n                }\n            } else if (source instanceof TextNode) {\n                TextNode sourceText = (TextNode) source;\n                TextNode destText = new TextNode(sourceText.getWholeText(), source.baseUri());\n                destination.appendChild(destText);\n            } else if (source instanceof DataNode && whitelist.isSafeTag(source.parent().nodeName())) {\n              DataNode sourceData = (DataNode) source;\n              DataNode destData = new DataNode(sourceData.getWholeData(), source.baseUri());\n              destination.appendChild(destData);\n            } else { \n                numDiscarded++;\n            }\n        }\n\n        public void tail(Node source, int depth) {\n            if (source instanceof Element && whitelist.isSafeTag(source.nodeName())) {\n                destination = destination.parent(); \n            }\n        }\n    }\n\n    private int copySafeNodes(Element source, Element dest) {\n        CleaningVisitor cleaningVisitor = new CleaningVisitor(source, dest);\n        NodeTraversor traversor = new NodeTraversor(cleaningVisitor);\n        traversor.traverse(source);\n        return cleaningVisitor.numDiscarded;\n    }\n\n    private ElementMeta createSafeElement(Element sourceEl) {\n        String sourceTag = sourceEl.tagName();\n        Attributes destAttrs = new Attributes();\n        Element dest = new Element(Tag.valueOf(sourceTag), sourceEl.baseUri(), destAttrs);\n        int numDiscarded = 0;\n\n        Attributes sourceAttrs = sourceEl.attributes();\n        for (Attribute sourceAttr : sourceAttrs) {\n            if (whitelist.isSafeAttribute(sourceTag, sourceEl, sourceAttr))\n                destAttrs.put(sourceAttr);\n            else\n                numDiscarded++;\n        }\n        Attributes enforcedAttrs = whitelist.getEnforcedAttributes(sourceTag);\n        destAttrs.addAll(enforcedAttrs);\n\n        return new ElementMeta(dest, numDiscarded);\n    }\n\n    private static class ElementMeta { Element el; int numAttribsDiscarded; ElementMeta(Element el, int numAttribsDiscarded) {\n            this.el = el;\n            this.numAttribsDiscarded = numAttribsDiscarded;\n        }\n    }\n\n}\n",
      "fixed_full_code": "package org.jsoup.safety;\n\nimport org.jsoup.helper.Validate;\nimport org.jsoup.nodes.Attribute;\nimport org.jsoup.nodes.Attributes;\nimport org.jsoup.nodes.DataNode;\nimport org.jsoup.nodes.Document;\nimport org.jsoup.nodes.Element;\nimport org.jsoup.nodes.Node;\nimport org.jsoup.nodes.TextNode;\nimport org.jsoup.parser.ParseErrorList;\nimport org.jsoup.parser.Parser;\nimport org.jsoup.parser.Tag;\nimport org.jsoup.select.NodeTraversor;\nimport org.jsoup.select.NodeVisitor;\n\nimport java.util.List;\n\n\n\npublic class Cleaner { private Whitelist whitelist; public Cleaner(Whitelist whitelist) {\n        Validate.notNull(whitelist);\n        this.whitelist = whitelist;\n    }\n\n    \n    public Document clean(Document dirtyDocument) {\n        Validate.notNull(dirtyDocument);\n\n        Document clean = Document.createShell(dirtyDocument.baseUri());\n        if (dirtyDocument.body() != null) \n            copySafeNodes(dirtyDocument.body(), clean.body());\n\n        return clean;\n    }\n\n    \n    public boolean isValid(Document dirtyDocument) {\n        Validate.notNull(dirtyDocument);\n\n        Document clean = Document.createShell(dirtyDocument.baseUri());\n        int numDiscarded = copySafeNodes(dirtyDocument.body(), clean.body());\n        return numDiscarded == 0\n            && dirtyDocument.head().childNodes().size() == 0; \n    }\n\n    public boolean isValidBodyHtml(String bodyHtml) {\n        Document clean = Document.createShell(\"\");\n        Document dirty = Document.createShell(\"\");\n        ParseErrorList errorList = ParseErrorList.tracking(1);\n        List<Node> nodes = Parser.parseFragment(bodyHtml, dirty.body(), \"\", errorList);\n        dirty.body().insertChildren(0, nodes);\n        int numDiscarded = copySafeNodes(dirty.body(), clean.body());\n        return numDiscarded == 0 && errorList.size() == 0;\n    }\n\n    \n    private final class CleaningVisitor implements NodeVisitor { private int numDiscarded = 0; private final Element root; private Element destination; private CleaningVisitor(Element root, Element destination) {\n            this.root = root;\n            this.destination = destination;\n        }\n\n        public void head(Node source, int depth) {\n            if (source instanceof Element) {\n                Element sourceEl = (Element) source;\n\n                if (whitelist.isSafeTag(sourceEl.tagName())) { \n                    ElementMeta meta = createSafeElement(sourceEl);\n                    Element destChild = meta.el;\n                    destination.appendChild(destChild);\n\n                    numDiscarded += meta.numAttribsDiscarded;\n                    destination = destChild;\n                } else if (source != root) { \n                    numDiscarded++;\n                }\n            } else if (source instanceof TextNode) {\n                TextNode sourceText = (TextNode) source;\n                TextNode destText = new TextNode(sourceText.getWholeText(), source.baseUri());\n                destination.appendChild(destText);\n            } else if (source instanceof DataNode && whitelist.isSafeTag(source.parent().nodeName())) {\n              DataNode sourceData = (DataNode) source;\n              DataNode destData = new DataNode(sourceData.getWholeData(), source.baseUri());\n              destination.appendChild(destData);\n            } else { \n                numDiscarded++;\n            }\n        }\n\n        public void tail(Node source, int depth) {\n            if (source instanceof Element && whitelist.isSafeTag(source.nodeName())) {\n                destination = destination.parent(); \n            }\n        }\n    }\n\n    private int copySafeNodes(Element source, Element dest) {\n        CleaningVisitor cleaningVisitor = new CleaningVisitor(source, dest);\n        NodeTraversor traversor = new NodeTraversor(cleaningVisitor);\n        traversor.traverse(source);\n        return cleaningVisitor.numDiscarded;\n    }\n\n    private ElementMeta createSafeElement(Element sourceEl) {\n        String sourceTag = sourceEl.tagName();\n        Attributes destAttrs = new Attributes();\n        Element dest = new Element(Tag.valueOf(sourceTag), sourceEl.baseUri(), destAttrs);\n        int numDiscarded = 0;\n\n        Attributes sourceAttrs = sourceEl.attributes();\n        for (Attribute sourceAttr : sourceAttrs) {\n            if (whitelist.isSafeAttribute(sourceTag, sourceEl, sourceAttr))\n                destAttrs.put(sourceAttr);\n            else\n                numDiscarded++;\n        }\n        Attributes enforcedAttrs = whitelist.getEnforcedAttributes(sourceTag);\n        destAttrs.addAll(enforcedAttrs);\n\n        return new ElementMeta(dest, numDiscarded);\n    }\n\n    private static class ElementMeta { Element el; int numAttribsDiscarded; ElementMeta(Element el, int numAttribsDiscarded) {\n            this.el = el;\n            this.numAttribsDiscarded = numAttribsDiscarded;\n        }\n    }\n\n}\n",
      "buggy_signatures": [
        "public class Cleaner { private Whitelist whitelist; public Cleaner(Whitelist whitelist)",
        "public Document clean(Document dirtyDocument)",
        "public boolean isValid(Document dirtyDocument)",
        "public void head(Node source, int depth)",
        "public void tail(Node source, int depth)",
        "private int copySafeNodes(Element source, Element dest)",
        "private ElementMeta createSafeElement(Element sourceEl)",
        "private static class ElementMeta { Element el; int numAttribsDiscarded; ElementMeta(Element el, int numAttribsDiscarded)"
      ],
      "fixed_signatures": [
        "public class Cleaner { private Whitelist whitelist; public Cleaner(Whitelist whitelist)",
        "public Document clean(Document dirtyDocument)",
        "public boolean isValid(Document dirtyDocument)",
        "public boolean isValidBodyHtml(String bodyHtml)",
        "public void head(Node source, int depth)",
        "public void tail(Node source, int depth)",
        "private int copySafeNodes(Element source, Element dest)",
        "private ElementMeta createSafeElement(Element sourceEl)",
        "private static class ElementMeta { Element el; int numAttribsDiscarded; ElementMeta(Element el, int numAttribsDiscarded)"
      ],
      "methods": [
        {
          "buggy_method": "",
          "fixed_method": "",
          "diff": [
            "@@ -14,6 +14,7 @@",
            " import org.jsoup.select.NodeTraversor;\n",
            " import org.jsoup.select.NodeVisitor;\n",
            " \n",
            "+import java.util.List;\n",
            " \n",
            " \n",
            " /**\n"
          ],
          "changed_lines": 1
        },
        {
          "buggy_method": "  public boolean isValid(Document dirtyDocument) {\n  Validate.notNull(dirtyDocument);\n\n  Document clean = Document.createShell(dirtyDocument.baseUri());\n  int numDiscarded = copySafeNodes(dirtyDocument.body(), clean.body());\n  return numDiscarded == 0;\n  }",
          "fixed_method": "  public boolean isValidBodyHtml(String bodyHtml) {\n  Document clean = Document.createShell(\"\");\n  Document dirty = Document.createShell(\"\");\n  ParseErrorList errorList = ParseErrorList.tracking(1);\n  List<Node> nodes = Parser.parseFragment(bodyHtml, dirty.body(), \"\", errorList);\n  dirty.body().insertChildren(0, nodes);\n  int numDiscarded = copySafeNodes(dirty.body(), clean.body());\n  return numDiscarded == 0 && errorList.size() == 0;\n  }",
          "diff": [
            "@@ -75,9 +76,19 @@",
            " \n",
            "         Document clean = Document.createShell(dirtyDocument.baseUri());\n",
            "         int numDiscarded = copySafeNodes(dirtyDocument.body(), clean.body());\n",
            "-        return numDiscarded == 0;\n",
            "+        return numDiscarded == 0\n",
            "+            && dirtyDocument.head().childNodes().size() == 0; // because we only look at the body, but we start from a shell, make sure there's nothing in the head\n",
            "     }\n",
            " \n",
            "+    public boolean isValidBodyHtml(String bodyHtml) {\n",
            "+        Document clean = Document.createShell(\"\");\n",
            "+        Document dirty = Document.createShell(\"\");\n",
            "+        ParseErrorList errorList = ParseErrorList.tracking(1);\n",
            "+        List<Node> nodes = Parser.parseFragment(bodyHtml, dirty.body(), \"\", errorList);\n",
            "+        dirty.body().insertChildren(0, nodes);\n",
            "+        int numDiscarded = copySafeNodes(dirty.body(), clean.body());\n",
            "+        return numDiscarded == 0 && errorList.size() == 0;\n",
            "+    }\n",
            " \n",
            "     /**\n",
            "      Iterates the input and copies trusted nodes (tags, attributes, text) into the destination.\n"
          ],
          "changed_lines": 12
        }
      ]
    }
  ]
}
