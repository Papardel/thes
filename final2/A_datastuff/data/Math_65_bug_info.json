{
  "bug_id": "65",
  "failed_tests": {
    "org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest": [
      {
        "methodName": "testCircleFitting",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<0.004> but was:<0.0019737107108948474>",
        "fail_line": "        assertEquals(0.004, errors[0], 0.001);",
        "test_source": "  public void testCircleFitting() throws FunctionEvaluationException, OptimizationException {\n  Circle circle = new Circle();\n  circle.addPoint( 30.0,  68.0);\n  circle.addPoint( 50.0,  -6.0);\n  circle.addPoint(110.0, -20.0);\n  circle.addPoint( 35.0,  15.0);\n  circle.addPoint( 45.0,  97.0);\n  LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n  VectorialPointValuePair optimum =\n  optimizer.optimize(circle, new double[] { 0, 0, 0, 0, 0 }, new double[] { 1, 1, 1, 1, 1 },\n  new double[] { 98.680, 47.345 });\n  assertTrue(optimizer.getEvaluations() < 10);\n  assertTrue(optimizer.getJacobianEvaluations() < 10);\n  double rms = optimizer.getRMS();\n  assertEquals(1.768262623567235,  Math.sqrt(circle.getN()) * rms,  1.0e-10);\n  Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);\n  assertEquals(69.96016176931406, circle.getRadius(center), 1.0e-10);\n  assertEquals(96.07590211815305, center.x,  1.0e-10);\n  assertEquals(48.13516790438953, center.y,  1.0e-10);\n  double[][] cov = optimizer.getCovariances();\n  assertEquals(1.839, cov[0][0], 0.001);\n  assertEquals(0.731, cov[0][1], 0.001);\n  assertEquals(cov[0][1], cov[1][0], 1.0e-14);\n  assertEquals(0.786, cov[1][1], 0.001);\n  double[] errors = optimizer.guessParametersErrors();\n  assertEquals(1.384, errors[0], 0.001);\n  assertEquals(0.905, errors[1], 0.001);\n\n  // add perfect measurements and check errors are reduced\n  double  r = circle.getRadius(center);\n  for (double d= 0; d < 2 * Math.PI; d += 0.01) {\n  circle.addPoint(center.x + r * Math.cos(d), center.y + r * Math.sin(d));\n  }\n  double[] target = new double[circle.getN()];\n  Arrays.fill(target, 0.0);\n  double[] weights = new double[circle.getN()];\n  Arrays.fill(weights, 2.0);\n  optimizer.optimize(circle, target, weights, new double[] { 98.680, 47.345 });\n  cov = optimizer.getCovariances();\n  assertEquals(0.0016, cov[0][0], 0.001);\n  assertEquals(3.2e-7, cov[0][1], 1.0e-9);\n  assertEquals(cov[0][1], cov[1][0], 1.0e-14);\n  assertEquals(0.0016, cov[1][1], 0.001);\n  errors = optimizer.guessParametersErrors();\n  assertEquals(0.004, errors[0], 0.001);\n  assertEquals(0.004, errors[1], 0.001);\n\n  }",
        "stack": [
          "LevenbergMarquardtOptimizerTest.testCircleFitting line 442"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java",
      "buggy_full_code": "\n\npackage org.apache.commons.math.optimization.general;\n\nimport org.apache.commons.math.FunctionEvaluationException;\nimport org.apache.commons.math.MaxEvaluationsExceededException;\nimport org.apache.commons.math.MaxIterationsExceededException;\nimport org.apache.commons.math.analysis.DifferentiableMultivariateVectorialFunction;\nimport org.apache.commons.math.analysis.MultivariateMatrixFunction;\nimport org.apache.commons.math.exception.LocalizedFormats;\nimport org.apache.commons.math.linear.InvalidMatrixException;\nimport org.apache.commons.math.linear.LUDecompositionImpl;\nimport org.apache.commons.math.linear.MatrixUtils;\nimport org.apache.commons.math.linear.RealMatrix;\nimport org.apache.commons.math.optimization.OptimizationException;\nimport org.apache.commons.math.optimization.SimpleVectorialValueChecker;\nimport org.apache.commons.math.optimization.VectorialConvergenceChecker;\nimport org.apache.commons.math.optimization.DifferentiableMultivariateVectorialOptimizer;\nimport org.apache.commons.math.optimization.VectorialPointValuePair;\n\n\npublic abstract class AbstractLeastSquaresOptimizer implements DifferentiableMultivariateVectorialOptimizer { public static final int DEFAULT_MAX_ITERATIONS = 100; protected VectorialConvergenceChecker checker; protected double[][] jacobian; protected int cols; protected int rows; protected double[] targetValues; protected double[] residualsWeights; protected double[] point; protected double[] objective; protected double[] residuals; protected double cost; private int maxIterations; private int iterations; private int maxEvaluations; private int objectiveEvaluations; private int jacobianEvaluations; private DifferentiableMultivariateVectorialFunction function; private MultivariateMatrixFunction jF; protected AbstractLeastSquaresOptimizer() {\n        setConvergenceChecker(new SimpleVectorialValueChecker());\n        setMaxIterations(DEFAULT_MAX_ITERATIONS);\n        setMaxEvaluations(Integer.MAX_VALUE);\n    }\n\n    \n    public void setMaxIterations(int maxIterations) {\n        this.maxIterations = maxIterations;\n    }\n\n    \n    public int getMaxIterations() {\n        return maxIterations;\n    }\n\n    \n    public int getIterations() {\n        return iterations;\n    }\n\n    \n    public void setMaxEvaluations(int maxEvaluations) {\n        this.maxEvaluations = maxEvaluations;\n    }\n\n    \n    public int getMaxEvaluations() {\n        return maxEvaluations;\n    }\n\n    \n    public int getEvaluations() {\n        return objectiveEvaluations;\n    }\n\n    \n    public int getJacobianEvaluations() {\n        return jacobianEvaluations;\n    }\n\n    \n    public void setConvergenceChecker(VectorialConvergenceChecker convergenceChecker) {\n        this.checker = convergenceChecker;\n    }\n\n    \n    public VectorialConvergenceChecker getConvergenceChecker() {\n        return checker;\n    }\n\n    \n    protected void incrementIterationsCounter() throws OptimizationException {\n        if (++iterations > maxIterations) {\n            throw new OptimizationException(new MaxIterationsExceededException(maxIterations));\n        }\n    }\n\n    \n    protected void updateJacobian() throws FunctionEvaluationException {\n        ++jacobianEvaluations;\n        jacobian = jF.value(point);\n        if (jacobian.length != rows) {\n            throw new FunctionEvaluationException(point, LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE,\n                                                  jacobian.length, rows);\n        }\n        for (int i = 0; i < rows; i++) {\n            final double[] ji = jacobian[i];\n            final double factor = -Math.sqrt(residualsWeights[i]);\n            for (int j = 0; j < cols; ++j) {\n                ji[j] *= factor;\n            }\n        }\n    }\n\n    \n    protected void updateResidualsAndCost() throws FunctionEvaluationException {\n\n        if (++objectiveEvaluations > maxEvaluations) {\n            throw new FunctionEvaluationException(new MaxEvaluationsExceededException(maxEvaluations),\n                                                  point);\n        }\n        objective = function.value(point);\n        if (objective.length != rows) {\n            throw new FunctionEvaluationException(point, LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE,\n                                                  objective.length, rows);\n        }\n        cost = 0;\n        int index = 0;\n        for (int i = 0; i < rows; i++) {\n            final double residual = targetValues[i] - objective[i];\n            residuals[i] = residual;\n            cost += residualsWeights[i] * residual * residual;\n            index += cols;\n        }\n        cost = Math.sqrt(cost);\n\n    }\n\n    \n    public double getRMS() {\n        double criterion = 0;\n        for (int i = 0; i < rows; ++i) {\n            final double residual = residuals[i];\n            criterion += residual * residual * residualsWeights[i];\n        }\n        return Math.sqrt(criterion / rows);\n    }\n\n    \n    public double getChiSquare() {\n        double chiSquare = 0;\n        for (int i = 0; i < rows; ++i) {\n            final double residual = residuals[i];\n            chiSquare += residual * residual / residualsWeights[i];\n        }\n        return chiSquare;\n    }\n\n    \n    public double[][] getCovariances() throws FunctionEvaluationException, OptimizationException {\n\n        \n        updateJacobian();\n\n        \n        double[][] jTj = new double[cols][cols];\n        for (int i = 0; i < cols; ++i) {\n            for (int j = i; j < cols; ++j) {\n                double sum = 0;\n                for (int k = 0; k < rows; ++k) {\n                    sum += jacobian[k][i] * jacobian[k][j];\n                }\n                jTj[i][j] = sum;\n                jTj[j][i] = sum;\n            }\n        }\n\n        try {\n            \n            RealMatrix inverse =\n                new LUDecompositionImpl(MatrixUtils.createRealMatrix(jTj)).getSolver().getInverse();\n            return inverse.getData();\n        } catch (InvalidMatrixException ime) {\n            throw new OptimizationException(LocalizedFormats.UNABLE_TO_COMPUTE_COVARIANCE_SINGULAR_PROBLEM);\n        }\n\n    }\n\n    \n    public double[] guessParametersErrors() throws FunctionEvaluationException, OptimizationException {\n        if (rows <= cols) {\n            throw new OptimizationException(\n                    LocalizedFormats.NO_DEGREES_OF_FREEDOM,\n                    rows, cols);\n        }\n        double[] errors = new double[cols];\n        final double c = Math.sqrt(getChiSquare() / (rows - cols));\n        double[][] covar = getCovariances();\n        for (int i = 0; i < errors.length; ++i) {\n            errors[i] = Math.sqrt(covar[i][i]) * c;\n        }\n        return errors;\n    }\n\n    \n    public VectorialPointValuePair optimize(final DifferentiableMultivariateVectorialFunction f, final double[] target, final double[] weights, final double[] startPoint) throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n        if (target.length != weights.length) {\n            throw new OptimizationException(LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE,\n                                            target.length, weights.length);\n        }\n\n        \n        iterations           = 0;\n        objectiveEvaluations = 0;\n        jacobianEvaluations  = 0;\n\n        \n        function         = f;\n        jF               = f.jacobian();\n        targetValues     = target.clone();\n        residualsWeights = weights.clone();\n        this.point       = startPoint.clone();\n        this.residuals   = new double[target.length];\n\n        \n        rows      = target.length;\n        cols      = point.length;\n        jacobian  = new double[rows][cols];\n\n        cost = Double.POSITIVE_INFINITY;\n\n        return doOptimize();\n\n    }\n\n    \n    protected abstract VectorialPointValuePair doOptimize()\n        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException;\n\n}\n",
      "fixed_full_code": "\n\npackage org.apache.commons.math.optimization.general;\n\nimport org.apache.commons.math.FunctionEvaluationException;\nimport org.apache.commons.math.MaxEvaluationsExceededException;\nimport org.apache.commons.math.MaxIterationsExceededException;\nimport org.apache.commons.math.analysis.DifferentiableMultivariateVectorialFunction;\nimport org.apache.commons.math.analysis.MultivariateMatrixFunction;\nimport org.apache.commons.math.exception.LocalizedFormats;\nimport org.apache.commons.math.linear.InvalidMatrixException;\nimport org.apache.commons.math.linear.LUDecompositionImpl;\nimport org.apache.commons.math.linear.MatrixUtils;\nimport org.apache.commons.math.linear.RealMatrix;\nimport org.apache.commons.math.optimization.OptimizationException;\nimport org.apache.commons.math.optimization.SimpleVectorialValueChecker;\nimport org.apache.commons.math.optimization.VectorialConvergenceChecker;\nimport org.apache.commons.math.optimization.DifferentiableMultivariateVectorialOptimizer;\nimport org.apache.commons.math.optimization.VectorialPointValuePair;\n\n\npublic abstract class AbstractLeastSquaresOptimizer implements DifferentiableMultivariateVectorialOptimizer { public static final int DEFAULT_MAX_ITERATIONS = 100; protected VectorialConvergenceChecker checker; protected double[][] jacobian; protected int cols; protected int rows; protected double[] targetValues; protected double[] residualsWeights; protected double[] point; protected double[] objective; protected double[] residuals; protected double cost; private int maxIterations; private int iterations; private int maxEvaluations; private int objectiveEvaluations; private int jacobianEvaluations; private DifferentiableMultivariateVectorialFunction function; private MultivariateMatrixFunction jF; protected AbstractLeastSquaresOptimizer() {\n        setConvergenceChecker(new SimpleVectorialValueChecker());\n        setMaxIterations(DEFAULT_MAX_ITERATIONS);\n        setMaxEvaluations(Integer.MAX_VALUE);\n    }\n\n    \n    public void setMaxIterations(int maxIterations) {\n        this.maxIterations = maxIterations;\n    }\n\n    \n    public int getMaxIterations() {\n        return maxIterations;\n    }\n\n    \n    public int getIterations() {\n        return iterations;\n    }\n\n    \n    public void setMaxEvaluations(int maxEvaluations) {\n        this.maxEvaluations = maxEvaluations;\n    }\n\n    \n    public int getMaxEvaluations() {\n        return maxEvaluations;\n    }\n\n    \n    public int getEvaluations() {\n        return objectiveEvaluations;\n    }\n\n    \n    public int getJacobianEvaluations() {\n        return jacobianEvaluations;\n    }\n\n    \n    public void setConvergenceChecker(VectorialConvergenceChecker convergenceChecker) {\n        this.checker = convergenceChecker;\n    }\n\n    \n    public VectorialConvergenceChecker getConvergenceChecker() {\n        return checker;\n    }\n\n    \n    protected void incrementIterationsCounter() throws OptimizationException {\n        if (++iterations > maxIterations) {\n            throw new OptimizationException(new MaxIterationsExceededException(maxIterations));\n        }\n    }\n\n    \n    protected void updateJacobian() throws FunctionEvaluationException {\n        ++jacobianEvaluations;\n        jacobian = jF.value(point);\n        if (jacobian.length != rows) {\n            throw new FunctionEvaluationException(point, LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE,\n                                                  jacobian.length, rows);\n        }\n        for (int i = 0; i < rows; i++) {\n            final double[] ji = jacobian[i];\n            final double factor = -Math.sqrt(residualsWeights[i]);\n            for (int j = 0; j < cols; ++j) {\n                ji[j] *= factor;\n            }\n        }\n    }\n\n    \n    protected void updateResidualsAndCost() throws FunctionEvaluationException {\n\n        if (++objectiveEvaluations > maxEvaluations) {\n            throw new FunctionEvaluationException(new MaxEvaluationsExceededException(maxEvaluations),\n                                                  point);\n        }\n        objective = function.value(point);\n        if (objective.length != rows) {\n            throw new FunctionEvaluationException(point, LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE,\n                                                  objective.length, rows);\n        }\n        cost = 0;\n        int index = 0;\n        for (int i = 0; i < rows; i++) {\n            final double residual = targetValues[i] - objective[i];\n            residuals[i] = residual;\n            cost += residualsWeights[i] * residual * residual;\n            index += cols;\n        }\n        cost = Math.sqrt(cost);\n\n    }\n\n    \n    public double getRMS() {\n        return Math.sqrt(getChiSquare() / rows);\n    }\n\n    \n    public double getChiSquare() {\n        double chiSquare = 0;\n        for (int i = 0; i < rows; ++i) {\n            final double residual = residuals[i];\n            chiSquare += residual * residual * residualsWeights[i];\n        }\n        return chiSquare;\n    }\n\n    \n    public double[][] getCovariances() throws FunctionEvaluationException, OptimizationException {\n\n        \n        updateJacobian();\n\n        \n        double[][] jTj = new double[cols][cols];\n        for (int i = 0; i < cols; ++i) {\n            for (int j = i; j < cols; ++j) {\n                double sum = 0;\n                for (int k = 0; k < rows; ++k) {\n                    sum += jacobian[k][i] * jacobian[k][j];\n                }\n                jTj[i][j] = sum;\n                jTj[j][i] = sum;\n            }\n        }\n\n        try {\n            \n            RealMatrix inverse =\n                new LUDecompositionImpl(MatrixUtils.createRealMatrix(jTj)).getSolver().getInverse();\n            return inverse.getData();\n        } catch (InvalidMatrixException ime) {\n            throw new OptimizationException(LocalizedFormats.UNABLE_TO_COMPUTE_COVARIANCE_SINGULAR_PROBLEM);\n        }\n\n    }\n\n    \n    public double[] guessParametersErrors() throws FunctionEvaluationException, OptimizationException {\n        if (rows <= cols) {\n            throw new OptimizationException(\n                    LocalizedFormats.NO_DEGREES_OF_FREEDOM,\n                    rows, cols);\n        }\n        double[] errors = new double[cols];\n        final double c = Math.sqrt(getChiSquare() / (rows - cols));\n        double[][] covar = getCovariances();\n        for (int i = 0; i < errors.length; ++i) {\n            errors[i] = Math.sqrt(covar[i][i]) * c;\n        }\n        return errors;\n    }\n\n    \n    public VectorialPointValuePair optimize(final DifferentiableMultivariateVectorialFunction f, final double[] target, final double[] weights, final double[] startPoint) throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n        if (target.length != weights.length) {\n            throw new OptimizationException(LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE,\n                                            target.length, weights.length);\n        }\n\n        \n        iterations           = 0;\n        objectiveEvaluations = 0;\n        jacobianEvaluations  = 0;\n\n        \n        function         = f;\n        jF               = f.jacobian();\n        targetValues     = target.clone();\n        residualsWeights = weights.clone();\n        this.point       = startPoint.clone();\n        this.residuals   = new double[target.length];\n\n        \n        rows      = target.length;\n        cols      = point.length;\n        jacobian  = new double[rows][cols];\n\n        cost = Double.POSITIVE_INFINITY;\n\n        return doOptimize();\n\n    }\n\n    \n    protected abstract VectorialPointValuePair doOptimize()\n        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException;\n\n}\n",
      "buggy_signatures": [
        "public void setMaxIterations(int maxIterations)",
        "public int getMaxIterations()",
        "public int getIterations()",
        "public void setMaxEvaluations(int maxEvaluations)",
        "public int getMaxEvaluations()",
        "public int getEvaluations()",
        "public int getJacobianEvaluations()",
        "public void setConvergenceChecker(VectorialConvergenceChecker convergenceChecker)",
        "public VectorialConvergenceChecker getConvergenceChecker()",
        "protected void incrementIterationsCounter() throws OptimizationException",
        "protected void updateJacobian() throws FunctionEvaluationException",
        "protected void updateResidualsAndCost() throws FunctionEvaluationException",
        "public double getRMS()",
        "public double getChiSquare()",
        "public double[][] getCovariances() throws FunctionEvaluationException, OptimizationException",
        "public double[] guessParametersErrors() throws FunctionEvaluationException, OptimizationException",
        "public VectorialPointValuePair optimize(final DifferentiableMultivariateVectorialFunction f, final double[] target, final double[] weights, final double[] startPoint) throws FunctionEvaluationException, OptimizationException, IllegalArgumentException"
      ],
      "fixed_signatures": [
        "public void setMaxIterations(int maxIterations)",
        "public int getMaxIterations()",
        "public int getIterations()",
        "public void setMaxEvaluations(int maxEvaluations)",
        "public int getMaxEvaluations()",
        "public int getEvaluations()",
        "public int getJacobianEvaluations()",
        "public void setConvergenceChecker(VectorialConvergenceChecker convergenceChecker)",
        "public VectorialConvergenceChecker getConvergenceChecker()",
        "protected void incrementIterationsCounter() throws OptimizationException",
        "protected void updateJacobian() throws FunctionEvaluationException",
        "protected void updateResidualsAndCost() throws FunctionEvaluationException",
        "public double getRMS()",
        "public double getChiSquare()",
        "public double[][] getCovariances() throws FunctionEvaluationException, OptimizationException",
        "public double[] guessParametersErrors() throws FunctionEvaluationException, OptimizationException",
        "public VectorialPointValuePair optimize(final DifferentiableMultivariateVectorialFunction f, final double[] target, final double[] weights, final double[] startPoint) throws FunctionEvaluationException, OptimizationException, IllegalArgumentException"
      ],
      "methods": [
        {
          "buggy_method": "  public double getRMS() {\n  double criterion = 0;\n  for (int i = 0; i < rows; ++i) {\n  final double residual = residuals[i];\n  criterion += residual * residual * residualsWeights[i];\n  }\n  return Math.sqrt(criterion / rows);\n  }",
          "fixed_method": "  public double getRMS() {\n  return Math.sqrt(getChiSquare() / rows);\n  }",
          "diff": [
            "@@ -237,12 +237,7 @@",
            "      * @return RMS value\n",
            "      */\n",
            "     public double getRMS() {\n",
            "-        double criterion = 0;\n",
            "-        for (int i = 0; i < rows; ++i) {\n",
            "-            final double residual = residuals[i];\n",
            "-            criterion += residual * residual * residualsWeights[i];\n",
            "-        }\n",
            "-        return Math.sqrt(criterion / rows);\n",
            "+        return Math.sqrt(getChiSquare() / rows);\n",
            "     }\n",
            " \n",
            "     /**\n"
          ],
          "changed_lines": 7
        },
        {
          "buggy_method": "  public double getChiSquare() {\n  double chiSquare = 0;\n  for (int i = 0; i < rows; ++i) {\n  final double residual = residuals[i];\n  chiSquare += residual * residual / residualsWeights[i];\n  }\n  return chiSquare;\n  }",
          "fixed_method": "  public double getChiSquare() {\n  double chiSquare = 0;\n  for (int i = 0; i < rows; ++i) {\n  final double residual = residuals[i];\n  chiSquare += residual * residual * residualsWeights[i];\n  }\n  return chiSquare;\n  }",
          "diff": [
            "@@ -255,7 +250,7 @@",
            "         double chiSquare = 0;\n",
            "         for (int i = 0; i < rows; ++i) {\n",
            "             final double residual = residuals[i];\n",
            "-            chiSquare += residual * residual / residualsWeights[i];\n",
            "+            chiSquare += residual * residual * residualsWeights[i];\n",
            "         }\n",
            "         return chiSquare;\n",
            "     }\n"
          ],
          "changed_lines": 2
        }
      ]
    }
  ]
}
