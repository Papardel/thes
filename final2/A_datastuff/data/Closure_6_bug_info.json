{
  "bug_id": "6",
  "failed_tests": {
    "com.google.javascript.jscomp.LooseTypeCheckTest": [
      {
        "methodName": "testTypeRedefinition",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<2> but was:<1>",
        "fail_line": "    testClosureTypesMultipleWarnings(",
        "test_source": "  public void testTypeRedefinition() throws Exception {\n  testClosureTypesMultipleWarnings(\n  \"a={};/**@enum {string}*/ a.A = {ZOR:'b'};\"\n  + \"/** @constructor */ a.A = function() {}\",\n  Lists.newArrayList(\n  \"variable a.A redefined with type function (new:a.A): undefined, \" +\n  \"original definition at [testcode]:1 with type enum{a.A}\",\n  \"assignment to property A of a\\n\" +\n  \"found  : function (new:a.A): undefined\\n\" +\n  \"required: enum{a.A}\"));\n  }",
        "stack": [
          "LooseTypeCheckTest.testClosureTypesMultipleWarnings line 6939, LooseTypeCheckTest.testTypeRedefinition line 2121"
        ]
      }
    ],
    "com.google.javascript.jscomp.TypeCheckTest": [
      {
        "methodName": "testIssue635b",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected a warning",
        "fail_line": "    testTypes(",
        "test_source": "  public void testIssue635b() throws Exception {\n  testTypes(\n  \"/** @constructor */\" +\n  \"function F() {}\" +\n  \"/** @constructor */\" +\n  \"function G() {}\" +\n  \"/** @type {function(new:G)} */ var x = F;\",\n  \"initializing variable\\n\" +\n  \"found  : function (new:F): undefined\\n\" +\n  \"required: function (new:G): ?\");\n  }",
        "stack": [
          "TypeCheckTest.testTypes line 10911, TypeCheckTest.testTypes line 10891, TypeCheckTest.testTypes line 10827, TypeCheckTest.testIssue635b line 6342"
        ]
      },
      {
        "methodName": "testTypeRedefinition",
        "error": "junit.framework.AssertionFailedError",
        "message": "unexpected warning(s) : JSC_DUP_VAR_DECLARATION. variable a.A redefined with type function (new:a.A): undefined, original definition at [testcode]:1 with type enum{a.A} at [testcode] line 1 : 61 expected:<2> but was:<1>",
        "fail_line": "    testClosureTypesMultipleWarnings(\"a={};/**@enum {string}*/ a.A = {ZOR:'b'};\"",
        "test_source": "  public void testTypeRedefinition() throws Exception {\n  testClosureTypesMultipleWarnings(\"a={};/**@enum {string}*/ a.A = {ZOR:'b'};\"\n  + \"/** @constructor */ a.A = function() {}\",\n  Lists.newArrayList(\n  \"variable a.A redefined with type function (new:a.A): undefined, \" +\n  \"original definition at [testcode]:1 with type enum{a.A}\",\n  \"assignment to property A of a\\n\" +\n  \"found  : function (new:a.A): undefined\\n\" +\n  \"required: enum{a.A}\"));\n  }",
        "stack": [
          "TypeCheckTest.testClosureTypesMultipleWarnings line 10876, TypeCheckTest.testTypeRedefinition line 2516"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "com/google/javascript/jscomp/TypeValidator.java",
      "buggy_full_code": "\n\npackage com.google.javascript.jscomp;\n\nimport static com.google.javascript.rhino.jstype.JSTypeNative.ARRAY_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.BOOLEAN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NO_OBJECT_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NULL_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_STRING; import static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.OBJECT_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.STRING_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.UNKNOWN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.VOID_TYPE; import com.google.common.base.Objects; import com.google.common.base.Preconditions; import com.google.common.collect.Lists; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.jstype.FunctionType; import com.google.javascript.rhino.jstype.JSType; import com.google.javascript.rhino.jstype.JSTypeNative; import com.google.javascript.rhino.jstype.JSTypeRegistry; import com.google.javascript.rhino.jstype.ObjectType; import com.google.javascript.rhino.jstype.StaticSlot; import com.google.javascript.rhino.jstype.UnknownType; import java.text.MessageFormat; import java.util.Iterator; import java.util.List; class TypeValidator { private final AbstractCompiler compiler; private final JSTypeRegistry typeRegistry; private final JSType allValueTypes; private boolean shouldReport = true; private final JSType nullOrUndefined; private final List<TypeMismatch> mismatches = Lists.newArrayList(); private static final String FOUND_REQUIRED = \" {0}\\n\" +\n      \"found   : {1}\\n\" +\n      \"required: {2}\";\n\n  static final DiagnosticType INVALID_CAST = DiagnosticType.warning(\"JSC_INVALID_CAST\", \"invalid cast - must be a subtype or supertype\\n\" + \"from: {0}\\n\" + \"to : {1}\"); static final DiagnosticType TYPE_MISMATCH_WARNING = DiagnosticType.warning( \"JSC_TYPE_MISMATCH\", \" {0}\");\n\n  static final DiagnosticType MISSING_EXTENDS_TAG_WARNING = DiagnosticType.warning( \"JSC_MISSING_EXTENDS_TAG\", \"Missing @extends tag on type {0}\"); static final DiagnosticType DUP_VAR_DECLARATION = DiagnosticType.warning(\"JSC_DUP_VAR_DECLARATION\", \"variable {0} redefined with type {1}, \" +\n          \"original definition at {2}:{3} with type {4}\");\n\n  static final DiagnosticType HIDDEN_PROPERTY_MISMATCH = DiagnosticType.warning(\"JSC_HIDDEN_PROPERTY_MISMATCH\", \"mismatch of the {0} property type and the type \" + \"of the property it overrides from superclass {1}\\n\" + \"original: {2}\\n\" + \"override: {3}\"); static final DiagnosticType INTERFACE_METHOD_NOT_IMPLEMENTED = DiagnosticType.warning( \"JSC_INTERFACE_METHOD_NOT_IMPLEMENTED\", \"property {0} on interface {1} is not implemented by type {2}\");\n\n  static final DiagnosticType HIDDEN_INTERFACE_PROPERTY_MISMATCH = DiagnosticType.warning( \"JSC_HIDDEN_INTERFACE_PROPERTY_MISMATCH\", \"mismatch of the {0} property type and the type \" + \"of the property it overrides from interface {1}\\n\" + \"original: {2}\\n\" + \"override: {3}\"); static final DiagnosticType UNKNOWN_TYPEOF_VALUE = DiagnosticType.warning(\"JSC_UNKNOWN_TYPEOF_VALUE\", \"unknown type: {0}\");\n\n  static final DiagnosticType ILLEGAL_PROPERTY_ACCESS = DiagnosticType.warning(\"JSC_ILLEGAL_PROPERTY_ACCESS\", \"Cannot do {0} access on a {1}\"); static final DiagnosticGroup ALL_DIAGNOSTICS = new DiagnosticGroup( INVALID_CAST, TYPE_MISMATCH_WARNING, MISSING_EXTENDS_TAG_WARNING, DUP_VAR_DECLARATION, HIDDEN_PROPERTY_MISMATCH, INTERFACE_METHOD_NOT_IMPLEMENTED, HIDDEN_INTERFACE_PROPERTY_MISMATCH, UNKNOWN_TYPEOF_VALUE, ILLEGAL_PROPERTY_ACCESS); TypeValidator(AbstractCompiler compiler) {\n    this.compiler = compiler;\n    this.typeRegistry = compiler.getTypeRegistry();\n    this.allValueTypes = typeRegistry.createUnionType(\n        STRING_TYPE, NUMBER_TYPE, BOOLEAN_TYPE, NULL_TYPE, VOID_TYPE);\n    this.nullOrUndefined = typeRegistry.createUnionType(\n        NULL_TYPE, VOID_TYPE);\n  }\n\n  \n  Iterable<TypeMismatch> getMismatches() {\n    return mismatches;\n  }\n\n  void setShouldReport(boolean report) {\n    this.shouldReport = report;\n  }\n\n  \n  \n  \n  \n\n  void expectValidTypeofName(NodeTraversal t, Node n, String found) {\n    report(JSError.make(t.getSourceName(), n, UNKNOWN_TYPEOF_VALUE, found));\n  }\n\n  \n  boolean expectObject(NodeTraversal t, Node n, JSType type, String msg) {\n    if (!type.matchesObjectContext()) {\n      mismatch(t, n, msg, type, OBJECT_TYPE);\n      return false;\n    }\n    return true;\n  }\n\n  \n  void expectActualObject(NodeTraversal t, Node n, JSType type, String msg) {\n    if (!type.isObject()) {\n      mismatch(t, n, msg, type, OBJECT_TYPE);\n    }\n  }\n\n  \n  void expectAnyObject(NodeTraversal t, Node n, JSType type, String msg) {\n    JSType anyObjectType = getNativeType(NO_OBJECT_TYPE);\n    if (!anyObjectType.isSubtype(type) && !type.isEmptyType()) {\n      mismatch(t, n, msg, type, anyObjectType);\n    }\n  }\n\n  \n  void expectString(NodeTraversal t, Node n, JSType type, String msg) {\n    if (!type.matchesStringContext()) {\n      mismatch(t, n, msg, type, STRING_TYPE);\n    }\n  }\n\n  \n  void expectNumber(NodeTraversal t, Node n, JSType type, String msg) {\n    if (!type.matchesNumberContext()) {\n      mismatch(t, n, msg, type, NUMBER_TYPE);\n    }\n  }\n\n  \n  void expectBitwiseable(NodeTraversal t, Node n, JSType type, String msg) {\n    if (!type.matchesNumberContext() && !type.isSubtype(allValueTypes)) {\n      mismatch(t, n, msg, type, allValueTypes);\n    }\n  }\n\n  \n  void expectStringOrNumber(\n      NodeTraversal t, Node n, JSType type, String msg) {\n    if (!type.matchesNumberContext() && !type.matchesStringContext()) {\n      mismatch(t, n, msg, type, NUMBER_STRING);\n    }\n  }\n\n  \n  boolean expectNotNullOrUndefined(\n      NodeTraversal t, Node n, JSType type, String msg, JSType expectedType) {\n    if (!type.isNoType() && !type.isUnknownType() &&\n        type.isSubtype(nullOrUndefined) &&\n        !containsForwardDeclaredUnresolvedName(type)) {\n\n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      if (n.isGetProp() &&\n          !t.inGlobalScope() && type.isNullType()) {\n        return true;\n      }\n\n      mismatch(t, n, msg, type, expectedType);\n      return false;\n    }\n    return true;\n  }\n\n  private boolean containsForwardDeclaredUnresolvedName(JSType type) {\n    if (type.isUnionType()) {\n      for (JSType alt : type.toMaybeUnionType().getAlternates()) {\n        if (containsForwardDeclaredUnresolvedName(alt)) {\n          return true;\n        }\n      }\n    }\n    return type.isNoResolvedType();\n  }\n\n  \n  void expectSwitchMatchesCase(NodeTraversal t, Node n, JSType switchType,\n      JSType caseType) {\n    \n    \n    \n    \n    if (!switchType.canTestForShallowEqualityWith(caseType) &&\n        (caseType.autoboxesTo() == null ||\n            !caseType.autoboxesTo().isSubtype(switchType))) {\n      mismatch(t, n.getFirstChild(),\n          \"case expression doesn't match switch\",\n          caseType, switchType);\n    }\n  }\n\n  \n  void expectIndexMatch(NodeTraversal t, Node n, JSType objType,\n                        JSType indexType) {\n    Preconditions.checkState(n.isGetElem());\n    Node indexNode = n.getLastChild();\n    if (objType.isStruct()) {\n      report(JSError.make(t.getSourceName(), indexNode,\n                          ILLEGAL_PROPERTY_ACCESS, \"'[]'\", \"struct\"));\n    }\n    if (objType.isUnknownType()) {\n      expectStringOrNumber(t, indexNode, indexType, \"property access\");\n    } else {\n      ObjectType dereferenced = objType.dereference();\n      if (dereferenced != null && dereferenced.getIndexType() != null) {\n        expectCanAssignTo(t, indexNode, indexType, dereferenced.getIndexType(),\n            \"restricted index type\");\n      } else if (dereferenced != null && dereferenced.isArrayType()) {\n        expectNumber(t, indexNode, indexType, \"array access\");\n      } else if (objType.matchesObjectContext()) {\n        expectString(t, indexNode, indexType, \"property access\");\n      } else {\n        mismatch(t, n, \"only arrays or objects can be accessed\",\n            objType,\n            typeRegistry.createUnionType(ARRAY_TYPE, OBJECT_TYPE));\n      }\n    }\n  }\n\n  \n  boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType,\n      JSType leftType, Node owner, String propName) {\n    \n    if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) {\n      if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n      \n      \n      \n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      }\n      return false;\n    }\n    return true;\n  }\n\n  \n  boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType,\n      JSType leftType, String msg) {\n    if (!rightType.canAssignTo(leftType)) {\n      if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n      mismatch(t, n, msg, rightType, leftType);\n      }\n      return false;\n    }\n    return true;\n  }\n\n  \n  void expectArgumentMatchesParameter(NodeTraversal t, Node n, JSType argType,\n      JSType paramType, Node callNode, int ordinal) {\n    if (!argType.canAssignTo(paramType)) {\n      mismatch(t, n,\n          String.format(\"actual parameter %d of %s does not match \" +\n              \"formal parameter\", ordinal,\n              getReadableJSTypeName(callNode.getFirstChild(), false)),\n          argType, paramType);\n    }\n  }\n\n  \n  void expectCanOverride(NodeTraversal t, Node n, JSType overridingType,\n      JSType hiddenType, String propertyName, JSType ownerType) {\n    if (!overridingType.canAssignTo(hiddenType)) {\n      registerMismatch(overridingType, hiddenType,\n          report(t.makeError(n, HIDDEN_PROPERTY_MISMATCH, propertyName,\n            ownerType.toString(), hiddenType.toString(),\n            overridingType.toString())));\n    }\n  }\n\n  \n  void expectSuperType(NodeTraversal t, Node n, ObjectType superObject,\n      ObjectType subObject) {\n    FunctionType subCtor = subObject.getConstructor();\n    ObjectType implicitProto = subObject.getImplicitPrototype();\n    ObjectType declaredSuper =\n        implicitProto == null ? null : implicitProto.getImplicitPrototype();\n    if (declaredSuper != null &&\n        !(superObject instanceof UnknownType) &&\n        !declaredSuper.isEquivalentTo(superObject)) {\n      if (declaredSuper.isEquivalentTo(getNativeType(OBJECT_TYPE))) {\n        registerMismatch(superObject, declaredSuper, report(\n            t.makeError(n, MISSING_EXTENDS_TAG_WARNING, subObject.toString())));\n      } else {\n        mismatch(t.getSourceName(), n,\n            \"mismatch in declaration of superclass type\",\n            superObject, declaredSuper);\n      }\n\n      \n      if (!subCtor.hasCachedValues()) {\n        subCtor.setPrototypeBasedOn(superObject);\n      }\n    }\n  }\n\n  \n  void expectCanCast(NodeTraversal t, Node n, JSType type, JSType castType) {\n    castType = castType.restrictByNotNullOrUndefined();\n    type = type.restrictByNotNullOrUndefined();\n\n    if (!type.canAssignTo(castType) && !castType.canAssignTo(type)) {\n      registerMismatch(type, castType, report(t.makeError(n, INVALID_CAST,\n          castType.toString(), type.toString())));\n    }\n  }\n\n  \n  Var expectUndeclaredVariable(String sourceName, CompilerInput input,\n      Node n, Node parent, Var var, String variableName, JSType newType) {\n    Var newVar = var;\n    boolean allowDupe = false;\n    if (n.isGetProp() ||\n        NodeUtil.isObjectLitKey(n, parent)) {\n      JSDocInfo info = n.getJSDocInfo();\n      if (info == null) {\n        info = parent.getJSDocInfo();\n      }\n      allowDupe =\n          info != null && info.getSuppressions().contains(\"duplicate\");\n    }\n\n    JSType varType = var.getType();\n\n    \n    \n    \n    if (varType != null &&\n        varType != typeRegistry.getNativeType(UNKNOWN_TYPE) &&\n        newType != null &&\n        newType != typeRegistry.getNativeType(UNKNOWN_TYPE)) {\n      \n      \n      \n      \n      \n      if (var.input == null) {\n        Scope s = var.getScope();\n        s.undeclare(var);\n        newVar = s.declare(variableName, n, varType, input, false);\n\n        n.setJSType(varType);\n        if (parent.isVar()) {\n          if (n.getFirstChild() != null) {\n            n.getFirstChild().setJSType(varType);\n          }\n        } else {\n          Preconditions.checkState(parent.isFunction());\n          parent.setJSType(varType);\n        }\n      } else {\n        \n        \n        \n        \n        \n        if (!(allowDupe ||\n              var.getParentNode().isExprResult()) ||\n            !newType.isEquivalentTo(varType)) {\n          report(JSError.make(sourceName, n, DUP_VAR_DECLARATION,\n              variableName, newType.toString(), var.getInputName(),\n              String.valueOf(var.nameNode.getLineno()),\n              varType.toString()));\n        }\n      }\n    }\n\n    return newVar;\n  }\n\n  \n  void expectAllInterfaceProperties(NodeTraversal t, Node n,\n      FunctionType type) {\n    ObjectType instance = type.getInstanceType();\n    for (ObjectType implemented : type.getAllImplementedInterfaces()) {\n      if (implemented.getImplicitPrototype() != null) {\n        for (String prop :\n             implemented.getImplicitPrototype().getOwnPropertyNames()) {\n          expectInterfaceProperty(t, n, instance, implemented, prop);\n        }\n      }\n    }\n  }\n\n  \n  private void expectInterfaceProperty(NodeTraversal t, Node n, ObjectType instance, ObjectType implementedInterface, String prop) {\n    StaticSlot<JSType> propSlot = instance.getSlot(prop);\n    if (propSlot == null) {\n      \n      String sourceName = n.getSourceFileName();\n      sourceName = sourceName == null ? \"\" : sourceName;\n      registerMismatch(instance, implementedInterface,\n          report(JSError.make(sourceName, n,\n          INTERFACE_METHOD_NOT_IMPLEMENTED,\n          prop, implementedInterface.toString(), instance.toString())));\n    } else {\n      Node propNode = propSlot.getDeclaration() == null ?\n          null : propSlot.getDeclaration().getNode();\n\n      \n      \n      propNode = propNode == null ? n : propNode;\n\n      JSType found = propSlot.getType();\n      JSType required\n          = implementedInterface.getImplicitPrototype().getPropertyType(prop);\n      found = found.restrictByNotNullOrUndefined();\n      required = required.restrictByNotNullOrUndefined();\n      if (!found.canAssignTo(required)) {\n        \n        FunctionType constructor =\n            implementedInterface.toObjectType().getConstructor();\n        registerMismatch(found, required, report(t.makeError(propNode,\n            HIDDEN_INTERFACE_PROPERTY_MISMATCH, prop,\n            constructor.getTopMostDefiningType(prop).toString(),\n            required.toString(), found.toString())));\n      }\n    }\n  }\n\n  \n  private void mismatch(NodeTraversal t, Node n, String msg, JSType found, JSType required) {\n    mismatch(t.getSourceName(), n, msg, found, required);\n  }\n\n  private void mismatch(NodeTraversal t, Node n, String msg, JSType found, JSTypeNative required) {\n    mismatch(t, n, msg, found, getNativeType(required));\n  }\n\n  private void mismatch(String sourceName, Node n, String msg, JSType found, JSType required) {\n    registerMismatch(found, required, report(\n        JSError.make(sourceName, n, TYPE_MISMATCH_WARNING,\n                     formatFoundRequired(msg, found, required))));\n  }\n\n  private void registerMismatch(JSType found, JSType required, JSError error) {\n    \n    \n    found = found.restrictByNotNullOrUndefined();\n    required = required.restrictByNotNullOrUndefined();\n    if (found.canAssignTo(required) || required.canAssignTo(found)) {\n      return;\n    }\n\n    mismatches.add(new TypeMismatch(found, required, error));\n    if (found.isFunctionType() &&\n        required.isFunctionType()) {\n      FunctionType fnTypeA = found.toMaybeFunctionType();\n      FunctionType fnTypeB = required.toMaybeFunctionType();\n      Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n      Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n      while (paramItA.hasNext() && paramItB.hasNext()) {\n        registerIfMismatch(paramItA.next().getJSType(),\n            paramItB.next().getJSType(), error);\n      }\n\n      registerIfMismatch(\n          fnTypeA.getReturnType(), fnTypeB.getReturnType(), error);\n    }\n  }\n\n  private void registerIfMismatch( JSType found, JSType required, JSError error) {\n    if (found != null && required != null &&\n        !found.canAssignTo(required)) {\n      registerMismatch(found, required, error);\n    }\n  }\n\n  \n  private String formatFoundRequired(String description, JSType found, JSType required) {\n    return MessageFormat.format(FOUND_REQUIRED, description, found, required);\n  }\n\n  \n  String getReadableJSTypeName(Node n, boolean dereference) {\n    \n    \n    \n    if (n.isGetProp()) {\n      ObjectType objectType = getJSType(n.getFirstChild()).dereference();\n      if (objectType != null) {\n        String propName = n.getLastChild().getString();\n        if (objectType.getConstructor() != null &&\n            objectType.getConstructor().isInterface()) {\n          objectType = FunctionType.getTopDefiningInterface(\n              objectType, propName);\n        } else {\n          \n          while (objectType != null && !objectType.hasOwnProperty(propName)) {\n            objectType = objectType.getImplicitPrototype();\n          }\n        }\n\n        \n        \n        if (objectType != null &&\n            (objectType.getConstructor() != null ||\n             objectType.isFunctionPrototypeType())) {\n          return objectType.toString() + \".\" + propName;\n        }\n      }\n    }\n\n    JSType type = getJSType(n);\n    if (dereference) {\n      ObjectType dereferenced = type.dereference();\n      if (dereferenced != null) {\n        type = dereferenced;\n      }\n    }\n\n    String qualifiedName = n.getQualifiedName();\n    if (type.isFunctionPrototypeType() ||\n        (type.toObjectType() != null &&\n         type.toObjectType().getConstructor() != null)) {\n      return type.toString();\n    } else if (qualifiedName != null) {\n      return qualifiedName;\n    } else if (type.isFunctionType()) {\n      \n      return \"function\";\n    } else {\n      return type.toString();\n    }\n  }\n\n  \n  private JSType getJSType(Node n) {\n    JSType jsType = n.getJSType();\n    if (jsType == null) {\n      \n      \n      \n      \n      return getNativeType(UNKNOWN_TYPE);\n    } else {\n      return jsType;\n    }\n  }\n\n  private JSType getNativeType(JSTypeNative typeId) {\n    return typeRegistry.getNativeType(typeId);\n  }\n\n  private JSError report(JSError error) {\n    if (shouldReport) {\n      compiler.report(error);\n    }\n    return error;\n  }\n\n  \n  static class TypeMismatch { final JSType typeA; final JSType typeB; final JSError src; TypeMismatch(JSType a, JSType b, JSError src) {\n      this.typeA = a;\n      this.typeB = b;\n      this.src = src;\n    }\n\n    @Override public boolean equals(Object object) {\n      if (object instanceof TypeMismatch) {\n        TypeMismatch that = (TypeMismatch) object;\n        return (that.typeA.isEquivalentTo(this.typeA)\n                && that.typeB.isEquivalentTo(this.typeB))\n            || (that.typeB.isEquivalentTo(this.typeA)\n                && that.typeA.isEquivalentTo(this.typeB));\n      }\n      return false;\n    }\n\n    @Override public int hashCode() {\n      return Objects.hashCode(typeA, typeB);\n    }\n\n    @Override public String toString() {\n      return \"(\" + typeA + \", \" + typeB + \")\";\n    }\n  }\n}\n",
      "fixed_full_code": "\n\npackage com.google.javascript.jscomp;\n\nimport static com.google.javascript.rhino.jstype.JSTypeNative.ARRAY_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.BOOLEAN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NO_OBJECT_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NULL_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_STRING; import static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.OBJECT_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.STRING_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.UNKNOWN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.VOID_TYPE; import com.google.common.base.Objects; import com.google.common.base.Preconditions; import com.google.common.collect.Lists; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.jstype.FunctionType; import com.google.javascript.rhino.jstype.JSType; import com.google.javascript.rhino.jstype.JSTypeNative; import com.google.javascript.rhino.jstype.JSTypeRegistry; import com.google.javascript.rhino.jstype.ObjectType; import com.google.javascript.rhino.jstype.StaticSlot; import com.google.javascript.rhino.jstype.UnknownType; import java.text.MessageFormat; import java.util.Iterator; import java.util.List; class TypeValidator { private final AbstractCompiler compiler; private final JSTypeRegistry typeRegistry; private final JSType allValueTypes; private boolean shouldReport = true; private final JSType nullOrUndefined; private final List<TypeMismatch> mismatches = Lists.newArrayList(); private static final String FOUND_REQUIRED = \" {0}\\n\" +\n      \"found   : {1}\\n\" +\n      \"required: {2}\";\n\n  static final DiagnosticType INVALID_CAST = DiagnosticType.warning(\"JSC_INVALID_CAST\", \"invalid cast - must be a subtype or supertype\\n\" + \"from: {0}\\n\" + \"to : {1}\"); static final DiagnosticType TYPE_MISMATCH_WARNING = DiagnosticType.warning( \"JSC_TYPE_MISMATCH\", \" {0}\");\n\n  static final DiagnosticType MISSING_EXTENDS_TAG_WARNING = DiagnosticType.warning( \"JSC_MISSING_EXTENDS_TAG\", \"Missing @extends tag on type {0}\"); static final DiagnosticType DUP_VAR_DECLARATION = DiagnosticType.warning(\"JSC_DUP_VAR_DECLARATION\", \"variable {0} redefined with type {1}, \" +\n          \"original definition at {2}:{3} with type {4}\");\n\n  static final DiagnosticType HIDDEN_PROPERTY_MISMATCH = DiagnosticType.warning(\"JSC_HIDDEN_PROPERTY_MISMATCH\", \"mismatch of the {0} property type and the type \" + \"of the property it overrides from superclass {1}\\n\" + \"original: {2}\\n\" + \"override: {3}\"); static final DiagnosticType INTERFACE_METHOD_NOT_IMPLEMENTED = DiagnosticType.warning( \"JSC_INTERFACE_METHOD_NOT_IMPLEMENTED\", \"property {0} on interface {1} is not implemented by type {2}\");\n\n  static final DiagnosticType HIDDEN_INTERFACE_PROPERTY_MISMATCH = DiagnosticType.warning( \"JSC_HIDDEN_INTERFACE_PROPERTY_MISMATCH\", \"mismatch of the {0} property type and the type \" + \"of the property it overrides from interface {1}\\n\" + \"original: {2}\\n\" + \"override: {3}\"); static final DiagnosticType UNKNOWN_TYPEOF_VALUE = DiagnosticType.warning(\"JSC_UNKNOWN_TYPEOF_VALUE\", \"unknown type: {0}\");\n\n  static final DiagnosticType ILLEGAL_PROPERTY_ACCESS = DiagnosticType.warning(\"JSC_ILLEGAL_PROPERTY_ACCESS\", \"Cannot do {0} access on a {1}\"); static final DiagnosticGroup ALL_DIAGNOSTICS = new DiagnosticGroup( INVALID_CAST, TYPE_MISMATCH_WARNING, MISSING_EXTENDS_TAG_WARNING, DUP_VAR_DECLARATION, HIDDEN_PROPERTY_MISMATCH, INTERFACE_METHOD_NOT_IMPLEMENTED, HIDDEN_INTERFACE_PROPERTY_MISMATCH, UNKNOWN_TYPEOF_VALUE, ILLEGAL_PROPERTY_ACCESS); TypeValidator(AbstractCompiler compiler) {\n    this.compiler = compiler;\n    this.typeRegistry = compiler.getTypeRegistry();\n    this.allValueTypes = typeRegistry.createUnionType(\n        STRING_TYPE, NUMBER_TYPE, BOOLEAN_TYPE, NULL_TYPE, VOID_TYPE);\n    this.nullOrUndefined = typeRegistry.createUnionType(\n        NULL_TYPE, VOID_TYPE);\n  }\n\n  \n  Iterable<TypeMismatch> getMismatches() {\n    return mismatches;\n  }\n\n  void setShouldReport(boolean report) {\n    this.shouldReport = report;\n  }\n\n  \n  \n  \n  \n\n  void expectValidTypeofName(NodeTraversal t, Node n, String found) {\n    report(JSError.make(t.getSourceName(), n, UNKNOWN_TYPEOF_VALUE, found));\n  }\n\n  \n  boolean expectObject(NodeTraversal t, Node n, JSType type, String msg) {\n    if (!type.matchesObjectContext()) {\n      mismatch(t, n, msg, type, OBJECT_TYPE);\n      return false;\n    }\n    return true;\n  }\n\n  \n  void expectActualObject(NodeTraversal t, Node n, JSType type, String msg) {\n    if (!type.isObject()) {\n      mismatch(t, n, msg, type, OBJECT_TYPE);\n    }\n  }\n\n  \n  void expectAnyObject(NodeTraversal t, Node n, JSType type, String msg) {\n    JSType anyObjectType = getNativeType(NO_OBJECT_TYPE);\n    if (!anyObjectType.isSubtype(type) && !type.isEmptyType()) {\n      mismatch(t, n, msg, type, anyObjectType);\n    }\n  }\n\n  \n  void expectString(NodeTraversal t, Node n, JSType type, String msg) {\n    if (!type.matchesStringContext()) {\n      mismatch(t, n, msg, type, STRING_TYPE);\n    }\n  }\n\n  \n  void expectNumber(NodeTraversal t, Node n, JSType type, String msg) {\n    if (!type.matchesNumberContext()) {\n      mismatch(t, n, msg, type, NUMBER_TYPE);\n    }\n  }\n\n  \n  void expectBitwiseable(NodeTraversal t, Node n, JSType type, String msg) {\n    if (!type.matchesNumberContext() && !type.isSubtype(allValueTypes)) {\n      mismatch(t, n, msg, type, allValueTypes);\n    }\n  }\n\n  \n  void expectStringOrNumber(\n      NodeTraversal t, Node n, JSType type, String msg) {\n    if (!type.matchesNumberContext() && !type.matchesStringContext()) {\n      mismatch(t, n, msg, type, NUMBER_STRING);\n    }\n  }\n\n  \n  boolean expectNotNullOrUndefined(\n      NodeTraversal t, Node n, JSType type, String msg, JSType expectedType) {\n    if (!type.isNoType() && !type.isUnknownType() &&\n        type.isSubtype(nullOrUndefined) &&\n        !containsForwardDeclaredUnresolvedName(type)) {\n\n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      if (n.isGetProp() &&\n          !t.inGlobalScope() && type.isNullType()) {\n        return true;\n      }\n\n      mismatch(t, n, msg, type, expectedType);\n      return false;\n    }\n    return true;\n  }\n\n  private boolean containsForwardDeclaredUnresolvedName(JSType type) {\n    if (type.isUnionType()) {\n      for (JSType alt : type.toMaybeUnionType().getAlternates()) {\n        if (containsForwardDeclaredUnresolvedName(alt)) {\n          return true;\n        }\n      }\n    }\n    return type.isNoResolvedType();\n  }\n\n  \n  void expectSwitchMatchesCase(NodeTraversal t, Node n, JSType switchType,\n      JSType caseType) {\n    \n    \n    \n    \n    if (!switchType.canTestForShallowEqualityWith(caseType) &&\n        (caseType.autoboxesTo() == null ||\n            !caseType.autoboxesTo().isSubtype(switchType))) {\n      mismatch(t, n.getFirstChild(),\n          \"case expression doesn't match switch\",\n          caseType, switchType);\n    }\n  }\n\n  \n  void expectIndexMatch(NodeTraversal t, Node n, JSType objType,\n                        JSType indexType) {\n    Preconditions.checkState(n.isGetElem());\n    Node indexNode = n.getLastChild();\n    if (objType.isStruct()) {\n      report(JSError.make(t.getSourceName(), indexNode,\n                          ILLEGAL_PROPERTY_ACCESS, \"'[]'\", \"struct\"));\n    }\n    if (objType.isUnknownType()) {\n      expectStringOrNumber(t, indexNode, indexType, \"property access\");\n    } else {\n      ObjectType dereferenced = objType.dereference();\n      if (dereferenced != null && dereferenced.getIndexType() != null) {\n        expectCanAssignTo(t, indexNode, indexType, dereferenced.getIndexType(),\n            \"restricted index type\");\n      } else if (dereferenced != null && dereferenced.isArrayType()) {\n        expectNumber(t, indexNode, indexType, \"array access\");\n      } else if (objType.matchesObjectContext()) {\n        expectString(t, indexNode, indexType, \"property access\");\n      } else {\n        mismatch(t, n, \"only arrays or objects can be accessed\",\n            objType,\n            typeRegistry.createUnionType(ARRAY_TYPE, OBJECT_TYPE));\n      }\n    }\n  }\n\n  \n  boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType,\n      JSType leftType, Node owner, String propName) {\n    \n    if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) {\n      \n      \n      \n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      return false;\n    }\n    return true;\n  }\n\n  \n  boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType,\n      JSType leftType, String msg) {\n    if (!rightType.canAssignTo(leftType)) {\n      mismatch(t, n, msg, rightType, leftType);\n      return false;\n    }\n    return true;\n  }\n\n  \n  void expectArgumentMatchesParameter(NodeTraversal t, Node n, JSType argType,\n      JSType paramType, Node callNode, int ordinal) {\n    if (!argType.canAssignTo(paramType)) {\n      mismatch(t, n,\n          String.format(\"actual parameter %d of %s does not match \" +\n              \"formal parameter\", ordinal,\n              getReadableJSTypeName(callNode.getFirstChild(), false)),\n          argType, paramType);\n    }\n  }\n\n  \n  void expectCanOverride(NodeTraversal t, Node n, JSType overridingType,\n      JSType hiddenType, String propertyName, JSType ownerType) {\n    if (!overridingType.canAssignTo(hiddenType)) {\n      registerMismatch(overridingType, hiddenType,\n          report(t.makeError(n, HIDDEN_PROPERTY_MISMATCH, propertyName,\n            ownerType.toString(), hiddenType.toString(),\n            overridingType.toString())));\n    }\n  }\n\n  \n  void expectSuperType(NodeTraversal t, Node n, ObjectType superObject,\n      ObjectType subObject) {\n    FunctionType subCtor = subObject.getConstructor();\n    ObjectType implicitProto = subObject.getImplicitPrototype();\n    ObjectType declaredSuper =\n        implicitProto == null ? null : implicitProto.getImplicitPrototype();\n    if (declaredSuper != null &&\n        !(superObject instanceof UnknownType) &&\n        !declaredSuper.isEquivalentTo(superObject)) {\n      if (declaredSuper.isEquivalentTo(getNativeType(OBJECT_TYPE))) {\n        registerMismatch(superObject, declaredSuper, report(\n            t.makeError(n, MISSING_EXTENDS_TAG_WARNING, subObject.toString())));\n      } else {\n        mismatch(t.getSourceName(), n,\n            \"mismatch in declaration of superclass type\",\n            superObject, declaredSuper);\n      }\n\n      \n      if (!subCtor.hasCachedValues()) {\n        subCtor.setPrototypeBasedOn(superObject);\n      }\n    }\n  }\n\n  \n  void expectCanCast(NodeTraversal t, Node n, JSType type, JSType castType) {\n    castType = castType.restrictByNotNullOrUndefined();\n    type = type.restrictByNotNullOrUndefined();\n\n    if (!type.canAssignTo(castType) && !castType.canAssignTo(type)) {\n      registerMismatch(type, castType, report(t.makeError(n, INVALID_CAST,\n          castType.toString(), type.toString())));\n    }\n  }\n\n  \n  Var expectUndeclaredVariable(String sourceName, CompilerInput input,\n      Node n, Node parent, Var var, String variableName, JSType newType) {\n    Var newVar = var;\n    boolean allowDupe = false;\n    if (n.isGetProp() ||\n        NodeUtil.isObjectLitKey(n, parent)) {\n      JSDocInfo info = n.getJSDocInfo();\n      if (info == null) {\n        info = parent.getJSDocInfo();\n      }\n      allowDupe =\n          info != null && info.getSuppressions().contains(\"duplicate\");\n    }\n\n    JSType varType = var.getType();\n\n    \n    \n    \n    if (varType != null &&\n        varType != typeRegistry.getNativeType(UNKNOWN_TYPE) &&\n        newType != null &&\n        newType != typeRegistry.getNativeType(UNKNOWN_TYPE)) {\n      \n      \n      \n      \n      \n      if (var.input == null) {\n        Scope s = var.getScope();\n        s.undeclare(var);\n        newVar = s.declare(variableName, n, varType, input, false);\n\n        n.setJSType(varType);\n        if (parent.isVar()) {\n          if (n.getFirstChild() != null) {\n            n.getFirstChild().setJSType(varType);\n          }\n        } else {\n          Preconditions.checkState(parent.isFunction());\n          parent.setJSType(varType);\n        }\n      } else {\n        \n        \n        \n        \n        \n        if (!(allowDupe ||\n              var.getParentNode().isExprResult()) ||\n            !newType.isEquivalentTo(varType)) {\n          report(JSError.make(sourceName, n, DUP_VAR_DECLARATION,\n              variableName, newType.toString(), var.getInputName(),\n              String.valueOf(var.nameNode.getLineno()),\n              varType.toString()));\n        }\n      }\n    }\n\n    return newVar;\n  }\n\n  \n  void expectAllInterfaceProperties(NodeTraversal t, Node n,\n      FunctionType type) {\n    ObjectType instance = type.getInstanceType();\n    for (ObjectType implemented : type.getAllImplementedInterfaces()) {\n      if (implemented.getImplicitPrototype() != null) {\n        for (String prop :\n             implemented.getImplicitPrototype().getOwnPropertyNames()) {\n          expectInterfaceProperty(t, n, instance, implemented, prop);\n        }\n      }\n    }\n  }\n\n  \n  private void expectInterfaceProperty(NodeTraversal t, Node n, ObjectType instance, ObjectType implementedInterface, String prop) {\n    StaticSlot<JSType> propSlot = instance.getSlot(prop);\n    if (propSlot == null) {\n      \n      String sourceName = n.getSourceFileName();\n      sourceName = sourceName == null ? \"\" : sourceName;\n      registerMismatch(instance, implementedInterface,\n          report(JSError.make(sourceName, n,\n          INTERFACE_METHOD_NOT_IMPLEMENTED,\n          prop, implementedInterface.toString(), instance.toString())));\n    } else {\n      Node propNode = propSlot.getDeclaration() == null ?\n          null : propSlot.getDeclaration().getNode();\n\n      \n      \n      propNode = propNode == null ? n : propNode;\n\n      JSType found = propSlot.getType();\n      JSType required\n          = implementedInterface.getImplicitPrototype().getPropertyType(prop);\n      found = found.restrictByNotNullOrUndefined();\n      required = required.restrictByNotNullOrUndefined();\n      if (!found.canAssignTo(required)) {\n        \n        FunctionType constructor =\n            implementedInterface.toObjectType().getConstructor();\n        registerMismatch(found, required, report(t.makeError(propNode,\n            HIDDEN_INTERFACE_PROPERTY_MISMATCH, prop,\n            constructor.getTopMostDefiningType(prop).toString(),\n            required.toString(), found.toString())));\n      }\n    }\n  }\n\n  \n  private void mismatch(NodeTraversal t, Node n, String msg, JSType found, JSType required) {\n    mismatch(t.getSourceName(), n, msg, found, required);\n  }\n\n  private void mismatch(NodeTraversal t, Node n, String msg, JSType found, JSTypeNative required) {\n    mismatch(t, n, msg, found, getNativeType(required));\n  }\n\n  private void mismatch(String sourceName, Node n, String msg, JSType found, JSType required) {\n    registerMismatch(found, required, report(\n        JSError.make(sourceName, n, TYPE_MISMATCH_WARNING,\n                     formatFoundRequired(msg, found, required))));\n  }\n\n  private void registerMismatch(JSType found, JSType required, JSError error) {\n    \n    \n    found = found.restrictByNotNullOrUndefined();\n    required = required.restrictByNotNullOrUndefined();\n    if (found.canAssignTo(required) || required.canAssignTo(found)) {\n      return;\n    }\n\n    mismatches.add(new TypeMismatch(found, required, error));\n    if (found.isFunctionType() &&\n        required.isFunctionType()) {\n      FunctionType fnTypeA = found.toMaybeFunctionType();\n      FunctionType fnTypeB = required.toMaybeFunctionType();\n      Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n      Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n      while (paramItA.hasNext() && paramItB.hasNext()) {\n        registerIfMismatch(paramItA.next().getJSType(),\n            paramItB.next().getJSType(), error);\n      }\n\n      registerIfMismatch(\n          fnTypeA.getReturnType(), fnTypeB.getReturnType(), error);\n    }\n  }\n\n  private void registerIfMismatch( JSType found, JSType required, JSError error) {\n    if (found != null && required != null &&\n        !found.canAssignTo(required)) {\n      registerMismatch(found, required, error);\n    }\n  }\n\n  \n  private String formatFoundRequired(String description, JSType found, JSType required) {\n    return MessageFormat.format(FOUND_REQUIRED, description, found, required);\n  }\n\n  \n  String getReadableJSTypeName(Node n, boolean dereference) {\n    \n    \n    \n    if (n.isGetProp()) {\n      ObjectType objectType = getJSType(n.getFirstChild()).dereference();\n      if (objectType != null) {\n        String propName = n.getLastChild().getString();\n        if (objectType.getConstructor() != null &&\n            objectType.getConstructor().isInterface()) {\n          objectType = FunctionType.getTopDefiningInterface(\n              objectType, propName);\n        } else {\n          \n          while (objectType != null && !objectType.hasOwnProperty(propName)) {\n            objectType = objectType.getImplicitPrototype();\n          }\n        }\n\n        \n        \n        if (objectType != null &&\n            (objectType.getConstructor() != null ||\n             objectType.isFunctionPrototypeType())) {\n          return objectType.toString() + \".\" + propName;\n        }\n      }\n    }\n\n    JSType type = getJSType(n);\n    if (dereference) {\n      ObjectType dereferenced = type.dereference();\n      if (dereferenced != null) {\n        type = dereferenced;\n      }\n    }\n\n    String qualifiedName = n.getQualifiedName();\n    if (type.isFunctionPrototypeType() ||\n        (type.toObjectType() != null &&\n         type.toObjectType().getConstructor() != null)) {\n      return type.toString();\n    } else if (qualifiedName != null) {\n      return qualifiedName;\n    } else if (type.isFunctionType()) {\n      \n      return \"function\";\n    } else {\n      return type.toString();\n    }\n  }\n\n  \n  private JSType getJSType(Node n) {\n    JSType jsType = n.getJSType();\n    if (jsType == null) {\n      \n      \n      \n      \n      return getNativeType(UNKNOWN_TYPE);\n    } else {\n      return jsType;\n    }\n  }\n\n  private JSType getNativeType(JSTypeNative typeId) {\n    return typeRegistry.getNativeType(typeId);\n  }\n\n  private JSError report(JSError error) {\n    if (shouldReport) {\n      compiler.report(error);\n    }\n    return error;\n  }\n\n  \n  static class TypeMismatch { final JSType typeA; final JSType typeB; final JSError src; TypeMismatch(JSType a, JSType b, JSError src) {\n      this.typeA = a;\n      this.typeB = b;\n      this.src = src;\n    }\n\n    @Override public boolean equals(Object object) {\n      if (object instanceof TypeMismatch) {\n        TypeMismatch that = (TypeMismatch) object;\n        return (that.typeA.isEquivalentTo(this.typeA)\n                && that.typeB.isEquivalentTo(this.typeB))\n            || (that.typeB.isEquivalentTo(this.typeA)\n                && that.typeA.isEquivalentTo(this.typeB));\n      }\n      return false;\n    }\n\n    @Override public int hashCode() {\n      return Objects.hashCode(typeA, typeB);\n    }\n\n    @Override public String toString() {\n      return \"(\" + typeA + \", \" + typeB + \")\";\n    }\n  }\n}\n",
      "buggy_signatures": [
        "private boolean containsForwardDeclaredUnresolvedName(JSType type)",
        "private void expectInterfaceProperty(NodeTraversal t, Node n, ObjectType instance, ObjectType implementedInterface, String prop)",
        "private void mismatch(NodeTraversal t, Node n, String msg, JSType found, JSType required)",
        "private void mismatch(NodeTraversal t, Node n, String msg, JSType found, JSTypeNative required)",
        "private void mismatch(String sourceName, Node n, String msg, JSType found, JSType required)",
        "private void registerMismatch(JSType found, JSType required, JSError error)",
        "private void registerIfMismatch( JSType found, JSType required, JSError error)",
        "private String formatFoundRequired(String description, JSType found, JSType required)",
        "private JSType getJSType(Node n)",
        "private JSType getNativeType(JSTypeNative typeId)",
        "private JSError report(JSError error)",
        "static class TypeMismatch { final JSType typeA; final JSType typeB; final JSError src; TypeMismatch(JSType a, JSType b, JSError src)",
        "public boolean equals(Object object)",
        "public int hashCode()",
        "public String toString()"
      ],
      "fixed_signatures": [
        "private boolean containsForwardDeclaredUnresolvedName(JSType type)",
        "private void expectInterfaceProperty(NodeTraversal t, Node n, ObjectType instance, ObjectType implementedInterface, String prop)",
        "private void mismatch(NodeTraversal t, Node n, String msg, JSType found, JSType required)",
        "private void mismatch(NodeTraversal t, Node n, String msg, JSType found, JSTypeNative required)",
        "private void mismatch(String sourceName, Node n, String msg, JSType found, JSType required)",
        "private void registerMismatch(JSType found, JSType required, JSError error)",
        "private void registerIfMismatch( JSType found, JSType required, JSError error)",
        "private String formatFoundRequired(String description, JSType found, JSType required)",
        "private JSType getJSType(Node n)",
        "private JSType getNativeType(JSTypeNative typeId)",
        "private JSError report(JSError error)",
        "static class TypeMismatch { final JSType typeA; final JSType typeB; final JSError src; TypeMismatch(JSType a, JSType b, JSError src)",
        "public boolean equals(Object object)",
        "public int hashCode()",
        "public String toString()"
      ],
      "methods": [
        {
          "buggy_method": "  private boolean containsForwardDeclaredUnresolvedName(JSType type) {\n  if (type.isUnionType()) {\n  for (JSType alt : type.toMaybeUnionType().getAlternates()) {\n  if (containsForwardDeclaredUnresolvedName(alt)) {\n  return true;\n  }\n  }\n  }\n  return type.isNoResolvedType();\n  }",
          "fixed_method": "  private boolean containsForwardDeclaredUnresolvedName(JSType type) {\n  if (type.isUnionType()) {\n  for (JSType alt : type.toMaybeUnionType().getAlternates()) {\n  if (containsForwardDeclaredUnresolvedName(alt)) {\n  return true;\n  }\n  }\n  }\n  return type.isNoResolvedType();\n  }",
          "diff": [
            "@@ -363,9 +363,6 @@",
            "       JSType leftType, Node owner, String propName) {\n",
            "     // The NoType check is a hack to make typedefs work OK.\n",
            "     if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) {\n",
            "-      if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n",
            "-        registerMismatch(rightType, leftType, null);\n",
            "-      } else {\n",
            "       // Do not type-check interface methods, because we expect that\n",
            "       // they will have dummy implementations that do not match the type\n",
            "       // annotations.\n",
            "@@ -382,7 +379,6 @@",
            "           \"assignment to property \" + propName + \" of \" +\n",
            "           getReadableJSTypeName(owner, true),\n",
            "           rightType, leftType);\n",
            "-      }\n",
            "       return false;\n",
            "     }\n",
            "     return true;\n",
            "@@ -402,11 +398,7 @@",
            "   boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType,\n",
            "       JSType leftType, String msg) {\n",
            "     if (!rightType.canAssignTo(leftType)) {\n",
            "-      if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n",
            "-        registerMismatch(rightType, leftType, null);\n",
            "-      } else {\n",
            "       mismatch(t, n, msg, rightType, leftType);\n",
            "-      }\n",
            "       return false;\n",
            "     }\n",
            "     return true;\n"
          ],
          "changed_lines": 8
        }
      ]
    }
  ]
}
