{
  "bug_id": "12",
  "failed_tests": {
    "org.joda.time.TestLocalDateTime_Constructors": [
      {
        "methodName": "testFactory_fromDateFields_beforeYearZero1",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<0000-02-03T04:05:06.007> but was:<0001-02-03T04:05:06.007>",
        "fail_line": "        assertEquals(expected, LocalDateTime.fromDateFields(cal.getTime()));",
        "test_source": "  public void testFactory_fromDateFields_beforeYearZero1() throws Exception {\n  GregorianCalendar cal = new GregorianCalendar(1, 1, 3, 4, 5, 6);\n  cal.set(Calendar.ERA, GregorianCalendar.BC);\n  cal.set(Calendar.MILLISECOND, 7);\n  LocalDateTime expected = new LocalDateTime(0, 2, 3, 4, 5, 6, 7);\n  assertEquals(expected, LocalDateTime.fromDateFields(cal.getTime()));\n  }",
        "stack": [
          "TestLocalDateTime_Constructors.testFactory_fromDateFields_beforeYearZero1 line 155"
        ]
      },
      {
        "methodName": "testFactory_fromDateFields_beforeYearZero3",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<-0002-02-03T04:05:06.007> but was:<0003-02-03T04:05:06.007>",
        "fail_line": "        assertEquals(expected, LocalDateTime.fromDateFields(cal.getTime()));",
        "test_source": "  public void testFactory_fromDateFields_beforeYearZero3() throws Exception {\n  GregorianCalendar cal = new GregorianCalendar(3, 1, 3, 4, 5, 6);\n  cal.set(Calendar.ERA, GregorianCalendar.BC);\n  cal.set(Calendar.MILLISECOND, 7);\n  LocalDateTime expected = new LocalDateTime(-2, 2, 3, 4, 5, 6, 7);\n  assertEquals(expected, LocalDateTime.fromDateFields(cal.getTime()));\n  }",
        "stack": [
          "TestLocalDateTime_Constructors.testFactory_fromDateFields_beforeYearZero3 line 163"
        ]
      },
      {
        "methodName": "testFactory_fromCalendarFields_beforeYearZero1",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<0000-02-03T04:05:06.007> but was:<0001-02-03T04:05:06.007>",
        "fail_line": "        assertEquals(expected, LocalDateTime.fromCalendarFields(cal));",
        "test_source": "  public void testFactory_fromCalendarFields_beforeYearZero1() throws Exception {\n  GregorianCalendar cal = new GregorianCalendar(1, 1, 3, 4, 5, 6);\n  cal.set(Calendar.ERA, GregorianCalendar.BC);\n  cal.set(Calendar.MILLISECOND, 7);\n  LocalDateTime expected = new LocalDateTime(0, 2, 3, 4, 5, 6, 7);\n  assertEquals(expected, LocalDateTime.fromCalendarFields(cal));\n  }",
        "stack": [
          "TestLocalDateTime_Constructors.testFactory_fromCalendarFields_beforeYearZero1 line 117"
        ]
      },
      {
        "methodName": "testFactory_fromCalendarFields_beforeYearZero3",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<-0002-02-03T04:05:06.007> but was:<0003-02-03T04:05:06.007>",
        "fail_line": "        assertEquals(expected, LocalDateTime.fromCalendarFields(cal));",
        "test_source": "  public void testFactory_fromCalendarFields_beforeYearZero3() throws Exception {\n  GregorianCalendar cal = new GregorianCalendar(3, 1, 3, 4, 5, 6);\n  cal.set(Calendar.ERA, GregorianCalendar.BC);\n  cal.set(Calendar.MILLISECOND, 7);\n  LocalDateTime expected = new LocalDateTime(-2, 2, 3, 4, 5, 6, 7);\n  assertEquals(expected, LocalDateTime.fromCalendarFields(cal));\n  }",
        "stack": [
          "TestLocalDateTime_Constructors.testFactory_fromCalendarFields_beforeYearZero3 line 125"
        ]
      }
    ],
    "org.joda.time.TestLocalDate_Constructors": [
      {
        "methodName": "testFactory_fromDateFields_beforeYearZero1",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<0000-02-03> but was:<0001-02-03>",
        "fail_line": "        assertEquals(expected, LocalDate.fromDateFields(cal.getTime()));",
        "test_source": "  public void testFactory_fromDateFields_beforeYearZero1() throws Exception {\n  GregorianCalendar cal = new GregorianCalendar(1, 1, 3, 4, 5, 6);\n  cal.set(Calendar.ERA, GregorianCalendar.BC);\n  cal.set(Calendar.MILLISECOND, 7);\n  LocalDate expected = new LocalDate(0, 2, 3);\n  assertEquals(expected, LocalDate.fromDateFields(cal.getTime()));\n  }",
        "stack": [
          "TestLocalDate_Constructors.testFactory_fromDateFields_beforeYearZero1 line 147"
        ]
      },
      {
        "methodName": "testFactory_fromDateFields_beforeYearZero3",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<-0002-02-03> but was:<0003-02-03>",
        "fail_line": "        assertEquals(expected, LocalDate.fromDateFields(cal.getTime()));",
        "test_source": "  public void testFactory_fromDateFields_beforeYearZero3() throws Exception {\n  GregorianCalendar cal = new GregorianCalendar(3, 1, 3, 4, 5, 6);\n  cal.set(Calendar.ERA, GregorianCalendar.BC);\n  cal.set(Calendar.MILLISECOND, 7);\n  LocalDate expected = new LocalDate(-2, 2, 3);\n  assertEquals(expected, LocalDate.fromDateFields(cal.getTime()));\n  }",
        "stack": [
          "TestLocalDate_Constructors.testFactory_fromDateFields_beforeYearZero3 line 155"
        ]
      },
      {
        "methodName": "testFactory_fromCalendarFields_beforeYearZero1",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<0000-02-03> but was:<0001-02-03>",
        "fail_line": "        assertEquals(expected, LocalDate.fromCalendarFields(cal));",
        "test_source": "  public void testFactory_fromCalendarFields_beforeYearZero1() throws Exception {\n  GregorianCalendar cal = new GregorianCalendar(1, 1, 3, 4, 5, 6);\n  cal.set(Calendar.ERA, GregorianCalendar.BC);\n  cal.set(Calendar.MILLISECOND, 7);\n  LocalDate expected = new LocalDate(0, 2, 3);\n  assertEquals(expected, LocalDate.fromCalendarFields(cal));\n  }",
        "stack": [
          "TestLocalDate_Constructors.testFactory_fromCalendarFields_beforeYearZero1 line 109"
        ]
      },
      {
        "methodName": "testFactory_fromCalendarFields_beforeYearZero3",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<-0002-02-03> but was:<0003-02-03>",
        "fail_line": "        assertEquals(expected, LocalDate.fromCalendarFields(cal));",
        "test_source": "  public void testFactory_fromCalendarFields_beforeYearZero3() throws Exception {\n  GregorianCalendar cal = new GregorianCalendar(3, 1, 3, 4, 5, 6);\n  cal.set(Calendar.ERA, GregorianCalendar.BC);\n  cal.set(Calendar.MILLISECOND, 7);\n  LocalDate expected = new LocalDate(-2, 2, 3);\n  assertEquals(expected, LocalDate.fromCalendarFields(cal));\n  }",
        "stack": [
          "TestLocalDate_Constructors.testFactory_fromCalendarFields_beforeYearZero3 line 117"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/joda/time/LocalDate.java",
      "buggy_full_code": "\npackage org.joda.time;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.GregorianCalendar;\nimport java.util.HashSet;\nimport java.util.Locale;\nimport java.util.Set;\nimport java.util.TimeZone;\n\nimport org.joda.convert.FromString;\nimport org.joda.convert.ToString;\nimport org.joda.time.base.BaseLocal;\nimport org.joda.time.chrono.ISOChronology;\nimport org.joda.time.convert.ConverterManager;\nimport org.joda.time.convert.PartialConverter;\nimport org.joda.time.field.AbstractReadableInstantFieldProperty;\nimport org.joda.time.field.FieldUtils;\nimport org.joda.time.format.DateTimeFormat;\nimport org.joda.time.format.DateTimeFormatter;\nimport org.joda.time.format.ISODateTimeFormat;\n\n\npublic final class LocalDate extends BaseLocal implements ReadablePartial, Serializable { private static final long serialVersionUID = -8775358157899L; private static final int YEAR = 0; private static final int MONTH_OF_YEAR = 1; private static final int DAY_OF_MONTH = 2; private static final Set<DurationFieldType> DATE_DURATION_TYPES = new HashSet<DurationFieldType>(); static {\n        DATE_DURATION_TYPES.add(DurationFieldType.days());\n        DATE_DURATION_TYPES.add(DurationFieldType.weeks());\n        DATE_DURATION_TYPES.add(DurationFieldType.months());\n        DATE_DURATION_TYPES.add(DurationFieldType.weekyears());\n        DATE_DURATION_TYPES.add(DurationFieldType.years());\n        DATE_DURATION_TYPES.add(DurationFieldType.centuries());\n        \n        DATE_DURATION_TYPES.add(DurationFieldType.eras());\n    }\n\n    \n    private final long iLocalMillis; private final Chronology iChronology; private transient volatile int iHash; public static LocalDate now() {\n        return new LocalDate();\n    }\n\n    \n    public static LocalDate now(DateTimeZone zone) {\n        if (zone == null) {\n            throw new NullPointerException(\"Zone must not be null\");\n        }\n        return new LocalDate(zone);\n    }\n\n    \n    public static LocalDate now(Chronology chronology) {\n        if (chronology == null) {\n            throw new NullPointerException(\"Chronology must not be null\");\n        }\n        return new LocalDate(chronology);\n    }\n\n    \n    \n    @FromString\n    public static LocalDate parse(String str) {\n        return parse(str, ISODateTimeFormat.localDateParser());\n    }\n\n    \n    public static LocalDate parse(String str, DateTimeFormatter formatter) {\n        return formatter.parseLocalDate(str);\n    }\n\n    \n    \n    public static LocalDate fromCalendarFields(Calendar calendar) {\n        if (calendar == null) {\n            throw new IllegalArgumentException(\"The calendar must not be null\");\n        }\n        int yearOfEra = calendar.get(Calendar.YEAR);\n        return new LocalDate(\n            yearOfEra,\n            calendar.get(Calendar.MONTH) + 1,\n            calendar.get(Calendar.DAY_OF_MONTH)\n        );\n    }\n\n    \n    @SuppressWarnings(\"deprecation\")\n    public static LocalDate fromDateFields(Date date) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n            \n        return new LocalDate(\n            date.getYear() + 1900,\n            date.getMonth() + 1,\n            date.getDate()\n        );\n    }\n\n    \n    \n    public LocalDate() {\n        this(DateTimeUtils.currentTimeMillis(), ISOChronology.getInstance());\n    }\n\n    \n    public LocalDate(DateTimeZone zone) {\n        this(DateTimeUtils.currentTimeMillis(), ISOChronology.getInstance(zone));\n    }\n\n    \n    public LocalDate(Chronology chronology) {\n        this(DateTimeUtils.currentTimeMillis(), chronology);\n    }\n\n    \n    \n    public LocalDate(long instant) {\n        this(instant, ISOChronology.getInstance());\n    }\n\n    \n    public LocalDate(long instant, DateTimeZone zone) {\n        this(instant, ISOChronology.getInstance(zone));\n    }\n\n    \n    public LocalDate(long instant, Chronology chronology) {\n        chronology = DateTimeUtils.getChronology(chronology);\n        \n        long localMillis = chronology.getZone().getMillisKeepLocal(DateTimeZone.UTC, instant);\n        chronology = chronology.withUTC();\n        iLocalMillis = chronology.dayOfMonth().roundFloor(localMillis);\n        iChronology = chronology;\n    }\n\n    \n    \n    public LocalDate(Object instant) {\n        this(instant, (Chronology) null);\n    }\n\n    \n    public LocalDate(Object instant, DateTimeZone zone) {\n        PartialConverter converter = ConverterManager.getInstance().getPartialConverter(instant);\n        Chronology chronology = converter.getChronology(instant, zone);\n        chronology = DateTimeUtils.getChronology(chronology);\n        iChronology = chronology.withUTC();\n        int[] values = converter.getPartialValues(this, instant, chronology, ISODateTimeFormat.localDateParser());\n        iLocalMillis = iChronology.getDateTimeMillis(values[0], values[1], values[2], 0);\n    }\n\n    \n    public LocalDate(Object instant, Chronology chronology) {\n        PartialConverter converter = ConverterManager.getInstance().getPartialConverter(instant);\n        chronology = converter.getChronology(instant, chronology);\n        chronology = DateTimeUtils.getChronology(chronology);\n        iChronology = chronology.withUTC();\n        int[] values = converter.getPartialValues(this, instant, chronology, ISODateTimeFormat.localDateParser());\n        iLocalMillis = iChronology.getDateTimeMillis(values[0], values[1], values[2], 0);\n    }\n\n    \n    \n    public LocalDate( int year, int monthOfYear, int dayOfMonth) {\n        this(year, monthOfYear, dayOfMonth, ISOChronology.getInstanceUTC());\n    }\n\n    \n    public LocalDate( int year, int monthOfYear, int dayOfMonth, Chronology chronology) {\n        super();\n        chronology = DateTimeUtils.getChronology(chronology).withUTC();\n        long instant = chronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, 0);\n        iChronology = chronology;\n        iLocalMillis = instant;\n    }\n\n    \n    private Object readResolve() {\n        if (iChronology == null) {\n            return new LocalDate(iLocalMillis, ISOChronology.getInstanceUTC());\n        }\n        if (DateTimeZone.UTC.equals(iChronology.getZone()) == false) {\n            return new LocalDate(iLocalMillis, iChronology.withUTC());\n        }\n        return this;\n    }\n\n    \n    \n    public int size() {\n        return 3;\n    }\n\n    \n    protected DateTimeField getField(int index, Chronology chrono) {\n        switch (index) {\n            case YEAR:\n                return chrono.year();\n            case MONTH_OF_YEAR:\n                return chrono.monthOfYear();\n            case DAY_OF_MONTH:\n                return chrono.dayOfMonth();\n            default:\n                throw new IndexOutOfBoundsException(\"Invalid index: \" + index);\n        }\n    }\n\n    \n    public int getValue(int index) {\n        switch (index) {\n            case YEAR:\n                return getChronology().year().get(getLocalMillis());\n            case MONTH_OF_YEAR:\n                return getChronology().monthOfYear().get(getLocalMillis());\n            case DAY_OF_MONTH:\n                return getChronology().dayOfMonth().get(getLocalMillis());\n            default:\n                throw new IndexOutOfBoundsException(\"Invalid index: \" + index);\n        }\n    }\n\n    \n    \n    public int get(DateTimeFieldType fieldType) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\");\n        }\n        if (isSupported(fieldType) == false) {\n            throw new IllegalArgumentException(\"Field '\" + fieldType + \"' is not supported\");\n        }\n        return fieldType.getField(getChronology()).get(getLocalMillis());\n    }\n\n    \n    public boolean isSupported(DateTimeFieldType type) {\n        if (type == null) {\n            return false;\n        }\n        DurationFieldType durType = type.getDurationType();\n        if (DATE_DURATION_TYPES.contains(durType) ||\n                durType.getField(getChronology()).getUnitMillis() >=\n                    getChronology().days().getUnitMillis()) {\n            return type.getField(getChronology()).isSupported();\n        }\n        return false;\n    }\n\n    \n    public boolean isSupported(DurationFieldType type) {\n        if (type == null) {\n            return false;\n        }\n        DurationField field = type.getField(getChronology());\n        if (DATE_DURATION_TYPES.contains(type) ||\n            field.getUnitMillis() >= getChronology().days().getUnitMillis()) {\n            return field.isSupported();\n        }\n        return false;\n    }\n\n    \n    \n    protected long getLocalMillis() {\n        return iLocalMillis;\n    }\n\n    \n    public Chronology getChronology() {\n        return iChronology;\n    }\n\n    \n    \n    public boolean equals(Object partial) {\n        \n        if (this == partial) {\n            return true;\n        }\n        if (partial instanceof LocalDate) {\n            LocalDate other = (LocalDate) partial;\n            if (iChronology.equals(other.iChronology)) {\n                return iLocalMillis == other.iLocalMillis;\n            }\n        }\n        return super.equals(partial);\n    }\n\n    \n    public int hashCode() {\n        \n        int hash = iHash;\n        if (hash == 0) {\n            hash = iHash = super.hashCode();\n        }\n        return hash;\n    }\n\n    \n    public int compareTo(ReadablePartial partial) {\n        \n        if (this == partial) {\n            return 0;\n        }\n        if (partial instanceof LocalDate) {\n            LocalDate other = (LocalDate) partial;\n            if (iChronology.equals(other.iChronology)) {\n                return (iLocalMillis < other.iLocalMillis ? -1 :\n                            (iLocalMillis == other.iLocalMillis ? 0 : 1));\n\n            }\n        }\n        return super.compareTo(partial);\n    }\n\n    \n    \n    public DateTime toDateTimeAtStartOfDay() {\n        return toDateTimeAtStartOfDay(null);\n    }\n\n    \n    public DateTime toDateTimeAtStartOfDay(DateTimeZone zone) {\n        zone = DateTimeUtils.getZone(zone);\n        Chronology chrono = getChronology().withZone(zone);\n        long localMillis = getLocalMillis() + 6L * DateTimeConstants.MILLIS_PER_HOUR;\n        long instant = zone.convertLocalToUTC(localMillis, false);\n        instant = chrono.dayOfMonth().roundFloor(instant);\n        return new DateTime(instant, chrono);\n    }\n\n    \n    \n    @Deprecated\n    public DateTime toDateTimeAtMidnight() {\n        return toDateTimeAtMidnight(null);\n    }\n\n    \n    @Deprecated\n    public DateTime toDateTimeAtMidnight(DateTimeZone zone) {\n        zone = DateTimeUtils.getZone(zone);\n        Chronology chrono = getChronology().withZone(zone);\n        return new DateTime(getYear(), getMonthOfYear(), getDayOfMonth(), 0, 0, 0, 0, chrono);\n    }\n\n    \n    \n    public DateTime toDateTimeAtCurrentTime() {\n        return toDateTimeAtCurrentTime(null);\n    }\n\n    \n    public DateTime toDateTimeAtCurrentTime(DateTimeZone zone) {\n        zone = DateTimeUtils.getZone(zone);\n        Chronology chrono = getChronology().withZone(zone);\n        long instantMillis = DateTimeUtils.currentTimeMillis();\n        long resolved = chrono.set(this, instantMillis);\n        return new DateTime(resolved, chrono);\n    }\n\n    \n    \n    public DateMidnight toDateMidnight() {\n        return toDateMidnight(null);\n    }\n\n    \n    public DateMidnight toDateMidnight(DateTimeZone zone) {\n        zone = DateTimeUtils.getZone(zone);\n        Chronology chrono = getChronology().withZone(zone);\n        return new DateMidnight(getYear(), getMonthOfYear(), getDayOfMonth(), chrono);\n    }\n\n    \n    \n    public LocalDateTime toLocalDateTime(LocalTime time) {\n        if (time == null) {\n            throw new IllegalArgumentException(\"The time must not be null\");\n        }\n        if (getChronology() != time.getChronology()) {\n            throw new IllegalArgumentException(\"The chronology of the time does not match\");\n        }\n        long localMillis = getLocalMillis() + time.getLocalMillis();\n        return new LocalDateTime(localMillis, getChronology());\n    }\n\n    \n    \n    public DateTime toDateTime(LocalTime time) {\n        return toDateTime(time, null);\n    }\n\n    \n    public DateTime toDateTime(LocalTime time, DateTimeZone zone) {\n        if (time != null && getChronology() != time.getChronology()) {\n            throw new IllegalArgumentException(\"The chronology of the time does not match\");\n        }\n        Chronology chrono = getChronology().withZone(zone);\n        long instant = DateTimeUtils.currentTimeMillis();\n        instant = chrono.set(this, instant);\n        if (time != null) {\n            instant = chrono.set(time, instant);\n        }\n        return new DateTime(instant, chrono);\n    }\n\n    \n    \n    public Interval toInterval() {\n        return toInterval(null);\n    }\n\n    \n    public Interval toInterval(DateTimeZone zone) {\n        zone = DateTimeUtils.getZone(zone);\n        DateTime start = toDateTimeAtStartOfDay(zone);\n        DateTime end = plusDays(1).toDateTimeAtStartOfDay(zone);\n        return new Interval(start, end);\n    }\n\n    \n    \n    @SuppressWarnings(\"deprecation\")\n    public Date toDate() {\n        int dom = getDayOfMonth();\n        Date date = new Date(getYear() - 1900, getMonthOfYear() - 1, dom);\n        LocalDate check = LocalDate.fromDateFields(date);\n        if (check.isBefore(this)) {\n            \n            \n            while (check.equals(this) == false) {\n                date.setTime(date.getTime() + 3600000);\n                check = LocalDate.fromDateFields(date);\n            }\n            \n            while (date.getDate() == dom) {\n                date.setTime(date.getTime() - 1000);\n            }\n            \n            date.setTime(date.getTime() + 1000);\n        } else if (check.equals(this)) {\n            \n            Date earlier = new Date(date.getTime() - TimeZone.getDefault().getDSTSavings());\n            if (earlier.getDate() == dom) {\n                date = earlier;\n            }\n        }\n        return date;\n    }\n\n    \n    \n    LocalDate withLocalMillis(long newMillis) {\n        newMillis = iChronology.dayOfMonth().roundFloor(newMillis);\n        return (newMillis == getLocalMillis() ? this : new LocalDate(newMillis, getChronology()));\n    }\n\n    \n    \n    public LocalDate withFields(ReadablePartial partial) {\n        if (partial == null) {\n            return this;\n        }\n        return withLocalMillis(getChronology().set(partial, getLocalMillis()));\n    }\n\n    \n    public LocalDate withField(DateTimeFieldType fieldType, int value) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"Field must not be null\");\n        }\n        if (isSupported(fieldType) == false) {\n            throw new IllegalArgumentException(\"Field '\" + fieldType + \"' is not supported\");\n        }\n        long instant = fieldType.getField(getChronology()).set(getLocalMillis(), value);\n        return withLocalMillis(instant);\n    }\n\n    \n    public LocalDate withFieldAdded(DurationFieldType fieldType, int amount) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"Field must not be null\");\n        }\n        if (isSupported(fieldType) == false) {\n            throw new IllegalArgumentException(\"Field '\" + fieldType + \"' is not supported\");\n        }\n        if (amount == 0) {\n            return this;\n        }\n        long instant = fieldType.getField(getChronology()).add(getLocalMillis(), amount);\n        return withLocalMillis(instant);\n    }\n\n    \n    \n    public LocalDate withPeriodAdded(ReadablePeriod period, int scalar) {\n        if (period == null || scalar == 0) {\n            return this;\n        }\n        long instant = getLocalMillis();\n        Chronology chrono = getChronology();\n        for (int i = 0; i < period.size(); i++) {\n            long value = FieldUtils.safeMultiply(period.getValue(i), scalar);\n            DurationFieldType type = period.getFieldType(i);\n            if (isSupported(type)) {\n                instant = type.getField(chrono).add(instant, value);\n            }\n        }\n        return withLocalMillis(instant);\n    }\n\n    \n    \n    public LocalDate plus(ReadablePeriod period) {\n        return withPeriodAdded(period, 1);\n    }\n\n    \n    \n    public LocalDate plusYears(int years) {\n        if (years == 0) {\n            return this;\n        }\n        long instant = getChronology().years().add(getLocalMillis(), years);\n        return withLocalMillis(instant);\n    }\n\n    \n    public LocalDate plusMonths(int months) {\n        if (months == 0) {\n            return this;\n        }\n        long instant = getChronology().months().add(getLocalMillis(), months);\n        return withLocalMillis(instant);\n    }\n\n    \n    public LocalDate plusWeeks(int weeks) {\n        if (weeks == 0) {\n            return this;\n        }\n        long instant = getChronology().weeks().add(getLocalMillis(), weeks);\n        return withLocalMillis(instant);\n    }\n\n    \n    public LocalDate plusDays(int days) {\n        if (days == 0) {\n            return this;\n        }\n        long instant = getChronology().days().add(getLocalMillis(), days);\n        return withLocalMillis(instant);\n    }\n\n    \n    \n    public LocalDate minus(ReadablePeriod period) {\n        return withPeriodAdded(period, -1);\n    }\n\n    \n    \n    public LocalDate minusYears(int years) {\n        if (years == 0) {\n            return this;\n        }\n        long instant = getChronology().years().subtract(getLocalMillis(), years);\n        return withLocalMillis(instant);\n    }\n\n    \n    public LocalDate minusMonths(int months) {\n        if (months == 0) {\n            return this;\n        }\n        long instant = getChronology().months().subtract(getLocalMillis(), months);\n        return withLocalMillis(instant);\n    }\n\n    \n    public LocalDate minusWeeks(int weeks) {\n        if (weeks == 0) {\n            return this;\n        }\n        long instant = getChronology().weeks().subtract(getLocalMillis(), weeks);\n        return withLocalMillis(instant);\n    }\n\n    \n    public LocalDate minusDays(int days) {\n        if (days == 0) {\n            return this;\n        }\n        long instant = getChronology().days().subtract(getLocalMillis(), days);\n        return withLocalMillis(instant);\n    }\n\n    \n    \n    public Property property(DateTimeFieldType fieldType) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\");\n        }\n        if (isSupported(fieldType) == false) {\n            throw new IllegalArgumentException(\"Field '\" + fieldType + \"' is not supported\");\n        }\n        return new Property(this, fieldType.getField(getChronology()));\n    }\n\n    \n    \n    public int getEra() {\n        return getChronology().era().get(getLocalMillis());\n    }\n\n    \n    public int getCenturyOfEra() {\n        return getChronology().centuryOfEra().get(getLocalMillis());\n    }\n\n    \n    public int getYearOfEra() {\n        return getChronology().yearOfEra().get(getLocalMillis());\n    }\n\n    \n    public int getYearOfCentury() {\n        return getChronology().yearOfCentury().get(getLocalMillis());\n    }\n\n    \n    public int getYear() {\n        return getChronology().year().get(getLocalMillis());\n    }\n\n    \n    public int getWeekyear() {\n        return getChronology().weekyear().get(getLocalMillis());\n    }\n\n    \n    public int getMonthOfYear() {\n        return getChronology().monthOfYear().get(getLocalMillis());\n    }\n\n    \n    public int getWeekOfWeekyear() {\n        return getChronology().weekOfWeekyear().get(getLocalMillis());\n    }\n\n    \n    public int getDayOfYear() {\n        return getChronology().dayOfYear().get(getLocalMillis());\n    }\n\n    \n    public int getDayOfMonth() {\n        return getChronology().dayOfMonth().get(getLocalMillis());\n    }\n\n    \n    public int getDayOfWeek() {\n        return getChronology().dayOfWeek().get(getLocalMillis());\n    }\n\n    \n    \n    public LocalDate withEra(int era) {\n        return withLocalMillis(getChronology().era().set(getLocalMillis(), era));\n    }\n\n    \n    public LocalDate withCenturyOfEra(int centuryOfEra) {\n        return withLocalMillis(getChronology().centuryOfEra().set(getLocalMillis(), centuryOfEra));\n    }\n\n    \n    public LocalDate withYearOfEra(int yearOfEra) {\n        return withLocalMillis(getChronology().yearOfEra().set(getLocalMillis(), yearOfEra));\n    }\n\n    \n    public LocalDate withYearOfCentury(int yearOfCentury) {\n        return withLocalMillis(getChronology().yearOfCentury().set(getLocalMillis(), yearOfCentury));\n    }\n\n    \n    public LocalDate withYear(int year) {\n        return withLocalMillis(getChronology().year().set(getLocalMillis(), year));\n    }\n\n    \n    public LocalDate withWeekyear(int weekyear) {\n        return withLocalMillis(getChronology().weekyear().set(getLocalMillis(), weekyear));\n    }\n\n    \n    public LocalDate withMonthOfYear(int monthOfYear) {\n        return withLocalMillis(getChronology().monthOfYear().set(getLocalMillis(), monthOfYear));\n    }\n\n    \n    public LocalDate withWeekOfWeekyear(int weekOfWeekyear) {\n        return withLocalMillis(getChronology().weekOfWeekyear().set(getLocalMillis(), weekOfWeekyear));\n    }\n\n    \n    public LocalDate withDayOfYear(int dayOfYear) {\n        return withLocalMillis(getChronology().dayOfYear().set(getLocalMillis(), dayOfYear));\n    }\n\n    \n    public LocalDate withDayOfMonth(int dayOfMonth) {\n        return withLocalMillis(getChronology().dayOfMonth().set(getLocalMillis(), dayOfMonth));\n    }\n\n    \n    public LocalDate withDayOfWeek(int dayOfWeek) {\n        return withLocalMillis(getChronology().dayOfWeek().set(getLocalMillis(), dayOfWeek));\n    }\n\n    \n    \n    public Property era() {\n        return new Property(this, getChronology().era());\n    }\n\n    \n    public Property centuryOfEra() {\n        return new Property(this, getChronology().centuryOfEra());\n    }\n\n    \n    public Property yearOfCentury() {\n        return new Property(this, getChronology().yearOfCentury());\n    }\n\n    \n    public Property yearOfEra() {\n        return new Property(this, getChronology().yearOfEra());\n    }\n\n    \n    public Property year() {\n        return new Property(this, getChronology().year());\n    }\n\n    \n    public Property weekyear() {\n        return new Property(this, getChronology().weekyear());\n    }\n\n    \n    public Property monthOfYear() {\n        return new Property(this, getChronology().monthOfYear());\n    }\n\n    \n    public Property weekOfWeekyear() {\n        return new Property(this, getChronology().weekOfWeekyear());\n    }\n\n    \n    public Property dayOfYear() {\n        return new Property(this, getChronology().dayOfYear());\n    }\n\n    \n    public Property dayOfMonth() {\n        return new Property(this, getChronology().dayOfMonth());\n    }\n\n    \n    public Property dayOfWeek() {\n        return new Property(this, getChronology().dayOfWeek());\n    }\n\n    \n    \n    @ToString\n    public String toString() {\n        return ISODateTimeFormat.date().print(this);\n    }\n\n    \n    public String toString(String pattern) {\n        if (pattern == null) {\n            return toString();\n        }\n        return DateTimeFormat.forPattern(pattern).print(this);\n    }\n\n    \n    public String toString(String pattern, Locale locale) throws IllegalArgumentException {\n        if (pattern == null) {\n            return toString();\n        }\n        return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this);\n    }\n\n    \n    \n    public static final class Property extends AbstractReadableInstantFieldProperty { private static final long serialVersionUID = -3193829732634L; private transient LocalDate iInstant; private transient DateTimeField iField; Property(LocalDate instant, DateTimeField field) {\n            super();\n            iInstant = instant;\n            iField = field;\n        }\n        \n        \n        private void writeObject(ObjectOutputStream oos) throws IOException {\n            oos.writeObject(iInstant);\n            oos.writeObject(iField.getType());\n        }\n\n        \n        private void readObject(ObjectInputStream oos) throws IOException, ClassNotFoundException {\n            iInstant = (LocalDate) oos.readObject();\n            DateTimeFieldType type = (DateTimeFieldType) oos.readObject();\n            iField = type.getField(iInstant.getChronology());\n        }\n\n        \n        \n        public DateTimeField getField() {\n            return iField;\n        }\n        \n        \n        protected long getMillis() {\n            return iInstant.getLocalMillis();\n        }\n        \n        \n        protected Chronology getChronology() {\n            return iInstant.getChronology();\n        }\n        \n        \n        public LocalDate getLocalDate() {\n            return iInstant;\n        }\n        \n        \n        \n        public LocalDate addToCopy(int value) {\n            return iInstant.withLocalMillis(iField.add(iInstant.getLocalMillis(), value));\n        }\n        \n        \n        public LocalDate addWrapFieldToCopy(int value) {\n            return iInstant.withLocalMillis(iField.addWrapField(iInstant.getLocalMillis(), value));\n        }\n        \n        \n        \n        public LocalDate setCopy(int value) {\n            return iInstant.withLocalMillis(iField.set(iInstant.getLocalMillis(), value));\n        }\n        \n        \n        public LocalDate setCopy(String text, Locale locale) {\n            return iInstant.withLocalMillis(iField.set(iInstant.getLocalMillis(), text, locale));\n        }\n        \n        \n        public LocalDate setCopy(String text) {\n            return setCopy(text, null);\n        }\n        \n        \n        \n        public LocalDate withMaximumValue() {\n            return setCopy(getMaximumValue());\n        }\n        \n        \n        public LocalDate withMinimumValue() {\n            return setCopy(getMinimumValue());\n        }\n        \n        \n        \n        public LocalDate roundFloorCopy() {\n            return iInstant.withLocalMillis(iField.roundFloor(iInstant.getLocalMillis()));\n        }\n        \n        \n        public LocalDate roundCeilingCopy() {\n            return iInstant.withLocalMillis(iField.roundCeiling(iInstant.getLocalMillis()));\n        }\n        \n        \n        public LocalDate roundHalfFloorCopy() {\n            return iInstant.withLocalMillis(iField.roundHalfFloor(iInstant.getLocalMillis()));\n        }\n        \n        \n        public LocalDate roundHalfCeilingCopy() {\n            return iInstant.withLocalMillis(iField.roundHalfCeiling(iInstant.getLocalMillis()));\n        }\n        \n        \n        public LocalDate roundHalfEvenCopy() {\n            return iInstant.withLocalMillis(iField.roundHalfEven(iInstant.getLocalMillis()));\n        }\n    }\n\n}\n",
      "fixed_full_code": "\npackage org.joda.time;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.GregorianCalendar;\nimport java.util.HashSet;\nimport java.util.Locale;\nimport java.util.Set;\nimport java.util.TimeZone;\n\nimport org.joda.convert.FromString;\nimport org.joda.convert.ToString;\nimport org.joda.time.base.BaseLocal;\nimport org.joda.time.chrono.ISOChronology;\nimport org.joda.time.convert.ConverterManager;\nimport org.joda.time.convert.PartialConverter;\nimport org.joda.time.field.AbstractReadableInstantFieldProperty;\nimport org.joda.time.field.FieldUtils;\nimport org.joda.time.format.DateTimeFormat;\nimport org.joda.time.format.DateTimeFormatter;\nimport org.joda.time.format.ISODateTimeFormat;\n\n\npublic final class LocalDate extends BaseLocal implements ReadablePartial, Serializable { private static final long serialVersionUID = -8775358157899L; private static final int YEAR = 0; private static final int MONTH_OF_YEAR = 1; private static final int DAY_OF_MONTH = 2; private static final Set<DurationFieldType> DATE_DURATION_TYPES = new HashSet<DurationFieldType>(); static {\n        DATE_DURATION_TYPES.add(DurationFieldType.days());\n        DATE_DURATION_TYPES.add(DurationFieldType.weeks());\n        DATE_DURATION_TYPES.add(DurationFieldType.months());\n        DATE_DURATION_TYPES.add(DurationFieldType.weekyears());\n        DATE_DURATION_TYPES.add(DurationFieldType.years());\n        DATE_DURATION_TYPES.add(DurationFieldType.centuries());\n        \n        DATE_DURATION_TYPES.add(DurationFieldType.eras());\n    }\n\n    \n    private final long iLocalMillis; private final Chronology iChronology; private transient volatile int iHash; public static LocalDate now() {\n        return new LocalDate();\n    }\n\n    \n    public static LocalDate now(DateTimeZone zone) {\n        if (zone == null) {\n            throw new NullPointerException(\"Zone must not be null\");\n        }\n        return new LocalDate(zone);\n    }\n\n    \n    public static LocalDate now(Chronology chronology) {\n        if (chronology == null) {\n            throw new NullPointerException(\"Chronology must not be null\");\n        }\n        return new LocalDate(chronology);\n    }\n\n    \n    \n    @FromString\n    public static LocalDate parse(String str) {\n        return parse(str, ISODateTimeFormat.localDateParser());\n    }\n\n    \n    public static LocalDate parse(String str, DateTimeFormatter formatter) {\n        return formatter.parseLocalDate(str);\n    }\n\n    \n    \n    public static LocalDate fromCalendarFields(Calendar calendar) {\n        if (calendar == null) {\n            throw new IllegalArgumentException(\"The calendar must not be null\");\n        }\n        int era = calendar.get(Calendar.ERA);\n        int yearOfEra = calendar.get(Calendar.YEAR);\n        return new LocalDate(\n            (era == GregorianCalendar.AD ? yearOfEra : 1 - yearOfEra),\n            calendar.get(Calendar.MONTH) + 1,\n            calendar.get(Calendar.DAY_OF_MONTH)\n        );\n    }\n\n    \n    @SuppressWarnings(\"deprecation\")\n    public static LocalDate fromDateFields(Date date) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        if (date.getTime() < 0) {\n            \n            GregorianCalendar cal = new GregorianCalendar();\n            cal.setTime(date);\n            return fromCalendarFields(cal);\n        }\n        return new LocalDate(\n            date.getYear() + 1900,\n            date.getMonth() + 1,\n            date.getDate()\n        );\n    }\n\n    \n    \n    public LocalDate() {\n        this(DateTimeUtils.currentTimeMillis(), ISOChronology.getInstance());\n    }\n\n    \n    public LocalDate(DateTimeZone zone) {\n        this(DateTimeUtils.currentTimeMillis(), ISOChronology.getInstance(zone));\n    }\n\n    \n    public LocalDate(Chronology chronology) {\n        this(DateTimeUtils.currentTimeMillis(), chronology);\n    }\n\n    \n    \n    public LocalDate(long instant) {\n        this(instant, ISOChronology.getInstance());\n    }\n\n    \n    public LocalDate(long instant, DateTimeZone zone) {\n        this(instant, ISOChronology.getInstance(zone));\n    }\n\n    \n    public LocalDate(long instant, Chronology chronology) {\n        chronology = DateTimeUtils.getChronology(chronology);\n        \n        long localMillis = chronology.getZone().getMillisKeepLocal(DateTimeZone.UTC, instant);\n        chronology = chronology.withUTC();\n        iLocalMillis = chronology.dayOfMonth().roundFloor(localMillis);\n        iChronology = chronology;\n    }\n\n    \n    \n    public LocalDate(Object instant) {\n        this(instant, (Chronology) null);\n    }\n\n    \n    public LocalDate(Object instant, DateTimeZone zone) {\n        PartialConverter converter = ConverterManager.getInstance().getPartialConverter(instant);\n        Chronology chronology = converter.getChronology(instant, zone);\n        chronology = DateTimeUtils.getChronology(chronology);\n        iChronology = chronology.withUTC();\n        int[] values = converter.getPartialValues(this, instant, chronology, ISODateTimeFormat.localDateParser());\n        iLocalMillis = iChronology.getDateTimeMillis(values[0], values[1], values[2], 0);\n    }\n\n    \n    public LocalDate(Object instant, Chronology chronology) {\n        PartialConverter converter = ConverterManager.getInstance().getPartialConverter(instant);\n        chronology = converter.getChronology(instant, chronology);\n        chronology = DateTimeUtils.getChronology(chronology);\n        iChronology = chronology.withUTC();\n        int[] values = converter.getPartialValues(this, instant, chronology, ISODateTimeFormat.localDateParser());\n        iLocalMillis = iChronology.getDateTimeMillis(values[0], values[1], values[2], 0);\n    }\n\n    \n    \n    public LocalDate( int year, int monthOfYear, int dayOfMonth) {\n        this(year, monthOfYear, dayOfMonth, ISOChronology.getInstanceUTC());\n    }\n\n    \n    public LocalDate( int year, int monthOfYear, int dayOfMonth, Chronology chronology) {\n        super();\n        chronology = DateTimeUtils.getChronology(chronology).withUTC();\n        long instant = chronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, 0);\n        iChronology = chronology;\n        iLocalMillis = instant;\n    }\n\n    \n    private Object readResolve() {\n        if (iChronology == null) {\n            return new LocalDate(iLocalMillis, ISOChronology.getInstanceUTC());\n        }\n        if (DateTimeZone.UTC.equals(iChronology.getZone()) == false) {\n            return new LocalDate(iLocalMillis, iChronology.withUTC());\n        }\n        return this;\n    }\n\n    \n    \n    public int size() {\n        return 3;\n    }\n\n    \n    protected DateTimeField getField(int index, Chronology chrono) {\n        switch (index) {\n            case YEAR:\n                return chrono.year();\n            case MONTH_OF_YEAR:\n                return chrono.monthOfYear();\n            case DAY_OF_MONTH:\n                return chrono.dayOfMonth();\n            default:\n                throw new IndexOutOfBoundsException(\"Invalid index: \" + index);\n        }\n    }\n\n    \n    public int getValue(int index) {\n        switch (index) {\n            case YEAR:\n                return getChronology().year().get(getLocalMillis());\n            case MONTH_OF_YEAR:\n                return getChronology().monthOfYear().get(getLocalMillis());\n            case DAY_OF_MONTH:\n                return getChronology().dayOfMonth().get(getLocalMillis());\n            default:\n                throw new IndexOutOfBoundsException(\"Invalid index: \" + index);\n        }\n    }\n\n    \n    \n    public int get(DateTimeFieldType fieldType) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\");\n        }\n        if (isSupported(fieldType) == false) {\n            throw new IllegalArgumentException(\"Field '\" + fieldType + \"' is not supported\");\n        }\n        return fieldType.getField(getChronology()).get(getLocalMillis());\n    }\n\n    \n    public boolean isSupported(DateTimeFieldType type) {\n        if (type == null) {\n            return false;\n        }\n        DurationFieldType durType = type.getDurationType();\n        if (DATE_DURATION_TYPES.contains(durType) ||\n                durType.getField(getChronology()).getUnitMillis() >=\n                    getChronology().days().getUnitMillis()) {\n            return type.getField(getChronology()).isSupported();\n        }\n        return false;\n    }\n\n    \n    public boolean isSupported(DurationFieldType type) {\n        if (type == null) {\n            return false;\n        }\n        DurationField field = type.getField(getChronology());\n        if (DATE_DURATION_TYPES.contains(type) ||\n            field.getUnitMillis() >= getChronology().days().getUnitMillis()) {\n            return field.isSupported();\n        }\n        return false;\n    }\n\n    \n    \n    protected long getLocalMillis() {\n        return iLocalMillis;\n    }\n\n    \n    public Chronology getChronology() {\n        return iChronology;\n    }\n\n    \n    \n    public boolean equals(Object partial) {\n        \n        if (this == partial) {\n            return true;\n        }\n        if (partial instanceof LocalDate) {\n            LocalDate other = (LocalDate) partial;\n            if (iChronology.equals(other.iChronology)) {\n                return iLocalMillis == other.iLocalMillis;\n            }\n        }\n        return super.equals(partial);\n    }\n\n    \n    public int hashCode() {\n        \n        int hash = iHash;\n        if (hash == 0) {\n            hash = iHash = super.hashCode();\n        }\n        return hash;\n    }\n\n    \n    public int compareTo(ReadablePartial partial) {\n        \n        if (this == partial) {\n            return 0;\n        }\n        if (partial instanceof LocalDate) {\n            LocalDate other = (LocalDate) partial;\n            if (iChronology.equals(other.iChronology)) {\n                return (iLocalMillis < other.iLocalMillis ? -1 :\n                            (iLocalMillis == other.iLocalMillis ? 0 : 1));\n\n            }\n        }\n        return super.compareTo(partial);\n    }\n\n    \n    \n    public DateTime toDateTimeAtStartOfDay() {\n        return toDateTimeAtStartOfDay(null);\n    }\n\n    \n    public DateTime toDateTimeAtStartOfDay(DateTimeZone zone) {\n        zone = DateTimeUtils.getZone(zone);\n        Chronology chrono = getChronology().withZone(zone);\n        long localMillis = getLocalMillis() + 6L * DateTimeConstants.MILLIS_PER_HOUR;\n        long instant = zone.convertLocalToUTC(localMillis, false);\n        instant = chrono.dayOfMonth().roundFloor(instant);\n        return new DateTime(instant, chrono);\n    }\n\n    \n    \n    @Deprecated\n    public DateTime toDateTimeAtMidnight() {\n        return toDateTimeAtMidnight(null);\n    }\n\n    \n    @Deprecated\n    public DateTime toDateTimeAtMidnight(DateTimeZone zone) {\n        zone = DateTimeUtils.getZone(zone);\n        Chronology chrono = getChronology().withZone(zone);\n        return new DateTime(getYear(), getMonthOfYear(), getDayOfMonth(), 0, 0, 0, 0, chrono);\n    }\n\n    \n    \n    public DateTime toDateTimeAtCurrentTime() {\n        return toDateTimeAtCurrentTime(null);\n    }\n\n    \n    public DateTime toDateTimeAtCurrentTime(DateTimeZone zone) {\n        zone = DateTimeUtils.getZone(zone);\n        Chronology chrono = getChronology().withZone(zone);\n        long instantMillis = DateTimeUtils.currentTimeMillis();\n        long resolved = chrono.set(this, instantMillis);\n        return new DateTime(resolved, chrono);\n    }\n\n    \n    \n    public DateMidnight toDateMidnight() {\n        return toDateMidnight(null);\n    }\n\n    \n    public DateMidnight toDateMidnight(DateTimeZone zone) {\n        zone = DateTimeUtils.getZone(zone);\n        Chronology chrono = getChronology().withZone(zone);\n        return new DateMidnight(getYear(), getMonthOfYear(), getDayOfMonth(), chrono);\n    }\n\n    \n    \n    public LocalDateTime toLocalDateTime(LocalTime time) {\n        if (time == null) {\n            throw new IllegalArgumentException(\"The time must not be null\");\n        }\n        if (getChronology() != time.getChronology()) {\n            throw new IllegalArgumentException(\"The chronology of the time does not match\");\n        }\n        long localMillis = getLocalMillis() + time.getLocalMillis();\n        return new LocalDateTime(localMillis, getChronology());\n    }\n\n    \n    \n    public DateTime toDateTime(LocalTime time) {\n        return toDateTime(time, null);\n    }\n\n    \n    public DateTime toDateTime(LocalTime time, DateTimeZone zone) {\n        if (time != null && getChronology() != time.getChronology()) {\n            throw new IllegalArgumentException(\"The chronology of the time does not match\");\n        }\n        Chronology chrono = getChronology().withZone(zone);\n        long instant = DateTimeUtils.currentTimeMillis();\n        instant = chrono.set(this, instant);\n        if (time != null) {\n            instant = chrono.set(time, instant);\n        }\n        return new DateTime(instant, chrono);\n    }\n\n    \n    \n    public Interval toInterval() {\n        return toInterval(null);\n    }\n\n    \n    public Interval toInterval(DateTimeZone zone) {\n        zone = DateTimeUtils.getZone(zone);\n        DateTime start = toDateTimeAtStartOfDay(zone);\n        DateTime end = plusDays(1).toDateTimeAtStartOfDay(zone);\n        return new Interval(start, end);\n    }\n\n    \n    \n    @SuppressWarnings(\"deprecation\")\n    public Date toDate() {\n        int dom = getDayOfMonth();\n        Date date = new Date(getYear() - 1900, getMonthOfYear() - 1, dom);\n        LocalDate check = LocalDate.fromDateFields(date);\n        if (check.isBefore(this)) {\n            \n            \n            while (check.equals(this) == false) {\n                date.setTime(date.getTime() + 3600000);\n                check = LocalDate.fromDateFields(date);\n            }\n            \n            while (date.getDate() == dom) {\n                date.setTime(date.getTime() - 1000);\n            }\n            \n            date.setTime(date.getTime() + 1000);\n        } else if (check.equals(this)) {\n            \n            Date earlier = new Date(date.getTime() - TimeZone.getDefault().getDSTSavings());\n            if (earlier.getDate() == dom) {\n                date = earlier;\n            }\n        }\n        return date;\n    }\n\n    \n    \n    LocalDate withLocalMillis(long newMillis) {\n        newMillis = iChronology.dayOfMonth().roundFloor(newMillis);\n        return (newMillis == getLocalMillis() ? this : new LocalDate(newMillis, getChronology()));\n    }\n\n    \n    \n    public LocalDate withFields(ReadablePartial partial) {\n        if (partial == null) {\n            return this;\n        }\n        return withLocalMillis(getChronology().set(partial, getLocalMillis()));\n    }\n\n    \n    public LocalDate withField(DateTimeFieldType fieldType, int value) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"Field must not be null\");\n        }\n        if (isSupported(fieldType) == false) {\n            throw new IllegalArgumentException(\"Field '\" + fieldType + \"' is not supported\");\n        }\n        long instant = fieldType.getField(getChronology()).set(getLocalMillis(), value);\n        return withLocalMillis(instant);\n    }\n\n    \n    public LocalDate withFieldAdded(DurationFieldType fieldType, int amount) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"Field must not be null\");\n        }\n        if (isSupported(fieldType) == false) {\n            throw new IllegalArgumentException(\"Field '\" + fieldType + \"' is not supported\");\n        }\n        if (amount == 0) {\n            return this;\n        }\n        long instant = fieldType.getField(getChronology()).add(getLocalMillis(), amount);\n        return withLocalMillis(instant);\n    }\n\n    \n    \n    public LocalDate withPeriodAdded(ReadablePeriod period, int scalar) {\n        if (period == null || scalar == 0) {\n            return this;\n        }\n        long instant = getLocalMillis();\n        Chronology chrono = getChronology();\n        for (int i = 0; i < period.size(); i++) {\n            long value = FieldUtils.safeMultiply(period.getValue(i), scalar);\n            DurationFieldType type = period.getFieldType(i);\n            if (isSupported(type)) {\n                instant = type.getField(chrono).add(instant, value);\n            }\n        }\n        return withLocalMillis(instant);\n    }\n\n    \n    \n    public LocalDate plus(ReadablePeriod period) {\n        return withPeriodAdded(period, 1);\n    }\n\n    \n    \n    public LocalDate plusYears(int years) {\n        if (years == 0) {\n            return this;\n        }\n        long instant = getChronology().years().add(getLocalMillis(), years);\n        return withLocalMillis(instant);\n    }\n\n    \n    public LocalDate plusMonths(int months) {\n        if (months == 0) {\n            return this;\n        }\n        long instant = getChronology().months().add(getLocalMillis(), months);\n        return withLocalMillis(instant);\n    }\n\n    \n    public LocalDate plusWeeks(int weeks) {\n        if (weeks == 0) {\n            return this;\n        }\n        long instant = getChronology().weeks().add(getLocalMillis(), weeks);\n        return withLocalMillis(instant);\n    }\n\n    \n    public LocalDate plusDays(int days) {\n        if (days == 0) {\n            return this;\n        }\n        long instant = getChronology().days().add(getLocalMillis(), days);\n        return withLocalMillis(instant);\n    }\n\n    \n    \n    public LocalDate minus(ReadablePeriod period) {\n        return withPeriodAdded(period, -1);\n    }\n\n    \n    \n    public LocalDate minusYears(int years) {\n        if (years == 0) {\n            return this;\n        }\n        long instant = getChronology().years().subtract(getLocalMillis(), years);\n        return withLocalMillis(instant);\n    }\n\n    \n    public LocalDate minusMonths(int months) {\n        if (months == 0) {\n            return this;\n        }\n        long instant = getChronology().months().subtract(getLocalMillis(), months);\n        return withLocalMillis(instant);\n    }\n\n    \n    public LocalDate minusWeeks(int weeks) {\n        if (weeks == 0) {\n            return this;\n        }\n        long instant = getChronology().weeks().subtract(getLocalMillis(), weeks);\n        return withLocalMillis(instant);\n    }\n\n    \n    public LocalDate minusDays(int days) {\n        if (days == 0) {\n            return this;\n        }\n        long instant = getChronology().days().subtract(getLocalMillis(), days);\n        return withLocalMillis(instant);\n    }\n\n    \n    \n    public Property property(DateTimeFieldType fieldType) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\");\n        }\n        if (isSupported(fieldType) == false) {\n            throw new IllegalArgumentException(\"Field '\" + fieldType + \"' is not supported\");\n        }\n        return new Property(this, fieldType.getField(getChronology()));\n    }\n\n    \n    \n    public int getEra() {\n        return getChronology().era().get(getLocalMillis());\n    }\n\n    \n    public int getCenturyOfEra() {\n        return getChronology().centuryOfEra().get(getLocalMillis());\n    }\n\n    \n    public int getYearOfEra() {\n        return getChronology().yearOfEra().get(getLocalMillis());\n    }\n\n    \n    public int getYearOfCentury() {\n        return getChronology().yearOfCentury().get(getLocalMillis());\n    }\n\n    \n    public int getYear() {\n        return getChronology().year().get(getLocalMillis());\n    }\n\n    \n    public int getWeekyear() {\n        return getChronology().weekyear().get(getLocalMillis());\n    }\n\n    \n    public int getMonthOfYear() {\n        return getChronology().monthOfYear().get(getLocalMillis());\n    }\n\n    \n    public int getWeekOfWeekyear() {\n        return getChronology().weekOfWeekyear().get(getLocalMillis());\n    }\n\n    \n    public int getDayOfYear() {\n        return getChronology().dayOfYear().get(getLocalMillis());\n    }\n\n    \n    public int getDayOfMonth() {\n        return getChronology().dayOfMonth().get(getLocalMillis());\n    }\n\n    \n    public int getDayOfWeek() {\n        return getChronology().dayOfWeek().get(getLocalMillis());\n    }\n\n    \n    \n    public LocalDate withEra(int era) {\n        return withLocalMillis(getChronology().era().set(getLocalMillis(), era));\n    }\n\n    \n    public LocalDate withCenturyOfEra(int centuryOfEra) {\n        return withLocalMillis(getChronology().centuryOfEra().set(getLocalMillis(), centuryOfEra));\n    }\n\n    \n    public LocalDate withYearOfEra(int yearOfEra) {\n        return withLocalMillis(getChronology().yearOfEra().set(getLocalMillis(), yearOfEra));\n    }\n\n    \n    public LocalDate withYearOfCentury(int yearOfCentury) {\n        return withLocalMillis(getChronology().yearOfCentury().set(getLocalMillis(), yearOfCentury));\n    }\n\n    \n    public LocalDate withYear(int year) {\n        return withLocalMillis(getChronology().year().set(getLocalMillis(), year));\n    }\n\n    \n    public LocalDate withWeekyear(int weekyear) {\n        return withLocalMillis(getChronology().weekyear().set(getLocalMillis(), weekyear));\n    }\n\n    \n    public LocalDate withMonthOfYear(int monthOfYear) {\n        return withLocalMillis(getChronology().monthOfYear().set(getLocalMillis(), monthOfYear));\n    }\n\n    \n    public LocalDate withWeekOfWeekyear(int weekOfWeekyear) {\n        return withLocalMillis(getChronology().weekOfWeekyear().set(getLocalMillis(), weekOfWeekyear));\n    }\n\n    \n    public LocalDate withDayOfYear(int dayOfYear) {\n        return withLocalMillis(getChronology().dayOfYear().set(getLocalMillis(), dayOfYear));\n    }\n\n    \n    public LocalDate withDayOfMonth(int dayOfMonth) {\n        return withLocalMillis(getChronology().dayOfMonth().set(getLocalMillis(), dayOfMonth));\n    }\n\n    \n    public LocalDate withDayOfWeek(int dayOfWeek) {\n        return withLocalMillis(getChronology().dayOfWeek().set(getLocalMillis(), dayOfWeek));\n    }\n\n    \n    \n    public Property era() {\n        return new Property(this, getChronology().era());\n    }\n\n    \n    public Property centuryOfEra() {\n        return new Property(this, getChronology().centuryOfEra());\n    }\n\n    \n    public Property yearOfCentury() {\n        return new Property(this, getChronology().yearOfCentury());\n    }\n\n    \n    public Property yearOfEra() {\n        return new Property(this, getChronology().yearOfEra());\n    }\n\n    \n    public Property year() {\n        return new Property(this, getChronology().year());\n    }\n\n    \n    public Property weekyear() {\n        return new Property(this, getChronology().weekyear());\n    }\n\n    \n    public Property monthOfYear() {\n        return new Property(this, getChronology().monthOfYear());\n    }\n\n    \n    public Property weekOfWeekyear() {\n        return new Property(this, getChronology().weekOfWeekyear());\n    }\n\n    \n    public Property dayOfYear() {\n        return new Property(this, getChronology().dayOfYear());\n    }\n\n    \n    public Property dayOfMonth() {\n        return new Property(this, getChronology().dayOfMonth());\n    }\n\n    \n    public Property dayOfWeek() {\n        return new Property(this, getChronology().dayOfWeek());\n    }\n\n    \n    \n    @ToString\n    public String toString() {\n        return ISODateTimeFormat.date().print(this);\n    }\n\n    \n    public String toString(String pattern) {\n        if (pattern == null) {\n            return toString();\n        }\n        return DateTimeFormat.forPattern(pattern).print(this);\n    }\n\n    \n    public String toString(String pattern, Locale locale) throws IllegalArgumentException {\n        if (pattern == null) {\n            return toString();\n        }\n        return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this);\n    }\n\n    \n    \n    public static final class Property extends AbstractReadableInstantFieldProperty { private static final long serialVersionUID = -3193829732634L; private transient LocalDate iInstant; private transient DateTimeField iField; Property(LocalDate instant, DateTimeField field) {\n            super();\n            iInstant = instant;\n            iField = field;\n        }\n        \n        \n        private void writeObject(ObjectOutputStream oos) throws IOException {\n            oos.writeObject(iInstant);\n            oos.writeObject(iField.getType());\n        }\n\n        \n        private void readObject(ObjectInputStream oos) throws IOException, ClassNotFoundException {\n            iInstant = (LocalDate) oos.readObject();\n            DateTimeFieldType type = (DateTimeFieldType) oos.readObject();\n            iField = type.getField(iInstant.getChronology());\n        }\n\n        \n        \n        public DateTimeField getField() {\n            return iField;\n        }\n        \n        \n        protected long getMillis() {\n            return iInstant.getLocalMillis();\n        }\n        \n        \n        protected Chronology getChronology() {\n            return iInstant.getChronology();\n        }\n        \n        \n        public LocalDate getLocalDate() {\n            return iInstant;\n        }\n        \n        \n        \n        public LocalDate addToCopy(int value) {\n            return iInstant.withLocalMillis(iField.add(iInstant.getLocalMillis(), value));\n        }\n        \n        \n        public LocalDate addWrapFieldToCopy(int value) {\n            return iInstant.withLocalMillis(iField.addWrapField(iInstant.getLocalMillis(), value));\n        }\n        \n        \n        \n        public LocalDate setCopy(int value) {\n            return iInstant.withLocalMillis(iField.set(iInstant.getLocalMillis(), value));\n        }\n        \n        \n        public LocalDate setCopy(String text, Locale locale) {\n            return iInstant.withLocalMillis(iField.set(iInstant.getLocalMillis(), text, locale));\n        }\n        \n        \n        public LocalDate setCopy(String text) {\n            return setCopy(text, null);\n        }\n        \n        \n        \n        public LocalDate withMaximumValue() {\n            return setCopy(getMaximumValue());\n        }\n        \n        \n        public LocalDate withMinimumValue() {\n            return setCopy(getMinimumValue());\n        }\n        \n        \n        \n        public LocalDate roundFloorCopy() {\n            return iInstant.withLocalMillis(iField.roundFloor(iInstant.getLocalMillis()));\n        }\n        \n        \n        public LocalDate roundCeilingCopy() {\n            return iInstant.withLocalMillis(iField.roundCeiling(iInstant.getLocalMillis()));\n        }\n        \n        \n        public LocalDate roundHalfFloorCopy() {\n            return iInstant.withLocalMillis(iField.roundHalfFloor(iInstant.getLocalMillis()));\n        }\n        \n        \n        public LocalDate roundHalfCeilingCopy() {\n            return iInstant.withLocalMillis(iField.roundHalfCeiling(iInstant.getLocalMillis()));\n        }\n        \n        \n        public LocalDate roundHalfEvenCopy() {\n            return iInstant.withLocalMillis(iField.roundHalfEven(iInstant.getLocalMillis()));\n        }\n    }\n\n}\n",
      "buggy_signatures": [
        "private final long iLocalMillis; private final Chronology iChronology; private transient volatile int iHash; public static LocalDate now()",
        "public static LocalDate now(DateTimeZone zone)",
        "public static LocalDate now(Chronology chronology)",
        "public static LocalDate parse(String str)",
        "public static LocalDate parse(String str, DateTimeFormatter formatter)",
        "public static LocalDate fromCalendarFields(Calendar calendar)",
        "public static LocalDate fromDateFields(Date date)",
        "public LocalDate()",
        "public LocalDate(DateTimeZone zone)",
        "public LocalDate(Chronology chronology)",
        "public LocalDate(long instant)",
        "public LocalDate(long instant, DateTimeZone zone)",
        "public LocalDate(long instant, Chronology chronology)",
        "public LocalDate(Object instant)",
        "public LocalDate(Object instant, DateTimeZone zone)",
        "public LocalDate(Object instant, Chronology chronology)",
        "public LocalDate( int year, int monthOfYear, int dayOfMonth)",
        "public LocalDate( int year, int monthOfYear, int dayOfMonth, Chronology chronology)",
        "private Object readResolve()",
        "public int size()",
        "protected DateTimeField getField(int index, Chronology chrono)",
        "public int getValue(int index)",
        "public int get(DateTimeFieldType fieldType)",
        "public boolean isSupported(DateTimeFieldType type)",
        "public boolean isSupported(DurationFieldType type)",
        "protected long getLocalMillis()",
        "public Chronology getChronology()",
        "public boolean equals(Object partial)",
        "public int hashCode()",
        "public int compareTo(ReadablePartial partial)",
        "public DateTime toDateTimeAtStartOfDay()",
        "public DateTime toDateTimeAtStartOfDay(DateTimeZone zone)",
        "public DateTime toDateTimeAtMidnight()",
        "public DateTime toDateTimeAtMidnight(DateTimeZone zone)",
        "public DateTime toDateTimeAtCurrentTime()",
        "public DateTime toDateTimeAtCurrentTime(DateTimeZone zone)",
        "public DateMidnight toDateMidnight()",
        "public DateMidnight toDateMidnight(DateTimeZone zone)",
        "public LocalDateTime toLocalDateTime(LocalTime time)",
        "public DateTime toDateTime(LocalTime time)",
        "public DateTime toDateTime(LocalTime time, DateTimeZone zone)",
        "public Interval toInterval()",
        "public Interval toInterval(DateTimeZone zone)",
        "public Date toDate()",
        "public LocalDate withFields(ReadablePartial partial)",
        "public LocalDate withField(DateTimeFieldType fieldType, int value)",
        "public LocalDate withFieldAdded(DurationFieldType fieldType, int amount)",
        "public LocalDate withPeriodAdded(ReadablePeriod period, int scalar)",
        "public LocalDate plus(ReadablePeriod period)",
        "public LocalDate plusYears(int years)",
        "public LocalDate plusMonths(int months)",
        "public LocalDate plusWeeks(int weeks)",
        "public LocalDate plusDays(int days)",
        "public LocalDate minus(ReadablePeriod period)",
        "public LocalDate minusYears(int years)",
        "public LocalDate minusMonths(int months)",
        "public LocalDate minusWeeks(int weeks)",
        "public LocalDate minusDays(int days)",
        "public Property property(DateTimeFieldType fieldType)",
        "public int getEra()",
        "public int getCenturyOfEra()",
        "public int getYearOfEra()",
        "public int getYearOfCentury()",
        "public int getYear()",
        "public int getWeekyear()",
        "public int getMonthOfYear()",
        "public int getWeekOfWeekyear()",
        "public int getDayOfYear()",
        "public int getDayOfMonth()",
        "public int getDayOfWeek()",
        "public LocalDate withEra(int era)",
        "public LocalDate withCenturyOfEra(int centuryOfEra)",
        "public LocalDate withYearOfEra(int yearOfEra)",
        "public LocalDate withYearOfCentury(int yearOfCentury)",
        "public LocalDate withYear(int year)",
        "public LocalDate withWeekyear(int weekyear)",
        "public LocalDate withMonthOfYear(int monthOfYear)",
        "public LocalDate withWeekOfWeekyear(int weekOfWeekyear)",
        "public LocalDate withDayOfYear(int dayOfYear)",
        "public LocalDate withDayOfMonth(int dayOfMonth)",
        "public LocalDate withDayOfWeek(int dayOfWeek)",
        "public Property era()",
        "public Property centuryOfEra()",
        "public Property yearOfCentury()",
        "public Property yearOfEra()",
        "public Property year()",
        "public Property weekyear()",
        "public Property monthOfYear()",
        "public Property weekOfWeekyear()",
        "public Property dayOfYear()",
        "public Property dayOfMonth()",
        "public Property dayOfWeek()",
        "public String toString()",
        "public String toString(String pattern)",
        "public String toString(String pattern, Locale locale) throws IllegalArgumentException",
        "private void writeObject(ObjectOutputStream oos) throws IOException",
        "private void readObject(ObjectInputStream oos) throws IOException, ClassNotFoundException",
        "public DateTimeField getField()",
        "protected long getMillis()",
        "protected Chronology getChronology()",
        "public LocalDate getLocalDate()",
        "public LocalDate addToCopy(int value)",
        "public LocalDate addWrapFieldToCopy(int value)",
        "public LocalDate setCopy(int value)",
        "public LocalDate setCopy(String text, Locale locale)",
        "public LocalDate setCopy(String text)",
        "public LocalDate withMaximumValue()",
        "public LocalDate withMinimumValue()",
        "public LocalDate roundFloorCopy()",
        "public LocalDate roundCeilingCopy()",
        "public LocalDate roundHalfFloorCopy()",
        "public LocalDate roundHalfCeilingCopy()",
        "public LocalDate roundHalfEvenCopy()"
      ],
      "fixed_signatures": [
        "private final long iLocalMillis; private final Chronology iChronology; private transient volatile int iHash; public static LocalDate now()",
        "public static LocalDate now(DateTimeZone zone)",
        "public static LocalDate now(Chronology chronology)",
        "public static LocalDate parse(String str)",
        "public static LocalDate parse(String str, DateTimeFormatter formatter)",
        "public static LocalDate fromCalendarFields(Calendar calendar)",
        "public static LocalDate fromDateFields(Date date)",
        "public LocalDate()",
        "public LocalDate(DateTimeZone zone)",
        "public LocalDate(Chronology chronology)",
        "public LocalDate(long instant)",
        "public LocalDate(long instant, DateTimeZone zone)",
        "public LocalDate(long instant, Chronology chronology)",
        "public LocalDate(Object instant)",
        "public LocalDate(Object instant, DateTimeZone zone)",
        "public LocalDate(Object instant, Chronology chronology)",
        "public LocalDate( int year, int monthOfYear, int dayOfMonth)",
        "public LocalDate( int year, int monthOfYear, int dayOfMonth, Chronology chronology)",
        "private Object readResolve()",
        "public int size()",
        "protected DateTimeField getField(int index, Chronology chrono)",
        "public int getValue(int index)",
        "public int get(DateTimeFieldType fieldType)",
        "public boolean isSupported(DateTimeFieldType type)",
        "public boolean isSupported(DurationFieldType type)",
        "protected long getLocalMillis()",
        "public Chronology getChronology()",
        "public boolean equals(Object partial)",
        "public int hashCode()",
        "public int compareTo(ReadablePartial partial)",
        "public DateTime toDateTimeAtStartOfDay()",
        "public DateTime toDateTimeAtStartOfDay(DateTimeZone zone)",
        "public DateTime toDateTimeAtMidnight()",
        "public DateTime toDateTimeAtMidnight(DateTimeZone zone)",
        "public DateTime toDateTimeAtCurrentTime()",
        "public DateTime toDateTimeAtCurrentTime(DateTimeZone zone)",
        "public DateMidnight toDateMidnight()",
        "public DateMidnight toDateMidnight(DateTimeZone zone)",
        "public LocalDateTime toLocalDateTime(LocalTime time)",
        "public DateTime toDateTime(LocalTime time)",
        "public DateTime toDateTime(LocalTime time, DateTimeZone zone)",
        "public Interval toInterval()",
        "public Interval toInterval(DateTimeZone zone)",
        "public Date toDate()",
        "public LocalDate withFields(ReadablePartial partial)",
        "public LocalDate withField(DateTimeFieldType fieldType, int value)",
        "public LocalDate withFieldAdded(DurationFieldType fieldType, int amount)",
        "public LocalDate withPeriodAdded(ReadablePeriod period, int scalar)",
        "public LocalDate plus(ReadablePeriod period)",
        "public LocalDate plusYears(int years)",
        "public LocalDate plusMonths(int months)",
        "public LocalDate plusWeeks(int weeks)",
        "public LocalDate plusDays(int days)",
        "public LocalDate minus(ReadablePeriod period)",
        "public LocalDate minusYears(int years)",
        "public LocalDate minusMonths(int months)",
        "public LocalDate minusWeeks(int weeks)",
        "public LocalDate minusDays(int days)",
        "public Property property(DateTimeFieldType fieldType)",
        "public int getEra()",
        "public int getCenturyOfEra()",
        "public int getYearOfEra()",
        "public int getYearOfCentury()",
        "public int getYear()",
        "public int getWeekyear()",
        "public int getMonthOfYear()",
        "public int getWeekOfWeekyear()",
        "public int getDayOfYear()",
        "public int getDayOfMonth()",
        "public int getDayOfWeek()",
        "public LocalDate withEra(int era)",
        "public LocalDate withCenturyOfEra(int centuryOfEra)",
        "public LocalDate withYearOfEra(int yearOfEra)",
        "public LocalDate withYearOfCentury(int yearOfCentury)",
        "public LocalDate withYear(int year)",
        "public LocalDate withWeekyear(int weekyear)",
        "public LocalDate withMonthOfYear(int monthOfYear)",
        "public LocalDate withWeekOfWeekyear(int weekOfWeekyear)",
        "public LocalDate withDayOfYear(int dayOfYear)",
        "public LocalDate withDayOfMonth(int dayOfMonth)",
        "public LocalDate withDayOfWeek(int dayOfWeek)",
        "public Property era()",
        "public Property centuryOfEra()",
        "public Property yearOfCentury()",
        "public Property yearOfEra()",
        "public Property year()",
        "public Property weekyear()",
        "public Property monthOfYear()",
        "public Property weekOfWeekyear()",
        "public Property dayOfYear()",
        "public Property dayOfMonth()",
        "public Property dayOfWeek()",
        "public String toString()",
        "public String toString(String pattern)",
        "public String toString(String pattern, Locale locale) throws IllegalArgumentException",
        "private void writeObject(ObjectOutputStream oos) throws IOException",
        "private void readObject(ObjectInputStream oos) throws IOException, ClassNotFoundException",
        "public DateTimeField getField()",
        "protected long getMillis()",
        "protected Chronology getChronology()",
        "public LocalDate getLocalDate()",
        "public LocalDate addToCopy(int value)",
        "public LocalDate addWrapFieldToCopy(int value)",
        "public LocalDate setCopy(int value)",
        "public LocalDate setCopy(String text, Locale locale)",
        "public LocalDate setCopy(String text)",
        "public LocalDate withMaximumValue()",
        "public LocalDate withMinimumValue()",
        "public LocalDate roundFloorCopy()",
        "public LocalDate roundCeilingCopy()",
        "public LocalDate roundHalfFloorCopy()",
        "public LocalDate roundHalfCeilingCopy()",
        "public LocalDate roundHalfEvenCopy()"
      ],
      "methods": [
        {
          "buggy_method": "  public static LocalDate fromCalendarFields(Calendar calendar) {\n  if (calendar == null) {\n  throw new IllegalArgumentException(\"The calendar must not be null\");\n  }\n  int yearOfEra = calendar.get(Calendar.YEAR);\n  return new LocalDate(\n  yearOfEra,\n  calendar.get(Calendar.MONTH) + 1,\n  calendar.get(Calendar.DAY_OF_MONTH)\n  );\n  }",
          "fixed_method": "  public static LocalDate fromCalendarFields(Calendar calendar) {\n  if (calendar == null) {\n  throw new IllegalArgumentException(\"The calendar must not be null\");\n  }\n  int era = calendar.get(Calendar.ERA);\n  int yearOfEra = calendar.get(Calendar.YEAR);\n  return new LocalDate(\n  (era == GregorianCalendar.AD ? yearOfEra : 1 - yearOfEra),\n  calendar.get(Calendar.MONTH) + 1,\n  calendar.get(Calendar.DAY_OF_MONTH)\n  );\n  }",
          "diff": [
            "@@ -207,9 +207,10 @@",
            "         if (calendar == null) {\n",
            "             throw new IllegalArgumentException(\"The calendar must not be null\");\n",
            "         }\n",
            "+        int era = calendar.get(Calendar.ERA);\n",
            "         int yearOfEra = calendar.get(Calendar.YEAR);\n",
            "         return new LocalDate(\n",
            "-            yearOfEra,\n",
            "+            (era == GregorianCalendar.AD ? yearOfEra : 1 - yearOfEra),\n",
            "             calendar.get(Calendar.MONTH) + 1,\n",
            "             calendar.get(Calendar.DAY_OF_MONTH)\n",
            "         );\n"
          ],
          "changed_lines": 3
        },
        {
          "buggy_method": "  public static LocalDate fromDateFields(Date date) {\n  if (date == null) {\n  throw new IllegalArgumentException(\"The date must not be null\");\n  }\n  \n  return new LocalDate(\n  date.getYear() + 1900,\n  date.getMonth() + 1,\n  date.getDate()\n  );\n  }",
          "fixed_method": "  public static LocalDate fromDateFields(Date date) {\n  if (date == null) {\n  throw new IllegalArgumentException(\"The date must not be null\");\n  }\n  if (date.getTime() < 0) {\n  \n  GregorianCalendar cal = new GregorianCalendar();\n  cal.setTime(date);\n  return fromCalendarFields(cal);\n  }\n  return new LocalDate(\n  date.getYear() + 1900,\n  date.getMonth() + 1,\n  date.getDate()\n  );\n  }",
          "diff": [
            "@@ -240,7 +241,12 @@",
            "         if (date == null) {\n",
            "             throw new IllegalArgumentException(\"The date must not be null\");\n",
            "         }\n",
            "+        if (date.getTime() < 0) {\n",
            "             // handle years in era BC\n",
            "+            GregorianCalendar cal = new GregorianCalendar();\n",
            "+            cal.setTime(date);\n",
            "+            return fromCalendarFields(cal);\n",
            "+        }\n",
            "         return new LocalDate(\n",
            "             date.getYear() + 1900,\n",
            "             date.getMonth() + 1,\n"
          ],
          "changed_lines": 5
        }
      ]
    },
    {
      "name": "org/joda/time/LocalDateTime.java",
      "buggy_full_code": "\npackage org.joda.time;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.GregorianCalendar;\nimport java.util.Locale;\nimport java.util.TimeZone;\n\nimport org.joda.convert.FromString;\nimport org.joda.convert.ToString;\nimport org.joda.time.base.BaseLocal;\nimport org.joda.time.chrono.ISOChronology;\nimport org.joda.time.convert.ConverterManager;\nimport org.joda.time.convert.PartialConverter;\nimport org.joda.time.field.AbstractReadableInstantFieldProperty;\nimport org.joda.time.format.DateTimeFormat;\nimport org.joda.time.format.DateTimeFormatter;\nimport org.joda.time.format.ISODateTimeFormat;\n\n\npublic final class LocalDateTime extends BaseLocal implements ReadablePartial, Serializable { private static final long serialVersionUID = -268716875315837168L; private static final int YEAR = 0; private static final int MONTH_OF_YEAR = 1; private static final int DAY_OF_MONTH = 2; private static final int MILLIS_OF_DAY = 3; private final long iLocalMillis; private final Chronology iChronology; public static LocalDateTime now() {\n        return new LocalDateTime();\n    }\n\n    \n    public static LocalDateTime now(DateTimeZone zone) {\n        if (zone == null) {\n            throw new NullPointerException(\"Zone must not be null\");\n        }\n        return new LocalDateTime(zone);\n    }\n\n    \n    public static LocalDateTime now(Chronology chronology) {\n        if (chronology == null) {\n            throw new NullPointerException(\"Chronology must not be null\");\n        }\n        return new LocalDateTime(chronology);\n    }\n\n    \n    \n    @FromString\n    public static LocalDateTime parse(String str) {\n        return parse(str, ISODateTimeFormat.localDateOptionalTimeParser());\n    }\n\n    \n    public static LocalDateTime parse(String str, DateTimeFormatter formatter) {\n        return formatter.parseLocalDateTime(str);\n    }\n\n    \n    \n    public static LocalDateTime fromCalendarFields(Calendar calendar) {\n        if (calendar == null) {\n            throw new IllegalArgumentException(\"The calendar must not be null\");\n        }\n        int yearOfEra = calendar.get(Calendar.YEAR);\n        return new LocalDateTime(\n            yearOfEra,\n            calendar.get(Calendar.MONTH) + 1,\n            calendar.get(Calendar.DAY_OF_MONTH),\n            calendar.get(Calendar.HOUR_OF_DAY),\n            calendar.get(Calendar.MINUTE),\n            calendar.get(Calendar.SECOND),\n            calendar.get(Calendar.MILLISECOND)\n        );\n    }\n\n    \n    @SuppressWarnings(\"deprecation\")\n    public static LocalDateTime fromDateFields(Date date) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n            \n        return new LocalDateTime(\n            date.getYear() + 1900,\n            date.getMonth() + 1,\n            date.getDate(),\n            date.getHours(),\n            date.getMinutes(),\n            date.getSeconds(),\n            (((int) (date.getTime() % 1000)) + 1000) % 1000\n        );\n    }\n\n    \n    \n    public LocalDateTime() {\n        this(DateTimeUtils.currentTimeMillis(), ISOChronology.getInstance());\n    }\n\n    \n    public LocalDateTime(DateTimeZone zone) {\n        this(DateTimeUtils.currentTimeMillis(), ISOChronology.getInstance(zone));\n    }\n\n    \n    public LocalDateTime(Chronology chronology) {\n        this(DateTimeUtils.currentTimeMillis(), chronology);\n    }\n\n    \n    \n    public LocalDateTime(long instant) {\n        this(instant, ISOChronology.getInstance());\n    }\n\n    \n    public LocalDateTime(long instant, DateTimeZone zone) {\n        this(instant, ISOChronology.getInstance(zone));\n    }\n\n    \n    public LocalDateTime(long instant, Chronology chronology) {\n        chronology = DateTimeUtils.getChronology(chronology);\n        \n        long localMillis = chronology.getZone().getMillisKeepLocal(DateTimeZone.UTC, instant);\n        iLocalMillis = localMillis;\n        iChronology = chronology.withUTC();\n    }\n\n    \n    \n    public LocalDateTime(Object instant) {\n        this(instant, (Chronology) null);\n    }\n\n    \n    public LocalDateTime(Object instant, DateTimeZone zone) {\n        PartialConverter converter = ConverterManager.getInstance().getPartialConverter(instant);\n        Chronology chronology = converter.getChronology(instant, zone);\n        chronology = DateTimeUtils.getChronology(chronology);\n        iChronology = chronology.withUTC();\n        int[] values = converter.getPartialValues(this, instant, chronology, ISODateTimeFormat.localDateOptionalTimeParser());\n        iLocalMillis = iChronology.getDateTimeMillis(values[0], values[1], values[2], values[3]);\n    }\n\n    \n    public LocalDateTime(Object instant, Chronology chronology) {\n        PartialConverter converter = ConverterManager.getInstance().getPartialConverter(instant);\n        chronology = converter.getChronology(instant, chronology);\n        chronology = DateTimeUtils.getChronology(chronology);\n        iChronology = chronology.withUTC();\n        int[] values = converter.getPartialValues(this, instant, chronology, ISODateTimeFormat.localDateOptionalTimeParser());\n        iLocalMillis = iChronology.getDateTimeMillis(values[0], values[1], values[2], values[3]);\n    }\n\n    \n    \n    public LocalDateTime( int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour) {\n        this(year, monthOfYear, dayOfMonth, hourOfDay,\n            minuteOfHour, 0, 0, ISOChronology.getInstanceUTC());\n    }\n\n    \n    public LocalDateTime( int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute) {\n        this(year, monthOfYear, dayOfMonth, hourOfDay,\n            minuteOfHour, secondOfMinute, 0, ISOChronology.getInstanceUTC());\n    }\n\n    \n    public LocalDateTime( int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) {\n        this(year, monthOfYear, dayOfMonth, hourOfDay,\n            minuteOfHour, secondOfMinute, millisOfSecond, ISOChronology.getInstanceUTC());\n    }\n\n    \n    public LocalDateTime( int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology) {\n        super();\n        chronology = DateTimeUtils.getChronology(chronology).withUTC();\n        long instant = chronology.getDateTimeMillis(year, monthOfYear, dayOfMonth,\n            hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n        iChronology = chronology;\n        iLocalMillis = instant;\n    }\n\n    \n    private Object readResolve() {\n        if (iChronology == null) {\n            return new LocalDateTime(iLocalMillis, ISOChronology.getInstanceUTC());\n        }\n        if (DateTimeZone.UTC.equals(iChronology.getZone()) == false) {\n            return new LocalDateTime(iLocalMillis, iChronology.withUTC());\n        }\n        return this;\n    }\n\n    \n    \n    public int size() {\n        return 4;\n    }\n\n    \n    protected DateTimeField getField(int index, Chronology chrono) {\n        switch (index) {\n            case YEAR:\n                return chrono.year();\n            case MONTH_OF_YEAR:\n                return chrono.monthOfYear();\n            case DAY_OF_MONTH:\n                return chrono.dayOfMonth();\n            case MILLIS_OF_DAY:\n                return chrono.millisOfDay();\n            default:\n                throw new IndexOutOfBoundsException(\"Invalid index: \" + index);\n        }\n    }\n\n    \n    public int getValue(int index) {\n        switch (index) {\n            case YEAR:\n                return getChronology().year().get(getLocalMillis());\n            case MONTH_OF_YEAR:\n                return getChronology().monthOfYear().get(getLocalMillis());\n            case DAY_OF_MONTH:\n                return getChronology().dayOfMonth().get(getLocalMillis());\n            case MILLIS_OF_DAY:\n                return getChronology().millisOfDay().get(getLocalMillis());\n            default:\n                throw new IndexOutOfBoundsException(\"Invalid index: \" + index);\n        }\n    }\n\n    \n    \n    public int get(DateTimeFieldType type) {\n        if (type == null) {\n            throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\");\n        }\n        return type.getField(getChronology()).get(getLocalMillis());\n    }\n\n    \n    public boolean isSupported(DateTimeFieldType type) {\n        if (type == null) {\n            return false;\n        }\n        return type.getField(getChronology()).isSupported();\n    }\n\n    \n    public boolean isSupported(DurationFieldType type) {\n        if (type == null) {\n            return false;\n        }\n        return type.getField(getChronology()).isSupported();\n    }\n\n    \n    \n    protected long getLocalMillis() {\n        return iLocalMillis;\n    }\n\n    \n    public Chronology getChronology() {\n        return iChronology;\n    }\n\n    \n    \n    public boolean equals(Object partial) {\n        \n        if (this == partial) {\n            return true;\n        }\n        if (partial instanceof LocalDateTime) {\n            LocalDateTime other = (LocalDateTime) partial;\n            if (iChronology.equals(other.iChronology)) {\n                return iLocalMillis == other.iLocalMillis;\n            }\n        }\n        return super.equals(partial);\n    }\n\n    \n    public int compareTo(ReadablePartial partial) {\n        \n        if (this == partial) {\n            return 0;\n        }\n        if (partial instanceof LocalDateTime) {\n            LocalDateTime other = (LocalDateTime) partial;\n            if (iChronology.equals(other.iChronology)) {\n                return (iLocalMillis < other.iLocalMillis ? -1 :\n                            (iLocalMillis == other.iLocalMillis ? 0 : 1));\n\n            }\n        }\n        return super.compareTo(partial);\n    }\n\n    \n    \n    public DateTime toDateTime() {\n        return toDateTime((DateTimeZone) null);\n    }\n\n    \n    public DateTime toDateTime(DateTimeZone zone) {\n        zone = DateTimeUtils.getZone(zone);\n        Chronology chrono = iChronology.withZone(zone);\n        return new DateTime(\n                getYear(), getMonthOfYear(), getDayOfMonth(),\n                getHourOfDay(), getMinuteOfHour(),\n                getSecondOfMinute(), getMillisOfSecond(), chrono);\n    }\n\n    \n    \n    public LocalDate toLocalDate() {\n        return new LocalDate(getLocalMillis(), getChronology());\n    }\n\n    \n    public LocalTime toLocalTime() {\n        return new LocalTime(getLocalMillis(), getChronology());\n    }\n\n    \n    \n    @SuppressWarnings(\"deprecation\")\n    public Date toDate() {\n        int dom = getDayOfMonth();\n        Date date = new Date(getYear() - 1900, getMonthOfYear() - 1, dom,\n                        getHourOfDay(), getMinuteOfHour(), getSecondOfMinute());\n        date.setTime(date.getTime() + getMillisOfSecond());\n        LocalDateTime check = LocalDateTime.fromDateFields(date);\n        if (check.isBefore(this)) {\n            \n            \n            while (check.isBefore(this)) {\n                date.setTime(date.getTime() + 60000);\n                check = LocalDateTime.fromDateFields(date);\n            }\n            \n            while (check.isBefore(this) == false) {\n                date.setTime(date.getTime() - 1000);\n                check = LocalDateTime.fromDateFields(date);\n            }\n            date.setTime(date.getTime() + 1000);\n        } else if (check.equals(this)) {\n            \n            Date earlier = new Date(date.getTime() - TimeZone.getDefault().getDSTSavings());\n            check = LocalDateTime.fromDateFields(earlier);\n            if (check.equals(this)) {\n                date = earlier;\n            }\n        }\n        return date;\n    }\n\n    \n    \n    LocalDateTime withLocalMillis(long newMillis) {\n        return (newMillis == getLocalMillis() ? this : new LocalDateTime(newMillis, getChronology()));\n    }\n\n    \n    \n    public LocalDateTime withDate(int year, int monthOfYear, int dayOfMonth) {\n        Chronology chrono = getChronology();\n        long instant = getLocalMillis();\n        instant = chrono.year().set(instant, year);\n        instant = chrono.monthOfYear().set(instant, monthOfYear);\n        instant = chrono.dayOfMonth().set(instant, dayOfMonth);\n        return withLocalMillis(instant);\n    }\n\n    \n    public LocalDateTime withTime(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) {\n        Chronology chrono = getChronology();\n        long instant = getLocalMillis();\n        instant = chrono.hourOfDay().set(instant, hourOfDay);\n        instant = chrono.minuteOfHour().set(instant, minuteOfHour);\n        instant = chrono.secondOfMinute().set(instant, secondOfMinute);\n        instant = chrono.millisOfSecond().set(instant, millisOfSecond);\n        return withLocalMillis(instant);\n    }\n\n    \n    \n    public LocalDateTime withFields(ReadablePartial partial) {\n        if (partial == null) {\n            return this;\n        }\n        return withLocalMillis(getChronology().set(partial, getLocalMillis()));\n    }\n\n    \n    public LocalDateTime withField(DateTimeFieldType fieldType, int value) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"Field must not be null\");\n        }\n        long instant = fieldType.getField(getChronology()).set(getLocalMillis(), value);\n        return withLocalMillis(instant);\n    }\n\n    \n    public LocalDateTime withFieldAdded(DurationFieldType fieldType, int amount) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"Field must not be null\");\n        }\n        if (amount == 0) {\n            return this;\n        }\n        long instant = fieldType.getField(getChronology()).add(getLocalMillis(), amount);\n        return withLocalMillis(instant);\n    }\n\n    \n    \n    public LocalDateTime withDurationAdded(ReadableDuration durationToAdd, int scalar) {\n        if (durationToAdd == null || scalar == 0) {\n            return this;\n        }\n        long instant = getChronology().add(getLocalMillis(), durationToAdd.getMillis(), scalar);\n        return withLocalMillis(instant);\n    }\n\n    \n    public LocalDateTime withPeriodAdded(ReadablePeriod period, int scalar) {\n        if (period == null || scalar == 0) {\n            return this;\n        }\n        long instant = getChronology().add(period, getLocalMillis(), scalar);\n        return withLocalMillis(instant);\n    }\n\n    \n    \n    public LocalDateTime plus(ReadableDuration duration) {\n        return withDurationAdded(duration, 1);\n    }\n\n    \n    public LocalDateTime plus(ReadablePeriod period) {\n        return withPeriodAdded(period, 1);\n    }\n\n    \n    \n    public LocalDateTime plusYears(int years) {\n        if (years == 0) {\n            return this;\n        }\n        long instant = getChronology().years().add(getLocalMillis(), years);\n        return withLocalMillis(instant);\n    }\n\n    \n    public LocalDateTime plusMonths(int months) {\n        if (months == 0) {\n            return this;\n        }\n        long instant = getChronology().months().add(getLocalMillis(), months);\n        return withLocalMillis(instant);\n    }\n\n    \n    public LocalDateTime plusWeeks(int weeks) {\n        if (weeks == 0) {\n            return this;\n        }\n        long instant = getChronology().weeks().add(getLocalMillis(), weeks);\n        return withLocalMillis(instant);\n    }\n\n    \n    public LocalDateTime plusDays(int days) {\n        if (days == 0) {\n            return this;\n        }\n        long instant = getChronology().days().add(getLocalMillis(), days);\n        return withLocalMillis(instant);\n    }\n\n    \n    \n    public LocalDateTime plusHours(int hours) {\n        if (hours == 0) {\n            return this;\n        }\n        long instant = getChronology().hours().add(getLocalMillis(), hours);\n        return withLocalMillis(instant);\n    }\n\n    \n    public LocalDateTime plusMinutes(int minutes) {\n        if (minutes == 0) {\n            return this;\n        }\n        long instant = getChronology().minutes().add(getLocalMillis(), minutes);\n        return withLocalMillis(instant);\n    }\n\n    \n    public LocalDateTime plusSeconds(int seconds) {\n        if (seconds == 0) {\n            return this;\n        }\n        long instant = getChronology().seconds().add(getLocalMillis(), seconds);\n        return withLocalMillis(instant);\n    }\n\n    \n    public LocalDateTime plusMillis(int millis) {\n        if (millis == 0) {\n            return this;\n        }\n        long instant = getChronology().millis().add(getLocalMillis(), millis);\n        return withLocalMillis(instant);\n    }\n\n    \n    \n    public LocalDateTime minus(ReadableDuration duration) {\n        return withDurationAdded(duration, -1);\n    }\n\n    \n    public LocalDateTime minus(ReadablePeriod period) {\n        return withPeriodAdded(period, -1);\n    }\n\n    \n    \n    public LocalDateTime minusYears(int years) {\n        if (years == 0) {\n            return this;\n        }\n        long instant = getChronology().years().subtract(getLocalMillis(), years);\n        return withLocalMillis(instant);\n    }\n\n    \n    public LocalDateTime minusMonths(int months) {\n        if (months == 0) {\n            return this;\n        }\n        long instant = getChronology().months().subtract(getLocalMillis(), months);\n        return withLocalMillis(instant);\n    }\n\n    \n    public LocalDateTime minusWeeks(int weeks) {\n        if (weeks == 0) {\n            return this;\n        }\n        long instant = getChronology().weeks().subtract(getLocalMillis(), weeks);\n        return withLocalMillis(instant);\n    }\n\n    \n    public LocalDateTime minusDays(int days) {\n        if (days == 0) {\n            return this;\n        }\n        long instant = getChronology().days().subtract(getLocalMillis(), days);\n        return withLocalMillis(instant);\n    }\n\n    \n    \n    public LocalDateTime minusHours(int hours) {\n        if (hours == 0) {\n            return this;\n        }\n        long instant = getChronology().hours().subtract(getLocalMillis(), hours);\n        return withLocalMillis(instant);\n    }\n\n    \n    public LocalDateTime minusMinutes(int minutes) {\n        if (minutes == 0) {\n            return this;\n        }\n        long instant = getChronology().minutes().subtract(getLocalMillis(), minutes);\n        return withLocalMillis(instant);\n    }\n\n    \n    public LocalDateTime minusSeconds(int seconds) {\n        if (seconds == 0) {\n            return this;\n        }\n        long instant = getChronology().seconds().subtract(getLocalMillis(), seconds);\n        return withLocalMillis(instant);\n    }\n\n    \n    public LocalDateTime minusMillis(int millis) {\n        if (millis == 0) {\n            return this;\n        }\n        long instant = getChronology().millis().subtract(getLocalMillis(), millis);\n        return withLocalMillis(instant);\n    }\n\n    \n    \n    public Property property(DateTimeFieldType fieldType) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\");\n        }\n        if (isSupported(fieldType) == false) {\n            throw new IllegalArgumentException(\"Field '\" + fieldType + \"' is not supported\");\n        }\n        return new Property(this, fieldType.getField(getChronology()));\n    }\n\n    \n    \n    public int getEra() {\n        return getChronology().era().get(getLocalMillis());\n    }\n\n    \n    public int getCenturyOfEra() {\n        return getChronology().centuryOfEra().get(getLocalMillis());\n    }\n\n    \n    public int getYearOfEra() {\n        return getChronology().yearOfEra().get(getLocalMillis());\n    }\n\n    \n    public int getYearOfCentury() {\n        return getChronology().yearOfCentury().get(getLocalMillis());\n    }\n\n    \n    public int getYear() {\n        return getChronology().year().get(getLocalMillis());\n    }\n\n    \n    public int getWeekyear() {\n        return getChronology().weekyear().get(getLocalMillis());\n    }\n\n    \n    public int getMonthOfYear() {\n        return getChronology().monthOfYear().get(getLocalMillis());\n    }\n\n    \n    public int getWeekOfWeekyear() {\n        return getChronology().weekOfWeekyear().get(getLocalMillis());\n    }\n\n    \n    public int getDayOfYear() {\n        return getChronology().dayOfYear().get(getLocalMillis());\n    }\n\n    \n    public int getDayOfMonth() {\n        return getChronology().dayOfMonth().get(getLocalMillis());\n    }\n\n    \n    public int getDayOfWeek() {\n        return getChronology().dayOfWeek().get(getLocalMillis());\n    }\n\n    \n    \n    public int getHourOfDay() {\n        return getChronology().hourOfDay().get(getLocalMillis());\n    }\n\n    \n    public int getMinuteOfHour() {\n        return getChronology().minuteOfHour().get(getLocalMillis());\n    }\n\n    \n    public int getSecondOfMinute() {\n        return getChronology().secondOfMinute().get(getLocalMillis());\n    }\n\n    \n    public int getMillisOfSecond() {\n        return getChronology().millisOfSecond().get(getLocalMillis());\n    }\n\n    \n    public int getMillisOfDay() {\n        return getChronology().millisOfDay().get(getLocalMillis());\n    }\n\n    \n    \n    public LocalDateTime withEra(int era) {\n        return withLocalMillis(getChronology().era().set(getLocalMillis(), era));\n    }\n\n    \n    public LocalDateTime withCenturyOfEra(int centuryOfEra) {\n        return withLocalMillis(getChronology().centuryOfEra().set(getLocalMillis(), centuryOfEra));\n    }\n\n    \n    public LocalDateTime withYearOfEra(int yearOfEra) {\n        return withLocalMillis(getChronology().yearOfEra().set(getLocalMillis(), yearOfEra));\n    }\n\n    \n    public LocalDateTime withYearOfCentury(int yearOfCentury) {\n        return withLocalMillis(getChronology().yearOfCentury().set(getLocalMillis(), yearOfCentury));\n    }\n\n    \n    public LocalDateTime withYear(int year) {\n        return withLocalMillis(getChronology().year().set(getLocalMillis(), year));\n    }\n\n    \n    public LocalDateTime withWeekyear(int weekyear) {\n        return withLocalMillis(getChronology().weekyear().set(getLocalMillis(), weekyear));\n    }\n\n    \n    public LocalDateTime withMonthOfYear(int monthOfYear) {\n        return withLocalMillis(getChronology().monthOfYear().set(getLocalMillis(), monthOfYear));\n    }\n\n    \n    public LocalDateTime withWeekOfWeekyear(int weekOfWeekyear) {\n        return withLocalMillis(getChronology().weekOfWeekyear().set(getLocalMillis(), weekOfWeekyear));\n    }\n\n    \n    public LocalDateTime withDayOfYear(int dayOfYear) {\n        return withLocalMillis(getChronology().dayOfYear().set(getLocalMillis(), dayOfYear));\n    }\n\n    \n    public LocalDateTime withDayOfMonth(int dayOfMonth) {\n        return withLocalMillis(getChronology().dayOfMonth().set(getLocalMillis(), dayOfMonth));\n    }\n\n    \n    public LocalDateTime withDayOfWeek(int dayOfWeek) {\n        return withLocalMillis(getChronology().dayOfWeek().set(getLocalMillis(), dayOfWeek));\n    }\n\n    \n    \n    public LocalDateTime withHourOfDay(int hour) {\n        return withLocalMillis(getChronology().hourOfDay().set(getLocalMillis(), hour));\n    }\n\n    \n    public LocalDateTime withMinuteOfHour(int minute) {\n        return withLocalMillis(getChronology().minuteOfHour().set(getLocalMillis(), minute));\n    }\n\n    \n    public LocalDateTime withSecondOfMinute(int second) {\n        return withLocalMillis(getChronology().secondOfMinute().set(getLocalMillis(), second));\n    }\n\n    \n    public LocalDateTime withMillisOfSecond(int millis) {\n        return withLocalMillis(getChronology().millisOfSecond().set(getLocalMillis(), millis));\n    }\n\n    \n    public LocalDateTime withMillisOfDay(int millis) {\n        return withLocalMillis(getChronology().millisOfDay().set(getLocalMillis(), millis));\n    }\n\n    \n    \n    public Property era() {\n        return new Property(this, getChronology().era());\n    }\n\n    \n    public Property centuryOfEra() {\n        return new Property(this, getChronology().centuryOfEra());\n    }\n\n    \n    public Property yearOfCentury() {\n        return new Property(this, getChronology().yearOfCentury());\n    }\n\n    \n    public Property yearOfEra() {\n        return new Property(this, getChronology().yearOfEra());\n    }\n\n    \n    public Property year() {\n        return new Property(this, getChronology().year());\n    }\n\n    \n    public Property weekyear() {\n        return new Property(this, getChronology().weekyear());\n    }\n\n    \n    public Property monthOfYear() {\n        return new Property(this, getChronology().monthOfYear());\n    }\n\n    \n    public Property weekOfWeekyear() {\n        return new Property(this, getChronology().weekOfWeekyear());\n    }\n\n    \n    public Property dayOfYear() {\n        return new Property(this, getChronology().dayOfYear());\n    }\n\n    \n    public Property dayOfMonth() {\n        return new Property(this, getChronology().dayOfMonth());\n    }\n\n    \n    public Property dayOfWeek() {\n        return new Property(this, getChronology().dayOfWeek());\n    }\n\n    \n    \n    public Property hourOfDay() {\n        return new Property(this, getChronology().hourOfDay());\n    }\n\n    \n    public Property minuteOfHour() {\n        return new Property(this, getChronology().minuteOfHour());\n    }\n\n    \n    public Property secondOfMinute() {\n        return new Property(this, getChronology().secondOfMinute());\n    }\n\n    \n    public Property millisOfSecond() {\n        return new Property(this, getChronology().millisOfSecond());\n    }\n\n    \n    public Property millisOfDay() {\n        return new Property(this, getChronology().millisOfDay());\n    }\n\n    \n    \n    @ToString\n    public String toString() {\n        return ISODateTimeFormat.dateTime().print(this);\n    }\n\n    \n    public String toString(String pattern) {\n        if (pattern == null) {\n            return toString();\n        }\n        return DateTimeFormat.forPattern(pattern).print(this);\n    }\n\n    \n    public String toString(String pattern, Locale locale) throws IllegalArgumentException {\n        if (pattern == null) {\n            return toString();\n        }\n        return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this);\n    }\n\n    \n    \n    public static final class Property extends AbstractReadableInstantFieldProperty { private static final long serialVersionUID = -358138762846288L; private transient LocalDateTime iInstant; private transient DateTimeField iField; Property(LocalDateTime instant, DateTimeField field) {\n            super();\n            iInstant = instant;\n            iField = field;\n        }\n        \n        \n        private void writeObject(ObjectOutputStream oos) throws IOException {\n            oos.writeObject(iInstant);\n            oos.writeObject(iField.getType());\n        }\n\n        \n        private void readObject(ObjectInputStream oos) throws IOException, ClassNotFoundException {\n            iInstant = (LocalDateTime) oos.readObject();\n            DateTimeFieldType type = (DateTimeFieldType) oos.readObject();\n            iField = type.getField(iInstant.getChronology());\n        }\n\n        \n        \n        public DateTimeField getField() {\n            return iField;\n        }\n        \n        \n        protected long getMillis() {\n            return iInstant.getLocalMillis();\n        }\n        \n        \n        protected Chronology getChronology() {\n            return iInstant.getChronology();\n        }\n        \n        \n        public LocalDateTime getLocalDateTime() {\n            return iInstant;\n        }\n        \n        \n        \n        public LocalDateTime addToCopy(int value) {\n            return iInstant.withLocalMillis(iField.add(iInstant.getLocalMillis(), value));\n        }\n        \n        \n        public LocalDateTime addToCopy(long value) {\n            return iInstant.withLocalMillis(iField.add(iInstant.getLocalMillis(), value));\n        }\n        \n        \n        public LocalDateTime addWrapFieldToCopy(int value) {\n            return iInstant.withLocalMillis(iField.addWrapField(iInstant.getLocalMillis(), value));\n        }\n        \n        \n        \n        public LocalDateTime setCopy(int value) {\n            return iInstant.withLocalMillis(iField.set(iInstant.getLocalMillis(), value));\n        }\n        \n        \n        public LocalDateTime setCopy(String text, Locale locale) {\n            return iInstant.withLocalMillis(iField.set(iInstant.getLocalMillis(), text, locale));\n        }\n        \n        \n        public LocalDateTime setCopy(String text) {\n            return setCopy(text, null);\n        }\n        \n        \n        \n        public LocalDateTime withMaximumValue() {\n            return setCopy(getMaximumValue());\n        }\n        \n        \n        public LocalDateTime withMinimumValue() {\n            return setCopy(getMinimumValue());\n        }\n        \n        \n        \n        public LocalDateTime roundFloorCopy() {\n            return iInstant.withLocalMillis(iField.roundFloor(iInstant.getLocalMillis()));\n        }\n        \n        \n        public LocalDateTime roundCeilingCopy() {\n            return iInstant.withLocalMillis(iField.roundCeiling(iInstant.getLocalMillis()));\n        }\n        \n        \n        public LocalDateTime roundHalfFloorCopy() {\n            return iInstant.withLocalMillis(iField.roundHalfFloor(iInstant.getLocalMillis()));\n        }\n        \n        \n        public LocalDateTime roundHalfCeilingCopy() {\n            return iInstant.withLocalMillis(iField.roundHalfCeiling(iInstant.getLocalMillis()));\n        }\n        \n        \n        public LocalDateTime roundHalfEvenCopy() {\n            return iInstant.withLocalMillis(iField.roundHalfEven(iInstant.getLocalMillis()));\n        }\n    }\n\n}\n",
      "fixed_full_code": "\npackage org.joda.time;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.GregorianCalendar;\nimport java.util.Locale;\nimport java.util.TimeZone;\n\nimport org.joda.convert.FromString;\nimport org.joda.convert.ToString;\nimport org.joda.time.base.BaseLocal;\nimport org.joda.time.chrono.ISOChronology;\nimport org.joda.time.convert.ConverterManager;\nimport org.joda.time.convert.PartialConverter;\nimport org.joda.time.field.AbstractReadableInstantFieldProperty;\nimport org.joda.time.format.DateTimeFormat;\nimport org.joda.time.format.DateTimeFormatter;\nimport org.joda.time.format.ISODateTimeFormat;\n\n\npublic final class LocalDateTime extends BaseLocal implements ReadablePartial, Serializable { private static final long serialVersionUID = -268716875315837168L; private static final int YEAR = 0; private static final int MONTH_OF_YEAR = 1; private static final int DAY_OF_MONTH = 2; private static final int MILLIS_OF_DAY = 3; private final long iLocalMillis; private final Chronology iChronology; public static LocalDateTime now() {\n        return new LocalDateTime();\n    }\n\n    \n    public static LocalDateTime now(DateTimeZone zone) {\n        if (zone == null) {\n            throw new NullPointerException(\"Zone must not be null\");\n        }\n        return new LocalDateTime(zone);\n    }\n\n    \n    public static LocalDateTime now(Chronology chronology) {\n        if (chronology == null) {\n            throw new NullPointerException(\"Chronology must not be null\");\n        }\n        return new LocalDateTime(chronology);\n    }\n\n    \n    \n    @FromString\n    public static LocalDateTime parse(String str) {\n        return parse(str, ISODateTimeFormat.localDateOptionalTimeParser());\n    }\n\n    \n    public static LocalDateTime parse(String str, DateTimeFormatter formatter) {\n        return formatter.parseLocalDateTime(str);\n    }\n\n    \n    \n    public static LocalDateTime fromCalendarFields(Calendar calendar) {\n        if (calendar == null) {\n            throw new IllegalArgumentException(\"The calendar must not be null\");\n        }\n        int era = calendar.get(Calendar.ERA);\n        int yearOfEra = calendar.get(Calendar.YEAR);\n        return new LocalDateTime(\n            (era == GregorianCalendar.AD ? yearOfEra : 1 - yearOfEra),\n            calendar.get(Calendar.MONTH) + 1,\n            calendar.get(Calendar.DAY_OF_MONTH),\n            calendar.get(Calendar.HOUR_OF_DAY),\n            calendar.get(Calendar.MINUTE),\n            calendar.get(Calendar.SECOND),\n            calendar.get(Calendar.MILLISECOND)\n        );\n    }\n\n    \n    @SuppressWarnings(\"deprecation\")\n    public static LocalDateTime fromDateFields(Date date) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        if (date.getTime() < 0) {\n            \n            GregorianCalendar cal = new GregorianCalendar();\n            cal.setTime(date);\n            return fromCalendarFields(cal);\n        }\n        return new LocalDateTime(\n            date.getYear() + 1900,\n            date.getMonth() + 1,\n            date.getDate(),\n            date.getHours(),\n            date.getMinutes(),\n            date.getSeconds(),\n            (((int) (date.getTime() % 1000)) + 1000) % 1000\n        );\n    }\n\n    \n    \n    public LocalDateTime() {\n        this(DateTimeUtils.currentTimeMillis(), ISOChronology.getInstance());\n    }\n\n    \n    public LocalDateTime(DateTimeZone zone) {\n        this(DateTimeUtils.currentTimeMillis(), ISOChronology.getInstance(zone));\n    }\n\n    \n    public LocalDateTime(Chronology chronology) {\n        this(DateTimeUtils.currentTimeMillis(), chronology);\n    }\n\n    \n    \n    public LocalDateTime(long instant) {\n        this(instant, ISOChronology.getInstance());\n    }\n\n    \n    public LocalDateTime(long instant, DateTimeZone zone) {\n        this(instant, ISOChronology.getInstance(zone));\n    }\n\n    \n    public LocalDateTime(long instant, Chronology chronology) {\n        chronology = DateTimeUtils.getChronology(chronology);\n        \n        long localMillis = chronology.getZone().getMillisKeepLocal(DateTimeZone.UTC, instant);\n        iLocalMillis = localMillis;\n        iChronology = chronology.withUTC();\n    }\n\n    \n    \n    public LocalDateTime(Object instant) {\n        this(instant, (Chronology) null);\n    }\n\n    \n    public LocalDateTime(Object instant, DateTimeZone zone) {\n        PartialConverter converter = ConverterManager.getInstance().getPartialConverter(instant);\n        Chronology chronology = converter.getChronology(instant, zone);\n        chronology = DateTimeUtils.getChronology(chronology);\n        iChronology = chronology.withUTC();\n        int[] values = converter.getPartialValues(this, instant, chronology, ISODateTimeFormat.localDateOptionalTimeParser());\n        iLocalMillis = iChronology.getDateTimeMillis(values[0], values[1], values[2], values[3]);\n    }\n\n    \n    public LocalDateTime(Object instant, Chronology chronology) {\n        PartialConverter converter = ConverterManager.getInstance().getPartialConverter(instant);\n        chronology = converter.getChronology(instant, chronology);\n        chronology = DateTimeUtils.getChronology(chronology);\n        iChronology = chronology.withUTC();\n        int[] values = converter.getPartialValues(this, instant, chronology, ISODateTimeFormat.localDateOptionalTimeParser());\n        iLocalMillis = iChronology.getDateTimeMillis(values[0], values[1], values[2], values[3]);\n    }\n\n    \n    \n    public LocalDateTime( int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour) {\n        this(year, monthOfYear, dayOfMonth, hourOfDay,\n            minuteOfHour, 0, 0, ISOChronology.getInstanceUTC());\n    }\n\n    \n    public LocalDateTime( int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute) {\n        this(year, monthOfYear, dayOfMonth, hourOfDay,\n            minuteOfHour, secondOfMinute, 0, ISOChronology.getInstanceUTC());\n    }\n\n    \n    public LocalDateTime( int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) {\n        this(year, monthOfYear, dayOfMonth, hourOfDay,\n            minuteOfHour, secondOfMinute, millisOfSecond, ISOChronology.getInstanceUTC());\n    }\n\n    \n    public LocalDateTime( int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology) {\n        super();\n        chronology = DateTimeUtils.getChronology(chronology).withUTC();\n        long instant = chronology.getDateTimeMillis(year, monthOfYear, dayOfMonth,\n            hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n        iChronology = chronology;\n        iLocalMillis = instant;\n    }\n\n    \n    private Object readResolve() {\n        if (iChronology == null) {\n            return new LocalDateTime(iLocalMillis, ISOChronology.getInstanceUTC());\n        }\n        if (DateTimeZone.UTC.equals(iChronology.getZone()) == false) {\n            return new LocalDateTime(iLocalMillis, iChronology.withUTC());\n        }\n        return this;\n    }\n\n    \n    \n    public int size() {\n        return 4;\n    }\n\n    \n    protected DateTimeField getField(int index, Chronology chrono) {\n        switch (index) {\n            case YEAR:\n                return chrono.year();\n            case MONTH_OF_YEAR:\n                return chrono.monthOfYear();\n            case DAY_OF_MONTH:\n                return chrono.dayOfMonth();\n            case MILLIS_OF_DAY:\n                return chrono.millisOfDay();\n            default:\n                throw new IndexOutOfBoundsException(\"Invalid index: \" + index);\n        }\n    }\n\n    \n    public int getValue(int index) {\n        switch (index) {\n            case YEAR:\n                return getChronology().year().get(getLocalMillis());\n            case MONTH_OF_YEAR:\n                return getChronology().monthOfYear().get(getLocalMillis());\n            case DAY_OF_MONTH:\n                return getChronology().dayOfMonth().get(getLocalMillis());\n            case MILLIS_OF_DAY:\n                return getChronology().millisOfDay().get(getLocalMillis());\n            default:\n                throw new IndexOutOfBoundsException(\"Invalid index: \" + index);\n        }\n    }\n\n    \n    \n    public int get(DateTimeFieldType type) {\n        if (type == null) {\n            throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\");\n        }\n        return type.getField(getChronology()).get(getLocalMillis());\n    }\n\n    \n    public boolean isSupported(DateTimeFieldType type) {\n        if (type == null) {\n            return false;\n        }\n        return type.getField(getChronology()).isSupported();\n    }\n\n    \n    public boolean isSupported(DurationFieldType type) {\n        if (type == null) {\n            return false;\n        }\n        return type.getField(getChronology()).isSupported();\n    }\n\n    \n    \n    protected long getLocalMillis() {\n        return iLocalMillis;\n    }\n\n    \n    public Chronology getChronology() {\n        return iChronology;\n    }\n\n    \n    \n    public boolean equals(Object partial) {\n        \n        if (this == partial) {\n            return true;\n        }\n        if (partial instanceof LocalDateTime) {\n            LocalDateTime other = (LocalDateTime) partial;\n            if (iChronology.equals(other.iChronology)) {\n                return iLocalMillis == other.iLocalMillis;\n            }\n        }\n        return super.equals(partial);\n    }\n\n    \n    public int compareTo(ReadablePartial partial) {\n        \n        if (this == partial) {\n            return 0;\n        }\n        if (partial instanceof LocalDateTime) {\n            LocalDateTime other = (LocalDateTime) partial;\n            if (iChronology.equals(other.iChronology)) {\n                return (iLocalMillis < other.iLocalMillis ? -1 :\n                            (iLocalMillis == other.iLocalMillis ? 0 : 1));\n\n            }\n        }\n        return super.compareTo(partial);\n    }\n\n    \n    \n    public DateTime toDateTime() {\n        return toDateTime((DateTimeZone) null);\n    }\n\n    \n    public DateTime toDateTime(DateTimeZone zone) {\n        zone = DateTimeUtils.getZone(zone);\n        Chronology chrono = iChronology.withZone(zone);\n        return new DateTime(\n                getYear(), getMonthOfYear(), getDayOfMonth(),\n                getHourOfDay(), getMinuteOfHour(),\n                getSecondOfMinute(), getMillisOfSecond(), chrono);\n    }\n\n    \n    \n    public LocalDate toLocalDate() {\n        return new LocalDate(getLocalMillis(), getChronology());\n    }\n\n    \n    public LocalTime toLocalTime() {\n        return new LocalTime(getLocalMillis(), getChronology());\n    }\n\n    \n    \n    @SuppressWarnings(\"deprecation\")\n    public Date toDate() {\n        int dom = getDayOfMonth();\n        Date date = new Date(getYear() - 1900, getMonthOfYear() - 1, dom,\n                        getHourOfDay(), getMinuteOfHour(), getSecondOfMinute());\n        date.setTime(date.getTime() + getMillisOfSecond());\n        LocalDateTime check = LocalDateTime.fromDateFields(date);\n        if (check.isBefore(this)) {\n            \n            \n            while (check.isBefore(this)) {\n                date.setTime(date.getTime() + 60000);\n                check = LocalDateTime.fromDateFields(date);\n            }\n            \n            while (check.isBefore(this) == false) {\n                date.setTime(date.getTime() - 1000);\n                check = LocalDateTime.fromDateFields(date);\n            }\n            date.setTime(date.getTime() + 1000);\n        } else if (check.equals(this)) {\n            \n            Date earlier = new Date(date.getTime() - TimeZone.getDefault().getDSTSavings());\n            check = LocalDateTime.fromDateFields(earlier);\n            if (check.equals(this)) {\n                date = earlier;\n            }\n        }\n        return date;\n    }\n\n    \n    \n    LocalDateTime withLocalMillis(long newMillis) {\n        return (newMillis == getLocalMillis() ? this : new LocalDateTime(newMillis, getChronology()));\n    }\n\n    \n    \n    public LocalDateTime withDate(int year, int monthOfYear, int dayOfMonth) {\n        Chronology chrono = getChronology();\n        long instant = getLocalMillis();\n        instant = chrono.year().set(instant, year);\n        instant = chrono.monthOfYear().set(instant, monthOfYear);\n        instant = chrono.dayOfMonth().set(instant, dayOfMonth);\n        return withLocalMillis(instant);\n    }\n\n    \n    public LocalDateTime withTime(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) {\n        Chronology chrono = getChronology();\n        long instant = getLocalMillis();\n        instant = chrono.hourOfDay().set(instant, hourOfDay);\n        instant = chrono.minuteOfHour().set(instant, minuteOfHour);\n        instant = chrono.secondOfMinute().set(instant, secondOfMinute);\n        instant = chrono.millisOfSecond().set(instant, millisOfSecond);\n        return withLocalMillis(instant);\n    }\n\n    \n    \n    public LocalDateTime withFields(ReadablePartial partial) {\n        if (partial == null) {\n            return this;\n        }\n        return withLocalMillis(getChronology().set(partial, getLocalMillis()));\n    }\n\n    \n    public LocalDateTime withField(DateTimeFieldType fieldType, int value) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"Field must not be null\");\n        }\n        long instant = fieldType.getField(getChronology()).set(getLocalMillis(), value);\n        return withLocalMillis(instant);\n    }\n\n    \n    public LocalDateTime withFieldAdded(DurationFieldType fieldType, int amount) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"Field must not be null\");\n        }\n        if (amount == 0) {\n            return this;\n        }\n        long instant = fieldType.getField(getChronology()).add(getLocalMillis(), amount);\n        return withLocalMillis(instant);\n    }\n\n    \n    \n    public LocalDateTime withDurationAdded(ReadableDuration durationToAdd, int scalar) {\n        if (durationToAdd == null || scalar == 0) {\n            return this;\n        }\n        long instant = getChronology().add(getLocalMillis(), durationToAdd.getMillis(), scalar);\n        return withLocalMillis(instant);\n    }\n\n    \n    public LocalDateTime withPeriodAdded(ReadablePeriod period, int scalar) {\n        if (period == null || scalar == 0) {\n            return this;\n        }\n        long instant = getChronology().add(period, getLocalMillis(), scalar);\n        return withLocalMillis(instant);\n    }\n\n    \n    \n    public LocalDateTime plus(ReadableDuration duration) {\n        return withDurationAdded(duration, 1);\n    }\n\n    \n    public LocalDateTime plus(ReadablePeriod period) {\n        return withPeriodAdded(period, 1);\n    }\n\n    \n    \n    public LocalDateTime plusYears(int years) {\n        if (years == 0) {\n            return this;\n        }\n        long instant = getChronology().years().add(getLocalMillis(), years);\n        return withLocalMillis(instant);\n    }\n\n    \n    public LocalDateTime plusMonths(int months) {\n        if (months == 0) {\n            return this;\n        }\n        long instant = getChronology().months().add(getLocalMillis(), months);\n        return withLocalMillis(instant);\n    }\n\n    \n    public LocalDateTime plusWeeks(int weeks) {\n        if (weeks == 0) {\n            return this;\n        }\n        long instant = getChronology().weeks().add(getLocalMillis(), weeks);\n        return withLocalMillis(instant);\n    }\n\n    \n    public LocalDateTime plusDays(int days) {\n        if (days == 0) {\n            return this;\n        }\n        long instant = getChronology().days().add(getLocalMillis(), days);\n        return withLocalMillis(instant);\n    }\n\n    \n    \n    public LocalDateTime plusHours(int hours) {\n        if (hours == 0) {\n            return this;\n        }\n        long instant = getChronology().hours().add(getLocalMillis(), hours);\n        return withLocalMillis(instant);\n    }\n\n    \n    public LocalDateTime plusMinutes(int minutes) {\n        if (minutes == 0) {\n            return this;\n        }\n        long instant = getChronology().minutes().add(getLocalMillis(), minutes);\n        return withLocalMillis(instant);\n    }\n\n    \n    public LocalDateTime plusSeconds(int seconds) {\n        if (seconds == 0) {\n            return this;\n        }\n        long instant = getChronology().seconds().add(getLocalMillis(), seconds);\n        return withLocalMillis(instant);\n    }\n\n    \n    public LocalDateTime plusMillis(int millis) {\n        if (millis == 0) {\n            return this;\n        }\n        long instant = getChronology().millis().add(getLocalMillis(), millis);\n        return withLocalMillis(instant);\n    }\n\n    \n    \n    public LocalDateTime minus(ReadableDuration duration) {\n        return withDurationAdded(duration, -1);\n    }\n\n    \n    public LocalDateTime minus(ReadablePeriod period) {\n        return withPeriodAdded(period, -1);\n    }\n\n    \n    \n    public LocalDateTime minusYears(int years) {\n        if (years == 0) {\n            return this;\n        }\n        long instant = getChronology().years().subtract(getLocalMillis(), years);\n        return withLocalMillis(instant);\n    }\n\n    \n    public LocalDateTime minusMonths(int months) {\n        if (months == 0) {\n            return this;\n        }\n        long instant = getChronology().months().subtract(getLocalMillis(), months);\n        return withLocalMillis(instant);\n    }\n\n    \n    public LocalDateTime minusWeeks(int weeks) {\n        if (weeks == 0) {\n            return this;\n        }\n        long instant = getChronology().weeks().subtract(getLocalMillis(), weeks);\n        return withLocalMillis(instant);\n    }\n\n    \n    public LocalDateTime minusDays(int days) {\n        if (days == 0) {\n            return this;\n        }\n        long instant = getChronology().days().subtract(getLocalMillis(), days);\n        return withLocalMillis(instant);\n    }\n\n    \n    \n    public LocalDateTime minusHours(int hours) {\n        if (hours == 0) {\n            return this;\n        }\n        long instant = getChronology().hours().subtract(getLocalMillis(), hours);\n        return withLocalMillis(instant);\n    }\n\n    \n    public LocalDateTime minusMinutes(int minutes) {\n        if (minutes == 0) {\n            return this;\n        }\n        long instant = getChronology().minutes().subtract(getLocalMillis(), minutes);\n        return withLocalMillis(instant);\n    }\n\n    \n    public LocalDateTime minusSeconds(int seconds) {\n        if (seconds == 0) {\n            return this;\n        }\n        long instant = getChronology().seconds().subtract(getLocalMillis(), seconds);\n        return withLocalMillis(instant);\n    }\n\n    \n    public LocalDateTime minusMillis(int millis) {\n        if (millis == 0) {\n            return this;\n        }\n        long instant = getChronology().millis().subtract(getLocalMillis(), millis);\n        return withLocalMillis(instant);\n    }\n\n    \n    \n    public Property property(DateTimeFieldType fieldType) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\");\n        }\n        if (isSupported(fieldType) == false) {\n            throw new IllegalArgumentException(\"Field '\" + fieldType + \"' is not supported\");\n        }\n        return new Property(this, fieldType.getField(getChronology()));\n    }\n\n    \n    \n    public int getEra() {\n        return getChronology().era().get(getLocalMillis());\n    }\n\n    \n    public int getCenturyOfEra() {\n        return getChronology().centuryOfEra().get(getLocalMillis());\n    }\n\n    \n    public int getYearOfEra() {\n        return getChronology().yearOfEra().get(getLocalMillis());\n    }\n\n    \n    public int getYearOfCentury() {\n        return getChronology().yearOfCentury().get(getLocalMillis());\n    }\n\n    \n    public int getYear() {\n        return getChronology().year().get(getLocalMillis());\n    }\n\n    \n    public int getWeekyear() {\n        return getChronology().weekyear().get(getLocalMillis());\n    }\n\n    \n    public int getMonthOfYear() {\n        return getChronology().monthOfYear().get(getLocalMillis());\n    }\n\n    \n    public int getWeekOfWeekyear() {\n        return getChronology().weekOfWeekyear().get(getLocalMillis());\n    }\n\n    \n    public int getDayOfYear() {\n        return getChronology().dayOfYear().get(getLocalMillis());\n    }\n\n    \n    public int getDayOfMonth() {\n        return getChronology().dayOfMonth().get(getLocalMillis());\n    }\n\n    \n    public int getDayOfWeek() {\n        return getChronology().dayOfWeek().get(getLocalMillis());\n    }\n\n    \n    \n    public int getHourOfDay() {\n        return getChronology().hourOfDay().get(getLocalMillis());\n    }\n\n    \n    public int getMinuteOfHour() {\n        return getChronology().minuteOfHour().get(getLocalMillis());\n    }\n\n    \n    public int getSecondOfMinute() {\n        return getChronology().secondOfMinute().get(getLocalMillis());\n    }\n\n    \n    public int getMillisOfSecond() {\n        return getChronology().millisOfSecond().get(getLocalMillis());\n    }\n\n    \n    public int getMillisOfDay() {\n        return getChronology().millisOfDay().get(getLocalMillis());\n    }\n\n    \n    \n    public LocalDateTime withEra(int era) {\n        return withLocalMillis(getChronology().era().set(getLocalMillis(), era));\n    }\n\n    \n    public LocalDateTime withCenturyOfEra(int centuryOfEra) {\n        return withLocalMillis(getChronology().centuryOfEra().set(getLocalMillis(), centuryOfEra));\n    }\n\n    \n    public LocalDateTime withYearOfEra(int yearOfEra) {\n        return withLocalMillis(getChronology().yearOfEra().set(getLocalMillis(), yearOfEra));\n    }\n\n    \n    public LocalDateTime withYearOfCentury(int yearOfCentury) {\n        return withLocalMillis(getChronology().yearOfCentury().set(getLocalMillis(), yearOfCentury));\n    }\n\n    \n    public LocalDateTime withYear(int year) {\n        return withLocalMillis(getChronology().year().set(getLocalMillis(), year));\n    }\n\n    \n    public LocalDateTime withWeekyear(int weekyear) {\n        return withLocalMillis(getChronology().weekyear().set(getLocalMillis(), weekyear));\n    }\n\n    \n    public LocalDateTime withMonthOfYear(int monthOfYear) {\n        return withLocalMillis(getChronology().monthOfYear().set(getLocalMillis(), monthOfYear));\n    }\n\n    \n    public LocalDateTime withWeekOfWeekyear(int weekOfWeekyear) {\n        return withLocalMillis(getChronology().weekOfWeekyear().set(getLocalMillis(), weekOfWeekyear));\n    }\n\n    \n    public LocalDateTime withDayOfYear(int dayOfYear) {\n        return withLocalMillis(getChronology().dayOfYear().set(getLocalMillis(), dayOfYear));\n    }\n\n    \n    public LocalDateTime withDayOfMonth(int dayOfMonth) {\n        return withLocalMillis(getChronology().dayOfMonth().set(getLocalMillis(), dayOfMonth));\n    }\n\n    \n    public LocalDateTime withDayOfWeek(int dayOfWeek) {\n        return withLocalMillis(getChronology().dayOfWeek().set(getLocalMillis(), dayOfWeek));\n    }\n\n    \n    \n    public LocalDateTime withHourOfDay(int hour) {\n        return withLocalMillis(getChronology().hourOfDay().set(getLocalMillis(), hour));\n    }\n\n    \n    public LocalDateTime withMinuteOfHour(int minute) {\n        return withLocalMillis(getChronology().minuteOfHour().set(getLocalMillis(), minute));\n    }\n\n    \n    public LocalDateTime withSecondOfMinute(int second) {\n        return withLocalMillis(getChronology().secondOfMinute().set(getLocalMillis(), second));\n    }\n\n    \n    public LocalDateTime withMillisOfSecond(int millis) {\n        return withLocalMillis(getChronology().millisOfSecond().set(getLocalMillis(), millis));\n    }\n\n    \n    public LocalDateTime withMillisOfDay(int millis) {\n        return withLocalMillis(getChronology().millisOfDay().set(getLocalMillis(), millis));\n    }\n\n    \n    \n    public Property era() {\n        return new Property(this, getChronology().era());\n    }\n\n    \n    public Property centuryOfEra() {\n        return new Property(this, getChronology().centuryOfEra());\n    }\n\n    \n    public Property yearOfCentury() {\n        return new Property(this, getChronology().yearOfCentury());\n    }\n\n    \n    public Property yearOfEra() {\n        return new Property(this, getChronology().yearOfEra());\n    }\n\n    \n    public Property year() {\n        return new Property(this, getChronology().year());\n    }\n\n    \n    public Property weekyear() {\n        return new Property(this, getChronology().weekyear());\n    }\n\n    \n    public Property monthOfYear() {\n        return new Property(this, getChronology().monthOfYear());\n    }\n\n    \n    public Property weekOfWeekyear() {\n        return new Property(this, getChronology().weekOfWeekyear());\n    }\n\n    \n    public Property dayOfYear() {\n        return new Property(this, getChronology().dayOfYear());\n    }\n\n    \n    public Property dayOfMonth() {\n        return new Property(this, getChronology().dayOfMonth());\n    }\n\n    \n    public Property dayOfWeek() {\n        return new Property(this, getChronology().dayOfWeek());\n    }\n\n    \n    \n    public Property hourOfDay() {\n        return new Property(this, getChronology().hourOfDay());\n    }\n\n    \n    public Property minuteOfHour() {\n        return new Property(this, getChronology().minuteOfHour());\n    }\n\n    \n    public Property secondOfMinute() {\n        return new Property(this, getChronology().secondOfMinute());\n    }\n\n    \n    public Property millisOfSecond() {\n        return new Property(this, getChronology().millisOfSecond());\n    }\n\n    \n    public Property millisOfDay() {\n        return new Property(this, getChronology().millisOfDay());\n    }\n\n    \n    \n    @ToString\n    public String toString() {\n        return ISODateTimeFormat.dateTime().print(this);\n    }\n\n    \n    public String toString(String pattern) {\n        if (pattern == null) {\n            return toString();\n        }\n        return DateTimeFormat.forPattern(pattern).print(this);\n    }\n\n    \n    public String toString(String pattern, Locale locale) throws IllegalArgumentException {\n        if (pattern == null) {\n            return toString();\n        }\n        return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this);\n    }\n\n    \n    \n    public static final class Property extends AbstractReadableInstantFieldProperty { private static final long serialVersionUID = -358138762846288L; private transient LocalDateTime iInstant; private transient DateTimeField iField; Property(LocalDateTime instant, DateTimeField field) {\n            super();\n            iInstant = instant;\n            iField = field;\n        }\n        \n        \n        private void writeObject(ObjectOutputStream oos) throws IOException {\n            oos.writeObject(iInstant);\n            oos.writeObject(iField.getType());\n        }\n\n        \n        private void readObject(ObjectInputStream oos) throws IOException, ClassNotFoundException {\n            iInstant = (LocalDateTime) oos.readObject();\n            DateTimeFieldType type = (DateTimeFieldType) oos.readObject();\n            iField = type.getField(iInstant.getChronology());\n        }\n\n        \n        \n        public DateTimeField getField() {\n            return iField;\n        }\n        \n        \n        protected long getMillis() {\n            return iInstant.getLocalMillis();\n        }\n        \n        \n        protected Chronology getChronology() {\n            return iInstant.getChronology();\n        }\n        \n        \n        public LocalDateTime getLocalDateTime() {\n            return iInstant;\n        }\n        \n        \n        \n        public LocalDateTime addToCopy(int value) {\n            return iInstant.withLocalMillis(iField.add(iInstant.getLocalMillis(), value));\n        }\n        \n        \n        public LocalDateTime addToCopy(long value) {\n            return iInstant.withLocalMillis(iField.add(iInstant.getLocalMillis(), value));\n        }\n        \n        \n        public LocalDateTime addWrapFieldToCopy(int value) {\n            return iInstant.withLocalMillis(iField.addWrapField(iInstant.getLocalMillis(), value));\n        }\n        \n        \n        \n        public LocalDateTime setCopy(int value) {\n            return iInstant.withLocalMillis(iField.set(iInstant.getLocalMillis(), value));\n        }\n        \n        \n        public LocalDateTime setCopy(String text, Locale locale) {\n            return iInstant.withLocalMillis(iField.set(iInstant.getLocalMillis(), text, locale));\n        }\n        \n        \n        public LocalDateTime setCopy(String text) {\n            return setCopy(text, null);\n        }\n        \n        \n        \n        public LocalDateTime withMaximumValue() {\n            return setCopy(getMaximumValue());\n        }\n        \n        \n        public LocalDateTime withMinimumValue() {\n            return setCopy(getMinimumValue());\n        }\n        \n        \n        \n        public LocalDateTime roundFloorCopy() {\n            return iInstant.withLocalMillis(iField.roundFloor(iInstant.getLocalMillis()));\n        }\n        \n        \n        public LocalDateTime roundCeilingCopy() {\n            return iInstant.withLocalMillis(iField.roundCeiling(iInstant.getLocalMillis()));\n        }\n        \n        \n        public LocalDateTime roundHalfFloorCopy() {\n            return iInstant.withLocalMillis(iField.roundHalfFloor(iInstant.getLocalMillis()));\n        }\n        \n        \n        public LocalDateTime roundHalfCeilingCopy() {\n            return iInstant.withLocalMillis(iField.roundHalfCeiling(iInstant.getLocalMillis()));\n        }\n        \n        \n        public LocalDateTime roundHalfEvenCopy() {\n            return iInstant.withLocalMillis(iField.roundHalfEven(iInstant.getLocalMillis()));\n        }\n    }\n\n}\n",
      "buggy_signatures": [
        "public static LocalDateTime now(DateTimeZone zone)",
        "public static LocalDateTime now(Chronology chronology)",
        "public static LocalDateTime parse(String str)",
        "public static LocalDateTime parse(String str, DateTimeFormatter formatter)",
        "public static LocalDateTime fromCalendarFields(Calendar calendar)",
        "public static LocalDateTime fromDateFields(Date date)",
        "public LocalDateTime()",
        "public LocalDateTime(DateTimeZone zone)",
        "public LocalDateTime(Chronology chronology)",
        "public LocalDateTime(long instant)",
        "public LocalDateTime(long instant, DateTimeZone zone)",
        "public LocalDateTime(long instant, Chronology chronology)",
        "public LocalDateTime(Object instant)",
        "public LocalDateTime(Object instant, DateTimeZone zone)",
        "public LocalDateTime(Object instant, Chronology chronology)",
        "public LocalDateTime( int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour)",
        "public LocalDateTime( int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute)",
        "public LocalDateTime( int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond)",
        "public LocalDateTime( int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology)",
        "private Object readResolve()",
        "public int size()",
        "protected DateTimeField getField(int index, Chronology chrono)",
        "public int getValue(int index)",
        "public int get(DateTimeFieldType type)",
        "public boolean isSupported(DateTimeFieldType type)",
        "public boolean isSupported(DurationFieldType type)",
        "protected long getLocalMillis()",
        "public Chronology getChronology()",
        "public boolean equals(Object partial)",
        "public int compareTo(ReadablePartial partial)",
        "public DateTime toDateTime()",
        "public DateTime toDateTime(DateTimeZone zone)",
        "public LocalDate toLocalDate()",
        "public LocalTime toLocalTime()",
        "public Date toDate()",
        "public LocalDateTime withDate(int year, int monthOfYear, int dayOfMonth)",
        "public LocalDateTime withTime(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond)",
        "public LocalDateTime withFields(ReadablePartial partial)",
        "public LocalDateTime withField(DateTimeFieldType fieldType, int value)",
        "public LocalDateTime withFieldAdded(DurationFieldType fieldType, int amount)",
        "public LocalDateTime withDurationAdded(ReadableDuration durationToAdd, int scalar)",
        "public LocalDateTime withPeriodAdded(ReadablePeriod period, int scalar)",
        "public LocalDateTime plus(ReadableDuration duration)",
        "public LocalDateTime plus(ReadablePeriod period)",
        "public LocalDateTime plusYears(int years)",
        "public LocalDateTime plusMonths(int months)",
        "public LocalDateTime plusWeeks(int weeks)",
        "public LocalDateTime plusDays(int days)",
        "public LocalDateTime plusHours(int hours)",
        "public LocalDateTime plusMinutes(int minutes)",
        "public LocalDateTime plusSeconds(int seconds)",
        "public LocalDateTime plusMillis(int millis)",
        "public LocalDateTime minus(ReadableDuration duration)",
        "public LocalDateTime minus(ReadablePeriod period)",
        "public LocalDateTime minusYears(int years)",
        "public LocalDateTime minusMonths(int months)",
        "public LocalDateTime minusWeeks(int weeks)",
        "public LocalDateTime minusDays(int days)",
        "public LocalDateTime minusHours(int hours)",
        "public LocalDateTime minusMinutes(int minutes)",
        "public LocalDateTime minusSeconds(int seconds)",
        "public LocalDateTime minusMillis(int millis)",
        "public Property property(DateTimeFieldType fieldType)",
        "public int getEra()",
        "public int getCenturyOfEra()",
        "public int getYearOfEra()",
        "public int getYearOfCentury()",
        "public int getYear()",
        "public int getWeekyear()",
        "public int getMonthOfYear()",
        "public int getWeekOfWeekyear()",
        "public int getDayOfYear()",
        "public int getDayOfMonth()",
        "public int getDayOfWeek()",
        "public int getHourOfDay()",
        "public int getMinuteOfHour()",
        "public int getSecondOfMinute()",
        "public int getMillisOfSecond()",
        "public int getMillisOfDay()",
        "public LocalDateTime withEra(int era)",
        "public LocalDateTime withCenturyOfEra(int centuryOfEra)",
        "public LocalDateTime withYearOfEra(int yearOfEra)",
        "public LocalDateTime withYearOfCentury(int yearOfCentury)",
        "public LocalDateTime withYear(int year)",
        "public LocalDateTime withWeekyear(int weekyear)",
        "public LocalDateTime withMonthOfYear(int monthOfYear)",
        "public LocalDateTime withWeekOfWeekyear(int weekOfWeekyear)",
        "public LocalDateTime withDayOfYear(int dayOfYear)",
        "public LocalDateTime withDayOfMonth(int dayOfMonth)",
        "public LocalDateTime withDayOfWeek(int dayOfWeek)",
        "public LocalDateTime withHourOfDay(int hour)",
        "public LocalDateTime withMinuteOfHour(int minute)",
        "public LocalDateTime withSecondOfMinute(int second)",
        "public LocalDateTime withMillisOfSecond(int millis)",
        "public LocalDateTime withMillisOfDay(int millis)",
        "public Property era()",
        "public Property centuryOfEra()",
        "public Property yearOfCentury()",
        "public Property yearOfEra()",
        "public Property year()",
        "public Property weekyear()",
        "public Property monthOfYear()",
        "public Property weekOfWeekyear()",
        "public Property dayOfYear()",
        "public Property dayOfMonth()",
        "public Property dayOfWeek()",
        "public Property hourOfDay()",
        "public Property minuteOfHour()",
        "public Property secondOfMinute()",
        "public Property millisOfSecond()",
        "public Property millisOfDay()",
        "public String toString()",
        "public String toString(String pattern)",
        "public String toString(String pattern, Locale locale) throws IllegalArgumentException",
        "private void writeObject(ObjectOutputStream oos) throws IOException",
        "private void readObject(ObjectInputStream oos) throws IOException, ClassNotFoundException",
        "public DateTimeField getField()",
        "protected long getMillis()",
        "protected Chronology getChronology()",
        "public LocalDateTime getLocalDateTime()",
        "public LocalDateTime addToCopy(int value)",
        "public LocalDateTime addToCopy(long value)",
        "public LocalDateTime addWrapFieldToCopy(int value)",
        "public LocalDateTime setCopy(int value)",
        "public LocalDateTime setCopy(String text, Locale locale)",
        "public LocalDateTime setCopy(String text)",
        "public LocalDateTime withMaximumValue()",
        "public LocalDateTime withMinimumValue()",
        "public LocalDateTime roundFloorCopy()",
        "public LocalDateTime roundCeilingCopy()",
        "public LocalDateTime roundHalfFloorCopy()",
        "public LocalDateTime roundHalfCeilingCopy()",
        "public LocalDateTime roundHalfEvenCopy()"
      ],
      "fixed_signatures": [
        "public static LocalDateTime now(DateTimeZone zone)",
        "public static LocalDateTime now(Chronology chronology)",
        "public static LocalDateTime parse(String str)",
        "public static LocalDateTime parse(String str, DateTimeFormatter formatter)",
        "public static LocalDateTime fromCalendarFields(Calendar calendar)",
        "public static LocalDateTime fromDateFields(Date date)",
        "public LocalDateTime()",
        "public LocalDateTime(DateTimeZone zone)",
        "public LocalDateTime(Chronology chronology)",
        "public LocalDateTime(long instant)",
        "public LocalDateTime(long instant, DateTimeZone zone)",
        "public LocalDateTime(long instant, Chronology chronology)",
        "public LocalDateTime(Object instant)",
        "public LocalDateTime(Object instant, DateTimeZone zone)",
        "public LocalDateTime(Object instant, Chronology chronology)",
        "public LocalDateTime( int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour)",
        "public LocalDateTime( int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute)",
        "public LocalDateTime( int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond)",
        "public LocalDateTime( int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology)",
        "private Object readResolve()",
        "public int size()",
        "protected DateTimeField getField(int index, Chronology chrono)",
        "public int getValue(int index)",
        "public int get(DateTimeFieldType type)",
        "public boolean isSupported(DateTimeFieldType type)",
        "public boolean isSupported(DurationFieldType type)",
        "protected long getLocalMillis()",
        "public Chronology getChronology()",
        "public boolean equals(Object partial)",
        "public int compareTo(ReadablePartial partial)",
        "public DateTime toDateTime()",
        "public DateTime toDateTime(DateTimeZone zone)",
        "public LocalDate toLocalDate()",
        "public LocalTime toLocalTime()",
        "public Date toDate()",
        "public LocalDateTime withDate(int year, int monthOfYear, int dayOfMonth)",
        "public LocalDateTime withTime(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond)",
        "public LocalDateTime withFields(ReadablePartial partial)",
        "public LocalDateTime withField(DateTimeFieldType fieldType, int value)",
        "public LocalDateTime withFieldAdded(DurationFieldType fieldType, int amount)",
        "public LocalDateTime withDurationAdded(ReadableDuration durationToAdd, int scalar)",
        "public LocalDateTime withPeriodAdded(ReadablePeriod period, int scalar)",
        "public LocalDateTime plus(ReadableDuration duration)",
        "public LocalDateTime plus(ReadablePeriod period)",
        "public LocalDateTime plusYears(int years)",
        "public LocalDateTime plusMonths(int months)",
        "public LocalDateTime plusWeeks(int weeks)",
        "public LocalDateTime plusDays(int days)",
        "public LocalDateTime plusHours(int hours)",
        "public LocalDateTime plusMinutes(int minutes)",
        "public LocalDateTime plusSeconds(int seconds)",
        "public LocalDateTime plusMillis(int millis)",
        "public LocalDateTime minus(ReadableDuration duration)",
        "public LocalDateTime minus(ReadablePeriod period)",
        "public LocalDateTime minusYears(int years)",
        "public LocalDateTime minusMonths(int months)",
        "public LocalDateTime minusWeeks(int weeks)",
        "public LocalDateTime minusDays(int days)",
        "public LocalDateTime minusHours(int hours)",
        "public LocalDateTime minusMinutes(int minutes)",
        "public LocalDateTime minusSeconds(int seconds)",
        "public LocalDateTime minusMillis(int millis)",
        "public Property property(DateTimeFieldType fieldType)",
        "public int getEra()",
        "public int getCenturyOfEra()",
        "public int getYearOfEra()",
        "public int getYearOfCentury()",
        "public int getYear()",
        "public int getWeekyear()",
        "public int getMonthOfYear()",
        "public int getWeekOfWeekyear()",
        "public int getDayOfYear()",
        "public int getDayOfMonth()",
        "public int getDayOfWeek()",
        "public int getHourOfDay()",
        "public int getMinuteOfHour()",
        "public int getSecondOfMinute()",
        "public int getMillisOfSecond()",
        "public int getMillisOfDay()",
        "public LocalDateTime withEra(int era)",
        "public LocalDateTime withCenturyOfEra(int centuryOfEra)",
        "public LocalDateTime withYearOfEra(int yearOfEra)",
        "public LocalDateTime withYearOfCentury(int yearOfCentury)",
        "public LocalDateTime withYear(int year)",
        "public LocalDateTime withWeekyear(int weekyear)",
        "public LocalDateTime withMonthOfYear(int monthOfYear)",
        "public LocalDateTime withWeekOfWeekyear(int weekOfWeekyear)",
        "public LocalDateTime withDayOfYear(int dayOfYear)",
        "public LocalDateTime withDayOfMonth(int dayOfMonth)",
        "public LocalDateTime withDayOfWeek(int dayOfWeek)",
        "public LocalDateTime withHourOfDay(int hour)",
        "public LocalDateTime withMinuteOfHour(int minute)",
        "public LocalDateTime withSecondOfMinute(int second)",
        "public LocalDateTime withMillisOfSecond(int millis)",
        "public LocalDateTime withMillisOfDay(int millis)",
        "public Property era()",
        "public Property centuryOfEra()",
        "public Property yearOfCentury()",
        "public Property yearOfEra()",
        "public Property year()",
        "public Property weekyear()",
        "public Property monthOfYear()",
        "public Property weekOfWeekyear()",
        "public Property dayOfYear()",
        "public Property dayOfMonth()",
        "public Property dayOfWeek()",
        "public Property hourOfDay()",
        "public Property minuteOfHour()",
        "public Property secondOfMinute()",
        "public Property millisOfSecond()",
        "public Property millisOfDay()",
        "public String toString()",
        "public String toString(String pattern)",
        "public String toString(String pattern, Locale locale) throws IllegalArgumentException",
        "private void writeObject(ObjectOutputStream oos) throws IOException",
        "private void readObject(ObjectInputStream oos) throws IOException, ClassNotFoundException",
        "public DateTimeField getField()",
        "protected long getMillis()",
        "protected Chronology getChronology()",
        "public LocalDateTime getLocalDateTime()",
        "public LocalDateTime addToCopy(int value)",
        "public LocalDateTime addToCopy(long value)",
        "public LocalDateTime addWrapFieldToCopy(int value)",
        "public LocalDateTime setCopy(int value)",
        "public LocalDateTime setCopy(String text, Locale locale)",
        "public LocalDateTime setCopy(String text)",
        "public LocalDateTime withMaximumValue()",
        "public LocalDateTime withMinimumValue()",
        "public LocalDateTime roundFloorCopy()",
        "public LocalDateTime roundCeilingCopy()",
        "public LocalDateTime roundHalfFloorCopy()",
        "public LocalDateTime roundHalfCeilingCopy()",
        "public LocalDateTime roundHalfEvenCopy()"
      ],
      "methods": [
        {
          "buggy_method": "  public static LocalDateTime fromCalendarFields(Calendar calendar) {\n  if (calendar == null) {\n  throw new IllegalArgumentException(\"The calendar must not be null\");\n  }\n  int yearOfEra = calendar.get(Calendar.YEAR);\n  return new LocalDateTime(\n  yearOfEra,\n  calendar.get(Calendar.MONTH) + 1,\n  calendar.get(Calendar.DAY_OF_MONTH),\n  calendar.get(Calendar.HOUR_OF_DAY),\n  calendar.get(Calendar.MINUTE),\n  calendar.get(Calendar.SECOND),\n  calendar.get(Calendar.MILLISECOND)\n  );\n  }",
          "fixed_method": "  public static LocalDateTime fromCalendarFields(Calendar calendar) {\n  if (calendar == null) {\n  throw new IllegalArgumentException(\"The calendar must not be null\");\n  }\n  int era = calendar.get(Calendar.ERA);\n  int yearOfEra = calendar.get(Calendar.YEAR);\n  return new LocalDateTime(\n  (era == GregorianCalendar.AD ? yearOfEra : 1 - yearOfEra),\n  calendar.get(Calendar.MONTH) + 1,\n  calendar.get(Calendar.DAY_OF_MONTH),\n  calendar.get(Calendar.HOUR_OF_DAY),\n  calendar.get(Calendar.MINUTE),\n  calendar.get(Calendar.SECOND),\n  calendar.get(Calendar.MILLISECOND)\n  );\n  }",
          "diff": [
            "@@ -196,9 +196,10 @@",
            "         if (calendar == null) {\n",
            "             throw new IllegalArgumentException(\"The calendar must not be null\");\n",
            "         }\n",
            "+        int era = calendar.get(Calendar.ERA);\n",
            "         int yearOfEra = calendar.get(Calendar.YEAR);\n",
            "         return new LocalDateTime(\n",
            "-            yearOfEra,\n",
            "+            (era == GregorianCalendar.AD ? yearOfEra : 1 - yearOfEra),\n",
            "             calendar.get(Calendar.MONTH) + 1,\n",
            "             calendar.get(Calendar.DAY_OF_MONTH),\n",
            "             calendar.get(Calendar.HOUR_OF_DAY),\n"
          ],
          "changed_lines": 3
        },
        {
          "buggy_method": "  public static LocalDateTime fromDateFields(Date date) {\n  if (date == null) {\n  throw new IllegalArgumentException(\"The date must not be null\");\n  }\n  \n  return new LocalDateTime(\n  date.getYear() + 1900,\n  date.getMonth() + 1,\n  date.getDate(),\n  date.getHours(),\n  date.getMinutes(),\n  date.getSeconds(),\n  (((int) (date.getTime() % 1000)) + 1000) % 1000\n  );\n  }",
          "fixed_method": "  public static LocalDateTime fromDateFields(Date date) {\n  if (date == null) {\n  throw new IllegalArgumentException(\"The date must not be null\");\n  }\n  if (date.getTime() < 0) {\n  \n  GregorianCalendar cal = new GregorianCalendar();\n  cal.setTime(date);\n  return fromCalendarFields(cal);\n  }\n  return new LocalDateTime(\n  date.getYear() + 1900,\n  date.getMonth() + 1,\n  date.getDate(),\n  date.getHours(),\n  date.getMinutes(),\n  date.getSeconds(),\n  (((int) (date.getTime() % 1000)) + 1000) % 1000\n  );\n  }",
          "diff": [
            "@@ -233,7 +234,12 @@",
            "         if (date == null) {\n",
            "             throw new IllegalArgumentException(\"The date must not be null\");\n",
            "         }\n",
            "+        if (date.getTime() < 0) {\n",
            "             // handle years in era BC\n",
            "+            GregorianCalendar cal = new GregorianCalendar();\n",
            "+            cal.setTime(date);\n",
            "+            return fromCalendarFields(cal);\n",
            "+        }\n",
            "         return new LocalDateTime(\n",
            "             date.getYear() + 1900,\n",
            "             date.getMonth() + 1,\n"
          ],
          "changed_lines": 5
        }
      ]
    }
  ]
}
