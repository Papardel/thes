{
  "bug_id": "14",
  "failed_tests": {
    "org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest": [
      {
        "methodName": "workaroundForBrokenTimeHeader",
        "error": "java.io.IOException",
        "message": "Error detected parsing the header",
        "fail_line": "            tae = in.getNextTarEntry();",
        "test_source": "  public void workaroundForBrokenTimeHeader() throws Exception {\n  URL tar = getClass().getResource(\"/simple-aix-native-tar.tar\"); TarArchiveInputStream in = null; try { in = new TarArchiveInputStream(new FileInputStream(new File(new URI(tar.toString())))); TarArchiveEntry tae = in.getNextTarEntry(); tae = in.getNextTarEntry(); assertEquals(\"sample/link-to-txt-file.lnk\", tae.getName()); assertEquals(new Date(0), tae.getLastModifiedDate()); assertTrue(tae.isSymbolicLink()); } finally {\n  if (in != null) {\n  in.close();\n  }\n  }\n  }  ",
        "stack": [
          "TarArchiveInputStream.getNextTarEntry line 201, TarArchiveInputStreamTest.workaroundForBrokenTimeHeader line 57, TarUtils.parseOctal line 105, TarArchiveEntry.parseTarHeader line 819, TarArchiveEntry.<init> line 314, TarArchiveInputStream.getNextTarEntry line 199"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/compress/archivers/tar/TarUtils.java",
      "buggy_full_code": "\npackage org.apache.commons.compress.archivers.tar;\n\n\n\npublic class TarUtils { private static final int BYTE_MASK = 255; private TarUtils() {    \n    }\n\n    \n    public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n        long    result = 0;\n        int     end = offset + length;\n        int     start = offset;\n\n        if (length < 2){\n            throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n        }\n\n        boolean allNUL = true;\n        for (int i = start; i < end; i++){\n            if (buffer[i] != 0){\n                allNUL = false;\n                break;\n            }\n        }\n        if (allNUL) {\n            return 0L;\n        }\n\n        \n        while (start < end){\n            if (buffer[start] == ' '){\n                start++;\n            } else {\n                break;\n            }\n        }\n\n        \n        byte trailer;\n        trailer = buffer[end-1];\n        if (trailer == 0 || trailer == ' '){\n            end--;\n        } else {\n            throw new IllegalArgumentException(\n                    exceptionMessage(buffer, offset, length, end-1, trailer));\n        }\n        \n        trailer = buffer[end-1];\n        if (trailer == 0 || trailer == ' '){\n            end--;\n        }\n\n        for ( ;start < end; start++) {\n            final byte currentByte = buffer[start];\n            \n            if (currentByte < '0' || currentByte > '7'){\n                throw new IllegalArgumentException(\n                        exceptionMessage(buffer, offset, length, start, currentByte));\n            }\n            result = (result << 3) + (currentByte - '0'); \n            \n        }\n\n        return result;\n    }\n\n    \n    public static long parseOctalOrBinary(final byte[] buffer, final int offset, final int length) {\n\n        if ((buffer[offset] & 0x80) == 0) {\n            return parseOctal(buffer, offset, length);\n        }\n\n        long val = buffer[offset] & 0x7f;\n        for (int i = 1; i < length; i++) {\n            if (val >= (1L << (63 - 8))) {\n                throw new IllegalArgumentException(\n                    \"At offset \" + offset + \", \" + length + \" byte \" +\n                    \"binary number exceeds maximum signed long value\");\n            }\n            val = (val << 8) + (buffer[offset + i] & 0xff);\n        }\n        return val;\n    }\n\n    \n    public static boolean parseBoolean(final byte[] buffer, final int offset) {\n        return buffer[offset] == 1;\n    }\n\n    \n    private static String exceptionMessage(byte[] buffer, final int offset, final int length, int current, final byte currentByte) {\n        String string = new String(buffer, offset, length);\n        string=string.replaceAll(\"\\0\", \"{NUL}\"); \n        final String s = \"Invalid byte \"+currentByte+\" at offset \"+(current-offset)+\" in '\"+string+\"' len=\"+length;\n        return s;\n    }\n\n    \n    public static String parseName(byte[] buffer, final int offset, final int length) {\n        StringBuffer result = new StringBuffer(length);\n        int          end = offset + length;\n\n        for (int i = offset; i < end; ++i) {\n            byte b = buffer[i];\n            if (b == 0) { \n                break;\n            }\n            result.append((char) (b & 0xFF)); \n        }\n\n        return result.toString();\n    }\n\n    \n    public static int formatNameBytes(String name, byte[] buf, final int offset, final int length) {\n        int i;\n\n        \n        for (i = 0; i < length && i < name.length(); ++i) {\n            buf[offset + i] = (byte) name.charAt(i);\n        }\n\n        \n        for (; i < length; ++i) {\n            buf[offset + i] = 0;\n        }\n\n        return offset + length;\n    }\n\n    \n    public static void formatUnsignedOctalString(final long value, byte[] buffer, final int offset, final int length) {\n        int remaining = length;\n        remaining--;\n        if (value == 0) {\n            buffer[offset + remaining--] = (byte) '0';\n        } else {\n            long val = value;\n            for (; remaining >= 0 && val != 0; --remaining) {\n                \n                buffer[offset + remaining] = (byte) ((byte) '0' + (byte) (val & 7));\n                val = val >>> 3;\n                \n            }\n            if (val != 0){\n                throw new IllegalArgumentException\n                (value+\"=\"+Long.toOctalString(value)+ \" will not fit in octal number buffer of length \"+length);\n            }\n        }\n\n        for (; remaining >= 0; --remaining) { \n            buffer[offset + remaining] = (byte) '0';\n        }\n    }\n\n    \n    public static int formatOctalBytes(final long value, byte[] buf, final int offset, final int length) {\n\n        int idx=length-2; \n        formatUnsignedOctalString(value, buf, offset, idx);\n\n        buf[offset + idx++] = (byte) ' '; \n        buf[offset + idx]   = 0; \n\n        return offset + length;\n    }\n\n    \n    public static int formatLongOctalBytes(final long value, byte[] buf, final int offset, final int length) {\n\n        int idx=length-1; \n        \n        formatUnsignedOctalString(value, buf, offset, idx);\n        buf[offset + idx] = (byte) ' '; \n\n        return offset + length;\n    }\n\n    \n    public static int formatLongOctalOrBinaryBytes( final long value, byte[] buf, final int offset, final int length) {\n\n        \n        final long maxAsOctalChar = length == TarConstants.UIDLEN ? TarConstants.MAXID : TarConstants.MAXSIZE;\n\n        if (value <= maxAsOctalChar) { \n            return formatLongOctalBytes(value, buf, offset, length);\n        }\n\n        long val = value;\n        for (int i = offset + length - 1; i >= offset; i--) {\n            buf[i] = (byte) val;\n            val >>= 8;\n        }\n\n        if (val != 0 || (buf[offset] & 0x80) != 0) {\n            throw new IllegalArgumentException(\"Value \" + value +\n                \" is too large for \" + length + \" byte field.\");\n        }\n\n        buf[offset] |= 0x80;\n        return offset + length;\n    }\n\n    \n    public static int formatCheckSumOctalBytes(final long value, byte[] buf, final int offset, final int length) {\n\n        int idx=length-2; \n        formatUnsignedOctalString(value, buf, offset, idx);\n\n        buf[offset + idx++]   = 0; \n        buf[offset + idx]     = (byte) ' '; \n\n        return offset + length;\n    }\n\n    \n    public static long computeCheckSum(final byte[] buf) {\n        long sum = 0;\n\n        for (int i = 0; i < buf.length; ++i) {\n            sum += BYTE_MASK & buf[i];\n        }\n\n        return sum;\n    }\n}\n",
      "fixed_full_code": "\npackage org.apache.commons.compress.archivers.tar;\n\n\n\npublic class TarUtils { private static final int BYTE_MASK = 255; private TarUtils() {    \n    }\n\n    \n    public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n        long    result = 0;\n        int     end = offset + length;\n        int     start = offset;\n\n        if (length < 2){\n            throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n        }\n\n        if (buffer[start] == 0) {\n            return 0L;\n        }\n\n        \n        while (start < end){\n            if (buffer[start] == ' '){\n                start++;\n            } else {\n                break;\n            }\n        }\n\n        \n        byte trailer;\n        trailer = buffer[end-1];\n        if (trailer == 0 || trailer == ' '){\n            end--;\n        } else {\n            throw new IllegalArgumentException(\n                    exceptionMessage(buffer, offset, length, end-1, trailer));\n        }\n        \n        trailer = buffer[end-1];\n        if (trailer == 0 || trailer == ' '){\n            end--;\n        }\n\n        for ( ;start < end; start++) {\n            final byte currentByte = buffer[start];\n            \n            if (currentByte < '0' || currentByte > '7'){\n                throw new IllegalArgumentException(\n                        exceptionMessage(buffer, offset, length, start, currentByte));\n            }\n            result = (result << 3) + (currentByte - '0'); \n            \n        }\n\n        return result;\n    }\n\n    \n    public static long parseOctalOrBinary(final byte[] buffer, final int offset, final int length) {\n\n        if ((buffer[offset] & 0x80) == 0) {\n            return parseOctal(buffer, offset, length);\n        }\n\n        long val = buffer[offset] & 0x7f;\n        for (int i = 1; i < length; i++) {\n            if (val >= (1L << (63 - 8))) {\n                throw new IllegalArgumentException(\n                    \"At offset \" + offset + \", \" + length + \" byte \" +\n                    \"binary number exceeds maximum signed long value\");\n            }\n            val = (val << 8) + (buffer[offset + i] & 0xff);\n        }\n        return val;\n    }\n\n    \n    public static boolean parseBoolean(final byte[] buffer, final int offset) {\n        return buffer[offset] == 1;\n    }\n\n    \n    private static String exceptionMessage(byte[] buffer, final int offset, final int length, int current, final byte currentByte) {\n        String string = new String(buffer, offset, length);\n        string=string.replaceAll(\"\\0\", \"{NUL}\"); \n        final String s = \"Invalid byte \"+currentByte+\" at offset \"+(current-offset)+\" in '\"+string+\"' len=\"+length;\n        return s;\n    }\n\n    \n    public static String parseName(byte[] buffer, final int offset, final int length) {\n        StringBuffer result = new StringBuffer(length);\n        int          end = offset + length;\n\n        for (int i = offset; i < end; ++i) {\n            byte b = buffer[i];\n            if (b == 0) { \n                break;\n            }\n            result.append((char) (b & 0xFF)); \n        }\n\n        return result.toString();\n    }\n\n    \n    public static int formatNameBytes(String name, byte[] buf, final int offset, final int length) {\n        int i;\n\n        \n        for (i = 0; i < length && i < name.length(); ++i) {\n            buf[offset + i] = (byte) name.charAt(i);\n        }\n\n        \n        for (; i < length; ++i) {\n            buf[offset + i] = 0;\n        }\n\n        return offset + length;\n    }\n\n    \n    public static void formatUnsignedOctalString(final long value, byte[] buffer, final int offset, final int length) {\n        int remaining = length;\n        remaining--;\n        if (value == 0) {\n            buffer[offset + remaining--] = (byte) '0';\n        } else {\n            long val = value;\n            for (; remaining >= 0 && val != 0; --remaining) {\n                \n                buffer[offset + remaining] = (byte) ((byte) '0' + (byte) (val & 7));\n                val = val >>> 3;\n                \n            }\n            if (val != 0){\n                throw new IllegalArgumentException\n                (value+\"=\"+Long.toOctalString(value)+ \" will not fit in octal number buffer of length \"+length);\n            }\n        }\n\n        for (; remaining >= 0; --remaining) { \n            buffer[offset + remaining] = (byte) '0';\n        }\n    }\n\n    \n    public static int formatOctalBytes(final long value, byte[] buf, final int offset, final int length) {\n\n        int idx=length-2; \n        formatUnsignedOctalString(value, buf, offset, idx);\n\n        buf[offset + idx++] = (byte) ' '; \n        buf[offset + idx]   = 0; \n\n        return offset + length;\n    }\n\n    \n    public static int formatLongOctalBytes(final long value, byte[] buf, final int offset, final int length) {\n\n        int idx=length-1; \n        \n        formatUnsignedOctalString(value, buf, offset, idx);\n        buf[offset + idx] = (byte) ' '; \n\n        return offset + length;\n    }\n\n    \n    public static int formatLongOctalOrBinaryBytes( final long value, byte[] buf, final int offset, final int length) {\n\n        \n        final long maxAsOctalChar = length == TarConstants.UIDLEN ? TarConstants.MAXID : TarConstants.MAXSIZE;\n\n        if (value <= maxAsOctalChar) { \n            return formatLongOctalBytes(value, buf, offset, length);\n        }\n\n        long val = value;\n        for (int i = offset + length - 1; i >= offset; i--) {\n            buf[i] = (byte) val;\n            val >>= 8;\n        }\n\n        if (val != 0 || (buf[offset] & 0x80) != 0) {\n            throw new IllegalArgumentException(\"Value \" + value +\n                \" is too large for \" + length + \" byte field.\");\n        }\n\n        buf[offset] |= 0x80;\n        return offset + length;\n    }\n\n    \n    public static int formatCheckSumOctalBytes(final long value, byte[] buf, final int offset, final int length) {\n\n        int idx=length-2; \n        formatUnsignedOctalString(value, buf, offset, idx);\n\n        buf[offset + idx++]   = 0; \n        buf[offset + idx]     = (byte) ' '; \n\n        return offset + length;\n    }\n\n    \n    public static long computeCheckSum(final byte[] buf) {\n        long sum = 0;\n\n        for (int i = 0; i < buf.length; ++i) {\n            sum += BYTE_MASK & buf[i];\n        }\n\n        return sum;\n    }\n}\n",
      "buggy_signatures": [
        "public static long parseOctal(final byte[] buffer, final int offset, final int length)",
        "public static long parseOctalOrBinary(final byte[] buffer, final int offset, final int length)",
        "public static boolean parseBoolean(final byte[] buffer, final int offset)",
        "private static String exceptionMessage(byte[] buffer, final int offset, final int length, int current, final byte currentByte)",
        "public static String parseName(byte[] buffer, final int offset, final int length)",
        "public static int formatNameBytes(String name, byte[] buf, final int offset, final int length)",
        "public static void formatUnsignedOctalString(final long value, byte[] buffer, final int offset, final int length)",
        "public static int formatOctalBytes(final long value, byte[] buf, final int offset, final int length)",
        "public static int formatLongOctalBytes(final long value, byte[] buf, final int offset, final int length)",
        "public static int formatLongOctalOrBinaryBytes( final long value, byte[] buf, final int offset, final int length)",
        "public static int formatCheckSumOctalBytes(final long value, byte[] buf, final int offset, final int length)",
        "public static long computeCheckSum(final byte[] buf)"
      ],
      "fixed_signatures": [
        "public static long parseOctal(final byte[] buffer, final int offset, final int length)",
        "public static long parseOctalOrBinary(final byte[] buffer, final int offset, final int length)",
        "public static boolean parseBoolean(final byte[] buffer, final int offset)",
        "private static String exceptionMessage(byte[] buffer, final int offset, final int length, int current, final byte currentByte)",
        "public static String parseName(byte[] buffer, final int offset, final int length)",
        "public static int formatNameBytes(String name, byte[] buf, final int offset, final int length)",
        "public static void formatUnsignedOctalString(final long value, byte[] buffer, final int offset, final int length)",
        "public static int formatOctalBytes(final long value, byte[] buf, final int offset, final int length)",
        "public static int formatLongOctalBytes(final long value, byte[] buf, final int offset, final int length)",
        "public static int formatLongOctalOrBinaryBytes( final long value, byte[] buf, final int offset, final int length)",
        "public static int formatCheckSumOctalBytes(final long value, byte[] buf, final int offset, final int length)",
        "public static long computeCheckSum(final byte[] buf)"
      ],
      "methods": [
        {
          "buggy_method": "  public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n  long  result = 0;\n  int  end = offset + length;\n  int  start = offset;\n\n  if (length < 2){\n  throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n  }\n\n  boolean allNUL = true;\n  for (int i = start; i < end; i++){\n  if (buffer[i] != 0){\n  allNUL = false;\n  break;\n  }\n  }\n  if (allNUL) {\n  return 0L;\n  }\n\n  \n  while (start < end){\n  if (buffer[start] == ' '){\n  start++;\n  } else {\n  break;\n  }\n  }\n\n  \n  byte trailer;\n  trailer = buffer[end-1];\n  if (trailer == 0 || trailer == ' '){\n  end--;\n  } else {\n  throw new IllegalArgumentException(\n  exceptionMessage(buffer, offset, length, end-1, trailer));\n  }\n  \n  trailer = buffer[end-1];\n  if (trailer == 0 || trailer == ' '){\n  end--;\n  }\n\n  for ( ;start < end; start++) {\n  final byte currentByte = buffer[start];\n  \n  if (currentByte < '0' || currentByte > '7'){\n  throw new IllegalArgumentException(\n  exceptionMessage(buffer, offset, length, start, currentByte));\n  }\n  result = (result << 3) + (currentByte - '0'); \n  \n  }\n\n  return result;\n  }",
          "fixed_method": "  public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n  long  result = 0;\n  int  end = offset + length;\n  int  start = offset;\n\n  if (length < 2){\n  throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n  }\n\n  if (buffer[start] == 0) {\n  return 0L;\n  }\n\n  \n  while (start < end){\n  if (buffer[start] == ' '){\n  start++;\n  } else {\n  break;\n  }\n  }\n\n  \n  byte trailer;\n  trailer = buffer[end-1];\n  if (trailer == 0 || trailer == ' '){\n  end--;\n  } else {\n  throw new IllegalArgumentException(\n  exceptionMessage(buffer, offset, length, end-1, trailer));\n  }\n  \n  trailer = buffer[end-1];\n  if (trailer == 0 || trailer == ' '){\n  end--;\n  }\n\n  for ( ;start < end; start++) {\n  final byte currentByte = buffer[start];\n  \n  if (currentByte < '0' || currentByte > '7'){\n  throw new IllegalArgumentException(\n  exceptionMessage(buffer, offset, length, start, currentByte));\n  }\n  result = (result << 3) + (currentByte - '0'); \n  \n  }\n\n  return result;\n  }",
          "diff": [
            "@@ -62,14 +62,7 @@",
            "             throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n",
            "         }\n",
            " \n",
            "-        boolean allNUL = true;\n",
            "-        for (int i = start; i < end; i++){\n",
            "-            if (buffer[i] != 0){\n",
            "-                allNUL = false;\n",
            "-                break;\n",
            "-            }\n",
            "-        }\n",
            "-        if (allNUL) {\n",
            "+        if (buffer[start] == 0) {\n",
            "             return 0L;\n",
            "         }\n",
            " \n"
          ],
          "changed_lines": 9
        }
      ]
    }
  ]
}
