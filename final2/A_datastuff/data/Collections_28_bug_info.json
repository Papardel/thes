{
  "bug_id": "28",
  "failed_tests": {
    "org.apache.commons.collections4.trie.PatriciaTrieTest": [
      {
        "methodName": "testPrefixMapClear",
        "error": "java.lang.NullPointerException",
        "message": "",
        "fail_line": "        prefixMap.clear();",
        "test_source": "  public void testPrefixMapClear() {\n  Trie<String, Integer> trie = new PatriciaTrie<Integer>();\n  trie.put(\"Anna\", 1);\n  trie.put(\"Anael\", 2);\n  trie.put(\"Analu\", 3);\n  trie.put(\"Andreas\", 4);\n  trie.put(\"Andrea\", 5);\n  trie.put(\"Andres\", 6);\n  trie.put(\"Anatole\", 7);\n  SortedMap<String, Integer> prefixMap = trie.prefixMap(\"And\");\n  assertEquals(new HashSet<String>(Arrays.asList(\"Andrea\", \"Andreas\", \"Andres\")), prefixMap.keySet());\n  assertEquals(Arrays.asList(5, 4, 6), new ArrayList<Integer>(prefixMap.values()));\n\n  prefixMap.clear();\n  assertTrue(prefixMap.isEmpty());\n  assertTrue(prefixMap.keySet().isEmpty());\n  assertTrue(prefixMap.values().isEmpty());\n  assertEquals(new HashSet<String>(Arrays.asList(\"Anael\", \"Analu\", \"Anatole\", \"Anna\")), trie.keySet());\n  assertEquals(Arrays.asList(2, 3, 7, 1), new ArrayList<Integer>(trie.values()));\n  }",
        "stack": [
          "AbstractPatriciaTrie$PrefixRangeEntrySet$EntryIterator.remove line 2405, PatriciaTrieTest.testPrefixMapClear line 386"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/collections4/trie/AbstractPatriciaTrie.java",
      "buggy_full_code": "\npackage org.apache.commons.collections4.trie;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.util.AbstractCollection;\nimport java.util.AbstractMap;\nimport java.util.AbstractSet;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.ConcurrentModificationException;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Set;\nimport java.util.SortedMap;\n\nimport org.apache.commons.collections4.OrderedMapIterator;\n\n\nabstract class AbstractPatriciaTrie<K, V> extends AbstractBitwiseTrie<K, V> { private static final long serialVersionUID = 5155253417231339498L; private transient TrieEntry<K, V> root = new TrieEntry<K, V>(null, null, -1); private transient volatile Set<K> keySet; private transient volatile Collection<V> values; private transient volatile Set<Map.Entry<K,V>> entrySet; private transient int size = 0; protected transient int modCount = 0; protected AbstractPatriciaTrie(final KeyAnalyzer<? super K> keyAnalyzer) {\n        super(keyAnalyzer);\n    }\n\n    \n    protected AbstractPatriciaTrie(final KeyAnalyzer<? super K> keyAnalyzer, final Map<? extends K, ? extends V> map) {\n        super(keyAnalyzer);\n        putAll(map);\n    }\n\n    \n    @Override\n    public void clear() {\n        root.key = null;\n        root.bitIndex = -1;\n        root.value = null;\n\n        root.parent = null;\n        root.left = root;\n        root.right = null;\n        root.predecessor = root;\n\n        size = 0;\n        incrementModCount();\n    }\n\n    @Override\n    public int size() {\n        return size;\n    }\n\n    \n    void incrementSize() {\n        size++;\n        incrementModCount();\n    }\n\n    \n    void decrementSize() {\n        size--;\n        incrementModCount();\n    }\n\n    \n    private void incrementModCount() {\n        ++modCount;\n    }\n\n    @Override\n    public V put(final K key, final V value) {\n        if (key == null) {\n            throw new NullPointerException(\"Key cannot be null\");\n        }\n\n        final int lengthInBits = lengthInBits(key);\n\n        \n        \n        if (lengthInBits == 0) {\n            if (root.isEmpty()) {\n                incrementSize();\n            } else {\n                incrementModCount();\n            }\n            return root.setKeyValue(key, value);\n        }\n\n        final TrieEntry<K, V> found = getNearestEntryForKey(key, lengthInBits);\n        if (compareKeys(key, found.key)) {\n            if (found.isEmpty()) { \n                incrementSize();\n            } else {\n                incrementModCount();\n            }\n            return found.setKeyValue(key, value);\n        }\n\n        final int bitIndex = bitIndex(key, found.key);\n        if (!KeyAnalyzer.isOutOfBoundsIndex(bitIndex)) {\n            if (KeyAnalyzer.isValidBitIndex(bitIndex)) { \n                \n                final TrieEntry<K, V> t = new TrieEntry<K, V>(key, value, bitIndex);\n                addEntry(t, lengthInBits);\n                incrementSize();\n                return null;\n            } else if (KeyAnalyzer.isNullBitKey(bitIndex)) {\n                \n                \n\n                \n                if (root.isEmpty()) {\n                    incrementSize();\n                } else {\n                    incrementModCount();\n                }\n                return root.setKeyValue(key, value);\n\n            } else if (KeyAnalyzer.isEqualBitKey(bitIndex)) {\n                \n\n                \n                if (found != root) {\n                    incrementModCount();\n                    return found.setKeyValue(key, value);\n                }\n            }\n        }\n\n        throw new IllegalArgumentException(\"Failed to put: \" + key + \" -> \" + value + \", \" + bitIndex);\n    }\n\n    \n    TrieEntry<K, V> addEntry(final TrieEntry<K, V> entry, final int lengthInBits) {\n        TrieEntry<K, V> current = root.left;\n        TrieEntry<K, V> path = root;\n        while(true) {\n            if (current.bitIndex >= entry.bitIndex\n                    || current.bitIndex <= path.bitIndex) {\n                entry.predecessor = entry;\n\n                if (!isBitSet(entry.key, entry.bitIndex, lengthInBits)) {\n                    entry.left = entry;\n                    entry.right = current;\n                } else {\n                    entry.left = current;\n                    entry.right = entry;\n                }\n\n                entry.parent = path;\n                if (current.bitIndex >= entry.bitIndex) {\n                    current.parent = entry;\n                }\n\n                \n                if (current.bitIndex <= path.bitIndex) {\n                    current.predecessor = entry;\n                }\n\n                if (path == root || !isBitSet(entry.key, path.bitIndex, lengthInBits)) {\n                    path.left = entry;\n                } else {\n                    path.right = entry;\n                }\n\n                return entry;\n            }\n\n            path = current;\n\n            if (!isBitSet(entry.key, current.bitIndex, lengthInBits)) {\n                current = current.left;\n            } else {\n                current = current.right;\n            }\n        }\n    }\n\n    @Override\n    public V get(final Object k) {\n        final TrieEntry<K, V> entry = getEntry(k);\n        return entry != null ? entry.getValue() : null;\n    }\n\n    \n    TrieEntry<K,V> getEntry(final Object k) {\n        final K key = castKey(k);\n        if (key == null) {\n            return null;\n        }\n\n        final int lengthInBits = lengthInBits(key);\n        final TrieEntry<K,V> entry = getNearestEntryForKey(key, lengthInBits);\n        return !entry.isEmpty() && compareKeys(key, entry.key) ? entry : null;\n    }\n\n    \n    public Map.Entry<K, V> select(final K key) {\n        final int lengthInBits = lengthInBits(key);\n        final Reference<Map.Entry<K, V>> reference = new Reference<Map.Entry<K,V>>();\n        if (!selectR(root.left, -1, key, lengthInBits, reference)) {\n            return reference.get();\n        }\n        return null;\n    }\n\n    \n    public K selectKey(final K key) {\n        final Map.Entry<K, V> entry = select(key);\n        if (entry == null) {\n            return null;\n        }\n        return entry.getKey();\n    }\n\n    \n    public V selectValue(final K key) {\n        final Map.Entry<K, V> entry = select(key);\n        if (entry == null) {\n            return null;\n        }\n        return entry.getValue();\n    }\n\n    \n    private boolean selectR(final TrieEntry<K, V> h, final int bitIndex, final K key, final int lengthInBits, final Reference<Map.Entry<K, V>> reference) {\n\n        if (h.bitIndex <= bitIndex) {\n            \n            \n            \n            if (!h.isEmpty()) {\n                reference.set(h);\n                return false;\n            }\n            return true;\n        }\n\n        if (!isBitSet(key, h.bitIndex, lengthInBits)) {\n            if (selectR(h.left, h.bitIndex, key, lengthInBits, reference)) {\n                return selectR(h.right, h.bitIndex, key, lengthInBits, reference);\n            }\n        } else {\n            if (selectR(h.right, h.bitIndex, key, lengthInBits, reference)) {\n                return selectR(h.left, h.bitIndex, key, lengthInBits, reference);\n            }\n        }\n        return false;\n    }\n\n    @Override\n    public boolean containsKey(final Object k) {\n        if (k == null) {\n            return false;\n        }\n\n        final K key = castKey(k);\n        final int lengthInBits = lengthInBits(key);\n        final TrieEntry<K, V> entry = getNearestEntryForKey(key, lengthInBits);\n        return !entry.isEmpty() && compareKeys(key, entry.key);\n    }\n\n    @Override\n    public Set<Map.Entry<K,V>> entrySet() {\n        if (entrySet == null) {\n            entrySet = new EntrySet();\n        }\n        return entrySet;\n    }\n\n    @Override\n    public Set<K> keySet() {\n        if (keySet == null) {\n            keySet = new KeySet();\n        }\n        return keySet;\n    }\n\n    @Override\n    public Collection<V> values() {\n        if (values == null) {\n            values = new Values();\n        }\n        return values;\n    }\n\n    \n    @Override\n    public V remove(final Object k) {\n        if (k == null) {\n            return null;\n        }\n\n        final K key = castKey(k);\n        final int lengthInBits = lengthInBits(key);\n        TrieEntry<K, V> current = root.left;\n        TrieEntry<K, V> path = root;\n        while (true) {\n            if (current.bitIndex <= path.bitIndex) {\n                if (!current.isEmpty() && compareKeys(key, current.key)) {\n                    return removeEntry(current);\n                }\n                return null;\n            }\n\n            path = current;\n\n            if (!isBitSet(key, current.bitIndex, lengthInBits)) {\n                current = current.left;\n            } else {\n                current = current.right;\n            }\n        }\n    }\n\n    \n    TrieEntry<K, V> getNearestEntryForKey(final K key, final int lengthInBits) {\n        TrieEntry<K, V> current = root.left;\n        TrieEntry<K, V> path = root;\n        while(true) {\n            if (current.bitIndex <= path.bitIndex) {\n                return current;\n            }\n\n            path = current;\n            if (!isBitSet(key, current.bitIndex, lengthInBits)) {\n                current = current.left;\n            } else {\n                current = current.right;\n            }\n        }\n    }\n\n    \n    V removeEntry(final TrieEntry<K, V> h) {\n        if (h != root) {\n            if (h.isInternalNode()) {\n                removeInternalEntry(h);\n            } else {\n                removeExternalEntry(h);\n            }\n        }\n\n        decrementSize();\n        return h.setKeyValue(null, null);\n    }\n\n    \n    private void removeExternalEntry(final TrieEntry<K, V> h) {\n        if (h == root) {\n            throw new IllegalArgumentException(\"Cannot delete root Entry!\");\n        } else if (!h.isExternalNode()) {\n            throw new IllegalArgumentException(h + \" is not an external Entry!\");\n        }\n\n        final TrieEntry<K, V> parent = h.parent;\n        final TrieEntry<K, V> child = h.left == h ? h.right : h.left;\n\n        if (parent.left == h) {\n            parent.left = child;\n        } else {\n            parent.right = child;\n        }\n\n        \n        if (child.bitIndex > parent.bitIndex) {\n            child.parent = parent;\n        } else {\n            child.predecessor = parent;\n        }\n\n    }\n\n    \n    private void removeInternalEntry(final TrieEntry<K, V> h) {\n        if (h == root) {\n            throw new IllegalArgumentException(\"Cannot delete root Entry!\");\n        } else if (!h.isInternalNode()) {\n            throw new IllegalArgumentException(h + \" is not an internal Entry!\");\n        }\n\n        final TrieEntry<K, V> p = h.predecessor;\n\n        \n        p.bitIndex = h.bitIndex;\n\n        \n        {\n            final TrieEntry<K, V> parent = p.parent;\n            final TrieEntry<K, V> child = p.left == h ? p.right : p.left;\n\n            \n            \n            \n            \n            \n            \n            if (p.predecessor == p && p.parent != h) {\n                p.predecessor = p.parent;\n            }\n\n            if (parent.left == p) {\n                parent.left = child;\n            } else {\n                parent.right = child;\n            }\n\n            if (child.bitIndex > parent.bitIndex) {\n                child.parent = parent;\n            }\n        }\n\n        \n        {\n            \n            \n            if (h.left.parent == h) {\n                h.left.parent = p;\n            }\n\n            if (h.right.parent == h) {\n                h.right.parent = p;\n            }\n\n            \n            if (h.parent.left == h) {\n                h.parent.left = p;\n            } else {\n                h.parent.right = p;\n            }\n        }\n\n        \n        \n        p.parent = h.parent;\n        p.left = h.left;\n        p.right = h.right;\n\n        \n        \n        if (isValidUplink(p.left, p)) {\n            p.left.predecessor = p;\n        }\n\n        if (isValidUplink(p.right, p)) {\n            p.right.predecessor = p;\n        }\n    }\n\n    \n    TrieEntry<K, V> nextEntry(final TrieEntry<K, V> node) {\n        if (node == null) {\n            return firstEntry();\n        }\n        return nextEntryImpl(node.predecessor, node, null);\n    }\n\n    \n    TrieEntry<K, V> nextEntryImpl(final TrieEntry<K, V> start,\n            final TrieEntry<K, V> previous, final TrieEntry<K, V> tree) {\n\n        TrieEntry<K, V> current = start;\n\n        \n        \n        \n        if (previous == null || start != previous.predecessor) {\n            while (!current.left.isEmpty()) {\n                \n                \n                if (previous == current.left) {\n                    break;\n                }\n\n                if (isValidUplink(current.left, current)) {\n                    return current.left;\n                }\n\n                current = current.left;\n            }\n        }\n\n        \n        if (current.isEmpty()) {\n            return null;\n        }\n\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        if (current.right == null) {\n            return null;\n        }\n\n        \n        if (previous != current.right) {\n            \n            if (isValidUplink(current.right, current)) {\n                return current.right;\n            }\n\n            \n            return nextEntryImpl(current.right, previous, tree);\n        }\n\n        \n        \n        while (current == current.parent.right) {\n            \n            if (current == tree) {\n                return null;\n            }\n\n            current = current.parent;\n        }\n\n        \n        if (current == tree) {\n            return null;\n        }\n\n        \n        if (current.parent.right == null) {\n            return null;\n        }\n\n        \n        if (previous != current.parent.right\n                && isValidUplink(current.parent.right, current.parent)) {\n            return current.parent.right;\n        }\n\n        \n        if (current.parent.right == current.parent) {\n            return null;\n        }\n\n        \n        return nextEntryImpl(current.parent.right, previous, tree);\n    }\n\n    \n    TrieEntry<K, V> firstEntry() {\n        \n        if (isEmpty()) {\n            return null;\n        }\n\n        return followLeft(root);\n    }\n\n    \n    TrieEntry<K, V> followLeft(TrieEntry<K, V> node) {\n        while(true) {\n            TrieEntry<K, V> child = node.left;\n            \n            if (child.isEmpty()) {\n                child = node.right;\n            }\n\n            if (child.bitIndex <= node.bitIndex) {\n                return child;\n            }\n\n            node = child;\n        }\n    }\n\n    \n\n    @Override\n    public Comparator<? super K> comparator() {\n        return getKeyAnalyzer();\n    }\n\n    @Override\n    public K firstKey() {\n        if (size() == 0) {\n            throw new NoSuchElementException();\n        }\n        return firstEntry().getKey();\n    }\n\n    @Override\n    public K lastKey() {\n        final TrieEntry<K, V> entry = lastEntry();\n        if (entry != null) {\n            return entry.getKey();\n        }\n        throw new NoSuchElementException();\n    }\n\n    @Override\n    public K nextKey(final K key) {\n        if (key == null) {\n            throw new NullPointerException();\n        }\n        final TrieEntry<K, V> entry = getEntry(key);\n        if (entry != null) {\n            final TrieEntry<K, V> nextEntry = nextEntry(entry);\n            return nextEntry != null ? nextEntry.getKey() : null;\n        }\n        return null;\n    }\n\n    @Override\n    public K previousKey(final K key) {\n        if (key == null) {\n            throw new NullPointerException();\n        }\n        final TrieEntry<K, V> entry = getEntry(key);\n        if (entry != null) {\n            final TrieEntry<K, V> prevEntry = previousEntry(entry);\n            return prevEntry != null ? prevEntry.getKey() : null;\n        }\n        return null;\n    }\n\n    @Override\n    public OrderedMapIterator<K, V> mapIterator() {\n        return new TrieMapIterator();\n    }\n\n    @Override\n    public SortedMap<K, V> prefixMap(final K key) {\n        return getPrefixMapByBits(key, 0, lengthInBits(key));\n    }\n\n    \n    private SortedMap<K, V> getPrefixMapByBits(final K key, final int offsetInBits, final int lengthInBits) {\n\n        final int offsetLength = offsetInBits + lengthInBits;\n        if (offsetLength > lengthInBits(key)) {\n            throw new IllegalArgumentException(offsetInBits + \" + \"\n                    + lengthInBits + \" > \" + lengthInBits(key));\n        }\n\n        if (offsetLength == 0) {\n            return this;\n        }\n\n        return new PrefixRangeMap(key, offsetInBits, lengthInBits);\n    }\n\n    @Override\n    public SortedMap<K, V> headMap(final K toKey) {\n        return new RangeEntryMap(null, toKey);\n    }\n\n    @Override\n    public SortedMap<K, V> subMap(final K fromKey, final K toKey) {\n        return new RangeEntryMap(fromKey, toKey);\n    }\n\n    @Override\n    public SortedMap<K, V> tailMap(final K fromKey) {\n        return new RangeEntryMap(fromKey, null);\n    }\n\n    \n    TrieEntry<K,V> higherEntry(final K key) {\n        \n        \n        \n        final int lengthInBits = lengthInBits(key);\n\n        if (lengthInBits == 0) {\n            if (!root.isEmpty()) {\n                \n                if (size() > 1) {\n                    return nextEntry(root);\n                }\n                \n                return null;\n            }\n            \n            return firstEntry();\n        }\n\n        final TrieEntry<K, V> found = getNearestEntryForKey(key, lengthInBits);\n        if (compareKeys(key, found.key)) {\n            return nextEntry(found);\n        }\n\n        final int bitIndex = bitIndex(key, found.key);\n        if (KeyAnalyzer.isValidBitIndex(bitIndex)) {\n            final TrieEntry<K, V> added = new TrieEntry<K, V>(key, null, bitIndex);\n            addEntry(added, lengthInBits);\n            incrementSize(); \n            final TrieEntry<K, V> ceil = nextEntry(added);\n            removeEntry(added);\n            modCount -= 2; \n            return ceil;\n        } else if (KeyAnalyzer.isNullBitKey(bitIndex)) {\n            if (!root.isEmpty()) {\n                return firstEntry();\n            } else if (size() > 1) {\n                return nextEntry(firstEntry());\n            } else {\n                return null;\n            }\n        } else if (KeyAnalyzer.isEqualBitKey(bitIndex)) {\n            return nextEntry(found);\n        }\n\n        \n        throw new IllegalStateException(\"invalid lookup: \" + key);\n    }\n\n    \n    TrieEntry<K,V> ceilingEntry(final K key) {\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n\n        \n        \n        \n        final int lengthInBits = lengthInBits(key);\n\n        if (lengthInBits == 0) {\n            if (!root.isEmpty()) {\n                return root;\n            }\n            return firstEntry();\n        }\n\n        final TrieEntry<K, V> found = getNearestEntryForKey(key, lengthInBits);\n        if (compareKeys(key, found.key)) {\n            return found;\n        }\n\n        final int bitIndex = bitIndex(key, found.key);\n        if (KeyAnalyzer.isValidBitIndex(bitIndex)) {\n            final TrieEntry<K, V> added = new TrieEntry<K, V>(key, null, bitIndex);\n            addEntry(added, lengthInBits);\n            incrementSize(); \n            final TrieEntry<K, V> ceil = nextEntry(added);\n            removeEntry(added);\n            modCount -= 2; \n            return ceil;\n        } else if (KeyAnalyzer.isNullBitKey(bitIndex)) {\n            if (!root.isEmpty()) {\n                return root;\n            }\n            return firstEntry();\n        } else if (KeyAnalyzer.isEqualBitKey(bitIndex)) {\n            return found;\n        }\n\n        \n        throw new IllegalStateException(\"invalid lookup: \" + key);\n    }\n\n    \n    TrieEntry<K,V> lowerEntry(final K key) {\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n\n        \n        \n        \n        final int lengthInBits = lengthInBits(key);\n\n        if (lengthInBits == 0) {\n            return null; \n        }\n\n        final TrieEntry<K, V> found = getNearestEntryForKey(key, lengthInBits);\n        if (compareKeys(key, found.key)) {\n            return previousEntry(found);\n        }\n\n        final int bitIndex = bitIndex(key, found.key);\n        if (KeyAnalyzer.isValidBitIndex(bitIndex)) {\n            final TrieEntry<K, V> added = new TrieEntry<K, V>(key, null, bitIndex);\n            addEntry(added, lengthInBits);\n            incrementSize(); \n            final TrieEntry<K, V> prior = previousEntry(added);\n            removeEntry(added);\n            modCount -= 2; \n            return prior;\n        } else if (KeyAnalyzer.isNullBitKey(bitIndex)) {\n            return null;\n        } else if (KeyAnalyzer.isEqualBitKey(bitIndex)) {\n            return previousEntry(found);\n        }\n\n        \n        throw new IllegalStateException(\"invalid lookup: \" + key);\n    }\n\n    \n    TrieEntry<K,V> floorEntry(final K key) {\n        \n        \n        \n        final int lengthInBits = lengthInBits(key);\n\n        if (lengthInBits == 0) {\n            if (!root.isEmpty()) {\n                return root;\n            }\n            return null;\n        }\n\n        final TrieEntry<K, V> found = getNearestEntryForKey(key, lengthInBits);\n        if (compareKeys(key, found.key)) {\n            return found;\n        }\n\n        final int bitIndex = bitIndex(key, found.key);\n        if (KeyAnalyzer.isValidBitIndex(bitIndex)) {\n            final TrieEntry<K, V> added = new TrieEntry<K, V>(key, null, bitIndex);\n            addEntry(added, lengthInBits);\n            incrementSize(); \n            final TrieEntry<K, V> floor = previousEntry(added);\n            removeEntry(added);\n            modCount -= 2; \n            return floor;\n        } else if (KeyAnalyzer.isNullBitKey(bitIndex)) {\n            if (!root.isEmpty()) {\n                return root;\n            }\n            return null;\n        } else if (KeyAnalyzer.isEqualBitKey(bitIndex)) {\n            return found;\n        }\n\n        \n        throw new IllegalStateException(\"invalid lookup: \" + key);\n    }\n\n    \n    TrieEntry<K, V> subtree(final K prefix, final int offsetInBits, final int lengthInBits) {\n        TrieEntry<K, V> current = root.left;\n        TrieEntry<K, V> path = root;\n        while(true) {\n            if (current.bitIndex <= path.bitIndex || lengthInBits <= current.bitIndex) {\n                break;\n            }\n\n            path = current;\n            if (!isBitSet(prefix, offsetInBits + current.bitIndex, offsetInBits + lengthInBits)) {\n                current = current.left;\n            } else {\n                current = current.right;\n            }\n        }\n\n        \n        final TrieEntry<K, V> entry = current.isEmpty() ? path : current;\n\n        \n        if (entry.isEmpty()) {\n            return null;\n        }\n\n        final int endIndexInBits = offsetInBits + lengthInBits;\n\n        \n        \n        \n        \n        if (entry == root && lengthInBits(entry.getKey()) < endIndexInBits) {\n            return null;\n        }\n\n        \n        \n        if (isBitSet(prefix, endIndexInBits - 1, endIndexInBits)\n                != isBitSet(entry.key, lengthInBits - 1, lengthInBits(entry.key))) {\n            return null;\n        }\n\n        \n        final int bitIndex = getKeyAnalyzer().bitIndex(prefix, offsetInBits, lengthInBits,\n                                                       entry.key, 0, lengthInBits(entry.getKey()));\n\n        if (bitIndex >= 0 && bitIndex < lengthInBits) {\n            return null;\n        }\n\n        return entry;\n    }\n\n    \n    TrieEntry<K, V> lastEntry() {\n        return followRight(root.left);\n    }\n\n    \n    TrieEntry<K, V> followRight(TrieEntry<K, V> node) {\n        \n        if (node.right == null) {\n            return null;\n        }\n\n        \n        while (node.right.bitIndex > node.bitIndex) {\n            node = node.right;\n        }\n\n        return node.right;\n    }\n\n    \n    TrieEntry<K, V> previousEntry(final TrieEntry<K, V> start) {\n        if (start.predecessor == null) {\n            throw new IllegalArgumentException(\"must have come from somewhere!\");\n        }\n\n        if (start.predecessor.right == start) {\n            if (isValidUplink(start.predecessor.left, start.predecessor)) {\n                return start.predecessor.left;\n            }\n            return followRight(start.predecessor.left);\n        }\n        TrieEntry<K, V> node = start.predecessor;\n        while (node.parent != null && node == node.parent.left) {\n            node = node.parent;\n        }\n\n        if (node.parent == null) { \n            return null;\n        }\n\n        if (isValidUplink(node.parent.left, node.parent)) {\n            if (node.parent.left == root) {\n                if (root.isEmpty()) {\n                    return null;\n                }\n                return root;\n\n            }\n            return node.parent.left;\n        }\n        return followRight(node.parent.left);\n    }\n\n    \n    TrieEntry<K, V> nextEntryInSubtree(final TrieEntry<K, V> node,\n            final TrieEntry<K, V> parentOfSubtree) {\n        if (node == null) {\n            return firstEntry();\n        }\n        return nextEntryImpl(node.predecessor, node, parentOfSubtree);\n    }\n\n    \n    static boolean isValidUplink(final TrieEntry<?, ?> next, final TrieEntry<?, ?> from) {\n        return next != null && next.bitIndex <= from.bitIndex && !next.isEmpty();\n    }\n\n    \n    private static class Reference<E> { private E item; public void set(final E item) {\n            this.item = item;\n        }\n\n        public E get() {\n            return item;\n        }\n    }\n\n    \n    protected static class TrieEntry<K,V> extends BasicEntry<K, V> { private static final long serialVersionUID = 4596023148184140013L; protected int bitIndex; protected TrieEntry<K,V> parent; protected TrieEntry<K,V> left; protected TrieEntry<K,V> right; protected TrieEntry<K,V> predecessor; public TrieEntry(final K key, final V value, final int bitIndex) {\n            super(key, value);\n\n            this.bitIndex = bitIndex;\n\n            this.parent = null;\n            this.left = this;\n            this.right = null;\n            this.predecessor = this;\n        }\n\n        \n        public boolean isEmpty() {\n            return key == null;\n        }\n\n        \n        public boolean isInternalNode() {\n            return left != this && right != this;\n        }\n\n        \n        public boolean isExternalNode() {\n            return !isInternalNode();\n        }\n\n        @Override\n        public String toString() {\n            final StringBuilder buffer = new StringBuilder();\n\n            if (bitIndex == -1) {\n                buffer.append(\"RootEntry(\");\n            } else {\n                buffer.append(\"Entry(\");\n            }\n\n            buffer.append(\"key=\").append(getKey()).append(\" [\").append(bitIndex).append(\"], \");\n            buffer.append(\"value=\").append(getValue()).append(\", \");\n            \n\n            if (parent != null) {\n                if (parent.bitIndex == -1) {\n                    buffer.append(\"parent=\").append(\"ROOT\");\n                } else {\n                    buffer.append(\"parent=\").append(parent.getKey()).append(\" [\").append(parent.bitIndex).append(\"]\");\n                }\n            } else {\n                buffer.append(\"parent=\").append(\"null\");\n            }\n            buffer.append(\", \");\n\n            if (left != null) {\n                if (left.bitIndex == -1) {\n                    buffer.append(\"left=\").append(\"ROOT\");\n                } else {\n                    buffer.append(\"left=\").append(left.getKey()).append(\" [\").append(left.bitIndex).append(\"]\");\n                }\n            } else {\n                buffer.append(\"left=\").append(\"null\");\n            }\n            buffer.append(\", \");\n\n            if (right != null) {\n                if (right.bitIndex == -1) {\n                    buffer.append(\"right=\").append(\"ROOT\");\n                } else {\n                    buffer.append(\"right=\").append(right.getKey()).append(\" [\").append(right.bitIndex).append(\"]\");\n                }\n            } else {\n                buffer.append(\"right=\").append(\"null\");\n            }\n            buffer.append(\", \");\n\n            if (predecessor != null) {\n                if(predecessor.bitIndex == -1) {\n                    buffer.append(\"predecessor=\").append(\"ROOT\");\n                } else {\n                    buffer.append(\"predecessor=\").append(predecessor.getKey()).append(\" [\").\n                           append(predecessor.bitIndex).append(\"]\");\n                }\n            }\n\n            buffer.append(\")\");\n            return buffer.toString();\n        }\n    }\n\n\n    \n    private class EntrySet extends AbstractSet<Map.Entry<K,V>> { @Override public Iterator<Map.Entry<K,V>> iterator() {\n            return new EntryIterator();\n        }\n\n        @Override\n        public boolean contains(final Object o) {\n            if (!(o instanceof Map.Entry)) {\n                return false;\n            }\n\n            final TrieEntry<K,V> candidate = getEntry(((Map.Entry<?, ?>)o).getKey());\n            return candidate != null && candidate.equals(o);\n        }\n\n        @Override\n        public boolean remove(final Object obj) {\n            if (obj instanceof Map.Entry == false) {\n                return false;\n            }\n            if (contains(obj) == false) {\n                return false;\n            }\n            final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n            AbstractPatriciaTrie.this.remove(entry.getKey());\n            return true;\n        }\n\n        @Override\n        public int size() {\n            return AbstractPatriciaTrie.this.size();\n        }\n\n        @Override\n        public void clear() {\n            AbstractPatriciaTrie.this.clear();\n        }\n\n        \n        private class EntryIterator extends TrieIterator<Map.Entry<K,V>> { @Override public Map.Entry<K,V> next() {\n                return nextEntry();\n            }\n        }\n    }\n\n    \n    private class KeySet extends AbstractSet<K> { @Override public Iterator<K> iterator() {\n            return new KeyIterator();\n        }\n\n        @Override\n        public int size() {\n            return AbstractPatriciaTrie.this.size();\n        }\n\n        @Override\n        public boolean contains(final Object o) {\n            return containsKey(o);\n        }\n\n        @Override\n        public boolean remove(final Object o) {\n            final int size = size();\n            AbstractPatriciaTrie.this.remove(o);\n            return size != size();\n        }\n\n        @Override\n        public void clear() {\n            AbstractPatriciaTrie.this.clear();\n        }\n\n        \n        private class KeyIterator extends TrieIterator<K> { @Override public K next() {\n                return nextEntry().getKey();\n            }\n        }\n    }\n\n    \n    private class Values extends AbstractCollection<V> { @Override public Iterator<V> iterator() {\n            return new ValueIterator();\n        }\n\n        @Override\n        public int size() {\n            return AbstractPatriciaTrie.this.size();\n        }\n\n        @Override\n        public boolean contains(final Object o) {\n            return containsValue(o);\n        }\n\n        @Override\n        public void clear() {\n            AbstractPatriciaTrie.this.clear();\n        }\n\n        @Override\n        public boolean remove(final Object o) {\n            for (final Iterator<V> it = iterator(); it.hasNext(); ) {\n                final V value = it.next();\n                if (compare(value, o)) {\n                    it.remove();\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        \n        private class ValueIterator extends TrieIterator<V> { @Override public V next() {\n                return nextEntry().getValue();\n            }\n        }\n    }\n\n    \n    abstract class TrieIterator<E> implements Iterator<E> { protected int expectedModCount = AbstractPatriciaTrie.this.modCount; protected TrieEntry<K, V> next; protected TrieEntry<K, V> current; protected TrieIterator() {\n            next = AbstractPatriciaTrie.this.nextEntry(null);\n        }\n\n        \n        protected TrieIterator(final TrieEntry<K, V> firstEntry) {\n            next = firstEntry;\n        }\n\n        \n        protected TrieEntry<K,V> nextEntry() {\n            if (expectedModCount != AbstractPatriciaTrie.this.modCount) {\n                throw new ConcurrentModificationException();\n            }\n\n            final TrieEntry<K,V> e = next;\n            if (e == null) {\n                throw new NoSuchElementException();\n            }\n\n            next = findNext(e);\n            current = e;\n            return e;\n        }\n\n        \n        protected TrieEntry<K, V> findNext(final TrieEntry<K, V> prior) {\n            return AbstractPatriciaTrie.this.nextEntry(prior);\n        }\n\n        @Override\n        public boolean hasNext() {\n            return next != null;\n        }\n\n        @Override\n        public void remove() {\n            if (current == null) {\n                throw new IllegalStateException();\n            }\n\n            if (expectedModCount != AbstractPatriciaTrie.this.modCount) {\n                throw new ConcurrentModificationException();\n            }\n\n            final TrieEntry<K, V> node = current;\n            current = null;\n            AbstractPatriciaTrie.this.removeEntry(node);\n\n            expectedModCount = AbstractPatriciaTrie.this.modCount;\n        }\n    }\n\n    \n    private class TrieMapIterator extends TrieIterator<K> implements OrderedMapIterator<K, V> { protected TrieEntry<K, V> previous; @Override public K next() {\n            return nextEntry().getKey();\n        }\n\n        @Override\n        public K getKey() {\n            if (current == null) {\n                throw new IllegalStateException();\n            }\n            return current.getKey();\n        }\n\n        @Override\n        public V getValue() {\n            if (current == null) {\n                throw new IllegalStateException();\n            }\n            return current.getValue();\n        }\n\n        @Override\n        public V setValue(final V value) {\n            if (current == null) {\n                throw new IllegalStateException();\n            }\n            return current.setValue(value);\n        }\n\n        @Override\n        public boolean hasPrevious() {\n            return previous != null;\n        }\n\n        @Override\n        public K previous() {\n            return previousEntry().getKey();\n        }\n\n        @Override\n        protected TrieEntry<K, V> nextEntry() {\n            final TrieEntry<K, V> nextEntry = super.nextEntry();\n            previous = nextEntry;\n            return nextEntry;\n        }\n\n        protected TrieEntry<K,V> previousEntry() {\n            if (expectedModCount != AbstractPatriciaTrie.this.modCount) {\n                throw new ConcurrentModificationException();\n            }\n\n            final TrieEntry<K,V> e = previous;\n            if (e == null) {\n                throw new NoSuchElementException();\n            }\n\n            previous = AbstractPatriciaTrie.this.previousEntry(e);\n            next = current;\n            current = e;\n            return current;\n        }\n\n    }\n\n    \n    private abstract class RangeMap extends AbstractMap<K, V> implements SortedMap<K, V> { private transient volatile Set<Map.Entry<K, V>> entrySet; protected abstract Set<Map.Entry<K, V>> createEntrySet(); protected abstract K getFromKey(); protected abstract boolean isFromInclusive(); protected abstract K getToKey(); protected abstract boolean isToInclusive(); @Override public Comparator<? super K> comparator() {\n            return AbstractPatriciaTrie.this.comparator();\n        }\n\n        @Override\n        public boolean containsKey(final Object key) {\n            if (!inRange(castKey(key))) {\n                return false;\n            }\n\n            return AbstractPatriciaTrie.this.containsKey(key);\n        }\n\n        @Override\n        public V remove(final Object key) {\n            if (!inRange(castKey(key))) {\n                return null;\n            }\n\n            return AbstractPatriciaTrie.this.remove(key);\n        }\n\n        @Override\n        public V get(final Object key) {\n            if (!inRange(castKey(key))) {\n                return null;\n            }\n\n            return AbstractPatriciaTrie.this.get(key);\n        }\n\n        @Override\n        public V put(final K key, final V value) {\n            if (!inRange(key)) {\n                throw new IllegalArgumentException(\"Key is out of range: \" + key);\n            }\n            return AbstractPatriciaTrie.this.put(key, value);\n        }\n\n        @Override\n        public Set<Map.Entry<K, V>> entrySet() {\n            if (entrySet == null) {\n                entrySet = createEntrySet();\n            }\n            return entrySet;\n        }\n\n        @Override\n        public SortedMap<K, V> subMap(final K fromKey, final K toKey) {\n            if (!inRange2(fromKey)) {\n                throw new IllegalArgumentException(\"FromKey is out of range: \" + fromKey);\n            }\n\n            if (!inRange2(toKey)) {\n                throw new IllegalArgumentException(\"ToKey is out of range: \" + toKey);\n            }\n\n            return createRangeMap(fromKey, isFromInclusive(), toKey, isToInclusive());\n        }\n\n        @Override\n        public SortedMap<K, V> headMap(final K toKey) {\n            if (!inRange2(toKey)) {\n                throw new IllegalArgumentException(\"ToKey is out of range: \" + toKey);\n            }\n            return createRangeMap(getFromKey(), isFromInclusive(), toKey, isToInclusive());\n        }\n\n        @Override\n        public SortedMap<K, V> tailMap(final K fromKey) {\n            if (!inRange2(fromKey)) {\n                throw new IllegalArgumentException(\"FromKey is out of range: \" + fromKey);\n            }\n            return createRangeMap(fromKey, isFromInclusive(), getToKey(), isToInclusive());\n        }\n\n        \n        protected boolean inRange(final K key) {\n            final K fromKey = getFromKey();\n            final K toKey = getToKey();\n\n            return (fromKey == null || inFromRange(key, false)) && (toKey == null || inToRange(key, false));\n        }\n\n        \n        protected boolean inRange2(final K key) {\n            final K fromKey = getFromKey();\n            final K toKey = getToKey();\n\n            return (fromKey == null || inFromRange(key, false)) && (toKey == null || inToRange(key, true));\n        }\n\n        \n        protected boolean inFromRange(final K key, final boolean forceInclusive) {\n            final K fromKey = getFromKey();\n            final boolean fromInclusive = isFromInclusive();\n\n            final int ret = getKeyAnalyzer().compare(key, fromKey);\n            if (fromInclusive || forceInclusive) {\n                return ret >= 0;\n            }\n            return ret > 0;\n        }\n\n        \n        protected boolean inToRange(final K key, final boolean forceInclusive) {\n            final K toKey = getToKey();\n            final boolean toInclusive = isToInclusive();\n\n            final int ret = getKeyAnalyzer().compare(key, toKey);\n            if (toInclusive || forceInclusive) {\n                return ret <= 0;\n            }\n            return ret < 0;\n        }\n\n        \n        protected abstract SortedMap<K, V> createRangeMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive); } private class RangeEntryMap extends RangeMap {\n\n       \n       private final K fromKey; private final K toKey; private final boolean fromInclusive; private final boolean toInclusive; protected RangeEntryMap(final K fromKey, final K toKey) {\n           this(fromKey, true, toKey, false);\n       }\n\n       \n       protected RangeEntryMap(final K fromKey, final boolean fromInclusive, final K toKey, final boolean toInclusive) {\n\n           if (fromKey == null && toKey == null) {\n               throw new IllegalArgumentException(\"must have a from or to!\");\n           }\n\n           if (fromKey != null && toKey != null && getKeyAnalyzer().compare(fromKey, toKey) > 0) {\n               throw new IllegalArgumentException(\"fromKey > toKey\");\n           }\n\n           this.fromKey = fromKey;\n           this.fromInclusive = fromInclusive;\n           this.toKey = toKey;\n           this.toInclusive = toInclusive;\n       }\n\n       @Override\n    public K firstKey() {\n           Map.Entry<K,V> e = null;\n           if (fromKey == null) {\n               e = firstEntry();\n           } else {\n               if (fromInclusive) {\n                   e = ceilingEntry(fromKey);\n               } else {\n                   e = higherEntry(fromKey);\n               }\n           }\n\n           final K first = e != null ? e.getKey() : null;\n           if (e == null || toKey != null && !inToRange(first, false)) {\n               throw new NoSuchElementException();\n           }\n           return first;\n       }\n\n       @Override\n    public K lastKey() {\n           Map.Entry<K,V> e;\n           if (toKey == null) {\n               e = lastEntry();\n           } else {\n               if (toInclusive) {\n                   e = floorEntry(toKey);\n               } else {\n                   e = lowerEntry(toKey);\n               }\n           }\n\n           final K last = e != null ? e.getKey() : null;\n           if (e == null || fromKey != null && !inFromRange(last, false)) {\n               throw new NoSuchElementException();\n           }\n           return last;\n       }\n\n       @Override\n       protected Set<Entry<K, V>> createEntrySet() {\n           return new RangeEntrySet(this);\n       }\n\n       @Override\n       public K getFromKey() {\n           return fromKey;\n       }\n\n       @Override\n       public K getToKey() {\n           return toKey;\n       }\n\n       @Override\n       public boolean isFromInclusive() {\n           return fromInclusive;\n       }\n\n       @Override\n       public boolean isToInclusive() {\n           return toInclusive;\n       }\n\n       @Override\n       protected SortedMap<K, V> createRangeMap(final K fromKey, final boolean fromInclusive, final K toKey, final boolean toInclusive) {\n           return new RangeEntryMap(fromKey, fromInclusive, toKey, toInclusive);\n       }\n   }\n\n    \n    private class RangeEntrySet extends AbstractSet<Map.Entry<K, V>> { private final RangeMap delegate; private transient int size = -1; private transient int expectedModCount; public RangeEntrySet(final RangeMap delegate) {\n            if (delegate == null) {\n                throw new NullPointerException(\"delegate\");\n            }\n\n            this.delegate = delegate;\n        }\n\n        @Override\n        public Iterator<Map.Entry<K, V>> iterator() {\n            final K fromKey = delegate.getFromKey();\n            final K toKey = delegate.getToKey();\n\n            TrieEntry<K, V> first = null;\n            if (fromKey == null) {\n                first = firstEntry();\n            } else {\n                first = ceilingEntry(fromKey);\n            }\n\n            TrieEntry<K, V> last = null;\n            if (toKey != null) {\n                last = ceilingEntry(toKey);\n            }\n\n            return new EntryIterator(first, last);\n        }\n\n        @Override\n        public int size() {\n            if (size == -1 || expectedModCount != AbstractPatriciaTrie.this.modCount) {\n                size = 0;\n\n                for (final Iterator<?> it = iterator(); it.hasNext(); it.next()) {\n                    ++size;\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n            return size;\n        }\n\n        @Override\n        public boolean isEmpty() {\n            return !iterator().hasNext();\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        @Override\n        public boolean contains(final Object o) {\n            if (!(o instanceof Map.Entry)) {\n                return false;\n            }\n\n            final Map.Entry<K, V> entry = (Map.Entry<K, V>) o;\n            final K key = entry.getKey();\n            if (!delegate.inRange(key)) {\n                return false;\n            }\n\n            final TrieEntry<K, V> node = getEntry(key);\n            return node != null && compare(node.getValue(), entry.getValue());\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        @Override\n        public boolean remove(final Object o) {\n            if (!(o instanceof Map.Entry)) {\n                return false;\n            }\n\n            final Map.Entry<K, V> entry = (Map.Entry<K, V>) o;\n            final K key = entry.getKey();\n            if (!delegate.inRange(key)) {\n                return false;\n            }\n\n            final TrieEntry<K, V> node = getEntry(key);\n            if (node != null && compare(node.getValue(), entry.getValue())) {\n                removeEntry(node);\n                return true;\n            }\n            return false;\n        }\n\n        \n        private final class EntryIterator extends TrieIterator<Map.Entry<K,V>> { private final K excludedKey; private EntryIterator(final TrieEntry<K,V> first, final TrieEntry<K,V> last) {\n                super(first);\n                this.excludedKey = last != null ? last.getKey() : null;\n            }\n\n            @Override\n            public boolean hasNext() {\n                return next != null && !compare(next.key, excludedKey);\n            }\n\n            @Override\n            public Map.Entry<K,V> next() {\n                if (next == null || compare(next.key, excludedKey)) {\n                    throw new NoSuchElementException();\n                }\n                return nextEntry();\n            }\n        }\n    }\n\n    \n    private class PrefixRangeMap extends RangeMap { private final K prefix; private final int offsetInBits; private final int lengthInBits; private K fromKey = null; private K toKey = null; private transient int expectedModCount = 0; private int size = -1; private PrefixRangeMap(final K prefix, final int offsetInBits, final int lengthInBits) {\n            this.prefix = prefix;\n            this.offsetInBits = offsetInBits;\n            this.lengthInBits = lengthInBits;\n        }\n\n        \n        private int fixup() {\n            \n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\n                if (it.hasNext()) {\n                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }\n\n        @Override\n        public K firstKey() {\n            fixup();\n\n            Map.Entry<K,V> e = null;\n            if (fromKey == null) {\n                e = firstEntry();\n            } else {\n                e = higherEntry(fromKey);\n            }\n\n            final K first = e != null ? e.getKey() : null;\n            if (e == null || !getKeyAnalyzer().isPrefix(prefix, offsetInBits, lengthInBits, first)) {\n                throw new NoSuchElementException();\n            }\n\n            return first;\n        }\n\n        @Override\n        public K lastKey() {\n            fixup();\n\n            Map.Entry<K,V> e = null;\n            if (toKey == null) {\n                e = lastEntry();\n            } else {\n                e = lowerEntry(toKey);\n            }\n\n            final K last = e != null ? e.getKey() : null;\n            if (e == null || !getKeyAnalyzer().isPrefix(prefix, offsetInBits, lengthInBits, last)) {\n                throw new NoSuchElementException();\n            }\n\n            return last;\n        }\n\n        \n        @Override\n        protected boolean inRange(final K key) {\n            return getKeyAnalyzer().isPrefix(prefix, offsetInBits, lengthInBits, key);\n        }\n\n        \n        @Override\n        protected boolean inRange2(final K key) {\n            return inRange(key);\n        }\n\n        \n        @Override\n        protected boolean inFromRange(final K key, final boolean forceInclusive) {\n            return getKeyAnalyzer().isPrefix(prefix, offsetInBits, lengthInBits, key);\n        }\n\n        \n        @Override\n        protected boolean inToRange(final K key, final boolean forceInclusive) {\n            return getKeyAnalyzer().isPrefix(prefix, offsetInBits, lengthInBits, key);\n        }\n\n        @Override\n        protected Set<Map.Entry<K, V>> createEntrySet() {\n            return new PrefixRangeEntrySet(this);\n        }\n\n        @Override\n        public K getFromKey() {\n            return fromKey;\n        }\n\n        @Override\n        public K getToKey() {\n            return toKey;\n        }\n\n        @Override\n        public boolean isFromInclusive() {\n            return false;\n        }\n\n        @Override\n        public boolean isToInclusive() {\n            return false;\n        }\n\n        @Override\n        protected SortedMap<K, V> createRangeMap(final K fromKey, final boolean fromInclusive, final K toKey, final boolean toInclusive) {\n            return new RangeEntryMap(fromKey, fromInclusive, toKey, toInclusive);\n        }\n\n    }\n\n    \n    private final class PrefixRangeEntrySet extends RangeEntrySet { private final PrefixRangeMap delegate; private TrieEntry<K, V> prefixStart; private int expectedModCount = 0; public PrefixRangeEntrySet(final PrefixRangeMap delegate) {\n            super(delegate);\n            this.delegate = delegate;\n        }\n\n        @Override\n        public int size() {\n            return delegate.fixup();\n        }\n\n        @Override\n        public Iterator<Map.Entry<K,V>> iterator() {\n            if (AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                prefixStart = subtree(delegate.prefix, delegate.offsetInBits, delegate.lengthInBits);\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            if (prefixStart == null) {\n                final Set<Map.Entry<K,V>> empty = Collections.emptySet();\n                return empty.iterator();\n            } else if (delegate.lengthInBits > prefixStart.bitIndex) {\n                return new SingletonIterator(prefixStart);\n            } else {\n                return new EntryIterator(prefixStart, delegate.prefix, delegate.offsetInBits, delegate.lengthInBits);\n            }\n        }\n\n        \n        private final class SingletonIterator implements Iterator<Map.Entry<K, V>> { private final TrieEntry<K, V> entry; private int hit = 0; public SingletonIterator(final TrieEntry<K, V> entry) {\n                this.entry = entry;\n            }\n\n            @Override\n            public boolean hasNext() {\n                return hit == 0;\n            }\n\n            @Override\n            public Map.Entry<K, V> next() {\n                if (hit != 0) {\n                    throw new NoSuchElementException();\n                }\n\n                ++hit;\n                return entry;\n            }\n\n            @Override\n            public void remove() {\n                if (hit != 1) {\n                    throw new IllegalStateException();\n                }\n\n                ++hit;\n                AbstractPatriciaTrie.this.removeEntry(entry);\n            }\n        }\n\n        \n        private final class EntryIterator extends TrieIterator<Map.Entry<K, V>> { private final K prefix; private final int offset; private final int lengthInBits; private boolean lastOne; private TrieEntry<K, V> subtree; EntryIterator(final TrieEntry<K, V> startScan, final K prefix, final int offset, final int lengthInBits) {\n                subtree = startScan;\n                next = AbstractPatriciaTrie.this.followLeft(startScan);\n                this.prefix = prefix;\n                this.offset = offset;\n                this.lengthInBits = lengthInBits;\n            }\n\n            @Override\n            public Map.Entry<K,V> next() {\n                final Map.Entry<K, V> entry = nextEntry();\n                if (lastOne) {\n                    next = null;\n                }\n                return entry;\n            }\n\n            @Override\n            protected TrieEntry<K, V> findNext(final TrieEntry<K, V> prior) {\n                return AbstractPatriciaTrie.this.nextEntryInSubtree(prior, subtree);\n            }\n\n            @Override\n            public void remove() {\n                \n                \n                boolean needsFixing = false;\n                final int bitIdx = subtree.bitIndex;\n                if (current == subtree) {\n                    needsFixing = true;\n                }\n\n                super.remove();\n\n                \n                \n                if (bitIdx != subtree.bitIndex || needsFixing) {\n                    subtree = subtree(prefix, offset, lengthInBits);\n                }\n\n                \n                \n                \n                if (lengthInBits >= subtree.bitIndex) {\n                    lastOne = true;\n                }\n            }\n        }\n    }\n\n    \n\n    \n    @SuppressWarnings(\"unchecked\") \n    private void readObject(final ObjectInputStream stream) throws IOException, ClassNotFoundException {\n        stream.defaultReadObject();\n        root = new TrieEntry<K, V>(null, null, -1);\n        int size = stream.readInt();\n        for(int i = 0; i < size; i++){\n            K k = (K) stream.readObject();\n            V v = (V) stream.readObject();\n            put(k, v);\n        }\n    }\n\n    \n    private void writeObject(final ObjectOutputStream stream) throws IOException {\n        stream.defaultWriteObject();\n        stream.writeInt(this.size());\n        for (final Entry<K, V> entry : entrySet()) {\n            stream.writeObject(entry.getKey());\n            stream.writeObject(entry.getValue());\n        }\n    }\n\n}\n",
      "fixed_full_code": "\npackage org.apache.commons.collections4.trie;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.util.AbstractCollection;\nimport java.util.AbstractMap;\nimport java.util.AbstractSet;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.ConcurrentModificationException;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Set;\nimport java.util.SortedMap;\n\nimport org.apache.commons.collections4.OrderedMapIterator;\n\n\nabstract class AbstractPatriciaTrie<K, V> extends AbstractBitwiseTrie<K, V> { private static final long serialVersionUID = 5155253417231339498L; private transient TrieEntry<K, V> root = new TrieEntry<K, V>(null, null, -1); private transient volatile Set<K> keySet; private transient volatile Collection<V> values; private transient volatile Set<Map.Entry<K,V>> entrySet; private transient int size = 0; protected transient int modCount = 0; protected AbstractPatriciaTrie(final KeyAnalyzer<? super K> keyAnalyzer) {\n        super(keyAnalyzer);\n    }\n\n    \n    protected AbstractPatriciaTrie(final KeyAnalyzer<? super K> keyAnalyzer, final Map<? extends K, ? extends V> map) {\n        super(keyAnalyzer);\n        putAll(map);\n    }\n\n    \n    @Override\n    public void clear() {\n        root.key = null;\n        root.bitIndex = -1;\n        root.value = null;\n\n        root.parent = null;\n        root.left = root;\n        root.right = null;\n        root.predecessor = root;\n\n        size = 0;\n        incrementModCount();\n    }\n\n    @Override\n    public int size() {\n        return size;\n    }\n\n    \n    void incrementSize() {\n        size++;\n        incrementModCount();\n    }\n\n    \n    void decrementSize() {\n        size--;\n        incrementModCount();\n    }\n\n    \n    private void incrementModCount() {\n        ++modCount;\n    }\n\n    @Override\n    public V put(final K key, final V value) {\n        if (key == null) {\n            throw new NullPointerException(\"Key cannot be null\");\n        }\n\n        final int lengthInBits = lengthInBits(key);\n\n        \n        \n        if (lengthInBits == 0) {\n            if (root.isEmpty()) {\n                incrementSize();\n            } else {\n                incrementModCount();\n            }\n            return root.setKeyValue(key, value);\n        }\n\n        final TrieEntry<K, V> found = getNearestEntryForKey(key, lengthInBits);\n        if (compareKeys(key, found.key)) {\n            if (found.isEmpty()) { \n                incrementSize();\n            } else {\n                incrementModCount();\n            }\n            return found.setKeyValue(key, value);\n        }\n\n        final int bitIndex = bitIndex(key, found.key);\n        if (!KeyAnalyzer.isOutOfBoundsIndex(bitIndex)) {\n            if (KeyAnalyzer.isValidBitIndex(bitIndex)) { \n                \n                final TrieEntry<K, V> t = new TrieEntry<K, V>(key, value, bitIndex);\n                addEntry(t, lengthInBits);\n                incrementSize();\n                return null;\n            } else if (KeyAnalyzer.isNullBitKey(bitIndex)) {\n                \n                \n\n                \n                if (root.isEmpty()) {\n                    incrementSize();\n                } else {\n                    incrementModCount();\n                }\n                return root.setKeyValue(key, value);\n\n            } else if (KeyAnalyzer.isEqualBitKey(bitIndex)) {\n                \n\n                \n                if (found != root) {\n                    incrementModCount();\n                    return found.setKeyValue(key, value);\n                }\n            }\n        }\n\n        throw new IllegalArgumentException(\"Failed to put: \" + key + \" -> \" + value + \", \" + bitIndex);\n    }\n\n    \n    TrieEntry<K, V> addEntry(final TrieEntry<K, V> entry, final int lengthInBits) {\n        TrieEntry<K, V> current = root.left;\n        TrieEntry<K, V> path = root;\n        while(true) {\n            if (current.bitIndex >= entry.bitIndex\n                    || current.bitIndex <= path.bitIndex) {\n                entry.predecessor = entry;\n\n                if (!isBitSet(entry.key, entry.bitIndex, lengthInBits)) {\n                    entry.left = entry;\n                    entry.right = current;\n                } else {\n                    entry.left = current;\n                    entry.right = entry;\n                }\n\n                entry.parent = path;\n                if (current.bitIndex >= entry.bitIndex) {\n                    current.parent = entry;\n                }\n\n                \n                if (current.bitIndex <= path.bitIndex) {\n                    current.predecessor = entry;\n                }\n\n                if (path == root || !isBitSet(entry.key, path.bitIndex, lengthInBits)) {\n                    path.left = entry;\n                } else {\n                    path.right = entry;\n                }\n\n                return entry;\n            }\n\n            path = current;\n\n            if (!isBitSet(entry.key, current.bitIndex, lengthInBits)) {\n                current = current.left;\n            } else {\n                current = current.right;\n            }\n        }\n    }\n\n    @Override\n    public V get(final Object k) {\n        final TrieEntry<K, V> entry = getEntry(k);\n        return entry != null ? entry.getValue() : null;\n    }\n\n    \n    TrieEntry<K,V> getEntry(final Object k) {\n        final K key = castKey(k);\n        if (key == null) {\n            return null;\n        }\n\n        final int lengthInBits = lengthInBits(key);\n        final TrieEntry<K,V> entry = getNearestEntryForKey(key, lengthInBits);\n        return !entry.isEmpty() && compareKeys(key, entry.key) ? entry : null;\n    }\n\n    \n    public Map.Entry<K, V> select(final K key) {\n        final int lengthInBits = lengthInBits(key);\n        final Reference<Map.Entry<K, V>> reference = new Reference<Map.Entry<K,V>>();\n        if (!selectR(root.left, -1, key, lengthInBits, reference)) {\n            return reference.get();\n        }\n        return null;\n    }\n\n    \n    public K selectKey(final K key) {\n        final Map.Entry<K, V> entry = select(key);\n        if (entry == null) {\n            return null;\n        }\n        return entry.getKey();\n    }\n\n    \n    public V selectValue(final K key) {\n        final Map.Entry<K, V> entry = select(key);\n        if (entry == null) {\n            return null;\n        }\n        return entry.getValue();\n    }\n\n    \n    private boolean selectR(final TrieEntry<K, V> h, final int bitIndex, final K key, final int lengthInBits, final Reference<Map.Entry<K, V>> reference) {\n\n        if (h.bitIndex <= bitIndex) {\n            \n            \n            \n            if (!h.isEmpty()) {\n                reference.set(h);\n                return false;\n            }\n            return true;\n        }\n\n        if (!isBitSet(key, h.bitIndex, lengthInBits)) {\n            if (selectR(h.left, h.bitIndex, key, lengthInBits, reference)) {\n                return selectR(h.right, h.bitIndex, key, lengthInBits, reference);\n            }\n        } else {\n            if (selectR(h.right, h.bitIndex, key, lengthInBits, reference)) {\n                return selectR(h.left, h.bitIndex, key, lengthInBits, reference);\n            }\n        }\n        return false;\n    }\n\n    @Override\n    public boolean containsKey(final Object k) {\n        if (k == null) {\n            return false;\n        }\n\n        final K key = castKey(k);\n        final int lengthInBits = lengthInBits(key);\n        final TrieEntry<K, V> entry = getNearestEntryForKey(key, lengthInBits);\n        return !entry.isEmpty() && compareKeys(key, entry.key);\n    }\n\n    @Override\n    public Set<Map.Entry<K,V>> entrySet() {\n        if (entrySet == null) {\n            entrySet = new EntrySet();\n        }\n        return entrySet;\n    }\n\n    @Override\n    public Set<K> keySet() {\n        if (keySet == null) {\n            keySet = new KeySet();\n        }\n        return keySet;\n    }\n\n    @Override\n    public Collection<V> values() {\n        if (values == null) {\n            values = new Values();\n        }\n        return values;\n    }\n\n    \n    @Override\n    public V remove(final Object k) {\n        if (k == null) {\n            return null;\n        }\n\n        final K key = castKey(k);\n        final int lengthInBits = lengthInBits(key);\n        TrieEntry<K, V> current = root.left;\n        TrieEntry<K, V> path = root;\n        while (true) {\n            if (current.bitIndex <= path.bitIndex) {\n                if (!current.isEmpty() && compareKeys(key, current.key)) {\n                    return removeEntry(current);\n                }\n                return null;\n            }\n\n            path = current;\n\n            if (!isBitSet(key, current.bitIndex, lengthInBits)) {\n                current = current.left;\n            } else {\n                current = current.right;\n            }\n        }\n    }\n\n    \n    TrieEntry<K, V> getNearestEntryForKey(final K key, final int lengthInBits) {\n        TrieEntry<K, V> current = root.left;\n        TrieEntry<K, V> path = root;\n        while(true) {\n            if (current.bitIndex <= path.bitIndex) {\n                return current;\n            }\n\n            path = current;\n            if (!isBitSet(key, current.bitIndex, lengthInBits)) {\n                current = current.left;\n            } else {\n                current = current.right;\n            }\n        }\n    }\n\n    \n    V removeEntry(final TrieEntry<K, V> h) {\n        if (h != root) {\n            if (h.isInternalNode()) {\n                removeInternalEntry(h);\n            } else {\n                removeExternalEntry(h);\n            }\n        }\n\n        decrementSize();\n        return h.setKeyValue(null, null);\n    }\n\n    \n    private void removeExternalEntry(final TrieEntry<K, V> h) {\n        if (h == root) {\n            throw new IllegalArgumentException(\"Cannot delete root Entry!\");\n        } else if (!h.isExternalNode()) {\n            throw new IllegalArgumentException(h + \" is not an external Entry!\");\n        }\n\n        final TrieEntry<K, V> parent = h.parent;\n        final TrieEntry<K, V> child = h.left == h ? h.right : h.left;\n\n        if (parent.left == h) {\n            parent.left = child;\n        } else {\n            parent.right = child;\n        }\n\n        \n        if (child.bitIndex > parent.bitIndex) {\n            child.parent = parent;\n        } else {\n            child.predecessor = parent;\n        }\n\n    }\n\n    \n    private void removeInternalEntry(final TrieEntry<K, V> h) {\n        if (h == root) {\n            throw new IllegalArgumentException(\"Cannot delete root Entry!\");\n        } else if (!h.isInternalNode()) {\n            throw new IllegalArgumentException(h + \" is not an internal Entry!\");\n        }\n\n        final TrieEntry<K, V> p = h.predecessor;\n\n        \n        p.bitIndex = h.bitIndex;\n\n        \n        {\n            final TrieEntry<K, V> parent = p.parent;\n            final TrieEntry<K, V> child = p.left == h ? p.right : p.left;\n\n            \n            \n            \n            \n            \n            \n            if (p.predecessor == p && p.parent != h) {\n                p.predecessor = p.parent;\n            }\n\n            if (parent.left == p) {\n                parent.left = child;\n            } else {\n                parent.right = child;\n            }\n\n            if (child.bitIndex > parent.bitIndex) {\n                child.parent = parent;\n            }\n        }\n\n        \n        {\n            \n            \n            if (h.left.parent == h) {\n                h.left.parent = p;\n            }\n\n            if (h.right.parent == h) {\n                h.right.parent = p;\n            }\n\n            \n            if (h.parent.left == h) {\n                h.parent.left = p;\n            } else {\n                h.parent.right = p;\n            }\n        }\n\n        \n        \n        p.parent = h.parent;\n        p.left = h.left;\n        p.right = h.right;\n\n        \n        \n        if (isValidUplink(p.left, p)) {\n            p.left.predecessor = p;\n        }\n\n        if (isValidUplink(p.right, p)) {\n            p.right.predecessor = p;\n        }\n    }\n\n    \n    TrieEntry<K, V> nextEntry(final TrieEntry<K, V> node) {\n        if (node == null) {\n            return firstEntry();\n        }\n        return nextEntryImpl(node.predecessor, node, null);\n    }\n\n    \n    TrieEntry<K, V> nextEntryImpl(final TrieEntry<K, V> start,\n            final TrieEntry<K, V> previous, final TrieEntry<K, V> tree) {\n\n        TrieEntry<K, V> current = start;\n\n        \n        \n        \n        if (previous == null || start != previous.predecessor) {\n            while (!current.left.isEmpty()) {\n                \n                \n                if (previous == current.left) {\n                    break;\n                }\n\n                if (isValidUplink(current.left, current)) {\n                    return current.left;\n                }\n\n                current = current.left;\n            }\n        }\n\n        \n        if (current.isEmpty()) {\n            return null;\n        }\n\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        if (current.right == null) {\n            return null;\n        }\n\n        \n        if (previous != current.right) {\n            \n            if (isValidUplink(current.right, current)) {\n                return current.right;\n            }\n\n            \n            return nextEntryImpl(current.right, previous, tree);\n        }\n\n        \n        \n        while (current == current.parent.right) {\n            \n            if (current == tree) {\n                return null;\n            }\n\n            current = current.parent;\n        }\n\n        \n        if (current == tree) {\n            return null;\n        }\n\n        \n        if (current.parent.right == null) {\n            return null;\n        }\n\n        \n        if (previous != current.parent.right\n                && isValidUplink(current.parent.right, current.parent)) {\n            return current.parent.right;\n        }\n\n        \n        if (current.parent.right == current.parent) {\n            return null;\n        }\n\n        \n        return nextEntryImpl(current.parent.right, previous, tree);\n    }\n\n    \n    TrieEntry<K, V> firstEntry() {\n        \n        if (isEmpty()) {\n            return null;\n        }\n\n        return followLeft(root);\n    }\n\n    \n    TrieEntry<K, V> followLeft(TrieEntry<K, V> node) {\n        while(true) {\n            TrieEntry<K, V> child = node.left;\n            \n            if (child.isEmpty()) {\n                child = node.right;\n            }\n\n            if (child.bitIndex <= node.bitIndex) {\n                return child;\n            }\n\n            node = child;\n        }\n    }\n\n    \n\n    @Override\n    public Comparator<? super K> comparator() {\n        return getKeyAnalyzer();\n    }\n\n    @Override\n    public K firstKey() {\n        if (size() == 0) {\n            throw new NoSuchElementException();\n        }\n        return firstEntry().getKey();\n    }\n\n    @Override\n    public K lastKey() {\n        final TrieEntry<K, V> entry = lastEntry();\n        if (entry != null) {\n            return entry.getKey();\n        }\n        throw new NoSuchElementException();\n    }\n\n    @Override\n    public K nextKey(final K key) {\n        if (key == null) {\n            throw new NullPointerException();\n        }\n        final TrieEntry<K, V> entry = getEntry(key);\n        if (entry != null) {\n            final TrieEntry<K, V> nextEntry = nextEntry(entry);\n            return nextEntry != null ? nextEntry.getKey() : null;\n        }\n        return null;\n    }\n\n    @Override\n    public K previousKey(final K key) {\n        if (key == null) {\n            throw new NullPointerException();\n        }\n        final TrieEntry<K, V> entry = getEntry(key);\n        if (entry != null) {\n            final TrieEntry<K, V> prevEntry = previousEntry(entry);\n            return prevEntry != null ? prevEntry.getKey() : null;\n        }\n        return null;\n    }\n\n    @Override\n    public OrderedMapIterator<K, V> mapIterator() {\n        return new TrieMapIterator();\n    }\n\n    @Override\n    public SortedMap<K, V> prefixMap(final K key) {\n        return getPrefixMapByBits(key, 0, lengthInBits(key));\n    }\n\n    \n    private SortedMap<K, V> getPrefixMapByBits(final K key, final int offsetInBits, final int lengthInBits) {\n\n        final int offsetLength = offsetInBits + lengthInBits;\n        if (offsetLength > lengthInBits(key)) {\n            throw new IllegalArgumentException(offsetInBits + \" + \"\n                    + lengthInBits + \" > \" + lengthInBits(key));\n        }\n\n        if (offsetLength == 0) {\n            return this;\n        }\n\n        return new PrefixRangeMap(key, offsetInBits, lengthInBits);\n    }\n\n    @Override\n    public SortedMap<K, V> headMap(final K toKey) {\n        return new RangeEntryMap(null, toKey);\n    }\n\n    @Override\n    public SortedMap<K, V> subMap(final K fromKey, final K toKey) {\n        return new RangeEntryMap(fromKey, toKey);\n    }\n\n    @Override\n    public SortedMap<K, V> tailMap(final K fromKey) {\n        return new RangeEntryMap(fromKey, null);\n    }\n\n    \n    TrieEntry<K,V> higherEntry(final K key) {\n        \n        \n        \n        final int lengthInBits = lengthInBits(key);\n\n        if (lengthInBits == 0) {\n            if (!root.isEmpty()) {\n                \n                if (size() > 1) {\n                    return nextEntry(root);\n                }\n                \n                return null;\n            }\n            \n            return firstEntry();\n        }\n\n        final TrieEntry<K, V> found = getNearestEntryForKey(key, lengthInBits);\n        if (compareKeys(key, found.key)) {\n            return nextEntry(found);\n        }\n\n        final int bitIndex = bitIndex(key, found.key);\n        if (KeyAnalyzer.isValidBitIndex(bitIndex)) {\n            final TrieEntry<K, V> added = new TrieEntry<K, V>(key, null, bitIndex);\n            addEntry(added, lengthInBits);\n            incrementSize(); \n            final TrieEntry<K, V> ceil = nextEntry(added);\n            removeEntry(added);\n            modCount -= 2; \n            return ceil;\n        } else if (KeyAnalyzer.isNullBitKey(bitIndex)) {\n            if (!root.isEmpty()) {\n                return firstEntry();\n            } else if (size() > 1) {\n                return nextEntry(firstEntry());\n            } else {\n                return null;\n            }\n        } else if (KeyAnalyzer.isEqualBitKey(bitIndex)) {\n            return nextEntry(found);\n        }\n\n        \n        throw new IllegalStateException(\"invalid lookup: \" + key);\n    }\n\n    \n    TrieEntry<K,V> ceilingEntry(final K key) {\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n\n        \n        \n        \n        final int lengthInBits = lengthInBits(key);\n\n        if (lengthInBits == 0) {\n            if (!root.isEmpty()) {\n                return root;\n            }\n            return firstEntry();\n        }\n\n        final TrieEntry<K, V> found = getNearestEntryForKey(key, lengthInBits);\n        if (compareKeys(key, found.key)) {\n            return found;\n        }\n\n        final int bitIndex = bitIndex(key, found.key);\n        if (KeyAnalyzer.isValidBitIndex(bitIndex)) {\n            final TrieEntry<K, V> added = new TrieEntry<K, V>(key, null, bitIndex);\n            addEntry(added, lengthInBits);\n            incrementSize(); \n            final TrieEntry<K, V> ceil = nextEntry(added);\n            removeEntry(added);\n            modCount -= 2; \n            return ceil;\n        } else if (KeyAnalyzer.isNullBitKey(bitIndex)) {\n            if (!root.isEmpty()) {\n                return root;\n            }\n            return firstEntry();\n        } else if (KeyAnalyzer.isEqualBitKey(bitIndex)) {\n            return found;\n        }\n\n        \n        throw new IllegalStateException(\"invalid lookup: \" + key);\n    }\n\n    \n    TrieEntry<K,V> lowerEntry(final K key) {\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n\n        \n        \n        \n        final int lengthInBits = lengthInBits(key);\n\n        if (lengthInBits == 0) {\n            return null; \n        }\n\n        final TrieEntry<K, V> found = getNearestEntryForKey(key, lengthInBits);\n        if (compareKeys(key, found.key)) {\n            return previousEntry(found);\n        }\n\n        final int bitIndex = bitIndex(key, found.key);\n        if (KeyAnalyzer.isValidBitIndex(bitIndex)) {\n            final TrieEntry<K, V> added = new TrieEntry<K, V>(key, null, bitIndex);\n            addEntry(added, lengthInBits);\n            incrementSize(); \n            final TrieEntry<K, V> prior = previousEntry(added);\n            removeEntry(added);\n            modCount -= 2; \n            return prior;\n        } else if (KeyAnalyzer.isNullBitKey(bitIndex)) {\n            return null;\n        } else if (KeyAnalyzer.isEqualBitKey(bitIndex)) {\n            return previousEntry(found);\n        }\n\n        \n        throw new IllegalStateException(\"invalid lookup: \" + key);\n    }\n\n    \n    TrieEntry<K,V> floorEntry(final K key) {\n        \n        \n        \n        final int lengthInBits = lengthInBits(key);\n\n        if (lengthInBits == 0) {\n            if (!root.isEmpty()) {\n                return root;\n            }\n            return null;\n        }\n\n        final TrieEntry<K, V> found = getNearestEntryForKey(key, lengthInBits);\n        if (compareKeys(key, found.key)) {\n            return found;\n        }\n\n        final int bitIndex = bitIndex(key, found.key);\n        if (KeyAnalyzer.isValidBitIndex(bitIndex)) {\n            final TrieEntry<K, V> added = new TrieEntry<K, V>(key, null, bitIndex);\n            addEntry(added, lengthInBits);\n            incrementSize(); \n            final TrieEntry<K, V> floor = previousEntry(added);\n            removeEntry(added);\n            modCount -= 2; \n            return floor;\n        } else if (KeyAnalyzer.isNullBitKey(bitIndex)) {\n            if (!root.isEmpty()) {\n                return root;\n            }\n            return null;\n        } else if (KeyAnalyzer.isEqualBitKey(bitIndex)) {\n            return found;\n        }\n\n        \n        throw new IllegalStateException(\"invalid lookup: \" + key);\n    }\n\n    \n    TrieEntry<K, V> subtree(final K prefix, final int offsetInBits, final int lengthInBits) {\n        TrieEntry<K, V> current = root.left;\n        TrieEntry<K, V> path = root;\n        while(true) {\n            if (current.bitIndex <= path.bitIndex || lengthInBits <= current.bitIndex) {\n                break;\n            }\n\n            path = current;\n            if (!isBitSet(prefix, offsetInBits + current.bitIndex, offsetInBits + lengthInBits)) {\n                current = current.left;\n            } else {\n                current = current.right;\n            }\n        }\n\n        \n        final TrieEntry<K, V> entry = current.isEmpty() ? path : current;\n\n        \n        if (entry.isEmpty()) {\n            return null;\n        }\n\n        final int endIndexInBits = offsetInBits + lengthInBits;\n\n        \n        \n        \n        \n        if (entry == root && lengthInBits(entry.getKey()) < endIndexInBits) {\n            return null;\n        }\n\n        \n        \n        if (isBitSet(prefix, endIndexInBits - 1, endIndexInBits)\n                != isBitSet(entry.key, lengthInBits - 1, lengthInBits(entry.key))) {\n            return null;\n        }\n\n        \n        final int bitIndex = getKeyAnalyzer().bitIndex(prefix, offsetInBits, lengthInBits,\n                                                       entry.key, 0, lengthInBits(entry.getKey()));\n\n        if (bitIndex >= 0 && bitIndex < lengthInBits) {\n            return null;\n        }\n\n        return entry;\n    }\n\n    \n    TrieEntry<K, V> lastEntry() {\n        return followRight(root.left);\n    }\n\n    \n    TrieEntry<K, V> followRight(TrieEntry<K, V> node) {\n        \n        if (node.right == null) {\n            return null;\n        }\n\n        \n        while (node.right.bitIndex > node.bitIndex) {\n            node = node.right;\n        }\n\n        return node.right;\n    }\n\n    \n    TrieEntry<K, V> previousEntry(final TrieEntry<K, V> start) {\n        if (start.predecessor == null) {\n            throw new IllegalArgumentException(\"must have come from somewhere!\");\n        }\n\n        if (start.predecessor.right == start) {\n            if (isValidUplink(start.predecessor.left, start.predecessor)) {\n                return start.predecessor.left;\n            }\n            return followRight(start.predecessor.left);\n        }\n        TrieEntry<K, V> node = start.predecessor;\n        while (node.parent != null && node == node.parent.left) {\n            node = node.parent;\n        }\n\n        if (node.parent == null) { \n            return null;\n        }\n\n        if (isValidUplink(node.parent.left, node.parent)) {\n            if (node.parent.left == root) {\n                if (root.isEmpty()) {\n                    return null;\n                }\n                return root;\n\n            }\n            return node.parent.left;\n        }\n        return followRight(node.parent.left);\n    }\n\n    \n    TrieEntry<K, V> nextEntryInSubtree(final TrieEntry<K, V> node,\n            final TrieEntry<K, V> parentOfSubtree) {\n        if (node == null) {\n            return firstEntry();\n        }\n        return nextEntryImpl(node.predecessor, node, parentOfSubtree);\n    }\n\n    \n    static boolean isValidUplink(final TrieEntry<?, ?> next, final TrieEntry<?, ?> from) {\n        return next != null && next.bitIndex <= from.bitIndex && !next.isEmpty();\n    }\n\n    \n    private static class Reference<E> { private E item; public void set(final E item) {\n            this.item = item;\n        }\n\n        public E get() {\n            return item;\n        }\n    }\n\n    \n    protected static class TrieEntry<K,V> extends BasicEntry<K, V> { private static final long serialVersionUID = 4596023148184140013L; protected int bitIndex; protected TrieEntry<K,V> parent; protected TrieEntry<K,V> left; protected TrieEntry<K,V> right; protected TrieEntry<K,V> predecessor; public TrieEntry(final K key, final V value, final int bitIndex) {\n            super(key, value);\n\n            this.bitIndex = bitIndex;\n\n            this.parent = null;\n            this.left = this;\n            this.right = null;\n            this.predecessor = this;\n        }\n\n        \n        public boolean isEmpty() {\n            return key == null;\n        }\n\n        \n        public boolean isInternalNode() {\n            return left != this && right != this;\n        }\n\n        \n        public boolean isExternalNode() {\n            return !isInternalNode();\n        }\n\n        @Override\n        public String toString() {\n            final StringBuilder buffer = new StringBuilder();\n\n            if (bitIndex == -1) {\n                buffer.append(\"RootEntry(\");\n            } else {\n                buffer.append(\"Entry(\");\n            }\n\n            buffer.append(\"key=\").append(getKey()).append(\" [\").append(bitIndex).append(\"], \");\n            buffer.append(\"value=\").append(getValue()).append(\", \");\n            \n\n            if (parent != null) {\n                if (parent.bitIndex == -1) {\n                    buffer.append(\"parent=\").append(\"ROOT\");\n                } else {\n                    buffer.append(\"parent=\").append(parent.getKey()).append(\" [\").append(parent.bitIndex).append(\"]\");\n                }\n            } else {\n                buffer.append(\"parent=\").append(\"null\");\n            }\n            buffer.append(\", \");\n\n            if (left != null) {\n                if (left.bitIndex == -1) {\n                    buffer.append(\"left=\").append(\"ROOT\");\n                } else {\n                    buffer.append(\"left=\").append(left.getKey()).append(\" [\").append(left.bitIndex).append(\"]\");\n                }\n            } else {\n                buffer.append(\"left=\").append(\"null\");\n            }\n            buffer.append(\", \");\n\n            if (right != null) {\n                if (right.bitIndex == -1) {\n                    buffer.append(\"right=\").append(\"ROOT\");\n                } else {\n                    buffer.append(\"right=\").append(right.getKey()).append(\" [\").append(right.bitIndex).append(\"]\");\n                }\n            } else {\n                buffer.append(\"right=\").append(\"null\");\n            }\n            buffer.append(\", \");\n\n            if (predecessor != null) {\n                if(predecessor.bitIndex == -1) {\n                    buffer.append(\"predecessor=\").append(\"ROOT\");\n                } else {\n                    buffer.append(\"predecessor=\").append(predecessor.getKey()).append(\" [\").\n                           append(predecessor.bitIndex).append(\"]\");\n                }\n            }\n\n            buffer.append(\")\");\n            return buffer.toString();\n        }\n    }\n\n\n    \n    private class EntrySet extends AbstractSet<Map.Entry<K,V>> { @Override public Iterator<Map.Entry<K,V>> iterator() {\n            return new EntryIterator();\n        }\n\n        @Override\n        public boolean contains(final Object o) {\n            if (!(o instanceof Map.Entry)) {\n                return false;\n            }\n\n            final TrieEntry<K,V> candidate = getEntry(((Map.Entry<?, ?>)o).getKey());\n            return candidate != null && candidate.equals(o);\n        }\n\n        @Override\n        public boolean remove(final Object obj) {\n            if (obj instanceof Map.Entry == false) {\n                return false;\n            }\n            if (contains(obj) == false) {\n                return false;\n            }\n            final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n            AbstractPatriciaTrie.this.remove(entry.getKey());\n            return true;\n        }\n\n        @Override\n        public int size() {\n            return AbstractPatriciaTrie.this.size();\n        }\n\n        @Override\n        public void clear() {\n            AbstractPatriciaTrie.this.clear();\n        }\n\n        \n        private class EntryIterator extends TrieIterator<Map.Entry<K,V>> { @Override public Map.Entry<K,V> next() {\n                return nextEntry();\n            }\n        }\n    }\n\n    \n    private class KeySet extends AbstractSet<K> { @Override public Iterator<K> iterator() {\n            return new KeyIterator();\n        }\n\n        @Override\n        public int size() {\n            return AbstractPatriciaTrie.this.size();\n        }\n\n        @Override\n        public boolean contains(final Object o) {\n            return containsKey(o);\n        }\n\n        @Override\n        public boolean remove(final Object o) {\n            final int size = size();\n            AbstractPatriciaTrie.this.remove(o);\n            return size != size();\n        }\n\n        @Override\n        public void clear() {\n            AbstractPatriciaTrie.this.clear();\n        }\n\n        \n        private class KeyIterator extends TrieIterator<K> { @Override public K next() {\n                return nextEntry().getKey();\n            }\n        }\n    }\n\n    \n    private class Values extends AbstractCollection<V> { @Override public Iterator<V> iterator() {\n            return new ValueIterator();\n        }\n\n        @Override\n        public int size() {\n            return AbstractPatriciaTrie.this.size();\n        }\n\n        @Override\n        public boolean contains(final Object o) {\n            return containsValue(o);\n        }\n\n        @Override\n        public void clear() {\n            AbstractPatriciaTrie.this.clear();\n        }\n\n        @Override\n        public boolean remove(final Object o) {\n            for (final Iterator<V> it = iterator(); it.hasNext(); ) {\n                final V value = it.next();\n                if (compare(value, o)) {\n                    it.remove();\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        \n        private class ValueIterator extends TrieIterator<V> { @Override public V next() {\n                return nextEntry().getValue();\n            }\n        }\n    }\n\n    \n    abstract class TrieIterator<E> implements Iterator<E> { protected int expectedModCount = AbstractPatriciaTrie.this.modCount; protected TrieEntry<K, V> next; protected TrieEntry<K, V> current; protected TrieIterator() {\n            next = AbstractPatriciaTrie.this.nextEntry(null);\n        }\n\n        \n        protected TrieIterator(final TrieEntry<K, V> firstEntry) {\n            next = firstEntry;\n        }\n\n        \n        protected TrieEntry<K,V> nextEntry() {\n            if (expectedModCount != AbstractPatriciaTrie.this.modCount) {\n                throw new ConcurrentModificationException();\n            }\n\n            final TrieEntry<K,V> e = next;\n            if (e == null) {\n                throw new NoSuchElementException();\n            }\n\n            next = findNext(e);\n            current = e;\n            return e;\n        }\n\n        \n        protected TrieEntry<K, V> findNext(final TrieEntry<K, V> prior) {\n            return AbstractPatriciaTrie.this.nextEntry(prior);\n        }\n\n        @Override\n        public boolean hasNext() {\n            return next != null;\n        }\n\n        @Override\n        public void remove() {\n            if (current == null) {\n                throw new IllegalStateException();\n            }\n\n            if (expectedModCount != AbstractPatriciaTrie.this.modCount) {\n                throw new ConcurrentModificationException();\n            }\n\n            final TrieEntry<K, V> node = current;\n            current = null;\n            AbstractPatriciaTrie.this.removeEntry(node);\n\n            expectedModCount = AbstractPatriciaTrie.this.modCount;\n        }\n    }\n\n    \n    private class TrieMapIterator extends TrieIterator<K> implements OrderedMapIterator<K, V> { protected TrieEntry<K, V> previous; @Override public K next() {\n            return nextEntry().getKey();\n        }\n\n        @Override\n        public K getKey() {\n            if (current == null) {\n                throw new IllegalStateException();\n            }\n            return current.getKey();\n        }\n\n        @Override\n        public V getValue() {\n            if (current == null) {\n                throw new IllegalStateException();\n            }\n            return current.getValue();\n        }\n\n        @Override\n        public V setValue(final V value) {\n            if (current == null) {\n                throw new IllegalStateException();\n            }\n            return current.setValue(value);\n        }\n\n        @Override\n        public boolean hasPrevious() {\n            return previous != null;\n        }\n\n        @Override\n        public K previous() {\n            return previousEntry().getKey();\n        }\n\n        @Override\n        protected TrieEntry<K, V> nextEntry() {\n            final TrieEntry<K, V> nextEntry = super.nextEntry();\n            previous = nextEntry;\n            return nextEntry;\n        }\n\n        protected TrieEntry<K,V> previousEntry() {\n            if (expectedModCount != AbstractPatriciaTrie.this.modCount) {\n                throw new ConcurrentModificationException();\n            }\n\n            final TrieEntry<K,V> e = previous;\n            if (e == null) {\n                throw new NoSuchElementException();\n            }\n\n            previous = AbstractPatriciaTrie.this.previousEntry(e);\n            next = current;\n            current = e;\n            return current;\n        }\n\n    }\n\n    \n    private abstract class RangeMap extends AbstractMap<K, V> implements SortedMap<K, V> { private transient volatile Set<Map.Entry<K, V>> entrySet; protected abstract Set<Map.Entry<K, V>> createEntrySet(); protected abstract K getFromKey(); protected abstract boolean isFromInclusive(); protected abstract K getToKey(); protected abstract boolean isToInclusive(); @Override public Comparator<? super K> comparator() {\n            return AbstractPatriciaTrie.this.comparator();\n        }\n\n        @Override\n        public boolean containsKey(final Object key) {\n            if (!inRange(castKey(key))) {\n                return false;\n            }\n\n            return AbstractPatriciaTrie.this.containsKey(key);\n        }\n\n        @Override\n        public V remove(final Object key) {\n            if (!inRange(castKey(key))) {\n                return null;\n            }\n\n            return AbstractPatriciaTrie.this.remove(key);\n        }\n\n        @Override\n        public V get(final Object key) {\n            if (!inRange(castKey(key))) {\n                return null;\n            }\n\n            return AbstractPatriciaTrie.this.get(key);\n        }\n\n        @Override\n        public V put(final K key, final V value) {\n            if (!inRange(key)) {\n                throw new IllegalArgumentException(\"Key is out of range: \" + key);\n            }\n            return AbstractPatriciaTrie.this.put(key, value);\n        }\n\n        @Override\n        public Set<Map.Entry<K, V>> entrySet() {\n            if (entrySet == null) {\n                entrySet = createEntrySet();\n            }\n            return entrySet;\n        }\n\n        @Override\n        public SortedMap<K, V> subMap(final K fromKey, final K toKey) {\n            if (!inRange2(fromKey)) {\n                throw new IllegalArgumentException(\"FromKey is out of range: \" + fromKey);\n            }\n\n            if (!inRange2(toKey)) {\n                throw new IllegalArgumentException(\"ToKey is out of range: \" + toKey);\n            }\n\n            return createRangeMap(fromKey, isFromInclusive(), toKey, isToInclusive());\n        }\n\n        @Override\n        public SortedMap<K, V> headMap(final K toKey) {\n            if (!inRange2(toKey)) {\n                throw new IllegalArgumentException(\"ToKey is out of range: \" + toKey);\n            }\n            return createRangeMap(getFromKey(), isFromInclusive(), toKey, isToInclusive());\n        }\n\n        @Override\n        public SortedMap<K, V> tailMap(final K fromKey) {\n            if (!inRange2(fromKey)) {\n                throw new IllegalArgumentException(\"FromKey is out of range: \" + fromKey);\n            }\n            return createRangeMap(fromKey, isFromInclusive(), getToKey(), isToInclusive());\n        }\n\n        \n        protected boolean inRange(final K key) {\n            final K fromKey = getFromKey();\n            final K toKey = getToKey();\n\n            return (fromKey == null || inFromRange(key, false)) && (toKey == null || inToRange(key, false));\n        }\n\n        \n        protected boolean inRange2(final K key) {\n            final K fromKey = getFromKey();\n            final K toKey = getToKey();\n\n            return (fromKey == null || inFromRange(key, false)) && (toKey == null || inToRange(key, true));\n        }\n\n        \n        protected boolean inFromRange(final K key, final boolean forceInclusive) {\n            final K fromKey = getFromKey();\n            final boolean fromInclusive = isFromInclusive();\n\n            final int ret = getKeyAnalyzer().compare(key, fromKey);\n            if (fromInclusive || forceInclusive) {\n                return ret >= 0;\n            }\n            return ret > 0;\n        }\n\n        \n        protected boolean inToRange(final K key, final boolean forceInclusive) {\n            final K toKey = getToKey();\n            final boolean toInclusive = isToInclusive();\n\n            final int ret = getKeyAnalyzer().compare(key, toKey);\n            if (toInclusive || forceInclusive) {\n                return ret <= 0;\n            }\n            return ret < 0;\n        }\n\n        \n        protected abstract SortedMap<K, V> createRangeMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive); } private class RangeEntryMap extends RangeMap {\n\n       \n       private final K fromKey; private final K toKey; private final boolean fromInclusive; private final boolean toInclusive; protected RangeEntryMap(final K fromKey, final K toKey) {\n           this(fromKey, true, toKey, false);\n       }\n\n       \n       protected RangeEntryMap(final K fromKey, final boolean fromInclusive, final K toKey, final boolean toInclusive) {\n\n           if (fromKey == null && toKey == null) {\n               throw new IllegalArgumentException(\"must have a from or to!\");\n           }\n\n           if (fromKey != null && toKey != null && getKeyAnalyzer().compare(fromKey, toKey) > 0) {\n               throw new IllegalArgumentException(\"fromKey > toKey\");\n           }\n\n           this.fromKey = fromKey;\n           this.fromInclusive = fromInclusive;\n           this.toKey = toKey;\n           this.toInclusive = toInclusive;\n       }\n\n       @Override\n    public K firstKey() {\n           Map.Entry<K,V> e = null;\n           if (fromKey == null) {\n               e = firstEntry();\n           } else {\n               if (fromInclusive) {\n                   e = ceilingEntry(fromKey);\n               } else {\n                   e = higherEntry(fromKey);\n               }\n           }\n\n           final K first = e != null ? e.getKey() : null;\n           if (e == null || toKey != null && !inToRange(first, false)) {\n               throw new NoSuchElementException();\n           }\n           return first;\n       }\n\n       @Override\n    public K lastKey() {\n           Map.Entry<K,V> e;\n           if (toKey == null) {\n               e = lastEntry();\n           } else {\n               if (toInclusive) {\n                   e = floorEntry(toKey);\n               } else {\n                   e = lowerEntry(toKey);\n               }\n           }\n\n           final K last = e != null ? e.getKey() : null;\n           if (e == null || fromKey != null && !inFromRange(last, false)) {\n               throw new NoSuchElementException();\n           }\n           return last;\n       }\n\n       @Override\n       protected Set<Entry<K, V>> createEntrySet() {\n           return new RangeEntrySet(this);\n       }\n\n       @Override\n       public K getFromKey() {\n           return fromKey;\n       }\n\n       @Override\n       public K getToKey() {\n           return toKey;\n       }\n\n       @Override\n       public boolean isFromInclusive() {\n           return fromInclusive;\n       }\n\n       @Override\n       public boolean isToInclusive() {\n           return toInclusive;\n       }\n\n       @Override\n       protected SortedMap<K, V> createRangeMap(final K fromKey, final boolean fromInclusive, final K toKey, final boolean toInclusive) {\n           return new RangeEntryMap(fromKey, fromInclusive, toKey, toInclusive);\n       }\n   }\n\n    \n    private class RangeEntrySet extends AbstractSet<Map.Entry<K, V>> { private final RangeMap delegate; private transient int size = -1; private transient int expectedModCount; public RangeEntrySet(final RangeMap delegate) {\n            if (delegate == null) {\n                throw new NullPointerException(\"delegate\");\n            }\n\n            this.delegate = delegate;\n        }\n\n        @Override\n        public Iterator<Map.Entry<K, V>> iterator() {\n            final K fromKey = delegate.getFromKey();\n            final K toKey = delegate.getToKey();\n\n            TrieEntry<K, V> first = null;\n            if (fromKey == null) {\n                first = firstEntry();\n            } else {\n                first = ceilingEntry(fromKey);\n            }\n\n            TrieEntry<K, V> last = null;\n            if (toKey != null) {\n                last = ceilingEntry(toKey);\n            }\n\n            return new EntryIterator(first, last);\n        }\n\n        @Override\n        public int size() {\n            if (size == -1 || expectedModCount != AbstractPatriciaTrie.this.modCount) {\n                size = 0;\n\n                for (final Iterator<?> it = iterator(); it.hasNext(); it.next()) {\n                    ++size;\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n            return size;\n        }\n\n        @Override\n        public boolean isEmpty() {\n            return !iterator().hasNext();\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        @Override\n        public boolean contains(final Object o) {\n            if (!(o instanceof Map.Entry)) {\n                return false;\n            }\n\n            final Map.Entry<K, V> entry = (Map.Entry<K, V>) o;\n            final K key = entry.getKey();\n            if (!delegate.inRange(key)) {\n                return false;\n            }\n\n            final TrieEntry<K, V> node = getEntry(key);\n            return node != null && compare(node.getValue(), entry.getValue());\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        @Override\n        public boolean remove(final Object o) {\n            if (!(o instanceof Map.Entry)) {\n                return false;\n            }\n\n            final Map.Entry<K, V> entry = (Map.Entry<K, V>) o;\n            final K key = entry.getKey();\n            if (!delegate.inRange(key)) {\n                return false;\n            }\n\n            final TrieEntry<K, V> node = getEntry(key);\n            if (node != null && compare(node.getValue(), entry.getValue())) {\n                removeEntry(node);\n                return true;\n            }\n            return false;\n        }\n\n        \n        private final class EntryIterator extends TrieIterator<Map.Entry<K,V>> { private final K excludedKey; private EntryIterator(final TrieEntry<K,V> first, final TrieEntry<K,V> last) {\n                super(first);\n                this.excludedKey = last != null ? last.getKey() : null;\n            }\n\n            @Override\n            public boolean hasNext() {\n                return next != null && !compare(next.key, excludedKey);\n            }\n\n            @Override\n            public Map.Entry<K,V> next() {\n                if (next == null || compare(next.key, excludedKey)) {\n                    throw new NoSuchElementException();\n                }\n                return nextEntry();\n            }\n        }\n    }\n\n    \n    private class PrefixRangeMap extends RangeMap { private final K prefix; private final int offsetInBits; private final int lengthInBits; private K fromKey = null; private K toKey = null; private transient int expectedModCount = 0; private int size = -1; private PrefixRangeMap(final K prefix, final int offsetInBits, final int lengthInBits) {\n            this.prefix = prefix;\n            this.offsetInBits = offsetInBits;\n            this.lengthInBits = lengthInBits;\n        }\n\n        \n        private int fixup() {\n            \n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\n                if (it.hasNext()) {\n                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }\n\n        @Override\n        public K firstKey() {\n            fixup();\n\n            Map.Entry<K,V> e = null;\n            if (fromKey == null) {\n                e = firstEntry();\n            } else {\n                e = higherEntry(fromKey);\n            }\n\n            final K first = e != null ? e.getKey() : null;\n            if (e == null || !getKeyAnalyzer().isPrefix(prefix, offsetInBits, lengthInBits, first)) {\n                throw new NoSuchElementException();\n            }\n\n            return first;\n        }\n\n        @Override\n        public K lastKey() {\n            fixup();\n\n            Map.Entry<K,V> e = null;\n            if (toKey == null) {\n                e = lastEntry();\n            } else {\n                e = lowerEntry(toKey);\n            }\n\n            final K last = e != null ? e.getKey() : null;\n            if (e == null || !getKeyAnalyzer().isPrefix(prefix, offsetInBits, lengthInBits, last)) {\n                throw new NoSuchElementException();\n            }\n\n            return last;\n        }\n\n        \n        @Override\n        protected boolean inRange(final K key) {\n            return getKeyAnalyzer().isPrefix(prefix, offsetInBits, lengthInBits, key);\n        }\n\n        \n        @Override\n        protected boolean inRange2(final K key) {\n            return inRange(key);\n        }\n\n        \n        @Override\n        protected boolean inFromRange(final K key, final boolean forceInclusive) {\n            return getKeyAnalyzer().isPrefix(prefix, offsetInBits, lengthInBits, key);\n        }\n\n        \n        @Override\n        protected boolean inToRange(final K key, final boolean forceInclusive) {\n            return getKeyAnalyzer().isPrefix(prefix, offsetInBits, lengthInBits, key);\n        }\n\n        @Override\n        protected Set<Map.Entry<K, V>> createEntrySet() {\n            return new PrefixRangeEntrySet(this);\n        }\n\n        @Override\n        public K getFromKey() {\n            return fromKey;\n        }\n\n        @Override\n        public K getToKey() {\n            return toKey;\n        }\n\n        @Override\n        public boolean isFromInclusive() {\n            return false;\n        }\n\n        @Override\n        public boolean isToInclusive() {\n            return false;\n        }\n\n        @Override\n        protected SortedMap<K, V> createRangeMap(final K fromKey, final boolean fromInclusive, final K toKey, final boolean toInclusive) {\n            return new RangeEntryMap(fromKey, fromInclusive, toKey, toInclusive);\n        }\n\n        @Override\n        public void clear() {\n            Iterator<Map.Entry<K, V>> it = AbstractPatriciaTrie.this.entrySet().iterator();\n            Set<K> currentKeys = keySet();\n            while (it.hasNext()) {\n                if (currentKeys.contains(it.next().getKey())) {\n                    it.remove();\n                }\n            }\n        }\n    }\n\n    \n    private final class PrefixRangeEntrySet extends RangeEntrySet { private final PrefixRangeMap delegate; private TrieEntry<K, V> prefixStart; private int expectedModCount = 0; public PrefixRangeEntrySet(final PrefixRangeMap delegate) {\n            super(delegate);\n            this.delegate = delegate;\n        }\n\n        @Override\n        public int size() {\n            return delegate.fixup();\n        }\n\n        @Override\n        public Iterator<Map.Entry<K,V>> iterator() {\n            if (AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                prefixStart = subtree(delegate.prefix, delegate.offsetInBits, delegate.lengthInBits);\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            if (prefixStart == null) {\n                final Set<Map.Entry<K,V>> empty = Collections.emptySet();\n                return empty.iterator();\n            } else if (delegate.lengthInBits > prefixStart.bitIndex) {\n                return new SingletonIterator(prefixStart);\n            } else {\n                return new EntryIterator(prefixStart, delegate.prefix, delegate.offsetInBits, delegate.lengthInBits);\n            }\n        }\n\n        \n        private final class SingletonIterator implements Iterator<Map.Entry<K, V>> { private final TrieEntry<K, V> entry; private int hit = 0; public SingletonIterator(final TrieEntry<K, V> entry) {\n                this.entry = entry;\n            }\n\n            @Override\n            public boolean hasNext() {\n                return hit == 0;\n            }\n\n            @Override\n            public Map.Entry<K, V> next() {\n                if (hit != 0) {\n                    throw new NoSuchElementException();\n                }\n\n                ++hit;\n                return entry;\n            }\n\n            @Override\n            public void remove() {\n                if (hit != 1) {\n                    throw new IllegalStateException();\n                }\n\n                ++hit;\n                AbstractPatriciaTrie.this.removeEntry(entry);\n            }\n        }\n\n        \n        private final class EntryIterator extends TrieIterator<Map.Entry<K, V>> { private final K prefix; private final int offset; private final int lengthInBits; private boolean lastOne; private TrieEntry<K, V> subtree; EntryIterator(final TrieEntry<K, V> startScan, final K prefix, final int offset, final int lengthInBits) {\n                subtree = startScan;\n                next = AbstractPatriciaTrie.this.followLeft(startScan);\n                this.prefix = prefix;\n                this.offset = offset;\n                this.lengthInBits = lengthInBits;\n            }\n\n            @Override\n            public Map.Entry<K,V> next() {\n                final Map.Entry<K, V> entry = nextEntry();\n                if (lastOne) {\n                    next = null;\n                }\n                return entry;\n            }\n\n            @Override\n            protected TrieEntry<K, V> findNext(final TrieEntry<K, V> prior) {\n                return AbstractPatriciaTrie.this.nextEntryInSubtree(prior, subtree);\n            }\n\n            @Override\n            public void remove() {\n                \n                \n                boolean needsFixing = false;\n                final int bitIdx = subtree.bitIndex;\n                if (current == subtree) {\n                    needsFixing = true;\n                }\n\n                super.remove();\n\n                \n                \n                if (bitIdx != subtree.bitIndex || needsFixing) {\n                    subtree = subtree(prefix, offset, lengthInBits);\n                }\n\n                \n                \n                \n                if (lengthInBits >= subtree.bitIndex) {\n                    lastOne = true;\n                }\n            }\n        }\n    }\n\n    \n\n    \n    @SuppressWarnings(\"unchecked\") \n    private void readObject(final ObjectInputStream stream) throws IOException, ClassNotFoundException {\n        stream.defaultReadObject();\n        root = new TrieEntry<K, V>(null, null, -1);\n        int size = stream.readInt();\n        for(int i = 0; i < size; i++){\n            K k = (K) stream.readObject();\n            V v = (V) stream.readObject();\n            put(k, v);\n        }\n    }\n\n    \n    private void writeObject(final ObjectOutputStream stream) throws IOException {\n        stream.defaultWriteObject();\n        stream.writeInt(this.size());\n        for (final Entry<K, V> entry : entrySet()) {\n            stream.writeObject(entry.getKey());\n            stream.writeObject(entry.getValue());\n        }\n    }\n\n}\n",
      "buggy_signatures": [
        "protected AbstractPatriciaTrie(final KeyAnalyzer<? super K> keyAnalyzer, final Map<? extends K, ? extends V> map)",
        "public void clear()",
        "public int size()",
        "private void incrementModCount()",
        "public V put(final K key, final V value)",
        "public V get(final Object k)",
        "public Map.Entry<K, V> select(final K key)",
        "public K selectKey(final K key)",
        "public V selectValue(final K key)",
        "private boolean selectR(final TrieEntry<K, V> h, final int bitIndex, final K key, final int lengthInBits, final Reference<Map.Entry<K, V>> reference)",
        "public boolean containsKey(final Object k)",
        "public Set<Map.Entry<K,V>> entrySet()",
        "public Set<K> keySet()",
        "public Collection<V> values()",
        "public V remove(final Object k)",
        "private void removeExternalEntry(final TrieEntry<K, V> h)",
        "private void removeInternalEntry(final TrieEntry<K, V> h)",
        "public Comparator<? super K> comparator()",
        "public K firstKey()",
        "public K lastKey()",
        "public K nextKey(final K key)",
        "public K previousKey(final K key)",
        "public OrderedMapIterator<K, V> mapIterator()",
        "public SortedMap<K, V> prefixMap(final K key)",
        "private SortedMap<K, V> getPrefixMapByBits(final K key, final int offsetInBits, final int lengthInBits)",
        "public SortedMap<K, V> headMap(final K toKey)",
        "public SortedMap<K, V> subMap(final K fromKey, final K toKey)",
        "public SortedMap<K, V> tailMap(final K fromKey)",
        "static boolean isValidUplink(final TrieEntry<?, ?> next, final TrieEntry<?, ?> from)",
        "private static class Reference<E> { private E item; public void set(final E item)",
        "public E get()",
        "public boolean isEmpty()",
        "public boolean isInternalNode()",
        "public boolean isExternalNode()",
        "public String toString()",
        "private class EntrySet extends AbstractSet<Map.Entry<K,V>> { @Override public Iterator<Map.Entry<K,V>> iterator()",
        "public boolean contains(final Object o)",
        "public boolean remove(final Object obj)",
        "public int size()",
        "public void clear()",
        "private class EntryIterator extends TrieIterator<Map.Entry<K,V>> { @Override public Map.Entry<K,V> next()",
        "private class KeySet extends AbstractSet<K> { @Override public Iterator<K> iterator()",
        "public int size()",
        "public boolean contains(final Object o)",
        "public boolean remove(final Object o)",
        "public void clear()",
        "private class KeyIterator extends TrieIterator<K> { @Override public K next()",
        "private class Values extends AbstractCollection<V> { @Override public Iterator<V> iterator()",
        "public int size()",
        "public boolean contains(final Object o)",
        "public void clear()",
        "public boolean remove(final Object o)",
        "private class ValueIterator extends TrieIterator<V> { @Override public V next()",
        "protected TrieIterator(final TrieEntry<K, V> firstEntry)",
        "protected TrieEntry<K,V> nextEntry()",
        "protected TrieEntry<K, V> findNext(final TrieEntry<K, V> prior)",
        "public boolean hasNext()",
        "public void remove()",
        "private class TrieMapIterator extends TrieIterator<K> implements OrderedMapIterator<K, V> { protected TrieEntry<K, V> previous; @Override public K next()",
        "public K getKey()",
        "public V getValue()",
        "public V setValue(final V value)",
        "public boolean hasPrevious()",
        "public K previous()",
        "protected TrieEntry<K, V> nextEntry()",
        "protected TrieEntry<K,V> previousEntry()",
        "private abstract class RangeMap extends AbstractMap<K, V> implements SortedMap<K, V> { private transient volatile Set<Map.Entry<K, V>> entrySet; protected abstract Set<Map.Entry<K, V>> createEntrySet(); protected abstract K getFromKey(); protected abstract boolean isFromInclusive(); protected abstract K getToKey(); protected abstract boolean isToInclusive(); @Override public Comparator<? super K> comparator()",
        "public boolean containsKey(final Object key)",
        "public V remove(final Object key)",
        "public V get(final Object key)",
        "public V put(final K key, final V value)",
        "public Set<Map.Entry<K, V>> entrySet()",
        "public SortedMap<K, V> subMap(final K fromKey, final K toKey)",
        "public SortedMap<K, V> headMap(final K toKey)",
        "public SortedMap<K, V> tailMap(final K fromKey)",
        "protected boolean inRange(final K key)",
        "protected boolean inRange2(final K key)",
        "protected boolean inFromRange(final K key, final boolean forceInclusive)",
        "protected boolean inToRange(final K key, final boolean forceInclusive)",
        "protected abstract SortedMap<K, V> createRangeMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive); } private class RangeEntryMap extends RangeMap",
        "private final K fromKey; private final K toKey; private final boolean fromInclusive; private final boolean toInclusive; protected RangeEntryMap(final K fromKey, final K toKey)",
        "protected RangeEntryMap(final K fromKey, final boolean fromInclusive, final K toKey, final boolean toInclusive)",
        "public K firstKey()",
        "public K lastKey()",
        "protected Set<Entry<K, V>> createEntrySet()",
        "public K getFromKey()",
        "public K getToKey()",
        "public boolean isFromInclusive()",
        "public boolean isToInclusive()",
        "protected SortedMap<K, V> createRangeMap(final K fromKey, final boolean fromInclusive, final K toKey, final boolean toInclusive)",
        "public Iterator<Map.Entry<K, V>> iterator()",
        "public int size()",
        "public boolean isEmpty()",
        "public boolean contains(final Object o)",
        "public boolean remove(final Object o)",
        "private final class EntryIterator extends TrieIterator<Map.Entry<K,V>> { private final K excludedKey; private EntryIterator(final TrieEntry<K,V> first, final TrieEntry<K,V> last)",
        "public boolean hasNext()",
        "public Map.Entry<K,V> next()",
        "private int fixup()",
        "public K firstKey()",
        "public K lastKey()",
        "protected boolean inRange(final K key)",
        "protected boolean inRange2(final K key)",
        "protected boolean inFromRange(final K key, final boolean forceInclusive)",
        "protected boolean inToRange(final K key, final boolean forceInclusive)",
        "protected Set<Map.Entry<K, V>> createEntrySet()",
        "public K getFromKey()",
        "public K getToKey()",
        "public boolean isFromInclusive()",
        "public boolean isToInclusive()",
        "protected SortedMap<K, V> createRangeMap(final K fromKey, final boolean fromInclusive, final K toKey, final boolean toInclusive)",
        "public int size()",
        "public Iterator<Map.Entry<K,V>> iterator()",
        "public boolean hasNext()",
        "public Map.Entry<K, V> next()",
        "public void remove()",
        "private final class EntryIterator extends TrieIterator<Map.Entry<K, V>> { private final K prefix; private final int offset; private final int lengthInBits; private boolean lastOne; private TrieEntry<K, V> subtree; EntryIterator(final TrieEntry<K, V> startScan, final K prefix, final int offset, final int lengthInBits)",
        "public Map.Entry<K,V> next()",
        "protected TrieEntry<K, V> findNext(final TrieEntry<K, V> prior)",
        "public void remove()",
        "private void readObject(final ObjectInputStream stream) throws IOException, ClassNotFoundException",
        "private void writeObject(final ObjectOutputStream stream) throws IOException"
      ],
      "fixed_signatures": [
        "protected AbstractPatriciaTrie(final KeyAnalyzer<? super K> keyAnalyzer, final Map<? extends K, ? extends V> map)",
        "public void clear()",
        "public int size()",
        "private void incrementModCount()",
        "public V put(final K key, final V value)",
        "public V get(final Object k)",
        "public Map.Entry<K, V> select(final K key)",
        "public K selectKey(final K key)",
        "public V selectValue(final K key)",
        "private boolean selectR(final TrieEntry<K, V> h, final int bitIndex, final K key, final int lengthInBits, final Reference<Map.Entry<K, V>> reference)",
        "public boolean containsKey(final Object k)",
        "public Set<Map.Entry<K,V>> entrySet()",
        "public Set<K> keySet()",
        "public Collection<V> values()",
        "public V remove(final Object k)",
        "private void removeExternalEntry(final TrieEntry<K, V> h)",
        "private void removeInternalEntry(final TrieEntry<K, V> h)",
        "public Comparator<? super K> comparator()",
        "public K firstKey()",
        "public K lastKey()",
        "public K nextKey(final K key)",
        "public K previousKey(final K key)",
        "public OrderedMapIterator<K, V> mapIterator()",
        "public SortedMap<K, V> prefixMap(final K key)",
        "private SortedMap<K, V> getPrefixMapByBits(final K key, final int offsetInBits, final int lengthInBits)",
        "public SortedMap<K, V> headMap(final K toKey)",
        "public SortedMap<K, V> subMap(final K fromKey, final K toKey)",
        "public SortedMap<K, V> tailMap(final K fromKey)",
        "static boolean isValidUplink(final TrieEntry<?, ?> next, final TrieEntry<?, ?> from)",
        "private static class Reference<E> { private E item; public void set(final E item)",
        "public E get()",
        "public boolean isEmpty()",
        "public boolean isInternalNode()",
        "public boolean isExternalNode()",
        "public String toString()",
        "private class EntrySet extends AbstractSet<Map.Entry<K,V>> { @Override public Iterator<Map.Entry<K,V>> iterator()",
        "public boolean contains(final Object o)",
        "public boolean remove(final Object obj)",
        "public int size()",
        "public void clear()",
        "private class EntryIterator extends TrieIterator<Map.Entry<K,V>> { @Override public Map.Entry<K,V> next()",
        "private class KeySet extends AbstractSet<K> { @Override public Iterator<K> iterator()",
        "public int size()",
        "public boolean contains(final Object o)",
        "public boolean remove(final Object o)",
        "public void clear()",
        "private class KeyIterator extends TrieIterator<K> { @Override public K next()",
        "private class Values extends AbstractCollection<V> { @Override public Iterator<V> iterator()",
        "public int size()",
        "public boolean contains(final Object o)",
        "public void clear()",
        "public boolean remove(final Object o)",
        "private class ValueIterator extends TrieIterator<V> { @Override public V next()",
        "protected TrieIterator(final TrieEntry<K, V> firstEntry)",
        "protected TrieEntry<K,V> nextEntry()",
        "protected TrieEntry<K, V> findNext(final TrieEntry<K, V> prior)",
        "public boolean hasNext()",
        "public void remove()",
        "private class TrieMapIterator extends TrieIterator<K> implements OrderedMapIterator<K, V> { protected TrieEntry<K, V> previous; @Override public K next()",
        "public K getKey()",
        "public V getValue()",
        "public V setValue(final V value)",
        "public boolean hasPrevious()",
        "public K previous()",
        "protected TrieEntry<K, V> nextEntry()",
        "protected TrieEntry<K,V> previousEntry()",
        "private abstract class RangeMap extends AbstractMap<K, V> implements SortedMap<K, V> { private transient volatile Set<Map.Entry<K, V>> entrySet; protected abstract Set<Map.Entry<K, V>> createEntrySet(); protected abstract K getFromKey(); protected abstract boolean isFromInclusive(); protected abstract K getToKey(); protected abstract boolean isToInclusive(); @Override public Comparator<? super K> comparator()",
        "public boolean containsKey(final Object key)",
        "public V remove(final Object key)",
        "public V get(final Object key)",
        "public V put(final K key, final V value)",
        "public Set<Map.Entry<K, V>> entrySet()",
        "public SortedMap<K, V> subMap(final K fromKey, final K toKey)",
        "public SortedMap<K, V> headMap(final K toKey)",
        "public SortedMap<K, V> tailMap(final K fromKey)",
        "protected boolean inRange(final K key)",
        "protected boolean inRange2(final K key)",
        "protected boolean inFromRange(final K key, final boolean forceInclusive)",
        "protected boolean inToRange(final K key, final boolean forceInclusive)",
        "protected abstract SortedMap<K, V> createRangeMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive); } private class RangeEntryMap extends RangeMap",
        "private final K fromKey; private final K toKey; private final boolean fromInclusive; private final boolean toInclusive; protected RangeEntryMap(final K fromKey, final K toKey)",
        "protected RangeEntryMap(final K fromKey, final boolean fromInclusive, final K toKey, final boolean toInclusive)",
        "public K firstKey()",
        "public K lastKey()",
        "protected Set<Entry<K, V>> createEntrySet()",
        "public K getFromKey()",
        "public K getToKey()",
        "public boolean isFromInclusive()",
        "public boolean isToInclusive()",
        "protected SortedMap<K, V> createRangeMap(final K fromKey, final boolean fromInclusive, final K toKey, final boolean toInclusive)",
        "public Iterator<Map.Entry<K, V>> iterator()",
        "public int size()",
        "public boolean isEmpty()",
        "public boolean contains(final Object o)",
        "public boolean remove(final Object o)",
        "private final class EntryIterator extends TrieIterator<Map.Entry<K,V>> { private final K excludedKey; private EntryIterator(final TrieEntry<K,V> first, final TrieEntry<K,V> last)",
        "public boolean hasNext()",
        "public Map.Entry<K,V> next()",
        "private int fixup()",
        "public K firstKey()",
        "public K lastKey()",
        "protected boolean inRange(final K key)",
        "protected boolean inRange2(final K key)",
        "protected boolean inFromRange(final K key, final boolean forceInclusive)",
        "protected boolean inToRange(final K key, final boolean forceInclusive)",
        "protected Set<Map.Entry<K, V>> createEntrySet()",
        "public K getFromKey()",
        "public K getToKey()",
        "public boolean isFromInclusive()",
        "public boolean isToInclusive()",
        "protected SortedMap<K, V> createRangeMap(final K fromKey, final boolean fromInclusive, final K toKey, final boolean toInclusive)",
        "public void clear()",
        "public int size()",
        "public Iterator<Map.Entry<K,V>> iterator()",
        "public boolean hasNext()",
        "public Map.Entry<K, V> next()",
        "public void remove()",
        "private final class EntryIterator extends TrieIterator<Map.Entry<K, V>> { private final K prefix; private final int offset; private final int lengthInBits; private boolean lastOne; private TrieEntry<K, V> subtree; EntryIterator(final TrieEntry<K, V> startScan, final K prefix, final int offset, final int lengthInBits)",
        "public Map.Entry<K,V> next()",
        "protected TrieEntry<K, V> findNext(final TrieEntry<K, V> prior)",
        "public void remove()",
        "private void readObject(final ObjectInputStream stream) throws IOException, ClassNotFoundException",
        "private void writeObject(final ObjectOutputStream stream) throws IOException"
      ],
      "methods": [
        {
          "buggy_method": "  protected SortedMap<K, V> createRangeMap(final K fromKey, final boolean fromInclusive, final K toKey, final boolean toInclusive) {\n  return new RangeEntryMap(fromKey, fromInclusive, toKey, toInclusive);\n  }",
          "fixed_method": "  public void clear() {\n  Iterator<Map.Entry<K, V>> it = AbstractPatriciaTrie.this.entrySet().iterator();\n  Set<K> currentKeys = keySet();\n  while (it.hasNext()) {\n  if (currentKeys.contains(it.next().getKey())) {\n  it.remove();\n  }\n  }\n  }",
          "diff": [
            "@@ -2259,6 +2259,16 @@",
            "             return new RangeEntryMap(fromKey, fromInclusive, toKey, toInclusive);\n",
            "         }\n",
            " \n",
            "+        @Override\n",
            "+        public void clear() {\n",
            "+            Iterator<Map.Entry<K, V>> it = AbstractPatriciaTrie.this.entrySet().iterator();\n",
            "+            Set<K> currentKeys = keySet();\n",
            "+            while (it.hasNext()) {\n",
            "+                if (currentKeys.contains(it.next().getKey())) {\n",
            "+                    it.remove();\n",
            "+                }\n",
            "+            }\n",
            "+        }\n",
            "     }\n",
            " \n",
            "     /**\n"
          ],
          "changed_lines": 10
        }
      ]
    }
  ]
}
