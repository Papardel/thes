{
  "bug_id": "53",
  "failed_tests": {
    "org.apache.commons.math.complex.ComplexTest": [
      {
        "methodName": "testAddNaN",
        "error": "junit.framework.AssertionFailedError",
        "message": "",
        "fail_line": "        Assert.assertTrue(Double.isNaN(w.getReal()));",
        "test_source": "  public void testAddNaN() {\n  Complex x = new Complex(3.0, 4.0);\n  Complex z = x.add(Complex.NaN);\n  Assert.assertTrue(z.isNaN());\n  z = new Complex(1, nan);\n  Complex w = x.add(z);\n  Assert.assertTrue(Double.isNaN(w.getReal()));\n  Assert.assertTrue(Double.isNaN(w.getImaginary()));\n  }",
        "stack": [
          "ComplexTest.testAddNaN line 116"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/math/complex/Complex.java",
      "buggy_full_code": "\n\npackage org.apache.commons.math.complex;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.math.FieldElement;\nimport org.apache.commons.math.MathRuntimeException;\nimport org.apache.commons.math.exception.NullArgumentException;\nimport org.apache.commons.math.exception.util.LocalizedFormats;\nimport org.apache.commons.math.util.MathUtils;\nimport org.apache.commons.math.util.FastMath;\n\n\npublic class Complex implements FieldElement<Complex>, Serializable { public static final Complex I = new Complex(0.0, 1.0); public static final Complex NaN = new Complex(Double.NaN, Double.NaN); public static final Complex INF = new Complex(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY); public static final Complex ONE = new Complex(1.0, 0.0); public static final Complex ZERO = new Complex(0.0, 0.0); private static final long serialVersionUID = -6195664516687396620L; private final double imaginary; private final double real; private final transient boolean isNaN; private final transient boolean isInfinite; public Complex(double real, double imaginary) {\n        super();\n        this.real = real;\n        this.imaginary = imaginary;\n\n        isNaN = Double.isNaN(real) || Double.isNaN(imaginary);\n        isInfinite = !isNaN &&\n        (Double.isInfinite(real) || Double.isInfinite(imaginary));\n    }\n\n    \n    public double abs() {\n        if (isNaN) {\n            return Double.NaN;\n        }\n\n        if (isInfinite()) {\n            return Double.POSITIVE_INFINITY;\n        }\n\n        if (FastMath.abs(real) < FastMath.abs(imaginary)) {\n            if (imaginary == 0.0) {\n                return FastMath.abs(real);\n            }\n            double q = real / imaginary;\n            return FastMath.abs(imaginary) * FastMath.sqrt(1 + q * q);\n        } else {\n            if (real == 0.0) {\n                return FastMath.abs(imaginary);\n            }\n            double q = imaginary / real;\n            return FastMath.abs(real) * FastMath.sqrt(1 + q * q);\n        }\n    }\n\n    \n    public Complex add(Complex rhs) throws NullArgumentException {\n        MathUtils.checkNotNull(rhs);\n        return createComplex(real + rhs.getReal(),\n            imaginary + rhs.getImaginary());\n    }\n\n    \n    public Complex conjugate() {\n        if (isNaN) {\n            return NaN;\n        }\n        return createComplex(real, -imaginary);\n    }\n\n    \n    public Complex divide(Complex rhs) throws NullArgumentException {\n        MathUtils.checkNotNull(rhs);\n        if (isNaN || rhs.isNaN) {\n            return NaN;\n        }\n\n        double c = rhs.getReal();\n        double d = rhs.getImaginary();\n        if (c == 0.0 && d == 0.0) {\n            return NaN;\n        }\n\n        if (rhs.isInfinite() && !isInfinite()) {\n            return ZERO;\n        }\n\n        if (FastMath.abs(c) < FastMath.abs(d)) {\n            double q = c / d;\n            double denominator = c * q + d;\n            return createComplex((real * q + imaginary) / denominator,\n                (imaginary * q - real) / denominator);\n        } else {\n            double q = d / c;\n            double denominator = d * q + c;\n            return createComplex((imaginary * q + real) / denominator,\n                (imaginary - real * q) / denominator);\n        }\n    }\n\n    \n    @Override\n    public boolean equals(Object other) {\n        if (this == other) {\n            return true;\n        }\n        if (other instanceof Complex){\n            Complex rhs = (Complex)other;\n            if (rhs.isNaN) {\n                return isNaN;\n            } else {\n                return (real == rhs.real) && (imaginary == rhs.imaginary);\n            }\n        }\n        return false;\n    }\n\n    \n    @Override\n    public int hashCode() {\n        if (isNaN) {\n            return 7;\n        }\n        return 37 * (17 * MathUtils.hash(imaginary) +\n            MathUtils.hash(real));\n    }\n\n    \n    public double getImaginary() {\n        return imaginary;\n    }\n\n    \n    public double getReal() {\n        return real;\n    }\n\n    \n    public boolean isNaN() {\n        return isNaN;\n    }\n\n    \n    public boolean isInfinite() {\n        return isInfinite;\n    }\n\n    \n    public Complex multiply(Complex rhs) throws NullArgumentException {\n        MathUtils.checkNotNull(rhs);\n        if (isNaN || rhs.isNaN) {\n            return NaN;\n        }\n        if (Double.isInfinite(real) || Double.isInfinite(imaginary) ||\n            Double.isInfinite(rhs.real)|| Double.isInfinite(rhs.imaginary)) {\n            \n            return INF;\n        }\n        return createComplex(real * rhs.real - imaginary * rhs.imaginary,\n                real * rhs.imaginary + imaginary * rhs.real);\n    }\n\n    \n    public Complex multiply(double rhs) {\n        if (isNaN || Double.isNaN(rhs)) {\n            return NaN;\n        }\n        if (Double.isInfinite(real) || Double.isInfinite(imaginary) ||\n            Double.isInfinite(rhs)) {\n            \n            return INF;\n        }\n        return createComplex(real * rhs, imaginary * rhs);\n    }\n\n    \n    public Complex negate() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        return createComplex(-real, -imaginary);\n    }\n\n    \n    public Complex subtract(Complex rhs) throws NullArgumentException {\n        MathUtils.checkNotNull(rhs);\n        if (isNaN || rhs.isNaN) {\n            return NaN;\n        }\n\n        return createComplex(real - rhs.getReal(),\n            imaginary - rhs.getImaginary());\n    }\n\n    \n    public Complex acos() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        return this.add(this.sqrt1z().multiply(Complex.I)).log()\n              .multiply(Complex.I.negate());\n    }\n\n    \n    public Complex asin() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        return sqrt1z().add(this.multiply(Complex.I)).log()\n              .multiply(Complex.I.negate());\n    }\n\n    \n    public Complex atan() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        return this.add(Complex.I).divide(Complex.I.subtract(this)).log()\n            .multiply(Complex.I.divide(createComplex(2.0, 0.0)));\n    }\n\n    \n    public Complex cos() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        return createComplex(FastMath.cos(real) * MathUtils.cosh(imaginary),\n            -FastMath.sin(real) * MathUtils.sinh(imaginary));\n    }\n\n    \n    public Complex cosh() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        return createComplex(MathUtils.cosh(real) * FastMath.cos(imaginary),\n            MathUtils.sinh(real) * FastMath.sin(imaginary));\n    }\n\n    \n    public Complex exp() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        double expReal = FastMath.exp(real);\n        return createComplex(expReal *  FastMath.cos(imaginary), expReal * FastMath.sin(imaginary));\n    }\n\n    \n    public Complex log() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        return createComplex(FastMath.log(abs()),\n            FastMath.atan2(imaginary, real));\n    }\n\n    \n    public Complex pow(Complex x) throws NullArgumentException {\n        MathUtils.checkNotNull(x);\n        return this.log().multiply(x).exp();\n    }\n\n    \n    public Complex sin() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        return createComplex(FastMath.sin(real) * MathUtils.cosh(imaginary),\n            FastMath.cos(real) * MathUtils.sinh(imaginary));\n    }\n\n    \n    public Complex sinh() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        return createComplex(MathUtils.sinh(real) * FastMath.cos(imaginary),\n            MathUtils.cosh(real) * FastMath.sin(imaginary));\n    }\n\n    \n    public Complex sqrt() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        if (real == 0.0 && imaginary == 0.0) {\n            return createComplex(0.0, 0.0);\n        }\n\n        double t = FastMath.sqrt((FastMath.abs(real) + abs()) / 2.0);\n        if (real >= 0.0) {\n            return createComplex(t, imaginary / (2.0 * t));\n        } else {\n            return createComplex(FastMath.abs(imaginary) / (2.0 * t),\n                MathUtils.indicator(imaginary) * t);\n        }\n    }\n\n    \n    public Complex sqrt1z() {\n        return createComplex(1.0, 0.0).subtract(this.multiply(this)).sqrt();\n    }\n\n    \n    public Complex tan() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        double real2 = 2.0 * real;\n        double imaginary2 = 2.0 * imaginary;\n        double d = FastMath.cos(real2) + MathUtils.cosh(imaginary2);\n\n        return createComplex(FastMath.sin(real2) / d, MathUtils.sinh(imaginary2) / d);\n    }\n\n    \n    public Complex tanh() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        double real2 = 2.0 * real;\n        double imaginary2 = 2.0 * imaginary;\n        double d = MathUtils.cosh(real2) + FastMath.cos(imaginary2);\n\n        return createComplex(MathUtils.sinh(real2) / d, FastMath.sin(imaginary2) / d);\n    }\n\n\n\n    \n    public double getArgument() {\n        return FastMath.atan2(getImaginary(), getReal());\n    }\n\n    \n    public List<Complex> nthRoot(int n) throws IllegalArgumentException {\n\n        if (n <= 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                    LocalizedFormats.CANNOT_COMPUTE_NTH_ROOT_FOR_NEGATIVE_N,\n                    n);\n        }\n\n        List<Complex> result = new ArrayList<Complex>();\n\n        if (isNaN) {\n            result.add(NaN);\n            return result;\n        }\n\n        if (isInfinite()) {\n            result.add(INF);\n            return result;\n        }\n\n        \n        final double nthRootOfAbs = FastMath.pow(abs(), 1.0 / n);\n\n        \n        final double nthPhi = getArgument()/n;\n        final double slice = 2 * FastMath.PI / n;\n        double innerPart = nthPhi;\n        for (int k = 0; k < n ; k++) {\n            \n            final double realPart      = nthRootOfAbs *  FastMath.cos(innerPart);\n            final double imaginaryPart = nthRootOfAbs *  FastMath.sin(innerPart);\n            result.add(createComplex(realPart, imaginaryPart));\n            innerPart += slice;\n        }\n\n        return result;\n    }\n\n    \n    protected Complex createComplex(double realPart, double imaginaryPart) {\n        return new Complex(realPart, imaginaryPart);\n    }\n\n    \n    protected final Object readResolve() {\n        return createComplex(real, imaginary);\n    }\n\n    \n    public ComplexField getField() {\n        return ComplexField.getInstance();\n    }\n\n    \n    @Override\n    public String toString() {\n        return \"(\" + real + \", \" + imaginary + \")\";\n    }\n}\n",
      "fixed_full_code": "\n\npackage org.apache.commons.math.complex;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.math.FieldElement;\nimport org.apache.commons.math.MathRuntimeException;\nimport org.apache.commons.math.exception.NullArgumentException;\nimport org.apache.commons.math.exception.util.LocalizedFormats;\nimport org.apache.commons.math.util.MathUtils;\nimport org.apache.commons.math.util.FastMath;\n\n\npublic class Complex implements FieldElement<Complex>, Serializable { public static final Complex I = new Complex(0.0, 1.0); public static final Complex NaN = new Complex(Double.NaN, Double.NaN); public static final Complex INF = new Complex(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY); public static final Complex ONE = new Complex(1.0, 0.0); public static final Complex ZERO = new Complex(0.0, 0.0); private static final long serialVersionUID = -6195664516687396620L; private final double imaginary; private final double real; private final transient boolean isNaN; private final transient boolean isInfinite; public Complex(double real, double imaginary) {\n        super();\n        this.real = real;\n        this.imaginary = imaginary;\n\n        isNaN = Double.isNaN(real) || Double.isNaN(imaginary);\n        isInfinite = !isNaN &&\n        (Double.isInfinite(real) || Double.isInfinite(imaginary));\n    }\n\n    \n    public double abs() {\n        if (isNaN) {\n            return Double.NaN;\n        }\n\n        if (isInfinite()) {\n            return Double.POSITIVE_INFINITY;\n        }\n\n        if (FastMath.abs(real) < FastMath.abs(imaginary)) {\n            if (imaginary == 0.0) {\n                return FastMath.abs(real);\n            }\n            double q = real / imaginary;\n            return FastMath.abs(imaginary) * FastMath.sqrt(1 + q * q);\n        } else {\n            if (real == 0.0) {\n                return FastMath.abs(imaginary);\n            }\n            double q = imaginary / real;\n            return FastMath.abs(real) * FastMath.sqrt(1 + q * q);\n        }\n    }\n\n    \n    public Complex add(Complex rhs) throws NullArgumentException {\n        MathUtils.checkNotNull(rhs);\n        if (isNaN || rhs.isNaN) {\n            return NaN;\n        }\n        return createComplex(real + rhs.getReal(),\n            imaginary + rhs.getImaginary());\n    }\n\n    \n    public Complex conjugate() {\n        if (isNaN) {\n            return NaN;\n        }\n        return createComplex(real, -imaginary);\n    }\n\n    \n    public Complex divide(Complex rhs) throws NullArgumentException {\n        MathUtils.checkNotNull(rhs);\n        if (isNaN || rhs.isNaN) {\n            return NaN;\n        }\n\n        double c = rhs.getReal();\n        double d = rhs.getImaginary();\n        if (c == 0.0 && d == 0.0) {\n            return NaN;\n        }\n\n        if (rhs.isInfinite() && !isInfinite()) {\n            return ZERO;\n        }\n\n        if (FastMath.abs(c) < FastMath.abs(d)) {\n            double q = c / d;\n            double denominator = c * q + d;\n            return createComplex((real * q + imaginary) / denominator,\n                (imaginary * q - real) / denominator);\n        } else {\n            double q = d / c;\n            double denominator = d * q + c;\n            return createComplex((imaginary * q + real) / denominator,\n                (imaginary - real * q) / denominator);\n        }\n    }\n\n    \n    @Override\n    public boolean equals(Object other) {\n        if (this == other) {\n            return true;\n        }\n        if (other instanceof Complex){\n            Complex rhs = (Complex)other;\n            if (rhs.isNaN) {\n                return isNaN;\n            } else {\n                return (real == rhs.real) && (imaginary == rhs.imaginary);\n            }\n        }\n        return false;\n    }\n\n    \n    @Override\n    public int hashCode() {\n        if (isNaN) {\n            return 7;\n        }\n        return 37 * (17 * MathUtils.hash(imaginary) +\n            MathUtils.hash(real));\n    }\n\n    \n    public double getImaginary() {\n        return imaginary;\n    }\n\n    \n    public double getReal() {\n        return real;\n    }\n\n    \n    public boolean isNaN() {\n        return isNaN;\n    }\n\n    \n    public boolean isInfinite() {\n        return isInfinite;\n    }\n\n    \n    public Complex multiply(Complex rhs) throws NullArgumentException {\n        MathUtils.checkNotNull(rhs);\n        if (isNaN || rhs.isNaN) {\n            return NaN;\n        }\n        if (Double.isInfinite(real) || Double.isInfinite(imaginary) ||\n            Double.isInfinite(rhs.real)|| Double.isInfinite(rhs.imaginary)) {\n            \n            return INF;\n        }\n        return createComplex(real * rhs.real - imaginary * rhs.imaginary,\n                real * rhs.imaginary + imaginary * rhs.real);\n    }\n\n    \n    public Complex multiply(double rhs) {\n        if (isNaN || Double.isNaN(rhs)) {\n            return NaN;\n        }\n        if (Double.isInfinite(real) || Double.isInfinite(imaginary) ||\n            Double.isInfinite(rhs)) {\n            \n            return INF;\n        }\n        return createComplex(real * rhs, imaginary * rhs);\n    }\n\n    \n    public Complex negate() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        return createComplex(-real, -imaginary);\n    }\n\n    \n    public Complex subtract(Complex rhs) throws NullArgumentException {\n        MathUtils.checkNotNull(rhs);\n        if (isNaN || rhs.isNaN) {\n            return NaN;\n        }\n\n        return createComplex(real - rhs.getReal(),\n            imaginary - rhs.getImaginary());\n    }\n\n    \n    public Complex acos() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        return this.add(this.sqrt1z().multiply(Complex.I)).log()\n              .multiply(Complex.I.negate());\n    }\n\n    \n    public Complex asin() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        return sqrt1z().add(this.multiply(Complex.I)).log()\n              .multiply(Complex.I.negate());\n    }\n\n    \n    public Complex atan() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        return this.add(Complex.I).divide(Complex.I.subtract(this)).log()\n            .multiply(Complex.I.divide(createComplex(2.0, 0.0)));\n    }\n\n    \n    public Complex cos() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        return createComplex(FastMath.cos(real) * MathUtils.cosh(imaginary),\n            -FastMath.sin(real) * MathUtils.sinh(imaginary));\n    }\n\n    \n    public Complex cosh() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        return createComplex(MathUtils.cosh(real) * FastMath.cos(imaginary),\n            MathUtils.sinh(real) * FastMath.sin(imaginary));\n    }\n\n    \n    public Complex exp() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        double expReal = FastMath.exp(real);\n        return createComplex(expReal *  FastMath.cos(imaginary), expReal * FastMath.sin(imaginary));\n    }\n\n    \n    public Complex log() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        return createComplex(FastMath.log(abs()),\n            FastMath.atan2(imaginary, real));\n    }\n\n    \n    public Complex pow(Complex x) throws NullArgumentException {\n        MathUtils.checkNotNull(x);\n        return this.log().multiply(x).exp();\n    }\n\n    \n    public Complex sin() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        return createComplex(FastMath.sin(real) * MathUtils.cosh(imaginary),\n            FastMath.cos(real) * MathUtils.sinh(imaginary));\n    }\n\n    \n    public Complex sinh() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        return createComplex(MathUtils.sinh(real) * FastMath.cos(imaginary),\n            MathUtils.cosh(real) * FastMath.sin(imaginary));\n    }\n\n    \n    public Complex sqrt() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        if (real == 0.0 && imaginary == 0.0) {\n            return createComplex(0.0, 0.0);\n        }\n\n        double t = FastMath.sqrt((FastMath.abs(real) + abs()) / 2.0);\n        if (real >= 0.0) {\n            return createComplex(t, imaginary / (2.0 * t));\n        } else {\n            return createComplex(FastMath.abs(imaginary) / (2.0 * t),\n                MathUtils.indicator(imaginary) * t);\n        }\n    }\n\n    \n    public Complex sqrt1z() {\n        return createComplex(1.0, 0.0).subtract(this.multiply(this)).sqrt();\n    }\n\n    \n    public Complex tan() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        double real2 = 2.0 * real;\n        double imaginary2 = 2.0 * imaginary;\n        double d = FastMath.cos(real2) + MathUtils.cosh(imaginary2);\n\n        return createComplex(FastMath.sin(real2) / d, MathUtils.sinh(imaginary2) / d);\n    }\n\n    \n    public Complex tanh() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        double real2 = 2.0 * real;\n        double imaginary2 = 2.0 * imaginary;\n        double d = MathUtils.cosh(real2) + FastMath.cos(imaginary2);\n\n        return createComplex(MathUtils.sinh(real2) / d, FastMath.sin(imaginary2) / d);\n    }\n\n\n\n    \n    public double getArgument() {\n        return FastMath.atan2(getImaginary(), getReal());\n    }\n\n    \n    public List<Complex> nthRoot(int n) throws IllegalArgumentException {\n\n        if (n <= 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                    LocalizedFormats.CANNOT_COMPUTE_NTH_ROOT_FOR_NEGATIVE_N,\n                    n);\n        }\n\n        List<Complex> result = new ArrayList<Complex>();\n\n        if (isNaN) {\n            result.add(NaN);\n            return result;\n        }\n\n        if (isInfinite()) {\n            result.add(INF);\n            return result;\n        }\n\n        \n        final double nthRootOfAbs = FastMath.pow(abs(), 1.0 / n);\n\n        \n        final double nthPhi = getArgument()/n;\n        final double slice = 2 * FastMath.PI / n;\n        double innerPart = nthPhi;\n        for (int k = 0; k < n ; k++) {\n            \n            final double realPart      = nthRootOfAbs *  FastMath.cos(innerPart);\n            final double imaginaryPart = nthRootOfAbs *  FastMath.sin(innerPart);\n            result.add(createComplex(realPart, imaginaryPart));\n            innerPart += slice;\n        }\n\n        return result;\n    }\n\n    \n    protected Complex createComplex(double realPart, double imaginaryPart) {\n        return new Complex(realPart, imaginaryPart);\n    }\n\n    \n    protected final Object readResolve() {\n        return createComplex(real, imaginary);\n    }\n\n    \n    public ComplexField getField() {\n        return ComplexField.getInstance();\n    }\n\n    \n    @Override\n    public String toString() {\n        return \"(\" + real + \", \" + imaginary + \")\";\n    }\n}\n",
      "buggy_signatures": [
        "public double abs()",
        "public Complex add(Complex rhs) throws NullArgumentException",
        "public Complex conjugate()",
        "public Complex divide(Complex rhs) throws NullArgumentException",
        "public boolean equals(Object other)",
        "public int hashCode()",
        "public double getImaginary()",
        "public double getReal()",
        "public boolean isNaN()",
        "public boolean isInfinite()",
        "public Complex multiply(Complex rhs) throws NullArgumentException",
        "public Complex multiply(double rhs)",
        "public Complex negate()",
        "public Complex subtract(Complex rhs) throws NullArgumentException",
        "public Complex acos()",
        "public Complex asin()",
        "public Complex atan()",
        "public Complex cos()",
        "public Complex cosh()",
        "public Complex exp()",
        "public Complex log()",
        "public Complex pow(Complex x) throws NullArgumentException",
        "public Complex sin()",
        "public Complex sinh()",
        "public Complex sqrt()",
        "public Complex sqrt1z()",
        "public Complex tan()",
        "public Complex tanh()",
        "public double getArgument()",
        "public List<Complex> nthRoot(int n) throws IllegalArgumentException",
        "protected Complex createComplex(double realPart, double imaginaryPart)",
        "protected final Object readResolve()",
        "public ComplexField getField()",
        "public String toString()"
      ],
      "fixed_signatures": [
        "public double abs()",
        "public Complex add(Complex rhs) throws NullArgumentException",
        "public Complex conjugate()",
        "public Complex divide(Complex rhs) throws NullArgumentException",
        "public boolean equals(Object other)",
        "public int hashCode()",
        "public double getImaginary()",
        "public double getReal()",
        "public boolean isNaN()",
        "public boolean isInfinite()",
        "public Complex multiply(Complex rhs) throws NullArgumentException",
        "public Complex multiply(double rhs)",
        "public Complex negate()",
        "public Complex subtract(Complex rhs) throws NullArgumentException",
        "public Complex acos()",
        "public Complex asin()",
        "public Complex atan()",
        "public Complex cos()",
        "public Complex cosh()",
        "public Complex exp()",
        "public Complex log()",
        "public Complex pow(Complex x) throws NullArgumentException",
        "public Complex sin()",
        "public Complex sinh()",
        "public Complex sqrt()",
        "public Complex sqrt1z()",
        "public Complex tan()",
        "public Complex tanh()",
        "public double getArgument()",
        "public List<Complex> nthRoot(int n) throws IllegalArgumentException",
        "protected Complex createComplex(double realPart, double imaginaryPart)",
        "protected final Object readResolve()",
        "public ComplexField getField()",
        "public String toString()"
      ],
      "methods": [
        {
          "buggy_method": "  public Complex add(Complex rhs) throws NullArgumentException {\n  MathUtils.checkNotNull(rhs);\n  return createComplex(real + rhs.getReal(),\n  imaginary + rhs.getImaginary());\n  }",
          "fixed_method": "  public Complex add(Complex rhs) throws NullArgumentException {\n  MathUtils.checkNotNull(rhs);\n  if (isNaN || rhs.isNaN) {\n  return NaN;\n  }\n  return createComplex(real + rhs.getReal(),\n  imaginary + rhs.getImaginary());\n  }",
          "diff": [
            "@@ -150,6 +150,9 @@",
            "     public Complex add(Complex rhs)\n",
            "         throws NullArgumentException {\n",
            "         MathUtils.checkNotNull(rhs);\n",
            "+        if (isNaN || rhs.isNaN) {\n",
            "+            return NaN;\n",
            "+        }\n",
            "         return createComplex(real + rhs.getReal(),\n",
            "             imaginary + rhs.getImaginary());\n",
            "     }\n"
          ],
          "changed_lines": 3
        }
      ]
    }
  ]
}
