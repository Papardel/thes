{
  "bug_id": "72",
  "failed_tests": {
    "org.jsoup.parser.CharacterReaderTest": [
      {
        "methodName": "consumeToNonexistentEndWhenAtAnd",
        "error": "java.lang.StringIndexOutOfBoundsException",
        "message": "offset 0, count -1, length 2",
        "fail_line": "        String after = r.consumeTo('>');",
        "test_source": "  public void consumeToNonexistentEndWhenAtAnd() {\n  CharacterReader r = new CharacterReader(\"<!\");\n  assertTrue(r.matchConsume(\"<!\"));\n  assertTrue(r.isEmpty());\n\n  String after = r.consumeTo('>');\n  assertEquals(\"\", after);\n\n  assertTrue(r.isEmpty());\n  }",
        "stack": [
          "CharacterReader.cacheString line 440, CharacterReader.consumeToEnd line 255, CharacterReader.consumeTo line 167, CharacterReaderTest.consumeToNonexistentEndWhenAtAnd line 265"
        ]
      }
    ],
    "org.jsoup.parser.HtmlParserTest": [
      {
        "methodName": "commentAtEnd",
        "error": "java.lang.StringIndexOutOfBoundsException",
        "message": "offset 0, count -1, length 32768",
        "fail_line": "      Document doc = Jsoup.parse(\"<!\");",
        "test_source": "",
        "stack": [
          "CharacterReader.cacheString line 440, CharacterReader.consumeToEnd line 255, CharacterReader.consumeTo line 167, TokeniserState$43.read line 903, Tokeniser.read line 45, TreeBuilder.runParser line 51, TreeBuilder.parse line 45, Parser.parse line 107, Jsoup.parse line 58, HtmlParserTest.commentAtEnd line 1086"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/jsoup/parser/CharacterReader.java",
      "buggy_full_code": "package org.jsoup.parser;\n\nimport org.jsoup.UncheckedIOException;\nimport org.jsoup.helper.Validate;\n\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.util.Arrays;\nimport java.util.Locale;\n\n\npublic final class CharacterReader { static final char EOF = (char) -1; private static final int maxStringCacheLen = 12; static final int maxBufferLen = 1024 * 32; private static final int readAheadLimit = (int) (maxBufferLen * 0.75); private final char[] charBuf; private final Reader reader; private int bufLength; private int bufSplitPoint; private int bufPos; private int readerPos; private int bufMark; private final String[] stringCache = new String[512]; public CharacterReader(Reader input, int sz) {\n        Validate.notNull(input);\n        Validate.isTrue(input.markSupported());\n        reader = input;\n        charBuf = new char[sz > maxBufferLen ? maxBufferLen : sz];\n        bufferUp();\n    }\n\n    public CharacterReader(Reader input) {\n        this(input, maxBufferLen);\n    }\n\n    public CharacterReader(String input) {\n        this(new StringReader(input), input.length());\n    }\n\n    private void bufferUp() {\n        if (bufPos < bufSplitPoint)\n            return;\n\n        try {\n            readerPos += bufPos;\n            reader.skip(bufPos);\n            reader.mark(maxBufferLen);\n            bufLength = reader.read(charBuf);\n            reader.reset();\n            bufPos = 0;\n            bufMark = 0;\n            bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength;\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    \n    public int pos() {\n        return readerPos + bufPos;\n    }\n\n    \n    public boolean isEmpty() {\n        return bufPos >= bufLength;\n    }\n\n    \n    public char current() {\n        bufferUp();\n        return isEmpty() ? EOF : charBuf[bufPos];\n    }\n\n    char consume() {\n        bufferUp();\n        char val = isEmpty() ? EOF : charBuf[bufPos];\n        bufPos++;\n        return val;\n    }\n\n    void unconsume() {\n        bufPos--;\n    }\n\n    \n    public void advance() {\n        bufPos++;\n    }\n\n    void mark() {\n        bufMark = bufPos;\n    }\n\n    void rewindToMark() {\n        bufPos = bufMark;\n    }\n\n    \n    int nextIndexOf(char c) {\n        \n        bufferUp();\n        for (int i = bufPos; i < bufLength; i++) {\n            if (c == charBuf[i])\n                return i - bufPos;\n        }\n        return -1;\n    }\n\n    \n    int nextIndexOf(CharSequence seq) {\n        bufferUp();\n        \n        char startChar = seq.charAt(0);\n        for (int offset = bufPos; offset < bufLength; offset++) {\n            \n            if (startChar != charBuf[offset])\n                while(++offset < bufLength && startChar != charBuf[offset]) {  }\n            int i = offset + 1;\n            int last = i + seq.length()-1;\n            if (offset < bufLength && last <= bufLength) {\n                for (int j = 1; i < last && seq.charAt(j) == charBuf[i]; i++, j++) {  }\n                if (i == last) \n                    return offset - bufPos;\n            }\n        }\n        return -1;\n    }\n\n    \n    public String consumeTo(char c) {\n        int offset = nextIndexOf(c);\n        if (offset != -1) {\n            String consumed = cacheString(charBuf, stringCache, bufPos, offset);\n            bufPos += offset;\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    String consumeTo(String seq) {\n        int offset = nextIndexOf(seq);\n        if (offset != -1) {\n            String consumed = cacheString(charBuf, stringCache, bufPos, offset);\n            bufPos += offset;\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    \n    public String consumeToAny(final char... chars) {\n        bufferUp();\n        final int start = bufPos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        OUTER: while (bufPos < remaining) {\n            for (char c : chars) {\n                if (val[bufPos] == c)\n                    break OUTER;\n            }\n            bufPos++;\n        }\n\n        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n    }\n\n    String consumeToAnySorted(final char... chars) {\n        bufferUp();\n        final int start = bufPos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        while (bufPos < remaining) {\n            if (Arrays.binarySearch(chars, val[bufPos]) >= 0)\n                break;\n            bufPos++;\n        }\n\n        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n    }\n\n    String consumeData() {\n        \n        bufferUp();\n        final int start = bufPos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        while (bufPos < remaining) {\n            final char c = val[bufPos];\n            if (c == '&'|| c ==  '<' || c ==  TokeniserState.nullChar)\n                break;\n            bufPos++;\n        }\n\n        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n    }\n\n    String consumeTagName() {\n        \n        bufferUp();\n        final int start = bufPos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        while (bufPos < remaining) {\n            final char c = val[bufPos];\n            if (c == '\\t'|| c ==  '\\n'|| c ==  '\\r'|| c ==  '\\f'|| c ==  ' '|| c ==  '/'|| c ==  '>'|| c ==  TokeniserState.nullChar)\n                break;\n            bufPos++;\n        }\n\n        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n    }\n\n    String consumeToEnd() {\n        bufferUp();\n        String data = cacheString(charBuf, stringCache, bufPos, bufLength - bufPos);\n        bufPos = bufLength;\n        return data;\n    }\n\n    String consumeLetterSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\n            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c))\n                bufPos++;\n            else\n                break;\n        }\n\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    String consumeLetterThenDigitSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\n            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c))\n                bufPos++;\n            else\n                break;\n        }\n        while (!isEmpty()) {\n            char c = charBuf[bufPos];\n            if (c >= '0' && c <= '9')\n                bufPos++;\n            else\n                break;\n        }\n\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    String consumeHexSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\n            if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f'))\n                bufPos++;\n            else\n                break;\n        }\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    String consumeDigitSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\n            if (c >= '0' && c <= '9')\n                bufPos++;\n            else\n                break;\n        }\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    boolean matches(char c) {\n        return !isEmpty() && charBuf[bufPos] == c;\n\n    }\n\n    boolean matches(String seq) {\n        bufferUp();\n        int scanLength = seq.length();\n        if (scanLength > bufLength - bufPos)\n            return false;\n\n        for (int offset = 0; offset < scanLength; offset++)\n            if (seq.charAt(offset) != charBuf[bufPos +offset])\n                return false;\n        return true;\n    }\n\n    boolean matchesIgnoreCase(String seq) {\n        bufferUp();\n        int scanLength = seq.length();\n        if (scanLength > bufLength - bufPos)\n            return false;\n\n        for (int offset = 0; offset < scanLength; offset++) {\n            char upScan = Character.toUpperCase(seq.charAt(offset));\n            char upTarget = Character.toUpperCase(charBuf[bufPos + offset]);\n            if (upScan != upTarget)\n                return false;\n        }\n        return true;\n    }\n\n    boolean matchesAny(char... seq) {\n        if (isEmpty())\n            return false;\n\n        bufferUp();\n        char c = charBuf[bufPos];\n        for (char seek : seq) {\n            if (seek == c)\n                return true;\n        }\n        return false;\n    }\n\n    boolean matchesAnySorted(char[] seq) {\n        bufferUp();\n        return !isEmpty() && Arrays.binarySearch(seq, charBuf[bufPos]) >= 0;\n    }\n\n    boolean matchesLetter() {\n        if (isEmpty())\n            return false;\n        char c = charBuf[bufPos];\n        return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c);\n    }\n\n    boolean matchesDigit() {\n        if (isEmpty())\n            return false;\n        char c = charBuf[bufPos];\n        return (c >= '0' && c <= '9');\n    }\n\n    boolean matchConsume(String seq) {\n        bufferUp();\n        if (matches(seq)) {\n            bufPos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean matchConsumeIgnoreCase(String seq) {\n        if (matchesIgnoreCase(seq)) {\n            bufPos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean containsIgnoreCase(String seq) {\n        \n        String loScan = seq.toLowerCase(Locale.ENGLISH);\n        String hiScan = seq.toUpperCase(Locale.ENGLISH);\n        return (nextIndexOf(loScan) > -1) || (nextIndexOf(hiScan) > -1);\n    }\n\n    @Override\n    public String toString() {\n        return new String(charBuf, bufPos, bufLength - bufPos);\n    }\n\n    \n    private static String cacheString(final char[] charBuf, final String[] stringCache, final int start, final int count) {\n        \n        if (count > maxStringCacheLen)\n            return new String(charBuf, start, count);\n\n        \n        int hash = 0;\n        int offset = start;\n        for (int i = 0; i < count; i++) {\n            hash = 31 * hash + charBuf[offset++];\n        }\n\n        \n        final int index = hash & stringCache.length - 1;\n        String cached = stringCache[index];\n\n        if (cached == null) { \n            cached = new String(charBuf, start, count);\n            stringCache[index] = cached;\n        } else { \n            if (rangeEquals(charBuf, start, count, cached)) { \n                return cached;\n            } else { \n                cached = new String(charBuf, start, count);\n                stringCache[index] = cached; \n            }\n        }\n        return cached;\n    }\n\n    \n    static boolean rangeEquals(final char[] charBuf, final int start, int count, final String cached) {\n        if (count == cached.length()) {\n            int i = start;\n            int j = 0;\n            while (count-- != 0) {\n                if (charBuf[i++] != cached.charAt(j++))\n                    return false;\n            }\n            return true;\n        }\n        return false;\n    }\n\n    \n    boolean rangeEquals(final int start, final int count, final String cached) {\n        return rangeEquals(charBuf, start, count, cached);\n    }\n}\n",
      "fixed_full_code": "package org.jsoup.parser;\n\nimport org.jsoup.UncheckedIOException;\nimport org.jsoup.helper.Validate;\n\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.util.Arrays;\nimport java.util.Locale;\n\n\npublic final class CharacterReader { static final char EOF = (char) -1; private static final int maxStringCacheLen = 12; static final int maxBufferLen = 1024 * 32; private static final int readAheadLimit = (int) (maxBufferLen * 0.75); private final char[] charBuf; private final Reader reader; private int bufLength; private int bufSplitPoint; private int bufPos; private int readerPos; private int bufMark; private final String[] stringCache = new String[512]; public CharacterReader(Reader input, int sz) {\n        Validate.notNull(input);\n        Validate.isTrue(input.markSupported());\n        reader = input;\n        charBuf = new char[sz > maxBufferLen ? maxBufferLen : sz];\n        bufferUp();\n    }\n\n    public CharacterReader(Reader input) {\n        this(input, maxBufferLen);\n    }\n\n    public CharacterReader(String input) {\n        this(new StringReader(input), input.length());\n    }\n\n    private void bufferUp() {\n        if (bufPos < bufSplitPoint)\n            return;\n\n        try {\n            readerPos += bufPos;\n            reader.skip(bufPos);\n            reader.mark(maxBufferLen);\n            bufLength = reader.read(charBuf);\n            reader.reset();\n            bufPos = 0;\n            bufMark = 0;\n            bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength;\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    \n    public int pos() {\n        return readerPos + bufPos;\n    }\n\n    \n    public boolean isEmpty() {\n        return bufPos >= bufLength;\n    }\n\n    \n    public char current() {\n        bufferUp();\n        return isEmpty() ? EOF : charBuf[bufPos];\n    }\n\n    char consume() {\n        bufferUp();\n        char val = isEmpty() ? EOF : charBuf[bufPos];\n        bufPos++;\n        return val;\n    }\n\n    void unconsume() {\n        bufPos--;\n    }\n\n    \n    public void advance() {\n        bufPos++;\n    }\n\n    void mark() {\n        bufMark = bufPos;\n    }\n\n    void rewindToMark() {\n        bufPos = bufMark;\n    }\n\n    \n    int nextIndexOf(char c) {\n        \n        bufferUp();\n        for (int i = bufPos; i < bufLength; i++) {\n            if (c == charBuf[i])\n                return i - bufPos;\n        }\n        return -1;\n    }\n\n    \n    int nextIndexOf(CharSequence seq) {\n        bufferUp();\n        \n        char startChar = seq.charAt(0);\n        for (int offset = bufPos; offset < bufLength; offset++) {\n            \n            if (startChar != charBuf[offset])\n                while(++offset < bufLength && startChar != charBuf[offset]) {  }\n            int i = offset + 1;\n            int last = i + seq.length()-1;\n            if (offset < bufLength && last <= bufLength) {\n                for (int j = 1; i < last && seq.charAt(j) == charBuf[i]; i++, j++) {  }\n                if (i == last) \n                    return offset - bufPos;\n            }\n        }\n        return -1;\n    }\n\n    \n    public String consumeTo(char c) {\n        int offset = nextIndexOf(c);\n        if (offset != -1) {\n            String consumed = cacheString(charBuf, stringCache, bufPos, offset);\n            bufPos += offset;\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    String consumeTo(String seq) {\n        int offset = nextIndexOf(seq);\n        if (offset != -1) {\n            String consumed = cacheString(charBuf, stringCache, bufPos, offset);\n            bufPos += offset;\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    \n    public String consumeToAny(final char... chars) {\n        bufferUp();\n        final int start = bufPos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        OUTER: while (bufPos < remaining) {\n            for (char c : chars) {\n                if (val[bufPos] == c)\n                    break OUTER;\n            }\n            bufPos++;\n        }\n\n        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n    }\n\n    String consumeToAnySorted(final char... chars) {\n        bufferUp();\n        final int start = bufPos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        while (bufPos < remaining) {\n            if (Arrays.binarySearch(chars, val[bufPos]) >= 0)\n                break;\n            bufPos++;\n        }\n\n        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n    }\n\n    String consumeData() {\n        \n        bufferUp();\n        final int start = bufPos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        while (bufPos < remaining) {\n            final char c = val[bufPos];\n            if (c == '&'|| c ==  '<' || c ==  TokeniserState.nullChar)\n                break;\n            bufPos++;\n        }\n\n        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n    }\n\n    String consumeTagName() {\n        \n        bufferUp();\n        final int start = bufPos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        while (bufPos < remaining) {\n            final char c = val[bufPos];\n            if (c == '\\t'|| c ==  '\\n'|| c ==  '\\r'|| c ==  '\\f'|| c ==  ' '|| c ==  '/'|| c ==  '>'|| c ==  TokeniserState.nullChar)\n                break;\n            bufPos++;\n        }\n\n        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n    }\n\n    String consumeToEnd() {\n        bufferUp();\n        String data = cacheString(charBuf, stringCache, bufPos, bufLength - bufPos);\n        bufPos = bufLength;\n        return data;\n    }\n\n    String consumeLetterSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\n            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c))\n                bufPos++;\n            else\n                break;\n        }\n\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    String consumeLetterThenDigitSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\n            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c))\n                bufPos++;\n            else\n                break;\n        }\n        while (!isEmpty()) {\n            char c = charBuf[bufPos];\n            if (c >= '0' && c <= '9')\n                bufPos++;\n            else\n                break;\n        }\n\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    String consumeHexSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\n            if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f'))\n                bufPos++;\n            else\n                break;\n        }\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    String consumeDigitSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\n            if (c >= '0' && c <= '9')\n                bufPos++;\n            else\n                break;\n        }\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    boolean matches(char c) {\n        return !isEmpty() && charBuf[bufPos] == c;\n\n    }\n\n    boolean matches(String seq) {\n        bufferUp();\n        int scanLength = seq.length();\n        if (scanLength > bufLength - bufPos)\n            return false;\n\n        for (int offset = 0; offset < scanLength; offset++)\n            if (seq.charAt(offset) != charBuf[bufPos +offset])\n                return false;\n        return true;\n    }\n\n    boolean matchesIgnoreCase(String seq) {\n        bufferUp();\n        int scanLength = seq.length();\n        if (scanLength > bufLength - bufPos)\n            return false;\n\n        for (int offset = 0; offset < scanLength; offset++) {\n            char upScan = Character.toUpperCase(seq.charAt(offset));\n            char upTarget = Character.toUpperCase(charBuf[bufPos + offset]);\n            if (upScan != upTarget)\n                return false;\n        }\n        return true;\n    }\n\n    boolean matchesAny(char... seq) {\n        if (isEmpty())\n            return false;\n\n        bufferUp();\n        char c = charBuf[bufPos];\n        for (char seek : seq) {\n            if (seek == c)\n                return true;\n        }\n        return false;\n    }\n\n    boolean matchesAnySorted(char[] seq) {\n        bufferUp();\n        return !isEmpty() && Arrays.binarySearch(seq, charBuf[bufPos]) >= 0;\n    }\n\n    boolean matchesLetter() {\n        if (isEmpty())\n            return false;\n        char c = charBuf[bufPos];\n        return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c);\n    }\n\n    boolean matchesDigit() {\n        if (isEmpty())\n            return false;\n        char c = charBuf[bufPos];\n        return (c >= '0' && c <= '9');\n    }\n\n    boolean matchConsume(String seq) {\n        bufferUp();\n        if (matches(seq)) {\n            bufPos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean matchConsumeIgnoreCase(String seq) {\n        if (matchesIgnoreCase(seq)) {\n            bufPos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean containsIgnoreCase(String seq) {\n        \n        String loScan = seq.toLowerCase(Locale.ENGLISH);\n        String hiScan = seq.toUpperCase(Locale.ENGLISH);\n        return (nextIndexOf(loScan) > -1) || (nextIndexOf(hiScan) > -1);\n    }\n\n    @Override\n    public String toString() {\n        return new String(charBuf, bufPos, bufLength - bufPos);\n    }\n\n    \n    private static String cacheString(final char[] charBuf, final String[] stringCache, final int start, final int count) {\n        \n        if (count > maxStringCacheLen)\n            return new String(charBuf, start, count);\n        if (count < 1)\n            return \"\";\n\n        \n        int hash = 0;\n        int offset = start;\n        for (int i = 0; i < count; i++) {\n            hash = 31 * hash + charBuf[offset++];\n        }\n\n        \n        final int index = hash & stringCache.length - 1;\n        String cached = stringCache[index];\n\n        if (cached == null) { \n            cached = new String(charBuf, start, count);\n            stringCache[index] = cached;\n        } else { \n            if (rangeEquals(charBuf, start, count, cached)) { \n                return cached;\n            } else { \n                cached = new String(charBuf, start, count);\n                stringCache[index] = cached; \n            }\n        }\n        return cached;\n    }\n\n    \n    static boolean rangeEquals(final char[] charBuf, final int start, int count, final String cached) {\n        if (count == cached.length()) {\n            int i = start;\n            int j = 0;\n            while (count-- != 0) {\n                if (charBuf[i++] != cached.charAt(j++))\n                    return false;\n            }\n            return true;\n        }\n        return false;\n    }\n\n    \n    boolean rangeEquals(final int start, final int count, final String cached) {\n        return rangeEquals(charBuf, start, count, cached);\n    }\n}\n",
      "buggy_signatures": [
        "public CharacterReader(Reader input)",
        "public CharacterReader(String input)",
        "private void bufferUp()",
        "public int pos()",
        "public boolean isEmpty()",
        "public char current()",
        "public void advance()",
        "public String consumeTo(char c)",
        "public String consumeToAny(final char... chars)",
        "public String toString()",
        "private static String cacheString(final char[] charBuf, final String[] stringCache, final int start, final int count)",
        "static boolean rangeEquals(final char[] charBuf, final int start, int count, final String cached)"
      ],
      "fixed_signatures": [
        "public CharacterReader(Reader input)",
        "public CharacterReader(String input)",
        "private void bufferUp()",
        "public int pos()",
        "public boolean isEmpty()",
        "public char current()",
        "public void advance()",
        "public String consumeTo(char c)",
        "public String consumeToAny(final char... chars)",
        "public String toString()",
        "private static String cacheString(final char[] charBuf, final String[] stringCache, final int start, final int count)",
        "static boolean rangeEquals(final char[] charBuf, final int start, int count, final String cached)"
      ],
      "methods": [
        {
          "buggy_method": "  private static String cacheString(final char[] charBuf, final String[] stringCache, final int start, final int count) {\n  \n  if (count > maxStringCacheLen)\n  return new String(charBuf, start, count);\n\n  \n  int hash = 0;\n  int offset = start;\n  for (int i = 0; i < count; i++) {\n  hash = 31 * hash + charBuf[offset++];\n  }\n\n  \n  final int index = hash & stringCache.length - 1;\n  String cached = stringCache[index];\n\n  if (cached == null) { \n  cached = new String(charBuf, start, count);\n  stringCache[index] = cached;\n  } else { \n  if (rangeEquals(charBuf, start, count, cached)) { \n  return cached;\n  } else { \n  cached = new String(charBuf, start, count);\n  stringCache[index] = cached; \n  }\n  }\n  return cached;\n  }",
          "fixed_method": "  private static String cacheString(final char[] charBuf, final String[] stringCache, final int start, final int count) {\n  \n  if (count > maxStringCacheLen)\n  return new String(charBuf, start, count);\n  if (count < 1)\n  return \"\";\n\n  \n  int hash = 0;\n  int offset = start;\n  for (int i = 0; i < count; i++) {\n  hash = 31 * hash + charBuf[offset++];\n  }\n\n  \n  final int index = hash & stringCache.length - 1;\n  String cached = stringCache[index];\n\n  if (cached == null) { \n  cached = new String(charBuf, start, count);\n  stringCache[index] = cached;\n  } else { \n  if (rangeEquals(charBuf, start, count, cached)) { \n  return cached;\n  } else { \n  cached = new String(charBuf, start, count);\n  stringCache[index] = cached; \n  }\n  }\n  return cached;\n  }",
          "diff": [
            "@@ -424,6 +424,8 @@",
            "         // limit (no cache):\n",
            "         if (count > maxStringCacheLen)\n",
            "             return new String(charBuf, start, count);\n",
            "+        if (count < 1)\n",
            "+            return \"\";\n",
            " \n",
            "         // calculate hash:\n",
            "         int hash = 0;\n"
          ],
          "changed_lines": 2
        }
      ]
    }
  ]
}
