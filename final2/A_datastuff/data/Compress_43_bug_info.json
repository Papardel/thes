{
  "bug_id": "43",
  "failed_tests": {
    "org.apache.commons.compress.archivers.zip.DataDescriptorTest": [
      {
        "methodName": "doesntWriteDataDescriptorWhenAddingRawEntries",
        "error": "junit.framework.AssertionFailedError",
        "message": "arrays first differed at element [0]; expected:<0> but was:<8>",
        "fail_line": "        assertArrayEquals(new byte[] { 0, 8 }, gpbInLFH);",
        "test_source": "  public void doesntWriteDataDescriptorWhenAddingRawEntries() throws IOException {\n  ByteArrayOutputStream init = new ByteArrayOutputStream();\n  try (ZipArchiveOutputStream zos = new ZipArchiveOutputStream(init)) {\n  zos.putArchiveEntry(new ZipArchiveEntry(\"test1.txt\"));\n  zos.write(\"foo\".getBytes(\"UTF-8\"));\n  zos.closeArchiveEntry();\n  }\n\n  File f = new File(dir, \"test.zip\");\n  try (FileOutputStream fos = new FileOutputStream(f)) {\n  fos.write(init.toByteArray());\n  }\n\n  ByteArrayOutputStream o = new ByteArrayOutputStream();\n  ZipArchiveEntry zae;\n  try (ZipFile zf = new ZipFile(f);\n  ZipArchiveOutputStream zos = new ZipArchiveOutputStream(o)) {\n  zae = zf.getEntry(\"test1.txt\");\n  zos.addRawArchiveEntry(zae, zf.getRawInputStream(zae));\n  }\n\n  byte[] data = o.toByteArray();\n  byte[] versionInLFH = Arrays.copyOfRange(data, 4, 6);\n  // still 2.0 because of Deflate\n  assertArrayEquals(new byte[] { 20, 0 }, versionInLFH);\n  byte[] gpbInLFH = Arrays.copyOfRange(data, 6, 8);\n  // no DD but EFS flag\n  assertArrayEquals(new byte[] { 0, 8 }, gpbInLFH);\n\n  int cdhStart = findCentralDirectory(data);\n  byte[] versionInCDH = Arrays.copyOfRange(data, cdhStart + 6, cdhStart + 8);\n  assertArrayEquals(new byte[] { 20, 0 }, versionInCDH);\n  byte[] gpbInCDH = Arrays.copyOfRange(data, cdhStart + 8, cdhStart + 10);\n  assertArrayEquals(new byte[] { 0, 8 }, gpbInCDH);\n\n  int ddStart = cdhStart - 16;\n  assertNotEquals(ZipLong.DD_SIG, new ZipLong(data, ddStart));\n  long crcFromLFH = ZipLong.getValue(data, 14);\n  long cSizeFromLFH = ZipLong.getValue(data, 18);\n  long sizeFromLFH = ZipLong.getValue(data, 22);\n  assertEquals(3, sizeFromLFH);\n\n  long crcFromCDH = ZipLong.getValue(data, cdhStart + 16);\n  assertEquals(crcFromLFH, crcFromCDH);\n  long cSizeFromCDH = ZipLong.getValue(data, cdhStart + 20);\n  assertEquals(cSizeFromLFH, cSizeFromCDH);\n  long sizeFromCDH = ZipLong.getValue(data, cdhStart + 24);\n  assertEquals(sizeFromLFH, sizeFromCDH);\n  }",
        "stack": [
          "DataDescriptorTest.doesntWriteDataDescriptorWhenAddingRawEntries line 162"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java",
      "buggy_full_code": "\npackage org.apache.commons.compress.archivers.zip;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.file.Files;\nimport java.nio.file.StandardOpenOption;\nimport java.util.Calendar;\nimport java.util.EnumSet;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.zip.Deflater;\nimport java.util.zip.ZipException;\n\nimport org.apache.commons.compress.archivers.ArchiveEntry;\nimport org.apache.commons.compress.archivers.ArchiveOutputStream;\nimport org.apache.commons.compress.utils.IOUtils;\n\nimport static org.apache.commons.compress.archivers.zip.ZipConstants.DATA_DESCRIPTOR_MIN_VERSION; import static org.apache.commons.compress.archivers.zip.ZipConstants.DEFLATE_MIN_VERSION; import static org.apache.commons.compress.archivers.zip.ZipConstants.DWORD; import static org.apache.commons.compress.archivers.zip.ZipConstants.INITIAL_VERSION; import static org.apache.commons.compress.archivers.zip.ZipConstants.SHORT; import static org.apache.commons.compress.archivers.zip.ZipConstants.WORD; import static org.apache.commons.compress.archivers.zip.ZipConstants.ZIP64_MAGIC; import static org.apache.commons.compress.archivers.zip.ZipConstants.ZIP64_MAGIC_SHORT; import static org.apache.commons.compress.archivers.zip.ZipConstants.ZIP64_MIN_VERSION; import static org.apache.commons.compress.archivers.zip.ZipLong.putLong; import static org.apache.commons.compress.archivers.zip.ZipShort.putShort; public class ZipArchiveOutputStream extends ArchiveOutputStream { static final int BUFFER_SIZE = 512; private static final int LFH_SIG_OFFSET = 0; private static final int LFH_VERSION_NEEDED_OFFSET = 4; private static final int LFH_GPB_OFFSET = 6; private static final int LFH_METHOD_OFFSET = 8; private static final int LFH_TIME_OFFSET = 10; private static final int LFH_CRC_OFFSET = 14; private static final int LFH_COMPRESSED_SIZE_OFFSET = 18; private static final int LFH_ORIGINAL_SIZE_OFFSET = 22; private static final int LFH_FILENAME_LENGTH_OFFSET = 26; private static final int LFH_EXTRA_LENGTH_OFFSET = 28; private static final int LFH_FILENAME_OFFSET = 30; private static final int CFH_SIG_OFFSET = 0; private static final int CFH_VERSION_MADE_BY_OFFSET = 4; private static final int CFH_VERSION_NEEDED_OFFSET = 6; private static final int CFH_GPB_OFFSET = 8; private static final int CFH_METHOD_OFFSET = 10; private static final int CFH_TIME_OFFSET = 12; private static final int CFH_CRC_OFFSET = 16; private static final int CFH_COMPRESSED_SIZE_OFFSET = 20; private static final int CFH_ORIGINAL_SIZE_OFFSET = 24; private static final int CFH_FILENAME_LENGTH_OFFSET = 28; private static final int CFH_EXTRA_LENGTH_OFFSET = 30; private static final int CFH_COMMENT_LENGTH_OFFSET = 32; private static final int CFH_DISK_NUMBER_OFFSET = 34; private static final int CFH_INTERNAL_ATTRIBUTES_OFFSET = 36; private static final int CFH_EXTERNAL_ATTRIBUTES_OFFSET = 38; private static final int CFH_LFH_OFFSET = 42; private static final int CFH_FILENAME_OFFSET = 46; protected boolean finished = false; public static final int DEFLATED = java.util.zip.ZipEntry.DEFLATED; public static final int DEFAULT_COMPRESSION = Deflater.DEFAULT_COMPRESSION; public static final int STORED = java.util.zip.ZipEntry.STORED; static final String DEFAULT_ENCODING = ZipEncodingHelper.UTF8; @Deprecated public static final int EFS_FLAG = GeneralPurposeBit.UFT8_NAMES_FLAG; private static final byte[] EMPTY = new byte[0]; private CurrentEntry entry; private String comment = \"\"; private int level = DEFAULT_COMPRESSION; private boolean hasCompressionLevelChanged = false; private int method = java.util.zip.ZipEntry.DEFLATED; private final List<ZipArchiveEntry> entries = new LinkedList<>(); private final StreamCompressor streamCompressor; private long cdOffset = 0; private long cdLength = 0; private static final byte[] ZERO = {0, 0};\n\n    \n    private static final byte[] LZERO = {0, 0, 0, 0}; private static final byte[] ONE = ZipLong.getBytes(1L); private final Map<ZipArchiveEntry, EntryMetaData> metaData = new HashMap<>(); private String encoding = DEFAULT_ENCODING; private ZipEncoding zipEncoding = ZipEncodingHelper.getZipEncoding(DEFAULT_ENCODING); protected final Deflater def; private final SeekableByteChannel channel; private final OutputStream out; private boolean useUTF8Flag = true; private boolean fallbackToUTF8 = false; private UnicodeExtraFieldPolicy createUnicodeExtraFields = UnicodeExtraFieldPolicy.NEVER; private boolean hasUsedZip64 = false; private Zip64Mode zip64Mode = Zip64Mode.AsNeeded; private final byte[] copyBuffer = new byte[32768]; private final Calendar calendarInstance = Calendar.getInstance(); public ZipArchiveOutputStream(final OutputStream out) {\n        this.out = out;\n        this.channel = null;\n        def = new Deflater(level, true);\n        streamCompressor = StreamCompressor.create(out, def);\n    }\n\n    \n    public ZipArchiveOutputStream(final File file) throws IOException {\n        def = new Deflater(level, true);\n        OutputStream o = null;\n        SeekableByteChannel _channel = null;\n        StreamCompressor _streamCompressor = null;\n        try {\n            _channel = Files.newByteChannel(file.toPath(),\n                EnumSet.of(StandardOpenOption.CREATE, StandardOpenOption.WRITE,\n                           StandardOpenOption.READ,\n                           StandardOpenOption.TRUNCATE_EXISTING));\n            \n            _streamCompressor = StreamCompressor.create(_channel, def); \n        } catch (final IOException e) {\n            IOUtils.closeQuietly(_channel);\n            _channel = null;\n            o = new FileOutputStream(file);\n            _streamCompressor = StreamCompressor.create(o, def);\n        }\n        out = o;\n        channel = _channel;\n        streamCompressor = _streamCompressor;\n    }\n\n    \n    public ZipArchiveOutputStream(SeekableByteChannel channel) throws IOException {\n        this.channel = channel;\n        def = new Deflater(level, true);\n        streamCompressor = StreamCompressor.create(channel, def);\n        out = null;\n    }\n\n    \n    public boolean isSeekable() {\n        return channel != null;\n    }\n\n    \n    public void setEncoding(final String encoding) {\n        this.encoding = encoding;\n        this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n        if (useUTF8Flag && !ZipEncodingHelper.isUTF8(encoding)) {\n            useUTF8Flag = false;\n        }\n    }\n\n    \n    public String getEncoding() {\n        return encoding;\n    }\n\n    \n    public void setUseLanguageEncodingFlag(final boolean b) {\n        useUTF8Flag = b && ZipEncodingHelper.isUTF8(encoding);\n    }\n\n    \n    public void setCreateUnicodeExtraFields(final UnicodeExtraFieldPolicy b) {\n        createUnicodeExtraFields = b;\n    }\n\n    \n    public void setFallbackToUTF8(final boolean b) {\n        fallbackToUTF8 = b;\n    }\n\n    \n    public void setUseZip64(final Zip64Mode mode) {\n        zip64Mode = mode;\n    }\n\n    \n    @Override\n    public void finish() throws IOException {\n        if (finished) {\n            throw new IOException(\"This archive has already been finished\");\n        }\n\n        if (entry != null) {\n            throw new IOException(\"This archive contains unclosed entries.\");\n        }\n\n        cdOffset = streamCompressor.getTotalBytesWritten();\n        writeCentralDirectoryInChunks();\n\n        cdLength = streamCompressor.getTotalBytesWritten() - cdOffset;\n        writeZip64CentralDirectory();\n        writeCentralDirectoryEnd();\n        metaData.clear();\n        entries.clear();\n        streamCompressor.close();\n        finished = true;\n    }\n\n    private void writeCentralDirectoryInChunks() throws IOException {\n        final int NUM_PER_WRITE = 1000;\n        final ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(70 * NUM_PER_WRITE);\n        int count = 0;\n        for (final ZipArchiveEntry ze : entries) {\n            byteArrayOutputStream.write(createCentralFileHeader(ze));\n            if (++count > NUM_PER_WRITE){\n                writeCounted(byteArrayOutputStream.toByteArray());\n                byteArrayOutputStream.reset();\n                count = 0;\n            }\n        }\n        writeCounted(byteArrayOutputStream.toByteArray());\n    }\n\n    \n    @Override\n    public void closeArchiveEntry() throws IOException {\n        preClose();\n\n        flushDeflater();\n\n        final long bytesWritten = streamCompressor.getTotalBytesWritten() - entry.dataStart;\n        final long realCrc = streamCompressor.getCrc32();\n        entry.bytesRead = streamCompressor.getBytesRead();\n        final Zip64Mode effectiveMode = getEffectiveZip64Mode(entry.entry);\n        final boolean actuallyNeedsZip64 = handleSizesAndCrc(bytesWritten, realCrc, effectiveMode);\n        closeEntry(actuallyNeedsZip64, false);\n        streamCompressor.reset();\n    }\n\n    \n    private void closeCopiedEntry(final boolean phased) throws IOException {\n        preClose();\n        entry.bytesRead = entry.entry.getSize();\n        final Zip64Mode effectiveMode = getEffectiveZip64Mode(entry.entry);\n        final boolean actuallyNeedsZip64 = checkIfNeedsZip64(effectiveMode);\n        closeEntry(actuallyNeedsZip64, phased);\n    }\n\n    private void closeEntry(final boolean actuallyNeedsZip64, final boolean phased) throws IOException {\n        if (!phased && channel != null) {\n            rewriteSizesAndCrc(actuallyNeedsZip64);\n        }\n\n        if (!phased) {\n            writeDataDescriptor(entry.entry);\n        }\n        entry = null;\n    }\n\n    private void preClose() throws IOException {\n        if (finished) {\n            throw new IOException(\"Stream has already been finished\");\n        }\n\n        if (entry == null) {\n            throw new IOException(\"No current entry to close\");\n        }\n\n        if (!entry.hasWritten) {\n            write(EMPTY, 0, 0);\n        }\n    }\n\n    \n    public void addRawArchiveEntry(final ZipArchiveEntry entry, final InputStream rawStream) throws IOException {\n        final ZipArchiveEntry ae = new ZipArchiveEntry(entry);\n        if (hasZip64Extra(ae)) {\n            \n            \n            \n            ae.removeExtraField(Zip64ExtendedInformationExtraField.HEADER_ID);\n        }\n        final boolean is2PhaseSource = ae.getCrc() != ZipArchiveEntry.CRC_UNKNOWN\n                && ae.getSize() != ArchiveEntry.SIZE_UNKNOWN\n                && ae.getCompressedSize() != ArchiveEntry.SIZE_UNKNOWN;\n        putArchiveEntry(ae, is2PhaseSource);\n        copyFromZipInputStream(rawStream);\n        closeCopiedEntry(is2PhaseSource);\n    }\n\n    \n    private void flushDeflater() throws IOException {\n        if (entry.entry.getMethod() == DEFLATED) {\n            streamCompressor.flushDeflater();\n        }\n    }\n\n    \n    private boolean handleSizesAndCrc(final long bytesWritten, final long crc, final Zip64Mode effectiveMode) throws ZipException {\n        if (entry.entry.getMethod() == DEFLATED) {\n            \n            entry.entry.setSize(entry.bytesRead);\n            entry.entry.setCompressedSize(bytesWritten);\n            entry.entry.setCrc(crc);\n\n        } else if (channel == null) {\n            if (entry.entry.getCrc() != crc) {\n                throw new ZipException(\"bad CRC checksum for entry \"\n                                       + entry.entry.getName() + \": \"\n                                       + Long.toHexString(entry.entry.getCrc())\n                                       + \" instead of \"\n                                       + Long.toHexString(crc));\n            }\n\n            if (entry.entry.getSize() != bytesWritten) {\n                throw new ZipException(\"bad size for entry \"\n                                       + entry.entry.getName() + \": \"\n                                       + entry.entry.getSize()\n                                       + \" instead of \"\n                                       + bytesWritten);\n            }\n        } else { \n            entry.entry.setSize(bytesWritten);\n            entry.entry.setCompressedSize(bytesWritten);\n            entry.entry.setCrc(crc);\n        }\n\n        return checkIfNeedsZip64(effectiveMode);\n    }\n\n    \n    private boolean checkIfNeedsZip64(final Zip64Mode effectiveMode) throws ZipException {\n        final boolean actuallyNeedsZip64 = isZip64Required(entry.entry, effectiveMode);\n        if (actuallyNeedsZip64 && effectiveMode == Zip64Mode.Never) {\n            throw new Zip64RequiredException(Zip64RequiredException.getEntryTooBigMessage(entry.entry));\n        }\n        return actuallyNeedsZip64;\n    }\n\n    private boolean isZip64Required(final ZipArchiveEntry entry1, final Zip64Mode requestedMode) {\n        return requestedMode == Zip64Mode.Always || isTooLageForZip32(entry1);\n    }\n\n    private boolean isTooLageForZip32(final ZipArchiveEntry zipArchiveEntry) {\n        return zipArchiveEntry.getSize() >= ZIP64_MAGIC || zipArchiveEntry.getCompressedSize() >= ZIP64_MAGIC;\n    }\n\n    \n    private void rewriteSizesAndCrc(final boolean actuallyNeedsZip64) throws IOException {\n        final long save = channel.position();\n\n        channel.position(entry.localDataStart);\n        writeOut(ZipLong.getBytes(entry.entry.getCrc()));\n        if (!hasZip64Extra(entry.entry) || !actuallyNeedsZip64) {\n            writeOut(ZipLong.getBytes(entry.entry.getCompressedSize()));\n            writeOut(ZipLong.getBytes(entry.entry.getSize()));\n        } else {\n            writeOut(ZipLong.ZIP64_MAGIC.getBytes());\n            writeOut(ZipLong.ZIP64_MAGIC.getBytes());\n        }\n\n        if (hasZip64Extra(entry.entry)) {\n            final ByteBuffer name = getName(entry.entry);\n            final int nameLen = name.limit() - name.position();\n            \n            channel.position(entry.localDataStart + 3 * WORD + 2 * SHORT\n                             + nameLen + 2 * SHORT);\n            \n            \n            writeOut(ZipEightByteInteger.getBytes(entry.entry.getSize()));\n            writeOut(ZipEightByteInteger.getBytes(entry.entry.getCompressedSize()));\n\n            if (!actuallyNeedsZip64) {\n                \n                \n                channel.position(entry.localDataStart  - 5 * SHORT);\n                writeOut(ZipShort.getBytes(versionNeededToExtract(entry.entry.getMethod(), false, false)));\n\n                \n                \n                entry.entry.removeExtraField(Zip64ExtendedInformationExtraField\n                                             .HEADER_ID);\n                entry.entry.setExtra();\n\n                \n                \n                if (entry.causedUseOfZip64) {\n                    hasUsedZip64 = false;\n                }\n            }\n        }\n        channel.position(save);\n    }\n\n    \n    @Override\n    public void putArchiveEntry(final ArchiveEntry archiveEntry) throws IOException {\n        putArchiveEntry(archiveEntry, false);\n    }\n\n    \n    private void putArchiveEntry(final ArchiveEntry archiveEntry, final boolean phased) throws IOException {\n        if (finished) {\n            throw new IOException(\"Stream has already been finished\");\n        }\n\n        if (entry != null) {\n            closeArchiveEntry();\n        }\n\n        entry = new CurrentEntry((ZipArchiveEntry) archiveEntry);\n        entries.add(entry.entry);\n\n        setDefaults(entry.entry);\n\n        final Zip64Mode effectiveMode = getEffectiveZip64Mode(entry.entry);\n        validateSizeInformation(effectiveMode);\n\n        if (shouldAddZip64Extra(entry.entry, effectiveMode)) {\n\n            final Zip64ExtendedInformationExtraField z64 = getZip64Extra(entry.entry);\n\n            ZipEightByteInteger size, compressedSize;\n            if (phased) {\n                \n                size = new ZipEightByteInteger(entry.entry.getSize());\n                compressedSize = new ZipEightByteInteger(entry.entry.getCompressedSize());\n            } else if (entry.entry.getMethod() == STORED\n                    && entry.entry.getSize() != ArchiveEntry.SIZE_UNKNOWN) {\n                \n                compressedSize = size = new ZipEightByteInteger(entry.entry.getSize());\n            } else {\n                \n                \n                compressedSize = size = ZipEightByteInteger.ZERO;\n            }\n            z64.setSize(size);\n            z64.setCompressedSize(compressedSize);\n            entry.entry.setExtra();\n        }\n\n        if (entry.entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {\n            def.setLevel(level);\n            hasCompressionLevelChanged = false;\n        }\n        writeLocalFileHeader((ZipArchiveEntry) archiveEntry, phased);\n    }\n\n    \n    private void setDefaults(final ZipArchiveEntry entry) {\n        if (entry.getMethod() == -1) { \n            entry.setMethod(method);\n        }\n\n        if (entry.getTime() == -1) { \n            entry.setTime(System.currentTimeMillis());\n        }\n    }\n\n    \n    private void validateSizeInformation(final Zip64Mode effectiveMode) throws ZipException {\n        \n        if (entry.entry.getMethod() == STORED && channel == null) {\n            if (entry.entry.getSize() == ArchiveEntry.SIZE_UNKNOWN) {\n                throw new ZipException(\"uncompressed size is required for\"\n                                       + \" STORED method when not writing to a\"\n                                       + \" file\");\n            }\n            if (entry.entry.getCrc() == ZipArchiveEntry.CRC_UNKNOWN) {\n                throw new ZipException(\"crc checksum is required for STORED\"\n                                       + \" method when not writing to a file\");\n            }\n            entry.entry.setCompressedSize(entry.entry.getSize());\n        }\n\n        if ((entry.entry.getSize() >= ZIP64_MAGIC\n             || entry.entry.getCompressedSize() >= ZIP64_MAGIC)\n            && effectiveMode == Zip64Mode.Never) {\n            throw new Zip64RequiredException(Zip64RequiredException\n                                             .getEntryTooBigMessage(entry.entry));\n        }\n    }\n\n    \n    private boolean shouldAddZip64Extra(final ZipArchiveEntry entry, final Zip64Mode mode) {\n        return mode == Zip64Mode.Always\n            || entry.getSize() >= ZIP64_MAGIC\n            || entry.getCompressedSize() >= ZIP64_MAGIC\n            || (entry.getSize() == ArchiveEntry.SIZE_UNKNOWN\n                && channel != null && mode != Zip64Mode.Never);\n    }\n\n    \n    public void setComment(final String comment) {\n        this.comment = comment;\n    }\n\n    \n    public void setLevel(final int level) {\n        if (level < Deflater.DEFAULT_COMPRESSION\n            || level > Deflater.BEST_COMPRESSION) {\n            throw new IllegalArgumentException(\"Invalid compression level: \"\n                                               + level);\n        }\n        hasCompressionLevelChanged = (this.level != level);\n        this.level = level;\n    }\n\n    \n    public void setMethod(final int method) {\n        this.method = method;\n    }\n\n    \n    @Override\n    public boolean canWriteEntryData(final ArchiveEntry ae) {\n        if (ae instanceof ZipArchiveEntry) {\n            final ZipArchiveEntry zae = (ZipArchiveEntry) ae;\n            return zae.getMethod() != ZipMethod.IMPLODING.getCode()\n                && zae.getMethod() != ZipMethod.UNSHRINKING.getCode()\n                && ZipUtil.canHandleEntryData(zae);\n        }\n        return false;\n    }\n\n    \n    @Override\n    public void write(final byte[] b, final int offset, final int length) throws IOException {\n        if (entry == null) {\n            throw new IllegalStateException(\"No current entry\");\n        }\n        ZipUtil.checkRequestedFeatures(entry.entry);\n        final long writtenThisTime = streamCompressor.write(b, offset, length, entry.entry.getMethod());\n        count(writtenThisTime);\n    }\n\n    \n    private void writeCounted(final byte[] data) throws IOException {\n        streamCompressor.writeCounted(data);\n    }\n\n    private void copyFromZipInputStream(final InputStream src) throws IOException {\n        if (entry == null) {\n            throw new IllegalStateException(\"No current entry\");\n        }\n        ZipUtil.checkRequestedFeatures(entry.entry);\n        entry.hasWritten = true;\n        int length;\n        while ((length = src.read(copyBuffer)) >= 0 )\n        {\n            streamCompressor.writeCounted(copyBuffer, 0, length);\n            count( length );\n        }\n    }\n\n    \n    @Override\n    public void close() throws IOException {\n        if (!finished) {\n            finish();\n        }\n        destroy();\n    }\n\n    \n    @Override\n    public void flush() throws IOException {\n        if (out != null) {\n            out.flush();\n        }\n    }\n\n    \n    \n    static final byte[] LFH_SIG = ZipLong.LFH_SIG.getBytes(); static final byte[] DD_SIG = ZipLong.DD_SIG.getBytes(); static final byte[] CFH_SIG = ZipLong.CFH_SIG.getBytes(); static final byte[] EOCD_SIG = ZipLong.getBytes(0X06054B50L); static final byte[] ZIP64_EOCD_SIG = ZipLong.getBytes(0X06064B50L); static final byte[] ZIP64_EOCD_LOC_SIG = ZipLong.getBytes(0X07064B50L); protected final void deflate() throws IOException {\n        streamCompressor.deflate();\n    }\n\n    \n    protected void writeLocalFileHeader(final ZipArchiveEntry ze) throws IOException {\n        writeLocalFileHeader(ze, false);\n    }\n\n    private void writeLocalFileHeader(final ZipArchiveEntry ze, final boolean phased) throws IOException {\n        final boolean encodable = zipEncoding.canEncode(ze.getName());\n        final ByteBuffer name = getName(ze);\n\n        if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n            addUnicodeExtraFields(ze, encodable, name);\n        }\n\n        final long localHeaderStart = streamCompressor.getTotalBytesWritten();\n        final byte[] localHeader = createLocalFileHeader(ze, name, encodable, phased, localHeaderStart);\n        metaData.put(ze, new EntryMetaData(localHeaderStart, usesDataDescriptor(ze.getMethod())));\n        entry.localDataStart = localHeaderStart + LFH_CRC_OFFSET; \n        writeCounted(localHeader);\n        entry.dataStart = streamCompressor.getTotalBytesWritten();\n    }\n\n\n    private byte[] createLocalFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final boolean encodable, final boolean phased, long archiveOffset) throws IOException {\n        ResourceAlignmentExtraField oldAlignmentEx =\n            (ResourceAlignmentExtraField) ze.getExtraField(ResourceAlignmentExtraField.ID);\n        if (oldAlignmentEx != null) {\n            ze.removeExtraField(ResourceAlignmentExtraField.ID);\n        }\n\n        int alignment = ze.getAlignment();\n        if (alignment <= 0 && oldAlignmentEx != null) {\n            alignment = oldAlignmentEx.getAlignment();\n        }\n\n        if (alignment > 1 || (oldAlignmentEx != null && !oldAlignmentEx.allowMethodChange())) {\n            int oldLength = LFH_FILENAME_OFFSET +\n                            name.limit() - name.position() +\n                            ze.getLocalFileDataExtra().length;\n\n            int padding = (int) ((-archiveOffset - oldLength - ZipExtraField.EXTRAFIELD_HEADER_SIZE\n                            - ResourceAlignmentExtraField.BASE_SIZE) &\n                            (alignment - 1));\n            ze.addExtraField(new ResourceAlignmentExtraField(alignment,\n                            oldAlignmentEx != null && oldAlignmentEx.allowMethodChange(), padding));\n        }\n\n        final byte[] extra = ze.getLocalFileDataExtra();\n        final int nameLen = name.limit() - name.position();\n        final int len = LFH_FILENAME_OFFSET + nameLen + extra.length;\n        final byte[] buf = new byte[len];\n\n        System.arraycopy(LFH_SIG,  0, buf, LFH_SIG_OFFSET, WORD);\n\n        \n        final int zipMethod = ze.getMethod();\n        final boolean dataDescriptor = usesDataDescriptor(zipMethod);\n\n        putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET);\n\n        final GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(!encodable && fallbackToUTF8, dataDescriptor);\n        generalPurposeBit.encode(buf, LFH_GPB_OFFSET);\n\n        \n        putShort(zipMethod, buf, LFH_METHOD_OFFSET);\n\n        ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, LFH_TIME_OFFSET);\n\n        \n        if (phased){\n            putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n        } else if (zipMethod == DEFLATED || channel != null) {\n            System.arraycopy(LZERO, 0, buf, LFH_CRC_OFFSET, WORD);\n        } else {\n            putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n        }\n\n        \n        \n        if (hasZip64Extra(entry.entry)){\n            \n            \n            \n            ZipLong.ZIP64_MAGIC.putLong(buf, LFH_COMPRESSED_SIZE_OFFSET);\n            ZipLong.ZIP64_MAGIC.putLong(buf, LFH_ORIGINAL_SIZE_OFFSET);\n        } else if (phased) {\n            putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n            putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n        } else if (zipMethod == DEFLATED || channel != null) {\n            System.arraycopy(LZERO, 0, buf, LFH_COMPRESSED_SIZE_OFFSET, WORD);\n            System.arraycopy(LZERO, 0, buf, LFH_ORIGINAL_SIZE_OFFSET, WORD);\n        } else { \n            putLong(ze.getSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n            putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n        }\n        \n        putShort(nameLen, buf, LFH_FILENAME_LENGTH_OFFSET);\n\n        \n        putShort(extra.length, buf, LFH_EXTRA_LENGTH_OFFSET);\n\n        \n        System.arraycopy( name.array(), name.arrayOffset(), buf, LFH_FILENAME_OFFSET, nameLen);\n\n        \n        System.arraycopy(extra, 0, buf, LFH_FILENAME_OFFSET + nameLen, extra.length);\n\n        return buf;\n    }\n\n\n    \n    private void addUnicodeExtraFields(final ZipArchiveEntry ze, final boolean encodable, final ByteBuffer name) throws IOException {\n        if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n            || !encodable) {\n            ze.addExtraField(new UnicodePathExtraField(ze.getName(),\n                                                       name.array(),\n                                                       name.arrayOffset(),\n                                                       name.limit()\n                                                       - name.position()));\n        }\n\n        final String comm = ze.getComment();\n        if (comm != null && !\"\".equals(comm)) {\n\n            final boolean commentEncodable = zipEncoding.canEncode(comm);\n\n            if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                || !commentEncodable) {\n                final ByteBuffer commentB = getEntryEncoding(ze).encode(comm);\n                ze.addExtraField(new UnicodeCommentExtraField(comm,\n                                                              commentB.array(),\n                                                              commentB.arrayOffset(),\n                                                              commentB.limit()\n                                                              - commentB.position())\n                                 );\n            }\n        }\n    }\n\n    \n    protected void writeDataDescriptor(final ZipArchiveEntry ze) throws IOException {\n        if (ze.getMethod() != DEFLATED || channel != null) {\n            return;\n        }\n        writeCounted(DD_SIG);\n        writeCounted(ZipLong.getBytes(ze.getCrc()));\n        if (!hasZip64Extra(ze)) {\n            writeCounted(ZipLong.getBytes(ze.getCompressedSize()));\n            writeCounted(ZipLong.getBytes(ze.getSize()));\n        } else {\n            writeCounted(ZipEightByteInteger.getBytes(ze.getCompressedSize()));\n            writeCounted(ZipEightByteInteger.getBytes(ze.getSize()));\n        }\n    }\n\n    \n    protected void writeCentralFileHeader(final ZipArchiveEntry ze) throws IOException {\n        final byte[] centralFileHeader = createCentralFileHeader(ze);\n        writeCounted(centralFileHeader);\n    }\n\n    private byte[] createCentralFileHeader(final ZipArchiveEntry ze) throws IOException {\n\n        final EntryMetaData entryMetaData = metaData.get(ze);\n        final boolean needsZip64Extra = hasZip64Extra(ze)\n                || ze.getCompressedSize() >= ZIP64_MAGIC\n                || ze.getSize() >= ZIP64_MAGIC\n                || entryMetaData.offset >= ZIP64_MAGIC\n                || zip64Mode == Zip64Mode.Always;\n\n        if (needsZip64Extra && zip64Mode == Zip64Mode.Never) {\n            \n            \n            \n            throw new Zip64RequiredException(Zip64RequiredException\n                    .ARCHIVE_TOO_BIG_MESSAGE);\n        }\n\n\n        handleZip64Extra(ze, entryMetaData.offset, needsZip64Extra);\n\n        return createCentralFileHeader(ze, getName(ze), entryMetaData, needsZip64Extra);\n    }\n\n    \n    private byte[] createCentralFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final EntryMetaData entryMetaData, final boolean needsZip64Extra) throws IOException {\n        final byte[] extra = ze.getCentralDirectoryExtra();\n\n        \n        String comm = ze.getComment();\n        if (comm == null) {\n            comm = \"\";\n        }\n\n        final ByteBuffer commentB = getEntryEncoding(ze).encode(comm);\n        final int nameLen = name.limit() - name.position();\n        final int commentLen = commentB.limit() - commentB.position();\n        final int len= CFH_FILENAME_OFFSET + nameLen + extra.length + commentLen;\n        final byte[] buf = new byte[len];\n\n        System.arraycopy(CFH_SIG,  0, buf, CFH_SIG_OFFSET, WORD);\n\n        \n        \n        putShort((ze.getPlatform() << 8) | (!hasUsedZip64 ? DATA_DESCRIPTOR_MIN_VERSION : ZIP64_MIN_VERSION),\n                buf, CFH_VERSION_MADE_BY_OFFSET);\n\n        final int zipMethod = ze.getMethod();\n        final boolean encodable = zipEncoding.canEncode(ze.getName());\n        putShort(versionNeededToExtract(zipMethod, needsZip64Extra, entryMetaData.usesDataDescriptor),\n            buf, CFH_VERSION_NEEDED_OFFSET);\n        getGeneralPurposeBits(!encodable && fallbackToUTF8, entryMetaData.usesDataDescriptor).encode(buf, CFH_GPB_OFFSET);\n\n        \n        putShort(zipMethod, buf, CFH_METHOD_OFFSET);\n\n\n        \n        ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, CFH_TIME_OFFSET);\n\n        \n        \n        \n        putLong(ze.getCrc(), buf, CFH_CRC_OFFSET);\n        if (ze.getCompressedSize() >= ZIP64_MAGIC\n                || ze.getSize() >= ZIP64_MAGIC\n                || zip64Mode == Zip64Mode.Always) {\n            ZipLong.ZIP64_MAGIC.putLong(buf, CFH_COMPRESSED_SIZE_OFFSET);\n            ZipLong.ZIP64_MAGIC.putLong(buf, CFH_ORIGINAL_SIZE_OFFSET);\n        } else {\n            putLong(ze.getCompressedSize(), buf, CFH_COMPRESSED_SIZE_OFFSET);\n            putLong(ze.getSize(), buf, CFH_ORIGINAL_SIZE_OFFSET);\n        }\n\n        putShort(nameLen, buf, CFH_FILENAME_LENGTH_OFFSET);\n\n        \n        putShort(extra.length, buf, CFH_EXTRA_LENGTH_OFFSET);\n\n        putShort(commentLen, buf, CFH_COMMENT_LENGTH_OFFSET);\n\n        \n        System.arraycopy(ZERO, 0, buf, CFH_DISK_NUMBER_OFFSET, SHORT);\n\n        \n        putShort(ze.getInternalAttributes(), buf, CFH_INTERNAL_ATTRIBUTES_OFFSET);\n\n        \n        putLong(ze.getExternalAttributes(), buf, CFH_EXTERNAL_ATTRIBUTES_OFFSET);\n\n        \n        if (entryMetaData.offset >= ZIP64_MAGIC || zip64Mode == Zip64Mode.Always) {\n            putLong(ZIP64_MAGIC, buf, CFH_LFH_OFFSET);\n        } else {\n            putLong(Math.min(entryMetaData.offset, ZIP64_MAGIC), buf, CFH_LFH_OFFSET);\n        }\n\n        \n        System.arraycopy(name.array(), name.arrayOffset(), buf, CFH_FILENAME_OFFSET, nameLen);\n\n        final int extraStart = CFH_FILENAME_OFFSET + nameLen;\n        System.arraycopy(extra, 0, buf, extraStart, extra.length);\n\n        final int commentStart = extraStart + extra.length;\n\n        \n        System.arraycopy(commentB.array(), commentB.arrayOffset(), buf, commentStart, commentLen);\n        return buf;\n    }\n\n    \n    private void handleZip64Extra(final ZipArchiveEntry ze, final long lfhOffset, final boolean needsZip64Extra) {\n        if (needsZip64Extra) {\n            final Zip64ExtendedInformationExtraField z64 = getZip64Extra(ze);\n            if (ze.getCompressedSize() >= ZIP64_MAGIC\n                || ze.getSize() >= ZIP64_MAGIC\n                || zip64Mode == Zip64Mode.Always) {\n                z64.setCompressedSize(new ZipEightByteInteger(ze.getCompressedSize()));\n                z64.setSize(new ZipEightByteInteger(ze.getSize()));\n            } else {\n                \n                z64.setCompressedSize(null);\n                z64.setSize(null);\n            }\n            if (lfhOffset >= ZIP64_MAGIC || zip64Mode == Zip64Mode.Always) {\n                z64.setRelativeHeaderOffset(new ZipEightByteInteger(lfhOffset));\n            }\n            ze.setExtra();\n        }\n    }\n\n    \n    protected void writeCentralDirectoryEnd() throws IOException {\n        writeCounted(EOCD_SIG);\n\n        \n        writeCounted(ZERO);\n        writeCounted(ZERO);\n\n        \n        final int numberOfEntries = entries.size();\n        if (numberOfEntries > ZIP64_MAGIC_SHORT\n            && zip64Mode == Zip64Mode.Never) {\n            throw new Zip64RequiredException(Zip64RequiredException\n                                             .TOO_MANY_ENTRIES_MESSAGE);\n        }\n        if (cdOffset > ZIP64_MAGIC && zip64Mode == Zip64Mode.Never) {\n            throw new Zip64RequiredException(Zip64RequiredException\n                                             .ARCHIVE_TOO_BIG_MESSAGE);\n        }\n\n        final byte[] num = ZipShort.getBytes(Math.min(numberOfEntries,\n                                                ZIP64_MAGIC_SHORT));\n        writeCounted(num);\n        writeCounted(num);\n\n        \n        writeCounted(ZipLong.getBytes(Math.min(cdLength, ZIP64_MAGIC)));\n        writeCounted(ZipLong.getBytes(Math.min(cdOffset, ZIP64_MAGIC)));\n\n        \n        final ByteBuffer data = this.zipEncoding.encode(comment);\n        final int dataLen = data.limit() - data.position();\n        writeCounted(ZipShort.getBytes(dataLen));\n        streamCompressor.writeCounted(data.array(), data.arrayOffset(), dataLen);\n    }\n\n    \n    protected void writeZip64CentralDirectory() throws IOException {\n        if (zip64Mode == Zip64Mode.Never) {\n            return;\n        }\n\n        if (!hasUsedZip64\n            && (cdOffset >= ZIP64_MAGIC || cdLength >= ZIP64_MAGIC\n                || entries.size() >= ZIP64_MAGIC_SHORT)) {\n            \n            hasUsedZip64 = true;\n        }\n\n        if (!hasUsedZip64) {\n            return;\n        }\n\n        final long offset = streamCompressor.getTotalBytesWritten();\n\n        writeOut(ZIP64_EOCD_SIG);\n        \n        \n        writeOut(ZipEightByteInteger\n                 .getBytes(SHORT   \n                           + SHORT \n                           + WORD  \n                           + WORD  \n                           + DWORD \n                           + DWORD \n                           + DWORD \n                           + (long) DWORD \n                           ));\n\n        \n        writeOut(ZipShort.getBytes(ZIP64_MIN_VERSION));\n        writeOut(ZipShort.getBytes(ZIP64_MIN_VERSION));\n\n        \n        writeOut(LZERO);\n        writeOut(LZERO);\n\n        \n        final byte[] num = ZipEightByteInteger.getBytes(entries.size());\n        writeOut(num);\n        writeOut(num);\n\n        \n        writeOut(ZipEightByteInteger.getBytes(cdLength));\n        writeOut(ZipEightByteInteger.getBytes(cdOffset));\n\n        \n\n        \n        writeOut(ZIP64_EOCD_LOC_SIG);\n\n        \n        writeOut(LZERO);\n        \n        writeOut(ZipEightByteInteger.getBytes(offset));\n        \n        writeOut(ONE);\n    }\n\n    \n    protected final void writeOut(final byte[] data) throws IOException {\n        streamCompressor.writeOut(data, 0, data.length);\n    }\n\n\n    \n    protected final void writeOut(final byte[] data, final int offset, final int length) throws IOException {\n        streamCompressor.writeOut(data, offset, length);\n    }\n\n\n    private GeneralPurposeBit getGeneralPurposeBits(final boolean utfFallback, boolean usesDataDescriptor) {\n        final GeneralPurposeBit b = new GeneralPurposeBit();\n        b.useUTF8ForNames(useUTF8Flag || utfFallback);\n        if (usesDataDescriptor) {\n            b.useDataDescriptor(true);\n        }\n        return b;\n    }\n\n    private int versionNeededToExtract(final int zipMethod, final boolean zip64, final boolean usedDataDescriptor) {\n        if (zip64) {\n            return ZIP64_MIN_VERSION;\n        }\n        if (usedDataDescriptor) {\n            return DATA_DESCRIPTOR_MIN_VERSION;\n        }\n        return versionNeededToExtractMethod(zipMethod);\n    }\n\n    private boolean usesDataDescriptor(final int zipMethod) {\n        return zipMethod == DEFLATED && channel == null;\n    }\n\n    private int versionNeededToExtractMethod(int zipMethod) {\n        return zipMethod == DEFLATED ? DEFLATE_MIN_VERSION : INITIAL_VERSION;\n    }\n\n    \n    @Override\n    public ArchiveEntry createArchiveEntry(final File inputFile, final String entryName) throws IOException {\n        if (finished) {\n            throw new IOException(\"Stream has already been finished\");\n        }\n        return new ZipArchiveEntry(inputFile, entryName);\n    }\n\n    \n    private Zip64ExtendedInformationExtraField getZip64Extra(final ZipArchiveEntry ze) {\n        if (entry != null) {\n            entry.causedUseOfZip64 = !hasUsedZip64;\n        }\n        hasUsedZip64 = true;\n        Zip64ExtendedInformationExtraField z64 =\n            (Zip64ExtendedInformationExtraField)\n            ze.getExtraField(Zip64ExtendedInformationExtraField\n                             .HEADER_ID);\n        if (z64 == null) {\n            \n            z64 = new Zip64ExtendedInformationExtraField();\n        }\n\n        \n        ze.addAsFirstExtraField(z64);\n\n        return z64;\n    }\n\n    \n    private boolean hasZip64Extra(final ZipArchiveEntry ze) {\n        return ze.getExtraField(Zip64ExtendedInformationExtraField\n                                .HEADER_ID)\n            != null;\n    }\n\n    \n    private Zip64Mode getEffectiveZip64Mode(final ZipArchiveEntry ze) {\n        if (zip64Mode != Zip64Mode.AsNeeded\n            || channel != null\n            || ze.getMethod() != DEFLATED\n            || ze.getSize() != ArchiveEntry.SIZE_UNKNOWN) {\n            return zip64Mode;\n        }\n        return Zip64Mode.Never;\n    }\n\n    private ZipEncoding getEntryEncoding(final ZipArchiveEntry ze) {\n        final boolean encodable = zipEncoding.canEncode(ze.getName());\n        return !encodable && fallbackToUTF8\n            ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n    }\n\n    private ByteBuffer getName(final ZipArchiveEntry ze) throws IOException {\n        return getEntryEncoding(ze).encode(ze.getName());\n    }\n\n    \n    void destroy() throws IOException {\n        if (channel != null) {\n            channel.close();\n        }\n        if (out != null) {\n            out.close();\n        }\n    }\n\n    \n    public static final class UnicodeExtraFieldPolicy { public static final UnicodeExtraFieldPolicy ALWAYS = new UnicodeExtraFieldPolicy(\"always\"); public static final UnicodeExtraFieldPolicy NEVER = new UnicodeExtraFieldPolicy(\"never\"); public static final UnicodeExtraFieldPolicy NOT_ENCODEABLE = new UnicodeExtraFieldPolicy(\"not encodeable\"); private final String name; private UnicodeExtraFieldPolicy(final String n) {\n            name = n;\n        }\n        @Override\n        public String toString() {\n            return name;\n        }\n    }\n\n    \n    private static final class CurrentEntry { private CurrentEntry(final ZipArchiveEntry entry) {\n            this.entry = entry;\n        }\n        \n        private final ZipArchiveEntry entry; private long localDataStart = 0; private long dataStart = 0; private long bytesRead = 0; private boolean causedUseOfZip64 = false; private boolean hasWritten; } private static final class EntryMetaData { private final long offset; private final boolean usesDataDescriptor; private EntryMetaData(long offset, boolean usesDataDescriptor) {\n            this.offset = offset;\n            this.usesDataDescriptor = usesDataDescriptor;\n        }\n    }\n}\n",
      "fixed_full_code": "\npackage org.apache.commons.compress.archivers.zip;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.file.Files;\nimport java.nio.file.StandardOpenOption;\nimport java.util.Calendar;\nimport java.util.EnumSet;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.zip.Deflater;\nimport java.util.zip.ZipException;\n\nimport org.apache.commons.compress.archivers.ArchiveEntry;\nimport org.apache.commons.compress.archivers.ArchiveOutputStream;\nimport org.apache.commons.compress.utils.IOUtils;\n\nimport static org.apache.commons.compress.archivers.zip.ZipConstants.DATA_DESCRIPTOR_MIN_VERSION; import static org.apache.commons.compress.archivers.zip.ZipConstants.DEFLATE_MIN_VERSION; import static org.apache.commons.compress.archivers.zip.ZipConstants.DWORD; import static org.apache.commons.compress.archivers.zip.ZipConstants.INITIAL_VERSION; import static org.apache.commons.compress.archivers.zip.ZipConstants.SHORT; import static org.apache.commons.compress.archivers.zip.ZipConstants.WORD; import static org.apache.commons.compress.archivers.zip.ZipConstants.ZIP64_MAGIC; import static org.apache.commons.compress.archivers.zip.ZipConstants.ZIP64_MAGIC_SHORT; import static org.apache.commons.compress.archivers.zip.ZipConstants.ZIP64_MIN_VERSION; import static org.apache.commons.compress.archivers.zip.ZipLong.putLong; import static org.apache.commons.compress.archivers.zip.ZipShort.putShort; public class ZipArchiveOutputStream extends ArchiveOutputStream { static final int BUFFER_SIZE = 512; private static final int LFH_SIG_OFFSET = 0; private static final int LFH_VERSION_NEEDED_OFFSET = 4; private static final int LFH_GPB_OFFSET = 6; private static final int LFH_METHOD_OFFSET = 8; private static final int LFH_TIME_OFFSET = 10; private static final int LFH_CRC_OFFSET = 14; private static final int LFH_COMPRESSED_SIZE_OFFSET = 18; private static final int LFH_ORIGINAL_SIZE_OFFSET = 22; private static final int LFH_FILENAME_LENGTH_OFFSET = 26; private static final int LFH_EXTRA_LENGTH_OFFSET = 28; private static final int LFH_FILENAME_OFFSET = 30; private static final int CFH_SIG_OFFSET = 0; private static final int CFH_VERSION_MADE_BY_OFFSET = 4; private static final int CFH_VERSION_NEEDED_OFFSET = 6; private static final int CFH_GPB_OFFSET = 8; private static final int CFH_METHOD_OFFSET = 10; private static final int CFH_TIME_OFFSET = 12; private static final int CFH_CRC_OFFSET = 16; private static final int CFH_COMPRESSED_SIZE_OFFSET = 20; private static final int CFH_ORIGINAL_SIZE_OFFSET = 24; private static final int CFH_FILENAME_LENGTH_OFFSET = 28; private static final int CFH_EXTRA_LENGTH_OFFSET = 30; private static final int CFH_COMMENT_LENGTH_OFFSET = 32; private static final int CFH_DISK_NUMBER_OFFSET = 34; private static final int CFH_INTERNAL_ATTRIBUTES_OFFSET = 36; private static final int CFH_EXTERNAL_ATTRIBUTES_OFFSET = 38; private static final int CFH_LFH_OFFSET = 42; private static final int CFH_FILENAME_OFFSET = 46; protected boolean finished = false; public static final int DEFLATED = java.util.zip.ZipEntry.DEFLATED; public static final int DEFAULT_COMPRESSION = Deflater.DEFAULT_COMPRESSION; public static final int STORED = java.util.zip.ZipEntry.STORED; static final String DEFAULT_ENCODING = ZipEncodingHelper.UTF8; @Deprecated public static final int EFS_FLAG = GeneralPurposeBit.UFT8_NAMES_FLAG; private static final byte[] EMPTY = new byte[0]; private CurrentEntry entry; private String comment = \"\"; private int level = DEFAULT_COMPRESSION; private boolean hasCompressionLevelChanged = false; private int method = java.util.zip.ZipEntry.DEFLATED; private final List<ZipArchiveEntry> entries = new LinkedList<>(); private final StreamCompressor streamCompressor; private long cdOffset = 0; private long cdLength = 0; private static final byte[] ZERO = {0, 0};\n\n    \n    private static final byte[] LZERO = {0, 0, 0, 0}; private static final byte[] ONE = ZipLong.getBytes(1L); private final Map<ZipArchiveEntry, EntryMetaData> metaData = new HashMap<>(); private String encoding = DEFAULT_ENCODING; private ZipEncoding zipEncoding = ZipEncodingHelper.getZipEncoding(DEFAULT_ENCODING); protected final Deflater def; private final SeekableByteChannel channel; private final OutputStream out; private boolean useUTF8Flag = true; private boolean fallbackToUTF8 = false; private UnicodeExtraFieldPolicy createUnicodeExtraFields = UnicodeExtraFieldPolicy.NEVER; private boolean hasUsedZip64 = false; private Zip64Mode zip64Mode = Zip64Mode.AsNeeded; private final byte[] copyBuffer = new byte[32768]; private final Calendar calendarInstance = Calendar.getInstance(); public ZipArchiveOutputStream(final OutputStream out) {\n        this.out = out;\n        this.channel = null;\n        def = new Deflater(level, true);\n        streamCompressor = StreamCompressor.create(out, def);\n    }\n\n    \n    public ZipArchiveOutputStream(final File file) throws IOException {\n        def = new Deflater(level, true);\n        OutputStream o = null;\n        SeekableByteChannel _channel = null;\n        StreamCompressor _streamCompressor = null;\n        try {\n            _channel = Files.newByteChannel(file.toPath(),\n                EnumSet.of(StandardOpenOption.CREATE, StandardOpenOption.WRITE,\n                           StandardOpenOption.READ,\n                           StandardOpenOption.TRUNCATE_EXISTING));\n            \n            _streamCompressor = StreamCompressor.create(_channel, def); \n        } catch (final IOException e) {\n            IOUtils.closeQuietly(_channel);\n            _channel = null;\n            o = new FileOutputStream(file);\n            _streamCompressor = StreamCompressor.create(o, def);\n        }\n        out = o;\n        channel = _channel;\n        streamCompressor = _streamCompressor;\n    }\n\n    \n    public ZipArchiveOutputStream(SeekableByteChannel channel) throws IOException {\n        this.channel = channel;\n        def = new Deflater(level, true);\n        streamCompressor = StreamCompressor.create(channel, def);\n        out = null;\n    }\n\n    \n    public boolean isSeekable() {\n        return channel != null;\n    }\n\n    \n    public void setEncoding(final String encoding) {\n        this.encoding = encoding;\n        this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n        if (useUTF8Flag && !ZipEncodingHelper.isUTF8(encoding)) {\n            useUTF8Flag = false;\n        }\n    }\n\n    \n    public String getEncoding() {\n        return encoding;\n    }\n\n    \n    public void setUseLanguageEncodingFlag(final boolean b) {\n        useUTF8Flag = b && ZipEncodingHelper.isUTF8(encoding);\n    }\n\n    \n    public void setCreateUnicodeExtraFields(final UnicodeExtraFieldPolicy b) {\n        createUnicodeExtraFields = b;\n    }\n\n    \n    public void setFallbackToUTF8(final boolean b) {\n        fallbackToUTF8 = b;\n    }\n\n    \n    public void setUseZip64(final Zip64Mode mode) {\n        zip64Mode = mode;\n    }\n\n    \n    @Override\n    public void finish() throws IOException {\n        if (finished) {\n            throw new IOException(\"This archive has already been finished\");\n        }\n\n        if (entry != null) {\n            throw new IOException(\"This archive contains unclosed entries.\");\n        }\n\n        cdOffset = streamCompressor.getTotalBytesWritten();\n        writeCentralDirectoryInChunks();\n\n        cdLength = streamCompressor.getTotalBytesWritten() - cdOffset;\n        writeZip64CentralDirectory();\n        writeCentralDirectoryEnd();\n        metaData.clear();\n        entries.clear();\n        streamCompressor.close();\n        finished = true;\n    }\n\n    private void writeCentralDirectoryInChunks() throws IOException {\n        final int NUM_PER_WRITE = 1000;\n        final ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(70 * NUM_PER_WRITE);\n        int count = 0;\n        for (final ZipArchiveEntry ze : entries) {\n            byteArrayOutputStream.write(createCentralFileHeader(ze));\n            if (++count > NUM_PER_WRITE){\n                writeCounted(byteArrayOutputStream.toByteArray());\n                byteArrayOutputStream.reset();\n                count = 0;\n            }\n        }\n        writeCounted(byteArrayOutputStream.toByteArray());\n    }\n\n    \n    @Override\n    public void closeArchiveEntry() throws IOException {\n        preClose();\n\n        flushDeflater();\n\n        final long bytesWritten = streamCompressor.getTotalBytesWritten() - entry.dataStart;\n        final long realCrc = streamCompressor.getCrc32();\n        entry.bytesRead = streamCompressor.getBytesRead();\n        final Zip64Mode effectiveMode = getEffectiveZip64Mode(entry.entry);\n        final boolean actuallyNeedsZip64 = handleSizesAndCrc(bytesWritten, realCrc, effectiveMode);\n        closeEntry(actuallyNeedsZip64, false);\n        streamCompressor.reset();\n    }\n\n    \n    private void closeCopiedEntry(final boolean phased) throws IOException {\n        preClose();\n        entry.bytesRead = entry.entry.getSize();\n        final Zip64Mode effectiveMode = getEffectiveZip64Mode(entry.entry);\n        final boolean actuallyNeedsZip64 = checkIfNeedsZip64(effectiveMode);\n        closeEntry(actuallyNeedsZip64, phased);\n    }\n\n    private void closeEntry(final boolean actuallyNeedsZip64, final boolean phased) throws IOException {\n        if (!phased && channel != null) {\n            rewriteSizesAndCrc(actuallyNeedsZip64);\n        }\n\n        if (!phased) {\n            writeDataDescriptor(entry.entry);\n        }\n        entry = null;\n    }\n\n    private void preClose() throws IOException {\n        if (finished) {\n            throw new IOException(\"Stream has already been finished\");\n        }\n\n        if (entry == null) {\n            throw new IOException(\"No current entry to close\");\n        }\n\n        if (!entry.hasWritten) {\n            write(EMPTY, 0, 0);\n        }\n    }\n\n    \n    public void addRawArchiveEntry(final ZipArchiveEntry entry, final InputStream rawStream) throws IOException {\n        final ZipArchiveEntry ae = new ZipArchiveEntry(entry);\n        if (hasZip64Extra(ae)) {\n            \n            \n            \n            ae.removeExtraField(Zip64ExtendedInformationExtraField.HEADER_ID);\n        }\n        final boolean is2PhaseSource = ae.getCrc() != ZipArchiveEntry.CRC_UNKNOWN\n                && ae.getSize() != ArchiveEntry.SIZE_UNKNOWN\n                && ae.getCompressedSize() != ArchiveEntry.SIZE_UNKNOWN;\n        putArchiveEntry(ae, is2PhaseSource);\n        copyFromZipInputStream(rawStream);\n        closeCopiedEntry(is2PhaseSource);\n    }\n\n    \n    private void flushDeflater() throws IOException {\n        if (entry.entry.getMethod() == DEFLATED) {\n            streamCompressor.flushDeflater();\n        }\n    }\n\n    \n    private boolean handleSizesAndCrc(final long bytesWritten, final long crc, final Zip64Mode effectiveMode) throws ZipException {\n        if (entry.entry.getMethod() == DEFLATED) {\n            \n            entry.entry.setSize(entry.bytesRead);\n            entry.entry.setCompressedSize(bytesWritten);\n            entry.entry.setCrc(crc);\n\n        } else if (channel == null) {\n            if (entry.entry.getCrc() != crc) {\n                throw new ZipException(\"bad CRC checksum for entry \"\n                                       + entry.entry.getName() + \": \"\n                                       + Long.toHexString(entry.entry.getCrc())\n                                       + \" instead of \"\n                                       + Long.toHexString(crc));\n            }\n\n            if (entry.entry.getSize() != bytesWritten) {\n                throw new ZipException(\"bad size for entry \"\n                                       + entry.entry.getName() + \": \"\n                                       + entry.entry.getSize()\n                                       + \" instead of \"\n                                       + bytesWritten);\n            }\n        } else { \n            entry.entry.setSize(bytesWritten);\n            entry.entry.setCompressedSize(bytesWritten);\n            entry.entry.setCrc(crc);\n        }\n\n        return checkIfNeedsZip64(effectiveMode);\n    }\n\n    \n    private boolean checkIfNeedsZip64(final Zip64Mode effectiveMode) throws ZipException {\n        final boolean actuallyNeedsZip64 = isZip64Required(entry.entry, effectiveMode);\n        if (actuallyNeedsZip64 && effectiveMode == Zip64Mode.Never) {\n            throw new Zip64RequiredException(Zip64RequiredException.getEntryTooBigMessage(entry.entry));\n        }\n        return actuallyNeedsZip64;\n    }\n\n    private boolean isZip64Required(final ZipArchiveEntry entry1, final Zip64Mode requestedMode) {\n        return requestedMode == Zip64Mode.Always || isTooLageForZip32(entry1);\n    }\n\n    private boolean isTooLageForZip32(final ZipArchiveEntry zipArchiveEntry) {\n        return zipArchiveEntry.getSize() >= ZIP64_MAGIC || zipArchiveEntry.getCompressedSize() >= ZIP64_MAGIC;\n    }\n\n    \n    private void rewriteSizesAndCrc(final boolean actuallyNeedsZip64) throws IOException {\n        final long save = channel.position();\n\n        channel.position(entry.localDataStart);\n        writeOut(ZipLong.getBytes(entry.entry.getCrc()));\n        if (!hasZip64Extra(entry.entry) || !actuallyNeedsZip64) {\n            writeOut(ZipLong.getBytes(entry.entry.getCompressedSize()));\n            writeOut(ZipLong.getBytes(entry.entry.getSize()));\n        } else {\n            writeOut(ZipLong.ZIP64_MAGIC.getBytes());\n            writeOut(ZipLong.ZIP64_MAGIC.getBytes());\n        }\n\n        if (hasZip64Extra(entry.entry)) {\n            final ByteBuffer name = getName(entry.entry);\n            final int nameLen = name.limit() - name.position();\n            \n            channel.position(entry.localDataStart + 3 * WORD + 2 * SHORT\n                             + nameLen + 2 * SHORT);\n            \n            \n            writeOut(ZipEightByteInteger.getBytes(entry.entry.getSize()));\n            writeOut(ZipEightByteInteger.getBytes(entry.entry.getCompressedSize()));\n\n            if (!actuallyNeedsZip64) {\n                \n                \n                channel.position(entry.localDataStart  - 5 * SHORT);\n                writeOut(ZipShort.getBytes(versionNeededToExtract(entry.entry.getMethod(), false, false)));\n\n                \n                \n                entry.entry.removeExtraField(Zip64ExtendedInformationExtraField\n                                             .HEADER_ID);\n                entry.entry.setExtra();\n\n                \n                \n                if (entry.causedUseOfZip64) {\n                    hasUsedZip64 = false;\n                }\n            }\n        }\n        channel.position(save);\n    }\n\n    \n    @Override\n    public void putArchiveEntry(final ArchiveEntry archiveEntry) throws IOException {\n        putArchiveEntry(archiveEntry, false);\n    }\n\n    \n    private void putArchiveEntry(final ArchiveEntry archiveEntry, final boolean phased) throws IOException {\n        if (finished) {\n            throw new IOException(\"Stream has already been finished\");\n        }\n\n        if (entry != null) {\n            closeArchiveEntry();\n        }\n\n        entry = new CurrentEntry((ZipArchiveEntry) archiveEntry);\n        entries.add(entry.entry);\n\n        setDefaults(entry.entry);\n\n        final Zip64Mode effectiveMode = getEffectiveZip64Mode(entry.entry);\n        validateSizeInformation(effectiveMode);\n\n        if (shouldAddZip64Extra(entry.entry, effectiveMode)) {\n\n            final Zip64ExtendedInformationExtraField z64 = getZip64Extra(entry.entry);\n\n            ZipEightByteInteger size, compressedSize;\n            if (phased) {\n                \n                size = new ZipEightByteInteger(entry.entry.getSize());\n                compressedSize = new ZipEightByteInteger(entry.entry.getCompressedSize());\n            } else if (entry.entry.getMethod() == STORED\n                    && entry.entry.getSize() != ArchiveEntry.SIZE_UNKNOWN) {\n                \n                compressedSize = size = new ZipEightByteInteger(entry.entry.getSize());\n            } else {\n                \n                \n                compressedSize = size = ZipEightByteInteger.ZERO;\n            }\n            z64.setSize(size);\n            z64.setCompressedSize(compressedSize);\n            entry.entry.setExtra();\n        }\n\n        if (entry.entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {\n            def.setLevel(level);\n            hasCompressionLevelChanged = false;\n        }\n        writeLocalFileHeader((ZipArchiveEntry) archiveEntry, phased);\n    }\n\n    \n    private void setDefaults(final ZipArchiveEntry entry) {\n        if (entry.getMethod() == -1) { \n            entry.setMethod(method);\n        }\n\n        if (entry.getTime() == -1) { \n            entry.setTime(System.currentTimeMillis());\n        }\n    }\n\n    \n    private void validateSizeInformation(final Zip64Mode effectiveMode) throws ZipException {\n        \n        if (entry.entry.getMethod() == STORED && channel == null) {\n            if (entry.entry.getSize() == ArchiveEntry.SIZE_UNKNOWN) {\n                throw new ZipException(\"uncompressed size is required for\"\n                                       + \" STORED method when not writing to a\"\n                                       + \" file\");\n            }\n            if (entry.entry.getCrc() == ZipArchiveEntry.CRC_UNKNOWN) {\n                throw new ZipException(\"crc checksum is required for STORED\"\n                                       + \" method when not writing to a file\");\n            }\n            entry.entry.setCompressedSize(entry.entry.getSize());\n        }\n\n        if ((entry.entry.getSize() >= ZIP64_MAGIC\n             || entry.entry.getCompressedSize() >= ZIP64_MAGIC)\n            && effectiveMode == Zip64Mode.Never) {\n            throw new Zip64RequiredException(Zip64RequiredException\n                                             .getEntryTooBigMessage(entry.entry));\n        }\n    }\n\n    \n    private boolean shouldAddZip64Extra(final ZipArchiveEntry entry, final Zip64Mode mode) {\n        return mode == Zip64Mode.Always\n            || entry.getSize() >= ZIP64_MAGIC\n            || entry.getCompressedSize() >= ZIP64_MAGIC\n            || (entry.getSize() == ArchiveEntry.SIZE_UNKNOWN\n                && channel != null && mode != Zip64Mode.Never);\n    }\n\n    \n    public void setComment(final String comment) {\n        this.comment = comment;\n    }\n\n    \n    public void setLevel(final int level) {\n        if (level < Deflater.DEFAULT_COMPRESSION\n            || level > Deflater.BEST_COMPRESSION) {\n            throw new IllegalArgumentException(\"Invalid compression level: \"\n                                               + level);\n        }\n        hasCompressionLevelChanged = (this.level != level);\n        this.level = level;\n    }\n\n    \n    public void setMethod(final int method) {\n        this.method = method;\n    }\n\n    \n    @Override\n    public boolean canWriteEntryData(final ArchiveEntry ae) {\n        if (ae instanceof ZipArchiveEntry) {\n            final ZipArchiveEntry zae = (ZipArchiveEntry) ae;\n            return zae.getMethod() != ZipMethod.IMPLODING.getCode()\n                && zae.getMethod() != ZipMethod.UNSHRINKING.getCode()\n                && ZipUtil.canHandleEntryData(zae);\n        }\n        return false;\n    }\n\n    \n    @Override\n    public void write(final byte[] b, final int offset, final int length) throws IOException {\n        if (entry == null) {\n            throw new IllegalStateException(\"No current entry\");\n        }\n        ZipUtil.checkRequestedFeatures(entry.entry);\n        final long writtenThisTime = streamCompressor.write(b, offset, length, entry.entry.getMethod());\n        count(writtenThisTime);\n    }\n\n    \n    private void writeCounted(final byte[] data) throws IOException {\n        streamCompressor.writeCounted(data);\n    }\n\n    private void copyFromZipInputStream(final InputStream src) throws IOException {\n        if (entry == null) {\n            throw new IllegalStateException(\"No current entry\");\n        }\n        ZipUtil.checkRequestedFeatures(entry.entry);\n        entry.hasWritten = true;\n        int length;\n        while ((length = src.read(copyBuffer)) >= 0 )\n        {\n            streamCompressor.writeCounted(copyBuffer, 0, length);\n            count( length );\n        }\n    }\n\n    \n    @Override\n    public void close() throws IOException {\n        if (!finished) {\n            finish();\n        }\n        destroy();\n    }\n\n    \n    @Override\n    public void flush() throws IOException {\n        if (out != null) {\n            out.flush();\n        }\n    }\n\n    \n    \n    static final byte[] LFH_SIG = ZipLong.LFH_SIG.getBytes(); static final byte[] DD_SIG = ZipLong.DD_SIG.getBytes(); static final byte[] CFH_SIG = ZipLong.CFH_SIG.getBytes(); static final byte[] EOCD_SIG = ZipLong.getBytes(0X06054B50L); static final byte[] ZIP64_EOCD_SIG = ZipLong.getBytes(0X06064B50L); static final byte[] ZIP64_EOCD_LOC_SIG = ZipLong.getBytes(0X07064B50L); protected final void deflate() throws IOException {\n        streamCompressor.deflate();\n    }\n\n    \n    protected void writeLocalFileHeader(final ZipArchiveEntry ze) throws IOException {\n        writeLocalFileHeader(ze, false);\n    }\n\n    private void writeLocalFileHeader(final ZipArchiveEntry ze, final boolean phased) throws IOException {\n        final boolean encodable = zipEncoding.canEncode(ze.getName());\n        final ByteBuffer name = getName(ze);\n\n        if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n            addUnicodeExtraFields(ze, encodable, name);\n        }\n\n        final long localHeaderStart = streamCompressor.getTotalBytesWritten();\n        final byte[] localHeader = createLocalFileHeader(ze, name, encodable, phased, localHeaderStart);\n        metaData.put(ze, new EntryMetaData(localHeaderStart, usesDataDescriptor(ze.getMethod(), phased)));\n        entry.localDataStart = localHeaderStart + LFH_CRC_OFFSET; \n        writeCounted(localHeader);\n        entry.dataStart = streamCompressor.getTotalBytesWritten();\n    }\n\n\n    private byte[] createLocalFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final boolean encodable, final boolean phased, long archiveOffset) throws IOException {\n        ResourceAlignmentExtraField oldAlignmentEx =\n            (ResourceAlignmentExtraField) ze.getExtraField(ResourceAlignmentExtraField.ID);\n        if (oldAlignmentEx != null) {\n            ze.removeExtraField(ResourceAlignmentExtraField.ID);\n        }\n\n        int alignment = ze.getAlignment();\n        if (alignment <= 0 && oldAlignmentEx != null) {\n            alignment = oldAlignmentEx.getAlignment();\n        }\n\n        if (alignment > 1 || (oldAlignmentEx != null && !oldAlignmentEx.allowMethodChange())) {\n            int oldLength = LFH_FILENAME_OFFSET +\n                            name.limit() - name.position() +\n                            ze.getLocalFileDataExtra().length;\n\n            int padding = (int) ((-archiveOffset - oldLength - ZipExtraField.EXTRAFIELD_HEADER_SIZE\n                            - ResourceAlignmentExtraField.BASE_SIZE) &\n                            (alignment - 1));\n            ze.addExtraField(new ResourceAlignmentExtraField(alignment,\n                            oldAlignmentEx != null && oldAlignmentEx.allowMethodChange(), padding));\n        }\n\n        final byte[] extra = ze.getLocalFileDataExtra();\n        final int nameLen = name.limit() - name.position();\n        final int len = LFH_FILENAME_OFFSET + nameLen + extra.length;\n        final byte[] buf = new byte[len];\n\n        System.arraycopy(LFH_SIG,  0, buf, LFH_SIG_OFFSET, WORD);\n\n        \n        final int zipMethod = ze.getMethod();\n        final boolean dataDescriptor = usesDataDescriptor(zipMethod, phased);\n\n        putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET);\n\n        final GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(!encodable && fallbackToUTF8, dataDescriptor);\n        generalPurposeBit.encode(buf, LFH_GPB_OFFSET);\n\n        \n        putShort(zipMethod, buf, LFH_METHOD_OFFSET);\n\n        ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, LFH_TIME_OFFSET);\n\n        \n        if (phased){\n            putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n        } else if (zipMethod == DEFLATED || channel != null) {\n            System.arraycopy(LZERO, 0, buf, LFH_CRC_OFFSET, WORD);\n        } else {\n            putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n        }\n\n        \n        \n        if (hasZip64Extra(entry.entry)){\n            \n            \n            \n            ZipLong.ZIP64_MAGIC.putLong(buf, LFH_COMPRESSED_SIZE_OFFSET);\n            ZipLong.ZIP64_MAGIC.putLong(buf, LFH_ORIGINAL_SIZE_OFFSET);\n        } else if (phased) {\n            putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n            putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n        } else if (zipMethod == DEFLATED || channel != null) {\n            System.arraycopy(LZERO, 0, buf, LFH_COMPRESSED_SIZE_OFFSET, WORD);\n            System.arraycopy(LZERO, 0, buf, LFH_ORIGINAL_SIZE_OFFSET, WORD);\n        } else { \n            putLong(ze.getSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n            putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n        }\n        \n        putShort(nameLen, buf, LFH_FILENAME_LENGTH_OFFSET);\n\n        \n        putShort(extra.length, buf, LFH_EXTRA_LENGTH_OFFSET);\n\n        \n        System.arraycopy( name.array(), name.arrayOffset(), buf, LFH_FILENAME_OFFSET, nameLen);\n\n        \n        System.arraycopy(extra, 0, buf, LFH_FILENAME_OFFSET + nameLen, extra.length);\n\n        return buf;\n    }\n\n\n    \n    private void addUnicodeExtraFields(final ZipArchiveEntry ze, final boolean encodable, final ByteBuffer name) throws IOException {\n        if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n            || !encodable) {\n            ze.addExtraField(new UnicodePathExtraField(ze.getName(),\n                                                       name.array(),\n                                                       name.arrayOffset(),\n                                                       name.limit()\n                                                       - name.position()));\n        }\n\n        final String comm = ze.getComment();\n        if (comm != null && !\"\".equals(comm)) {\n\n            final boolean commentEncodable = zipEncoding.canEncode(comm);\n\n            if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                || !commentEncodable) {\n                final ByteBuffer commentB = getEntryEncoding(ze).encode(comm);\n                ze.addExtraField(new UnicodeCommentExtraField(comm,\n                                                              commentB.array(),\n                                                              commentB.arrayOffset(),\n                                                              commentB.limit()\n                                                              - commentB.position())\n                                 );\n            }\n        }\n    }\n\n    \n    protected void writeDataDescriptor(final ZipArchiveEntry ze) throws IOException {\n        if (!usesDataDescriptor(ze.getMethod(), false)) {\n            return;\n        }\n        writeCounted(DD_SIG);\n        writeCounted(ZipLong.getBytes(ze.getCrc()));\n        if (!hasZip64Extra(ze)) {\n            writeCounted(ZipLong.getBytes(ze.getCompressedSize()));\n            writeCounted(ZipLong.getBytes(ze.getSize()));\n        } else {\n            writeCounted(ZipEightByteInteger.getBytes(ze.getCompressedSize()));\n            writeCounted(ZipEightByteInteger.getBytes(ze.getSize()));\n        }\n    }\n\n    \n    protected void writeCentralFileHeader(final ZipArchiveEntry ze) throws IOException {\n        final byte[] centralFileHeader = createCentralFileHeader(ze);\n        writeCounted(centralFileHeader);\n    }\n\n    private byte[] createCentralFileHeader(final ZipArchiveEntry ze) throws IOException {\n\n        final EntryMetaData entryMetaData = metaData.get(ze);\n        final boolean needsZip64Extra = hasZip64Extra(ze)\n                || ze.getCompressedSize() >= ZIP64_MAGIC\n                || ze.getSize() >= ZIP64_MAGIC\n                || entryMetaData.offset >= ZIP64_MAGIC\n                || zip64Mode == Zip64Mode.Always;\n\n        if (needsZip64Extra && zip64Mode == Zip64Mode.Never) {\n            \n            \n            \n            throw new Zip64RequiredException(Zip64RequiredException\n                    .ARCHIVE_TOO_BIG_MESSAGE);\n        }\n\n\n        handleZip64Extra(ze, entryMetaData.offset, needsZip64Extra);\n\n        return createCentralFileHeader(ze, getName(ze), entryMetaData, needsZip64Extra);\n    }\n\n    \n    private byte[] createCentralFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final EntryMetaData entryMetaData, final boolean needsZip64Extra) throws IOException {\n        final byte[] extra = ze.getCentralDirectoryExtra();\n\n        \n        String comm = ze.getComment();\n        if (comm == null) {\n            comm = \"\";\n        }\n\n        final ByteBuffer commentB = getEntryEncoding(ze).encode(comm);\n        final int nameLen = name.limit() - name.position();\n        final int commentLen = commentB.limit() - commentB.position();\n        final int len= CFH_FILENAME_OFFSET + nameLen + extra.length + commentLen;\n        final byte[] buf = new byte[len];\n\n        System.arraycopy(CFH_SIG,  0, buf, CFH_SIG_OFFSET, WORD);\n\n        \n        \n        putShort((ze.getPlatform() << 8) | (!hasUsedZip64 ? DATA_DESCRIPTOR_MIN_VERSION : ZIP64_MIN_VERSION),\n                buf, CFH_VERSION_MADE_BY_OFFSET);\n\n        final int zipMethod = ze.getMethod();\n        final boolean encodable = zipEncoding.canEncode(ze.getName());\n        putShort(versionNeededToExtract(zipMethod, needsZip64Extra, entryMetaData.usesDataDescriptor),\n            buf, CFH_VERSION_NEEDED_OFFSET);\n        getGeneralPurposeBits(!encodable && fallbackToUTF8, entryMetaData.usesDataDescriptor).encode(buf, CFH_GPB_OFFSET);\n\n        \n        putShort(zipMethod, buf, CFH_METHOD_OFFSET);\n\n\n        \n        ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, CFH_TIME_OFFSET);\n\n        \n        \n        \n        putLong(ze.getCrc(), buf, CFH_CRC_OFFSET);\n        if (ze.getCompressedSize() >= ZIP64_MAGIC\n                || ze.getSize() >= ZIP64_MAGIC\n                || zip64Mode == Zip64Mode.Always) {\n            ZipLong.ZIP64_MAGIC.putLong(buf, CFH_COMPRESSED_SIZE_OFFSET);\n            ZipLong.ZIP64_MAGIC.putLong(buf, CFH_ORIGINAL_SIZE_OFFSET);\n        } else {\n            putLong(ze.getCompressedSize(), buf, CFH_COMPRESSED_SIZE_OFFSET);\n            putLong(ze.getSize(), buf, CFH_ORIGINAL_SIZE_OFFSET);\n        }\n\n        putShort(nameLen, buf, CFH_FILENAME_LENGTH_OFFSET);\n\n        \n        putShort(extra.length, buf, CFH_EXTRA_LENGTH_OFFSET);\n\n        putShort(commentLen, buf, CFH_COMMENT_LENGTH_OFFSET);\n\n        \n        System.arraycopy(ZERO, 0, buf, CFH_DISK_NUMBER_OFFSET, SHORT);\n\n        \n        putShort(ze.getInternalAttributes(), buf, CFH_INTERNAL_ATTRIBUTES_OFFSET);\n\n        \n        putLong(ze.getExternalAttributes(), buf, CFH_EXTERNAL_ATTRIBUTES_OFFSET);\n\n        \n        if (entryMetaData.offset >= ZIP64_MAGIC || zip64Mode == Zip64Mode.Always) {\n            putLong(ZIP64_MAGIC, buf, CFH_LFH_OFFSET);\n        } else {\n            putLong(Math.min(entryMetaData.offset, ZIP64_MAGIC), buf, CFH_LFH_OFFSET);\n        }\n\n        \n        System.arraycopy(name.array(), name.arrayOffset(), buf, CFH_FILENAME_OFFSET, nameLen);\n\n        final int extraStart = CFH_FILENAME_OFFSET + nameLen;\n        System.arraycopy(extra, 0, buf, extraStart, extra.length);\n\n        final int commentStart = extraStart + extra.length;\n\n        \n        System.arraycopy(commentB.array(), commentB.arrayOffset(), buf, commentStart, commentLen);\n        return buf;\n    }\n\n    \n    private void handleZip64Extra(final ZipArchiveEntry ze, final long lfhOffset, final boolean needsZip64Extra) {\n        if (needsZip64Extra) {\n            final Zip64ExtendedInformationExtraField z64 = getZip64Extra(ze);\n            if (ze.getCompressedSize() >= ZIP64_MAGIC\n                || ze.getSize() >= ZIP64_MAGIC\n                || zip64Mode == Zip64Mode.Always) {\n                z64.setCompressedSize(new ZipEightByteInteger(ze.getCompressedSize()));\n                z64.setSize(new ZipEightByteInteger(ze.getSize()));\n            } else {\n                \n                z64.setCompressedSize(null);\n                z64.setSize(null);\n            }\n            if (lfhOffset >= ZIP64_MAGIC || zip64Mode == Zip64Mode.Always) {\n                z64.setRelativeHeaderOffset(new ZipEightByteInteger(lfhOffset));\n            }\n            ze.setExtra();\n        }\n    }\n\n    \n    protected void writeCentralDirectoryEnd() throws IOException {\n        writeCounted(EOCD_SIG);\n\n        \n        writeCounted(ZERO);\n        writeCounted(ZERO);\n\n        \n        final int numberOfEntries = entries.size();\n        if (numberOfEntries > ZIP64_MAGIC_SHORT\n            && zip64Mode == Zip64Mode.Never) {\n            throw new Zip64RequiredException(Zip64RequiredException\n                                             .TOO_MANY_ENTRIES_MESSAGE);\n        }\n        if (cdOffset > ZIP64_MAGIC && zip64Mode == Zip64Mode.Never) {\n            throw new Zip64RequiredException(Zip64RequiredException\n                                             .ARCHIVE_TOO_BIG_MESSAGE);\n        }\n\n        final byte[] num = ZipShort.getBytes(Math.min(numberOfEntries,\n                                                ZIP64_MAGIC_SHORT));\n        writeCounted(num);\n        writeCounted(num);\n\n        \n        writeCounted(ZipLong.getBytes(Math.min(cdLength, ZIP64_MAGIC)));\n        writeCounted(ZipLong.getBytes(Math.min(cdOffset, ZIP64_MAGIC)));\n\n        \n        final ByteBuffer data = this.zipEncoding.encode(comment);\n        final int dataLen = data.limit() - data.position();\n        writeCounted(ZipShort.getBytes(dataLen));\n        streamCompressor.writeCounted(data.array(), data.arrayOffset(), dataLen);\n    }\n\n    \n    protected void writeZip64CentralDirectory() throws IOException {\n        if (zip64Mode == Zip64Mode.Never) {\n            return;\n        }\n\n        if (!hasUsedZip64\n            && (cdOffset >= ZIP64_MAGIC || cdLength >= ZIP64_MAGIC\n                || entries.size() >= ZIP64_MAGIC_SHORT)) {\n            \n            hasUsedZip64 = true;\n        }\n\n        if (!hasUsedZip64) {\n            return;\n        }\n\n        final long offset = streamCompressor.getTotalBytesWritten();\n\n        writeOut(ZIP64_EOCD_SIG);\n        \n        \n        writeOut(ZipEightByteInteger\n                 .getBytes(SHORT   \n                           + SHORT \n                           + WORD  \n                           + WORD  \n                           + DWORD \n                           + DWORD \n                           + DWORD \n                           + (long) DWORD \n                           ));\n\n        \n        writeOut(ZipShort.getBytes(ZIP64_MIN_VERSION));\n        writeOut(ZipShort.getBytes(ZIP64_MIN_VERSION));\n\n        \n        writeOut(LZERO);\n        writeOut(LZERO);\n\n        \n        final byte[] num = ZipEightByteInteger.getBytes(entries.size());\n        writeOut(num);\n        writeOut(num);\n\n        \n        writeOut(ZipEightByteInteger.getBytes(cdLength));\n        writeOut(ZipEightByteInteger.getBytes(cdOffset));\n\n        \n\n        \n        writeOut(ZIP64_EOCD_LOC_SIG);\n\n        \n        writeOut(LZERO);\n        \n        writeOut(ZipEightByteInteger.getBytes(offset));\n        \n        writeOut(ONE);\n    }\n\n    \n    protected final void writeOut(final byte[] data) throws IOException {\n        streamCompressor.writeOut(data, 0, data.length);\n    }\n\n\n    \n    protected final void writeOut(final byte[] data, final int offset, final int length) throws IOException {\n        streamCompressor.writeOut(data, offset, length);\n    }\n\n\n    private GeneralPurposeBit getGeneralPurposeBits(final boolean utfFallback, boolean usesDataDescriptor) {\n        final GeneralPurposeBit b = new GeneralPurposeBit();\n        b.useUTF8ForNames(useUTF8Flag || utfFallback);\n        if (usesDataDescriptor) {\n            b.useDataDescriptor(true);\n        }\n        return b;\n    }\n\n    private int versionNeededToExtract(final int zipMethod, final boolean zip64, final boolean usedDataDescriptor) {\n        if (zip64) {\n            return ZIP64_MIN_VERSION;\n        }\n        if (usedDataDescriptor) {\n            return DATA_DESCRIPTOR_MIN_VERSION;\n        }\n        return versionNeededToExtractMethod(zipMethod);\n    }\n\n    private boolean usesDataDescriptor(final int zipMethod, boolean phased) {\n        return !phased && zipMethod == DEFLATED && channel == null;\n    }\n\n    private int versionNeededToExtractMethod(int zipMethod) {\n        return zipMethod == DEFLATED ? DEFLATE_MIN_VERSION : INITIAL_VERSION;\n    }\n\n    \n    @Override\n    public ArchiveEntry createArchiveEntry(final File inputFile, final String entryName) throws IOException {\n        if (finished) {\n            throw new IOException(\"Stream has already been finished\");\n        }\n        return new ZipArchiveEntry(inputFile, entryName);\n    }\n\n    \n    private Zip64ExtendedInformationExtraField getZip64Extra(final ZipArchiveEntry ze) {\n        if (entry != null) {\n            entry.causedUseOfZip64 = !hasUsedZip64;\n        }\n        hasUsedZip64 = true;\n        Zip64ExtendedInformationExtraField z64 =\n            (Zip64ExtendedInformationExtraField)\n            ze.getExtraField(Zip64ExtendedInformationExtraField\n                             .HEADER_ID);\n        if (z64 == null) {\n            \n            z64 = new Zip64ExtendedInformationExtraField();\n        }\n\n        \n        ze.addAsFirstExtraField(z64);\n\n        return z64;\n    }\n\n    \n    private boolean hasZip64Extra(final ZipArchiveEntry ze) {\n        return ze.getExtraField(Zip64ExtendedInformationExtraField\n                                .HEADER_ID)\n            != null;\n    }\n\n    \n    private Zip64Mode getEffectiveZip64Mode(final ZipArchiveEntry ze) {\n        if (zip64Mode != Zip64Mode.AsNeeded\n            || channel != null\n            || ze.getMethod() != DEFLATED\n            || ze.getSize() != ArchiveEntry.SIZE_UNKNOWN) {\n            return zip64Mode;\n        }\n        return Zip64Mode.Never;\n    }\n\n    private ZipEncoding getEntryEncoding(final ZipArchiveEntry ze) {\n        final boolean encodable = zipEncoding.canEncode(ze.getName());\n        return !encodable && fallbackToUTF8\n            ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n    }\n\n    private ByteBuffer getName(final ZipArchiveEntry ze) throws IOException {\n        return getEntryEncoding(ze).encode(ze.getName());\n    }\n\n    \n    void destroy() throws IOException {\n        if (channel != null) {\n            channel.close();\n        }\n        if (out != null) {\n            out.close();\n        }\n    }\n\n    \n    public static final class UnicodeExtraFieldPolicy { public static final UnicodeExtraFieldPolicy ALWAYS = new UnicodeExtraFieldPolicy(\"always\"); public static final UnicodeExtraFieldPolicy NEVER = new UnicodeExtraFieldPolicy(\"never\"); public static final UnicodeExtraFieldPolicy NOT_ENCODEABLE = new UnicodeExtraFieldPolicy(\"not encodeable\"); private final String name; private UnicodeExtraFieldPolicy(final String n) {\n            name = n;\n        }\n        @Override\n        public String toString() {\n            return name;\n        }\n    }\n\n    \n    private static final class CurrentEntry { private CurrentEntry(final ZipArchiveEntry entry) {\n            this.entry = entry;\n        }\n        \n        private final ZipArchiveEntry entry; private long localDataStart = 0; private long dataStart = 0; private long bytesRead = 0; private boolean causedUseOfZip64 = false; private boolean hasWritten; } private static final class EntryMetaData { private final long offset; private final boolean usesDataDescriptor; private EntryMetaData(long offset, boolean usesDataDescriptor) {\n            this.offset = offset;\n            this.usesDataDescriptor = usesDataDescriptor;\n        }\n    }\n}\n",
      "buggy_signatures": [
        "public ZipArchiveOutputStream(final File file) throws IOException",
        "public ZipArchiveOutputStream(SeekableByteChannel channel) throws IOException",
        "public boolean isSeekable()",
        "public void setEncoding(final String encoding)",
        "public String getEncoding()",
        "public void setUseLanguageEncodingFlag(final boolean b)",
        "public void setCreateUnicodeExtraFields(final UnicodeExtraFieldPolicy b)",
        "public void setFallbackToUTF8(final boolean b)",
        "public void setUseZip64(final Zip64Mode mode)",
        "public void finish() throws IOException",
        "private void writeCentralDirectoryInChunks() throws IOException",
        "public void closeArchiveEntry() throws IOException",
        "private void closeCopiedEntry(final boolean phased) throws IOException",
        "private void closeEntry(final boolean actuallyNeedsZip64, final boolean phased) throws IOException",
        "private void preClose() throws IOException",
        "public void addRawArchiveEntry(final ZipArchiveEntry entry, final InputStream rawStream) throws IOException",
        "private void flushDeflater() throws IOException",
        "private boolean handleSizesAndCrc(final long bytesWritten, final long crc, final Zip64Mode effectiveMode) throws ZipException",
        "private boolean checkIfNeedsZip64(final Zip64Mode effectiveMode) throws ZipException",
        "private boolean isZip64Required(final ZipArchiveEntry entry1, final Zip64Mode requestedMode)",
        "private boolean isTooLageForZip32(final ZipArchiveEntry zipArchiveEntry)",
        "private void rewriteSizesAndCrc(final boolean actuallyNeedsZip64) throws IOException",
        "public void putArchiveEntry(final ArchiveEntry archiveEntry) throws IOException",
        "private void putArchiveEntry(final ArchiveEntry archiveEntry, final boolean phased) throws IOException",
        "private void setDefaults(final ZipArchiveEntry entry)",
        "private void validateSizeInformation(final Zip64Mode effectiveMode) throws ZipException",
        "private boolean shouldAddZip64Extra(final ZipArchiveEntry entry, final Zip64Mode mode)",
        "public void setComment(final String comment)",
        "public void setLevel(final int level)",
        "public void setMethod(final int method)",
        "public boolean canWriteEntryData(final ArchiveEntry ae)",
        "public void write(final byte[] b, final int offset, final int length) throws IOException",
        "private void writeCounted(final byte[] data) throws IOException",
        "private void copyFromZipInputStream(final InputStream src) throws IOException",
        "public void close() throws IOException",
        "public void flush() throws IOException",
        "protected void writeLocalFileHeader(final ZipArchiveEntry ze) throws IOException",
        "private void writeLocalFileHeader(final ZipArchiveEntry ze, final boolean phased) throws IOException",
        "private byte[] createLocalFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final boolean encodable, final boolean phased, long archiveOffset) throws IOException",
        "private void addUnicodeExtraFields(final ZipArchiveEntry ze, final boolean encodable, final ByteBuffer name) throws IOException",
        "protected void writeDataDescriptor(final ZipArchiveEntry ze) throws IOException",
        "protected void writeCentralFileHeader(final ZipArchiveEntry ze) throws IOException",
        "private byte[] createCentralFileHeader(final ZipArchiveEntry ze) throws IOException",
        "private byte[] createCentralFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final EntryMetaData entryMetaData, final boolean needsZip64Extra) throws IOException",
        "private void handleZip64Extra(final ZipArchiveEntry ze, final long lfhOffset, final boolean needsZip64Extra)",
        "protected void writeCentralDirectoryEnd() throws IOException",
        "protected void writeZip64CentralDirectory() throws IOException",
        "protected final void writeOut(final byte[] data) throws IOException",
        "protected final void writeOut(final byte[] data, final int offset, final int length) throws IOException",
        "private GeneralPurposeBit getGeneralPurposeBits(final boolean utfFallback, boolean usesDataDescriptor)",
        "private int versionNeededToExtract(final int zipMethod, final boolean zip64, final boolean usedDataDescriptor)",
        "private boolean usesDataDescriptor(final int zipMethod)",
        "private int versionNeededToExtractMethod(int zipMethod)",
        "public ArchiveEntry createArchiveEntry(final File inputFile, final String entryName) throws IOException",
        "private Zip64ExtendedInformationExtraField getZip64Extra(final ZipArchiveEntry ze)",
        "private boolean hasZip64Extra(final ZipArchiveEntry ze)",
        "private Zip64Mode getEffectiveZip64Mode(final ZipArchiveEntry ze)",
        "private ZipEncoding getEntryEncoding(final ZipArchiveEntry ze)",
        "private ByteBuffer getName(final ZipArchiveEntry ze) throws IOException",
        "public String toString()",
        "private static final class CurrentEntry { private CurrentEntry(final ZipArchiveEntry entry)"
      ],
      "fixed_signatures": [
        "public ZipArchiveOutputStream(final File file) throws IOException",
        "public ZipArchiveOutputStream(SeekableByteChannel channel) throws IOException",
        "public boolean isSeekable()",
        "public void setEncoding(final String encoding)",
        "public String getEncoding()",
        "public void setUseLanguageEncodingFlag(final boolean b)",
        "public void setCreateUnicodeExtraFields(final UnicodeExtraFieldPolicy b)",
        "public void setFallbackToUTF8(final boolean b)",
        "public void setUseZip64(final Zip64Mode mode)",
        "public void finish() throws IOException",
        "private void writeCentralDirectoryInChunks() throws IOException",
        "public void closeArchiveEntry() throws IOException",
        "private void closeCopiedEntry(final boolean phased) throws IOException",
        "private void closeEntry(final boolean actuallyNeedsZip64, final boolean phased) throws IOException",
        "private void preClose() throws IOException",
        "public void addRawArchiveEntry(final ZipArchiveEntry entry, final InputStream rawStream) throws IOException",
        "private void flushDeflater() throws IOException",
        "private boolean handleSizesAndCrc(final long bytesWritten, final long crc, final Zip64Mode effectiveMode) throws ZipException",
        "private boolean checkIfNeedsZip64(final Zip64Mode effectiveMode) throws ZipException",
        "private boolean isZip64Required(final ZipArchiveEntry entry1, final Zip64Mode requestedMode)",
        "private boolean isTooLageForZip32(final ZipArchiveEntry zipArchiveEntry)",
        "private void rewriteSizesAndCrc(final boolean actuallyNeedsZip64) throws IOException",
        "public void putArchiveEntry(final ArchiveEntry archiveEntry) throws IOException",
        "private void putArchiveEntry(final ArchiveEntry archiveEntry, final boolean phased) throws IOException",
        "private void setDefaults(final ZipArchiveEntry entry)",
        "private void validateSizeInformation(final Zip64Mode effectiveMode) throws ZipException",
        "private boolean shouldAddZip64Extra(final ZipArchiveEntry entry, final Zip64Mode mode)",
        "public void setComment(final String comment)",
        "public void setLevel(final int level)",
        "public void setMethod(final int method)",
        "public boolean canWriteEntryData(final ArchiveEntry ae)",
        "public void write(final byte[] b, final int offset, final int length) throws IOException",
        "private void writeCounted(final byte[] data) throws IOException",
        "private void copyFromZipInputStream(final InputStream src) throws IOException",
        "public void close() throws IOException",
        "public void flush() throws IOException",
        "protected void writeLocalFileHeader(final ZipArchiveEntry ze) throws IOException",
        "private void writeLocalFileHeader(final ZipArchiveEntry ze, final boolean phased) throws IOException",
        "private byte[] createLocalFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final boolean encodable, final boolean phased, long archiveOffset) throws IOException",
        "private void addUnicodeExtraFields(final ZipArchiveEntry ze, final boolean encodable, final ByteBuffer name) throws IOException",
        "protected void writeDataDescriptor(final ZipArchiveEntry ze) throws IOException",
        "protected void writeCentralFileHeader(final ZipArchiveEntry ze) throws IOException",
        "private byte[] createCentralFileHeader(final ZipArchiveEntry ze) throws IOException",
        "private byte[] createCentralFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final EntryMetaData entryMetaData, final boolean needsZip64Extra) throws IOException",
        "private void handleZip64Extra(final ZipArchiveEntry ze, final long lfhOffset, final boolean needsZip64Extra)",
        "protected void writeCentralDirectoryEnd() throws IOException",
        "protected void writeZip64CentralDirectory() throws IOException",
        "protected final void writeOut(final byte[] data) throws IOException",
        "protected final void writeOut(final byte[] data, final int offset, final int length) throws IOException",
        "private GeneralPurposeBit getGeneralPurposeBits(final boolean utfFallback, boolean usesDataDescriptor)",
        "private int versionNeededToExtract(final int zipMethod, final boolean zip64, final boolean usedDataDescriptor)",
        "private boolean usesDataDescriptor(final int zipMethod, boolean phased)",
        "private int versionNeededToExtractMethod(int zipMethod)",
        "public ArchiveEntry createArchiveEntry(final File inputFile, final String entryName) throws IOException",
        "private Zip64ExtendedInformationExtraField getZip64Extra(final ZipArchiveEntry ze)",
        "private boolean hasZip64Extra(final ZipArchiveEntry ze)",
        "private Zip64Mode getEffectiveZip64Mode(final ZipArchiveEntry ze)",
        "private ZipEncoding getEntryEncoding(final ZipArchiveEntry ze)",
        "private ByteBuffer getName(final ZipArchiveEntry ze) throws IOException",
        "public String toString()",
        "private static final class CurrentEntry { private CurrentEntry(final ZipArchiveEntry entry)"
      ],
      "methods": [
        {
          "buggy_method": "  private void writeLocalFileHeader(final ZipArchiveEntry ze, final boolean phased) throws IOException {\n  final boolean encodable = zipEncoding.canEncode(ze.getName());\n  final ByteBuffer name = getName(ze);\n\n  if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n  addUnicodeExtraFields(ze, encodable, name);\n  }\n\n  final long localHeaderStart = streamCompressor.getTotalBytesWritten();\n  final byte[] localHeader = createLocalFileHeader(ze, name, encodable, phased, localHeaderStart);\n  metaData.put(ze, new EntryMetaData(localHeaderStart, usesDataDescriptor(ze.getMethod())));\n  entry.localDataStart = localHeaderStart + LFH_CRC_OFFSET; \n  writeCounted(localHeader);\n  entry.dataStart = streamCompressor.getTotalBytesWritten();\n  }",
          "fixed_method": "  private void writeLocalFileHeader(final ZipArchiveEntry ze, final boolean phased) throws IOException {\n  final boolean encodable = zipEncoding.canEncode(ze.getName());\n  final ByteBuffer name = getName(ze);\n\n  if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n  addUnicodeExtraFields(ze, encodable, name);\n  }\n\n  final long localHeaderStart = streamCompressor.getTotalBytesWritten();\n  final byte[] localHeader = createLocalFileHeader(ze, name, encodable, phased, localHeaderStart);\n  metaData.put(ze, new EntryMetaData(localHeaderStart, usesDataDescriptor(ze.getMethod(), phased)));\n  entry.localDataStart = localHeaderStart + LFH_CRC_OFFSET; \n  writeCounted(localHeader);\n  entry.dataStart = streamCompressor.getTotalBytesWritten();\n  }",
          "diff": [
            "@@ -1031,7 +1031,7 @@",
            " \n",
            "         final long localHeaderStart = streamCompressor.getTotalBytesWritten();\n",
            "         final byte[] localHeader = createLocalFileHeader(ze, name, encodable, phased, localHeaderStart);\n",
            "-        metaData.put(ze, new EntryMetaData(localHeaderStart, usesDataDescriptor(ze.getMethod())));\n",
            "+        metaData.put(ze, new EntryMetaData(localHeaderStart, usesDataDescriptor(ze.getMethod(), phased)));\n",
            "         entry.localDataStart = localHeaderStart + LFH_CRC_OFFSET; // At crc offset\n",
            "         writeCounted(localHeader);\n",
            "         entry.dataStart = streamCompressor.getTotalBytesWritten();\n"
          ],
          "changed_lines": 2
        },
        {
          "buggy_method": "  private byte[] createLocalFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final boolean encodable, final boolean phased, long archiveOffset) throws IOException {\n  ResourceAlignmentExtraField oldAlignmentEx =\n  (ResourceAlignmentExtraField) ze.getExtraField(ResourceAlignmentExtraField.ID);\n  if (oldAlignmentEx != null) {\n  ze.removeExtraField(ResourceAlignmentExtraField.ID);\n  }\n\n  int alignment = ze.getAlignment();\n  if (alignment <= 0 && oldAlignmentEx != null) {\n  alignment = oldAlignmentEx.getAlignment();\n  }\n\n  if (alignment > 1 || (oldAlignmentEx != null && !oldAlignmentEx.allowMethodChange())) {\n  int oldLength = LFH_FILENAME_OFFSET +\n  name.limit() - name.position() +\n  ze.getLocalFileDataExtra().length;\n\n  int padding = (int) ((-archiveOffset - oldLength - ZipExtraField.EXTRAFIELD_HEADER_SIZE\n  - ResourceAlignmentExtraField.BASE_SIZE) &\n  (alignment - 1));\n  ze.addExtraField(new ResourceAlignmentExtraField(alignment,\n  oldAlignmentEx != null && oldAlignmentEx.allowMethodChange(), padding));\n  }\n\n  final byte[] extra = ze.getLocalFileDataExtra();\n  final int nameLen = name.limit() - name.position();\n  final int len = LFH_FILENAME_OFFSET + nameLen + extra.length;\n  final byte[] buf = new byte[len];\n\n  System.arraycopy(LFH_SIG,  0, buf, LFH_SIG_OFFSET, WORD);\n\n  \n  final int zipMethod = ze.getMethod();\n  final boolean dataDescriptor = usesDataDescriptor(zipMethod);\n\n  putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET);\n\n  final GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(!encodable && fallbackToUTF8, dataDescriptor);\n  generalPurposeBit.encode(buf, LFH_GPB_OFFSET);\n\n  \n  putShort(zipMethod, buf, LFH_METHOD_OFFSET);\n\n  ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, LFH_TIME_OFFSET);\n\n  \n  if (phased){\n  putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n  } else if (zipMethod == DEFLATED || channel != null) {\n  System.arraycopy(LZERO, 0, buf, LFH_CRC_OFFSET, WORD);\n  } else {\n  putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n  }\n\n  \n  \n  if (hasZip64Extra(entry.entry)){\n  \n  \n  \n  ZipLong.ZIP64_MAGIC.putLong(buf, LFH_COMPRESSED_SIZE_OFFSET);\n  ZipLong.ZIP64_MAGIC.putLong(buf, LFH_ORIGINAL_SIZE_OFFSET);\n  } else if (phased) {\n  putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n  putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n  } else if (zipMethod == DEFLATED || channel != null) {\n  System.arraycopy(LZERO, 0, buf, LFH_COMPRESSED_SIZE_OFFSET, WORD);\n  System.arraycopy(LZERO, 0, buf, LFH_ORIGINAL_SIZE_OFFSET, WORD);\n  } else { \n  putLong(ze.getSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n  putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n  }\n  \n  putShort(nameLen, buf, LFH_FILENAME_LENGTH_OFFSET);\n\n  \n  putShort(extra.length, buf, LFH_EXTRA_LENGTH_OFFSET);\n\n  \n  System.arraycopy( name.array(), name.arrayOffset(), buf, LFH_FILENAME_OFFSET, nameLen);\n\n  \n  System.arraycopy(extra, 0, buf, LFH_FILENAME_OFFSET + nameLen, extra.length);\n\n  return buf;\n  }",
          "fixed_method": "  private byte[] createLocalFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final boolean encodable, final boolean phased, long archiveOffset) throws IOException {\n  ResourceAlignmentExtraField oldAlignmentEx =\n  (ResourceAlignmentExtraField) ze.getExtraField(ResourceAlignmentExtraField.ID);\n  if (oldAlignmentEx != null) {\n  ze.removeExtraField(ResourceAlignmentExtraField.ID);\n  }\n\n  int alignment = ze.getAlignment();\n  if (alignment <= 0 && oldAlignmentEx != null) {\n  alignment = oldAlignmentEx.getAlignment();\n  }\n\n  if (alignment > 1 || (oldAlignmentEx != null && !oldAlignmentEx.allowMethodChange())) {\n  int oldLength = LFH_FILENAME_OFFSET +\n  name.limit() - name.position() +\n  ze.getLocalFileDataExtra().length;\n\n  int padding = (int) ((-archiveOffset - oldLength - ZipExtraField.EXTRAFIELD_HEADER_SIZE\n  - ResourceAlignmentExtraField.BASE_SIZE) &\n  (alignment - 1));\n  ze.addExtraField(new ResourceAlignmentExtraField(alignment,\n  oldAlignmentEx != null && oldAlignmentEx.allowMethodChange(), padding));\n  }\n\n  final byte[] extra = ze.getLocalFileDataExtra();\n  final int nameLen = name.limit() - name.position();\n  final int len = LFH_FILENAME_OFFSET + nameLen + extra.length;\n  final byte[] buf = new byte[len];\n\n  System.arraycopy(LFH_SIG,  0, buf, LFH_SIG_OFFSET, WORD);\n\n  \n  final int zipMethod = ze.getMethod();\n  final boolean dataDescriptor = usesDataDescriptor(zipMethod, phased);\n\n  putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET);\n\n  final GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(!encodable && fallbackToUTF8, dataDescriptor);\n  generalPurposeBit.encode(buf, LFH_GPB_OFFSET);\n\n  \n  putShort(zipMethod, buf, LFH_METHOD_OFFSET);\n\n  ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, LFH_TIME_OFFSET);\n\n  \n  if (phased){\n  putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n  } else if (zipMethod == DEFLATED || channel != null) {\n  System.arraycopy(LZERO, 0, buf, LFH_CRC_OFFSET, WORD);\n  } else {\n  putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n  }\n\n  \n  \n  if (hasZip64Extra(entry.entry)){\n  \n  \n  \n  ZipLong.ZIP64_MAGIC.putLong(buf, LFH_COMPRESSED_SIZE_OFFSET);\n  ZipLong.ZIP64_MAGIC.putLong(buf, LFH_ORIGINAL_SIZE_OFFSET);\n  } else if (phased) {\n  putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n  putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n  } else if (zipMethod == DEFLATED || channel != null) {\n  System.arraycopy(LZERO, 0, buf, LFH_COMPRESSED_SIZE_OFFSET, WORD);\n  System.arraycopy(LZERO, 0, buf, LFH_ORIGINAL_SIZE_OFFSET, WORD);\n  } else { \n  putLong(ze.getSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n  putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n  }\n  \n  putShort(nameLen, buf, LFH_FILENAME_LENGTH_OFFSET);\n\n  \n  putShort(extra.length, buf, LFH_EXTRA_LENGTH_OFFSET);\n\n  \n  System.arraycopy( name.array(), name.arrayOffset(), buf, LFH_FILENAME_OFFSET, nameLen);\n\n  \n  System.arraycopy(extra, 0, buf, LFH_FILENAME_OFFSET + nameLen, extra.length);\n\n  return buf;\n  }",
          "diff": [
            "@@ -1072,7 +1072,7 @@",
            " \n",
            "         //store method in local variable to prevent multiple method calls\n",
            "         final int zipMethod = ze.getMethod();\n",
            "-        final boolean dataDescriptor = usesDataDescriptor(zipMethod);\n",
            "+        final boolean dataDescriptor = usesDataDescriptor(zipMethod, phased);\n",
            " \n",
            "         putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET);\n",
            " \n"
          ],
          "changed_lines": 2
        },
        {
          "buggy_method": "  protected void writeDataDescriptor(final ZipArchiveEntry ze) throws IOException {\n  if (ze.getMethod() != DEFLATED || channel != null) {\n  return;\n  }\n  writeCounted(DD_SIG);\n  writeCounted(ZipLong.getBytes(ze.getCrc()));\n  if (!hasZip64Extra(ze)) {\n  writeCounted(ZipLong.getBytes(ze.getCompressedSize()));\n  writeCounted(ZipLong.getBytes(ze.getSize()));\n  } else {\n  writeCounted(ZipEightByteInteger.getBytes(ze.getCompressedSize()));\n  writeCounted(ZipEightByteInteger.getBytes(ze.getSize()));\n  }\n  }",
          "fixed_method": "  protected void writeDataDescriptor(final ZipArchiveEntry ze) throws IOException {\n  if (!usesDataDescriptor(ze.getMethod(), false)) {\n  return;\n  }\n  writeCounted(DD_SIG);\n  writeCounted(ZipLong.getBytes(ze.getCrc()));\n  if (!hasZip64Extra(ze)) {\n  writeCounted(ZipLong.getBytes(ze.getCompressedSize()));\n  writeCounted(ZipLong.getBytes(ze.getSize()));\n  } else {\n  writeCounted(ZipEightByteInteger.getBytes(ze.getCompressedSize()));\n  writeCounted(ZipEightByteInteger.getBytes(ze.getSize()));\n  }\n  }",
          "diff": [
            "@@ -1168,7 +1168,7 @@",
            "      * @throws IOException on error\n",
            "      */\n",
            "     protected void writeDataDescriptor(final ZipArchiveEntry ze) throws IOException {\n",
            "-        if (ze.getMethod() != DEFLATED || channel != null) {\n",
            "+        if (!usesDataDescriptor(ze.getMethod(), false)) {\n",
            "             return;\n",
            "         }\n",
            "         writeCounted(DD_SIG);\n"
          ],
          "changed_lines": 2
        },
        {
          "buggy_method": "  private boolean usesDataDescriptor(final int zipMethod) {\n  return zipMethod == DEFLATED && channel == null;\n  }",
          "fixed_method": "  private boolean usesDataDescriptor(final int zipMethod, boolean phased) {\n  return !phased && zipMethod == DEFLATED && channel == null;\n  }",
          "diff": [
            "@@ -1489,8 +1489,8 @@",
            "         return versionNeededToExtractMethod(zipMethod);\n",
            "     }\n",
            " \n",
            "-    private boolean usesDataDescriptor(final int zipMethod) {\n",
            "-        return zipMethod == DEFLATED && channel == null;\n",
            "+    private boolean usesDataDescriptor(final int zipMethod, boolean phased) {\n",
            "+        return !phased && zipMethod == DEFLATED && channel == null;\n",
            "     }\n",
            " \n",
            "     private int versionNeededToExtractMethod(int zipMethod) {\n"
          ],
          "changed_lines": 4
        }
      ]
    }
  ]
}
