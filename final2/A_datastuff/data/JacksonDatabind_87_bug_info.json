{
  "bug_id": "87",
  "failed_tests": {
    "com.fasterxml.jackson.databind.deser.TestDateDeserialization": [
      {
        "methodName": "testDateUtilISO8601NoTimezoneNonDefault",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<Wed Dec 31 16:00:00 PST 1969> but was:<Wed Dec 31 18:00:00 PST 1969>",
        "fail_line": "        assertEquals(date1, date2);",
        "test_source": "  public void testDateUtilISO8601NoTimezoneNonDefault() throws Exception {\n  // In first case, no timezone -> SHOULD use configured timezone\n  ObjectReader r = MAPPER.readerFor(Date.class);\n  TimeZone tz = TimeZone.getTimeZone(\"GMT-2\");\n  Date date1 = r.with(tz)\n  .readValue(quote(\"1970-01-01T00:00:00.000\"));\n  // Second case, should use specified timezone, not configured\n  Date date2 = r.with(TimeZone.getTimeZone(\"GMT+5\"))\n  .readValue(quote(\"1970-01-01T00:00:00.000-02:00\"));\n  assertEquals(date1, date2);\n\n  // also verify actual value, in GMT\n  Calendar c = Calendar.getInstance(TimeZone.getTimeZone(\"GMT\"));\n  c.setTime(date1);\n  assertEquals(1970, c.get(Calendar.YEAR));\n  assertEquals(Calendar.JANUARY, c.get(Calendar.MONTH));\n  assertEquals(1, c.get(Calendar.DAY_OF_MONTH));\n  assertEquals(2, c.get(Calendar.HOUR_OF_DAY));\n  }",
        "stack": [
          "TestDateDeserialization.testDateUtilISO8601NoTimezoneNonDefault line 277"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "com/fasterxml/jackson/databind/util/StdDateFormat.java",
      "buggy_full_code": "package com.fasterxml.jackson.databind.util;\n\nimport java.text.DateFormat;\nimport java.text.FieldPosition;\nimport java.text.ParseException;\nimport java.text.ParsePosition;\nimport java.text.SimpleDateFormat;\nimport java.util.*;\n\nimport com.fasterxml.jackson.core.io.NumberInput;\n\n\n@SuppressWarnings(\"serial\")\npublic class StdDateFormat extends DateFormat { public final static String DATE_FORMAT_STR_ISO8601 = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\"; protected final static String DATE_FORMAT_STR_ISO8601_Z = \"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\"; protected final static String DATE_FORMAT_STR_PLAIN = \"yyyy-MM-dd\"; protected final static String DATE_FORMAT_STR_RFC1123 = \"EEE, dd MMM yyyy HH:mm:ss zzz\"; protected final static String[] ALL_FORMATS = new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }; private final static TimeZone DEFAULT_TIMEZONE; static { DEFAULT_TIMEZONE = TimeZone.getTimeZone(\"UTC\"); } private final static Locale DEFAULT_LOCALE = Locale.US; protected final static DateFormat DATE_FORMAT_RFC1123; protected final static DateFormat DATE_FORMAT_ISO8601; protected final static DateFormat DATE_FORMAT_ISO8601_Z; protected final static DateFormat DATE_FORMAT_PLAIN; static {\n        \n\n        DATE_FORMAT_RFC1123 = new SimpleDateFormat(DATE_FORMAT_STR_RFC1123, DEFAULT_LOCALE);\n        DATE_FORMAT_RFC1123.setTimeZone(DEFAULT_TIMEZONE);\n        DATE_FORMAT_ISO8601 = new SimpleDateFormat(DATE_FORMAT_STR_ISO8601, DEFAULT_LOCALE);\n        DATE_FORMAT_ISO8601.setTimeZone(DEFAULT_TIMEZONE);\n        DATE_FORMAT_ISO8601_Z = new SimpleDateFormat(DATE_FORMAT_STR_ISO8601_Z, DEFAULT_LOCALE);\n        DATE_FORMAT_ISO8601_Z.setTimeZone(DEFAULT_TIMEZONE);\n        DATE_FORMAT_PLAIN = new SimpleDateFormat(DATE_FORMAT_STR_PLAIN, DEFAULT_LOCALE);\n        DATE_FORMAT_PLAIN.setTimeZone(DEFAULT_TIMEZONE);\n    }\n    \n    \n    public final static StdDateFormat instance = new StdDateFormat(); protected transient TimeZone _timezone; protected final Locale _locale; protected Boolean _lenient; protected transient DateFormat _formatRFC1123; protected transient DateFormat _formatISO8601; protected transient DateFormat _formatISO8601_z; protected transient DateFormat _formatPlain; public StdDateFormat() {\n        _locale = DEFAULT_LOCALE;\n    }\n\n    @Deprecated \n    public StdDateFormat(TimeZone tz, Locale loc) {\n        _timezone = tz;\n        _locale = loc;\n    }\n\n    protected StdDateFormat(TimeZone tz, Locale loc, Boolean lenient) {\n        _timezone = tz;\n        _locale = loc;\n        _lenient = lenient;\n    }\n    \n    public static TimeZone getDefaultTimeZone() {\n        return DEFAULT_TIMEZONE;\n    }\n    \n    \n    public StdDateFormat withTimeZone(TimeZone tz) {\n        if (tz == null) {\n            tz = DEFAULT_TIMEZONE;\n        }\n        if ((tz == _timezone) || tz.equals(_timezone)) {\n            return this;\n        }\n        return new StdDateFormat(tz, _locale, _lenient);\n    }\n\n    public StdDateFormat withLocale(Locale loc) {\n        if (loc.equals(_locale)) {\n            return this;\n        }\n        return new StdDateFormat(_timezone, loc, _lenient);\n    }\n    \n    @Override\n    public StdDateFormat clone() {\n        \n        return new StdDateFormat(_timezone, _locale, _lenient);\n    }\n\n    \n    @Deprecated\n    public static DateFormat getISO8601Format(TimeZone tz) {\n        return getISO8601Format(tz, DEFAULT_LOCALE);\n    }\n\n    \n    public static DateFormat getISO8601Format(TimeZone tz, Locale loc) {\n        return _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, tz, loc, null);\n    }\n\n    \n    public static DateFormat getRFC1123Format(TimeZone tz, Locale loc) {\n        return _cloneFormat(DATE_FORMAT_RFC1123, DATE_FORMAT_STR_RFC1123,\n                tz, loc, null);\n    }\n\n    \n    @Deprecated\n    public static DateFormat getRFC1123Format(TimeZone tz) {\n        return getRFC1123Format(tz, DEFAULT_LOCALE);\n    }\n\n    \n\n    @Override \n    public TimeZone getTimeZone() {\n        return _timezone;\n    }\n\n    @Override\n    public void setTimeZone(TimeZone tz) {\n        \n        if (!tz.equals(_timezone)) {\n            _clearFormats();\n            _timezone = tz;\n        }\n    }\n\n    \n    @Override \n    public void setLenient(boolean enabled) {\n        Boolean newValue = enabled;\n        if (_lenient != newValue) {\n            _lenient = newValue;\n            \n            _clearFormats();\n        }\n    }\n\n    @Override \n    public boolean isLenient() {\n        if (_lenient == null) {\n            \n            return true;\n        }\n        return _lenient.booleanValue();\n    }\n\n    \n\n    @Override\n    public Date parse(String dateStr) throws ParseException {\n        dateStr = dateStr.trim();\n        ParsePosition pos = new ParsePosition(0);\n\n        Date dt;\n\n        if (looksLikeISO8601(dateStr)) { \n            dt = parseAsISO8601(dateStr, pos, true);\n        } else {\n            \n            int i = dateStr.length();\n            while (--i >= 0) {\n                char ch = dateStr.charAt(i);\n                if (ch < '0' || ch > '9') {\n                    \n                    if (i > 0 || ch != '-') {\n                        break;\n                    }\n                }\n            }\n            if ((i < 0)\n                \n                    && (dateStr.charAt(0) == '-' || NumberInput.inLongRange(dateStr, false))) {\n                dt = new Date(Long.parseLong(dateStr));\n            } else {\n                \n                dt = parseAsRFC1123(dateStr, pos);\n            }\n        }\n        if (dt != null) {\n            return dt;\n        }\n\n        StringBuilder sb = new StringBuilder();\n        for (String f : ALL_FORMATS) {\n            if (sb.length() > 0) {\n                sb.append(\"\\\", \\\"\");\n            } else {\n                sb.append('\"');\n            }\n            sb.append(f);\n        }\n        sb.append('\"');\n        throw new ParseException\n            (String.format(\"Can not parse date \\\"%s\\\": not compatible with any of standard forms (%s)\",\n                           dateStr, sb.toString()), pos.getErrorIndex());\n    }\n\n    @Override\n    public Date parse(String dateStr, ParsePosition pos) {\n        if (looksLikeISO8601(dateStr)) { \n            try {\n                return parseAsISO8601(dateStr, pos, false);\n            } catch (ParseException e) { \n                return null;\n            }\n        }\n        \n        int i = dateStr.length();\n        while (--i >= 0) {\n            char ch = dateStr.charAt(i);\n            if (ch < '0' || ch > '9') {\n                \n                if (i > 0 || ch != '-') {\n                    break;\n                }\n            }\n        }\n        if (i < 0) { \n            \n            if (dateStr.charAt(0) == '-' || NumberInput.inLongRange(dateStr, false)) {\n                return new Date(Long.parseLong(dateStr));\n            }\n        }\n        \n        return parseAsRFC1123(dateStr, pos);\n    }\n\n    \n    \n    @Override\n    public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition) {\n        if (_formatISO8601 == null) {\n            _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601,\n                    _timezone, _locale, _lenient);\n        }\n        return _formatISO8601.format(date, toAppendTo, fieldPosition);\n    }\n\n    \n    \n    @Override\n    public String toString() {\n        String str = \"DateFormat \"+getClass().getName();\n        TimeZone tz = _timezone;\n        if (tz != null) {\n            str += \" (timezone: \"+tz+\")\";\n        }\n        str += \"(locale: \"+_locale+\")\";\n        return str;\n    }\n\n    @Override \n    public boolean equals(Object o) {\n        return (o == this);\n    }\n\n    @Override \n    public int hashCode() {\n        return System.identityHashCode(this);\n    }\n\n    \n\n    \n    protected boolean looksLikeISO8601(String dateStr) {\n        if (dateStr.length() >= 5\n            && Character.isDigit(dateStr.charAt(0))\n            && Character.isDigit(dateStr.charAt(3))\n            && dateStr.charAt(4) == '-'\n            ) {\n            return true;\n        }\n        return false;\n    }\n\n    protected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors) throws ParseException {\n        \n\n        \n        int len = dateStr.length();\n        char c = dateStr.charAt(len-1);\n        DateFormat df;\n        String formatStr;\n\n        \n        if (len <= 10 && Character.isDigit(c)) {\n            df = _formatPlain;\n            formatStr = DATE_FORMAT_STR_PLAIN;\n            if (df == null) {\n                df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, formatStr,\n                        _timezone, _locale, _lenient);\n            }\n        } else if (c == 'Z') {\n            df = _formatISO8601_z;\n            formatStr = DATE_FORMAT_STR_ISO8601_Z;\n            if (df == null) {\n                \n                \n                \n                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr,\n                        DEFAULT_TIMEZONE, _locale, _lenient);\n            }\n            \n            if (dateStr.charAt(len-4) == ':') {\n                StringBuilder sb = new StringBuilder(dateStr);\n                sb.insert(len-1, \".000\");\n                dateStr = sb.toString();\n            }\n        } else {\n            \n            if (hasTimeZone(dateStr)) {\n                c = dateStr.charAt(len-3);\n                if (c == ':') { \n                    \n                    StringBuilder sb = new StringBuilder(dateStr);\n                    sb.delete(len-3, len-2);\n                    dateStr = sb.toString();\n                } else if (c == '+' || c == '-') { \n                    \n                    dateStr += \"00\";\n                }\n                \n                len = dateStr.length();\n                \n                int timeLen = len - dateStr.lastIndexOf('T') - 6;\n                if (timeLen < 12) { \n                    int offset = len - 5; \n                    StringBuilder sb = new StringBuilder(dateStr);\n                    switch (timeLen) {\n                    case 11:\n                        sb.insert(offset, '0'); break;\n                    case 10:\n                        sb.insert(offset, \"00\"); break;\n                    case 9: \n                        sb.insert(offset, \"000\"); break;\n                    case 8:\n                        sb.insert(offset, \".000\"); break;\n                    case 7: \n                        break;\n                    case 6: \n                        sb.insert(offset, \"00.000\");\n                    case 5: \n                        sb.insert(offset, \":00.000\");\n                    }\n                    dateStr = sb.toString();\n                }\n                df = _formatISO8601;\n                formatStr = DATE_FORMAT_STR_ISO8601;\n                if (_formatISO8601 == null) {\n                    df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, formatStr,\n                            _timezone, _locale, _lenient);\n                }\n            } else {\n                \n                StringBuilder sb = new StringBuilder(dateStr);\n                int timeLen = len - dateStr.lastIndexOf('T') - 1;\n                \n                if (timeLen < 12) { \n                    switch (timeLen) {\n                    case 11: sb.append('0');\n                    case 10: sb.append('0');\n                    case 9: sb.append('0');\n                        break;\n                    default:\n                        sb.append(\".000\");\n                    }\n                }\n                sb.append('Z');\n                dateStr = sb.toString();\n                df = _formatISO8601_z;\n                formatStr = DATE_FORMAT_STR_ISO8601_Z;\n                if (df == null) {\n                    \n                    \n                    \n                    df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr,\n                            DEFAULT_TIMEZONE, _locale, _lenient);\n                }\n            }\n        }\n        Date dt = df.parse(dateStr, pos);\n        \n        if (dt == null) {\n            throw new ParseException\n            (String.format(\"Can not parse date \\\"%s\\\": while it seems to fit format '%s', parsing fails (leniency? %s)\",\n                           dateStr, formatStr, _lenient),\n               pos.getErrorIndex());\n        }\n        return dt;\n    }\n\n    protected Date parseAsRFC1123(String dateStr, ParsePosition pos) {\n        if (_formatRFC1123 == null) {\n            _formatRFC1123 = _cloneFormat(DATE_FORMAT_RFC1123, DATE_FORMAT_STR_RFC1123,\n                    _timezone, _locale, _lenient);\n        }\n        return _formatRFC1123.parse(dateStr, pos);\n    }\n\n    private final static boolean hasTimeZone(String str) {\n        \n        int len = str.length();\n        if (len >= 6) {\n            char c = str.charAt(len-6);\n            if (c == '+' || c == '-') return true;\n            c = str.charAt(len-5);\n            if (c == '+' || c == '-') return true;\n            c = str.charAt(len-3);\n            if (c == '+' || c == '-') return true;\n        }\n        return false;\n    }\n\n    private final static DateFormat _cloneFormat(DateFormat df, String format, TimeZone tz, Locale loc, Boolean lenient) {\n        if (!loc.equals(DEFAULT_LOCALE)) {\n            df = new SimpleDateFormat(format, loc);\n            df.setTimeZone((tz == null) ? DEFAULT_TIMEZONE : tz);\n        } else {\n            df = (DateFormat) df.clone();\n            if (tz != null) {\n                df.setTimeZone(tz);\n            }\n        }\n        if (lenient != null) {\n            df.setLenient(lenient.booleanValue());\n        }\n        return df;\n    }\n\n    protected void _clearFormats() {\n        _formatRFC1123 = null;\n        _formatISO8601 = null;\n        _formatISO8601_z = null;\n\n        _formatPlain = null;\n    }\n}\n\n",
      "fixed_full_code": "package com.fasterxml.jackson.databind.util;\n\nimport java.text.DateFormat;\nimport java.text.FieldPosition;\nimport java.text.ParseException;\nimport java.text.ParsePosition;\nimport java.text.SimpleDateFormat;\nimport java.util.*;\n\nimport com.fasterxml.jackson.core.io.NumberInput;\n\n\n@SuppressWarnings(\"serial\")\npublic class StdDateFormat extends DateFormat { public final static String DATE_FORMAT_STR_ISO8601 = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\"; protected final static String DATE_FORMAT_STR_ISO8601_Z = \"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\"; protected final static String DATE_FORMAT_STR_ISO8601_NO_TZ = \"yyyy-MM-dd'T'HH:mm:ss.SSS\"; protected final static String DATE_FORMAT_STR_PLAIN = \"yyyy-MM-dd\"; protected final static String DATE_FORMAT_STR_RFC1123 = \"EEE, dd MMM yyyy HH:mm:ss zzz\"; protected final static String[] ALL_FORMATS = new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_ISO8601_NO_TZ, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }; private final static TimeZone DEFAULT_TIMEZONE; static { DEFAULT_TIMEZONE = TimeZone.getTimeZone(\"UTC\"); } private final static Locale DEFAULT_LOCALE = Locale.US; protected final static DateFormat DATE_FORMAT_RFC1123; protected final static DateFormat DATE_FORMAT_ISO8601; protected final static DateFormat DATE_FORMAT_ISO8601_Z; protected final static DateFormat DATE_FORMAT_ISO8601_NO_TZ; protected final static DateFormat DATE_FORMAT_PLAIN; static {\n        \n\n        DATE_FORMAT_RFC1123 = new SimpleDateFormat(DATE_FORMAT_STR_RFC1123, DEFAULT_LOCALE);\n        DATE_FORMAT_RFC1123.setTimeZone(DEFAULT_TIMEZONE);\n        DATE_FORMAT_ISO8601 = new SimpleDateFormat(DATE_FORMAT_STR_ISO8601, DEFAULT_LOCALE);\n        DATE_FORMAT_ISO8601.setTimeZone(DEFAULT_TIMEZONE);\n        DATE_FORMAT_ISO8601_Z = new SimpleDateFormat(DATE_FORMAT_STR_ISO8601_Z, DEFAULT_LOCALE);\n        DATE_FORMAT_ISO8601_Z.setTimeZone(DEFAULT_TIMEZONE);\n        DATE_FORMAT_ISO8601_NO_TZ = new SimpleDateFormat(DATE_FORMAT_STR_ISO8601_NO_TZ, DEFAULT_LOCALE);\n        DATE_FORMAT_ISO8601_NO_TZ.setTimeZone(DEFAULT_TIMEZONE);\n        DATE_FORMAT_PLAIN = new SimpleDateFormat(DATE_FORMAT_STR_PLAIN, DEFAULT_LOCALE);\n        DATE_FORMAT_PLAIN.setTimeZone(DEFAULT_TIMEZONE);\n    }\n    \n    \n    public final static StdDateFormat instance = new StdDateFormat(); protected transient TimeZone _timezone; protected final Locale _locale; protected Boolean _lenient; protected transient DateFormat _formatRFC1123; protected transient DateFormat _formatISO8601; protected transient DateFormat _formatISO8601_z; protected transient DateFormat _formatISO8601_noTz; protected transient DateFormat _formatPlain; public StdDateFormat() {\n        _locale = DEFAULT_LOCALE;\n    }\n\n    @Deprecated \n    public StdDateFormat(TimeZone tz, Locale loc) {\n        _timezone = tz;\n        _locale = loc;\n    }\n\n    protected StdDateFormat(TimeZone tz, Locale loc, Boolean lenient) {\n        _timezone = tz;\n        _locale = loc;\n        _lenient = lenient;\n    }\n    \n    public static TimeZone getDefaultTimeZone() {\n        return DEFAULT_TIMEZONE;\n    }\n    \n    \n    public StdDateFormat withTimeZone(TimeZone tz) {\n        if (tz == null) {\n            tz = DEFAULT_TIMEZONE;\n        }\n        if ((tz == _timezone) || tz.equals(_timezone)) {\n            return this;\n        }\n        return new StdDateFormat(tz, _locale, _lenient);\n    }\n\n    public StdDateFormat withLocale(Locale loc) {\n        if (loc.equals(_locale)) {\n            return this;\n        }\n        return new StdDateFormat(_timezone, loc, _lenient);\n    }\n    \n    @Override\n    public StdDateFormat clone() {\n        \n        return new StdDateFormat(_timezone, _locale, _lenient);\n    }\n\n    \n    @Deprecated\n    public static DateFormat getISO8601Format(TimeZone tz) {\n        return getISO8601Format(tz, DEFAULT_LOCALE);\n    }\n\n    \n    public static DateFormat getISO8601Format(TimeZone tz, Locale loc) {\n        return _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, tz, loc, null);\n    }\n\n    \n    public static DateFormat getRFC1123Format(TimeZone tz, Locale loc) {\n        return _cloneFormat(DATE_FORMAT_RFC1123, DATE_FORMAT_STR_RFC1123,\n                tz, loc, null);\n    }\n\n    \n    @Deprecated\n    public static DateFormat getRFC1123Format(TimeZone tz) {\n        return getRFC1123Format(tz, DEFAULT_LOCALE);\n    }\n\n    \n\n    @Override \n    public TimeZone getTimeZone() {\n        return _timezone;\n    }\n\n    @Override\n    public void setTimeZone(TimeZone tz) {\n        \n        if (!tz.equals(_timezone)) {\n            _clearFormats();\n            _timezone = tz;\n        }\n    }\n\n    \n    @Override \n    public void setLenient(boolean enabled) {\n        Boolean newValue = enabled;\n        if (_lenient != newValue) {\n            _lenient = newValue;\n            \n            _clearFormats();\n        }\n    }\n\n    @Override \n    public boolean isLenient() {\n        if (_lenient == null) {\n            \n            return true;\n        }\n        return _lenient.booleanValue();\n    }\n\n    \n\n    @Override\n    public Date parse(String dateStr) throws ParseException {\n        dateStr = dateStr.trim();\n        ParsePosition pos = new ParsePosition(0);\n\n        Date dt;\n\n        if (looksLikeISO8601(dateStr)) { \n            dt = parseAsISO8601(dateStr, pos, true);\n        } else {\n            \n            int i = dateStr.length();\n            while (--i >= 0) {\n                char ch = dateStr.charAt(i);\n                if (ch < '0' || ch > '9') {\n                    \n                    if (i > 0 || ch != '-') {\n                        break;\n                    }\n                }\n            }\n            if ((i < 0)\n                \n                    && (dateStr.charAt(0) == '-' || NumberInput.inLongRange(dateStr, false))) {\n                dt = new Date(Long.parseLong(dateStr));\n            } else {\n                \n                dt = parseAsRFC1123(dateStr, pos);\n            }\n        }\n        if (dt != null) {\n            return dt;\n        }\n\n        StringBuilder sb = new StringBuilder();\n        for (String f : ALL_FORMATS) {\n            if (sb.length() > 0) {\n                sb.append(\"\\\", \\\"\");\n            } else {\n                sb.append('\"');\n            }\n            sb.append(f);\n        }\n        sb.append('\"');\n        throw new ParseException\n            (String.format(\"Can not parse date \\\"%s\\\": not compatible with any of standard forms (%s)\",\n                           dateStr, sb.toString()), pos.getErrorIndex());\n    }\n\n    @Override\n    public Date parse(String dateStr, ParsePosition pos) {\n        if (looksLikeISO8601(dateStr)) { \n            try {\n                return parseAsISO8601(dateStr, pos, false);\n            } catch (ParseException e) { \n                return null;\n            }\n        }\n        \n        int i = dateStr.length();\n        while (--i >= 0) {\n            char ch = dateStr.charAt(i);\n            if (ch < '0' || ch > '9') {\n                \n                if (i > 0 || ch != '-') {\n                    break;\n                }\n            }\n        }\n        if (i < 0) { \n            \n            if (dateStr.charAt(0) == '-' || NumberInput.inLongRange(dateStr, false)) {\n                return new Date(Long.parseLong(dateStr));\n            }\n        }\n        \n        return parseAsRFC1123(dateStr, pos);\n    }\n\n    \n    \n    @Override\n    public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition) {\n        if (_formatISO8601 == null) {\n            _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601,\n                    _timezone, _locale, _lenient);\n        }\n        return _formatISO8601.format(date, toAppendTo, fieldPosition);\n    }\n\n    \n    \n    @Override\n    public String toString() {\n        String str = \"DateFormat \"+getClass().getName();\n        TimeZone tz = _timezone;\n        if (tz != null) {\n            str += \" (timezone: \"+tz+\")\";\n        }\n        str += \"(locale: \"+_locale+\")\";\n        return str;\n    }\n\n    @Override \n    public boolean equals(Object o) {\n        return (o == this);\n    }\n\n    @Override \n    public int hashCode() {\n        return System.identityHashCode(this);\n    }\n\n    \n\n    \n    protected boolean looksLikeISO8601(String dateStr) {\n        if (dateStr.length() >= 5\n            && Character.isDigit(dateStr.charAt(0))\n            && Character.isDigit(dateStr.charAt(3))\n            && dateStr.charAt(4) == '-'\n            ) {\n            return true;\n        }\n        return false;\n    }\n\n    protected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors) throws ParseException {\n        \n\n        \n        int len = dateStr.length();\n        char c = dateStr.charAt(len-1);\n        DateFormat df;\n        String formatStr;\n\n        \n        if (len <= 10 && Character.isDigit(c)) {\n            df = _formatPlain;\n            formatStr = DATE_FORMAT_STR_PLAIN;\n            if (df == null) {\n                df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, formatStr,\n                        _timezone, _locale, _lenient);\n            }\n        } else if (c == 'Z') {\n            df = _formatISO8601_z;\n            formatStr = DATE_FORMAT_STR_ISO8601_Z;\n            if (df == null) {\n                \n                \n                \n                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr,\n                        DEFAULT_TIMEZONE, _locale, _lenient);\n            }\n            \n            if (dateStr.charAt(len-4) == ':') {\n                StringBuilder sb = new StringBuilder(dateStr);\n                sb.insert(len-1, \".000\");\n                dateStr = sb.toString();\n            }\n        } else {\n            \n            if (hasTimeZone(dateStr)) {\n                c = dateStr.charAt(len-3);\n                if (c == ':') { \n                    \n                    StringBuilder sb = new StringBuilder(dateStr);\n                    sb.delete(len-3, len-2);\n                    dateStr = sb.toString();\n                } else if (c == '+' || c == '-') { \n                    \n                    dateStr += \"00\";\n                }\n                \n                len = dateStr.length();\n                \n                int timeLen = len - dateStr.lastIndexOf('T') - 6;\n                if (timeLen < 12) { \n                    int offset = len - 5; \n                    StringBuilder sb = new StringBuilder(dateStr);\n                    switch (timeLen) {\n                    case 11:\n                        sb.insert(offset, '0'); break;\n                    case 10:\n                        sb.insert(offset, \"00\"); break;\n                    case 9: \n                        sb.insert(offset, \"000\"); break;\n                    case 8:\n                        sb.insert(offset, \".000\"); break;\n                    case 7: \n                        break;\n                    case 6: \n                        sb.insert(offset, \"00.000\");\n                    case 5: \n                        sb.insert(offset, \":00.000\");\n                    }\n                    dateStr = sb.toString();\n                }\n                df = _formatISO8601;\n                formatStr = DATE_FORMAT_STR_ISO8601;\n                if (_formatISO8601 == null) {\n                    df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, formatStr,\n                            _timezone, _locale, _lenient);\n                }\n            } else {\n                \n                int timeLen = len - dateStr.lastIndexOf('T') - 1;\n                \n                if (timeLen < 12) { \n                    StringBuilder sb = new StringBuilder(dateStr);\n                    switch (timeLen) {\n                    case 11: sb.append('0');\n                    case 10: sb.append('0');\n                    case 9: sb.append('0');\n                        break;\n                    default:\n                        sb.append(\".000\");\n                    }\n                    dateStr = sb.toString();\n                }\n                df = _formatISO8601_noTz;\n                formatStr = DATE_FORMAT_STR_ISO8601_NO_TZ;\n                if (df == null) {\n                    \n                    \n                    \n                    df = _formatISO8601_noTz = _cloneFormat(DATE_FORMAT_ISO8601_NO_TZ, formatStr,\n                            _timezone, _locale, _lenient);\n                }\n            }\n        }\n        Date dt = df.parse(dateStr, pos);\n        \n        if (dt == null) {\n            throw new ParseException\n            (String.format(\"Can not parse date \\\"%s\\\": while it seems to fit format '%s', parsing fails (leniency? %s)\",\n                           dateStr, formatStr, _lenient),\n               pos.getErrorIndex());\n        }\n        return dt;\n    }\n\n    protected Date parseAsRFC1123(String dateStr, ParsePosition pos) {\n        if (_formatRFC1123 == null) {\n            _formatRFC1123 = _cloneFormat(DATE_FORMAT_RFC1123, DATE_FORMAT_STR_RFC1123,\n                    _timezone, _locale, _lenient);\n        }\n        return _formatRFC1123.parse(dateStr, pos);\n    }\n\n    private final static boolean hasTimeZone(String str) {\n        \n        int len = str.length();\n        if (len >= 6) {\n            char c = str.charAt(len-6);\n            if (c == '+' || c == '-') return true;\n            c = str.charAt(len-5);\n            if (c == '+' || c == '-') return true;\n            c = str.charAt(len-3);\n            if (c == '+' || c == '-') return true;\n        }\n        return false;\n    }\n\n    private final static DateFormat _cloneFormat(DateFormat df, String format, TimeZone tz, Locale loc, Boolean lenient) {\n        if (!loc.equals(DEFAULT_LOCALE)) {\n            df = new SimpleDateFormat(format, loc);\n            df.setTimeZone((tz == null) ? DEFAULT_TIMEZONE : tz);\n        } else {\n            df = (DateFormat) df.clone();\n            if (tz != null) {\n                df.setTimeZone(tz);\n            }\n        }\n        if (lenient != null) {\n            df.setLenient(lenient.booleanValue());\n        }\n        return df;\n    }\n\n    protected void _clearFormats() {\n        _formatRFC1123 = null;\n        _formatISO8601 = null;\n        _formatISO8601_z = null;\n        _formatISO8601_noTz = null;\n\n        _formatPlain = null;\n    }\n}\n\n",
      "buggy_signatures": [
        "public StdDateFormat(TimeZone tz, Locale loc)",
        "protected StdDateFormat(TimeZone tz, Locale loc, Boolean lenient)",
        "public static TimeZone getDefaultTimeZone()",
        "public StdDateFormat withTimeZone(TimeZone tz)",
        "public StdDateFormat withLocale(Locale loc)",
        "public StdDateFormat clone()",
        "public static DateFormat getISO8601Format(TimeZone tz)",
        "public static DateFormat getISO8601Format(TimeZone tz, Locale loc)",
        "public static DateFormat getRFC1123Format(TimeZone tz, Locale loc)",
        "public static DateFormat getRFC1123Format(TimeZone tz)",
        "public TimeZone getTimeZone()",
        "public void setTimeZone(TimeZone tz)",
        "public void setLenient(boolean enabled)",
        "public boolean isLenient()",
        "public Date parse(String dateStr) throws ParseException",
        "public Date parse(String dateStr, ParsePosition pos)",
        "public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition)",
        "public String toString()",
        "public boolean equals(Object o)",
        "public int hashCode()",
        "protected boolean looksLikeISO8601(String dateStr)",
        "protected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors) throws ParseException",
        "protected Date parseAsRFC1123(String dateStr, ParsePosition pos)",
        "private final static boolean hasTimeZone(String str)",
        "private final static DateFormat _cloneFormat(DateFormat df, String format, TimeZone tz, Locale loc, Boolean lenient)",
        "protected void _clearFormats()"
      ],
      "fixed_signatures": [
        "public StdDateFormat(TimeZone tz, Locale loc)",
        "protected StdDateFormat(TimeZone tz, Locale loc, Boolean lenient)",
        "public static TimeZone getDefaultTimeZone()",
        "public StdDateFormat withTimeZone(TimeZone tz)",
        "public StdDateFormat withLocale(Locale loc)",
        "public StdDateFormat clone()",
        "public static DateFormat getISO8601Format(TimeZone tz)",
        "public static DateFormat getISO8601Format(TimeZone tz, Locale loc)",
        "public static DateFormat getRFC1123Format(TimeZone tz, Locale loc)",
        "public static DateFormat getRFC1123Format(TimeZone tz)",
        "public TimeZone getTimeZone()",
        "public void setTimeZone(TimeZone tz)",
        "public void setLenient(boolean enabled)",
        "public boolean isLenient()",
        "public Date parse(String dateStr) throws ParseException",
        "public Date parse(String dateStr, ParsePosition pos)",
        "public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition)",
        "public String toString()",
        "public boolean equals(Object o)",
        "public int hashCode()",
        "protected boolean looksLikeISO8601(String dateStr)",
        "protected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors) throws ParseException",
        "protected Date parseAsRFC1123(String dateStr, ParsePosition pos)",
        "private final static boolean hasTimeZone(String str)",
        "private final static DateFormat _cloneFormat(DateFormat df, String format, TimeZone tz, Locale loc, Boolean lenient)",
        "protected void _clearFormats()"
      ],
      "methods": [
        {
          "buggy_method": "",
          "fixed_method": "",
          "diff": [
            "@@ -44,6 +44,7 @@",
            "      *\n",
            "      * @since 2.8.10\n",
            "      */\n",
            "+    protected final static String DATE_FORMAT_STR_ISO8601_NO_TZ = \"yyyy-MM-dd'T'HH:mm:ss.SSS\";\n",
            " \n",
            "     /**\n",
            "      * ISO-8601 with just the Date part, no time\n"
          ],
          "changed_lines": 1
        },
        {
          "buggy_method": "",
          "fixed_method": "",
          "diff": [
            "@@ -62,6 +63,7 @@",
            "     protected final static String[] ALL_FORMATS = new String[] {\n",
            "         DATE_FORMAT_STR_ISO8601,\n",
            "         DATE_FORMAT_STR_ISO8601_Z,\n",
            "+        DATE_FORMAT_STR_ISO8601_NO_TZ,\n",
            "         DATE_FORMAT_STR_RFC1123,\n",
            "         DATE_FORMAT_STR_PLAIN\n",
            "     };\n"
          ],
          "changed_lines": 1
        },
        {
          "buggy_method": "",
          "fixed_method": "",
          "diff": [
            "@@ -81,6 +83,7 @@",
            " \n",
            "     protected final static DateFormat DATE_FORMAT_ISO8601;\n",
            "     protected final static DateFormat DATE_FORMAT_ISO8601_Z;\n",
            "+    protected final static DateFormat DATE_FORMAT_ISO8601_NO_TZ; // since 2.8.10\n",
            " \n",
            "     protected final static DateFormat DATE_FORMAT_PLAIN;\n",
            " \n"
          ],
          "changed_lines": 1
        },
        {
          "buggy_method": "",
          "fixed_method": "",
          "diff": [
            "@@ -99,6 +102,8 @@",
            "         DATE_FORMAT_ISO8601.setTimeZone(DEFAULT_TIMEZONE);\n",
            "         DATE_FORMAT_ISO8601_Z = new SimpleDateFormat(DATE_FORMAT_STR_ISO8601_Z, DEFAULT_LOCALE);\n",
            "         DATE_FORMAT_ISO8601_Z.setTimeZone(DEFAULT_TIMEZONE);\n",
            "+        DATE_FORMAT_ISO8601_NO_TZ = new SimpleDateFormat(DATE_FORMAT_STR_ISO8601_NO_TZ, DEFAULT_LOCALE);\n",
            "+        DATE_FORMAT_ISO8601_NO_TZ.setTimeZone(DEFAULT_TIMEZONE);\n",
            "         DATE_FORMAT_PLAIN = new SimpleDateFormat(DATE_FORMAT_STR_PLAIN, DEFAULT_LOCALE);\n",
            "         DATE_FORMAT_PLAIN.setTimeZone(DEFAULT_TIMEZONE);\n",
            "     }\n"
          ],
          "changed_lines": 2
        },
        {
          "buggy_method": "  public final static StdDateFormat instance = new StdDateFormat(); protected transient TimeZone _timezone; protected final Locale _locale; /** * Explicit override for leniency, if specified. *<p> * Can not be `final` because {@link #setLenient(boolean)} returns",
          "fixed_method": "  public final static StdDateFormat instance = new StdDateFormat(); protected transient TimeZone _timezone; protected final Locale _locale; /** * Explicit override for leniency, if specified. *<p> * Can not be `final` because {@link #setLenient(boolean)} returns",
          "diff": [
            "@@ -129,6 +134,7 @@",
            "     protected transient DateFormat _formatRFC1123;\n",
            "     protected transient DateFormat _formatISO8601;\n",
            "     protected transient DateFormat _formatISO8601_z;\n",
            "+    protected transient DateFormat _formatISO8601_noTz; // 2.8.10\n",
            "     protected transient DateFormat _formatPlain;\n",
            " \n",
            "     /*\n"
          ],
          "changed_lines": 1
        },
        {
          "buggy_method": "  protected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors) throws ParseException {\n  \n\n  \n  int len = dateStr.length();\n  char c = dateStr.charAt(len-1);\n  DateFormat df;\n  String formatStr;\n\n  \n  if (len <= 10 && Character.isDigit(c)) {\n  df = _formatPlain;\n  formatStr = DATE_FORMAT_STR_PLAIN;\n  if (df == null) {\n  df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, formatStr,\n  _timezone, _locale, _lenient);\n  }\n  } else if (c == 'Z') {\n  df = _formatISO8601_z;\n  formatStr = DATE_FORMAT_STR_ISO8601_Z;\n  if (df == null) {\n  \n  \n  \n  df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr,\n  DEFAULT_TIMEZONE, _locale, _lenient);\n  }\n  \n  if (dateStr.charAt(len-4) == ':') {\n  StringBuilder sb = new StringBuilder(dateStr);\n  sb.insert(len-1, \".000\");\n  dateStr = sb.toString();\n  }\n  } else {\n  \n  if (hasTimeZone(dateStr)) {\n  c = dateStr.charAt(len-3);\n  if (c == ':') { \n  \n  StringBuilder sb = new StringBuilder(dateStr);\n  sb.delete(len-3, len-2);\n  dateStr = sb.toString();\n  } else if (c == '+' || c == '-') { \n  \n  dateStr += \"00\";\n  }\n  \n  len = dateStr.length();\n  \n  int timeLen = len - dateStr.lastIndexOf('T') - 6;\n  if (timeLen < 12) { \n  int offset = len - 5; \n  StringBuilder sb = new StringBuilder(dateStr);\n  switch (timeLen) {\n  case 11:\n  sb.insert(offset, '0'); break;\n  case 10:\n  sb.insert(offset, \"00\"); break;\n  case 9: \n  sb.insert(offset, \"000\"); break;\n  case 8:\n  sb.insert(offset, \".000\"); break;\n  case 7: \n  break;\n  case 6: \n  sb.insert(offset, \"00.000\");\n  case 5: \n  sb.insert(offset, \":00.000\");\n  }\n  dateStr = sb.toString();\n  }\n  df = _formatISO8601;\n  formatStr = DATE_FORMAT_STR_ISO8601;\n  if (_formatISO8601 == null) {\n  df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, formatStr,\n  _timezone, _locale, _lenient);\n  }\n  } else {\n  \n  StringBuilder sb = new StringBuilder(dateStr);\n  int timeLen = len - dateStr.lastIndexOf('T') - 1;\n  \n  if (timeLen < 12) { \n  switch (timeLen) {\n  case 11: sb.append('0');\n  case 10: sb.append('0');\n  case 9: sb.append('0');\n  break;\n  default:\n  sb.append(\".000\");\n  }\n  }\n  sb.append('Z');\n  dateStr = sb.toString();\n  df = _formatISO8601_z;\n  formatStr = DATE_FORMAT_STR_ISO8601_Z;\n  if (df == null) {\n  \n  \n  \n  df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr,\n  DEFAULT_TIMEZONE, _locale, _lenient);\n  }\n  }\n  }\n  Date dt = df.parse(dateStr, pos);\n  \n  if (dt == null) {\n  throw new ParseException\n  (String.format(\"Can not parse date \\\"%s\\\": while it seems to fit format '%s', parsing fails (leniency? %s)\",\n  dateStr, formatStr, _lenient),\n  pos.getErrorIndex());\n  }\n  return dt;\n  }",
          "fixed_method": "  protected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors) throws ParseException {\n  \n\n  \n  int len = dateStr.length();\n  char c = dateStr.charAt(len-1);\n  DateFormat df;\n  String formatStr;\n\n  \n  if (len <= 10 && Character.isDigit(c)) {\n  df = _formatPlain;\n  formatStr = DATE_FORMAT_STR_PLAIN;\n  if (df == null) {\n  df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, formatStr,\n  _timezone, _locale, _lenient);\n  }\n  } else if (c == 'Z') {\n  df = _formatISO8601_z;\n  formatStr = DATE_FORMAT_STR_ISO8601_Z;\n  if (df == null) {\n  \n  \n  \n  df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr,\n  DEFAULT_TIMEZONE, _locale, _lenient);\n  }\n  \n  if (dateStr.charAt(len-4) == ':') {\n  StringBuilder sb = new StringBuilder(dateStr);\n  sb.insert(len-1, \".000\");\n  dateStr = sb.toString();\n  }\n  } else {\n  \n  if (hasTimeZone(dateStr)) {\n  c = dateStr.charAt(len-3);\n  if (c == ':') { \n  \n  StringBuilder sb = new StringBuilder(dateStr);\n  sb.delete(len-3, len-2);\n  dateStr = sb.toString();\n  } else if (c == '+' || c == '-') { \n  \n  dateStr += \"00\";\n  }\n  \n  len = dateStr.length();\n  \n  int timeLen = len - dateStr.lastIndexOf('T') - 6;\n  if (timeLen < 12) { \n  int offset = len - 5; \n  StringBuilder sb = new StringBuilder(dateStr);\n  switch (timeLen) {\n  case 11:\n  sb.insert(offset, '0'); break;\n  case 10:\n  sb.insert(offset, \"00\"); break;\n  case 9: \n  sb.insert(offset, \"000\"); break;\n  case 8:\n  sb.insert(offset, \".000\"); break;\n  case 7: \n  break;\n  case 6: \n  sb.insert(offset, \"00.000\");\n  case 5: \n  sb.insert(offset, \":00.000\");\n  }\n  dateStr = sb.toString();\n  }\n  df = _formatISO8601;\n  formatStr = DATE_FORMAT_STR_ISO8601;\n  if (_formatISO8601 == null) {\n  df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, formatStr,\n  _timezone, _locale, _lenient);\n  }\n  } else {\n  \n  int timeLen = len - dateStr.lastIndexOf('T') - 1;\n  \n  if (timeLen < 12) { \n  StringBuilder sb = new StringBuilder(dateStr);\n  switch (timeLen) {\n  case 11: sb.append('0');\n  case 10: sb.append('0');\n  case 9: sb.append('0');\n  break;\n  default:\n  sb.append(\".000\");\n  }\n  dateStr = sb.toString();\n  }\n  df = _formatISO8601_noTz;\n  formatStr = DATE_FORMAT_STR_ISO8601_NO_TZ;\n  if (df == null) {\n  \n  \n  \n  df = _formatISO8601_noTz = _cloneFormat(DATE_FORMAT_ISO8601_NO_TZ, formatStr,\n  _timezone, _locale, _lenient);\n  }\n  }\n  }\n  Date dt = df.parse(dateStr, pos);\n  \n  if (dt == null) {\n  throw new ParseException\n  (String.format(\"Can not parse date \\\"%s\\\": while it seems to fit format '%s', parsing fails (leniency? %s)\",\n  dateStr, formatStr, _lenient),\n  pos.getErrorIndex());\n  }\n  return dt;\n  }",
          "diff": [
            "@@ -511,10 +517,10 @@",
            "                 }\n",
            "             } else {\n",
            "                 // If not, plain date, no timezone\n",
            "-                StringBuilder sb = new StringBuilder(dateStr);\n",
            "                 int timeLen = len - dateStr.lastIndexOf('T') - 1;\n",
            "                 // And possible also millisecond part if missing\n",
            "                 if (timeLen < 12) { // missing, or partial\n",
            "+                    StringBuilder sb = new StringBuilder(dateStr);\n",
            "                     switch (timeLen) {\n",
            "                     case 11: sb.append('0');\n",
            "                     case 10: sb.append('0');\n",
            "@@ -523,17 +529,16 @@",
            "                     default:\n",
            "                         sb.append(\".000\");\n",
            "                     }\n",
            "+                    dateStr = sb.toString();\n",
            "                 }\n",
            "-                sb.append('Z');\n",
            "-                dateStr = sb.toString();\n",
            "-                df = _formatISO8601_z;\n",
            "-                formatStr = DATE_FORMAT_STR_ISO8601_Z;\n",
            "+                df = _formatISO8601_noTz;\n",
            "+                formatStr = DATE_FORMAT_STR_ISO8601_NO_TZ;\n",
            "                 if (df == null) {\n",
            "                     // 10-Jun-2017, tatu: As per [databind#1651], when using this format,\n",
            "                     //    must use UTC, not whatever is configured as default timezone\n",
            "                     //    (because we know `Z` identifier is used)\n",
            "-                    df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr,\n",
            "-                            DEFAULT_TIMEZONE, _locale, _lenient);\n",
            "+                    df = _formatISO8601_noTz = _cloneFormat(DATE_FORMAT_ISO8601_NO_TZ, formatStr,\n",
            "+                            _timezone, _locale, _lenient);\n",
            "                 }\n",
            "             }\n",
            "         }\n"
          ],
          "changed_lines": 13
        },
        {
          "buggy_method": "  protected void _clearFormats() {\n  _formatRFC1123 = null;\n  _formatISO8601 = null;\n  _formatISO8601_z = null;\n\n  _formatPlain = null;\n  }",
          "fixed_method": "  protected void _clearFormats() {\n  _formatRFC1123 = null;\n  _formatISO8601 = null;\n  _formatISO8601_z = null;\n  _formatISO8601_noTz = null;\n\n  _formatPlain = null;\n  }",
          "diff": [
            "@@ -594,6 +599,7 @@",
            "         _formatRFC1123 = null;\n",
            "         _formatISO8601 = null;\n",
            "         _formatISO8601_z = null;\n",
            "+        _formatISO8601_noTz = null;\n",
            " \n",
            "         _formatPlain = null;\n",
            "     }\n"
          ],
          "changed_lines": 1
        }
      ]
    }
  ]
}
