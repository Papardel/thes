{
  "bug_id": "76",
  "failed_tests": {
    "org.apache.commons.math.linear.SingularValueSolverTest": [
      {
        "methodName": "testMath320A",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<0.0> but was:<0.09336767546650959>",
        "fail_line": "        Assert.assertEquals(0.0, recomposed.subtract(rm).getNorm(), 5.0e-13);",
        "test_source": "  public void testMath320A() {\n  RealMatrix rm = new Array2DRowRealMatrix(new double[][] {\n  { 1.0, 2.0, 3.0 }, { 2.0, 3.0, 4.0 }, { 3.0, 5.0, 7.0 }\n  });\n  double s439  = Math.sqrt(439.0);\n  double[] reference = new double[] {\n  Math.sqrt(3.0 * (21.0 + s439)), Math.sqrt(3.0 * (21.0 - s439))\n  };\n  SingularValueDecomposition svd =\n  new SingularValueDecompositionImpl(rm);\n\n  // check we get the expected theoretical singular values\n  double[] singularValues = svd.getSingularValues();\n  Assert.assertEquals(reference.length, singularValues.length);\n  for (int i = 0; i < reference.length; ++i) {\n  Assert.assertEquals(reference[i], singularValues[i], 4.0e-13);\n  }\n\n  // check the decomposition allows to recover the original matrix\n  RealMatrix recomposed = svd.getU().multiply(svd.getS()).multiply(svd.getVT());\n  Assert.assertEquals(0.0, recomposed.subtract(rm).getNorm(), 5.0e-13);\n\n  // check we can solve a singular system\n  double[] b = new double[] { 5.0, 6.0, 7.0 };\n  double[] resSVD = svd.getSolver().solve(b);\n  Assert.assertEquals(rm.getColumnDimension(), resSVD.length);\n\n  // check the solution really minimizes the residuals\n  double svdMinResidual = residual(rm, resSVD, b);\n  double epsilon = 2 * Math.ulp(svdMinResidual);\n  double h = 0.1;\n  int  k = 3;\n  for (double d0 = -k * h; d0 <= k * h; d0 += h) {\n  for (double d1 = -k * h ; d1 <= k * h; d1 += h) {\n  for (double d2 = -k * h; d2 <= k * h; d2 += h) {\n  double[] x = new double[] { resSVD[0] + d0, resSVD[1] + d1, resSVD[2] + d2 };\n  Assert.assertTrue((residual(rm, x, b) - svdMinResidual) > -epsilon);\n  }\n  }\n  }\n\n  }",
        "stack": [
          "SingularValueSolverTest.testMath320A line 188"
        ]
      },
      {
        "methodName": "testMath320B",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<0.0> but was:<3.2>",
        "fail_line": "        Assert.assertEquals(0.0, recomposed.subtract(rm).getNorm(), 2.0e-15);",
        "test_source": "  public void testMath320B() {\n  RealMatrix rm = new Array2DRowRealMatrix(new double[][] {\n  { 1.0, 2.0 }, { 1.0, 2.0 }\n  });\n  SingularValueDecomposition svd =\n  new SingularValueDecompositionImpl(rm);\n  RealMatrix recomposed = svd.getU().multiply(svd.getS()).multiply(svd.getVT());\n  Assert.assertEquals(0.0, recomposed.subtract(rm).getNorm(), 2.0e-15);\n  }",
        "stack": [
          "SingularValueSolverTest.testMath320B line 219"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/math/linear/SingularValueDecompositionImpl.java",
      "buggy_full_code": "\n\npackage org.apache.commons.math.linear;\n\nimport org.apache.commons.math.MathRuntimeException;\nimport org.apache.commons.math.util.MathUtils;\n\n\npublic class SingularValueDecompositionImpl implements SingularValueDecomposition { private int m; private int n; private BiDiagonalTransformer transformer; private double[] mainBidiagonal; private double[] secondaryBidiagonal; private double[] mainTridiagonal; private double[] secondaryTridiagonal; private EigenDecomposition eigenDecomposition; private double[] singularValues; private RealMatrix cachedU; private RealMatrix cachedUt; private RealMatrix cachedS; private RealMatrix cachedV; private RealMatrix cachedVt; public SingularValueDecompositionImpl(final RealMatrix matrix) throws InvalidMatrixException {\n        this(matrix, Math.min(matrix.getRowDimension(), matrix.getColumnDimension()));\n    }\n\n    \n    public SingularValueDecompositionImpl(final RealMatrix matrix, final int max) throws InvalidMatrixException {\n\n        m = matrix.getRowDimension();\n        n = matrix.getColumnDimension();\n\n        cachedU  = null;\n        cachedS  = null;\n        cachedV  = null;\n        cachedVt = null;\n\n        \n        transformer         = new BiDiagonalTransformer(matrix);\n        mainBidiagonal      = transformer.getMainDiagonalRef();\n        secondaryBidiagonal = transformer.getSecondaryDiagonalRef();\n\n        \n        mainTridiagonal      = new double[mainBidiagonal.length];\n        secondaryTridiagonal = new double[mainBidiagonal.length - 1];\n        double a = mainBidiagonal[0];\n        mainTridiagonal[0] = a * a;\n        for (int i = 1; i < mainBidiagonal.length; ++i) {\n            final double b  = secondaryBidiagonal[i - 1];\n            secondaryTridiagonal[i - 1] = a * b;\n            a = mainBidiagonal[i];\n            mainTridiagonal[i] = a * a + b * b;\n        }\n\n        \n        eigenDecomposition =\n            new EigenDecompositionImpl(mainTridiagonal, secondaryTridiagonal,\n                                       MathUtils.SAFE_MIN);\n        final double[] eigenValues = eigenDecomposition.getRealEigenvalues();\n        int p = Math.min(max, eigenValues.length);\n        while ((p > 0) && (eigenValues[p - 1] <= 0)) {\n            --p;\n        }\n        singularValues = new double[p];\n        for (int i = 0; i < p; ++i) {\n            singularValues[i] = Math.sqrt(eigenValues[i]);\n        }\n\n    }\n\n    \n    public RealMatrix getU() throws InvalidMatrixException {\n\n        if (cachedU == null) {\n\n            final int p = singularValues.length;\n            if (m >= n) {\n                \n                final RealMatrix e =\n                    eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);\n                final double[][] eData = e.getData();\n                final double[][] wData = new double[m][p];\n                double[] ei1 = eData[0];\n                for (int i = 0; i < p - 1; ++i) {\n                    \n                    final double mi = mainBidiagonal[i];\n                    final double[] ei0 = ei1;\n                    final double[] wi  = wData[i];\n                        ei1 = eData[i + 1];\n                        final double si = secondaryBidiagonal[i];\n                        for (int j = 0; j < p; ++j) {\n                            wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];\n                        }\n                }\n                        for (int j = 0; j < p; ++j) {\n                            wData[p - 1][j] = ei1[j] * mainBidiagonal[p - 1] / singularValues[j];\n                        }\n\n                for (int i = p; i < m; ++i) {\n                    wData[i] = new double[p];\n                }\n                cachedU =\n                    transformer.getU().multiply(MatrixUtils.createRealMatrix(wData));\n            } else {\n                \n                final RealMatrix e =\n                    eigenDecomposition.getV().getSubMatrix(0, m - 1, 0, p - 1);\n                cachedU = transformer.getU().multiply(e);\n            }\n\n        }\n\n        \n        return cachedU;\n\n    }\n\n    \n    public RealMatrix getUT() throws InvalidMatrixException {\n\n        if (cachedUt == null) {\n            cachedUt = getU().transpose();\n        }\n\n        \n        return cachedUt;\n\n    }\n\n    \n    public RealMatrix getS() throws InvalidMatrixException {\n\n        if (cachedS == null) {\n\n            \n            cachedS = MatrixUtils.createRealDiagonalMatrix(singularValues);\n\n        }\n        return cachedS;\n    }\n\n    \n    public double[] getSingularValues() throws InvalidMatrixException {\n        return singularValues.clone();\n    }\n\n    \n    public RealMatrix getV() throws InvalidMatrixException {\n\n        if (cachedV == null) {\n\n            final int p = singularValues.length;\n            if (m >= n) {\n                \n                final RealMatrix e =\n                    eigenDecomposition.getV().getSubMatrix(0, n - 1, 0, p - 1);\n                cachedV = transformer.getV().multiply(e);\n            } else {\n                \n                \n                final RealMatrix e =\n                    eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);\n                final double[][] eData = e.getData();\n                final double[][] wData = new double[n][p];\n                double[] ei1 = eData[0];\n                for (int i = 0; i < p - 1; ++i) {\n                    final double mi = mainBidiagonal[i];\n                    final double[] ei0 = ei1;\n                    final double[] wi  = wData[i];\n                        ei1 = eData[i + 1];\n                        final double si = secondaryBidiagonal[i];\n                        for (int j = 0; j < p; ++j) {\n                            wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];\n                        }\n                }\n                        for (int j = 0; j < p; ++j) {\n                            wData[p - 1][j] = ei1[j] * mainBidiagonal[p - 1] / singularValues[j];\n                        }\n                for (int i = p; i < n; ++i) {\n                    wData[i] = new double[p];\n                }\n                cachedV =\n                    transformer.getV().multiply(MatrixUtils.createRealMatrix(wData));\n            }\n\n        }\n\n        \n        return cachedV;\n\n    }\n\n    \n    public RealMatrix getVT() throws InvalidMatrixException {\n\n        if (cachedVt == null) {\n            cachedVt = getV().transpose();\n        }\n\n        \n        return cachedVt;\n\n    }\n\n    \n    public RealMatrix getCovariance(final double minSingularValue) {\n\n        \n        final int p = singularValues.length;\n        int dimension = 0;\n        while ((dimension < p) && (singularValues[dimension] >= minSingularValue)) {\n            ++dimension;\n        }\n\n        if (dimension == 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"cutoff singular value is {0}, should be at most {1}\",\n                  minSingularValue, singularValues[0]);\n        }\n\n        final double[][] data = new double[dimension][p];\n        getVT().walkInOptimizedOrder(new DefaultRealMatrixPreservingVisitor() {\n            \n            @Override\n            public void visit(final int row, final int column, final double value) {\n                data[row][column] = value / singularValues[row];\n            }\n        }, 0, dimension - 1, 0, p - 1);\n\n        RealMatrix jv = new Array2DRowRealMatrix(data, false);\n        return jv.transpose().multiply(jv);\n\n    }\n\n    \n    public double getNorm() throws InvalidMatrixException {\n        return singularValues[0];\n    }\n\n    \n    public double getConditionNumber() throws InvalidMatrixException {\n        return singularValues[0] / singularValues[singularValues.length - 1];\n    }\n\n    \n    public int getRank() throws IllegalStateException {\n\n        final double threshold = Math.max(m, n) * Math.ulp(singularValues[0]);\n\n        for (int i = singularValues.length - 1; i >= 0; --i) {\n           if (singularValues[i] > threshold) {\n              return i + 1;\n           }\n        }\n        return 0;\n\n    }\n\n    \n    public DecompositionSolver getSolver() {\n        return new Solver(singularValues, getUT(), getV(),\n                          getRank() == Math.max(m, n));\n    }\n\n    \n    private static class Solver implements DecompositionSolver { private final RealMatrix pseudoInverse; private boolean nonSingular; private Solver(final double[] singularValues, final RealMatrix uT, final RealMatrix v, final boolean nonSingular) {\n            double[][] suT      = uT.getData();\n            for (int i = 0; i < singularValues.length; ++i) {\n                final double a      = 1.0 / singularValues[i];\n                final double[] suTi = suT[i];\n                for (int j = 0; j < suTi.length; ++j) {\n                    suTi[j] *= a;\n                }\n            }\n            pseudoInverse    = v.multiply(new Array2DRowRealMatrix(suT, false));\n            this.nonSingular = nonSingular;\n        }\n\n        \n        public double[] solve(final double[] b) throws IllegalArgumentException {\n            return pseudoInverse.operate(b);\n        }\n\n        \n        public RealVector solve(final RealVector b) throws IllegalArgumentException {\n            return pseudoInverse.operate(b);\n        }\n\n        \n        public RealMatrix solve(final RealMatrix b) throws IllegalArgumentException {\n            return pseudoInverse.multiply(b);\n        }\n\n        \n        public boolean isNonSingular() {\n            return nonSingular;\n        }\n\n        \n        public RealMatrix getInverse() {\n            return pseudoInverse;\n        }\n\n    }\n\n}\n",
      "fixed_full_code": "\n\npackage org.apache.commons.math.linear;\n\nimport org.apache.commons.math.MathRuntimeException;\nimport org.apache.commons.math.util.MathUtils;\n\n\npublic class SingularValueDecompositionImpl implements SingularValueDecomposition { private int m; private int n; private BiDiagonalTransformer transformer; private double[] mainBidiagonal; private double[] secondaryBidiagonal; private double[] mainTridiagonal; private double[] secondaryTridiagonal; private EigenDecomposition eigenDecomposition; private double[] singularValues; private RealMatrix cachedU; private RealMatrix cachedUt; private RealMatrix cachedS; private RealMatrix cachedV; private RealMatrix cachedVt; public SingularValueDecompositionImpl(final RealMatrix matrix) throws InvalidMatrixException {\n        this(matrix, Math.min(matrix.getRowDimension(), matrix.getColumnDimension()));\n    }\n\n    \n    public SingularValueDecompositionImpl(final RealMatrix matrix, final int max) throws InvalidMatrixException {\n\n        m = matrix.getRowDimension();\n        n = matrix.getColumnDimension();\n\n        cachedU  = null;\n        cachedS  = null;\n        cachedV  = null;\n        cachedVt = null;\n\n        \n        transformer         = new BiDiagonalTransformer(matrix);\n        mainBidiagonal      = transformer.getMainDiagonalRef();\n        secondaryBidiagonal = transformer.getSecondaryDiagonalRef();\n\n        \n        mainTridiagonal      = new double[mainBidiagonal.length];\n        secondaryTridiagonal = new double[mainBidiagonal.length - 1];\n        double a = mainBidiagonal[0];\n        mainTridiagonal[0] = a * a;\n        for (int i = 1; i < mainBidiagonal.length; ++i) {\n            final double b  = secondaryBidiagonal[i - 1];\n            secondaryTridiagonal[i - 1] = a * b;\n            a = mainBidiagonal[i];\n            mainTridiagonal[i] = a * a + b * b;\n        }\n\n        \n        eigenDecomposition =\n            new EigenDecompositionImpl(mainTridiagonal, secondaryTridiagonal,\n                                       MathUtils.SAFE_MIN);\n        final double[] eigenValues = eigenDecomposition.getRealEigenvalues();\n        int p = Math.min(max, eigenValues.length);\n        while ((p > 0) && (eigenValues[p - 1] <= 0)) {\n            --p;\n        }\n        singularValues = new double[p];\n        for (int i = 0; i < p; ++i) {\n            singularValues[i] = Math.sqrt(eigenValues[i]);\n        }\n\n    }\n\n    \n    public RealMatrix getU() throws InvalidMatrixException {\n\n        if (cachedU == null) {\n\n            final int p = singularValues.length;\n            if (m >= n) {\n                \n                final RealMatrix e =\n                    eigenDecomposition.getV().getSubMatrix(0, n - 1, 0, p - 1);\n                final double[][] eData = e.getData();\n                final double[][] wData = new double[m][p];\n                double[] ei1 = eData[0];\n                for (int i = 0; i < p; ++i) {\n                    \n                    final double mi = mainBidiagonal[i];\n                    final double[] ei0 = ei1;\n                    final double[] wi  = wData[i];\n                    if (i < n - 1) {\n                        ei1 = eData[i + 1];\n                        final double si = secondaryBidiagonal[i];\n                        for (int j = 0; j < p; ++j) {\n                            wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];\n                        }\n                    } else {\n                        for (int j = 0; j < p; ++j) {\n                            wi[j] = mi * ei0[j] / singularValues[j];\n                        }\n                    }\n                }\n\n                for (int i = p; i < m; ++i) {\n                    wData[i] = new double[p];\n                }\n                cachedU =\n                    transformer.getU().multiply(MatrixUtils.createRealMatrix(wData));\n            } else {\n                \n                final RealMatrix e =\n                    eigenDecomposition.getV().getSubMatrix(0, m - 1, 0, p - 1);\n                cachedU = transformer.getU().multiply(e);\n            }\n\n        }\n\n        \n        return cachedU;\n\n    }\n\n    \n    public RealMatrix getUT() throws InvalidMatrixException {\n\n        if (cachedUt == null) {\n            cachedUt = getU().transpose();\n        }\n\n        \n        return cachedUt;\n\n    }\n\n    \n    public RealMatrix getS() throws InvalidMatrixException {\n\n        if (cachedS == null) {\n\n            \n            cachedS = MatrixUtils.createRealDiagonalMatrix(singularValues);\n\n        }\n        return cachedS;\n    }\n\n    \n    public double[] getSingularValues() throws InvalidMatrixException {\n        return singularValues.clone();\n    }\n\n    \n    public RealMatrix getV() throws InvalidMatrixException {\n\n        if (cachedV == null) {\n\n            final int p = singularValues.length;\n            if (m >= n) {\n                \n                final RealMatrix e =\n                    eigenDecomposition.getV().getSubMatrix(0, n - 1, 0, p - 1);\n                cachedV = transformer.getV().multiply(e);\n            } else {\n                \n                \n                final RealMatrix e =\n                    eigenDecomposition.getV().getSubMatrix(0, m - 1, 0, p - 1);\n                final double[][] eData = e.getData();\n                final double[][] wData = new double[n][p];\n                double[] ei1 = eData[0];\n                for (int i = 0; i < p; ++i) {\n                    final double mi = mainBidiagonal[i];\n                    final double[] ei0 = ei1;\n                    final double[] wi  = wData[i];\n                    if (i < m - 1) {\n                        ei1 = eData[i + 1];\n                        final double si = secondaryBidiagonal[i];\n                        for (int j = 0; j < p; ++j) {\n                            wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];\n                        }\n                    } else {\n                        for (int j = 0; j < p; ++j) {\n                            wi[j] = mi * ei0[j] / singularValues[j];\n                        }\n                    }\n                }\n                for (int i = p; i < n; ++i) {\n                    wData[i] = new double[p];\n                }\n                cachedV =\n                    transformer.getV().multiply(MatrixUtils.createRealMatrix(wData));\n            }\n\n        }\n\n        \n        return cachedV;\n\n    }\n\n    \n    public RealMatrix getVT() throws InvalidMatrixException {\n\n        if (cachedVt == null) {\n            cachedVt = getV().transpose();\n        }\n\n        \n        return cachedVt;\n\n    }\n\n    \n    public RealMatrix getCovariance(final double minSingularValue) {\n\n        \n        final int p = singularValues.length;\n        int dimension = 0;\n        while ((dimension < p) && (singularValues[dimension] >= minSingularValue)) {\n            ++dimension;\n        }\n\n        if (dimension == 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"cutoff singular value is {0}, should be at most {1}\",\n                  minSingularValue, singularValues[0]);\n        }\n\n        final double[][] data = new double[dimension][p];\n        getVT().walkInOptimizedOrder(new DefaultRealMatrixPreservingVisitor() {\n            \n            @Override\n            public void visit(final int row, final int column, final double value) {\n                data[row][column] = value / singularValues[row];\n            }\n        }, 0, dimension - 1, 0, p - 1);\n\n        RealMatrix jv = new Array2DRowRealMatrix(data, false);\n        return jv.transpose().multiply(jv);\n\n    }\n\n    \n    public double getNorm() throws InvalidMatrixException {\n        return singularValues[0];\n    }\n\n    \n    public double getConditionNumber() throws InvalidMatrixException {\n        return singularValues[0] / singularValues[singularValues.length - 1];\n    }\n\n    \n    public int getRank() throws IllegalStateException {\n\n        final double threshold = Math.max(m, n) * Math.ulp(singularValues[0]);\n\n        for (int i = singularValues.length - 1; i >= 0; --i) {\n           if (singularValues[i] > threshold) {\n              return i + 1;\n           }\n        }\n        return 0;\n\n    }\n\n    \n    public DecompositionSolver getSolver() {\n        return new Solver(singularValues, getUT(), getV(),\n                          getRank() == Math.max(m, n));\n    }\n\n    \n    private static class Solver implements DecompositionSolver { private final RealMatrix pseudoInverse; private boolean nonSingular; private Solver(final double[] singularValues, final RealMatrix uT, final RealMatrix v, final boolean nonSingular) {\n            double[][] suT      = uT.getData();\n            for (int i = 0; i < singularValues.length; ++i) {\n                final double a      = 1.0 / singularValues[i];\n                final double[] suTi = suT[i];\n                for (int j = 0; j < suTi.length; ++j) {\n                    suTi[j] *= a;\n                }\n            }\n            pseudoInverse    = v.multiply(new Array2DRowRealMatrix(suT, false));\n            this.nonSingular = nonSingular;\n        }\n\n        \n        public double[] solve(final double[] b) throws IllegalArgumentException {\n            return pseudoInverse.operate(b);\n        }\n\n        \n        public RealVector solve(final RealVector b) throws IllegalArgumentException {\n            return pseudoInverse.operate(b);\n        }\n\n        \n        public RealMatrix solve(final RealMatrix b) throws IllegalArgumentException {\n            return pseudoInverse.multiply(b);\n        }\n\n        \n        public boolean isNonSingular() {\n            return nonSingular;\n        }\n\n        \n        public RealMatrix getInverse() {\n            return pseudoInverse;\n        }\n\n    }\n\n}\n",
      "buggy_signatures": [
        "public class SingularValueDecompositionImpl implements SingularValueDecomposition { private int m; private int n; private BiDiagonalTransformer transformer; private double[] mainBidiagonal; private double[] secondaryBidiagonal; private double[] mainTridiagonal; private double[] secondaryTridiagonal; private EigenDecomposition eigenDecomposition; private double[] singularValues; private RealMatrix cachedU; private RealMatrix cachedUt; private RealMatrix cachedS; private RealMatrix cachedV; private RealMatrix cachedVt; public SingularValueDecompositionImpl(final RealMatrix matrix) throws InvalidMatrixException",
        "public SingularValueDecompositionImpl(final RealMatrix matrix, final int max) throws InvalidMatrixException",
        "public RealMatrix getU() throws InvalidMatrixException",
        "public RealMatrix getUT() throws InvalidMatrixException",
        "public RealMatrix getS() throws InvalidMatrixException",
        "public double[] getSingularValues() throws InvalidMatrixException",
        "public RealMatrix getV() throws InvalidMatrixException",
        "public RealMatrix getVT() throws InvalidMatrixException",
        "public RealMatrix getCovariance(final double minSingularValue)",
        "public void visit(final int row, final int column, final double value)",
        "public double getNorm() throws InvalidMatrixException",
        "public double getConditionNumber() throws InvalidMatrixException",
        "public int getRank() throws IllegalStateException",
        "public DecompositionSolver getSolver()",
        "private static class Solver implements DecompositionSolver { private final RealMatrix pseudoInverse; private boolean nonSingular; private Solver(final double[] singularValues, final RealMatrix uT, final RealMatrix v, final boolean nonSingular)",
        "public double[] solve(final double[] b) throws IllegalArgumentException",
        "public RealVector solve(final RealVector b) throws IllegalArgumentException",
        "public RealMatrix solve(final RealMatrix b) throws IllegalArgumentException",
        "public boolean isNonSingular()",
        "public RealMatrix getInverse()"
      ],
      "fixed_signatures": [
        "public class SingularValueDecompositionImpl implements SingularValueDecomposition { private int m; private int n; private BiDiagonalTransformer transformer; private double[] mainBidiagonal; private double[] secondaryBidiagonal; private double[] mainTridiagonal; private double[] secondaryTridiagonal; private EigenDecomposition eigenDecomposition; private double[] singularValues; private RealMatrix cachedU; private RealMatrix cachedUt; private RealMatrix cachedS; private RealMatrix cachedV; private RealMatrix cachedVt; public SingularValueDecompositionImpl(final RealMatrix matrix) throws InvalidMatrixException",
        "public SingularValueDecompositionImpl(final RealMatrix matrix, final int max) throws InvalidMatrixException",
        "public RealMatrix getU() throws InvalidMatrixException",
        "public RealMatrix getUT() throws InvalidMatrixException",
        "public RealMatrix getS() throws InvalidMatrixException",
        "public double[] getSingularValues() throws InvalidMatrixException",
        "public RealMatrix getV() throws InvalidMatrixException",
        "public RealMatrix getVT() throws InvalidMatrixException",
        "public RealMatrix getCovariance(final double minSingularValue)",
        "public void visit(final int row, final int column, final double value)",
        "public double getNorm() throws InvalidMatrixException",
        "public double getConditionNumber() throws InvalidMatrixException",
        "public int getRank() throws IllegalStateException",
        "public DecompositionSolver getSolver()",
        "private static class Solver implements DecompositionSolver { private final RealMatrix pseudoInverse; private boolean nonSingular; private Solver(final double[] singularValues, final RealMatrix uT, final RealMatrix v, final boolean nonSingular)",
        "public double[] solve(final double[] b) throws IllegalArgumentException",
        "public RealVector solve(final RealVector b) throws IllegalArgumentException",
        "public RealMatrix solve(final RealMatrix b) throws IllegalArgumentException",
        "public boolean isNonSingular()",
        "public RealMatrix getInverse()"
      ],
      "methods": [
        {
          "buggy_method": "  public RealMatrix getU() throws InvalidMatrixException {\n\n  if (cachedU == null) {\n\n  final int p = singularValues.length;\n  if (m >= n) {\n  \n  final RealMatrix e =\n  eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);\n  final double[][] eData = e.getData();\n  final double[][] wData = new double[m][p];\n  double[] ei1 = eData[0];\n  for (int i = 0; i < p - 1; ++i) {\n  \n  final double mi = mainBidiagonal[i];\n  final double[] ei0 = ei1;\n  final double[] wi  = wData[i];\n  ei1 = eData[i + 1];\n  final double si = secondaryBidiagonal[i];\n  for (int j = 0; j < p; ++j) {\n  wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];\n  }\n  }\n  for (int j = 0; j < p; ++j) {\n  wData[p - 1][j] = ei1[j] * mainBidiagonal[p - 1] / singularValues[j];\n  }\n\n  for (int i = p; i < m; ++i) {\n  wData[i] = new double[p];\n  }\n  cachedU =\n  transformer.getU().multiply(MatrixUtils.createRealMatrix(wData));\n  } else {\n  \n  final RealMatrix e =\n  eigenDecomposition.getV().getSubMatrix(0, m - 1, 0, p - 1);\n  cachedU = transformer.getU().multiply(e);\n  }\n\n  }\n\n  \n  return cachedU;\n\n  }",
          "fixed_method": "  public RealMatrix getU() throws InvalidMatrixException {\n\n  if (cachedU == null) {\n\n  final int p = singularValues.length;\n  if (m >= n) {\n  \n  final RealMatrix e =\n  eigenDecomposition.getV().getSubMatrix(0, n - 1, 0, p - 1);\n  final double[][] eData = e.getData();\n  final double[][] wData = new double[m][p];\n  double[] ei1 = eData[0];\n  for (int i = 0; i < p; ++i) {\n  \n  final double mi = mainBidiagonal[i];\n  final double[] ei0 = ei1;\n  final double[] wi  = wData[i];\n  if (i < n - 1) {\n  ei1 = eData[i + 1];\n  final double si = secondaryBidiagonal[i];\n  for (int j = 0; j < p; ++j) {\n  wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];\n  }\n  } else {\n  for (int j = 0; j < p; ++j) {\n  wi[j] = mi * ei0[j] / singularValues[j];\n  }\n  }\n  }\n\n  for (int i = p; i < m; ++i) {\n  wData[i] = new double[p];\n  }\n  cachedU =\n  transformer.getU().multiply(MatrixUtils.createRealMatrix(wData));\n  } else {\n  \n  final RealMatrix e =\n  eigenDecomposition.getV().getSubMatrix(0, m - 1, 0, p - 1);\n  cachedU = transformer.getU().multiply(e);\n  }\n\n  }\n\n  \n  return cachedU;\n\n  }",
          "diff": [
            "@@ -159,24 +159,27 @@",
            "             if (m >= n) {\n",
            "                 // the tridiagonal matrix is Bt.B, where B is upper bidiagonal\n",
            "                 final RealMatrix e =\n",
            "-                    eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);\n",
            "+                    eigenDecomposition.getV().getSubMatrix(0, n - 1, 0, p - 1);\n",
            "                 final double[][] eData = e.getData();\n",
            "                 final double[][] wData = new double[m][p];\n",
            "                 double[] ei1 = eData[0];\n",
            "-                for (int i = 0; i < p - 1; ++i) {\n",
            "+                for (int i = 0; i < p; ++i) {\n",
            "                     // compute W = B.E.S^(-1) where E is the eigenvectors matrix\n",
            "                     final double mi = mainBidiagonal[i];\n",
            "                     final double[] ei0 = ei1;\n",
            "                     final double[] wi  = wData[i];\n",
            "+                    if (i < n - 1) {\n",
            "                         ei1 = eData[i + 1];\n",
            "                         final double si = secondaryBidiagonal[i];\n",
            "                         for (int j = 0; j < p; ++j) {\n",
            "                             wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];\n",
            "                         }\n",
            "+                    } else {\n",
            "+                        for (int j = 0; j < p; ++j) {\n",
            "+                            wi[j] = mi * ei0[j] / singularValues[j];\n",
            "+                        }\n",
            "+                    }\n",
            "                 }\n",
            "-                        for (int j = 0; j < p; ++j) {\n",
            "-                            wData[p - 1][j] = ei1[j] * mainBidiagonal[p - 1] / singularValues[j];\n",
            "-                        }\n",
            " \n",
            "                 for (int i = p; i < m; ++i) {\n",
            "                     wData[i] = new double[p];\n"
          ],
          "changed_lines": 13
        },
        {
          "buggy_method": "  public RealMatrix getV() throws InvalidMatrixException {\n\n  if (cachedV == null) {\n\n  final int p = singularValues.length;\n  if (m >= n) {\n  \n  final RealMatrix e =\n  eigenDecomposition.getV().getSubMatrix(0, n - 1, 0, p - 1);\n  cachedV = transformer.getV().multiply(e);\n  } else {\n  \n  \n  final RealMatrix e =\n  eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);\n  final double[][] eData = e.getData();\n  final double[][] wData = new double[n][p];\n  double[] ei1 = eData[0];\n  for (int i = 0; i < p - 1; ++i) {\n  final double mi = mainBidiagonal[i];\n  final double[] ei0 = ei1;\n  final double[] wi  = wData[i];\n  ei1 = eData[i + 1];\n  final double si = secondaryBidiagonal[i];\n  for (int j = 0; j < p; ++j) {\n  wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];\n  }\n  }\n  for (int j = 0; j < p; ++j) {\n  wData[p - 1][j] = ei1[j] * mainBidiagonal[p - 1] / singularValues[j];\n  }\n  for (int i = p; i < n; ++i) {\n  wData[i] = new double[p];\n  }\n  cachedV =\n  transformer.getV().multiply(MatrixUtils.createRealMatrix(wData));\n  }\n\n  }\n\n  \n  return cachedV;\n\n  }",
          "fixed_method": "  public RealMatrix getV() throws InvalidMatrixException {\n\n  if (cachedV == null) {\n\n  final int p = singularValues.length;\n  if (m >= n) {\n  \n  final RealMatrix e =\n  eigenDecomposition.getV().getSubMatrix(0, n - 1, 0, p - 1);\n  cachedV = transformer.getV().multiply(e);\n  } else {\n  \n  \n  final RealMatrix e =\n  eigenDecomposition.getV().getSubMatrix(0, m - 1, 0, p - 1);\n  final double[][] eData = e.getData();\n  final double[][] wData = new double[n][p];\n  double[] ei1 = eData[0];\n  for (int i = 0; i < p; ++i) {\n  final double mi = mainBidiagonal[i];\n  final double[] ei0 = ei1;\n  final double[] wi  = wData[i];\n  if (i < m - 1) {\n  ei1 = eData[i + 1];\n  final double si = secondaryBidiagonal[i];\n  for (int j = 0; j < p; ++j) {\n  wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];\n  }\n  } else {\n  for (int j = 0; j < p; ++j) {\n  wi[j] = mi * ei0[j] / singularValues[j];\n  }\n  }\n  }\n  for (int i = p; i < n; ++i) {\n  wData[i] = new double[p];\n  }\n  cachedV =\n  transformer.getV().multiply(MatrixUtils.createRealMatrix(wData));\n  }\n\n  }\n\n  \n  return cachedV;\n\n  }",
          "diff": [
            "@@ -245,23 +248,26 @@",
            "                 // the tridiagonal matrix is B.Bt, where B is lower bidiagonal\n",
            "                 // compute W = Bt.E.S^(-1) where E is the eigenvectors matrix\n",
            "                 final RealMatrix e =\n",
            "-                    eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);\n",
            "+                    eigenDecomposition.getV().getSubMatrix(0, m - 1, 0, p - 1);\n",
            "                 final double[][] eData = e.getData();\n",
            "                 final double[][] wData = new double[n][p];\n",
            "                 double[] ei1 = eData[0];\n",
            "-                for (int i = 0; i < p - 1; ++i) {\n",
            "+                for (int i = 0; i < p; ++i) {\n",
            "                     final double mi = mainBidiagonal[i];\n",
            "                     final double[] ei0 = ei1;\n",
            "                     final double[] wi  = wData[i];\n",
            "+                    if (i < m - 1) {\n",
            "                         ei1 = eData[i + 1];\n",
            "                         final double si = secondaryBidiagonal[i];\n",
            "                         for (int j = 0; j < p; ++j) {\n",
            "                             wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];\n",
            "                         }\n",
            "+                    } else {\n",
            "+                        for (int j = 0; j < p; ++j) {\n",
            "+                            wi[j] = mi * ei0[j] / singularValues[j];\n",
            "+                        }\n",
            "+                    }\n",
            "                 }\n",
            "-                        for (int j = 0; j < p; ++j) {\n",
            "-                            wData[p - 1][j] = ei1[j] * mainBidiagonal[p - 1] / singularValues[j];\n",
            "-                        }\n",
            "                 for (int i = p; i < n; ++i) {\n",
            "                     wData[i] = new double[p];\n",
            "                 }\n"
          ],
          "changed_lines": 13
        }
      ]
    }
  ]
}
