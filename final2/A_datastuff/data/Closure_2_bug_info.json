{
  "bug_id": "2",
  "failed_tests": {
    "com.google.javascript.jscomp.TypeCheckTest": [
      {
        "methodName": "testBadInterfaceExtendsNonExistentInterfaces",
        "error": "java.lang.NullPointerException",
        "message": "",
        "fail_line": "    testTypes(js, expectedWarnings);",
        "test_source": "  public void testBadInterfaceExtendsNonExistentInterfaces() throws Exception {\n  String js = \"/** @interface \\n\" +\n  \" * @extends {nonExistent1} \\n\" +\n  \" * @extends {nonExistent2} \\n\" +\n  \" */function A() {}\";\n  String[] expectedWarnings = {\n  \"Bad type annotation. Unknown type nonExistent1\",\n  \"Bad type annotation. Unknown type nonExistent2\"\n  };\n  testTypes(js, expectedWarnings);\n  }",
        "stack": [
          "TypeCheck.checkInterfaceConflictProperties line 1574, TypeCheck.visitFunction line 1664, TypeCheck.visit line 778, NodeTraversal.traverseBranch line 505, NodeTraversal.traverseBranch line 498, NodeTraversal.traverseWithScope line 343, TypeCheck.check line 404, TypeCheck.process line 375, TypeCheck.processForTesting line 393, TypeCheckTest.testTypes line 11530, TypeCheckTest.testBadInterfaceExtendsNonExistentInterfaces line 3780"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "com/google/javascript/jscomp/TypeCheck.java",
      "buggy_full_code": "\n\npackage com.google.javascript.jscomp;\n\nimport static com.google.javascript.rhino.jstype.JSTypeNative.ARRAY_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.BOOLEAN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NULL_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.OBJECT_FUNCTION_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.OBJECT_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.REGEXP_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.STRING_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.UNKNOWN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.VOID_TYPE; import com.google.common.base.Preconditions; import com.google.common.collect.ImmutableSet; import com.google.javascript.jscomp.CheckLevel; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.jscomp.type.ReverseAbstractInterpreter; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.jstype.EnumType; import com.google.javascript.rhino.jstype.FunctionType; import com.google.javascript.rhino.jstype.JSType; import com.google.javascript.rhino.jstype.JSTypeNative; import com.google.javascript.rhino.jstype.JSTypeRegistry; import com.google.javascript.rhino.jstype.ObjectType; import com.google.javascript.rhino.jstype.TernaryValue; import java.util.HashMap; import java.util.Iterator; import java.util.Set; public class TypeCheck implements NodeTraversal.Callback, CompilerPass { static final DiagnosticType UNEXPECTED_TOKEN = DiagnosticType.error( \"JSC_INTERNAL_ERROR_UNEXPECTED_TOKEN\", \"Internal Error: Don't know how to handle {0}\"); static final DiagnosticType BAD_DELETE = DiagnosticType.warning( \"JSC_BAD_DELETE_OPERAND\", \"delete operator needs a reference operand\"); protected static final String OVERRIDING_PROTOTYPE_WITH_NON_OBJECT = \"overriding prototype with non-object\"; static final DiagnosticType DETERMINISTIC_TEST = DiagnosticType.warning( \"JSC_DETERMINISTIC_TEST\", \"condition always evaluates to {2}\\n\" +\n          \"left : {0}\\n\" +\n          \"right: {1}\");\n\n  static final DiagnosticType DETERMINISTIC_TEST_NO_RESULT = DiagnosticType.warning( \"JSC_DETERMINISTIC_TEST_NO_RESULT\", \"condition always evaluates to the same value\\n\" + \"left : {0}\\n\" + \"right: {1}\"); static final DiagnosticType INEXISTENT_ENUM_ELEMENT = DiagnosticType.warning( \"JSC_INEXISTENT_ENUM_ELEMENT\", \"element {0} does not exist on this enum\");\n\n  \n  \n  static final DiagnosticType INEXISTENT_PROPERTY = DiagnosticType.disabled( \"JSC_INEXISTENT_PROPERTY\", \"Property {0} never defined on {1}\"); protected static final DiagnosticType NOT_A_CONSTRUCTOR = DiagnosticType.warning( \"JSC_NOT_A_CONSTRUCTOR\", \"cannot instantiate non-constructor\"); static final DiagnosticType BIT_OPERATION = DiagnosticType.warning( \"JSC_BAD_TYPE_FOR_BIT_OPERATION\", \"operator {0} cannot be applied to {1}\");\n\n  static final DiagnosticType NOT_CALLABLE = DiagnosticType.warning( \"JSC_NOT_FUNCTION_TYPE\", \"{0} expressions are not callable\"); static final DiagnosticType CONSTRUCTOR_NOT_CALLABLE = DiagnosticType.warning( \"JSC_CONSTRUCTOR_NOT_CALLABLE\", \"Constructor {0} should be called with the \\\"new\\\" keyword\");\n\n  static final DiagnosticType FUNCTION_MASKS_VARIABLE = DiagnosticType.warning( \"JSC_FUNCTION_MASKS_VARIABLE\", \"function {0} masks variable (IE bug)\"); static final DiagnosticType MULTIPLE_VAR_DEF = DiagnosticType.warning( \"JSC_MULTIPLE_VAR_DEF\", \"declaration of multiple variables with shared type information\"); static final DiagnosticType ENUM_DUP = DiagnosticType.error(\"JSC_ENUM_DUP\", \"enum element {0} already defined\");\n\n  static final DiagnosticType ENUM_NOT_CONSTANT = DiagnosticType.warning(\"JSC_ENUM_NOT_CONSTANT\", \"enum key {0} must be a syntactic constant\"); static final DiagnosticType INVALID_INTERFACE_MEMBER_DECLARATION = DiagnosticType.warning( \"JSC_INVALID_INTERFACE_MEMBER_DECLARATION\", \"interface members can only be empty property declarations,\" + \" empty functions {0}\");\n\n  static final DiagnosticType INTERFACE_FUNCTION_NOT_EMPTY = DiagnosticType.warning( \"JSC_INTERFACE_FUNCTION_NOT_EMPTY\", \"interface member functions must have an empty body\"); static final DiagnosticType CONFLICTING_EXTENDED_TYPE = DiagnosticType.warning( \"JSC_CONFLICTING_EXTENDED_TYPE\", \" {1} cannot extend this type; {0}s can only extend {0}s\");\n\n  static final DiagnosticType CONFLICTING_IMPLEMENTED_TYPE = DiagnosticType.warning( \"JSC_CONFLICTING_IMPLEMENTED_TYPE\", \"{0} cannot implement this type; \" + \"an interface can only extend, but not implement interfaces\"); static final DiagnosticType BAD_IMPLEMENTED_TYPE = DiagnosticType.warning( \"JSC_IMPLEMENTS_NON_INTERFACE\", \"can only implement interfaces\"); static final DiagnosticType HIDDEN_SUPERCLASS_PROPERTY = DiagnosticType.warning( \"JSC_HIDDEN_SUPERCLASS_PROPERTY\", \"property {0} already defined on superclass {1}; \" +\n          \"use @override to override it\");\n\n  static final DiagnosticType HIDDEN_INTERFACE_PROPERTY = DiagnosticType.warning( \"JSC_HIDDEN_INTERFACE_PROPERTY\", \"property {0} already defined on interface {1}; \" + \"use @override to override it\"); static final DiagnosticType HIDDEN_SUPERCLASS_PROPERTY_MISMATCH = DiagnosticType.warning(\"JSC_HIDDEN_SUPERCLASS_PROPERTY_MISMATCH\", \"mismatch of the {0} property type and the type \" +\n          \"of the property it overrides from superclass {1}\\n\" +\n          \"original: {2}\\n\" +\n          \"override: {3}\");\n\n  static final DiagnosticType UNKNOWN_OVERRIDE = DiagnosticType.warning( \"JSC_UNKNOWN_OVERRIDE\", \"property {0} not defined on any superclass of {1}\"); static final DiagnosticType INTERFACE_METHOD_OVERRIDE = DiagnosticType.warning( \"JSC_INTERFACE_METHOD_OVERRIDE\", \"property {0} is already defined by the {1} extended interface\");\n\n  static final DiagnosticType UNKNOWN_EXPR_TYPE = DiagnosticType.warning(\"JSC_UNKNOWN_EXPR_TYPE\", \"could not determine the type of this expression\"); static final DiagnosticType UNRESOLVED_TYPE = DiagnosticType.warning(\"JSC_UNRESOLVED_TYPE\", \"could not resolve the name {0} to a type\");\n\n  static final DiagnosticType WRONG_ARGUMENT_COUNT = DiagnosticType.warning( \"JSC_WRONG_ARGUMENT_COUNT\", \"Function {0}: called with {1} argument(s). \" + \"Function requires at least {2} argument(s){3}.\"); static final DiagnosticType ILLEGAL_IMPLICIT_CAST = DiagnosticType.warning( \"JSC_ILLEGAL_IMPLICIT_CAST\", \"Illegal annotation on {0}. @implicitCast may only be used in \" +\n          \"externs.\");\n\n  static final DiagnosticType INCOMPATIBLE_EXTENDED_PROPERTY_TYPE = DiagnosticType.warning( \"JSC_INCOMPATIBLE_EXTENDED_PROPERTY_TYPE\", \"Interface {0} has a property {1} with incompatible types in \" + \"its super interfaces {2} and {3}\"); static final DiagnosticType EXPECTED_THIS_TYPE = DiagnosticType.warning( \"JSC_EXPECTED_THIS_TYPE\", \"\\\" {0}\\\" must be called with a \\\"this\\\" type\");\n\n  static final DiagnosticType IN_USED_WITH_STRUCT = DiagnosticType.warning(\"JSC_IN_USED_WITH_STRUCT\", \"Cannot use the IN operator with structs\"); static final DiagnosticType ILLEGAL_PROPERTY_CREATION = DiagnosticType.warning(\"JSC_ILLEGAL_PROPERTY_CREATION\", \"Cannot add a property to a struct instance \" + \"after it is constructed.\"); static final DiagnosticType ILLEGAL_OBJLIT_KEY = DiagnosticType.warning( \"ILLEGAL_OBJLIT_KEY\", \"Illegal key, the object literal is a {0}\");\n\n  static final DiagnosticGroup ALL_DIAGNOSTICS = new DiagnosticGroup( DETERMINISTIC_TEST, DETERMINISTIC_TEST_NO_RESULT, INEXISTENT_ENUM_ELEMENT, INEXISTENT_PROPERTY, NOT_A_CONSTRUCTOR, BIT_OPERATION, NOT_CALLABLE, CONSTRUCTOR_NOT_CALLABLE, FUNCTION_MASKS_VARIABLE, MULTIPLE_VAR_DEF, ENUM_DUP, ENUM_NOT_CONSTANT, INVALID_INTERFACE_MEMBER_DECLARATION, INTERFACE_FUNCTION_NOT_EMPTY, CONFLICTING_EXTENDED_TYPE, CONFLICTING_IMPLEMENTED_TYPE, BAD_IMPLEMENTED_TYPE, HIDDEN_SUPERCLASS_PROPERTY, HIDDEN_INTERFACE_PROPERTY, HIDDEN_SUPERCLASS_PROPERTY_MISMATCH, UNKNOWN_OVERRIDE, INTERFACE_METHOD_OVERRIDE, UNKNOWN_EXPR_TYPE, UNRESOLVED_TYPE, WRONG_ARGUMENT_COUNT, ILLEGAL_IMPLICIT_CAST, INCOMPATIBLE_EXTENDED_PROPERTY_TYPE, EXPECTED_THIS_TYPE, IN_USED_WITH_STRUCT, ILLEGAL_PROPERTY_CREATION, ILLEGAL_OBJLIT_KEY, RhinoErrorReporter.TYPE_PARSE_ERROR, TypedScopeCreator.UNKNOWN_LENDS, TypedScopeCreator.LENDS_ON_NON_OBJECT, TypedScopeCreator.CTOR_INITIALIZER, TypedScopeCreator.IFACE_INITIALIZER, FunctionTypeBuilder.THIS_TYPE_NON_OBJECT); private final AbstractCompiler compiler; private final TypeValidator validator; private final ReverseAbstractInterpreter reverseInterpreter; private final JSTypeRegistry typeRegistry; private Scope topScope; private MemoizedScopeCreator scopeCreator; private final CheckLevel reportMissingOverride; private final CheckLevel reportUnknownTypes; private boolean reportMissingProperties = true; private InferJSDocInfo inferJSDocInfo = null; private int typedCount = 0; private int nullCount = 0; private int unknownCount = 0; private boolean inExterns; private int noTypeCheckSection = 0; public TypeCheck(AbstractCompiler compiler, ReverseAbstractInterpreter reverseInterpreter, JSTypeRegistry typeRegistry, Scope topScope, MemoizedScopeCreator scopeCreator, CheckLevel reportMissingOverride, CheckLevel reportUnknownTypes) {\n    this.compiler = compiler;\n    this.validator = compiler.getTypeValidator();\n    this.reverseInterpreter = reverseInterpreter;\n    this.typeRegistry = typeRegistry;\n    this.topScope = topScope;\n    this.scopeCreator = scopeCreator;\n    this.reportMissingOverride = reportMissingOverride;\n    this.reportUnknownTypes = reportUnknownTypes;\n    this.inferJSDocInfo = new InferJSDocInfo(compiler);\n  }\n\n  public TypeCheck(AbstractCompiler compiler, ReverseAbstractInterpreter reverseInterpreter, JSTypeRegistry typeRegistry, CheckLevel reportMissingOverride, CheckLevel reportUnknownTypes) {\n    this(compiler, reverseInterpreter, typeRegistry, null, null,\n        reportMissingOverride, reportUnknownTypes);\n  }\n\n  TypeCheck(AbstractCompiler compiler,\n      ReverseAbstractInterpreter reverseInterpreter,\n      JSTypeRegistry typeRegistry) {\n    this(compiler, reverseInterpreter, typeRegistry, null, null,\n         CheckLevel.WARNING, CheckLevel.OFF);\n  }\n\n  \n  TypeCheck reportMissingProperties(boolean report) {\n    reportMissingProperties = report;\n    return this;\n  }\n\n  \n  @Override\n  public void process(Node externsRoot, Node jsRoot) {\n    Preconditions.checkNotNull(scopeCreator);\n    Preconditions.checkNotNull(topScope);\n\n    Node externsAndJs = jsRoot.getParent();\n    Preconditions.checkState(externsAndJs != null);\n    Preconditions.checkState(\n        externsRoot == null || externsAndJs.hasChild(externsRoot));\n\n    if (externsRoot != null) {\n      check(externsRoot, true);\n    }\n    check(jsRoot, false);\n  }\n\n  \n  public Scope processForTesting(Node externsRoot, Node jsRoot) {\n    Preconditions.checkState(scopeCreator == null);\n    Preconditions.checkState(topScope == null);\n\n    Preconditions.checkState(jsRoot.getParent() != null);\n    Node externsAndJsRoot = jsRoot.getParent();\n\n    scopeCreator = new MemoizedScopeCreator(new TypedScopeCreator(compiler));\n    topScope = scopeCreator.createScope(externsAndJsRoot, null);\n\n    TypeInferencePass inference = new TypeInferencePass(compiler,\n        reverseInterpreter, topScope, scopeCreator);\n\n    inference.process(externsRoot, jsRoot);\n    process(externsRoot, jsRoot);\n\n    return topScope;\n  }\n\n\n  public void check(Node node, boolean externs) {\n    Preconditions.checkNotNull(node);\n\n    NodeTraversal t = new NodeTraversal(compiler, this, scopeCreator);\n    inExterns = externs;\n    t.traverseWithScope(node, topScope);\n    if (externs) {\n      inferJSDocInfo.process(node, null);\n    } else {\n      inferJSDocInfo.process(null, node);\n    }\n  }\n\n\n  private void checkNoTypeCheckSection(Node n, boolean enterSection) {\n    switch (n.getType()) {\n      case Token.SCRIPT:\n      case Token.BLOCK:\n      case Token.VAR:\n      case Token.FUNCTION:\n      case Token.ASSIGN:\n        JSDocInfo info = n.getJSDocInfo();\n        if (info != null && info.isNoTypeCheck()) {\n          if (enterSection) {\n            noTypeCheckSection++;\n          } else {\n            noTypeCheckSection--;\n          }\n        }\n        validator.setShouldReport(noTypeCheckSection == 0);\n        break;\n    }\n  }\n\n  private void report(NodeTraversal t, Node n, DiagnosticType diagnosticType, String... arguments) {\n    if (noTypeCheckSection == 0) {\n      t.report(n, diagnosticType, arguments);\n    }\n  }\n\n  @Override\n  public boolean shouldTraverse( NodeTraversal t, Node n, Node parent) {\n    checkNoTypeCheckSection(n, true);\n    switch (n.getType()) {\n      case Token.FUNCTION:\n        \n        final Scope outerScope = t.getScope();\n        final String functionPrivateName = n.getFirstChild().getString();\n        if (functionPrivateName != null && functionPrivateName.length() > 0 &&\n            outerScope.isDeclared(functionPrivateName, false) &&\n            \n            \n            \n            !(outerScope.getVar(\n                functionPrivateName).getType() instanceof FunctionType)) {\n          report(t, n, FUNCTION_MASKS_VARIABLE, functionPrivateName);\n        }\n\n        \n        \n        \n        break;\n    }\n    return true;\n  }\n\n  \n  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    JSType childType;\n    JSType leftType, rightType;\n    Node left, right;\n    \n    boolean typeable = true;\n\n    switch (n.getType()) {\n      case Token.CAST:\n        Node expr = n.getFirstChild();\n        ensureTyped(t, n, getJSType(expr));\n\n        \n        \n        JSType castType = getJSType(n);\n        JSType exprType = getJSType(expr);\n        if (castType.isSubtype(exprType)) {\n          expr.setJSType(castType);\n        }\n        break;\n\n      case Token.NAME:\n        typeable = visitName(t, n, parent);\n        break;\n\n      case Token.PARAM_LIST:\n        typeable = false;\n        break;\n\n      case Token.COMMA:\n        ensureTyped(t, n, getJSType(n.getLastChild()));\n        break;\n\n      case Token.TRUE:\n      case Token.FALSE:\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.THIS:\n        ensureTyped(t, n, t.getScope().getTypeOfThis());\n        break;\n\n      case Token.NULL:\n        ensureTyped(t, n, NULL_TYPE);\n        break;\n\n      case Token.NUMBER:\n        ensureTyped(t, n, NUMBER_TYPE);\n        break;\n\n      case Token.STRING:\n        ensureTyped(t, n, STRING_TYPE);\n        break;\n\n      case Token.STRING_KEY:\n        typeable = false;\n        break;\n\n      case Token.GETTER_DEF:\n      case Token.SETTER_DEF:\n        \n        break;\n\n      case Token.ARRAYLIT:\n        ensureTyped(t, n, ARRAY_TYPE);\n        break;\n\n      case Token.REGEXP:\n        ensureTyped(t, n, REGEXP_TYPE);\n        break;\n\n      case Token.GETPROP:\n        visitGetProp(t, n, parent);\n        typeable = !(parent.isAssign() &&\n                     parent.getFirstChild() == n);\n        break;\n\n      case Token.GETELEM:\n        visitGetElem(t, n);\n        \n        \n        \n        typeable = false;\n        break;\n\n      case Token.VAR:\n        visitVar(t, n);\n        typeable = false;\n        break;\n\n      case Token.NEW:\n        visitNew(t, n);\n        break;\n\n      case Token.CALL:\n        visitCall(t, n);\n        typeable = !parent.isExprResult();\n        break;\n\n      case Token.RETURN:\n        visitReturn(t, n);\n        typeable = false;\n        break;\n\n      case Token.DEC:\n      case Token.INC:\n        left = n.getFirstChild();\n        checkPropCreation(t, left);\n        validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n        ensureTyped(t, n, NUMBER_TYPE);\n        break;\n\n      case Token.NOT:\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.VOID:\n        ensureTyped(t, n, VOID_TYPE);\n        break;\n\n      case Token.TYPEOF:\n        ensureTyped(t, n, STRING_TYPE);\n        break;\n\n      case Token.BITNOT:\n        childType = getJSType(n.getFirstChild());\n        if (!childType.matchesInt32Context()) {\n          report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()),\n              childType.toString());\n        }\n        ensureTyped(t, n, NUMBER_TYPE);\n        break;\n\n      case Token.POS:\n      case Token.NEG:\n        left = n.getFirstChild();\n        validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n        ensureTyped(t, n, NUMBER_TYPE);\n        break;\n\n      case Token.EQ:\n      case Token.NE:\n      case Token.SHEQ:\n      case Token.SHNE: {\n        left = n.getFirstChild();\n        right = n.getLastChild();\n\n        if (left.isTypeOf()) {\n          if (right.isString()) {\n            checkTypeofString(t, right, right.getString());\n          }\n        } else if (right.isTypeOf() && left.isString()) {\n          checkTypeofString(t, left, left.getString());\n        }\n\n        leftType = getJSType(left);\n        rightType = getJSType(right);\n\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();\n        JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();\n\n        TernaryValue result = TernaryValue.UNKNOWN;\n        if (n.getType() == Token.EQ || n.getType() == Token.NE) {\n          result = leftTypeRestricted.testForEquality(rightTypeRestricted);\n          if (n.isNE()) {\n            result = result.not();\n          }\n        } else {\n          \n          if (!leftTypeRestricted.canTestForShallowEqualityWith(\n                  rightTypeRestricted)) {\n            result = n.getType() == Token.SHEQ ?\n                TernaryValue.FALSE : TernaryValue.TRUE;\n          }\n        }\n\n        if (result != TernaryValue.UNKNOWN) {\n          report(t, n, DETERMINISTIC_TEST, leftType.toString(),\n              rightType.toString(), result.toString());\n        }\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n      }\n\n      case Token.LT:\n      case Token.LE:\n      case Token.GT:\n      case Token.GE:\n        leftType = getJSType(n.getFirstChild());\n        rightType = getJSType(n.getLastChild());\n        if (rightType.isNumber()) {\n          validator.expectNumber(\n              t, n, leftType, \"left side of numeric comparison\");\n        } else if (leftType.isNumber()) {\n          validator.expectNumber(\n              t, n, rightType, \"right side of numeric comparison\");\n        } else if (leftType.matchesNumberContext() &&\n                   rightType.matchesNumberContext()) {\n          \n        } else {\n          \n          \n          \n          String message = \"left side of comparison\";\n          validator.expectString(t, n, leftType, message);\n          validator.expectNotNullOrUndefined(\n              t, n, leftType, message, getNativeType(STRING_TYPE));\n          message = \"right side of comparison\";\n          validator.expectString(t, n, rightType, message);\n          validator.expectNotNullOrUndefined(\n              t, n, rightType, message, getNativeType(STRING_TYPE));\n        }\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.IN:\n        left = n.getFirstChild();\n        right = n.getLastChild();\n        rightType = getJSType(right);\n        validator.expectString(t, left, getJSType(left), \"left side of 'in'\");\n        validator.expectObject(t, n, rightType, \"'in' requires an object\");\n        if (rightType.isStruct()) {\n          report(t, right, IN_USED_WITH_STRUCT);\n        }\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.INSTANCEOF:\n        left = n.getFirstChild();\n        right = n.getLastChild();\n        rightType = getJSType(right).restrictByNotNullOrUndefined();\n        validator.expectAnyObject(\n            t, left, getJSType(left), \"deterministic instanceof yields false\");\n        validator.expectActualObject(\n            t, right, rightType, \"instanceof requires an object\");\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.ASSIGN:\n        visitAssign(t, n);\n        typeable = false;\n        break;\n\n      case Token.ASSIGN_LSH:\n      case Token.ASSIGN_RSH:\n      case Token.ASSIGN_URSH:\n      case Token.ASSIGN_DIV:\n      case Token.ASSIGN_MOD:\n      case Token.ASSIGN_BITOR:\n      case Token.ASSIGN_BITXOR:\n      case Token.ASSIGN_BITAND:\n      case Token.ASSIGN_SUB:\n      case Token.ASSIGN_ADD:\n      case Token.ASSIGN_MUL:\n        checkPropCreation(t, n.getFirstChild());\n        \n\n      case Token.LSH:\n      case Token.RSH:\n      case Token.URSH:\n      case Token.DIV:\n      case Token.MOD:\n      case Token.BITOR:\n      case Token.BITXOR:\n      case Token.BITAND:\n      case Token.SUB:\n      case Token.ADD:\n      case Token.MUL:\n        visitBinaryOperator(n.getType(), t, n);\n        break;\n\n      case Token.DELPROP:\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.CASE:\n        JSType switchType = getJSType(parent.getFirstChild());\n        JSType caseType = getJSType(n.getFirstChild());\n        validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n        typeable = false;\n        break;\n\n      case Token.WITH: {\n        Node child = n.getFirstChild();\n        childType = getJSType(child);\n        validator.expectObject(t, child, childType, \"with requires an object\");\n        typeable = false;\n        break;\n      }\n\n      case Token.FUNCTION:\n        visitFunction(t, n);\n        break;\n\n      \n      case Token.LABEL:\n      case Token.LABEL_NAME:\n      case Token.SWITCH:\n      case Token.BREAK:\n      case Token.CATCH:\n      case Token.TRY:\n      case Token.SCRIPT:\n      case Token.EXPR_RESULT:\n      case Token.BLOCK:\n      case Token.EMPTY:\n      case Token.DEFAULT_CASE:\n      case Token.CONTINUE:\n      case Token.DEBUGGER:\n      case Token.THROW:\n        typeable = false;\n        break;\n\n      \n      case Token.DO:\n      case Token.IF:\n      case Token.WHILE:\n        typeable = false;\n        break;\n\n      case Token.FOR:\n        if (NodeUtil.isForIn(n)) {\n          Node obj = n.getChildAtIndex(1);\n          if (getJSType(obj).isStruct()) {\n            report(t, obj, IN_USED_WITH_STRUCT);\n          }\n        }\n        typeable = false;\n        break;\n\n      \n      case Token.AND:\n      case Token.HOOK:\n      case Token.OBJECTLIT:\n      case Token.OR:\n        if (n.getJSType() != null) { \n          ensureTyped(t, n);\n        } else {\n          \n          if ((n.isObjectLit())\n              && (parent.getJSType() instanceof EnumType)) {\n            ensureTyped(t, n, parent.getJSType());\n          } else {\n            ensureTyped(t, n);\n          }\n        }\n        if (n.isObjectLit()) {\n          JSType typ = getJSType(n);\n          for (Node key : n.children()) {\n            visitObjLitKey(t, key, n, typ);\n          }\n        }\n        break;\n\n      default:\n        report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n        ensureTyped(t, n);\n        break;\n    }\n\n    \n    typeable = typeable && !inExterns;\n\n    if (typeable) {\n      doPercentTypedAccounting(t, n);\n    }\n\n    checkNoTypeCheckSection(n, false);\n  }\n\n  private void checkTypeofString(NodeTraversal t, Node n, String s) {\n    if (!(s.equals(\"number\") || s.equals(\"string\") || s.equals(\"boolean\") ||\n          s.equals(\"undefined\") || s.equals(\"function\") ||\n          s.equals(\"object\") || s.equals(\"unknown\"))) {\n      validator.expectValidTypeofName(t, n, s);\n    }\n  }\n\n  \n  private void doPercentTypedAccounting(NodeTraversal t, Node n) {\n    JSType type = n.getJSType();\n    if (type == null) {\n      nullCount++;\n    } else if (type.isUnknownType()) {\n      if (reportUnknownTypes.isOn()) {\n        compiler.report(\n            t.makeError(n, reportUnknownTypes, UNKNOWN_EXPR_TYPE));\n      }\n      unknownCount++;\n    } else {\n      typedCount++;\n    }\n  }\n\n  \n  private void visitAssign(NodeTraversal t, Node assign) {\n    JSDocInfo info = assign.getJSDocInfo();\n    Node lvalue = assign.getFirstChild();\n    Node rvalue = assign.getLastChild();\n\n    \n    if (lvalue.isGetProp()) {\n      Node object = lvalue.getFirstChild();\n      JSType objectJsType = getJSType(object);\n      Node property = lvalue.getLastChild();\n      String pname = property.getString();\n\n      \n      \n      if (object.isGetProp()) {\n        JSType jsType = getJSType(object.getFirstChild());\n        if (jsType.isInterface() &&\n            object.getLastChild().getString().equals(\"prototype\")) {\n          visitInterfaceGetprop(t, assign, object, pname, lvalue, rvalue);\n        }\n      }\n\n      checkEnumAlias(t, info, rvalue);\n      checkPropCreation(t, lvalue);\n\n      \n      \n      \n      \n      if (pname.equals(\"prototype\")) {\n        if (objectJsType != null && objectJsType.isFunctionType()) {\n          FunctionType functionType = objectJsType.toMaybeFunctionType();\n          if (functionType.isConstructor()) {\n            JSType rvalueType = rvalue.getJSType();\n            validator.expectObject(t, rvalue, rvalueType,\n                OVERRIDING_PROTOTYPE_WITH_NON_OBJECT);\n            \n            if (functionType.makesStructs() && !rvalueType.isStruct()) {\n              String funName = functionType.getTypeOfThis().toString();\n              compiler.report(t.makeError(assign, CONFLICTING_EXTENDED_TYPE,\n                                          \"struct\", funName));\n            }\n            return;\n          }\n        }\n      }\n\n      \n      \n      \n      ObjectType type = ObjectType.cast(\n          objectJsType.restrictByNotNullOrUndefined());\n      if (type != null) {\n        if (type.hasProperty(pname) &&\n            !type.isPropertyTypeInferred(pname) &&\n            !propertyIsImplicitCast(type, pname)) {\n          JSType expectedType = type.getPropertyType(pname);\n          if (!expectedType.isUnknownType()) {\n            validator.expectCanAssignToPropertyOf(\n                t, assign, getJSType(rvalue),\n                expectedType, object, pname);\n            checkPropertyInheritanceOnGetpropAssign(\n                t, assign, object, pname, info, expectedType);\n            return;\n          }\n        }\n      }\n\n      \n      \n      checkPropertyInheritanceOnGetpropAssign(\n          t, assign, object, pname, info, getNativeType(UNKNOWN_TYPE));\n    }\n\n    \n    \n    \n    \n    \n    JSType leftType = getJSType(lvalue);\n    if (lvalue.isQualifiedName()) {\n      \n      JSType rvalueType = getJSType(assign.getLastChild());\n      Var var = t.getScope().getVar(lvalue.getQualifiedName());\n      if (var != null) {\n        if (var.isTypeInferred()) {\n          return;\n        }\n\n        if (NodeUtil.getRootOfQualifiedName(lvalue).isThis() &&\n            t.getScope() != var.getScope()) {\n          \n          return;\n        }\n\n        if (var.getType() != null) {\n          leftType = var.getType();\n        }\n      }\n    }\n\n    \n    Node rightChild = assign.getLastChild();\n    JSType rightType = getJSType(rightChild);\n    if (validator.expectCanAssignTo(\n            t, assign, rightType, leftType, \"assignment\")) {\n      ensureTyped(t, assign, rightType);\n    } else {\n      ensureTyped(t, assign);\n    }\n  }\n\n  \n  private void checkPropCreation(NodeTraversal t, Node lvalue) {\n    if (lvalue.isGetProp()) {\n      Node obj = lvalue.getFirstChild();\n      Node prop = lvalue.getLastChild();\n      JSType objType = getJSType(obj);\n      String pname = prop.getString();\n      if (objType.isStruct() && !objType.hasProperty(pname)) {\n        if (!(obj.isThis() &&\n              getJSType(t.getScope().getRootNode()).isConstructor())) {\n          report(t, prop, ILLEGAL_PROPERTY_CREATION);\n        }\n      }\n    }\n  }\n\n  private void checkPropertyInheritanceOnGetpropAssign( NodeTraversal t, Node assign, Node object, String property, JSDocInfo info, JSType propertyType) {\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    if (object.isGetProp()) {\n      Node object2 = object.getFirstChild();\n      String property2 = NodeUtil.getStringValue(object.getLastChild());\n\n      if (\"prototype\".equals(property2)) {\n        JSType jsType = getJSType(object2);\n        if (jsType.isFunctionType()) {\n          FunctionType functionType = jsType.toMaybeFunctionType();\n          if (functionType.isConstructor() || functionType.isInterface()) {\n            checkDeclaredPropertyInheritance(\n                t, assign, functionType, property, info, propertyType);\n          }\n        }\n      }\n    }\n  }\n\n  \n  private void visitObjLitKey( NodeTraversal t, Node key, Node objlit, JSType litType) {\n    \n    \n    if (objlit.isFromExterns()) {\n      ensureTyped(t, key);\n      return;\n    }\n\n    \n    if (litType.isStruct() && key.isQuotedString()) {\n      report(t, key, ILLEGAL_OBJLIT_KEY, \"struct\");\n    } else if (litType.isDict() && !key.isQuotedString()) {\n      report(t, key, ILLEGAL_OBJLIT_KEY, \"dict\");\n    }\n\n    \n    \n\n    \n    \n    Node rvalue = key.getFirstChild();\n    JSType rightType = NodeUtil.getObjectLitKeyTypeFromValueType(\n        key, getJSType(rvalue));\n    if (rightType == null) {\n      rightType = getNativeType(UNKNOWN_TYPE);\n    }\n\n    Node owner = objlit;\n\n    \n\n    JSType keyType = getJSType(key);\n\n    JSType allowedValueType = keyType;\n    if (allowedValueType.isEnumElementType()) {\n      allowedValueType =\n          allowedValueType.toMaybeEnumElementType().getPrimitiveType();\n    }\n\n    boolean valid = validator.expectCanAssignToPropertyOf(t, key,\n        rightType, allowedValueType,\n        owner, NodeUtil.getObjectLitKeyName(key));\n    if (valid) {\n      ensureTyped(t, key, rightType);\n    } else {\n      ensureTyped(t, key);\n    }\n\n    \n    \n    \n    \n    \n\n    JSType objlitType = getJSType(objlit);\n    ObjectType type = ObjectType.cast(\n        objlitType.restrictByNotNullOrUndefined());\n    if (type != null) {\n      String property = NodeUtil.getObjectLitKeyName(key);\n      if (type.hasProperty(property) &&\n          !type.isPropertyTypeInferred(property) &&\n          !propertyIsImplicitCast(type, property)) {\n        validator.expectCanAssignToPropertyOf(\n            t, key, keyType,\n            type.getPropertyType(property), owner, property);\n      }\n      return;\n    }\n  }\n\n  \n  private boolean propertyIsImplicitCast(ObjectType type, String prop) {\n    for (; type != null; type = type.getImplicitPrototype()) {\n      JSDocInfo docInfo = type.getOwnPropertyJSDocInfo(prop);\n      if (docInfo != null && docInfo.isImplicitCast()) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  \n  private void checkDeclaredPropertyInheritance( NodeTraversal t, Node n, FunctionType ctorType, String propertyName, JSDocInfo info, JSType propertyType) {\n    \n    \n    if (hasUnknownOrEmptySupertype(ctorType)) {\n      return;\n    }\n\n    FunctionType superClass = ctorType.getSuperClassConstructor();\n    boolean superClassHasProperty = superClass != null &&\n        superClass.getInstanceType().hasProperty(propertyName);\n    boolean superClassHasDeclaredProperty = superClass != null &&\n        superClass.getInstanceType().isPropertyTypeDeclared(propertyName);\n\n    \n    boolean superInterfaceHasProperty = false;\n    boolean superInterfaceHasDeclaredProperty = false;\n    if (ctorType.isInterface()) {\n      for (ObjectType interfaceType : ctorType.getExtendedInterfaces()) {\n        superInterfaceHasProperty =\n            superInterfaceHasProperty ||\n            interfaceType.hasProperty(propertyName);\n        superInterfaceHasDeclaredProperty =\n            superInterfaceHasDeclaredProperty ||\n            interfaceType.isPropertyTypeDeclared(propertyName);\n      }\n    }\n    boolean declaredOverride = info != null && info.isOverride();\n\n    boolean foundInterfaceProperty = false;\n    if (ctorType.isConstructor()) {\n      for (JSType implementedInterface :\n          ctorType.getAllImplementedInterfaces()) {\n        if (implementedInterface.isUnknownType() ||\n            implementedInterface.isEmptyType()) {\n          continue;\n        }\n        FunctionType interfaceType =\n            implementedInterface.toObjectType().getConstructor();\n        Preconditions.checkNotNull(interfaceType);\n\n        boolean interfaceHasProperty =\n            interfaceType.getPrototype().hasProperty(propertyName);\n        foundInterfaceProperty = foundInterfaceProperty ||\n            interfaceHasProperty;\n        if (reportMissingOverride.isOn()\n            && !declaredOverride\n            && interfaceHasProperty) {\n          \n          \n          compiler.report(t.makeError(n, reportMissingOverride,\n              HIDDEN_INTERFACE_PROPERTY, propertyName,\n              interfaceType.getTopMostDefiningType(propertyName).toString()));\n        }\n      }\n    }\n\n    if (!declaredOverride\n        && !superClassHasProperty\n        && !superInterfaceHasProperty) {\n      \n      return;\n    }\n\n    ObjectType topInstanceType = superClassHasDeclaredProperty ?\n        superClass.getTopMostDefiningType(propertyName) : null;\n    boolean declaredLocally =\n        ctorType.isConstructor() &&\n        (ctorType.getPrototype().hasOwnProperty(propertyName) ||\n         ctorType.getInstanceType().hasOwnProperty(propertyName));\n    if (reportMissingOverride.isOn()\n        && !declaredOverride\n        && superClassHasDeclaredProperty\n        && declaredLocally) {\n      \n      \n      compiler.report(t.makeError(n, reportMissingOverride,\n          HIDDEN_SUPERCLASS_PROPERTY, propertyName,\n          topInstanceType.toString()));\n    }\n\n    \n    if (superClassHasDeclaredProperty) {\n      \n      JSType superClassPropType =\n          superClass.getInstanceType().getPropertyType(propertyName);\n      if (!propertyType.isSubtype(superClassPropType)) {\n        compiler.report(\n            t.makeError(n, HIDDEN_SUPERCLASS_PROPERTY_MISMATCH,\n                propertyName, topInstanceType.toString(),\n                superClassPropType.toString(), propertyType.toString()));\n      }\n    } else if (superInterfaceHasDeclaredProperty) {\n      \n      for (ObjectType interfaceType : ctorType.getExtendedInterfaces()) {\n        if (interfaceType.hasProperty(propertyName)) {\n          JSType superPropertyType =\n              interfaceType.getPropertyType(propertyName);\n          if (!propertyType.isSubtype(superPropertyType)) {\n            topInstanceType = interfaceType.getConstructor().\n                getTopMostDefiningType(propertyName);\n            compiler.report(\n                t.makeError(n, HIDDEN_SUPERCLASS_PROPERTY_MISMATCH,\n                    propertyName, topInstanceType.toString(),\n                    superPropertyType.toString(),\n                    propertyType.toString()));\n          }\n        }\n      }\n    } else if (!foundInterfaceProperty\n        && !superClassHasProperty\n        && !superInterfaceHasProperty) {\n      \n      compiler.report(\n          t.makeError(n, UNKNOWN_OVERRIDE,\n              propertyName, ctorType.getInstanceType().toString()));\n    }\n  }\n\n  \n  private static boolean hasUnknownOrEmptySupertype(FunctionType ctor) {\n    Preconditions.checkArgument(ctor.isConstructor() || ctor.isInterface());\n    Preconditions.checkArgument(!ctor.isUnknownType());\n\n    \n    \n    while (true) {\n      ObjectType maybeSuperInstanceType =\n          ctor.getPrototype().getImplicitPrototype();\n      if (maybeSuperInstanceType == null) {\n        return false;\n      }\n      if (maybeSuperInstanceType.isUnknownType() ||\n          maybeSuperInstanceType.isEmptyType()) {\n        return true;\n      }\n      ctor = maybeSuperInstanceType.getConstructor();\n      if (ctor == null) {\n        return false;\n      }\n      Preconditions.checkState(ctor.isConstructor() || ctor.isInterface());\n    }\n  }\n\n  \n  private void visitInterfaceGetprop(NodeTraversal t, Node assign, Node object, String property, Node lvalue, Node rvalue) {\n\n    JSType rvalueType = getJSType(rvalue);\n\n    \n    \n    \n    \n    \n\n    String abstractMethodName =\n        compiler.getCodingConvention().getAbstractMethodName();\n    if (!rvalueType.isFunctionType()) {\n      \n      String abstractMethodMessage = (abstractMethodName != null)\n         ? \", or \" + abstractMethodName\n         : \"\";\n      compiler.report(\n          t.makeError(object, INVALID_INTERFACE_MEMBER_DECLARATION,\n              abstractMethodMessage));\n    }\n\n    if (assign.getLastChild().isFunction()\n        && !NodeUtil.isEmptyBlock(assign.getLastChild().getLastChild())) {\n      compiler.report(\n          t.makeError(object, INTERFACE_FUNCTION_NOT_EMPTY,\n              abstractMethodName));\n    }\n  }\n\n  \n  boolean visitName(NodeTraversal t, Node n, Node parent) {\n    \n    \n    \n    \n    \n    \n    \n    int parentNodeType = parent.getType();\n    if (parentNodeType == Token.FUNCTION ||\n        parentNodeType == Token.CATCH ||\n        parentNodeType == Token.PARAM_LIST ||\n        parentNodeType == Token.VAR) {\n      return false;\n    }\n\n    JSType type = n.getJSType();\n    if (type == null) {\n      type = getNativeType(UNKNOWN_TYPE);\n      Var var = t.getScope().getVar(n.getString());\n      if (var != null) {\n        JSType varType = var.getType();\n        if (varType != null) {\n          type = varType;\n        }\n      }\n    }\n    ensureTyped(t, n, type);\n    return true;\n  }\n\n  \n  private void visitGetProp(NodeTraversal t, Node n, Node parent) {\n    \n    \n    \n    \n    Node property = n.getLastChild();\n    Node objNode = n.getFirstChild();\n    JSType childType = getJSType(objNode);\n\n    if (childType.isDict()) {\n      report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n    } else if (validator.expectNotNullOrUndefined(t, n, childType,\n        \"No properties on this expression\", getNativeType(OBJECT_TYPE))) {\n      checkPropertyAccess(childType, property.getString(), t, n);\n    }\n    ensureTyped(t, n);\n  }\n\n  \n  private void checkPropertyAccess(JSType childType, String propName, NodeTraversal t, Node n) {\n    \n    \n    \n    \n    JSType propType = getJSType(n);\n    if (propType.isEquivalentTo(typeRegistry.getNativeType(UNKNOWN_TYPE))) {\n      childType = childType.autobox();\n      ObjectType objectType = ObjectType.cast(childType);\n      if (objectType != null) {\n        \n        \n        \n        if (!objectType.hasProperty(propName) ||\n            objectType.isEquivalentTo(\n                typeRegistry.getNativeType(UNKNOWN_TYPE))) {\n          if (objectType instanceof EnumType) {\n            report(t, n, INEXISTENT_ENUM_ELEMENT, propName);\n          } else {\n            checkPropertyAccessHelper(objectType, propName, t, n);\n          }\n        }\n\n      } else {\n        checkPropertyAccessHelper(childType, propName, t, n);\n      }\n    }\n  }\n\n  private void checkPropertyAccessHelper(JSType objectType, String propName, NodeTraversal t, Node n) {\n    if (!objectType.isEmptyType() &&\n        reportMissingProperties && !isPropertyTest(n)) {\n      if (!typeRegistry.canPropertyBeDefined(objectType, propName)) {\n        report(t, n, INEXISTENT_PROPERTY, propName,\n            validator.getReadableJSTypeName(n.getFirstChild(), true));\n      }\n    }\n  }\n\n  \n  private boolean isPropertyTest(Node getProp) {\n    Node parent = getProp.getParent();\n    switch (parent.getType()) {\n      case Token.CALL:\n        return parent.getFirstChild() != getProp &&\n            compiler.getCodingConvention().isPropertyTestFunction(parent);\n\n      case Token.IF:\n      case Token.WHILE:\n      case Token.DO:\n      case Token.FOR:\n        return NodeUtil.getConditionExpression(parent) == getProp;\n\n      case Token.INSTANCEOF:\n      case Token.TYPEOF:\n        return true;\n\n      case Token.AND:\n      case Token.HOOK:\n        return parent.getFirstChild() == getProp;\n\n      case Token.NOT:\n        return parent.getParent().isOr() &&\n            parent.getParent().getFirstChild() == parent;\n    }\n    return false;\n  }\n\n  \n  private void visitGetElem(NodeTraversal t, Node n) {\n    validator.expectIndexMatch(\n        t, n, getJSType(n.getFirstChild()), getJSType(n.getLastChild()));\n    ensureTyped(t, n);\n  }\n\n  \n  private void visitVar(NodeTraversal t, Node n) {\n    \n    \n    \n    JSDocInfo varInfo = n.hasOneChild() ? n.getJSDocInfo() : null;\n    for (Node name : n.children()) {\n      Node value = name.getFirstChild();\n      \n      Var var = t.getScope().getVar(name.getString());\n\n      if (value != null) {\n        JSType valueType = getJSType(value);\n        JSType nameType = var.getType();\n        nameType = (nameType == null) ? getNativeType(UNKNOWN_TYPE) : nameType;\n\n        JSDocInfo info = name.getJSDocInfo();\n        if (info == null) {\n          info = varInfo;\n        }\n\n        checkEnumAlias(t, info, value);\n        if (var.isTypeInferred()) {\n          ensureTyped(t, name, valueType);\n        } else {\n          validator.expectCanAssignTo(\n              t, value, valueType, nameType, \"initializing variable\");\n        }\n      }\n    }\n  }\n\n  \n  private void visitNew(NodeTraversal t, Node n) {\n    Node constructor = n.getFirstChild();\n    JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n    if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n      FunctionType fnType = type.toMaybeFunctionType();\n      if (fnType != null) {\n        visitParameterList(t, n, fnType);\n        ensureTyped(t, n, fnType.getInstanceType());\n      } else {\n        ensureTyped(t, n);\n      }\n    } else {\n      report(t, n, NOT_A_CONSTRUCTOR);\n      ensureTyped(t, n);\n    }\n  }\n\n  \n  private void checkInterfaceConflictProperties(NodeTraversal t, Node n, String functionName, HashMap<String, ObjectType> properties, HashMap<String, ObjectType> currentProperties, ObjectType interfaceType) {\n    ObjectType implicitProto = interfaceType.getImplicitPrototype();\n    Set<String> currentPropertyNames;\n      \n      \n      currentPropertyNames = implicitProto.getOwnPropertyNames();\n    for (String name : currentPropertyNames) {\n      ObjectType oType = properties.get(name);\n      if (oType != null) {\n        if (!interfaceType.getPropertyType(name).isEquivalentTo(\n            oType.getPropertyType(name))) {\n          compiler.report(\n              t.makeError(n, INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,\n                  functionName, name, oType.toString(),\n                  interfaceType.toString()));\n        }\n      }\n      currentProperties.put(name, interfaceType);\n    }\n    for (ObjectType iType : interfaceType.getCtorExtendedInterfaces()) {\n      checkInterfaceConflictProperties(t, n, functionName, properties,\n          currentProperties, iType);\n    }\n  }\n\n  \n  private void visitFunction(NodeTraversal t, Node n) {\n    FunctionType functionType = JSType.toMaybeFunctionType(n.getJSType());\n    String functionPrivateName = n.getFirstChild().getString();\n    if (functionType.isConstructor()) {\n      FunctionType baseConstructor = functionType.getSuperClassConstructor();\n      if (baseConstructor != getNativeType(OBJECT_FUNCTION_TYPE) &&\n          baseConstructor != null &&\n          baseConstructor.isInterface()) {\n        compiler.report(\n            t.makeError(n, CONFLICTING_EXTENDED_TYPE,\n                        \"constructor\", functionPrivateName));\n      } else {\n        if (baseConstructor != getNativeType(OBJECT_FUNCTION_TYPE)) {\n          ObjectType proto = functionType.getPrototype();\n          if (functionType.makesStructs() && !proto.isStruct()) {\n            compiler.report(t.makeError(n, CONFLICTING_EXTENDED_TYPE,\n                                        \"struct\", functionPrivateName));\n          } else if (functionType.makesDicts() && !proto.isDict()) {\n            compiler.report(t.makeError(n, CONFLICTING_EXTENDED_TYPE,\n                                        \"dict\", functionPrivateName));\n          }\n        }\n        \n        for (JSType baseInterface : functionType.getImplementedInterfaces()) {\n          boolean badImplementedType = false;\n          ObjectType baseInterfaceObj = ObjectType.cast(baseInterface);\n          if (baseInterfaceObj != null) {\n            FunctionType interfaceConstructor =\n              baseInterfaceObj.getConstructor();\n            if (interfaceConstructor != null &&\n                !interfaceConstructor.isInterface()) {\n              badImplementedType = true;\n            }\n          } else {\n            badImplementedType = true;\n          }\n          if (badImplementedType) {\n            report(t, n, BAD_IMPLEMENTED_TYPE, functionPrivateName);\n          }\n        }\n        \n        validator.expectAllInterfaceProperties(t, n, functionType);\n      }\n    } else if (functionType.isInterface()) {\n      \n      for (ObjectType extInterface : functionType.getExtendedInterfaces()) {\n        if (extInterface.getConstructor() != null\n            && !extInterface.getConstructor().isInterface()) {\n          compiler.report(\n              t.makeError(n, CONFLICTING_EXTENDED_TYPE,\n                          \"interface\", functionPrivateName));\n        }\n      }\n\n      \n      if (functionType.getExtendedInterfacesCount() > 1) {\n        \n        HashMap<String, ObjectType> properties\n            = new HashMap<String, ObjectType>();\n        HashMap<String, ObjectType> currentProperties\n            = new HashMap<String, ObjectType>();\n        for (ObjectType interfaceType : functionType.getExtendedInterfaces()) {\n          currentProperties.clear();\n          checkInterfaceConflictProperties(t, n, functionPrivateName,\n              properties, currentProperties, interfaceType);\n          properties.putAll(currentProperties);\n        }\n      }\n    }\n  }\n\n  \n  private void visitCall(NodeTraversal t, Node n) {\n    Node child = n.getFirstChild();\n    JSType childType = getJSType(child).restrictByNotNullOrUndefined();\n\n    if (!childType.canBeCalled()) {\n      report(t, n, NOT_CALLABLE, childType.toString());\n      ensureTyped(t, n);\n      return;\n    }\n\n    \n    \n    if (childType.isFunctionType()) {\n      FunctionType functionType = childType.toMaybeFunctionType();\n\n      boolean isExtern = false;\n      JSDocInfo functionJSDocInfo = functionType.getJSDocInfo();\n      if( functionJSDocInfo != null  &&\n          functionJSDocInfo.getAssociatedNode() != null) {\n        isExtern = functionJSDocInfo.getAssociatedNode().isFromExterns();\n      }\n\n      \n      \n      \n      if (functionType.isConstructor() &&\n          !functionType.isNativeObjectType() &&\n          (functionType.getReturnType().isUnknownType() ||\n           functionType.getReturnType().isVoidType() ||\n           !isExtern)) {\n        report(t, n, CONSTRUCTOR_NOT_CALLABLE, childType.toString());\n      }\n\n      \n      \n      if (functionType.isOrdinaryFunction() &&\n          !functionType.getTypeOfThis().isUnknownType() &&\n          !(functionType.getTypeOfThis().toObjectType() != null &&\n          functionType.getTypeOfThis().toObjectType().isNativeObjectType()) &&\n          !(child.isGetElem() ||\n            child.isGetProp())) {\n        report(t, n, EXPECTED_THIS_TYPE, functionType.toString());\n      }\n\n      visitParameterList(t, n, functionType);\n      ensureTyped(t, n, functionType.getReturnType());\n    } else {\n      ensureTyped(t, n);\n    }\n\n    \n    \n    \n  }\n\n  \n  private void visitParameterList(NodeTraversal t, Node call, FunctionType functionType) {\n    Iterator<Node> arguments = call.children().iterator();\n    arguments.next(); \n\n    Iterator<Node> parameters = functionType.getParameters().iterator();\n    int ordinal = 0;\n    Node parameter = null;\n    Node argument = null;\n    while (arguments.hasNext() &&\n           (parameters.hasNext() ||\n            parameter != null && parameter.isVarArgs())) {\n      \n      \n      if (parameters.hasNext()) {\n        parameter = parameters.next();\n      }\n      argument = arguments.next();\n      ordinal++;\n\n      validator.expectArgumentMatchesParameter(t, argument,\n          getJSType(argument), getJSType(parameter), call, ordinal);\n    }\n\n    int numArgs = call.getChildCount() - 1;\n    int minArgs = functionType.getMinArguments();\n    int maxArgs = functionType.getMaxArguments();\n    if (minArgs > numArgs || maxArgs < numArgs) {\n      report(t, call, WRONG_ARGUMENT_COUNT,\n              validator.getReadableJSTypeName(call.getFirstChild(), false),\n              String.valueOf(numArgs), String.valueOf(minArgs),\n              maxArgs != Integer.MAX_VALUE ?\n              \" and no more than \" + maxArgs + \" argument(s)\" : \"\");\n    }\n  }\n\n  \n  private void visitReturn(NodeTraversal t, Node n) {\n    JSType jsType = getJSType(t.getEnclosingFunction());\n\n    if (jsType.isFunctionType()) {\n      FunctionType functionType = jsType.toMaybeFunctionType();\n\n      JSType returnType = functionType.getReturnType();\n\n      \n      \n      if (returnType == null) {\n        returnType = getNativeType(VOID_TYPE);\n      }\n\n      \n      Node valueNode = n.getFirstChild();\n      JSType actualReturnType;\n      if (valueNode == null) {\n        actualReturnType = getNativeType(VOID_TYPE);\n        valueNode = n;\n      } else {\n        actualReturnType = getJSType(valueNode);\n      }\n\n      \n      validator.expectCanAssignTo(t, valueNode, actualReturnType, returnType,\n          \"inconsistent return type\");\n    }\n  }\n\n  \n  private void visitBinaryOperator(int op, NodeTraversal t, Node n) {\n    Node left = n.getFirstChild();\n    JSType leftType = getJSType(left);\n    Node right = n.getLastChild();\n    JSType rightType = getJSType(right);\n    switch (op) {\n      case Token.ASSIGN_LSH:\n      case Token.ASSIGN_RSH:\n      case Token.LSH:\n      case Token.RSH:\n      case Token.ASSIGN_URSH:\n      case Token.URSH:\n        if (!leftType.matchesInt32Context()) {\n          report(t, left, BIT_OPERATION,\n                   NodeUtil.opToStr(n.getType()), leftType.toString());\n        }\n        if (!rightType.matchesUint32Context()) {\n          report(t, right, BIT_OPERATION,\n                   NodeUtil.opToStr(n.getType()), rightType.toString());\n        }\n        break;\n\n      case Token.ASSIGN_DIV:\n      case Token.ASSIGN_MOD:\n      case Token.ASSIGN_MUL:\n      case Token.ASSIGN_SUB:\n      case Token.DIV:\n      case Token.MOD:\n      case Token.MUL:\n      case Token.SUB:\n        validator.expectNumber(t, left, leftType, \"left operand\");\n        validator.expectNumber(t, right, rightType, \"right operand\");\n        break;\n\n      case Token.ASSIGN_BITAND:\n      case Token.ASSIGN_BITXOR:\n      case Token.ASSIGN_BITOR:\n      case Token.BITAND:\n      case Token.BITXOR:\n      case Token.BITOR:\n        validator.expectBitwiseable(t, left, leftType,\n            \"bad left operand to bitwise operator\");\n        validator.expectBitwiseable(t, right, rightType,\n            \"bad right operand to bitwise operator\");\n        break;\n\n      case Token.ASSIGN_ADD:\n      case Token.ADD:\n        break;\n\n      default:\n        report(t, n, UNEXPECTED_TOKEN, Token.name(op));\n    }\n    ensureTyped(t, n);\n  }\n\n\n  \n  private void checkEnumAlias( NodeTraversal t, JSDocInfo declInfo, Node value) {\n    if (declInfo == null || !declInfo.hasEnumParameterType()) {\n      return;\n    }\n\n    JSType valueType = getJSType(value);\n    if (!valueType.isEnumType()) {\n      return;\n    }\n\n    EnumType valueEnumType = valueType.toMaybeEnumType();\n    JSType valueEnumPrimitiveType =\n        valueEnumType.getElementsType().getPrimitiveType();\n    validator.expectCanAssignTo(t, value, valueEnumPrimitiveType,\n        declInfo.getEnumParameterType().evaluate(t.getScope(), typeRegistry),\n        \"incompatible enum element types\");\n  }\n\n  \n  private JSType getJSType(Node n) {\n    JSType jsType = n.getJSType();\n    if (jsType == null) {\n      \n      \n      \n      \n      return getNativeType(UNKNOWN_TYPE);\n    } else {\n      return jsType;\n    }\n  }\n\n  \n  \n  \n  \n  \n\n  \n  private void ensureTyped(NodeTraversal t, Node n) {\n    ensureTyped(t, n, getNativeType(UNKNOWN_TYPE));\n  }\n\n  private void ensureTyped(NodeTraversal t, Node n, JSTypeNative type) {\n    ensureTyped(t, n, getNativeType(type));\n  }\n\n  \n  private void ensureTyped(NodeTraversal t, Node n, JSType type) {\n    \n    Preconditions.checkState(!n.isFunction() ||\n            type.isFunctionType() ||\n            type.isUnknownType());\n    JSDocInfo info = n.getJSDocInfo();\n    if (info != null) {\n      if (info.hasType()) {\n        \n        \n        \n        \n        JSType infoType = info.getType().evaluate(t.getScope(), typeRegistry);\n        validator.expectCanCast(t, n, infoType, type);\n        type = infoType;\n      }\n\n      if (info.isImplicitCast() && !inExterns) {\n        String propName = n.isGetProp() ?\n            n.getLastChild().getString() : \"(missing)\";\n        compiler.report(\n            t.makeError(n, ILLEGAL_IMPLICIT_CAST, propName));\n      }\n    }\n\n    if (n.getJSType() == null) {\n      n.setJSType(type);\n    }\n  }\n\n  \n  double getTypedPercent() {\n    int total = nullCount + unknownCount + typedCount;\n    return (total == 0) ? 0.0 : (100.0 * typedCount) / total;\n  }\n\n  private JSType getNativeType(JSTypeNative typeId) {\n    return typeRegistry.getNativeType(typeId);\n  }\n}\n",
      "fixed_full_code": "\n\npackage com.google.javascript.jscomp;\n\nimport static com.google.javascript.rhino.jstype.JSTypeNative.ARRAY_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.BOOLEAN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NULL_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.OBJECT_FUNCTION_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.OBJECT_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.REGEXP_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.STRING_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.UNKNOWN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.VOID_TYPE; import com.google.common.base.Preconditions; import com.google.common.collect.ImmutableSet; import com.google.javascript.jscomp.CheckLevel; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.jscomp.type.ReverseAbstractInterpreter; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.jstype.EnumType; import com.google.javascript.rhino.jstype.FunctionType; import com.google.javascript.rhino.jstype.JSType; import com.google.javascript.rhino.jstype.JSTypeNative; import com.google.javascript.rhino.jstype.JSTypeRegistry; import com.google.javascript.rhino.jstype.ObjectType; import com.google.javascript.rhino.jstype.TernaryValue; import java.util.HashMap; import java.util.Iterator; import java.util.Set; public class TypeCheck implements NodeTraversal.Callback, CompilerPass { static final DiagnosticType UNEXPECTED_TOKEN = DiagnosticType.error( \"JSC_INTERNAL_ERROR_UNEXPECTED_TOKEN\", \"Internal Error: Don't know how to handle {0}\"); static final DiagnosticType BAD_DELETE = DiagnosticType.warning( \"JSC_BAD_DELETE_OPERAND\", \"delete operator needs a reference operand\"); protected static final String OVERRIDING_PROTOTYPE_WITH_NON_OBJECT = \"overriding prototype with non-object\"; static final DiagnosticType DETERMINISTIC_TEST = DiagnosticType.warning( \"JSC_DETERMINISTIC_TEST\", \"condition always evaluates to {2}\\n\" +\n          \"left : {0}\\n\" +\n          \"right: {1}\");\n\n  static final DiagnosticType DETERMINISTIC_TEST_NO_RESULT = DiagnosticType.warning( \"JSC_DETERMINISTIC_TEST_NO_RESULT\", \"condition always evaluates to the same value\\n\" + \"left : {0}\\n\" + \"right: {1}\"); static final DiagnosticType INEXISTENT_ENUM_ELEMENT = DiagnosticType.warning( \"JSC_INEXISTENT_ENUM_ELEMENT\", \"element {0} does not exist on this enum\");\n\n  \n  \n  static final DiagnosticType INEXISTENT_PROPERTY = DiagnosticType.disabled( \"JSC_INEXISTENT_PROPERTY\", \"Property {0} never defined on {1}\"); protected static final DiagnosticType NOT_A_CONSTRUCTOR = DiagnosticType.warning( \"JSC_NOT_A_CONSTRUCTOR\", \"cannot instantiate non-constructor\"); static final DiagnosticType BIT_OPERATION = DiagnosticType.warning( \"JSC_BAD_TYPE_FOR_BIT_OPERATION\", \"operator {0} cannot be applied to {1}\");\n\n  static final DiagnosticType NOT_CALLABLE = DiagnosticType.warning( \"JSC_NOT_FUNCTION_TYPE\", \"{0} expressions are not callable\"); static final DiagnosticType CONSTRUCTOR_NOT_CALLABLE = DiagnosticType.warning( \"JSC_CONSTRUCTOR_NOT_CALLABLE\", \"Constructor {0} should be called with the \\\"new\\\" keyword\");\n\n  static final DiagnosticType FUNCTION_MASKS_VARIABLE = DiagnosticType.warning( \"JSC_FUNCTION_MASKS_VARIABLE\", \"function {0} masks variable (IE bug)\"); static final DiagnosticType MULTIPLE_VAR_DEF = DiagnosticType.warning( \"JSC_MULTIPLE_VAR_DEF\", \"declaration of multiple variables with shared type information\"); static final DiagnosticType ENUM_DUP = DiagnosticType.error(\"JSC_ENUM_DUP\", \"enum element {0} already defined\");\n\n  static final DiagnosticType ENUM_NOT_CONSTANT = DiagnosticType.warning(\"JSC_ENUM_NOT_CONSTANT\", \"enum key {0} must be a syntactic constant\"); static final DiagnosticType INVALID_INTERFACE_MEMBER_DECLARATION = DiagnosticType.warning( \"JSC_INVALID_INTERFACE_MEMBER_DECLARATION\", \"interface members can only be empty property declarations,\" + \" empty functions {0}\");\n\n  static final DiagnosticType INTERFACE_FUNCTION_NOT_EMPTY = DiagnosticType.warning( \"JSC_INTERFACE_FUNCTION_NOT_EMPTY\", \"interface member functions must have an empty body\"); static final DiagnosticType CONFLICTING_EXTENDED_TYPE = DiagnosticType.warning( \"JSC_CONFLICTING_EXTENDED_TYPE\", \" {1} cannot extend this type; {0}s can only extend {0}s\");\n\n  static final DiagnosticType CONFLICTING_IMPLEMENTED_TYPE = DiagnosticType.warning( \"JSC_CONFLICTING_IMPLEMENTED_TYPE\", \"{0} cannot implement this type; \" + \"an interface can only extend, but not implement interfaces\"); static final DiagnosticType BAD_IMPLEMENTED_TYPE = DiagnosticType.warning( \"JSC_IMPLEMENTS_NON_INTERFACE\", \"can only implement interfaces\"); static final DiagnosticType HIDDEN_SUPERCLASS_PROPERTY = DiagnosticType.warning( \"JSC_HIDDEN_SUPERCLASS_PROPERTY\", \"property {0} already defined on superclass {1}; \" +\n          \"use @override to override it\");\n\n  static final DiagnosticType HIDDEN_INTERFACE_PROPERTY = DiagnosticType.warning( \"JSC_HIDDEN_INTERFACE_PROPERTY\", \"property {0} already defined on interface {1}; \" + \"use @override to override it\"); static final DiagnosticType HIDDEN_SUPERCLASS_PROPERTY_MISMATCH = DiagnosticType.warning(\"JSC_HIDDEN_SUPERCLASS_PROPERTY_MISMATCH\", \"mismatch of the {0} property type and the type \" +\n          \"of the property it overrides from superclass {1}\\n\" +\n          \"original: {2}\\n\" +\n          \"override: {3}\");\n\n  static final DiagnosticType UNKNOWN_OVERRIDE = DiagnosticType.warning( \"JSC_UNKNOWN_OVERRIDE\", \"property {0} not defined on any superclass of {1}\"); static final DiagnosticType INTERFACE_METHOD_OVERRIDE = DiagnosticType.warning( \"JSC_INTERFACE_METHOD_OVERRIDE\", \"property {0} is already defined by the {1} extended interface\");\n\n  static final DiagnosticType UNKNOWN_EXPR_TYPE = DiagnosticType.warning(\"JSC_UNKNOWN_EXPR_TYPE\", \"could not determine the type of this expression\"); static final DiagnosticType UNRESOLVED_TYPE = DiagnosticType.warning(\"JSC_UNRESOLVED_TYPE\", \"could not resolve the name {0} to a type\");\n\n  static final DiagnosticType WRONG_ARGUMENT_COUNT = DiagnosticType.warning( \"JSC_WRONG_ARGUMENT_COUNT\", \"Function {0}: called with {1} argument(s). \" + \"Function requires at least {2} argument(s){3}.\"); static final DiagnosticType ILLEGAL_IMPLICIT_CAST = DiagnosticType.warning( \"JSC_ILLEGAL_IMPLICIT_CAST\", \"Illegal annotation on {0}. @implicitCast may only be used in \" +\n          \"externs.\");\n\n  static final DiagnosticType INCOMPATIBLE_EXTENDED_PROPERTY_TYPE = DiagnosticType.warning( \"JSC_INCOMPATIBLE_EXTENDED_PROPERTY_TYPE\", \"Interface {0} has a property {1} with incompatible types in \" + \"its super interfaces {2} and {3}\"); static final DiagnosticType EXPECTED_THIS_TYPE = DiagnosticType.warning( \"JSC_EXPECTED_THIS_TYPE\", \"\\\" {0}\\\" must be called with a \\\"this\\\" type\");\n\n  static final DiagnosticType IN_USED_WITH_STRUCT = DiagnosticType.warning(\"JSC_IN_USED_WITH_STRUCT\", \"Cannot use the IN operator with structs\"); static final DiagnosticType ILLEGAL_PROPERTY_CREATION = DiagnosticType.warning(\"JSC_ILLEGAL_PROPERTY_CREATION\", \"Cannot add a property to a struct instance \" + \"after it is constructed.\"); static final DiagnosticType ILLEGAL_OBJLIT_KEY = DiagnosticType.warning( \"ILLEGAL_OBJLIT_KEY\", \"Illegal key, the object literal is a {0}\");\n\n  static final DiagnosticGroup ALL_DIAGNOSTICS = new DiagnosticGroup( DETERMINISTIC_TEST, DETERMINISTIC_TEST_NO_RESULT, INEXISTENT_ENUM_ELEMENT, INEXISTENT_PROPERTY, NOT_A_CONSTRUCTOR, BIT_OPERATION, NOT_CALLABLE, CONSTRUCTOR_NOT_CALLABLE, FUNCTION_MASKS_VARIABLE, MULTIPLE_VAR_DEF, ENUM_DUP, ENUM_NOT_CONSTANT, INVALID_INTERFACE_MEMBER_DECLARATION, INTERFACE_FUNCTION_NOT_EMPTY, CONFLICTING_EXTENDED_TYPE, CONFLICTING_IMPLEMENTED_TYPE, BAD_IMPLEMENTED_TYPE, HIDDEN_SUPERCLASS_PROPERTY, HIDDEN_INTERFACE_PROPERTY, HIDDEN_SUPERCLASS_PROPERTY_MISMATCH, UNKNOWN_OVERRIDE, INTERFACE_METHOD_OVERRIDE, UNKNOWN_EXPR_TYPE, UNRESOLVED_TYPE, WRONG_ARGUMENT_COUNT, ILLEGAL_IMPLICIT_CAST, INCOMPATIBLE_EXTENDED_PROPERTY_TYPE, EXPECTED_THIS_TYPE, IN_USED_WITH_STRUCT, ILLEGAL_PROPERTY_CREATION, ILLEGAL_OBJLIT_KEY, RhinoErrorReporter.TYPE_PARSE_ERROR, TypedScopeCreator.UNKNOWN_LENDS, TypedScopeCreator.LENDS_ON_NON_OBJECT, TypedScopeCreator.CTOR_INITIALIZER, TypedScopeCreator.IFACE_INITIALIZER, FunctionTypeBuilder.THIS_TYPE_NON_OBJECT); private final AbstractCompiler compiler; private final TypeValidator validator; private final ReverseAbstractInterpreter reverseInterpreter; private final JSTypeRegistry typeRegistry; private Scope topScope; private MemoizedScopeCreator scopeCreator; private final CheckLevel reportMissingOverride; private final CheckLevel reportUnknownTypes; private boolean reportMissingProperties = true; private InferJSDocInfo inferJSDocInfo = null; private int typedCount = 0; private int nullCount = 0; private int unknownCount = 0; private boolean inExterns; private int noTypeCheckSection = 0; public TypeCheck(AbstractCompiler compiler, ReverseAbstractInterpreter reverseInterpreter, JSTypeRegistry typeRegistry, Scope topScope, MemoizedScopeCreator scopeCreator, CheckLevel reportMissingOverride, CheckLevel reportUnknownTypes) {\n    this.compiler = compiler;\n    this.validator = compiler.getTypeValidator();\n    this.reverseInterpreter = reverseInterpreter;\n    this.typeRegistry = typeRegistry;\n    this.topScope = topScope;\n    this.scopeCreator = scopeCreator;\n    this.reportMissingOverride = reportMissingOverride;\n    this.reportUnknownTypes = reportUnknownTypes;\n    this.inferJSDocInfo = new InferJSDocInfo(compiler);\n  }\n\n  public TypeCheck(AbstractCompiler compiler, ReverseAbstractInterpreter reverseInterpreter, JSTypeRegistry typeRegistry, CheckLevel reportMissingOverride, CheckLevel reportUnknownTypes) {\n    this(compiler, reverseInterpreter, typeRegistry, null, null,\n        reportMissingOverride, reportUnknownTypes);\n  }\n\n  TypeCheck(AbstractCompiler compiler,\n      ReverseAbstractInterpreter reverseInterpreter,\n      JSTypeRegistry typeRegistry) {\n    this(compiler, reverseInterpreter, typeRegistry, null, null,\n         CheckLevel.WARNING, CheckLevel.OFF);\n  }\n\n  \n  TypeCheck reportMissingProperties(boolean report) {\n    reportMissingProperties = report;\n    return this;\n  }\n\n  \n  @Override\n  public void process(Node externsRoot, Node jsRoot) {\n    Preconditions.checkNotNull(scopeCreator);\n    Preconditions.checkNotNull(topScope);\n\n    Node externsAndJs = jsRoot.getParent();\n    Preconditions.checkState(externsAndJs != null);\n    Preconditions.checkState(\n        externsRoot == null || externsAndJs.hasChild(externsRoot));\n\n    if (externsRoot != null) {\n      check(externsRoot, true);\n    }\n    check(jsRoot, false);\n  }\n\n  \n  public Scope processForTesting(Node externsRoot, Node jsRoot) {\n    Preconditions.checkState(scopeCreator == null);\n    Preconditions.checkState(topScope == null);\n\n    Preconditions.checkState(jsRoot.getParent() != null);\n    Node externsAndJsRoot = jsRoot.getParent();\n\n    scopeCreator = new MemoizedScopeCreator(new TypedScopeCreator(compiler));\n    topScope = scopeCreator.createScope(externsAndJsRoot, null);\n\n    TypeInferencePass inference = new TypeInferencePass(compiler,\n        reverseInterpreter, topScope, scopeCreator);\n\n    inference.process(externsRoot, jsRoot);\n    process(externsRoot, jsRoot);\n\n    return topScope;\n  }\n\n\n  public void check(Node node, boolean externs) {\n    Preconditions.checkNotNull(node);\n\n    NodeTraversal t = new NodeTraversal(compiler, this, scopeCreator);\n    inExterns = externs;\n    t.traverseWithScope(node, topScope);\n    if (externs) {\n      inferJSDocInfo.process(node, null);\n    } else {\n      inferJSDocInfo.process(null, node);\n    }\n  }\n\n\n  private void checkNoTypeCheckSection(Node n, boolean enterSection) {\n    switch (n.getType()) {\n      case Token.SCRIPT:\n      case Token.BLOCK:\n      case Token.VAR:\n      case Token.FUNCTION:\n      case Token.ASSIGN:\n        JSDocInfo info = n.getJSDocInfo();\n        if (info != null && info.isNoTypeCheck()) {\n          if (enterSection) {\n            noTypeCheckSection++;\n          } else {\n            noTypeCheckSection--;\n          }\n        }\n        validator.setShouldReport(noTypeCheckSection == 0);\n        break;\n    }\n  }\n\n  private void report(NodeTraversal t, Node n, DiagnosticType diagnosticType, String... arguments) {\n    if (noTypeCheckSection == 0) {\n      t.report(n, diagnosticType, arguments);\n    }\n  }\n\n  @Override\n  public boolean shouldTraverse( NodeTraversal t, Node n, Node parent) {\n    checkNoTypeCheckSection(n, true);\n    switch (n.getType()) {\n      case Token.FUNCTION:\n        \n        final Scope outerScope = t.getScope();\n        final String functionPrivateName = n.getFirstChild().getString();\n        if (functionPrivateName != null && functionPrivateName.length() > 0 &&\n            outerScope.isDeclared(functionPrivateName, false) &&\n            \n            \n            \n            !(outerScope.getVar(\n                functionPrivateName).getType() instanceof FunctionType)) {\n          report(t, n, FUNCTION_MASKS_VARIABLE, functionPrivateName);\n        }\n\n        \n        \n        \n        break;\n    }\n    return true;\n  }\n\n  \n  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    JSType childType;\n    JSType leftType, rightType;\n    Node left, right;\n    \n    boolean typeable = true;\n\n    switch (n.getType()) {\n      case Token.CAST:\n        Node expr = n.getFirstChild();\n        ensureTyped(t, n, getJSType(expr));\n\n        \n        \n        JSType castType = getJSType(n);\n        JSType exprType = getJSType(expr);\n        if (castType.isSubtype(exprType)) {\n          expr.setJSType(castType);\n        }\n        break;\n\n      case Token.NAME:\n        typeable = visitName(t, n, parent);\n        break;\n\n      case Token.PARAM_LIST:\n        typeable = false;\n        break;\n\n      case Token.COMMA:\n        ensureTyped(t, n, getJSType(n.getLastChild()));\n        break;\n\n      case Token.TRUE:\n      case Token.FALSE:\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.THIS:\n        ensureTyped(t, n, t.getScope().getTypeOfThis());\n        break;\n\n      case Token.NULL:\n        ensureTyped(t, n, NULL_TYPE);\n        break;\n\n      case Token.NUMBER:\n        ensureTyped(t, n, NUMBER_TYPE);\n        break;\n\n      case Token.STRING:\n        ensureTyped(t, n, STRING_TYPE);\n        break;\n\n      case Token.STRING_KEY:\n        typeable = false;\n        break;\n\n      case Token.GETTER_DEF:\n      case Token.SETTER_DEF:\n        \n        break;\n\n      case Token.ARRAYLIT:\n        ensureTyped(t, n, ARRAY_TYPE);\n        break;\n\n      case Token.REGEXP:\n        ensureTyped(t, n, REGEXP_TYPE);\n        break;\n\n      case Token.GETPROP:\n        visitGetProp(t, n, parent);\n        typeable = !(parent.isAssign() &&\n                     parent.getFirstChild() == n);\n        break;\n\n      case Token.GETELEM:\n        visitGetElem(t, n);\n        \n        \n        \n        typeable = false;\n        break;\n\n      case Token.VAR:\n        visitVar(t, n);\n        typeable = false;\n        break;\n\n      case Token.NEW:\n        visitNew(t, n);\n        break;\n\n      case Token.CALL:\n        visitCall(t, n);\n        typeable = !parent.isExprResult();\n        break;\n\n      case Token.RETURN:\n        visitReturn(t, n);\n        typeable = false;\n        break;\n\n      case Token.DEC:\n      case Token.INC:\n        left = n.getFirstChild();\n        checkPropCreation(t, left);\n        validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n        ensureTyped(t, n, NUMBER_TYPE);\n        break;\n\n      case Token.NOT:\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.VOID:\n        ensureTyped(t, n, VOID_TYPE);\n        break;\n\n      case Token.TYPEOF:\n        ensureTyped(t, n, STRING_TYPE);\n        break;\n\n      case Token.BITNOT:\n        childType = getJSType(n.getFirstChild());\n        if (!childType.matchesInt32Context()) {\n          report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()),\n              childType.toString());\n        }\n        ensureTyped(t, n, NUMBER_TYPE);\n        break;\n\n      case Token.POS:\n      case Token.NEG:\n        left = n.getFirstChild();\n        validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n        ensureTyped(t, n, NUMBER_TYPE);\n        break;\n\n      case Token.EQ:\n      case Token.NE:\n      case Token.SHEQ:\n      case Token.SHNE: {\n        left = n.getFirstChild();\n        right = n.getLastChild();\n\n        if (left.isTypeOf()) {\n          if (right.isString()) {\n            checkTypeofString(t, right, right.getString());\n          }\n        } else if (right.isTypeOf() && left.isString()) {\n          checkTypeofString(t, left, left.getString());\n        }\n\n        leftType = getJSType(left);\n        rightType = getJSType(right);\n\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();\n        JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();\n\n        TernaryValue result = TernaryValue.UNKNOWN;\n        if (n.getType() == Token.EQ || n.getType() == Token.NE) {\n          result = leftTypeRestricted.testForEquality(rightTypeRestricted);\n          if (n.isNE()) {\n            result = result.not();\n          }\n        } else {\n          \n          if (!leftTypeRestricted.canTestForShallowEqualityWith(\n                  rightTypeRestricted)) {\n            result = n.getType() == Token.SHEQ ?\n                TernaryValue.FALSE : TernaryValue.TRUE;\n          }\n        }\n\n        if (result != TernaryValue.UNKNOWN) {\n          report(t, n, DETERMINISTIC_TEST, leftType.toString(),\n              rightType.toString(), result.toString());\n        }\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n      }\n\n      case Token.LT:\n      case Token.LE:\n      case Token.GT:\n      case Token.GE:\n        leftType = getJSType(n.getFirstChild());\n        rightType = getJSType(n.getLastChild());\n        if (rightType.isNumber()) {\n          validator.expectNumber(\n              t, n, leftType, \"left side of numeric comparison\");\n        } else if (leftType.isNumber()) {\n          validator.expectNumber(\n              t, n, rightType, \"right side of numeric comparison\");\n        } else if (leftType.matchesNumberContext() &&\n                   rightType.matchesNumberContext()) {\n          \n        } else {\n          \n          \n          \n          String message = \"left side of comparison\";\n          validator.expectString(t, n, leftType, message);\n          validator.expectNotNullOrUndefined(\n              t, n, leftType, message, getNativeType(STRING_TYPE));\n          message = \"right side of comparison\";\n          validator.expectString(t, n, rightType, message);\n          validator.expectNotNullOrUndefined(\n              t, n, rightType, message, getNativeType(STRING_TYPE));\n        }\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.IN:\n        left = n.getFirstChild();\n        right = n.getLastChild();\n        rightType = getJSType(right);\n        validator.expectString(t, left, getJSType(left), \"left side of 'in'\");\n        validator.expectObject(t, n, rightType, \"'in' requires an object\");\n        if (rightType.isStruct()) {\n          report(t, right, IN_USED_WITH_STRUCT);\n        }\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.INSTANCEOF:\n        left = n.getFirstChild();\n        right = n.getLastChild();\n        rightType = getJSType(right).restrictByNotNullOrUndefined();\n        validator.expectAnyObject(\n            t, left, getJSType(left), \"deterministic instanceof yields false\");\n        validator.expectActualObject(\n            t, right, rightType, \"instanceof requires an object\");\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.ASSIGN:\n        visitAssign(t, n);\n        typeable = false;\n        break;\n\n      case Token.ASSIGN_LSH:\n      case Token.ASSIGN_RSH:\n      case Token.ASSIGN_URSH:\n      case Token.ASSIGN_DIV:\n      case Token.ASSIGN_MOD:\n      case Token.ASSIGN_BITOR:\n      case Token.ASSIGN_BITXOR:\n      case Token.ASSIGN_BITAND:\n      case Token.ASSIGN_SUB:\n      case Token.ASSIGN_ADD:\n      case Token.ASSIGN_MUL:\n        checkPropCreation(t, n.getFirstChild());\n        \n\n      case Token.LSH:\n      case Token.RSH:\n      case Token.URSH:\n      case Token.DIV:\n      case Token.MOD:\n      case Token.BITOR:\n      case Token.BITXOR:\n      case Token.BITAND:\n      case Token.SUB:\n      case Token.ADD:\n      case Token.MUL:\n        visitBinaryOperator(n.getType(), t, n);\n        break;\n\n      case Token.DELPROP:\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.CASE:\n        JSType switchType = getJSType(parent.getFirstChild());\n        JSType caseType = getJSType(n.getFirstChild());\n        validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n        typeable = false;\n        break;\n\n      case Token.WITH: {\n        Node child = n.getFirstChild();\n        childType = getJSType(child);\n        validator.expectObject(t, child, childType, \"with requires an object\");\n        typeable = false;\n        break;\n      }\n\n      case Token.FUNCTION:\n        visitFunction(t, n);\n        break;\n\n      \n      case Token.LABEL:\n      case Token.LABEL_NAME:\n      case Token.SWITCH:\n      case Token.BREAK:\n      case Token.CATCH:\n      case Token.TRY:\n      case Token.SCRIPT:\n      case Token.EXPR_RESULT:\n      case Token.BLOCK:\n      case Token.EMPTY:\n      case Token.DEFAULT_CASE:\n      case Token.CONTINUE:\n      case Token.DEBUGGER:\n      case Token.THROW:\n        typeable = false;\n        break;\n\n      \n      case Token.DO:\n      case Token.IF:\n      case Token.WHILE:\n        typeable = false;\n        break;\n\n      case Token.FOR:\n        if (NodeUtil.isForIn(n)) {\n          Node obj = n.getChildAtIndex(1);\n          if (getJSType(obj).isStruct()) {\n            report(t, obj, IN_USED_WITH_STRUCT);\n          }\n        }\n        typeable = false;\n        break;\n\n      \n      case Token.AND:\n      case Token.HOOK:\n      case Token.OBJECTLIT:\n      case Token.OR:\n        if (n.getJSType() != null) { \n          ensureTyped(t, n);\n        } else {\n          \n          if ((n.isObjectLit())\n              && (parent.getJSType() instanceof EnumType)) {\n            ensureTyped(t, n, parent.getJSType());\n          } else {\n            ensureTyped(t, n);\n          }\n        }\n        if (n.isObjectLit()) {\n          JSType typ = getJSType(n);\n          for (Node key : n.children()) {\n            visitObjLitKey(t, key, n, typ);\n          }\n        }\n        break;\n\n      default:\n        report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n        ensureTyped(t, n);\n        break;\n    }\n\n    \n    typeable = typeable && !inExterns;\n\n    if (typeable) {\n      doPercentTypedAccounting(t, n);\n    }\n\n    checkNoTypeCheckSection(n, false);\n  }\n\n  private void checkTypeofString(NodeTraversal t, Node n, String s) {\n    if (!(s.equals(\"number\") || s.equals(\"string\") || s.equals(\"boolean\") ||\n          s.equals(\"undefined\") || s.equals(\"function\") ||\n          s.equals(\"object\") || s.equals(\"unknown\"))) {\n      validator.expectValidTypeofName(t, n, s);\n    }\n  }\n\n  \n  private void doPercentTypedAccounting(NodeTraversal t, Node n) {\n    JSType type = n.getJSType();\n    if (type == null) {\n      nullCount++;\n    } else if (type.isUnknownType()) {\n      if (reportUnknownTypes.isOn()) {\n        compiler.report(\n            t.makeError(n, reportUnknownTypes, UNKNOWN_EXPR_TYPE));\n      }\n      unknownCount++;\n    } else {\n      typedCount++;\n    }\n  }\n\n  \n  private void visitAssign(NodeTraversal t, Node assign) {\n    JSDocInfo info = assign.getJSDocInfo();\n    Node lvalue = assign.getFirstChild();\n    Node rvalue = assign.getLastChild();\n\n    \n    if (lvalue.isGetProp()) {\n      Node object = lvalue.getFirstChild();\n      JSType objectJsType = getJSType(object);\n      Node property = lvalue.getLastChild();\n      String pname = property.getString();\n\n      \n      \n      if (object.isGetProp()) {\n        JSType jsType = getJSType(object.getFirstChild());\n        if (jsType.isInterface() &&\n            object.getLastChild().getString().equals(\"prototype\")) {\n          visitInterfaceGetprop(t, assign, object, pname, lvalue, rvalue);\n        }\n      }\n\n      checkEnumAlias(t, info, rvalue);\n      checkPropCreation(t, lvalue);\n\n      \n      \n      \n      \n      if (pname.equals(\"prototype\")) {\n        if (objectJsType != null && objectJsType.isFunctionType()) {\n          FunctionType functionType = objectJsType.toMaybeFunctionType();\n          if (functionType.isConstructor()) {\n            JSType rvalueType = rvalue.getJSType();\n            validator.expectObject(t, rvalue, rvalueType,\n                OVERRIDING_PROTOTYPE_WITH_NON_OBJECT);\n            \n            if (functionType.makesStructs() && !rvalueType.isStruct()) {\n              String funName = functionType.getTypeOfThis().toString();\n              compiler.report(t.makeError(assign, CONFLICTING_EXTENDED_TYPE,\n                                          \"struct\", funName));\n            }\n            return;\n          }\n        }\n      }\n\n      \n      \n      \n      ObjectType type = ObjectType.cast(\n          objectJsType.restrictByNotNullOrUndefined());\n      if (type != null) {\n        if (type.hasProperty(pname) &&\n            !type.isPropertyTypeInferred(pname) &&\n            !propertyIsImplicitCast(type, pname)) {\n          JSType expectedType = type.getPropertyType(pname);\n          if (!expectedType.isUnknownType()) {\n            validator.expectCanAssignToPropertyOf(\n                t, assign, getJSType(rvalue),\n                expectedType, object, pname);\n            checkPropertyInheritanceOnGetpropAssign(\n                t, assign, object, pname, info, expectedType);\n            return;\n          }\n        }\n      }\n\n      \n      \n      checkPropertyInheritanceOnGetpropAssign(\n          t, assign, object, pname, info, getNativeType(UNKNOWN_TYPE));\n    }\n\n    \n    \n    \n    \n    \n    JSType leftType = getJSType(lvalue);\n    if (lvalue.isQualifiedName()) {\n      \n      JSType rvalueType = getJSType(assign.getLastChild());\n      Var var = t.getScope().getVar(lvalue.getQualifiedName());\n      if (var != null) {\n        if (var.isTypeInferred()) {\n          return;\n        }\n\n        if (NodeUtil.getRootOfQualifiedName(lvalue).isThis() &&\n            t.getScope() != var.getScope()) {\n          \n          return;\n        }\n\n        if (var.getType() != null) {\n          leftType = var.getType();\n        }\n      }\n    }\n\n    \n    Node rightChild = assign.getLastChild();\n    JSType rightType = getJSType(rightChild);\n    if (validator.expectCanAssignTo(\n            t, assign, rightType, leftType, \"assignment\")) {\n      ensureTyped(t, assign, rightType);\n    } else {\n      ensureTyped(t, assign);\n    }\n  }\n\n  \n  private void checkPropCreation(NodeTraversal t, Node lvalue) {\n    if (lvalue.isGetProp()) {\n      Node obj = lvalue.getFirstChild();\n      Node prop = lvalue.getLastChild();\n      JSType objType = getJSType(obj);\n      String pname = prop.getString();\n      if (objType.isStruct() && !objType.hasProperty(pname)) {\n        if (!(obj.isThis() &&\n              getJSType(t.getScope().getRootNode()).isConstructor())) {\n          report(t, prop, ILLEGAL_PROPERTY_CREATION);\n        }\n      }\n    }\n  }\n\n  private void checkPropertyInheritanceOnGetpropAssign( NodeTraversal t, Node assign, Node object, String property, JSDocInfo info, JSType propertyType) {\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    if (object.isGetProp()) {\n      Node object2 = object.getFirstChild();\n      String property2 = NodeUtil.getStringValue(object.getLastChild());\n\n      if (\"prototype\".equals(property2)) {\n        JSType jsType = getJSType(object2);\n        if (jsType.isFunctionType()) {\n          FunctionType functionType = jsType.toMaybeFunctionType();\n          if (functionType.isConstructor() || functionType.isInterface()) {\n            checkDeclaredPropertyInheritance(\n                t, assign, functionType, property, info, propertyType);\n          }\n        }\n      }\n    }\n  }\n\n  \n  private void visitObjLitKey( NodeTraversal t, Node key, Node objlit, JSType litType) {\n    \n    \n    if (objlit.isFromExterns()) {\n      ensureTyped(t, key);\n      return;\n    }\n\n    \n    if (litType.isStruct() && key.isQuotedString()) {\n      report(t, key, ILLEGAL_OBJLIT_KEY, \"struct\");\n    } else if (litType.isDict() && !key.isQuotedString()) {\n      report(t, key, ILLEGAL_OBJLIT_KEY, \"dict\");\n    }\n\n    \n    \n\n    \n    \n    Node rvalue = key.getFirstChild();\n    JSType rightType = NodeUtil.getObjectLitKeyTypeFromValueType(\n        key, getJSType(rvalue));\n    if (rightType == null) {\n      rightType = getNativeType(UNKNOWN_TYPE);\n    }\n\n    Node owner = objlit;\n\n    \n\n    JSType keyType = getJSType(key);\n\n    JSType allowedValueType = keyType;\n    if (allowedValueType.isEnumElementType()) {\n      allowedValueType =\n          allowedValueType.toMaybeEnumElementType().getPrimitiveType();\n    }\n\n    boolean valid = validator.expectCanAssignToPropertyOf(t, key,\n        rightType, allowedValueType,\n        owner, NodeUtil.getObjectLitKeyName(key));\n    if (valid) {\n      ensureTyped(t, key, rightType);\n    } else {\n      ensureTyped(t, key);\n    }\n\n    \n    \n    \n    \n    \n\n    JSType objlitType = getJSType(objlit);\n    ObjectType type = ObjectType.cast(\n        objlitType.restrictByNotNullOrUndefined());\n    if (type != null) {\n      String property = NodeUtil.getObjectLitKeyName(key);\n      if (type.hasProperty(property) &&\n          !type.isPropertyTypeInferred(property) &&\n          !propertyIsImplicitCast(type, property)) {\n        validator.expectCanAssignToPropertyOf(\n            t, key, keyType,\n            type.getPropertyType(property), owner, property);\n      }\n      return;\n    }\n  }\n\n  \n  private boolean propertyIsImplicitCast(ObjectType type, String prop) {\n    for (; type != null; type = type.getImplicitPrototype()) {\n      JSDocInfo docInfo = type.getOwnPropertyJSDocInfo(prop);\n      if (docInfo != null && docInfo.isImplicitCast()) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  \n  private void checkDeclaredPropertyInheritance( NodeTraversal t, Node n, FunctionType ctorType, String propertyName, JSDocInfo info, JSType propertyType) {\n    \n    \n    if (hasUnknownOrEmptySupertype(ctorType)) {\n      return;\n    }\n\n    FunctionType superClass = ctorType.getSuperClassConstructor();\n    boolean superClassHasProperty = superClass != null &&\n        superClass.getInstanceType().hasProperty(propertyName);\n    boolean superClassHasDeclaredProperty = superClass != null &&\n        superClass.getInstanceType().isPropertyTypeDeclared(propertyName);\n\n    \n    boolean superInterfaceHasProperty = false;\n    boolean superInterfaceHasDeclaredProperty = false;\n    if (ctorType.isInterface()) {\n      for (ObjectType interfaceType : ctorType.getExtendedInterfaces()) {\n        superInterfaceHasProperty =\n            superInterfaceHasProperty ||\n            interfaceType.hasProperty(propertyName);\n        superInterfaceHasDeclaredProperty =\n            superInterfaceHasDeclaredProperty ||\n            interfaceType.isPropertyTypeDeclared(propertyName);\n      }\n    }\n    boolean declaredOverride = info != null && info.isOverride();\n\n    boolean foundInterfaceProperty = false;\n    if (ctorType.isConstructor()) {\n      for (JSType implementedInterface :\n          ctorType.getAllImplementedInterfaces()) {\n        if (implementedInterface.isUnknownType() ||\n            implementedInterface.isEmptyType()) {\n          continue;\n        }\n        FunctionType interfaceType =\n            implementedInterface.toObjectType().getConstructor();\n        Preconditions.checkNotNull(interfaceType);\n\n        boolean interfaceHasProperty =\n            interfaceType.getPrototype().hasProperty(propertyName);\n        foundInterfaceProperty = foundInterfaceProperty ||\n            interfaceHasProperty;\n        if (reportMissingOverride.isOn()\n            && !declaredOverride\n            && interfaceHasProperty) {\n          \n          \n          compiler.report(t.makeError(n, reportMissingOverride,\n              HIDDEN_INTERFACE_PROPERTY, propertyName,\n              interfaceType.getTopMostDefiningType(propertyName).toString()));\n        }\n      }\n    }\n\n    if (!declaredOverride\n        && !superClassHasProperty\n        && !superInterfaceHasProperty) {\n      \n      return;\n    }\n\n    ObjectType topInstanceType = superClassHasDeclaredProperty ?\n        superClass.getTopMostDefiningType(propertyName) : null;\n    boolean declaredLocally =\n        ctorType.isConstructor() &&\n        (ctorType.getPrototype().hasOwnProperty(propertyName) ||\n         ctorType.getInstanceType().hasOwnProperty(propertyName));\n    if (reportMissingOverride.isOn()\n        && !declaredOverride\n        && superClassHasDeclaredProperty\n        && declaredLocally) {\n      \n      \n      compiler.report(t.makeError(n, reportMissingOverride,\n          HIDDEN_SUPERCLASS_PROPERTY, propertyName,\n          topInstanceType.toString()));\n    }\n\n    \n    if (superClassHasDeclaredProperty) {\n      \n      JSType superClassPropType =\n          superClass.getInstanceType().getPropertyType(propertyName);\n      if (!propertyType.isSubtype(superClassPropType)) {\n        compiler.report(\n            t.makeError(n, HIDDEN_SUPERCLASS_PROPERTY_MISMATCH,\n                propertyName, topInstanceType.toString(),\n                superClassPropType.toString(), propertyType.toString()));\n      }\n    } else if (superInterfaceHasDeclaredProperty) {\n      \n      for (ObjectType interfaceType : ctorType.getExtendedInterfaces()) {\n        if (interfaceType.hasProperty(propertyName)) {\n          JSType superPropertyType =\n              interfaceType.getPropertyType(propertyName);\n          if (!propertyType.isSubtype(superPropertyType)) {\n            topInstanceType = interfaceType.getConstructor().\n                getTopMostDefiningType(propertyName);\n            compiler.report(\n                t.makeError(n, HIDDEN_SUPERCLASS_PROPERTY_MISMATCH,\n                    propertyName, topInstanceType.toString(),\n                    superPropertyType.toString(),\n                    propertyType.toString()));\n          }\n        }\n      }\n    } else if (!foundInterfaceProperty\n        && !superClassHasProperty\n        && !superInterfaceHasProperty) {\n      \n      compiler.report(\n          t.makeError(n, UNKNOWN_OVERRIDE,\n              propertyName, ctorType.getInstanceType().toString()));\n    }\n  }\n\n  \n  private static boolean hasUnknownOrEmptySupertype(FunctionType ctor) {\n    Preconditions.checkArgument(ctor.isConstructor() || ctor.isInterface());\n    Preconditions.checkArgument(!ctor.isUnknownType());\n\n    \n    \n    while (true) {\n      ObjectType maybeSuperInstanceType =\n          ctor.getPrototype().getImplicitPrototype();\n      if (maybeSuperInstanceType == null) {\n        return false;\n      }\n      if (maybeSuperInstanceType.isUnknownType() ||\n          maybeSuperInstanceType.isEmptyType()) {\n        return true;\n      }\n      ctor = maybeSuperInstanceType.getConstructor();\n      if (ctor == null) {\n        return false;\n      }\n      Preconditions.checkState(ctor.isConstructor() || ctor.isInterface());\n    }\n  }\n\n  \n  private void visitInterfaceGetprop(NodeTraversal t, Node assign, Node object, String property, Node lvalue, Node rvalue) {\n\n    JSType rvalueType = getJSType(rvalue);\n\n    \n    \n    \n    \n    \n\n    String abstractMethodName =\n        compiler.getCodingConvention().getAbstractMethodName();\n    if (!rvalueType.isFunctionType()) {\n      \n      String abstractMethodMessage = (abstractMethodName != null)\n         ? \", or \" + abstractMethodName\n         : \"\";\n      compiler.report(\n          t.makeError(object, INVALID_INTERFACE_MEMBER_DECLARATION,\n              abstractMethodMessage));\n    }\n\n    if (assign.getLastChild().isFunction()\n        && !NodeUtil.isEmptyBlock(assign.getLastChild().getLastChild())) {\n      compiler.report(\n          t.makeError(object, INTERFACE_FUNCTION_NOT_EMPTY,\n              abstractMethodName));\n    }\n  }\n\n  \n  boolean visitName(NodeTraversal t, Node n, Node parent) {\n    \n    \n    \n    \n    \n    \n    \n    int parentNodeType = parent.getType();\n    if (parentNodeType == Token.FUNCTION ||\n        parentNodeType == Token.CATCH ||\n        parentNodeType == Token.PARAM_LIST ||\n        parentNodeType == Token.VAR) {\n      return false;\n    }\n\n    JSType type = n.getJSType();\n    if (type == null) {\n      type = getNativeType(UNKNOWN_TYPE);\n      Var var = t.getScope().getVar(n.getString());\n      if (var != null) {\n        JSType varType = var.getType();\n        if (varType != null) {\n          type = varType;\n        }\n      }\n    }\n    ensureTyped(t, n, type);\n    return true;\n  }\n\n  \n  private void visitGetProp(NodeTraversal t, Node n, Node parent) {\n    \n    \n    \n    \n    Node property = n.getLastChild();\n    Node objNode = n.getFirstChild();\n    JSType childType = getJSType(objNode);\n\n    if (childType.isDict()) {\n      report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n    } else if (validator.expectNotNullOrUndefined(t, n, childType,\n        \"No properties on this expression\", getNativeType(OBJECT_TYPE))) {\n      checkPropertyAccess(childType, property.getString(), t, n);\n    }\n    ensureTyped(t, n);\n  }\n\n  \n  private void checkPropertyAccess(JSType childType, String propName, NodeTraversal t, Node n) {\n    \n    \n    \n    \n    JSType propType = getJSType(n);\n    if (propType.isEquivalentTo(typeRegistry.getNativeType(UNKNOWN_TYPE))) {\n      childType = childType.autobox();\n      ObjectType objectType = ObjectType.cast(childType);\n      if (objectType != null) {\n        \n        \n        \n        if (!objectType.hasProperty(propName) ||\n            objectType.isEquivalentTo(\n                typeRegistry.getNativeType(UNKNOWN_TYPE))) {\n          if (objectType instanceof EnumType) {\n            report(t, n, INEXISTENT_ENUM_ELEMENT, propName);\n          } else {\n            checkPropertyAccessHelper(objectType, propName, t, n);\n          }\n        }\n\n      } else {\n        checkPropertyAccessHelper(childType, propName, t, n);\n      }\n    }\n  }\n\n  private void checkPropertyAccessHelper(JSType objectType, String propName, NodeTraversal t, Node n) {\n    if (!objectType.isEmptyType() &&\n        reportMissingProperties && !isPropertyTest(n)) {\n      if (!typeRegistry.canPropertyBeDefined(objectType, propName)) {\n        report(t, n, INEXISTENT_PROPERTY, propName,\n            validator.getReadableJSTypeName(n.getFirstChild(), true));\n      }\n    }\n  }\n\n  \n  private boolean isPropertyTest(Node getProp) {\n    Node parent = getProp.getParent();\n    switch (parent.getType()) {\n      case Token.CALL:\n        return parent.getFirstChild() != getProp &&\n            compiler.getCodingConvention().isPropertyTestFunction(parent);\n\n      case Token.IF:\n      case Token.WHILE:\n      case Token.DO:\n      case Token.FOR:\n        return NodeUtil.getConditionExpression(parent) == getProp;\n\n      case Token.INSTANCEOF:\n      case Token.TYPEOF:\n        return true;\n\n      case Token.AND:\n      case Token.HOOK:\n        return parent.getFirstChild() == getProp;\n\n      case Token.NOT:\n        return parent.getParent().isOr() &&\n            parent.getParent().getFirstChild() == parent;\n    }\n    return false;\n  }\n\n  \n  private void visitGetElem(NodeTraversal t, Node n) {\n    validator.expectIndexMatch(\n        t, n, getJSType(n.getFirstChild()), getJSType(n.getLastChild()));\n    ensureTyped(t, n);\n  }\n\n  \n  private void visitVar(NodeTraversal t, Node n) {\n    \n    \n    \n    JSDocInfo varInfo = n.hasOneChild() ? n.getJSDocInfo() : null;\n    for (Node name : n.children()) {\n      Node value = name.getFirstChild();\n      \n      Var var = t.getScope().getVar(name.getString());\n\n      if (value != null) {\n        JSType valueType = getJSType(value);\n        JSType nameType = var.getType();\n        nameType = (nameType == null) ? getNativeType(UNKNOWN_TYPE) : nameType;\n\n        JSDocInfo info = name.getJSDocInfo();\n        if (info == null) {\n          info = varInfo;\n        }\n\n        checkEnumAlias(t, info, value);\n        if (var.isTypeInferred()) {\n          ensureTyped(t, name, valueType);\n        } else {\n          validator.expectCanAssignTo(\n              t, value, valueType, nameType, \"initializing variable\");\n        }\n      }\n    }\n  }\n\n  \n  private void visitNew(NodeTraversal t, Node n) {\n    Node constructor = n.getFirstChild();\n    JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n    if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n      FunctionType fnType = type.toMaybeFunctionType();\n      if (fnType != null) {\n        visitParameterList(t, n, fnType);\n        ensureTyped(t, n, fnType.getInstanceType());\n      } else {\n        ensureTyped(t, n);\n      }\n    } else {\n      report(t, n, NOT_A_CONSTRUCTOR);\n      ensureTyped(t, n);\n    }\n  }\n\n  \n  private void checkInterfaceConflictProperties(NodeTraversal t, Node n, String functionName, HashMap<String, ObjectType> properties, HashMap<String, ObjectType> currentProperties, ObjectType interfaceType) {\n    ObjectType implicitProto = interfaceType.getImplicitPrototype();\n    Set<String> currentPropertyNames;\n    if (implicitProto == null) {\n      \n      \n      currentPropertyNames = ImmutableSet.of();\n    } else {\n      currentPropertyNames = implicitProto.getOwnPropertyNames();\n    }\n    for (String name : currentPropertyNames) {\n      ObjectType oType = properties.get(name);\n      if (oType != null) {\n        if (!interfaceType.getPropertyType(name).isEquivalentTo(\n            oType.getPropertyType(name))) {\n          compiler.report(\n              t.makeError(n, INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,\n                  functionName, name, oType.toString(),\n                  interfaceType.toString()));\n        }\n      }\n      currentProperties.put(name, interfaceType);\n    }\n    for (ObjectType iType : interfaceType.getCtorExtendedInterfaces()) {\n      checkInterfaceConflictProperties(t, n, functionName, properties,\n          currentProperties, iType);\n    }\n  }\n\n  \n  private void visitFunction(NodeTraversal t, Node n) {\n    FunctionType functionType = JSType.toMaybeFunctionType(n.getJSType());\n    String functionPrivateName = n.getFirstChild().getString();\n    if (functionType.isConstructor()) {\n      FunctionType baseConstructor = functionType.getSuperClassConstructor();\n      if (baseConstructor != getNativeType(OBJECT_FUNCTION_TYPE) &&\n          baseConstructor != null &&\n          baseConstructor.isInterface()) {\n        compiler.report(\n            t.makeError(n, CONFLICTING_EXTENDED_TYPE,\n                        \"constructor\", functionPrivateName));\n      } else {\n        if (baseConstructor != getNativeType(OBJECT_FUNCTION_TYPE)) {\n          ObjectType proto = functionType.getPrototype();\n          if (functionType.makesStructs() && !proto.isStruct()) {\n            compiler.report(t.makeError(n, CONFLICTING_EXTENDED_TYPE,\n                                        \"struct\", functionPrivateName));\n          } else if (functionType.makesDicts() && !proto.isDict()) {\n            compiler.report(t.makeError(n, CONFLICTING_EXTENDED_TYPE,\n                                        \"dict\", functionPrivateName));\n          }\n        }\n        \n        for (JSType baseInterface : functionType.getImplementedInterfaces()) {\n          boolean badImplementedType = false;\n          ObjectType baseInterfaceObj = ObjectType.cast(baseInterface);\n          if (baseInterfaceObj != null) {\n            FunctionType interfaceConstructor =\n              baseInterfaceObj.getConstructor();\n            if (interfaceConstructor != null &&\n                !interfaceConstructor.isInterface()) {\n              badImplementedType = true;\n            }\n          } else {\n            badImplementedType = true;\n          }\n          if (badImplementedType) {\n            report(t, n, BAD_IMPLEMENTED_TYPE, functionPrivateName);\n          }\n        }\n        \n        validator.expectAllInterfaceProperties(t, n, functionType);\n      }\n    } else if (functionType.isInterface()) {\n      \n      for (ObjectType extInterface : functionType.getExtendedInterfaces()) {\n        if (extInterface.getConstructor() != null\n            && !extInterface.getConstructor().isInterface()) {\n          compiler.report(\n              t.makeError(n, CONFLICTING_EXTENDED_TYPE,\n                          \"interface\", functionPrivateName));\n        }\n      }\n\n      \n      if (functionType.getExtendedInterfacesCount() > 1) {\n        \n        HashMap<String, ObjectType> properties\n            = new HashMap<String, ObjectType>();\n        HashMap<String, ObjectType> currentProperties\n            = new HashMap<String, ObjectType>();\n        for (ObjectType interfaceType : functionType.getExtendedInterfaces()) {\n          currentProperties.clear();\n          checkInterfaceConflictProperties(t, n, functionPrivateName,\n              properties, currentProperties, interfaceType);\n          properties.putAll(currentProperties);\n        }\n      }\n    }\n  }\n\n  \n  private void visitCall(NodeTraversal t, Node n) {\n    Node child = n.getFirstChild();\n    JSType childType = getJSType(child).restrictByNotNullOrUndefined();\n\n    if (!childType.canBeCalled()) {\n      report(t, n, NOT_CALLABLE, childType.toString());\n      ensureTyped(t, n);\n      return;\n    }\n\n    \n    \n    if (childType.isFunctionType()) {\n      FunctionType functionType = childType.toMaybeFunctionType();\n\n      boolean isExtern = false;\n      JSDocInfo functionJSDocInfo = functionType.getJSDocInfo();\n      if( functionJSDocInfo != null  &&\n          functionJSDocInfo.getAssociatedNode() != null) {\n        isExtern = functionJSDocInfo.getAssociatedNode().isFromExterns();\n      }\n\n      \n      \n      \n      if (functionType.isConstructor() &&\n          !functionType.isNativeObjectType() &&\n          (functionType.getReturnType().isUnknownType() ||\n           functionType.getReturnType().isVoidType() ||\n           !isExtern)) {\n        report(t, n, CONSTRUCTOR_NOT_CALLABLE, childType.toString());\n      }\n\n      \n      \n      if (functionType.isOrdinaryFunction() &&\n          !functionType.getTypeOfThis().isUnknownType() &&\n          !(functionType.getTypeOfThis().toObjectType() != null &&\n          functionType.getTypeOfThis().toObjectType().isNativeObjectType()) &&\n          !(child.isGetElem() ||\n            child.isGetProp())) {\n        report(t, n, EXPECTED_THIS_TYPE, functionType.toString());\n      }\n\n      visitParameterList(t, n, functionType);\n      ensureTyped(t, n, functionType.getReturnType());\n    } else {\n      ensureTyped(t, n);\n    }\n\n    \n    \n    \n  }\n\n  \n  private void visitParameterList(NodeTraversal t, Node call, FunctionType functionType) {\n    Iterator<Node> arguments = call.children().iterator();\n    arguments.next(); \n\n    Iterator<Node> parameters = functionType.getParameters().iterator();\n    int ordinal = 0;\n    Node parameter = null;\n    Node argument = null;\n    while (arguments.hasNext() &&\n           (parameters.hasNext() ||\n            parameter != null && parameter.isVarArgs())) {\n      \n      \n      if (parameters.hasNext()) {\n        parameter = parameters.next();\n      }\n      argument = arguments.next();\n      ordinal++;\n\n      validator.expectArgumentMatchesParameter(t, argument,\n          getJSType(argument), getJSType(parameter), call, ordinal);\n    }\n\n    int numArgs = call.getChildCount() - 1;\n    int minArgs = functionType.getMinArguments();\n    int maxArgs = functionType.getMaxArguments();\n    if (minArgs > numArgs || maxArgs < numArgs) {\n      report(t, call, WRONG_ARGUMENT_COUNT,\n              validator.getReadableJSTypeName(call.getFirstChild(), false),\n              String.valueOf(numArgs), String.valueOf(minArgs),\n              maxArgs != Integer.MAX_VALUE ?\n              \" and no more than \" + maxArgs + \" argument(s)\" : \"\");\n    }\n  }\n\n  \n  private void visitReturn(NodeTraversal t, Node n) {\n    JSType jsType = getJSType(t.getEnclosingFunction());\n\n    if (jsType.isFunctionType()) {\n      FunctionType functionType = jsType.toMaybeFunctionType();\n\n      JSType returnType = functionType.getReturnType();\n\n      \n      \n      if (returnType == null) {\n        returnType = getNativeType(VOID_TYPE);\n      }\n\n      \n      Node valueNode = n.getFirstChild();\n      JSType actualReturnType;\n      if (valueNode == null) {\n        actualReturnType = getNativeType(VOID_TYPE);\n        valueNode = n;\n      } else {\n        actualReturnType = getJSType(valueNode);\n      }\n\n      \n      validator.expectCanAssignTo(t, valueNode, actualReturnType, returnType,\n          \"inconsistent return type\");\n    }\n  }\n\n  \n  private void visitBinaryOperator(int op, NodeTraversal t, Node n) {\n    Node left = n.getFirstChild();\n    JSType leftType = getJSType(left);\n    Node right = n.getLastChild();\n    JSType rightType = getJSType(right);\n    switch (op) {\n      case Token.ASSIGN_LSH:\n      case Token.ASSIGN_RSH:\n      case Token.LSH:\n      case Token.RSH:\n      case Token.ASSIGN_URSH:\n      case Token.URSH:\n        if (!leftType.matchesInt32Context()) {\n          report(t, left, BIT_OPERATION,\n                   NodeUtil.opToStr(n.getType()), leftType.toString());\n        }\n        if (!rightType.matchesUint32Context()) {\n          report(t, right, BIT_OPERATION,\n                   NodeUtil.opToStr(n.getType()), rightType.toString());\n        }\n        break;\n\n      case Token.ASSIGN_DIV:\n      case Token.ASSIGN_MOD:\n      case Token.ASSIGN_MUL:\n      case Token.ASSIGN_SUB:\n      case Token.DIV:\n      case Token.MOD:\n      case Token.MUL:\n      case Token.SUB:\n        validator.expectNumber(t, left, leftType, \"left operand\");\n        validator.expectNumber(t, right, rightType, \"right operand\");\n        break;\n\n      case Token.ASSIGN_BITAND:\n      case Token.ASSIGN_BITXOR:\n      case Token.ASSIGN_BITOR:\n      case Token.BITAND:\n      case Token.BITXOR:\n      case Token.BITOR:\n        validator.expectBitwiseable(t, left, leftType,\n            \"bad left operand to bitwise operator\");\n        validator.expectBitwiseable(t, right, rightType,\n            \"bad right operand to bitwise operator\");\n        break;\n\n      case Token.ASSIGN_ADD:\n      case Token.ADD:\n        break;\n\n      default:\n        report(t, n, UNEXPECTED_TOKEN, Token.name(op));\n    }\n    ensureTyped(t, n);\n  }\n\n\n  \n  private void checkEnumAlias( NodeTraversal t, JSDocInfo declInfo, Node value) {\n    if (declInfo == null || !declInfo.hasEnumParameterType()) {\n      return;\n    }\n\n    JSType valueType = getJSType(value);\n    if (!valueType.isEnumType()) {\n      return;\n    }\n\n    EnumType valueEnumType = valueType.toMaybeEnumType();\n    JSType valueEnumPrimitiveType =\n        valueEnumType.getElementsType().getPrimitiveType();\n    validator.expectCanAssignTo(t, value, valueEnumPrimitiveType,\n        declInfo.getEnumParameterType().evaluate(t.getScope(), typeRegistry),\n        \"incompatible enum element types\");\n  }\n\n  \n  private JSType getJSType(Node n) {\n    JSType jsType = n.getJSType();\n    if (jsType == null) {\n      \n      \n      \n      \n      return getNativeType(UNKNOWN_TYPE);\n    } else {\n      return jsType;\n    }\n  }\n\n  \n  \n  \n  \n  \n\n  \n  private void ensureTyped(NodeTraversal t, Node n) {\n    ensureTyped(t, n, getNativeType(UNKNOWN_TYPE));\n  }\n\n  private void ensureTyped(NodeTraversal t, Node n, JSTypeNative type) {\n    ensureTyped(t, n, getNativeType(type));\n  }\n\n  \n  private void ensureTyped(NodeTraversal t, Node n, JSType type) {\n    \n    Preconditions.checkState(!n.isFunction() ||\n            type.isFunctionType() ||\n            type.isUnknownType());\n    JSDocInfo info = n.getJSDocInfo();\n    if (info != null) {\n      if (info.hasType()) {\n        \n        \n        \n        \n        JSType infoType = info.getType().evaluate(t.getScope(), typeRegistry);\n        validator.expectCanCast(t, n, infoType, type);\n        type = infoType;\n      }\n\n      if (info.isImplicitCast() && !inExterns) {\n        String propName = n.isGetProp() ?\n            n.getLastChild().getString() : \"(missing)\";\n        compiler.report(\n            t.makeError(n, ILLEGAL_IMPLICIT_CAST, propName));\n      }\n    }\n\n    if (n.getJSType() == null) {\n      n.setJSType(type);\n    }\n  }\n\n  \n  double getTypedPercent() {\n    int total = nullCount + unknownCount + typedCount;\n    return (total == 0) ? 0.0 : (100.0 * typedCount) / total;\n  }\n\n  private JSType getNativeType(JSTypeNative typeId) {\n    return typeRegistry.getNativeType(typeId);\n  }\n}\n",
      "buggy_signatures": [
        "public TypeCheck(AbstractCompiler compiler, ReverseAbstractInterpreter reverseInterpreter, JSTypeRegistry typeRegistry, CheckLevel reportMissingOverride, CheckLevel reportUnknownTypes)",
        "public void process(Node externsRoot, Node jsRoot)",
        "public Scope processForTesting(Node externsRoot, Node jsRoot)",
        "public void check(Node node, boolean externs)",
        "private void checkNoTypeCheckSection(Node n, boolean enterSection)",
        "private void report(NodeTraversal t, Node n, DiagnosticType diagnosticType, String... arguments)",
        "public boolean shouldTraverse( NodeTraversal t, Node n, Node parent)",
        "public void visit(NodeTraversal t, Node n, Node parent)",
        "private void checkTypeofString(NodeTraversal t, Node n, String s)",
        "private void doPercentTypedAccounting(NodeTraversal t, Node n)",
        "private void visitAssign(NodeTraversal t, Node assign)",
        "private void checkPropCreation(NodeTraversal t, Node lvalue)",
        "private void checkPropertyInheritanceOnGetpropAssign( NodeTraversal t, Node assign, Node object, String property, JSDocInfo info, JSType propertyType)",
        "private void visitObjLitKey( NodeTraversal t, Node key, Node objlit, JSType litType)",
        "private boolean propertyIsImplicitCast(ObjectType type, String prop)",
        "private void checkDeclaredPropertyInheritance( NodeTraversal t, Node n, FunctionType ctorType, String propertyName, JSDocInfo info, JSType propertyType)",
        "private static boolean hasUnknownOrEmptySupertype(FunctionType ctor)",
        "private void visitInterfaceGetprop(NodeTraversal t, Node assign, Node object, String property, Node lvalue, Node rvalue)",
        "private void visitGetProp(NodeTraversal t, Node n, Node parent)",
        "private void checkPropertyAccess(JSType childType, String propName, NodeTraversal t, Node n)",
        "private void checkPropertyAccessHelper(JSType objectType, String propName, NodeTraversal t, Node n)",
        "private boolean isPropertyTest(Node getProp)",
        "private void visitGetElem(NodeTraversal t, Node n)",
        "private void visitVar(NodeTraversal t, Node n)",
        "private void visitNew(NodeTraversal t, Node n)",
        "private void checkInterfaceConflictProperties(NodeTraversal t, Node n, String functionName, HashMap<String, ObjectType> properties, HashMap<String, ObjectType> currentProperties, ObjectType interfaceType)",
        "private void visitFunction(NodeTraversal t, Node n)",
        "private void visitCall(NodeTraversal t, Node n)",
        "private void visitParameterList(NodeTraversal t, Node call, FunctionType functionType)",
        "private void visitReturn(NodeTraversal t, Node n)",
        "private void visitBinaryOperator(int op, NodeTraversal t, Node n)",
        "private void checkEnumAlias( NodeTraversal t, JSDocInfo declInfo, Node value)",
        "private JSType getJSType(Node n)",
        "private void ensureTyped(NodeTraversal t, Node n)",
        "private void ensureTyped(NodeTraversal t, Node n, JSTypeNative type)",
        "private void ensureTyped(NodeTraversal t, Node n, JSType type)",
        "private JSType getNativeType(JSTypeNative typeId)"
      ],
      "fixed_signatures": [
        "public TypeCheck(AbstractCompiler compiler, ReverseAbstractInterpreter reverseInterpreter, JSTypeRegistry typeRegistry, CheckLevel reportMissingOverride, CheckLevel reportUnknownTypes)",
        "public void process(Node externsRoot, Node jsRoot)",
        "public Scope processForTesting(Node externsRoot, Node jsRoot)",
        "public void check(Node node, boolean externs)",
        "private void checkNoTypeCheckSection(Node n, boolean enterSection)",
        "private void report(NodeTraversal t, Node n, DiagnosticType diagnosticType, String... arguments)",
        "public boolean shouldTraverse( NodeTraversal t, Node n, Node parent)",
        "public void visit(NodeTraversal t, Node n, Node parent)",
        "private void checkTypeofString(NodeTraversal t, Node n, String s)",
        "private void doPercentTypedAccounting(NodeTraversal t, Node n)",
        "private void visitAssign(NodeTraversal t, Node assign)",
        "private void checkPropCreation(NodeTraversal t, Node lvalue)",
        "private void checkPropertyInheritanceOnGetpropAssign( NodeTraversal t, Node assign, Node object, String property, JSDocInfo info, JSType propertyType)",
        "private void visitObjLitKey( NodeTraversal t, Node key, Node objlit, JSType litType)",
        "private boolean propertyIsImplicitCast(ObjectType type, String prop)",
        "private void checkDeclaredPropertyInheritance( NodeTraversal t, Node n, FunctionType ctorType, String propertyName, JSDocInfo info, JSType propertyType)",
        "private static boolean hasUnknownOrEmptySupertype(FunctionType ctor)",
        "private void visitInterfaceGetprop(NodeTraversal t, Node assign, Node object, String property, Node lvalue, Node rvalue)",
        "private void visitGetProp(NodeTraversal t, Node n, Node parent)",
        "private void checkPropertyAccess(JSType childType, String propName, NodeTraversal t, Node n)",
        "private void checkPropertyAccessHelper(JSType objectType, String propName, NodeTraversal t, Node n)",
        "private boolean isPropertyTest(Node getProp)",
        "private void visitGetElem(NodeTraversal t, Node n)",
        "private void visitVar(NodeTraversal t, Node n)",
        "private void visitNew(NodeTraversal t, Node n)",
        "private void checkInterfaceConflictProperties(NodeTraversal t, Node n, String functionName, HashMap<String, ObjectType> properties, HashMap<String, ObjectType> currentProperties, ObjectType interfaceType)",
        "private void visitFunction(NodeTraversal t, Node n)",
        "private void visitCall(NodeTraversal t, Node n)",
        "private void visitParameterList(NodeTraversal t, Node call, FunctionType functionType)",
        "private void visitReturn(NodeTraversal t, Node n)",
        "private void visitBinaryOperator(int op, NodeTraversal t, Node n)",
        "private void checkEnumAlias( NodeTraversal t, JSDocInfo declInfo, Node value)",
        "private JSType getJSType(Node n)",
        "private void ensureTyped(NodeTraversal t, Node n)",
        "private void ensureTyped(NodeTraversal t, Node n, JSTypeNative type)",
        "private void ensureTyped(NodeTraversal t, Node n, JSType type)",
        "private JSType getNativeType(JSTypeNative typeId)"
      ],
      "methods": [
        {
          "buggy_method": "  private void checkInterfaceConflictProperties(NodeTraversal t, Node n, String functionName, HashMap<String, ObjectType> properties, HashMap<String, ObjectType> currentProperties, ObjectType interfaceType) {\n  ObjectType implicitProto = interfaceType.getImplicitPrototype();\n  Set<String> currentPropertyNames;\n  \n  \n  currentPropertyNames = implicitProto.getOwnPropertyNames();\n  for (String name : currentPropertyNames) {\n  ObjectType oType = properties.get(name);\n  if (oType != null) {\n  if (!interfaceType.getPropertyType(name).isEquivalentTo(\n  oType.getPropertyType(name))) {\n  compiler.report(\n  t.makeError(n, INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,\n  functionName, name, oType.toString(),\n  interfaceType.toString()));\n  }\n  }\n  currentProperties.put(name, interfaceType);\n  }\n  for (ObjectType iType : interfaceType.getCtorExtendedInterfaces()) {\n  checkInterfaceConflictProperties(t, n, functionName, properties,\n  currentProperties, iType);\n  }\n  }",
          "fixed_method": "  private void checkInterfaceConflictProperties(NodeTraversal t, Node n, String functionName, HashMap<String, ObjectType> properties, HashMap<String, ObjectType> currentProperties, ObjectType interfaceType) {\n  ObjectType implicitProto = interfaceType.getImplicitPrototype();\n  Set<String> currentPropertyNames;\n  if (implicitProto == null) {\n  \n  \n  currentPropertyNames = ImmutableSet.of();\n  } else {\n  currentPropertyNames = implicitProto.getOwnPropertyNames();\n  }\n  for (String name : currentPropertyNames) {\n  ObjectType oType = properties.get(name);\n  if (oType != null) {\n  if (!interfaceType.getPropertyType(name).isEquivalentTo(\n  oType.getPropertyType(name))) {\n  compiler.report(\n  t.makeError(n, INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,\n  functionName, name, oType.toString(),\n  interfaceType.toString()));\n  }\n  }\n  currentProperties.put(name, interfaceType);\n  }\n  for (ObjectType iType : interfaceType.getCtorExtendedInterfaces()) {\n  checkInterfaceConflictProperties(t, n, functionName, properties,\n  currentProperties, iType);\n  }\n  }",
          "diff": [
            "@@ -1569,9 +1569,13 @@",
            "       ObjectType interfaceType) {\n",
            "     ObjectType implicitProto = interfaceType.getImplicitPrototype();\n",
            "     Set<String> currentPropertyNames;\n",
            "+    if (implicitProto == null) {\n",
            "       // This can be the case if interfaceType is proxy to a non-existent\n",
            "       // object (which is a bad type annotation, but shouldn't crash).\n",
            "+      currentPropertyNames = ImmutableSet.of();\n",
            "+    } else {\n",
            "       currentPropertyNames = implicitProto.getOwnPropertyNames();\n",
            "+    }\n",
            "     for (String name : currentPropertyNames) {\n",
            "       ObjectType oType = properties.get(name);\n",
            "       if (oType != null) {\n"
          ],
          "changed_lines": 4
        }
      ]
    }
  ]
}
