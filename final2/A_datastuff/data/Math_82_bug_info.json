{
  "bug_id": "82",
  "failed_tests": {
    "org.apache.commons.math.optimization.linear.SimplexSolverTest": [
      {
        "methodName": "testMath288",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<10.0> but was:<11.5>",
        "fail_line": "        assertEquals(10.0, solution.getValue(), .0000001);",
        "test_source": "  public void testMath288() throws OptimizationException {\n  LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 7, 3, 0, 0 }, 0 );\n  Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();\n  constraints.add(new LinearConstraint(new double[] { 3, 0, -5, 0 }, Relationship.LEQ, 0.0));\n  constraints.add(new LinearConstraint(new double[] { 2, 0, 0, -5 }, Relationship.LEQ, 0.0));\n  constraints.add(new LinearConstraint(new double[] { 0, 3, 0, -5 }, Relationship.LEQ, 0.0));\n  constraints.add(new LinearConstraint(new double[] { 1, 0, 0, 0 }, Relationship.LEQ, 1.0));\n  constraints.add(new LinearConstraint(new double[] { 0, 1, 0, 0 }, Relationship.LEQ, 1.0));\n\n  SimplexSolver solver = new SimplexSolver();\n  RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, true);\n  assertEquals(10.0, solution.getValue(), .0000001);\n  }",
        "stack": [
          "SimplexSolverTest.testMath288 line 73"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/math/optimization/linear/SimplexSolver.java",
      "buggy_full_code": "\n\npackage org.apache.commons.math.optimization.linear;\n\nimport org.apache.commons.math.optimization.OptimizationException;\nimport org.apache.commons.math.optimization.RealPointValuePair;\nimport org.apache.commons.math.util.MathUtils;\n\n\n\npublic class SimplexSolver extends AbstractLinearOptimizer { private static final double DEFAULT_EPSILON = 1.0e-6; protected final double epsilon; public SimplexSolver() {\n        this(DEFAULT_EPSILON);\n    }\n\n    \n    public SimplexSolver(final double epsilon) {\n        this.epsilon = epsilon;\n    }\n\n    \n    private Integer getPivotColumn(SimplexTableau tableau) {\n        double minValue = 0;\n        Integer minPos = null;\n        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) {\n            if (MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon) < 0) {\n                minValue = tableau.getEntry(0, i);\n                minPos = i;\n            }\n        }\n        return minPos;\n    }\n\n    \n    private Integer getPivotRow(final int col, final SimplexTableau tableau) {\n        double minRatio = Double.MAX_VALUE;\n        Integer minRatioPos = null;\n        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n            final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n            final double entry = tableau.getEntry(i, col);\n            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n                final double ratio = rhs / entry;\n                if (ratio < minRatio) {\n                    minRatio = ratio;\n                    minRatioPos = i; \n                }\n            }\n        }\n        return minRatioPos;\n    }\n\n\n    \n    protected void doIteration(final SimplexTableau tableau) throws OptimizationException {\n\n        incrementIterationsCounter();\n\n        Integer pivotCol = getPivotColumn(tableau);\n        Integer pivotRow = getPivotRow(pivotCol, tableau);\n        if (pivotRow == null) {\n            throw new UnboundedSolutionException();\n        }\n\n        \n        double pivotVal = tableau.getEntry(pivotRow, pivotCol);\n        tableau.divideRow(pivotRow, pivotVal);\n\n        \n        for (int i = 0; i < tableau.getHeight(); i++) {\n            if (i != pivotRow) {\n                double multiplier = tableau.getEntry(i, pivotCol);\n                tableau.subtractRow(i, pivotRow, multiplier);\n            }\n        }\n    }\n\n    \n    private boolean isPhase1Solved(final SimplexTableau tableau) {\n        if (tableau.getNumArtificialVariables() == 0) {\n            return true;\n        }\n        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) {\n            if (MathUtils.compareTo(tableau.getEntry(0, i), 0, epsilon) < 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public boolean isOptimal(final SimplexTableau tableau) {\n        if (tableau.getNumArtificialVariables() > 0) {\n            return false;\n        }\n        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) {\n            if (MathUtils.compareTo(tableau.getEntry(0, i), 0, epsilon) < 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    protected void solvePhase1(final SimplexTableau tableau) throws OptimizationException {\n        \n        if (tableau.getNumArtificialVariables() == 0) {\n            return;\n        }\n\n        while (!isPhase1Solved(tableau)) {\n            doIteration(tableau);\n        }\n\n        \n        if (!MathUtils.equals(tableau.getEntry(0, tableau.getRhsOffset()), 0, epsilon)) {\n            throw new NoFeasibleSolutionException();\n        }\n    }\n\n    \n    @Override\n    public RealPointValuePair doOptimize() throws OptimizationException {\n        final SimplexTableau tableau =\n            new SimplexTableau(f, constraints, goalType, restrictToNonNegative, epsilon);\n        solvePhase1(tableau);\n        tableau.discardArtificialVariables();\n        while (!isOptimal(tableau)) {\n            doIteration(tableau);\n        }\n        return tableau.getSolution();\n    }\n\n}\n",
      "fixed_full_code": "\n\npackage org.apache.commons.math.optimization.linear;\n\nimport org.apache.commons.math.optimization.OptimizationException;\nimport org.apache.commons.math.optimization.RealPointValuePair;\nimport org.apache.commons.math.util.MathUtils;\n\n\n\npublic class SimplexSolver extends AbstractLinearOptimizer { private static final double DEFAULT_EPSILON = 1.0e-6; protected final double epsilon; public SimplexSolver() {\n        this(DEFAULT_EPSILON);\n    }\n\n    \n    public SimplexSolver(final double epsilon) {\n        this.epsilon = epsilon;\n    }\n\n    \n    private Integer getPivotColumn(SimplexTableau tableau) {\n        double minValue = 0;\n        Integer minPos = null;\n        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) {\n            if (MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon) < 0) {\n                minValue = tableau.getEntry(0, i);\n                minPos = i;\n            }\n        }\n        return minPos;\n    }\n\n    \n    private Integer getPivotRow(final int col, final SimplexTableau tableau) {\n        double minRatio = Double.MAX_VALUE;\n        Integer minRatioPos = null;\n        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n            final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n            final double entry = tableau.getEntry(i, col);\n            if (MathUtils.compareTo(entry, 0, epsilon) > 0) {\n                final double ratio = rhs / entry;\n                if (ratio < minRatio) {\n                    minRatio = ratio;\n                    minRatioPos = i; \n                }\n            }\n        }\n        return minRatioPos;\n    }\n\n\n    \n    protected void doIteration(final SimplexTableau tableau) throws OptimizationException {\n\n        incrementIterationsCounter();\n\n        Integer pivotCol = getPivotColumn(tableau);\n        Integer pivotRow = getPivotRow(pivotCol, tableau);\n        if (pivotRow == null) {\n            throw new UnboundedSolutionException();\n        }\n\n        \n        double pivotVal = tableau.getEntry(pivotRow, pivotCol);\n        tableau.divideRow(pivotRow, pivotVal);\n\n        \n        for (int i = 0; i < tableau.getHeight(); i++) {\n            if (i != pivotRow) {\n                double multiplier = tableau.getEntry(i, pivotCol);\n                tableau.subtractRow(i, pivotRow, multiplier);\n            }\n        }\n    }\n\n    \n    private boolean isPhase1Solved(final SimplexTableau tableau) {\n        if (tableau.getNumArtificialVariables() == 0) {\n            return true;\n        }\n        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) {\n            if (MathUtils.compareTo(tableau.getEntry(0, i), 0, epsilon) < 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public boolean isOptimal(final SimplexTableau tableau) {\n        if (tableau.getNumArtificialVariables() > 0) {\n            return false;\n        }\n        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) {\n            if (MathUtils.compareTo(tableau.getEntry(0, i), 0, epsilon) < 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    protected void solvePhase1(final SimplexTableau tableau) throws OptimizationException {\n        \n        if (tableau.getNumArtificialVariables() == 0) {\n            return;\n        }\n\n        while (!isPhase1Solved(tableau)) {\n            doIteration(tableau);\n        }\n\n        \n        if (!MathUtils.equals(tableau.getEntry(0, tableau.getRhsOffset()), 0, epsilon)) {\n            throw new NoFeasibleSolutionException();\n        }\n    }\n\n    \n    @Override\n    public RealPointValuePair doOptimize() throws OptimizationException {\n        final SimplexTableau tableau =\n            new SimplexTableau(f, constraints, goalType, restrictToNonNegative, epsilon);\n        solvePhase1(tableau);\n        tableau.discardArtificialVariables();\n        while (!isOptimal(tableau)) {\n            doIteration(tableau);\n        }\n        return tableau.getSolution();\n    }\n\n}\n",
      "buggy_signatures": [
        "public SimplexSolver(final double epsilon)",
        "private Integer getPivotColumn(SimplexTableau tableau)",
        "private Integer getPivotRow(final int col, final SimplexTableau tableau)",
        "protected void doIteration(final SimplexTableau tableau) throws OptimizationException",
        "private boolean isPhase1Solved(final SimplexTableau tableau)",
        "public boolean isOptimal(final SimplexTableau tableau)",
        "protected void solvePhase1(final SimplexTableau tableau) throws OptimizationException",
        "public RealPointValuePair doOptimize() throws OptimizationException"
      ],
      "fixed_signatures": [
        "public SimplexSolver(final double epsilon)",
        "private Integer getPivotColumn(SimplexTableau tableau)",
        "private Integer getPivotRow(final int col, final SimplexTableau tableau)",
        "protected void doIteration(final SimplexTableau tableau) throws OptimizationException",
        "private boolean isPhase1Solved(final SimplexTableau tableau)",
        "public boolean isOptimal(final SimplexTableau tableau)",
        "protected void solvePhase1(final SimplexTableau tableau) throws OptimizationException",
        "public RealPointValuePair doOptimize() throws OptimizationException"
      ],
      "methods": [
        {
          "buggy_method": "  private Integer getPivotRow(final int col, final SimplexTableau tableau) {\n  double minRatio = Double.MAX_VALUE;\n  Integer minRatioPos = null;\n  for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n  final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n  final double entry = tableau.getEntry(i, col);\n  if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n  final double ratio = rhs / entry;\n  if (ratio < minRatio) {\n  minRatio = ratio;\n  minRatioPos = i; \n  }\n  }\n  }\n  return minRatioPos;\n  }",
          "fixed_method": "  private Integer getPivotRow(final int col, final SimplexTableau tableau) {\n  double minRatio = Double.MAX_VALUE;\n  Integer minRatioPos = null;\n  for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n  final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n  final double entry = tableau.getEntry(i, col);\n  if (MathUtils.compareTo(entry, 0, epsilon) > 0) {\n  final double ratio = rhs / entry;\n  if (ratio < minRatio) {\n  minRatio = ratio;\n  minRatioPos = i; \n  }\n  }\n  }\n  return minRatioPos;\n  }",
          "diff": [
            "@@ -79,7 +79,7 @@",
            "         for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n",
            "             final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n",
            "             final double entry = tableau.getEntry(i, col);\n",
            "-            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n",
            "+            if (MathUtils.compareTo(entry, 0, epsilon) > 0) {\n",
            "                 final double ratio = rhs / entry;\n",
            "                 if (ratio < minRatio) {\n",
            "                     minRatio = ratio;\n"
          ],
          "changed_lines": 2
        }
      ]
    }
  ]
}
