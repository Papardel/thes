{
  "bug_id": "78",
  "failed_tests": {
    "com.fasterxml.jackson.databind.interop.IllegalTypesCheckTest": [
      {
        "methodName": "testIssue1599",
        "error": "junit.framework.AssertionFailedError",
        "message": "Expected an exception with one of substrings ([Illegal type]): got one with message \"N/A",
        "fail_line": "            verifyException(e, \"Illegal type\");",
        "test_source": "  public void testIssue1599() throws Exception {\n  final String JSON = aposToQuotes(\n \"{'id': 124,\\n\"\n+\" 'obj':[ 'com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl',\\n\"\n+\"  {\\n\"\n+\"  'transletBytecodes' : [ 'AAIAZQ==' ],\\n\"\n+\"  'transletName' : 'a.b',\\n\"\n+\"  'outputProperties' : { }\\n\"\n+\"  }\\n\"\n+\" ]\\n\"\n+\"}\"\n  );\n  ObjectMapper mapper = new ObjectMapper();\n  mapper.enableDefaultTyping();\n  try {\n  mapper.readValue(JSON, Bean1599.class);\n  fail(\"Should not pass\");\n  } catch (JsonMappingException e) {\n  verifyException(e, \"Illegal type\");\n  verifyException(e, \"to deserialize\");\n  verifyException(e, \"prevented for security reasons\");\n  }\n  }",
        "stack": [
          "BaseTest.verifyException line 367, IllegalTypesCheckTest.testIssue1599 line 35"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java",
      "buggy_full_code": "package com.fasterxml.jackson.databind.deser;\n\nimport java.util.*;\n\nimport com.fasterxml.jackson.annotation.*;\n\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.annotation.JsonPOJOBuilder;\nimport com.fasterxml.jackson.databind.cfg.DeserializerFactoryConfig;\nimport com.fasterxml.jackson.databind.cfg.ConfigOverride;\nimport com.fasterxml.jackson.databind.deser.impl.*;\nimport com.fasterxml.jackson.databind.deser.std.ThrowableDeserializer;\nimport com.fasterxml.jackson.databind.introspect.*;\nimport com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\nimport com.fasterxml.jackson.databind.util.SimpleBeanPropertyDefinition;\n\n\npublic class BeanDeserializerFactory extends BasicDeserializerFactory implements java.io.Serializable { private static final long serialVersionUID = 1; private final static Class<?>[] INIT_CAUSE_PARAMS = new Class<?>[] { Throwable.class }; private final static Class<?>[] NO_VIEWS = new Class<?>[0]; public final static BeanDeserializerFactory instance = new BeanDeserializerFactory( new DeserializerFactoryConfig()); public BeanDeserializerFactory(DeserializerFactoryConfig config) {\n        super(config);\n    }\n    \n    \n    @Override\n    public DeserializerFactory withConfig(DeserializerFactoryConfig config) {\n        if (_factoryConfig == config) {\n            return this;\n        }\n        \n        if (getClass() != BeanDeserializerFactory.class) {\n            throw new IllegalStateException(\"Subtype of BeanDeserializerFactory (\"+getClass().getName()\n                    +\") has not properly overridden method 'withAdditionalDeserializers': can not instantiate subtype with \"\n                    +\"additional deserializer definitions\");\n        }\n        return new BeanDeserializerFactory(config);\n    }\n    \n    \n\n    \n    @Override\n    public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n        final DeserializationConfig config = ctxt.getConfig();\n        \n        JsonDeserializer<Object> custom = _findCustomBeanDeserializer(type, config, beanDesc);\n        if (custom != null) {\n            return custom;\n        }\n        \n        if (type.isThrowable()) {\n            return buildThrowableDeserializer(ctxt, type, beanDesc);\n        }\n        \n        \n        \n        if (type.isAbstract() && !type.isPrimitive() && !type.isEnumType()) {\n            \n            JavaType concreteType = materializeAbstractType(ctxt, type, beanDesc);\n            if (concreteType != null) {\n                \n                beanDesc = config.introspect(concreteType);\n                return buildBeanDeserializer(ctxt, concreteType, beanDesc);\n            }\n        }\n        \n        @SuppressWarnings(\"unchecked\")\n        JsonDeserializer<Object> deser = (JsonDeserializer<Object>) findStdDeserializer(ctxt, type, beanDesc);\n        if (deser != null) {\n            return deser;\n        }\n\n        \n        if (!isPotentialBeanType(type.getRawClass())) {\n            return null;\n        }\n        \n        \n        return buildBeanDeserializer(ctxt, type, beanDesc);\n    }\n\n    @Override\n    public JsonDeserializer<Object> createBuilderBasedDeserializer( DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException {\n        \n        JavaType builderType = ctxt.constructType(builderClass);\n        BeanDescription builderDesc = ctxt.getConfig().introspectForBuilder(builderType);\n        return buildBuilderBasedDeserializer(ctxt, valueType, builderDesc);\n    }\n    \n    \n    protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n        \n        \n        JsonDeserializer<?> deser = findDefaultDeserializer(ctxt, type, beanDesc);\n        \n        if (deser != null) {\n            if (_factoryConfig.hasDeserializerModifiers()) {\n                for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                    deser = mod.modifyDeserializer(ctxt.getConfig(), beanDesc, deser);\n                }\n            }\n        }\n        return deser;\n    }\n    \n    protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n        \n        for (AbstractTypeResolver r : _factoryConfig.abstractTypeResolvers()) {\n            JavaType concrete = r.resolveAbstractType(ctxt.getConfig(), beanDesc);\n            if (concrete != null) {\n                return concrete;\n            }\n        }\n        return null;\n    }\n\n    \n\n    \n    @SuppressWarnings(\"unchecked\")\n    public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n        \n        ValueInstantiator valueInstantiator;\n        \n        try {\n            valueInstantiator = findValueInstantiator(ctxt, beanDesc);\n        } catch (NoClassDefFoundError error) {\n            return new ErrorThrowingDeserializer(error);\n        }\n        BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc);\n        builder.setValueInstantiator(valueInstantiator);\n         \n        addBeanProps(ctxt, beanDesc, builder);\n        addObjectIdReader(ctxt, beanDesc, builder);\n\n        \n        addReferenceProperties(ctxt, beanDesc, builder);\n        addInjectables(ctxt, beanDesc, builder);\n        \n        final DeserializationConfig config = ctxt.getConfig();\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                builder = mod.updateBuilder(config, beanDesc, builder);\n            }\n        }\n        JsonDeserializer<?> deserializer;\n\n        \n        if (type.isAbstract() && !valueInstantiator.canInstantiate()) {\n            deserializer = builder.buildAbstract();\n        } else {\n            deserializer = builder.build();\n        }\n\n        \n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                deserializer = mod.modifyDeserializer(config, beanDesc, deserializer);\n            }\n        }\n        return (JsonDeserializer<Object>) deserializer;\n    }\n    \n    \n    @SuppressWarnings(\"unchecked\")\n    protected JsonDeserializer<Object> buildBuilderBasedDeserializer( DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException {\n    \t\n        ValueInstantiator valueInstantiator = findValueInstantiator(ctxt, builderDesc);\n        final DeserializationConfig config = ctxt.getConfig();\n        BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, builderDesc);\n        builder.setValueInstantiator(valueInstantiator);\n         \n        addBeanProps(ctxt, builderDesc, builder);\n        addObjectIdReader(ctxt, builderDesc, builder);\n        \n        \n        addReferenceProperties(ctxt, builderDesc, builder);\n        addInjectables(ctxt, builderDesc, builder);\n\n        JsonPOJOBuilder.Value builderConfig = builderDesc.findPOJOBuilderConfig();\n        final String buildMethodName = (builderConfig == null) ?\n                \"build\" : builderConfig.buildMethodName;\n        \n        \n        AnnotatedMethod buildMethod = builderDesc.findMethod(buildMethodName, null);\n        if (buildMethod != null) { \n            if (config.canOverrideAccessModifiers()) {\n            \tClassUtil.checkAndFixAccess(buildMethod.getMember(), config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n            }\n        }\n        builder.setPOJOBuilder(buildMethod, builderConfig);\n        \n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                builder = mod.updateBuilder(config, builderDesc, builder);\n            }\n        }\n        JsonDeserializer<?> deserializer = builder.buildBuilderBased(\n        \t\tvalueType, buildMethodName);\n\n        \n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                deserializer = mod.modifyDeserializer(config, builderDesc, deserializer);\n            }\n        }\n        return (JsonDeserializer<Object>) deserializer;\n    }\n    \n    protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException {\n        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n        if (objectIdInfo == null) {\n            return;\n        }\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n        JavaType idType;\n        SettableBeanProperty idProp;\n        ObjectIdGenerator<?> gen;\n\n        ObjectIdResolver resolver = ctxt.objectIdResolverInstance(beanDesc.getClassInfo(), objectIdInfo);\n\n        \n        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { \n            PropertyName propName = objectIdInfo.getPropertyName();\n            idProp = builder.findProperty(propName);\n            if (idProp == null) {\n                throw new IllegalArgumentException(\"Invalid Object Id definition for \"\n                        +beanDesc.getBeanClass().getName()+\": can not find property with name '\"+propName+\"'\");\n            }\n            idType = idProp.getType();\n            gen = new PropertyBasedObjectIdGenerator(objectIdInfo.getScope());\n        } else {\n            JavaType type = ctxt.constructType(implClass);\n            idType = ctxt.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n            idProp = null;\n            gen = ctxt.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n        }\n        \n        JsonDeserializer<?> deser = ctxt.findRootValueDeserializer(idType);\n        builder.setObjectIdReader(ObjectIdReader.construct(idType,\n                objectIdInfo.getPropertyName(), gen, deser, idProp, resolver));\n    }\n    \n    @SuppressWarnings(\"unchecked\")\n    public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n        final DeserializationConfig config = ctxt.getConfig();\n        \n        BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc);\n        builder.setValueInstantiator(findValueInstantiator(ctxt, beanDesc));\n\n        addBeanProps(ctxt, beanDesc, builder);\n        \n\n        \n        \n        AnnotatedMethod am = beanDesc.findMethod(\"initCause\", INIT_CAUSE_PARAMS);\n        if (am != null) { \n            SimpleBeanPropertyDefinition propDef = SimpleBeanPropertyDefinition.construct(ctxt.getConfig(), am,\n                    new PropertyName(\"cause\"));\n            SettableBeanProperty prop = constructSettableProperty(ctxt, beanDesc, propDef,\n                    am.getParameterType(0));\n            if (prop != null) {\n                \n                builder.addOrReplaceProperty(prop, true);\n            }\n        }\n\n        \n        builder.addIgnorable(\"localizedMessage\");\n        \n        builder.addIgnorable(\"suppressed\");\n        \n        builder.addIgnorable(\"message\");\n\n        \n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                builder = mod.updateBuilder(config, beanDesc, builder);\n            }\n        }\n        JsonDeserializer<?> deserializer = builder.build();\n        \n        \n        if (deserializer instanceof BeanDeserializer) {\n            deserializer = new ThrowableDeserializer((BeanDeserializer) deserializer);\n        }\n\n        \n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                deserializer = mod.modifyDeserializer(config, beanDesc, deserializer);\n            }\n        }\n        return (JsonDeserializer<Object>) deserializer;\n    }\n\n    \n\n    \n    protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc) {\n        return new BeanDeserializerBuilder(beanDesc, ctxt.getConfig());\n    }\n    \n    \n    protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException {\n        final boolean isConcrete = !beanDesc.getType().isAbstract();\n        final SettableBeanProperty[] creatorProps = isConcrete\n                ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig())\n                : null;\n        final boolean hasCreatorProps = (creatorProps != null);\n        \n        \n        \n        \n        \n        JsonIgnoreProperties.Value ignorals = ctxt.getConfig()\n                .getDefaultPropertyIgnorals(beanDesc.getBeanClass(),\n                        beanDesc.getClassInfo());\n        Set<String> ignored;\n\n        if (ignorals != null) {\n            boolean ignoreAny = ignorals.getIgnoreUnknown();\n            builder.setIgnoreUnknownProperties(ignoreAny);\n            \n            ignored = ignorals.getIgnored();\n            for (String propName : ignored) {\n                builder.addIgnorable(propName);\n            }\n        } else {\n            ignored = Collections.emptySet();\n        }\n\n        \n        AnnotatedMethod anySetterMethod = beanDesc.findAnySetter();\n        AnnotatedMember anySetterField = null;\n        if (anySetterMethod != null) {\n            builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterMethod));\n        }\n        else {\n        \tanySetterField = beanDesc.findAnySetterField();\n        \tif(anySetterField != null) {\n        \t\tbuilder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterField));\n        \t}\n        }\n        \n        \n        if (anySetterMethod == null && anySetterField == null) {\n            Collection<String> ignored2 = beanDesc.getIgnoredPropertyNames();\n            if (ignored2 != null) {\n                for (String propName : ignored2) {\n                    \n                    \n                    builder.addIgnorable(propName);\n                }\n            }\n        }\n        final boolean useGettersAsSetters = ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS)\n                && ctxt.isEnabled(MapperFeature.AUTO_DETECT_GETTERS);\n\n        \n        List<BeanPropertyDefinition> propDefs = filterBeanProps(ctxt,\n                beanDesc, builder, beanDesc.findProperties(), ignored);\n\n        \n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                propDefs = mod.updateProperties(ctxt.getConfig(), beanDesc, propDefs);\n            }\n        }\n        \n        \n        for (BeanPropertyDefinition propDef : propDefs) {\n            SettableBeanProperty prop = null;\n            \n            if (propDef.hasSetter()) {\n                JavaType propertyType = propDef.getSetter().getParameterType(0);\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else if (propDef.hasField()) {\n                JavaType propertyType = propDef.getField().getType();\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else if (useGettersAsSetters && propDef.hasGetter()) {\n                \n                AnnotatedMethod getter = propDef.getGetter();\n                \n                Class<?> rawPropertyType = getter.getRawType();\n                if (Collection.class.isAssignableFrom(rawPropertyType)\n                        || Map.class.isAssignableFrom(rawPropertyType)) {\n                    prop = constructSetterlessProperty(ctxt, beanDesc, propDef);\n                }\n            }\n            \n            \n            if (hasCreatorProps && propDef.hasConstructorParameter()) {\n                \n                \n                final String name = propDef.getName();\n                CreatorProperty cprop = null;\n                if (creatorProps != null) {\n                    for (SettableBeanProperty cp : creatorProps) {\n                        if (name.equals(cp.getName()) && (cp instanceof CreatorProperty)) {\n                            cprop = (CreatorProperty) cp;\n                            break;\n                        }\n                    }\n                }\n                if (cprop == null) {\n                    List<String> n = new ArrayList<>();\n                    for (SettableBeanProperty cp : creatorProps) {\n                        n.add(cp.getName());\n                    }\n                    ctxt.reportBadPropertyDefinition(beanDesc, propDef,\n                            \"Could not find creator property with name '%s' (known Creator properties: %s)\",\n                            name, n);\n                    continue;\n                }\n                if (prop != null) {\n                    cprop.setFallbackSetter(prop);\n                }\n                prop = cprop;\n                builder.addCreatorProperty(cprop);\n                continue;\n            }\n\n            if (prop != null) {\n                Class<?>[] views = propDef.findViews();\n                if (views == null) {\n                    \n                    if (!ctxt.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION)) {\n                        views = NO_VIEWS;\n                    }\n                }\n                \n                prop.setViews(views);\n                builder.addProperty(prop);\n            }\n        }\n    }\n    \n    \n    protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException {\n        ArrayList<BeanPropertyDefinition> result = new ArrayList<BeanPropertyDefinition>(\n                Math.max(4, propDefsIn.size()));\n        HashMap<Class<?>,Boolean> ignoredTypes = new HashMap<Class<?>,Boolean>();\n        \n        for (BeanPropertyDefinition property : propDefsIn) {\n            String name = property.getName();\n            if (ignored.contains(name)) { \n                continue;\n            }\n            if (!property.hasConstructorParameter()) { \n                Class<?> rawPropertyType = null;\n                if (property.hasSetter()) {\n                    rawPropertyType = property.getSetter().getRawParameterType(0);\n                } else if (property.hasField()) {\n                    rawPropertyType = property.getField().getRawType();\n                }\n\n                \n                if ((rawPropertyType != null)\n                        && isIgnorableType(ctxt.getConfig(), beanDesc, rawPropertyType, ignoredTypes)) {\n                    \n                    builder.addIgnorable(name);\n                    continue;\n                }\n            }\n            result.add(property);\n        }\n        return result;\n    }\n\n    \n    protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException {\n        \n        Map<String,AnnotatedMember> refs = beanDesc.findBackReferenceProperties();\n        if (refs != null) {\n            for (Map.Entry<String, AnnotatedMember> en : refs.entrySet()) {\n                String name = en.getKey();\n                AnnotatedMember m = en.getValue();\n                JavaType type;\n                if (m instanceof AnnotatedMethod) {\n                    type = ((AnnotatedMethod) m).getParameterType(0);\n                } else {\n                    type = m.getType();\n                    \n                    \n                    if (m instanceof AnnotatedParameter) {\n                        ctxt.reportBadTypeDefinition(beanDesc,\n\"Can not bind back references as Creator parameters: type %s (reference '%s', parameter index #%d)\",\nbeanDesc.getBeanClass().getName(), name, ((AnnotatedParameter) m).getIndex());\n                    }\n                }\n                SimpleBeanPropertyDefinition propDef = SimpleBeanPropertyDefinition.construct(\n                        ctxt.getConfig(), m, PropertyName.construct(name));\n                builder.addBackReferenceProperty(name, constructSettableProperty(ctxt,\n                        beanDesc, propDef, type));\n            }\n        }\n    }\n\n    \n    protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException {\n        Map<Object, AnnotatedMember> raw = beanDesc.findInjectables();\n        if (raw != null) {\n            for (Map.Entry<Object, AnnotatedMember> entry : raw.entrySet()) {\n                AnnotatedMember m = entry.getValue();\n                builder.addInjectable(PropertyName.construct(m.getName()),\n                        m.getType(),\n                        beanDesc.getClassAnnotations(), m, entry.getKey());\n            }\n        }\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMember mutator) throws JsonMappingException {\n        \n        JavaType type = null;\n        if (mutator instanceof AnnotatedMethod) {\n            \n            type = ((AnnotatedMethod) mutator).getParameterType(1);\n        } else if (mutator instanceof AnnotatedField) {\n            \n            type = ((AnnotatedField) mutator).getType().getContentType();\n        }\n        \n        \n        type = resolveMemberAndTypeAnnotations(ctxt, mutator, type);\n        BeanProperty.Std prop = new BeanProperty.Std(PropertyName.construct(mutator.getName()),\n                type, null, beanDesc.getClassAnnotations(), mutator,\n                PropertyMetadata.STD_OPTIONAL);\n        \n        JsonDeserializer<Object> deser = findDeserializerFromAnnotation(ctxt, mutator);\n        if (deser == null) {\n            deser = type.getValueHandler();\n        }\n        if (deser != null) {\n            \n            deser = (JsonDeserializer<Object>) ctxt.handlePrimaryContextualization(deser, prop, type);\n        }\n        TypeDeserializer typeDeser = type.getTypeHandler();\n        return new SettableAnyProperty(prop, mutator, type, deser, typeDeser);\n    }\n\n    \n    protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, JavaType propType0) throws JsonMappingException {\n        \n        AnnotatedMember mutator = propDef.getNonConstructorMutator();\n        \n        \n        \n        if (mutator == null) {\n            ctxt.reportBadPropertyDefinition(beanDesc, propDef, \"No non-constructor mutator available\");\n        }\n        JavaType type = resolveMemberAndTypeAnnotations(ctxt, mutator, propType0);\n        \n        TypeDeserializer typeDeser = type.getTypeHandler();\n        SettableBeanProperty prop;\n        if (mutator instanceof AnnotatedMethod) {\n            prop = new MethodProperty(propDef, type, typeDeser,\n                    beanDesc.getClassAnnotations(), (AnnotatedMethod) mutator);\n        } else {\n            \n            prop = new FieldProperty(propDef, type, typeDeser,\n                    beanDesc.getClassAnnotations(), (AnnotatedField) mutator);\n        }\n        JsonDeserializer<?> deser = findDeserializerFromAnnotation(ctxt, mutator);\n        if (deser == null) {\n            deser = type.getValueHandler();\n        }\n        if (deser != null) {\n            deser = ctxt.handlePrimaryContextualization(deser, prop, type);\n            prop = prop.withValueDeserializer(deser);\n        }\n        \n        AnnotationIntrospector.ReferenceProperty ref = propDef.findReferenceType();\n        if (ref != null && ref.isManagedReference()) {\n            prop.setManagedReferenceName(ref.getName());\n        }\n        ObjectIdInfo objectIdInfo = propDef.findObjectIdInfo();\n        if (objectIdInfo != null){\n            prop.setObjectIdInfo(objectIdInfo);\n        }\n        return prop;\n    }\n\n    \n    protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException {\n        final AnnotatedMethod getter = propDef.getGetter();\n        JavaType type = resolveMemberAndTypeAnnotations(ctxt, getter, getter.getType());\n        TypeDeserializer typeDeser = type.getTypeHandler();\n        SettableBeanProperty prop = new SetterlessProperty(propDef, type, typeDeser,\n                beanDesc.getClassAnnotations(), getter);\n        JsonDeserializer<?> deser = findDeserializerFromAnnotation(ctxt, getter);\n        if (deser == null) {\n            deser = type.getValueHandler();\n        }\n        if (deser != null) {\n            deser = ctxt.handlePrimaryContextualization(deser, prop, type);\n            prop = prop.withValueDeserializer(deser);\n        }\n        return prop;\n    }\n\n    \n\n    \n    protected boolean isPotentialBeanType(Class<?> type) {\n        String typeStr = ClassUtil.canBeABeanType(type);\n        if (typeStr != null) {\n            throw new IllegalArgumentException(\"Can not deserialize Class \"+type.getName()+\" (of type \"+typeStr+\") as a Bean\");\n        }\n        if (ClassUtil.isProxyType(type)) {\n            throw new IllegalArgumentException(\"Can not deserialize Proxy class \"+type.getName()+\" as a Bean\");\n        }\n        \n        typeStr = ClassUtil.isLocalType(type, true);\n        if (typeStr != null) {\n            throw new IllegalArgumentException(\"Can not deserialize Class \"+type.getName()+\" (of type \"+typeStr+\") as a Bean\");\n        }\n        return true;\n    }\n\n    \n    protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>,Boolean> ignoredTypes) {\n        Boolean status = ignoredTypes.get(type);\n        if (status != null) {\n            return status.booleanValue();\n        }\n        \n        ConfigOverride override = config.findConfigOverride(type);\n        if (override != null) {\n            status = override.getIsIgnoredType();\n        }\n        if (status == null) {\n            BeanDescription desc = config.introspectClassAnnotations(type);\n            status = config.getAnnotationIntrospector().isIgnorableType(desc.getClassInfo());\n            \n            if (status == null) {\n                status = Boolean.FALSE;\n            }\n        }\n        ignoredTypes.put(type, status);\n        return status.booleanValue();\n    }\n\n    \n        \n        \n\n}\n",
      "fixed_full_code": "package com.fasterxml.jackson.databind.deser;\n\nimport java.util.*;\n\nimport com.fasterxml.jackson.annotation.*;\n\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.annotation.JsonPOJOBuilder;\nimport com.fasterxml.jackson.databind.cfg.DeserializerFactoryConfig;\nimport com.fasterxml.jackson.databind.cfg.ConfigOverride;\nimport com.fasterxml.jackson.databind.deser.impl.*;\nimport com.fasterxml.jackson.databind.deser.std.ThrowableDeserializer;\nimport com.fasterxml.jackson.databind.introspect.*;\nimport com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\nimport com.fasterxml.jackson.databind.util.SimpleBeanPropertyDefinition;\n\n\npublic class BeanDeserializerFactory extends BasicDeserializerFactory implements java.io.Serializable { private static final long serialVersionUID = 1; private final static Class<?>[] INIT_CAUSE_PARAMS = new Class<?>[] { Throwable.class }; private final static Class<?>[] NO_VIEWS = new Class<?>[0]; protected final static Set<String> DEFAULT_NO_DESER_CLASS_NAMES; static { Set<String> s = new HashSet<>(); s.add(\"org.apache.commons.collections.functors.InvokerTransformer\"); s.add(\"org.apache.commons.collections.functors.InstantiateTransformer\"); s.add(\"org.apache.commons.collections4.functors.InvokerTransformer\"); s.add(\"org.apache.commons.collections4.functors.InstantiateTransformer\"); s.add(\"org.codehaus.groovy.runtime.ConvertedClosure\"); s.add(\"org.codehaus.groovy.runtime.MethodClosure\"); s.add(\"org.springframework.beans.factory.ObjectFactory\"); s.add(\"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\"); DEFAULT_NO_DESER_CLASS_NAMES = Collections.unmodifiableSet(s); } protected Set<String> _cfgIllegalClassNames = DEFAULT_NO_DESER_CLASS_NAMES; public final static BeanDeserializerFactory instance = new BeanDeserializerFactory( new DeserializerFactoryConfig()); public BeanDeserializerFactory(DeserializerFactoryConfig config) {\n        super(config);\n    }\n    \n    \n    @Override\n    public DeserializerFactory withConfig(DeserializerFactoryConfig config) {\n        if (_factoryConfig == config) {\n            return this;\n        }\n        \n        if (getClass() != BeanDeserializerFactory.class) {\n            throw new IllegalStateException(\"Subtype of BeanDeserializerFactory (\"+getClass().getName()\n                    +\") has not properly overridden method 'withAdditionalDeserializers': can not instantiate subtype with \"\n                    +\"additional deserializer definitions\");\n        }\n        return new BeanDeserializerFactory(config);\n    }\n    \n    \n\n    \n    @Override\n    public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n        final DeserializationConfig config = ctxt.getConfig();\n        \n        JsonDeserializer<Object> custom = _findCustomBeanDeserializer(type, config, beanDesc);\n        if (custom != null) {\n            return custom;\n        }\n        \n        if (type.isThrowable()) {\n            return buildThrowableDeserializer(ctxt, type, beanDesc);\n        }\n        \n        \n        \n        if (type.isAbstract() && !type.isPrimitive() && !type.isEnumType()) {\n            \n            JavaType concreteType = materializeAbstractType(ctxt, type, beanDesc);\n            if (concreteType != null) {\n                \n                beanDesc = config.introspect(concreteType);\n                return buildBeanDeserializer(ctxt, concreteType, beanDesc);\n            }\n        }\n        \n        @SuppressWarnings(\"unchecked\")\n        JsonDeserializer<Object> deser = (JsonDeserializer<Object>) findStdDeserializer(ctxt, type, beanDesc);\n        if (deser != null) {\n            return deser;\n        }\n\n        \n        if (!isPotentialBeanType(type.getRawClass())) {\n            return null;\n        }\n        \n        checkIllegalTypes(ctxt, type, beanDesc);\n        \n        return buildBeanDeserializer(ctxt, type, beanDesc);\n    }\n\n    @Override\n    public JsonDeserializer<Object> createBuilderBasedDeserializer( DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException {\n        \n        JavaType builderType = ctxt.constructType(builderClass);\n        BeanDescription builderDesc = ctxt.getConfig().introspectForBuilder(builderType);\n        return buildBuilderBasedDeserializer(ctxt, valueType, builderDesc);\n    }\n    \n    \n    protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n        \n        \n        JsonDeserializer<?> deser = findDefaultDeserializer(ctxt, type, beanDesc);\n        \n        if (deser != null) {\n            if (_factoryConfig.hasDeserializerModifiers()) {\n                for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                    deser = mod.modifyDeserializer(ctxt.getConfig(), beanDesc, deser);\n                }\n            }\n        }\n        return deser;\n    }\n    \n    protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n        \n        for (AbstractTypeResolver r : _factoryConfig.abstractTypeResolvers()) {\n            JavaType concrete = r.resolveAbstractType(ctxt.getConfig(), beanDesc);\n            if (concrete != null) {\n                return concrete;\n            }\n        }\n        return null;\n    }\n\n    \n\n    \n    @SuppressWarnings(\"unchecked\")\n    public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n        \n        ValueInstantiator valueInstantiator;\n        \n        try {\n            valueInstantiator = findValueInstantiator(ctxt, beanDesc);\n        } catch (NoClassDefFoundError error) {\n            return new ErrorThrowingDeserializer(error);\n        }\n        BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc);\n        builder.setValueInstantiator(valueInstantiator);\n         \n        addBeanProps(ctxt, beanDesc, builder);\n        addObjectIdReader(ctxt, beanDesc, builder);\n\n        \n        addReferenceProperties(ctxt, beanDesc, builder);\n        addInjectables(ctxt, beanDesc, builder);\n        \n        final DeserializationConfig config = ctxt.getConfig();\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                builder = mod.updateBuilder(config, beanDesc, builder);\n            }\n        }\n        JsonDeserializer<?> deserializer;\n\n        \n        if (type.isAbstract() && !valueInstantiator.canInstantiate()) {\n            deserializer = builder.buildAbstract();\n        } else {\n            deserializer = builder.build();\n        }\n\n        \n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                deserializer = mod.modifyDeserializer(config, beanDesc, deserializer);\n            }\n        }\n        return (JsonDeserializer<Object>) deserializer;\n    }\n    \n    \n    @SuppressWarnings(\"unchecked\")\n    protected JsonDeserializer<Object> buildBuilderBasedDeserializer( DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException {\n    \t\n        ValueInstantiator valueInstantiator = findValueInstantiator(ctxt, builderDesc);\n        final DeserializationConfig config = ctxt.getConfig();\n        BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, builderDesc);\n        builder.setValueInstantiator(valueInstantiator);\n         \n        addBeanProps(ctxt, builderDesc, builder);\n        addObjectIdReader(ctxt, builderDesc, builder);\n        \n        \n        addReferenceProperties(ctxt, builderDesc, builder);\n        addInjectables(ctxt, builderDesc, builder);\n\n        JsonPOJOBuilder.Value builderConfig = builderDesc.findPOJOBuilderConfig();\n        final String buildMethodName = (builderConfig == null) ?\n                \"build\" : builderConfig.buildMethodName;\n        \n        \n        AnnotatedMethod buildMethod = builderDesc.findMethod(buildMethodName, null);\n        if (buildMethod != null) { \n            if (config.canOverrideAccessModifiers()) {\n            \tClassUtil.checkAndFixAccess(buildMethod.getMember(), config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n            }\n        }\n        builder.setPOJOBuilder(buildMethod, builderConfig);\n        \n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                builder = mod.updateBuilder(config, builderDesc, builder);\n            }\n        }\n        JsonDeserializer<?> deserializer = builder.buildBuilderBased(\n        \t\tvalueType, buildMethodName);\n\n        \n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                deserializer = mod.modifyDeserializer(config, builderDesc, deserializer);\n            }\n        }\n        return (JsonDeserializer<Object>) deserializer;\n    }\n    \n    protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException {\n        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n        if (objectIdInfo == null) {\n            return;\n        }\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n        JavaType idType;\n        SettableBeanProperty idProp;\n        ObjectIdGenerator<?> gen;\n\n        ObjectIdResolver resolver = ctxt.objectIdResolverInstance(beanDesc.getClassInfo(), objectIdInfo);\n\n        \n        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { \n            PropertyName propName = objectIdInfo.getPropertyName();\n            idProp = builder.findProperty(propName);\n            if (idProp == null) {\n                throw new IllegalArgumentException(\"Invalid Object Id definition for \"\n                        +beanDesc.getBeanClass().getName()+\": can not find property with name '\"+propName+\"'\");\n            }\n            idType = idProp.getType();\n            gen = new PropertyBasedObjectIdGenerator(objectIdInfo.getScope());\n        } else {\n            JavaType type = ctxt.constructType(implClass);\n            idType = ctxt.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n            idProp = null;\n            gen = ctxt.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n        }\n        \n        JsonDeserializer<?> deser = ctxt.findRootValueDeserializer(idType);\n        builder.setObjectIdReader(ObjectIdReader.construct(idType,\n                objectIdInfo.getPropertyName(), gen, deser, idProp, resolver));\n    }\n    \n    @SuppressWarnings(\"unchecked\")\n    public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n        final DeserializationConfig config = ctxt.getConfig();\n        \n        BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc);\n        builder.setValueInstantiator(findValueInstantiator(ctxt, beanDesc));\n\n        addBeanProps(ctxt, beanDesc, builder);\n        \n\n        \n        \n        AnnotatedMethod am = beanDesc.findMethod(\"initCause\", INIT_CAUSE_PARAMS);\n        if (am != null) { \n            SimpleBeanPropertyDefinition propDef = SimpleBeanPropertyDefinition.construct(ctxt.getConfig(), am,\n                    new PropertyName(\"cause\"));\n            SettableBeanProperty prop = constructSettableProperty(ctxt, beanDesc, propDef,\n                    am.getParameterType(0));\n            if (prop != null) {\n                \n                builder.addOrReplaceProperty(prop, true);\n            }\n        }\n\n        \n        builder.addIgnorable(\"localizedMessage\");\n        \n        builder.addIgnorable(\"suppressed\");\n        \n        builder.addIgnorable(\"message\");\n\n        \n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                builder = mod.updateBuilder(config, beanDesc, builder);\n            }\n        }\n        JsonDeserializer<?> deserializer = builder.build();\n        \n        \n        if (deserializer instanceof BeanDeserializer) {\n            deserializer = new ThrowableDeserializer((BeanDeserializer) deserializer);\n        }\n\n        \n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                deserializer = mod.modifyDeserializer(config, beanDesc, deserializer);\n            }\n        }\n        return (JsonDeserializer<Object>) deserializer;\n    }\n\n    \n\n    \n    protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc) {\n        return new BeanDeserializerBuilder(beanDesc, ctxt.getConfig());\n    }\n    \n    \n    protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException {\n        final boolean isConcrete = !beanDesc.getType().isAbstract();\n        final SettableBeanProperty[] creatorProps = isConcrete\n                ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig())\n                : null;\n        final boolean hasCreatorProps = (creatorProps != null);\n        \n        \n        \n        \n        \n        JsonIgnoreProperties.Value ignorals = ctxt.getConfig()\n                .getDefaultPropertyIgnorals(beanDesc.getBeanClass(),\n                        beanDesc.getClassInfo());\n        Set<String> ignored;\n\n        if (ignorals != null) {\n            boolean ignoreAny = ignorals.getIgnoreUnknown();\n            builder.setIgnoreUnknownProperties(ignoreAny);\n            \n            ignored = ignorals.getIgnored();\n            for (String propName : ignored) {\n                builder.addIgnorable(propName);\n            }\n        } else {\n            ignored = Collections.emptySet();\n        }\n\n        \n        AnnotatedMethod anySetterMethod = beanDesc.findAnySetter();\n        AnnotatedMember anySetterField = null;\n        if (anySetterMethod != null) {\n            builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterMethod));\n        }\n        else {\n        \tanySetterField = beanDesc.findAnySetterField();\n        \tif(anySetterField != null) {\n        \t\tbuilder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterField));\n        \t}\n        }\n        \n        \n        if (anySetterMethod == null && anySetterField == null) {\n            Collection<String> ignored2 = beanDesc.getIgnoredPropertyNames();\n            if (ignored2 != null) {\n                for (String propName : ignored2) {\n                    \n                    \n                    builder.addIgnorable(propName);\n                }\n            }\n        }\n        final boolean useGettersAsSetters = ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS)\n                && ctxt.isEnabled(MapperFeature.AUTO_DETECT_GETTERS);\n\n        \n        List<BeanPropertyDefinition> propDefs = filterBeanProps(ctxt,\n                beanDesc, builder, beanDesc.findProperties(), ignored);\n\n        \n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                propDefs = mod.updateProperties(ctxt.getConfig(), beanDesc, propDefs);\n            }\n        }\n        \n        \n        for (BeanPropertyDefinition propDef : propDefs) {\n            SettableBeanProperty prop = null;\n            \n            if (propDef.hasSetter()) {\n                JavaType propertyType = propDef.getSetter().getParameterType(0);\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else if (propDef.hasField()) {\n                JavaType propertyType = propDef.getField().getType();\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else if (useGettersAsSetters && propDef.hasGetter()) {\n                \n                AnnotatedMethod getter = propDef.getGetter();\n                \n                Class<?> rawPropertyType = getter.getRawType();\n                if (Collection.class.isAssignableFrom(rawPropertyType)\n                        || Map.class.isAssignableFrom(rawPropertyType)) {\n                    prop = constructSetterlessProperty(ctxt, beanDesc, propDef);\n                }\n            }\n            \n            \n            if (hasCreatorProps && propDef.hasConstructorParameter()) {\n                \n                \n                final String name = propDef.getName();\n                CreatorProperty cprop = null;\n                if (creatorProps != null) {\n                    for (SettableBeanProperty cp : creatorProps) {\n                        if (name.equals(cp.getName()) && (cp instanceof CreatorProperty)) {\n                            cprop = (CreatorProperty) cp;\n                            break;\n                        }\n                    }\n                }\n                if (cprop == null) {\n                    List<String> n = new ArrayList<>();\n                    for (SettableBeanProperty cp : creatorProps) {\n                        n.add(cp.getName());\n                    }\n                    ctxt.reportBadPropertyDefinition(beanDesc, propDef,\n                            \"Could not find creator property with name '%s' (known Creator properties: %s)\",\n                            name, n);\n                    continue;\n                }\n                if (prop != null) {\n                    cprop.setFallbackSetter(prop);\n                }\n                prop = cprop;\n                builder.addCreatorProperty(cprop);\n                continue;\n            }\n\n            if (prop != null) {\n                Class<?>[] views = propDef.findViews();\n                if (views == null) {\n                    \n                    if (!ctxt.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION)) {\n                        views = NO_VIEWS;\n                    }\n                }\n                \n                prop.setViews(views);\n                builder.addProperty(prop);\n            }\n        }\n    }\n    \n    \n    protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException {\n        ArrayList<BeanPropertyDefinition> result = new ArrayList<BeanPropertyDefinition>(\n                Math.max(4, propDefsIn.size()));\n        HashMap<Class<?>,Boolean> ignoredTypes = new HashMap<Class<?>,Boolean>();\n        \n        for (BeanPropertyDefinition property : propDefsIn) {\n            String name = property.getName();\n            if (ignored.contains(name)) { \n                continue;\n            }\n            if (!property.hasConstructorParameter()) { \n                Class<?> rawPropertyType = null;\n                if (property.hasSetter()) {\n                    rawPropertyType = property.getSetter().getRawParameterType(0);\n                } else if (property.hasField()) {\n                    rawPropertyType = property.getField().getRawType();\n                }\n\n                \n                if ((rawPropertyType != null)\n                        && isIgnorableType(ctxt.getConfig(), beanDesc, rawPropertyType, ignoredTypes)) {\n                    \n                    builder.addIgnorable(name);\n                    continue;\n                }\n            }\n            result.add(property);\n        }\n        return result;\n    }\n\n    \n    protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException {\n        \n        Map<String,AnnotatedMember> refs = beanDesc.findBackReferenceProperties();\n        if (refs != null) {\n            for (Map.Entry<String, AnnotatedMember> en : refs.entrySet()) {\n                String name = en.getKey();\n                AnnotatedMember m = en.getValue();\n                JavaType type;\n                if (m instanceof AnnotatedMethod) {\n                    type = ((AnnotatedMethod) m).getParameterType(0);\n                } else {\n                    type = m.getType();\n                    \n                    \n                    if (m instanceof AnnotatedParameter) {\n                        ctxt.reportBadTypeDefinition(beanDesc,\n\"Can not bind back references as Creator parameters: type %s (reference '%s', parameter index #%d)\",\nbeanDesc.getBeanClass().getName(), name, ((AnnotatedParameter) m).getIndex());\n                    }\n                }\n                SimpleBeanPropertyDefinition propDef = SimpleBeanPropertyDefinition.construct(\n                        ctxt.getConfig(), m, PropertyName.construct(name));\n                builder.addBackReferenceProperty(name, constructSettableProperty(ctxt,\n                        beanDesc, propDef, type));\n            }\n        }\n    }\n\n    \n    protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException {\n        Map<Object, AnnotatedMember> raw = beanDesc.findInjectables();\n        if (raw != null) {\n            for (Map.Entry<Object, AnnotatedMember> entry : raw.entrySet()) {\n                AnnotatedMember m = entry.getValue();\n                builder.addInjectable(PropertyName.construct(m.getName()),\n                        m.getType(),\n                        beanDesc.getClassAnnotations(), m, entry.getKey());\n            }\n        }\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMember mutator) throws JsonMappingException {\n        \n        JavaType type = null;\n        if (mutator instanceof AnnotatedMethod) {\n            \n            type = ((AnnotatedMethod) mutator).getParameterType(1);\n        } else if (mutator instanceof AnnotatedField) {\n            \n            type = ((AnnotatedField) mutator).getType().getContentType();\n        }\n        \n        \n        type = resolveMemberAndTypeAnnotations(ctxt, mutator, type);\n        BeanProperty.Std prop = new BeanProperty.Std(PropertyName.construct(mutator.getName()),\n                type, null, beanDesc.getClassAnnotations(), mutator,\n                PropertyMetadata.STD_OPTIONAL);\n        \n        JsonDeserializer<Object> deser = findDeserializerFromAnnotation(ctxt, mutator);\n        if (deser == null) {\n            deser = type.getValueHandler();\n        }\n        if (deser != null) {\n            \n            deser = (JsonDeserializer<Object>) ctxt.handlePrimaryContextualization(deser, prop, type);\n        }\n        TypeDeserializer typeDeser = type.getTypeHandler();\n        return new SettableAnyProperty(prop, mutator, type, deser, typeDeser);\n    }\n\n    \n    protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, JavaType propType0) throws JsonMappingException {\n        \n        AnnotatedMember mutator = propDef.getNonConstructorMutator();\n        \n        \n        \n        if (mutator == null) {\n            ctxt.reportBadPropertyDefinition(beanDesc, propDef, \"No non-constructor mutator available\");\n        }\n        JavaType type = resolveMemberAndTypeAnnotations(ctxt, mutator, propType0);\n        \n        TypeDeserializer typeDeser = type.getTypeHandler();\n        SettableBeanProperty prop;\n        if (mutator instanceof AnnotatedMethod) {\n            prop = new MethodProperty(propDef, type, typeDeser,\n                    beanDesc.getClassAnnotations(), (AnnotatedMethod) mutator);\n        } else {\n            \n            prop = new FieldProperty(propDef, type, typeDeser,\n                    beanDesc.getClassAnnotations(), (AnnotatedField) mutator);\n        }\n        JsonDeserializer<?> deser = findDeserializerFromAnnotation(ctxt, mutator);\n        if (deser == null) {\n            deser = type.getValueHandler();\n        }\n        if (deser != null) {\n            deser = ctxt.handlePrimaryContextualization(deser, prop, type);\n            prop = prop.withValueDeserializer(deser);\n        }\n        \n        AnnotationIntrospector.ReferenceProperty ref = propDef.findReferenceType();\n        if (ref != null && ref.isManagedReference()) {\n            prop.setManagedReferenceName(ref.getName());\n        }\n        ObjectIdInfo objectIdInfo = propDef.findObjectIdInfo();\n        if (objectIdInfo != null){\n            prop.setObjectIdInfo(objectIdInfo);\n        }\n        return prop;\n    }\n\n    \n    protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException {\n        final AnnotatedMethod getter = propDef.getGetter();\n        JavaType type = resolveMemberAndTypeAnnotations(ctxt, getter, getter.getType());\n        TypeDeserializer typeDeser = type.getTypeHandler();\n        SettableBeanProperty prop = new SetterlessProperty(propDef, type, typeDeser,\n                beanDesc.getClassAnnotations(), getter);\n        JsonDeserializer<?> deser = findDeserializerFromAnnotation(ctxt, getter);\n        if (deser == null) {\n            deser = type.getValueHandler();\n        }\n        if (deser != null) {\n            deser = ctxt.handlePrimaryContextualization(deser, prop, type);\n            prop = prop.withValueDeserializer(deser);\n        }\n        return prop;\n    }\n\n    \n\n    \n    protected boolean isPotentialBeanType(Class<?> type) {\n        String typeStr = ClassUtil.canBeABeanType(type);\n        if (typeStr != null) {\n            throw new IllegalArgumentException(\"Can not deserialize Class \"+type.getName()+\" (of type \"+typeStr+\") as a Bean\");\n        }\n        if (ClassUtil.isProxyType(type)) {\n            throw new IllegalArgumentException(\"Can not deserialize Proxy class \"+type.getName()+\" as a Bean\");\n        }\n        \n        typeStr = ClassUtil.isLocalType(type, true);\n        if (typeStr != null) {\n            throw new IllegalArgumentException(\"Can not deserialize Class \"+type.getName()+\" (of type \"+typeStr+\") as a Bean\");\n        }\n        return true;\n    }\n\n    \n    protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>,Boolean> ignoredTypes) {\n        Boolean status = ignoredTypes.get(type);\n        if (status != null) {\n            return status.booleanValue();\n        }\n        \n        ConfigOverride override = config.findConfigOverride(type);\n        if (override != null) {\n            status = override.getIsIgnoredType();\n        }\n        if (status == null) {\n            BeanDescription desc = config.introspectClassAnnotations(type);\n            status = config.getAnnotationIntrospector().isIgnorableType(desc.getClassInfo());\n            \n            if (status == null) {\n                status = Boolean.FALSE;\n            }\n        }\n        ignoredTypes.put(type, status);\n        return status.booleanValue();\n    }\n\n    \n    protected void checkIllegalTypes(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n        \n        \n        String full = type.getRawClass().getName();\n\n        if (_cfgIllegalClassNames.contains(full)) {\n            ctxt.reportBadTypeDefinition(beanDesc,\n                    \"Illegal type (%s) to deserialize: prevented for security reasons\", full);\n        }\n    }\n}\n",
      "buggy_signatures": [
        "public DeserializerFactory withConfig(DeserializerFactoryConfig config)",
        "public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException",
        "public JsonDeserializer<Object> createBuilderBasedDeserializer( DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException",
        "protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException",
        "protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException",
        "public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException",
        "protected JsonDeserializer<Object> buildBuilderBasedDeserializer( DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException",
        "protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException",
        "public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException",
        "protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc)",
        "protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException",
        "protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException",
        "protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException",
        "protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException",
        "protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMember mutator) throws JsonMappingException",
        "protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, JavaType propType0) throws JsonMappingException",
        "protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException",
        "protected boolean isPotentialBeanType(Class<?> type)",
        "protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>,Boolean> ignoredTypes)"
      ],
      "fixed_signatures": [
        "public DeserializerFactory withConfig(DeserializerFactoryConfig config)",
        "public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException",
        "public JsonDeserializer<Object> createBuilderBasedDeserializer( DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException",
        "protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException",
        "protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException",
        "public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException",
        "protected JsonDeserializer<Object> buildBuilderBasedDeserializer( DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException",
        "protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException",
        "public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException",
        "protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc)",
        "protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException",
        "protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException",
        "protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException",
        "protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException",
        "protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMember mutator) throws JsonMappingException",
        "protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, JavaType propType0) throws JsonMappingException",
        "protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException",
        "protected boolean isPotentialBeanType(Class<?> type)",
        "protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>,Boolean> ignoredTypes)",
        "protected void checkIllegalTypes(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException"
      ],
      "methods": [
        {
          "buggy_method": "",
          "fixed_method": "",
          "diff": [
            "@@ -45,14 +45,28 @@",
            "      *\n",
            "      * @since 2.8.9\n",
            "      */\n",
            "+    protected final static Set<String> DEFAULT_NO_DESER_CLASS_NAMES;\n",
            "+    static {\n",
            "+        Set<String> s = new HashSet<>();\n",
            "         // Courtesy of [https://github.com/kantega/notsoserial]:\n",
            "         // (and wrt [databind#1599]\n",
            "+        s.add(\"org.apache.commons.collections.functors.InvokerTransformer\");\n",
            "+        s.add(\"org.apache.commons.collections.functors.InstantiateTransformer\");\n",
            "+        s.add(\"org.apache.commons.collections4.functors.InvokerTransformer\");\n",
            "+        s.add(\"org.apache.commons.collections4.functors.InstantiateTransformer\");\n",
            "+        s.add(\"org.codehaus.groovy.runtime.ConvertedClosure\");\n",
            "+        s.add(\"org.codehaus.groovy.runtime.MethodClosure\");\n",
            "+        s.add(\"org.springframework.beans.factory.ObjectFactory\");\n",
            "+        s.add(\"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\");\n",
            "+        DEFAULT_NO_DESER_CLASS_NAMES = Collections.unmodifiableSet(s);\n",
            "+    }\n",
            " \n",
            "     /**\n",
            "      * Set of class names of types that are never to be deserialized.\n",
            "      *\n",
            "      * @since 2.8.9\n",
            "      */\n",
            "+    protected Set<String> _cfgIllegalClassNames = DEFAULT_NO_DESER_CLASS_NAMES;\n",
            " \n",
            "     /*\n",
            "     /**********************************************************\n"
          ],
          "changed_lines": 14
        },
        {
          "buggy_method": "  public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n  final DeserializationConfig config = ctxt.getConfig();\n  \n  JsonDeserializer<Object> custom = _findCustomBeanDeserializer(type, config, beanDesc);\n  if (custom != null) {\n  return custom;\n  }\n  \n  if (type.isThrowable()) {\n  return buildThrowableDeserializer(ctxt, type, beanDesc);\n  }\n  \n  \n  \n  if (type.isAbstract() && !type.isPrimitive() && !type.isEnumType()) {\n  \n  JavaType concreteType = materializeAbstractType(ctxt, type, beanDesc);\n  if (concreteType != null) {\n  \n  beanDesc = config.introspect(concreteType);\n  return buildBeanDeserializer(ctxt, concreteType, beanDesc);\n  }\n  }\n  \n  @SuppressWarnings(\"unchecked\")\n  JsonDeserializer<Object> deser = (JsonDeserializer<Object>) findStdDeserializer(ctxt, type, beanDesc);\n  if (deser != null) {\n  return deser;\n  }\n\n  \n  if (!isPotentialBeanType(type.getRawClass())) {\n  return null;\n  }\n  \n  \n  return buildBeanDeserializer(ctxt, type, beanDesc);\n  }",
          "fixed_method": "  public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n  final DeserializationConfig config = ctxt.getConfig();\n  \n  JsonDeserializer<Object> custom = _findCustomBeanDeserializer(type, config, beanDesc);\n  if (custom != null) {\n  return custom;\n  }\n  \n  if (type.isThrowable()) {\n  return buildThrowableDeserializer(ctxt, type, beanDesc);\n  }\n  \n  \n  \n  if (type.isAbstract() && !type.isPrimitive() && !type.isEnumType()) {\n  \n  JavaType concreteType = materializeAbstractType(ctxt, type, beanDesc);\n  if (concreteType != null) {\n  \n  beanDesc = config.introspect(concreteType);\n  return buildBeanDeserializer(ctxt, concreteType, beanDesc);\n  }\n  }\n  \n  @SuppressWarnings(\"unchecked\")\n  JsonDeserializer<Object> deser = (JsonDeserializer<Object>) findStdDeserializer(ctxt, type, beanDesc);\n  if (deser != null) {\n  return deser;\n  }\n\n  \n  if (!isPotentialBeanType(type.getRawClass())) {\n  return null;\n  }\n  \n  checkIllegalTypes(ctxt, type, beanDesc);\n  \n  return buildBeanDeserializer(ctxt, type, beanDesc);\n  }",
          "diff": [
            "@@ -153,6 +167,7 @@",
            "             return null;\n",
            "         }\n",
            "         // For checks like [databind#1599]\n",
            "+        checkIllegalTypes(ctxt, type, beanDesc);\n",
            "         // Use generic bean introspection to build deserializer\n",
            "         return buildBeanDeserializer(ctxt, type, beanDesc);\n",
            "     }\n"
          ],
          "changed_lines": 1
        },
        {
          "buggy_method": "  protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>,Boolean> ignoredTypes) {\n  Boolean status = ignoredTypes.get(type);\n  if (status != null) {\n  return status.booleanValue();\n  }\n  \n  ConfigOverride override = config.findConfigOverride(type);\n  if (override != null) {\n  status = override.getIsIgnoredType();\n  }\n  if (status == null) {\n  BeanDescription desc = config.introspectClassAnnotations(type);\n  status = config.getAnnotationIntrospector().isIgnorableType(desc.getClassInfo());\n  \n  if (status == null) {\n  status = Boolean.FALSE;\n  }\n  }\n  ignoredTypes.put(type, status);\n  return status.booleanValue();\n  }",
          "fixed_method": "  protected void checkIllegalTypes(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n  \n  \n  String full = type.getRawClass().getName();\n\n  if (_cfgIllegalClassNames.contains(full)) {\n  ctxt.reportBadTypeDefinition(beanDesc,\n  \"Illegal type (%s) to deserialize: prevented for security reasons\", full);\n  }\n  }",
          "diff": [
            "@@ -875,7 +890,17 @@",
            "     /**\n",
            "      * @since 2.8.9\n",
            "      */\n",
            "+    protected void checkIllegalTypes(DeserializationContext ctxt, JavaType type,\n",
            "+            BeanDescription beanDesc)\n",
            "+        throws JsonMappingException\n",
            "+    {\n",
            "         // There are certain nasty classes that could cause problems, mostly\n",
            "         // via default typing -- catch them here.\n",
            "-\n",
            "+        String full = type.getRawClass().getName();\n",
            "+\n",
            "+        if (_cfgIllegalClassNames.contains(full)) {\n",
            "+            ctxt.reportBadTypeDefinition(beanDesc,\n",
            "+                    \"Illegal type (%s) to deserialize: prevented for security reasons\", full);\n",
            "+        }\n",
            "+    }\n",
            " }\n"
          ],
          "changed_lines": 12
        }
      ]
    }
  ]
}
