{
  "bug_id": "37",
  "failed_tests": {
    "org.apache.commons.cli.bug.BugCLI265Test": [
      {
        "methodName": "shouldParseShortOptionWithoutValue",
        "error": "junit.framework.AssertionFailedError",
        "message": "Second option has been used as value for first option. Actual: -last",
        "fail_line": "        assertNotEquals(\"Second option has been used as value for first option\", \"-last\", commandLine.getOptionValue(\"t1\"));",
        "test_source": "  public void shouldParseShortOptionWithoutValue() throws Exception {\n  String[] twoShortOptions = new String[]{\"-t1\", \"-last\"};\n\n  final CommandLine commandLine = parser.parse(options, twoShortOptions);\n\n  assertTrue(commandLine.hasOption(\"t1\"));\n  assertNotEquals(\"Second option has been used as value for first option\", \"-last\", commandLine.getOptionValue(\"t1\"));\n  assertTrue(\"Second option has not been detected\", commandLine.hasOption(\"last\"));\n  }",
        "stack": [
          "BugCLI265Test.shouldParseShortOptionWithoutValue line 52"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/cli/DefaultParser.java",
      "buggy_full_code": "\n\npackage org.apache.commons.cli;\n\nimport java.util.ArrayList;\nimport java.util.Enumeration;\nimport java.util.List;\nimport java.util.Properties;\n\n\npublic class DefaultParser implements CommandLineParser { protected CommandLine cmd; protected Options options; protected boolean stopAtNonOption; protected String currentToken; protected Option currentOption; protected boolean skipParsing; protected List expectedOpts; public CommandLine parse(Options options, String[] arguments) throws ParseException {\n        return parse(options, arguments, null);\n    }\n\n    \n    public CommandLine parse(Options options, String[] arguments, Properties properties) throws ParseException {\n        return parse(options, arguments, properties, false);\n    }\n\n    public CommandLine parse(Options options, String[] arguments, boolean stopAtNonOption) throws ParseException {\n        return parse(options, arguments, null, stopAtNonOption);\n    }\n\n    \n    public CommandLine parse(Options options, String[] arguments, Properties properties, boolean stopAtNonOption) throws ParseException {\n        this.options = options;\n        this.stopAtNonOption = stopAtNonOption;\n        skipParsing = false;\n        currentOption = null;\n        expectedOpts = new ArrayList(options.getRequiredOptions());\n\n        \n        for (OptionGroup group : options.getOptionGroups())\n        {\n            group.setSelected(null);\n        }\n\n        cmd = new CommandLine();\n\n        if (arguments != null)\n        {\n            for (String argument : arguments)\n            {\n                handleToken(argument);\n            }\n        }\n\n        \n        checkRequiredArgs();\n\n        \n        handleProperties(properties);\n\n        checkRequiredOptions();\n\n        return cmd;\n    }\n\n    \n    private void handleProperties(Properties properties) throws ParseException {\n        if (properties == null)\n        {\n            return;\n        }\n\n        for (Enumeration<?> e = properties.propertyNames(); e.hasMoreElements();)\n        {\n            String option = e.nextElement().toString();\n\n            Option opt = options.getOption(option);\n            if (opt == null)\n            {\n                throw new UnrecognizedOptionException(\"Default option wasn't defined\", option);\n            }\n\n            \n            OptionGroup group = options.getOptionGroup(opt);\n            boolean selected = group != null && group.getSelected() != null;\n\n            if (!cmd.hasOption(option) && !selected)\n            {\n                \n                String value = properties.getProperty(option);\n\n                if (opt.hasArg())\n                {\n                    if (opt.getValues() == null || opt.getValues().length == 0)\n                    {\n                        opt.addValueForProcessing(value);\n                    }\n                }\n                else if (!(\"yes\".equalsIgnoreCase(value)\n                        || \"true\".equalsIgnoreCase(value)\n                        || \"1\".equalsIgnoreCase(value)))\n                {\n                    \n                    continue;\n                }\n\n                handleOption(opt);\n                currentOption = null;\n            }\n        }\n    }\n\n    \n    private void checkRequiredOptions() throws MissingOptionException {\n        \n        if (!expectedOpts.isEmpty())\n        {\n            throw new MissingOptionException(expectedOpts);\n        }\n    }\n\n    \n    private void checkRequiredArgs() throws ParseException {\n        if (currentOption != null && currentOption.requiresArg())\n        {\n            throw new MissingArgumentException(currentOption);\n        }\n    }\n\n    \n    private void handleToken(String token) throws ParseException {\n        currentToken = token;\n\n        if (skipParsing)\n        {\n            cmd.addArg(token);\n        }\n        else if (\"--\".equals(token))\n        {\n            skipParsing = true;\n        }\n        else if (currentOption != null && currentOption.acceptsArg() && isArgument(token))\n        {\n            currentOption.addValueForProcessing(Util.stripLeadingAndTrailingQuotes(token));\n        }\n        else if (token.startsWith(\"--\"))\n        {\n            handleLongOption(token);\n        }\n        else if (token.startsWith(\"-\") && !\"-\".equals(token))\n        {\n            handleShortAndLongOption(token);\n        }\n        else\n        {\n            handleUnknownToken(token);\n        }\n\n        if (currentOption != null && !currentOption.acceptsArg())\n        {\n            currentOption = null;\n        }\n    }\n\n    \n    private boolean isArgument(String token) {\n        return !isOption(token) || isNegativeNumber(token);\n    }\n\n    \n    private boolean isNegativeNumber(String token) {\n        try\n        {\n            Double.parseDouble(token);\n            return true;\n        }\n        catch (NumberFormatException e)\n        {\n            return false;\n        }\n    }\n\n    \n    private boolean isOption(String token) {\n        return isLongOption(token) || isShortOption(token);\n    }\n\n    \n    private boolean isShortOption(String token) {\n        \n        return token.startsWith(\"-\") && token.length() >= 2 && options.hasShortOption(token.substring(1, 2));\n\n        \n    }\n\n    \n    private boolean isLongOption(String token) {\n        if (!token.startsWith(\"-\") || token.length() == 1)\n        {\n            return false;\n        }\n\n        int pos = token.indexOf(\"=\");\n        String t = pos == -1 ? token : token.substring(0, pos);\n\n        if (!options.getMatchingOptions(t).isEmpty())\n        {\n            \n            return true;\n        }\n        else if (getLongPrefix(token) != null && !token.startsWith(\"--\"))\n        {\n            \n            return true;\n        }\n\n        return false;\n    }\n\n    \n    private void handleUnknownToken(String token) throws ParseException {\n        if (token.startsWith(\"-\") && token.length() > 1 && !stopAtNonOption)\n        {\n            throw new UnrecognizedOptionException(\"Unrecognized option: \" + token, token);\n        }\n\n        cmd.addArg(token);\n        if (stopAtNonOption)\n        {\n            skipParsing = true;\n        }\n    }\n\n    \n    private void handleLongOption(String token) throws ParseException {\n        if (token.indexOf('=') == -1)\n        {\n            handleLongOptionWithoutEqual(token);\n        }\n        else\n        {\n            handleLongOptionWithEqual(token);\n        }\n    }\n\n    \n    private void handleLongOptionWithoutEqual(String token) throws ParseException {\n        List<String> matchingOpts = options.getMatchingOptions(token);\n        if (matchingOpts.isEmpty())\n        {\n            handleUnknownToken(currentToken);\n        }\n        else if (matchingOpts.size() > 1)\n        {\n            throw new AmbiguousOptionException(token, matchingOpts);\n        }\n        else\n        {\n            handleOption(options.getOption(matchingOpts.get(0)));\n        }\n    }\n\n    \n    private void handleLongOptionWithEqual(String token) throws ParseException {\n        int pos = token.indexOf('=');\n\n        String value = token.substring(pos + 1);\n\n        String opt = token.substring(0, pos);\n\n        List<String> matchingOpts = options.getMatchingOptions(opt);\n        if (matchingOpts.isEmpty())\n        {\n            handleUnknownToken(currentToken);\n        }\n        else if (matchingOpts.size() > 1)\n        {\n            throw new AmbiguousOptionException(opt, matchingOpts);\n        }\n        else\n        {\n            Option option = options.getOption(matchingOpts.get(0));\n\n            if (option.acceptsArg())\n            {\n                handleOption(option);\n                currentOption.addValueForProcessing(value);\n                currentOption = null;\n            }\n            else\n            {\n                handleUnknownToken(currentToken);\n            }\n        }\n    }\n\n    \n    private void handleShortAndLongOption(String token) throws ParseException {\n        String t = Util.stripLeadingHyphens(token);\n\n        int pos = t.indexOf('=');\n\n        if (t.length() == 1)\n        {\n            \n            if (options.hasShortOption(t))\n            {\n                handleOption(options.getOption(t));\n            }\n            else\n            {\n                handleUnknownToken(token);\n            }\n        }\n        else if (pos == -1)\n        {\n            \n            if (options.hasShortOption(t))\n            {\n                handleOption(options.getOption(t));\n            }\n            else if (!options.getMatchingOptions(t).isEmpty())\n            {\n                \n                handleLongOptionWithoutEqual(token);\n            }\n            else\n            {\n                \n                String opt = getLongPrefix(t);\n\n                if (opt != null && options.getOption(opt).acceptsArg())\n                {\n                    handleOption(options.getOption(opt));\n                    currentOption.addValueForProcessing(t.substring(opt.length()));\n                    currentOption = null;\n                }\n                else if (isJavaProperty(t))\n                {\n                    \n                    handleOption(options.getOption(t.substring(0, 1)));\n                    currentOption.addValueForProcessing(t.substring(1));\n                    currentOption = null;\n                }\n                else\n                {\n                    \n                    handleConcatenatedOptions(token);\n                }\n            }\n        }\n        else\n        {\n            \n            String opt = t.substring(0, pos);\n            String value = t.substring(pos + 1);\n\n            if (opt.length() == 1)\n            {\n                \n                Option option = options.getOption(opt);\n                if (option != null && option.acceptsArg())\n                {\n                    handleOption(option);\n                    currentOption.addValueForProcessing(value);\n                    currentOption = null;\n                }\n                else\n                {\n                    handleUnknownToken(token);\n                }\n            }\n            else if (isJavaProperty(opt))\n            {\n                \n                handleOption(options.getOption(opt.substring(0, 1)));\n                currentOption.addValueForProcessing(opt.substring(1));\n                currentOption.addValueForProcessing(value);\n                currentOption = null;\n            }\n            else\n            {\n                \n                handleLongOptionWithEqual(token);\n            }\n        }\n    }\n\n    \n    private String getLongPrefix(String token) {\n        String t = Util.stripLeadingHyphens(token);\n\n        int i;\n        String opt = null;\n        for (i = t.length() - 2; i > 1; i--)\n        {\n            String prefix = t.substring(0, i);\n            if (options.hasLongOption(prefix))\n            {\n                opt = prefix;\n                break;\n            }\n        }\n        \n        return opt;\n    }\n\n    \n    private boolean isJavaProperty(String token) {\n        String opt = token.substring(0, 1);\n        Option option = options.getOption(opt);\n\n        return option != null && (option.getArgs() >= 2 || option.getArgs() == Option.UNLIMITED_VALUES);\n    }\n\n    private void handleOption(Option option) throws ParseException {\n        \n        checkRequiredArgs();\n\n        option = (Option) option.clone();\n\n        updateRequiredOptions(option);\n\n        cmd.addOption(option);\n\n        if (option.hasArg())\n        {\n            currentOption = option;\n        }\n        else\n        {\n            currentOption = null;\n        }\n    }\n\n    \n    private void updateRequiredOptions(Option option) throws AlreadySelectedException {\n        if (option.isRequired())\n        {\n            expectedOpts.remove(option.getKey());\n        }\n\n        \n        if (options.getOptionGroup(option) != null)\n        {\n            OptionGroup group = options.getOptionGroup(option);\n\n            if (group.isRequired())\n            {\n                expectedOpts.remove(group);\n            }\n\n            group.setSelected(option);\n        }\n    }\n\n    \n    protected void handleConcatenatedOptions(String token) throws ParseException {\n        for (int i = 1; i < token.length(); i++)\n        {\n            String ch = String.valueOf(token.charAt(i));\n\n            if (options.hasOption(ch))\n            {\n                handleOption(options.getOption(ch));\n\n                if (currentOption != null && token.length() != i + 1)\n                {\n                    \n                    currentOption.addValueForProcessing(token.substring(i + 1));\n                    break;\n                }\n            }\n            else\n            {\n                handleUnknownToken(stopAtNonOption && i > 1 ? token.substring(i) : token);\n                break;\n            }\n        }\n    }\n}\n",
      "fixed_full_code": "\n\npackage org.apache.commons.cli;\n\nimport java.util.ArrayList;\nimport java.util.Enumeration;\nimport java.util.List;\nimport java.util.Properties;\n\n\npublic class DefaultParser implements CommandLineParser { protected CommandLine cmd; protected Options options; protected boolean stopAtNonOption; protected String currentToken; protected Option currentOption; protected boolean skipParsing; protected List expectedOpts; public CommandLine parse(Options options, String[] arguments) throws ParseException {\n        return parse(options, arguments, null);\n    }\n\n    \n    public CommandLine parse(Options options, String[] arguments, Properties properties) throws ParseException {\n        return parse(options, arguments, properties, false);\n    }\n\n    public CommandLine parse(Options options, String[] arguments, boolean stopAtNonOption) throws ParseException {\n        return parse(options, arguments, null, stopAtNonOption);\n    }\n\n    \n    public CommandLine parse(Options options, String[] arguments, Properties properties, boolean stopAtNonOption) throws ParseException {\n        this.options = options;\n        this.stopAtNonOption = stopAtNonOption;\n        skipParsing = false;\n        currentOption = null;\n        expectedOpts = new ArrayList(options.getRequiredOptions());\n\n        \n        for (OptionGroup group : options.getOptionGroups())\n        {\n            group.setSelected(null);\n        }\n\n        cmd = new CommandLine();\n\n        if (arguments != null)\n        {\n            for (String argument : arguments)\n            {\n                handleToken(argument);\n            }\n        }\n\n        \n        checkRequiredArgs();\n\n        \n        handleProperties(properties);\n\n        checkRequiredOptions();\n\n        return cmd;\n    }\n\n    \n    private void handleProperties(Properties properties) throws ParseException {\n        if (properties == null)\n        {\n            return;\n        }\n\n        for (Enumeration<?> e = properties.propertyNames(); e.hasMoreElements();)\n        {\n            String option = e.nextElement().toString();\n\n            Option opt = options.getOption(option);\n            if (opt == null)\n            {\n                throw new UnrecognizedOptionException(\"Default option wasn't defined\", option);\n            }\n\n            \n            OptionGroup group = options.getOptionGroup(opt);\n            boolean selected = group != null && group.getSelected() != null;\n\n            if (!cmd.hasOption(option) && !selected)\n            {\n                \n                String value = properties.getProperty(option);\n\n                if (opt.hasArg())\n                {\n                    if (opt.getValues() == null || opt.getValues().length == 0)\n                    {\n                        opt.addValueForProcessing(value);\n                    }\n                }\n                else if (!(\"yes\".equalsIgnoreCase(value)\n                        || \"true\".equalsIgnoreCase(value)\n                        || \"1\".equalsIgnoreCase(value)))\n                {\n                    \n                    continue;\n                }\n\n                handleOption(opt);\n                currentOption = null;\n            }\n        }\n    }\n\n    \n    private void checkRequiredOptions() throws MissingOptionException {\n        \n        if (!expectedOpts.isEmpty())\n        {\n            throw new MissingOptionException(expectedOpts);\n        }\n    }\n\n    \n    private void checkRequiredArgs() throws ParseException {\n        if (currentOption != null && currentOption.requiresArg())\n        {\n            throw new MissingArgumentException(currentOption);\n        }\n    }\n\n    \n    private void handleToken(String token) throws ParseException {\n        currentToken = token;\n\n        if (skipParsing)\n        {\n            cmd.addArg(token);\n        }\n        else if (\"--\".equals(token))\n        {\n            skipParsing = true;\n        }\n        else if (currentOption != null && currentOption.acceptsArg() && isArgument(token))\n        {\n            currentOption.addValueForProcessing(Util.stripLeadingAndTrailingQuotes(token));\n        }\n        else if (token.startsWith(\"--\"))\n        {\n            handleLongOption(token);\n        }\n        else if (token.startsWith(\"-\") && !\"-\".equals(token))\n        {\n            handleShortAndLongOption(token);\n        }\n        else\n        {\n            handleUnknownToken(token);\n        }\n\n        if (currentOption != null && !currentOption.acceptsArg())\n        {\n            currentOption = null;\n        }\n    }\n\n    \n    private boolean isArgument(String token) {\n        return !isOption(token) || isNegativeNumber(token);\n    }\n\n    \n    private boolean isNegativeNumber(String token) {\n        try\n        {\n            Double.parseDouble(token);\n            return true;\n        }\n        catch (NumberFormatException e)\n        {\n            return false;\n        }\n    }\n\n    \n    private boolean isOption(String token) {\n        return isLongOption(token) || isShortOption(token);\n    }\n\n    \n    private boolean isShortOption(String token) {\n        \n        if (!token.startsWith(\"-\") || token.length() == 1)\n        {\n            return false;\n        }\n\n        \n        int pos = token.indexOf(\"=\");\n        String optName = pos == -1 ? token.substring(1) : token.substring(1, pos);\n        return options.hasShortOption(optName);\n    }\n\n    \n    private boolean isLongOption(String token) {\n        if (!token.startsWith(\"-\") || token.length() == 1)\n        {\n            return false;\n        }\n\n        int pos = token.indexOf(\"=\");\n        String t = pos == -1 ? token : token.substring(0, pos);\n\n        if (!options.getMatchingOptions(t).isEmpty())\n        {\n            \n            return true;\n        }\n        else if (getLongPrefix(token) != null && !token.startsWith(\"--\"))\n        {\n            \n            return true;\n        }\n\n        return false;\n    }\n\n    \n    private void handleUnknownToken(String token) throws ParseException {\n        if (token.startsWith(\"-\") && token.length() > 1 && !stopAtNonOption)\n        {\n            throw new UnrecognizedOptionException(\"Unrecognized option: \" + token, token);\n        }\n\n        cmd.addArg(token);\n        if (stopAtNonOption)\n        {\n            skipParsing = true;\n        }\n    }\n\n    \n    private void handleLongOption(String token) throws ParseException {\n        if (token.indexOf('=') == -1)\n        {\n            handleLongOptionWithoutEqual(token);\n        }\n        else\n        {\n            handleLongOptionWithEqual(token);\n        }\n    }\n\n    \n    private void handleLongOptionWithoutEqual(String token) throws ParseException {\n        List<String> matchingOpts = options.getMatchingOptions(token);\n        if (matchingOpts.isEmpty())\n        {\n            handleUnknownToken(currentToken);\n        }\n        else if (matchingOpts.size() > 1)\n        {\n            throw new AmbiguousOptionException(token, matchingOpts);\n        }\n        else\n        {\n            handleOption(options.getOption(matchingOpts.get(0)));\n        }\n    }\n\n    \n    private void handleLongOptionWithEqual(String token) throws ParseException {\n        int pos = token.indexOf('=');\n\n        String value = token.substring(pos + 1);\n\n        String opt = token.substring(0, pos);\n\n        List<String> matchingOpts = options.getMatchingOptions(opt);\n        if (matchingOpts.isEmpty())\n        {\n            handleUnknownToken(currentToken);\n        }\n        else if (matchingOpts.size() > 1)\n        {\n            throw new AmbiguousOptionException(opt, matchingOpts);\n        }\n        else\n        {\n            Option option = options.getOption(matchingOpts.get(0));\n\n            if (option.acceptsArg())\n            {\n                handleOption(option);\n                currentOption.addValueForProcessing(value);\n                currentOption = null;\n            }\n            else\n            {\n                handleUnknownToken(currentToken);\n            }\n        }\n    }\n\n    \n    private void handleShortAndLongOption(String token) throws ParseException {\n        String t = Util.stripLeadingHyphens(token);\n\n        int pos = t.indexOf('=');\n\n        if (t.length() == 1)\n        {\n            \n            if (options.hasShortOption(t))\n            {\n                handleOption(options.getOption(t));\n            }\n            else\n            {\n                handleUnknownToken(token);\n            }\n        }\n        else if (pos == -1)\n        {\n            \n            if (options.hasShortOption(t))\n            {\n                handleOption(options.getOption(t));\n            }\n            else if (!options.getMatchingOptions(t).isEmpty())\n            {\n                \n                handleLongOptionWithoutEqual(token);\n            }\n            else\n            {\n                \n                String opt = getLongPrefix(t);\n\n                if (opt != null && options.getOption(opt).acceptsArg())\n                {\n                    handleOption(options.getOption(opt));\n                    currentOption.addValueForProcessing(t.substring(opt.length()));\n                    currentOption = null;\n                }\n                else if (isJavaProperty(t))\n                {\n                    \n                    handleOption(options.getOption(t.substring(0, 1)));\n                    currentOption.addValueForProcessing(t.substring(1));\n                    currentOption = null;\n                }\n                else\n                {\n                    \n                    handleConcatenatedOptions(token);\n                }\n            }\n        }\n        else\n        {\n            \n            String opt = t.substring(0, pos);\n            String value = t.substring(pos + 1);\n\n            if (opt.length() == 1)\n            {\n                \n                Option option = options.getOption(opt);\n                if (option != null && option.acceptsArg())\n                {\n                    handleOption(option);\n                    currentOption.addValueForProcessing(value);\n                    currentOption = null;\n                }\n                else\n                {\n                    handleUnknownToken(token);\n                }\n            }\n            else if (isJavaProperty(opt))\n            {\n                \n                handleOption(options.getOption(opt.substring(0, 1)));\n                currentOption.addValueForProcessing(opt.substring(1));\n                currentOption.addValueForProcessing(value);\n                currentOption = null;\n            }\n            else\n            {\n                \n                handleLongOptionWithEqual(token);\n            }\n        }\n    }\n\n    \n    private String getLongPrefix(String token) {\n        String t = Util.stripLeadingHyphens(token);\n\n        int i;\n        String opt = null;\n        for (i = t.length() - 2; i > 1; i--)\n        {\n            String prefix = t.substring(0, i);\n            if (options.hasLongOption(prefix))\n            {\n                opt = prefix;\n                break;\n            }\n        }\n        \n        return opt;\n    }\n\n    \n    private boolean isJavaProperty(String token) {\n        String opt = token.substring(0, 1);\n        Option option = options.getOption(opt);\n\n        return option != null && (option.getArgs() >= 2 || option.getArgs() == Option.UNLIMITED_VALUES);\n    }\n\n    private void handleOption(Option option) throws ParseException {\n        \n        checkRequiredArgs();\n\n        option = (Option) option.clone();\n\n        updateRequiredOptions(option);\n\n        cmd.addOption(option);\n\n        if (option.hasArg())\n        {\n            currentOption = option;\n        }\n        else\n        {\n            currentOption = null;\n        }\n    }\n\n    \n    private void updateRequiredOptions(Option option) throws AlreadySelectedException {\n        if (option.isRequired())\n        {\n            expectedOpts.remove(option.getKey());\n        }\n\n        \n        if (options.getOptionGroup(option) != null)\n        {\n            OptionGroup group = options.getOptionGroup(option);\n\n            if (group.isRequired())\n            {\n                expectedOpts.remove(group);\n            }\n\n            group.setSelected(option);\n        }\n    }\n\n    \n    protected void handleConcatenatedOptions(String token) throws ParseException {\n        for (int i = 1; i < token.length(); i++)\n        {\n            String ch = String.valueOf(token.charAt(i));\n\n            if (options.hasOption(ch))\n            {\n                handleOption(options.getOption(ch));\n\n                if (currentOption != null && token.length() != i + 1)\n                {\n                    \n                    currentOption.addValueForProcessing(token.substring(i + 1));\n                    break;\n                }\n            }\n            else\n            {\n                handleUnknownToken(stopAtNonOption && i > 1 ? token.substring(i) : token);\n                break;\n            }\n        }\n    }\n}\n",
      "buggy_signatures": [
        "public class DefaultParser implements CommandLineParser { protected CommandLine cmd; protected Options options; protected boolean stopAtNonOption; protected String currentToken; protected Option currentOption; protected boolean skipParsing; protected List expectedOpts; public CommandLine parse(Options options, String[] arguments) throws ParseException",
        "public CommandLine parse(Options options, String[] arguments, Properties properties) throws ParseException",
        "public CommandLine parse(Options options, String[] arguments, boolean stopAtNonOption) throws ParseException",
        "public CommandLine parse(Options options, String[] arguments, Properties properties, boolean stopAtNonOption) throws ParseException",
        "private void handleProperties(Properties properties) throws ParseException",
        "private void checkRequiredOptions() throws MissingOptionException",
        "private void checkRequiredArgs() throws ParseException",
        "private void handleToken(String token) throws ParseException",
        "private boolean isArgument(String token)",
        "private boolean isNegativeNumber(String token)",
        "private boolean isOption(String token)",
        "private boolean isShortOption(String token)",
        "private boolean isLongOption(String token)",
        "private void handleUnknownToken(String token) throws ParseException",
        "private void handleLongOption(String token) throws ParseException",
        "private void handleLongOptionWithoutEqual(String token) throws ParseException",
        "private void handleLongOptionWithEqual(String token) throws ParseException",
        "private void handleShortAndLongOption(String token) throws ParseException",
        "private String getLongPrefix(String token)",
        "private boolean isJavaProperty(String token)",
        "private void handleOption(Option option) throws ParseException",
        "private void updateRequiredOptions(Option option) throws AlreadySelectedException",
        "protected void handleConcatenatedOptions(String token) throws ParseException"
      ],
      "fixed_signatures": [
        "public class DefaultParser implements CommandLineParser { protected CommandLine cmd; protected Options options; protected boolean stopAtNonOption; protected String currentToken; protected Option currentOption; protected boolean skipParsing; protected List expectedOpts; public CommandLine parse(Options options, String[] arguments) throws ParseException",
        "public CommandLine parse(Options options, String[] arguments, Properties properties) throws ParseException",
        "public CommandLine parse(Options options, String[] arguments, boolean stopAtNonOption) throws ParseException",
        "public CommandLine parse(Options options, String[] arguments, Properties properties, boolean stopAtNonOption) throws ParseException",
        "private void handleProperties(Properties properties) throws ParseException",
        "private void checkRequiredOptions() throws MissingOptionException",
        "private void checkRequiredArgs() throws ParseException",
        "private void handleToken(String token) throws ParseException",
        "private boolean isArgument(String token)",
        "private boolean isNegativeNumber(String token)",
        "private boolean isOption(String token)",
        "private boolean isShortOption(String token)",
        "private boolean isLongOption(String token)",
        "private void handleUnknownToken(String token) throws ParseException",
        "private void handleLongOption(String token) throws ParseException",
        "private void handleLongOptionWithoutEqual(String token) throws ParseException",
        "private void handleLongOptionWithEqual(String token) throws ParseException",
        "private void handleShortAndLongOption(String token) throws ParseException",
        "private String getLongPrefix(String token)",
        "private boolean isJavaProperty(String token)",
        "private void handleOption(Option option) throws ParseException",
        "private void updateRequiredOptions(Option option) throws AlreadySelectedException",
        "protected void handleConcatenatedOptions(String token) throws ParseException"
      ],
      "methods": [
        {
          "buggy_method": "  private boolean isShortOption(String token) {\n  \n  return token.startsWith(\"-\") && token.length() >= 2 && options.hasShortOption(token.substring(1, 2));\n\n  \n  }",
          "fixed_method": "  private boolean isShortOption(String token) {\n  \n  if (!token.startsWith(\"-\") || token.length() == 1)\n  {\n  return false;\n  }\n\n  \n  int pos = token.indexOf(\"=\");\n  String optName = pos == -1 ? token.substring(1) : token.substring(1, pos);\n  return options.hasShortOption(optName);\n  }",
          "diff": [
            "@@ -299,9 +299,15 @@",
            "     private boolean isShortOption(String token)\n",
            "     {\n",
            "         // short options (-S, -SV, -S=V, -SV1=V2, -S1S2)\n",
            "-        return token.startsWith(\"-\") && token.length() >= 2 && options.hasShortOption(token.substring(1, 2));\n",
            "+        if (!token.startsWith(\"-\") || token.length() == 1)\n",
            "+        {\n",
            "+            return false;\n",
            "+        }\n",
            " \n",
            "         // remove leading \"-\" and \"=value\"\n",
            "+        int pos = token.indexOf(\"=\");\n",
            "+        String optName = pos == -1 ? token.substring(1) : token.substring(1, pos);\n",
            "+        return options.hasShortOption(optName);\n",
            "     }\n",
            " \n",
            "     /**\n"
          ],
          "changed_lines": 8
        }
      ]
    }
  ]
}
