{
  "bug_id": "71",
  "failed_tests": {
    "org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegratorTest": [
      {
        "methodName": "testMissedEndEvent",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<1.8782503799999986E9> but was:<1.878250439999994E9>",
        "fail_line": "      Assert.assertEquals(tEvent, finalT, 5.0e-6);",
        "test_source": "  public void testMissedEndEvent() throws IntegratorException, DerivativeException {\n  final double  t0  = 1878250320.0000029;\n  final double  tEvent = 1878250379.9999986;\n  final double[] k  = { 1.0e-4, 1.0e-5, 1.0e-6 };\n  FirstOrderDifferentialEquations ode = new FirstOrderDifferentialEquations() {\n\n  public int getDimension() {\n  return k.length;\n  }\n\n  public void computeDerivatives(double t, double[] y, double[] yDot) {\n  for (int i = 0; i < y.length; ++i) {\n  yDot[i] = k[i] * y[i];\n  }\n  }\n  };\n\n  ClassicalRungeKuttaIntegrator integrator = new ClassicalRungeKuttaIntegrator(60.0);\n\n  double[] y0  = new double[k.length];\n  for (int i = 0; i < y0.length; ++i) {\n  y0[i] = i + 1;\n  }\n  double[] y  = new double[k.length];\n\n  double finalT = integrator.integrate(ode, t0, y0, tEvent, y);\n  Assert.assertEquals(tEvent, finalT, 5.0e-6);\n  for (int i = 0; i < y.length; ++i) {\n  Assert.assertEquals(y0[i] * Math.exp(k[i] * (finalT - t0)), y[i], 1.0e-9);\n  }\n\n  integrator.addEventHandler(new EventHandler() {\n\n  public void resetState(double t, double[] y) {\n  }\n\n  public double g(double t, double[] y) {\n  return t - tEvent;\n  }\n\n  public int eventOccurred(double t, double[] y, boolean increasing) {\n  Assert.assertEquals(tEvent, t, 5.0e-6);\n  return CONTINUE;\n  }\n  }, Double.POSITIVE_INFINITY, 1.0e-20, 100);\n  finalT = integrator.integrate(ode, t0, y0, tEvent + 120, y);\n  Assert.assertEquals(tEvent + 120, finalT, 5.0e-6);\n  for (int i = 0; i < y.length; ++i) {\n  Assert.assertEquals(y0[i] * Math.exp(k[i] * (finalT - t0)), y[i], 1.0e-9);\n  }\n\n  }",
        "stack": [
          "ClassicalRungeKuttaIntegratorTest.testMissedEndEvent line 70"
        ]
      }
    ],
    "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest": [
      {
        "methodName": "testMissedEndEvent",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<1.8782503799999986E9> but was:<1.878250479999994E9>",
        "fail_line": "      Assert.assertEquals(tEvent, finalT, 5.0e-6);",
        "test_source": "  public void testMissedEndEvent() throws IntegratorException, DerivativeException {\n  final double  t0  = 1878250320.0000029;\n  final double  tEvent = 1878250379.9999986;\n  final double[] k  = { 1.0e-4, 1.0e-5, 1.0e-6 };\n  FirstOrderDifferentialEquations ode = new FirstOrderDifferentialEquations() {\n\n  public int getDimension() {\n  return k.length;\n  }\n\n  public void computeDerivatives(double t, double[] y, double[] yDot) {\n  for (int i = 0; i < y.length; ++i) {\n  yDot[i] = k[i] * y[i];\n  }\n  }\n  };\n\n  DormandPrince853Integrator integrator = new DormandPrince853Integrator(0.0, 100.0,\n  1.0e-10, 1.0e-10);\n\n  double[] y0  = new double[k.length];\n  for (int i = 0; i < y0.length; ++i) {\n  y0[i] = i + 1;\n  }\n  double[] y  = new double[k.length];\n\n  integrator.setInitialStepSize(60.0);\n  double finalT = integrator.integrate(ode, t0, y0, tEvent, y);\n  Assert.assertEquals(tEvent, finalT, 5.0e-6);\n  for (int i = 0; i < y.length; ++i) {\n  Assert.assertEquals(y0[i] * Math.exp(k[i] * (finalT - t0)), y[i], 1.0e-9);\n  }\n\n  integrator.setInitialStepSize(60.0);\n  integrator.addEventHandler(new EventHandler() {\n\n  public void resetState(double t, double[] y) {\n  }\n\n  public double g(double t, double[] y) {\n  return t - tEvent;\n  }\n\n  public int eventOccurred(double t, double[] y, boolean increasing) {\n  Assert.assertEquals(tEvent, t, 5.0e-6);\n  return CONTINUE;\n  }\n  }, Double.POSITIVE_INFINITY, 1.0e-20, 100);\n  finalT = integrator.integrate(ode, t0, y0, tEvent + 120, y);\n  Assert.assertEquals(tEvent + 120, finalT, 5.0e-6);\n  for (int i = 0; i < y.length; ++i) {\n  Assert.assertEquals(y0[i] * Math.exp(k[i] * (finalT - t0)), y[i], 1.0e-9);\n  }\n\n  }",
        "stack": [
          "DormandPrince853IntegratorTest.testMissedEndEvent line 72"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java",
      "buggy_full_code": "\n\npackage org.apache.commons.math.ode.nonstiff;\n\nimport org.apache.commons.math.ode.DerivativeException;\nimport org.apache.commons.math.ode.FirstOrderDifferentialEquations;\nimport org.apache.commons.math.ode.IntegratorException;\nimport org.apache.commons.math.ode.events.CombinedEventsManager;\nimport org.apache.commons.math.ode.sampling.AbstractStepInterpolator;\nimport org.apache.commons.math.ode.sampling.DummyStepInterpolator;\nimport org.apache.commons.math.ode.sampling.StepHandler;\n\n\n\npublic abstract class EmbeddedRungeKuttaIntegrator extends AdaptiveStepsizeIntegrator { private final boolean fsal; private final double[] c; private final double[][] a; private final double[] b; private final RungeKuttaStepInterpolator prototype; private final double exp; private double safety; private double minReduction; private double maxGrowth; protected EmbeddedRungeKuttaIntegrator(final String name, final boolean fsal, final double[] c, final double[][] a, final double[] b, final RungeKuttaStepInterpolator prototype, final double minStep, final double maxStep, final double scalAbsoluteTolerance, final double scalRelativeTolerance) {\n\n    super(name, minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);\n\n    this.fsal      = fsal;\n    this.c         = c;\n    this.a         = a;\n    this.b         = b;\n    this.prototype = prototype;\n\n    exp = -1.0 / getOrder();\n\n    \n    setSafety(0.9);\n    setMinReduction(0.2);\n    setMaxGrowth(10.0);\n\n  }\n\n  \n  protected EmbeddedRungeKuttaIntegrator(final String name, final boolean fsal, final double[] c, final double[][] a, final double[] b, final RungeKuttaStepInterpolator prototype, final double minStep, final double maxStep, final double[] vecAbsoluteTolerance, final double[] vecRelativeTolerance) {\n\n    super(name, minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance);\n\n    this.fsal      = fsal;\n    this.c         = c;\n    this.a         = a;\n    this.b         = b;\n    this.prototype = prototype;\n\n    exp = -1.0 / getOrder();\n\n    \n    setSafety(0.9);\n    setMinReduction(0.2);\n    setMaxGrowth(10.0);\n\n  }\n\n  \n  public abstract int getOrder(); public double getSafety() {\n    return safety;\n  }\n\n  \n  public void setSafety(final double safety) {\n    this.safety = safety;\n  }\n\n  \n  @Override\n  public double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws DerivativeException, IntegratorException {\n\n    sanityChecks(equations, t0, y0, t, y);\n    setEquations(equations);\n    resetEvaluations();\n    final boolean forward = t > t0;\n\n    \n    final int stages = c.length + 1;\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n    final double[][] yDotK = new double[stages][y0.length];\n    final double[] yTmp = new double[y0.length];\n\n    \n    AbstractStepInterpolator interpolator;\n    if (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {\n      final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n      rki.reinitialize(this, yTmp, yDotK, forward);\n      interpolator = rki;\n    } else {\n      interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);\n    }\n    interpolator.storeTime(t0);\n\n    \n    stepStart         = t0;\n    double  hNew      = 0;\n    boolean firstTime = true;\n    for (StepHandler handler : stepHandlers) {\n        handler.reset();\n    }\n    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n    boolean lastStep = false;\n\n    \n    while (!lastStep) {\n\n      interpolator.shift();\n\n      double error = 0;\n      for (boolean loop = true; loop;) {\n\n        if (firstTime || !fsal) {\n          \n          computeDerivatives(stepStart, y, yDotK[0]);\n        }\n\n        if (firstTime) {\n          final double[] scale = new double[y0.length];\n          if (vecAbsoluteTolerance == null) {\n              for (int i = 0; i < scale.length; ++i) {\n                scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]);\n              }\n            } else {\n              for (int i = 0; i < scale.length; ++i) {\n                scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]);\n              }\n            }\n          hNew = initializeStep(equations, forward, getOrder(), scale,\n                                stepStart, y, yDotK[0], yTmp, yDotK[1]);\n          firstTime = false;\n        }\n\n        stepSize = hNew;\n\n        \n        for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n            double sum = a[k-1][0] * yDotK[0][j];\n            for (int l = 1; l < k; ++l) {\n              sum += a[k-1][l] * yDotK[l][j];\n            }\n            yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n        }\n\n        \n        for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n            sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n        }\n\n        \n        error = estimateError(yDotK, y, yTmp, stepSize);\n        if (error <= 1.0) {\n\n          \n          interpolator.storeTime(stepStart + stepSize);\n          if (manager.evaluateStep(interpolator)) {\n              final double dt = manager.getEventTime() - stepStart;\n              if (Math.abs(dt) <= Math.ulp(stepStart)) {\n                  \n                  \n                  \n                  \n                  \n                  loop     = false;\n              } else {\n                  \n                  hNew = dt;\n              }\n          } else {\n            \n            loop = false;\n          }\n\n        } else {\n          \n          final double factor =\n              Math.min(maxGrowth,\n                       Math.max(minReduction, safety * Math.pow(error, exp)));\n          hNew = filterStep(stepSize * factor, forward, false);\n        }\n\n      }\n\n      \n      final double nextStep = stepStart + stepSize;\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      manager.stepAccepted(nextStep, y);\n      lastStep = manager.stop();\n\n      \n      interpolator.storeTime(nextStep);\n      for (StepHandler handler : stepHandlers) {\n          handler.handleStep(interpolator, lastStep);\n      }\n      stepStart = nextStep;\n\n      if (fsal) {\n        \n        System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);\n      }\n\n      if (manager.reset(stepStart, y) && ! lastStep) {\n        \n        \n        computeDerivatives(stepStart, y, yDotK[0]);\n      }\n\n      if (! lastStep) {\n        \n        \n        \n          stepSize = filterStep(stepSize, forward, true);\n\n        \n        final double factor = Math.min(maxGrowth,\n                                       Math.max(minReduction,\n                                                safety * Math.pow(error, exp)));\n        final double  scaledH    = stepSize * factor;\n        final double  nextT      = stepStart + scaledH;\n        final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n        hNew = filterStep(scaledH, forward, nextIsLast);\n      }\n\n    }\n\n    final double stopTime = stepStart;\n    resetInternalState();\n    return stopTime;\n\n  }\n\n  \n  public double getMinReduction() {\n    return minReduction;\n  }\n\n  \n  public void setMinReduction(final double minReduction) {\n    this.minReduction = minReduction;\n  }\n\n  \n  public double getMaxGrowth() {\n    return maxGrowth;\n  }\n\n  \n  public void setMaxGrowth(final double maxGrowth) {\n    this.maxGrowth = maxGrowth;\n  }\n\n  \n  protected abstract double estimateError(double[][] yDotK,\n                                          double[] y0, double[] y1,\n                                          double h);\n\n}\n",
      "fixed_full_code": "\n\npackage org.apache.commons.math.ode.nonstiff;\n\nimport org.apache.commons.math.ode.DerivativeException;\nimport org.apache.commons.math.ode.FirstOrderDifferentialEquations;\nimport org.apache.commons.math.ode.IntegratorException;\nimport org.apache.commons.math.ode.events.CombinedEventsManager;\nimport org.apache.commons.math.ode.sampling.AbstractStepInterpolator;\nimport org.apache.commons.math.ode.sampling.DummyStepInterpolator;\nimport org.apache.commons.math.ode.sampling.StepHandler;\n\n\n\npublic abstract class EmbeddedRungeKuttaIntegrator extends AdaptiveStepsizeIntegrator { private final boolean fsal; private final double[] c; private final double[][] a; private final double[] b; private final RungeKuttaStepInterpolator prototype; private final double exp; private double safety; private double minReduction; private double maxGrowth; protected EmbeddedRungeKuttaIntegrator(final String name, final boolean fsal, final double[] c, final double[][] a, final double[] b, final RungeKuttaStepInterpolator prototype, final double minStep, final double maxStep, final double scalAbsoluteTolerance, final double scalRelativeTolerance) {\n\n    super(name, minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);\n\n    this.fsal      = fsal;\n    this.c         = c;\n    this.a         = a;\n    this.b         = b;\n    this.prototype = prototype;\n\n    exp = -1.0 / getOrder();\n\n    \n    setSafety(0.9);\n    setMinReduction(0.2);\n    setMaxGrowth(10.0);\n\n  }\n\n  \n  protected EmbeddedRungeKuttaIntegrator(final String name, final boolean fsal, final double[] c, final double[][] a, final double[] b, final RungeKuttaStepInterpolator prototype, final double minStep, final double maxStep, final double[] vecAbsoluteTolerance, final double[] vecRelativeTolerance) {\n\n    super(name, minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance);\n\n    this.fsal      = fsal;\n    this.c         = c;\n    this.a         = a;\n    this.b         = b;\n    this.prototype = prototype;\n\n    exp = -1.0 / getOrder();\n\n    \n    setSafety(0.9);\n    setMinReduction(0.2);\n    setMaxGrowth(10.0);\n\n  }\n\n  \n  public abstract int getOrder(); public double getSafety() {\n    return safety;\n  }\n\n  \n  public void setSafety(final double safety) {\n    this.safety = safety;\n  }\n\n  \n  @Override\n  public double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws DerivativeException, IntegratorException {\n\n    sanityChecks(equations, t0, y0, t, y);\n    setEquations(equations);\n    resetEvaluations();\n    final boolean forward = t > t0;\n\n    \n    final int stages = c.length + 1;\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n    final double[][] yDotK = new double[stages][y0.length];\n    final double[] yTmp = new double[y0.length];\n\n    \n    AbstractStepInterpolator interpolator;\n    if (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {\n      final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n      rki.reinitialize(this, yTmp, yDotK, forward);\n      interpolator = rki;\n    } else {\n      interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);\n    }\n    interpolator.storeTime(t0);\n\n    \n    stepStart         = t0;\n    double  hNew      = 0;\n    boolean firstTime = true;\n    for (StepHandler handler : stepHandlers) {\n        handler.reset();\n    }\n    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n    boolean lastStep = false;\n\n    \n    while (!lastStep) {\n\n      interpolator.shift();\n\n      double error = 0;\n      for (boolean loop = true; loop;) {\n\n        if (firstTime || !fsal) {\n          \n          computeDerivatives(stepStart, y, yDotK[0]);\n        }\n\n        if (firstTime) {\n          final double[] scale = new double[y0.length];\n          if (vecAbsoluteTolerance == null) {\n              for (int i = 0; i < scale.length; ++i) {\n                scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]);\n              }\n            } else {\n              for (int i = 0; i < scale.length; ++i) {\n                scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]);\n              }\n            }\n          hNew = initializeStep(equations, forward, getOrder(), scale,\n                                stepStart, y, yDotK[0], yTmp, yDotK[1]);\n          firstTime = false;\n        }\n\n        stepSize = hNew;\n\n        \n        for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n            double sum = a[k-1][0] * yDotK[0][j];\n            for (int l = 1; l < k; ++l) {\n              sum += a[k-1][l] * yDotK[l][j];\n            }\n            yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n        }\n\n        \n        for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n            sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n        }\n\n        \n        error = estimateError(yDotK, y, yTmp, stepSize);\n        if (error <= 1.0) {\n\n          \n          interpolator.storeTime(stepStart + stepSize);\n          if (manager.evaluateStep(interpolator)) {\n              final double dt = manager.getEventTime() - stepStart;\n              if (Math.abs(dt) <= Math.ulp(stepStart)) {\n                  \n                  \n                  \n                  \n                  \n                  interpolator.storeTime(stepStart);\n                  System.arraycopy(y, 0, yTmp, 0, y0.length);\n                  hNew     = 0;\n                  stepSize = 0;\n                  loop     = false;\n              } else {\n                  \n                  hNew = dt;\n              }\n          } else {\n            \n            loop = false;\n          }\n\n        } else {\n          \n          final double factor =\n              Math.min(maxGrowth,\n                       Math.max(minReduction, safety * Math.pow(error, exp)));\n          hNew = filterStep(stepSize * factor, forward, false);\n        }\n\n      }\n\n      \n      final double nextStep = stepStart + stepSize;\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      manager.stepAccepted(nextStep, y);\n      lastStep = manager.stop();\n\n      \n      interpolator.storeTime(nextStep);\n      for (StepHandler handler : stepHandlers) {\n          handler.handleStep(interpolator, lastStep);\n      }\n      stepStart = nextStep;\n\n      if (fsal) {\n        \n        System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);\n      }\n\n      if (manager.reset(stepStart, y) && ! lastStep) {\n        \n        \n        computeDerivatives(stepStart, y, yDotK[0]);\n      }\n\n      if (! lastStep) {\n        \n        \n        \n          stepSize = filterStep(stepSize, forward, true);\n\n        \n        final double factor = Math.min(maxGrowth,\n                                       Math.max(minReduction,\n                                                safety * Math.pow(error, exp)));\n        final double  scaledH    = stepSize * factor;\n        final double  nextT      = stepStart + scaledH;\n        final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n        hNew = filterStep(scaledH, forward, nextIsLast);\n      }\n\n    }\n\n    final double stopTime = stepStart;\n    resetInternalState();\n    return stopTime;\n\n  }\n\n  \n  public double getMinReduction() {\n    return minReduction;\n  }\n\n  \n  public void setMinReduction(final double minReduction) {\n    this.minReduction = minReduction;\n  }\n\n  \n  public double getMaxGrowth() {\n    return maxGrowth;\n  }\n\n  \n  public void setMaxGrowth(final double maxGrowth) {\n    this.maxGrowth = maxGrowth;\n  }\n\n  \n  protected abstract double estimateError(double[][] yDotK,\n                                          double[] y0, double[] y1,\n                                          double h);\n\n}\n",
      "buggy_signatures": [
        "public abstract class EmbeddedRungeKuttaIntegrator extends AdaptiveStepsizeIntegrator { private final boolean fsal; private final double[] c; private final double[][] a; private final double[] b; private final RungeKuttaStepInterpolator prototype; private final double exp; private double safety; private double minReduction; private double maxGrowth; protected EmbeddedRungeKuttaIntegrator(final String name, final boolean fsal, final double[] c, final double[][] a, final double[] b, final RungeKuttaStepInterpolator prototype, final double minStep, final double maxStep, final double scalAbsoluteTolerance, final double scalRelativeTolerance)",
        "protected EmbeddedRungeKuttaIntegrator(final String name, final boolean fsal, final double[] c, final double[][] a, final double[] b, final RungeKuttaStepInterpolator prototype, final double minStep, final double maxStep, final double[] vecAbsoluteTolerance, final double[] vecRelativeTolerance)",
        "public abstract int getOrder(); public double getSafety()",
        "public void setSafety(final double safety)",
        "public double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws DerivativeException, IntegratorException",
        "public double getMinReduction()",
        "public void setMinReduction(final double minReduction)",
        "public double getMaxGrowth()",
        "public void setMaxGrowth(final double maxGrowth)"
      ],
      "fixed_signatures": [
        "public abstract class EmbeddedRungeKuttaIntegrator extends AdaptiveStepsizeIntegrator { private final boolean fsal; private final double[] c; private final double[][] a; private final double[] b; private final RungeKuttaStepInterpolator prototype; private final double exp; private double safety; private double minReduction; private double maxGrowth; protected EmbeddedRungeKuttaIntegrator(final String name, final boolean fsal, final double[] c, final double[][] a, final double[] b, final RungeKuttaStepInterpolator prototype, final double minStep, final double maxStep, final double scalAbsoluteTolerance, final double scalRelativeTolerance)",
        "protected EmbeddedRungeKuttaIntegrator(final String name, final boolean fsal, final double[] c, final double[][] a, final double[] b, final RungeKuttaStepInterpolator prototype, final double minStep, final double maxStep, final double[] vecAbsoluteTolerance, final double[] vecRelativeTolerance)",
        "public abstract int getOrder(); public double getSafety()",
        "public void setSafety(final double safety)",
        "public double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws DerivativeException, IntegratorException",
        "public double getMinReduction()",
        "public void setMinReduction(final double minReduction)",
        "public double getMaxGrowth()",
        "public void setMaxGrowth(final double maxGrowth)"
      ],
      "methods": [
        {
          "buggy_method": "  public double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws DerivativeException, IntegratorException {\n\n  sanityChecks(equations, t0, y0, t, y);\n  setEquations(equations);\n  resetEvaluations();\n  final boolean forward = t > t0;\n\n  \n  final int stages = c.length + 1;\n  if (y != y0) {\n  System.arraycopy(y0, 0, y, 0, y0.length);\n  }\n  final double[][] yDotK = new double[stages][y0.length];\n  final double[] yTmp = new double[y0.length];\n\n  \n  AbstractStepInterpolator interpolator;\n  if (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {\n  final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n  rki.reinitialize(this, yTmp, yDotK, forward);\n  interpolator = rki;\n  } else {\n  interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);\n  }\n  interpolator.storeTime(t0);\n\n  \n  stepStart  = t0;\n  double  hNew  = 0;\n  boolean firstTime = true;\n  for (StepHandler handler : stepHandlers) {\n  handler.reset();\n  }\n  CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n  boolean lastStep = false;\n\n  \n  while (!lastStep) {\n\n  interpolator.shift();\n\n  double error = 0;\n  for (boolean loop = true; loop;) {\n\n  if (firstTime || !fsal) {\n  \n  computeDerivatives(stepStart, y, yDotK[0]);\n  }\n\n  if (firstTime) {\n  final double[] scale = new double[y0.length];\n  if (vecAbsoluteTolerance == null) {\n  for (int i = 0; i < scale.length; ++i) {\n  scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]);\n  }\n  } else {\n  for (int i = 0; i < scale.length; ++i) {\n  scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]);\n  }\n  }\n  hNew = initializeStep(equations, forward, getOrder(), scale,\n  stepStart, y, yDotK[0], yTmp, yDotK[1]);\n  firstTime = false;\n  }\n\n  stepSize = hNew;\n\n  \n  for (int k = 1; k < stages; ++k) {\n\n  for (int j = 0; j < y0.length; ++j) {\n  double sum = a[k-1][0] * yDotK[0][j];\n  for (int l = 1; l < k; ++l) {\n  sum += a[k-1][l] * yDotK[l][j];\n  }\n  yTmp[j] = y[j] + stepSize * sum;\n  }\n\n  computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n  }\n\n  \n  for (int j = 0; j < y0.length; ++j) {\n  double sum  = b[0] * yDotK[0][j];\n  for (int l = 1; l < stages; ++l) {\n  sum  += b[l] * yDotK[l][j];\n  }\n  yTmp[j] = y[j] + stepSize * sum;\n  }\n\n  \n  error = estimateError(yDotK, y, yTmp, stepSize);\n  if (error <= 1.0) {\n\n  \n  interpolator.storeTime(stepStart + stepSize);\n  if (manager.evaluateStep(interpolator)) {\n  final double dt = manager.getEventTime() - stepStart;\n  if (Math.abs(dt) <= Math.ulp(stepStart)) {\n  \n  \n  \n  \n  \n  loop  = false;\n  } else {\n  \n  hNew = dt;\n  }\n  } else {\n  \n  loop = false;\n  }\n\n  } else {\n  \n  final double factor =\n  Math.min(maxGrowth,\n  Math.max(minReduction, safety * Math.pow(error, exp)));\n  hNew = filterStep(stepSize * factor, forward, false);\n  }\n\n  }\n\n  \n  final double nextStep = stepStart + stepSize;\n  System.arraycopy(yTmp, 0, y, 0, y0.length);\n  manager.stepAccepted(nextStep, y);\n  lastStep = manager.stop();\n\n  \n  interpolator.storeTime(nextStep);\n  for (StepHandler handler : stepHandlers) {\n  handler.handleStep(interpolator, lastStep);\n  }\n  stepStart = nextStep;\n\n  if (fsal) {\n  \n  System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);\n  }\n\n  if (manager.reset(stepStart, y) && ! lastStep) {\n  \n  \n  computeDerivatives(stepStart, y, yDotK[0]);\n  }\n\n  if (! lastStep) {\n  \n  \n  \n  stepSize = filterStep(stepSize, forward, true);\n\n  \n  final double factor = Math.min(maxGrowth,\n  Math.max(minReduction,\n  safety * Math.pow(error, exp)));\n  final double  scaledH  = stepSize * factor;\n  final double  nextT  = stepStart + scaledH;\n  final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n  hNew = filterStep(scaledH, forward, nextIsLast);\n  }\n\n  }\n\n  final double stopTime = stepStart;\n  resetInternalState();\n  return stopTime;\n\n  }",
          "fixed_method": "  public double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws DerivativeException, IntegratorException {\n\n  sanityChecks(equations, t0, y0, t, y);\n  setEquations(equations);\n  resetEvaluations();\n  final boolean forward = t > t0;\n\n  \n  final int stages = c.length + 1;\n  if (y != y0) {\n  System.arraycopy(y0, 0, y, 0, y0.length);\n  }\n  final double[][] yDotK = new double[stages][y0.length];\n  final double[] yTmp = new double[y0.length];\n\n  \n  AbstractStepInterpolator interpolator;\n  if (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {\n  final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n  rki.reinitialize(this, yTmp, yDotK, forward);\n  interpolator = rki;\n  } else {\n  interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);\n  }\n  interpolator.storeTime(t0);\n\n  \n  stepStart  = t0;\n  double  hNew  = 0;\n  boolean firstTime = true;\n  for (StepHandler handler : stepHandlers) {\n  handler.reset();\n  }\n  CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n  boolean lastStep = false;\n\n  \n  while (!lastStep) {\n\n  interpolator.shift();\n\n  double error = 0;\n  for (boolean loop = true; loop;) {\n\n  if (firstTime || !fsal) {\n  \n  computeDerivatives(stepStart, y, yDotK[0]);\n  }\n\n  if (firstTime) {\n  final double[] scale = new double[y0.length];\n  if (vecAbsoluteTolerance == null) {\n  for (int i = 0; i < scale.length; ++i) {\n  scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]);\n  }\n  } else {\n  for (int i = 0; i < scale.length; ++i) {\n  scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]);\n  }\n  }\n  hNew = initializeStep(equations, forward, getOrder(), scale,\n  stepStart, y, yDotK[0], yTmp, yDotK[1]);\n  firstTime = false;\n  }\n\n  stepSize = hNew;\n\n  \n  for (int k = 1; k < stages; ++k) {\n\n  for (int j = 0; j < y0.length; ++j) {\n  double sum = a[k-1][0] * yDotK[0][j];\n  for (int l = 1; l < k; ++l) {\n  sum += a[k-1][l] * yDotK[l][j];\n  }\n  yTmp[j] = y[j] + stepSize * sum;\n  }\n\n  computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n  }\n\n  \n  for (int j = 0; j < y0.length; ++j) {\n  double sum  = b[0] * yDotK[0][j];\n  for (int l = 1; l < stages; ++l) {\n  sum  += b[l] * yDotK[l][j];\n  }\n  yTmp[j] = y[j] + stepSize * sum;\n  }\n\n  \n  error = estimateError(yDotK, y, yTmp, stepSize);\n  if (error <= 1.0) {\n\n  \n  interpolator.storeTime(stepStart + stepSize);\n  if (manager.evaluateStep(interpolator)) {\n  final double dt = manager.getEventTime() - stepStart;\n  if (Math.abs(dt) <= Math.ulp(stepStart)) {\n  \n  \n  \n  \n  \n  interpolator.storeTime(stepStart);\n  System.arraycopy(y, 0, yTmp, 0, y0.length);\n  hNew  = 0;\n  stepSize = 0;\n  loop  = false;\n  } else {\n  \n  hNew = dt;\n  }\n  } else {\n  \n  loop = false;\n  }\n\n  } else {\n  \n  final double factor =\n  Math.min(maxGrowth,\n  Math.max(minReduction, safety * Math.pow(error, exp)));\n  hNew = filterStep(stepSize * factor, forward, false);\n  }\n\n  }\n\n  \n  final double nextStep = stepStart + stepSize;\n  System.arraycopy(yTmp, 0, y, 0, y0.length);\n  manager.stepAccepted(nextStep, y);\n  lastStep = manager.stop();\n\n  \n  interpolator.storeTime(nextStep);\n  for (StepHandler handler : stepHandlers) {\n  handler.handleStep(interpolator, lastStep);\n  }\n  stepStart = nextStep;\n\n  if (fsal) {\n  \n  System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);\n  }\n\n  if (manager.reset(stepStart, y) && ! lastStep) {\n  \n  \n  computeDerivatives(stepStart, y, yDotK[0]);\n  }\n\n  if (! lastStep) {\n  \n  \n  \n  stepSize = filterStep(stepSize, forward, true);\n\n  \n  final double factor = Math.min(maxGrowth,\n  Math.max(minReduction,\n  safety * Math.pow(error, exp)));\n  final double  scaledH  = stepSize * factor;\n  final double  nextT  = stepStart + scaledH;\n  final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n  hNew = filterStep(scaledH, forward, nextIsLast);\n  }\n\n  }\n\n  final double stopTime = stepStart;\n  resetInternalState();\n  return stopTime;\n\n  }",
          "diff": [
            "@@ -297,6 +297,10 @@",
            "                   // it is so small (much probably exactly 0 due to limited accuracy)\n",
            "                   // that the code above would fail handling it.\n",
            "                   // So we set up an artificial 0 size step by copying states\n",
            "+                  interpolator.storeTime(stepStart);\n",
            "+                  System.arraycopy(y, 0, yTmp, 0, y0.length);\n",
            "+                  hNew     = 0;\n",
            "+                  stepSize = 0;\n",
            "                   loop     = false;\n",
            "               } else {\n",
            "                   // reject the step to match exactly the next switch time\n"
          ],
          "changed_lines": 4
        }
      ]
    },
    {
      "name": "org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java",
      "buggy_full_code": "\n\npackage org.apache.commons.math.ode.nonstiff;\n\n\nimport org.apache.commons.math.ode.AbstractIntegrator;\nimport org.apache.commons.math.ode.DerivativeException;\nimport org.apache.commons.math.ode.FirstOrderDifferentialEquations;\nimport org.apache.commons.math.ode.IntegratorException;\nimport org.apache.commons.math.ode.events.CombinedEventsManager;\nimport org.apache.commons.math.ode.sampling.AbstractStepInterpolator;\nimport org.apache.commons.math.ode.sampling.DummyStepInterpolator;\nimport org.apache.commons.math.ode.sampling.StepHandler;\n\n\n\npublic abstract class RungeKuttaIntegrator extends AbstractIntegrator { private final double[] c; private final double[][] a; private final double[] b; private final RungeKuttaStepInterpolator prototype; private final double step; protected RungeKuttaIntegrator(final String name, final double[] c, final double[][] a, final double[] b, final RungeKuttaStepInterpolator prototype, final double step) {\n    super(name);\n    this.c          = c;\n    this.a          = a;\n    this.b          = b;\n    this.prototype  = prototype;\n    this.step       = Math.abs(step);\n  }\n\n  \n  public double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws DerivativeException, IntegratorException {\n\n    sanityChecks(equations, t0, y0, t, y);\n    setEquations(equations);\n    resetEvaluations();\n    final boolean forward = t > t0;\n\n    \n    final int stages = c.length + 1;\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK [i] = new double[y0.length];\n    }\n    final double[] yTmp = new double[y0.length];\n\n    \n    AbstractStepInterpolator interpolator;\n    if (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {\n      final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n      rki.reinitialize(this, yTmp, yDotK, forward);\n      interpolator = rki;\n    } else {\n      interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);\n    }\n    interpolator.storeTime(t0);\n\n    \n    stepStart = t0;\n    stepSize  = forward ? step : -step;\n    for (StepHandler handler : stepHandlers) {\n        handler.reset();\n    }\n    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n    boolean lastStep = false;\n\n    \n    while (!lastStep) {\n\n      interpolator.shift();\n\n      for (boolean loop = true; loop;) {\n\n        \n        computeDerivatives(stepStart, y, yDotK[0]);\n\n        \n        for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n            double sum = a[k-1][0] * yDotK[0][j];\n            for (int l = 1; l < k; ++l) {\n              sum += a[k-1][l] * yDotK[l][j];\n            }\n            yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n        }\n\n        \n        for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n            sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n        }\n\n        \n        interpolator.storeTime(stepStart + stepSize);\n        if (manager.evaluateStep(interpolator)) {\n            final double dt = manager.getEventTime() - stepStart;\n            if (Math.abs(dt) <= Math.ulp(stepStart)) {\n                \n                \n                \n                \n                \n                loop     = false;\n            } else {\n                \n                stepSize = dt;\n            }\n        } else {\n          loop = false;\n        }\n\n      }\n\n      \n      final double nextStep = stepStart + stepSize;\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      manager.stepAccepted(nextStep, y);\n      lastStep = manager.stop();\n\n      \n      interpolator.storeTime(nextStep);\n      for (StepHandler handler : stepHandlers) {\n          handler.handleStep(interpolator, lastStep);\n      }\n      stepStart = nextStep;\n\n      if (manager.reset(stepStart, y) && ! lastStep) {\n        \n        \n        computeDerivatives(stepStart, y, yDotK[0]);\n      }\n\n      \n      stepSize = forward ? step : -step;\n\n    }\n\n    final double stopTime = stepStart;\n    stepStart = Double.NaN;\n    stepSize  = Double.NaN;\n    return stopTime;\n\n  }\n\n}\n",
      "fixed_full_code": "\n\npackage org.apache.commons.math.ode.nonstiff;\n\n\nimport org.apache.commons.math.ode.AbstractIntegrator;\nimport org.apache.commons.math.ode.DerivativeException;\nimport org.apache.commons.math.ode.FirstOrderDifferentialEquations;\nimport org.apache.commons.math.ode.IntegratorException;\nimport org.apache.commons.math.ode.events.CombinedEventsManager;\nimport org.apache.commons.math.ode.sampling.AbstractStepInterpolator;\nimport org.apache.commons.math.ode.sampling.DummyStepInterpolator;\nimport org.apache.commons.math.ode.sampling.StepHandler;\n\n\n\npublic abstract class RungeKuttaIntegrator extends AbstractIntegrator { private final double[] c; private final double[][] a; private final double[] b; private final RungeKuttaStepInterpolator prototype; private final double step; protected RungeKuttaIntegrator(final String name, final double[] c, final double[][] a, final double[] b, final RungeKuttaStepInterpolator prototype, final double step) {\n    super(name);\n    this.c          = c;\n    this.a          = a;\n    this.b          = b;\n    this.prototype  = prototype;\n    this.step       = Math.abs(step);\n  }\n\n  \n  public double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws DerivativeException, IntegratorException {\n\n    sanityChecks(equations, t0, y0, t, y);\n    setEquations(equations);\n    resetEvaluations();\n    final boolean forward = t > t0;\n\n    \n    final int stages = c.length + 1;\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK [i] = new double[y0.length];\n    }\n    final double[] yTmp = new double[y0.length];\n\n    \n    AbstractStepInterpolator interpolator;\n    if (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {\n      final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n      rki.reinitialize(this, yTmp, yDotK, forward);\n      interpolator = rki;\n    } else {\n      interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);\n    }\n    interpolator.storeTime(t0);\n\n    \n    stepStart = t0;\n    stepSize  = forward ? step : -step;\n    for (StepHandler handler : stepHandlers) {\n        handler.reset();\n    }\n    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n    boolean lastStep = false;\n\n    \n    while (!lastStep) {\n\n      interpolator.shift();\n\n      for (boolean loop = true; loop;) {\n\n        \n        computeDerivatives(stepStart, y, yDotK[0]);\n\n        \n        for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n            double sum = a[k-1][0] * yDotK[0][j];\n            for (int l = 1; l < k; ++l) {\n              sum += a[k-1][l] * yDotK[l][j];\n            }\n            yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n        }\n\n        \n        for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n            sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n        }\n\n        \n        interpolator.storeTime(stepStart + stepSize);\n        if (manager.evaluateStep(interpolator)) {\n            final double dt = manager.getEventTime() - stepStart;\n            if (Math.abs(dt) <= Math.ulp(stepStart)) {\n                \n                \n                \n                \n                \n                interpolator.storeTime(stepStart);\n                System.arraycopy(y, 0, yTmp, 0, y0.length);\n                stepSize = 0;\n                loop     = false;\n            } else {\n                \n                stepSize = dt;\n            }\n        } else {\n          loop = false;\n        }\n\n      }\n\n      \n      final double nextStep = stepStart + stepSize;\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      manager.stepAccepted(nextStep, y);\n      lastStep = manager.stop();\n\n      \n      interpolator.storeTime(nextStep);\n      for (StepHandler handler : stepHandlers) {\n          handler.handleStep(interpolator, lastStep);\n      }\n      stepStart = nextStep;\n\n      if (manager.reset(stepStart, y) && ! lastStep) {\n        \n        \n        computeDerivatives(stepStart, y, yDotK[0]);\n      }\n\n      \n      stepSize = forward ? step : -step;\n\n    }\n\n    final double stopTime = stepStart;\n    stepStart = Double.NaN;\n    stepSize  = Double.NaN;\n    return stopTime;\n\n  }\n\n}\n",
      "buggy_signatures": [
        "public abstract class RungeKuttaIntegrator extends AbstractIntegrator { private final double[] c; private final double[][] a; private final double[] b; private final RungeKuttaStepInterpolator prototype; private final double step; protected RungeKuttaIntegrator(final String name, final double[] c, final double[][] a, final double[] b, final RungeKuttaStepInterpolator prototype, final double step)",
        "public double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws DerivativeException, IntegratorException"
      ],
      "fixed_signatures": [
        "public abstract class RungeKuttaIntegrator extends AbstractIntegrator { private final double[] c; private final double[][] a; private final double[] b; private final RungeKuttaStepInterpolator prototype; private final double step; protected RungeKuttaIntegrator(final String name, final double[] c, final double[][] a, final double[] b, final RungeKuttaStepInterpolator prototype, final double step)",
        "public double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws DerivativeException, IntegratorException"
      ],
      "methods": [
        {
          "buggy_method": "  public double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws DerivativeException, IntegratorException {\n\n  sanityChecks(equations, t0, y0, t, y);\n  setEquations(equations);\n  resetEvaluations();\n  final boolean forward = t > t0;\n\n  \n  final int stages = c.length + 1;\n  if (y != y0) {\n  System.arraycopy(y0, 0, y, 0, y0.length);\n  }\n  final double[][] yDotK = new double[stages][];\n  for (int i = 0; i < stages; ++i) {\n  yDotK [i] = new double[y0.length];\n  }\n  final double[] yTmp = new double[y0.length];\n\n  \n  AbstractStepInterpolator interpolator;\n  if (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {\n  final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n  rki.reinitialize(this, yTmp, yDotK, forward);\n  interpolator = rki;\n  } else {\n  interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);\n  }\n  interpolator.storeTime(t0);\n\n  \n  stepStart = t0;\n  stepSize  = forward ? step : -step;\n  for (StepHandler handler : stepHandlers) {\n  handler.reset();\n  }\n  CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n  boolean lastStep = false;\n\n  \n  while (!lastStep) {\n\n  interpolator.shift();\n\n  for (boolean loop = true; loop;) {\n\n  \n  computeDerivatives(stepStart, y, yDotK[0]);\n\n  \n  for (int k = 1; k < stages; ++k) {\n\n  for (int j = 0; j < y0.length; ++j) {\n  double sum = a[k-1][0] * yDotK[0][j];\n  for (int l = 1; l < k; ++l) {\n  sum += a[k-1][l] * yDotK[l][j];\n  }\n  yTmp[j] = y[j] + stepSize * sum;\n  }\n\n  computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n  }\n\n  \n  for (int j = 0; j < y0.length; ++j) {\n  double sum  = b[0] * yDotK[0][j];\n  for (int l = 1; l < stages; ++l) {\n  sum  += b[l] * yDotK[l][j];\n  }\n  yTmp[j] = y[j] + stepSize * sum;\n  }\n\n  \n  interpolator.storeTime(stepStart + stepSize);\n  if (manager.evaluateStep(interpolator)) {\n  final double dt = manager.getEventTime() - stepStart;\n  if (Math.abs(dt) <= Math.ulp(stepStart)) {\n  \n  \n  \n  \n  \n  loop  = false;\n  } else {\n  \n  stepSize = dt;\n  }\n  } else {\n  loop = false;\n  }\n\n  }\n\n  \n  final double nextStep = stepStart + stepSize;\n  System.arraycopy(yTmp, 0, y, 0, y0.length);\n  manager.stepAccepted(nextStep, y);\n  lastStep = manager.stop();\n\n  \n  interpolator.storeTime(nextStep);\n  for (StepHandler handler : stepHandlers) {\n  handler.handleStep(interpolator, lastStep);\n  }\n  stepStart = nextStep;\n\n  if (manager.reset(stepStart, y) && ! lastStep) {\n  \n  \n  computeDerivatives(stepStart, y, yDotK[0]);\n  }\n\n  \n  stepSize = forward ? step : -step;\n\n  }\n\n  final double stopTime = stepStart;\n  stepStart = Double.NaN;\n  stepSize  = Double.NaN;\n  return stopTime;\n\n  }",
          "fixed_method": "  public double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws DerivativeException, IntegratorException {\n\n  sanityChecks(equations, t0, y0, t, y);\n  setEquations(equations);\n  resetEvaluations();\n  final boolean forward = t > t0;\n\n  \n  final int stages = c.length + 1;\n  if (y != y0) {\n  System.arraycopy(y0, 0, y, 0, y0.length);\n  }\n  final double[][] yDotK = new double[stages][];\n  for (int i = 0; i < stages; ++i) {\n  yDotK [i] = new double[y0.length];\n  }\n  final double[] yTmp = new double[y0.length];\n\n  \n  AbstractStepInterpolator interpolator;\n  if (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {\n  final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n  rki.reinitialize(this, yTmp, yDotK, forward);\n  interpolator = rki;\n  } else {\n  interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);\n  }\n  interpolator.storeTime(t0);\n\n  \n  stepStart = t0;\n  stepSize  = forward ? step : -step;\n  for (StepHandler handler : stepHandlers) {\n  handler.reset();\n  }\n  CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n  boolean lastStep = false;\n\n  \n  while (!lastStep) {\n\n  interpolator.shift();\n\n  for (boolean loop = true; loop;) {\n\n  \n  computeDerivatives(stepStart, y, yDotK[0]);\n\n  \n  for (int k = 1; k < stages; ++k) {\n\n  for (int j = 0; j < y0.length; ++j) {\n  double sum = a[k-1][0] * yDotK[0][j];\n  for (int l = 1; l < k; ++l) {\n  sum += a[k-1][l] * yDotK[l][j];\n  }\n  yTmp[j] = y[j] + stepSize * sum;\n  }\n\n  computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n  }\n\n  \n  for (int j = 0; j < y0.length; ++j) {\n  double sum  = b[0] * yDotK[0][j];\n  for (int l = 1; l < stages; ++l) {\n  sum  += b[l] * yDotK[l][j];\n  }\n  yTmp[j] = y[j] + stepSize * sum;\n  }\n\n  \n  interpolator.storeTime(stepStart + stepSize);\n  if (manager.evaluateStep(interpolator)) {\n  final double dt = manager.getEventTime() - stepStart;\n  if (Math.abs(dt) <= Math.ulp(stepStart)) {\n  \n  \n  \n  \n  \n  interpolator.storeTime(stepStart);\n  System.arraycopy(y, 0, yTmp, 0, y0.length);\n  stepSize = 0;\n  loop  = false;\n  } else {\n  \n  stepSize = dt;\n  }\n  } else {\n  loop = false;\n  }\n\n  }\n\n  \n  final double nextStep = stepStart + stepSize;\n  System.arraycopy(yTmp, 0, y, 0, y0.length);\n  manager.stepAccepted(nextStep, y);\n  lastStep = manager.stop();\n\n  \n  interpolator.storeTime(nextStep);\n  for (StepHandler handler : stepHandlers) {\n  handler.handleStep(interpolator, lastStep);\n  }\n  stepStart = nextStep;\n\n  if (manager.reset(stepStart, y) && ! lastStep) {\n  \n  \n  computeDerivatives(stepStart, y, yDotK[0]);\n  }\n\n  \n  stepSize = forward ? step : -step;\n\n  }\n\n  final double stopTime = stepStart;\n  stepStart = Double.NaN;\n  stepSize  = Double.NaN;\n  return stopTime;\n\n  }",
          "diff": [
            "@@ -177,6 +177,9 @@",
            "                 // it is so small (much probably exactly 0 due to limited accuracy)\n",
            "                 // that the code above would fail handling it.\n",
            "                 // So we set up an artificial 0 size step by copying states\n",
            "+                interpolator.storeTime(stepStart);\n",
            "+                System.arraycopy(y, 0, yTmp, 0, y0.length);\n",
            "+                stepSize = 0;\n",
            "                 loop     = false;\n",
            "             } else {\n",
            "                 // reject the step to match exactly the next switch time\n"
          ],
          "changed_lines": 3
        }
      ]
    }
  ]
}
