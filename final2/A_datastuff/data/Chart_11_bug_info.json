{
  "bug_id": "11",
  "failed_tests": {
    "org.jfree.chart.util.junit.ShapeUtilitiesTests": [
      {
        "methodName": "testEqualGeneralPaths",
        "error": "junit.framework.AssertionFailedError",
        "message": "",
        "fail_line": "        assertFalse(ShapeUtilities.equal(g1, g2));",
        "test_source": "  public void testEqualGeneralPaths() {\n  GeneralPath g1 = new GeneralPath();\n  g1.moveTo(1.0f, 2.0f);\n  g1.lineTo(3.0f, 4.0f);\n  g1.curveTo(5.0f, 6.0f, 7.0f, 8.0f, 9.0f, 10.0f);\n  g1.quadTo(1.0f, 2.0f, 3.0f, 4.0f);\n  g1.closePath();\n  GeneralPath g2 = new GeneralPath();\n  g2.moveTo(1.0f, 2.0f);\n  g2.lineTo(3.0f, 4.0f);\n  g2.curveTo(5.0f, 6.0f, 7.0f, 8.0f, 9.0f, 10.0f);\n  g2.quadTo(1.0f, 2.0f, 3.0f, 4.0f);\n  g2.closePath();\n  assertTrue(ShapeUtilities.equal(g1, g2));\n\n  g2 = new GeneralPath();\n  g2.moveTo(11.0f, 22.0f);\n  g2.lineTo(3.0f, 4.0f);\n  g2.curveTo(5.0f, 6.0f, 7.0f, 8.0f, 9.0f, 10.0f);\n  g2.quadTo(1.0f, 2.0f, 3.0f, 4.0f);\n  g2.closePath();\n  assertFalse(ShapeUtilities.equal(g1, g2));\n\n  g2 = new GeneralPath();\n  g2.moveTo(1.0f, 2.0f);\n  g2.lineTo(33.0f, 44.0f);\n  g2.curveTo(5.0f, 6.0f, 7.0f, 8.0f, 9.0f, 10.0f);\n  g2.quadTo(1.0f, 2.0f, 3.0f, 4.0f);\n  g2.closePath();\n  assertFalse(ShapeUtilities.equal(g1, g2));\n\n  g2 = new GeneralPath();\n  g2.moveTo(1.0f, 2.0f);\n  g2.lineTo(3.0f, 4.0f);\n  g2.curveTo(55.0f, 66.0f, 77.0f, 88.0f, 99.0f, 100.0f);\n  g2.quadTo(1.0f, 2.0f, 3.0f, 4.0f);\n  g2.closePath();\n  assertFalse(ShapeUtilities.equal(g1, g2));\n\n  g2 = new GeneralPath();\n  g2.moveTo(1.0f, 2.0f);\n  g2.lineTo(3.0f, 4.0f);\n  g2.curveTo(5.0f, 6.0f, 7.0f, 8.0f, 9.0f, 10.0f);\n  g2.quadTo(11.0f, 22.0f, 33.0f, 44.0f);\n  g2.closePath();\n  assertFalse(ShapeUtilities.equal(g1, g2));\n\n  g2 = new GeneralPath();\n  g2.moveTo(1.0f, 2.0f);\n  g2.lineTo(3.0f, 4.0f);\n  g2.curveTo(5.0f, 6.0f, 7.0f, 8.0f, 9.0f, 10.0f);\n  g2.quadTo(1.0f, 2.0f, 3.0f, 4.0f);\n  g2.lineTo(3.0f, 4.0f);\n  g2.closePath();\n  assertFalse(ShapeUtilities.equal(g1, g2));\n  }",
        "stack": [
          "ShapeUtilitiesTests.testEqualGeneralPaths line 212"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/jfree/chart/util/ShapeUtilities.java",
      "buggy_full_code": "\n\npackage org.jfree.chart.util;\n\nimport java.awt.Graphics2D;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.PathIterator;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.util.Arrays;\n\n\npublic class ShapeUtilities { private ShapeUtilities() {\n    }\n\n    \n    public static Shape clone(Shape shape) {\n        if (shape instanceof Cloneable) {\n            try {\n                return (Shape) ObjectUtilities.clone(shape);\n            }\n            catch (CloneNotSupportedException cnse) {\n            }\n        }\n        Shape result = null;\n        return result;\n    }\n\n    \n    public static boolean equal(Shape s1, Shape s2) {\n        if (s1 instanceof Line2D && s2 instanceof Line2D) {\n            return equal((Line2D) s1, (Line2D) s2);\n        }\n        else if (s1 instanceof Ellipse2D && s2 instanceof Ellipse2D) {\n            return equal((Ellipse2D) s1, (Ellipse2D) s2);\n        }\n        else if (s1 instanceof Arc2D && s2 instanceof Arc2D) {\n            return equal((Arc2D) s1, (Arc2D) s2);\n        }\n        else if (s1 instanceof Polygon && s2 instanceof Polygon) {\n            return equal((Polygon) s1, (Polygon) s2);\n        }\n        else if (s1 instanceof GeneralPath && s2 instanceof GeneralPath) {\n            return equal((GeneralPath) s1, (GeneralPath) s2);\n        }\n        else {\n            \n            return ObjectUtilities.equal(s1, s2);\n        }\n    }\n\n    \n    public static boolean equal(Line2D l1, Line2D l2) {\n        if (l1 == null) {\n            return (l2 == null);\n        }\n        if (l2 == null) {\n            return false;\n        }\n        if (!l1.getP1().equals(l2.getP1())) {\n            return false;\n        }\n        if (!l1.getP2().equals(l2.getP2())) {\n            return false;\n        }\n        return true;\n    }\n\n    \n    public static boolean equal(Ellipse2D e1, Ellipse2D e2) {\n        if (e1 == null) {\n            return (e2 == null);\n        }\n        if (e2 == null) {\n            return false;\n        }\n        if (!e1.getFrame().equals(e2.getFrame())) {\n            return false;\n        }\n        return true;\n    }\n\n    \n    public static boolean equal(Arc2D a1, Arc2D a2) {\n        if (a1 == null) {\n            return (a2 == null);\n        }\n        if (a2 == null) {\n            return false;\n        }\n        if (!a1.getFrame().equals(a2.getFrame())) {\n            return false;\n        }\n        if (a1.getAngleStart() != a2.getAngleStart()) {\n            return false;\n        }\n        if (a1.getAngleExtent() != a2.getAngleExtent()) {\n            return false;\n        }\n        if (a1.getArcType() != a2.getArcType()) {\n            return false;\n        }\n        return true;\n    }\n\n    \n    public static boolean equal(Polygon p1, Polygon p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.npoints != p2.npoints) {\n            return false;\n        }\n        if (!Arrays.equals(p1.xpoints, p2.xpoints)) {\n            return false;\n        }\n        if (!Arrays.equals(p1.ypoints, p2.ypoints)) {\n            return false;\n        }\n        return true;\n    }\n\n    \n    public static boolean equal(GeneralPath p1, GeneralPath p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.getWindingRule() != p2.getWindingRule()) {\n            return false;\n        }\n        PathIterator iterator1 = p1.getPathIterator(null);\n        PathIterator iterator2 = p1.getPathIterator(null);\n        double[] d1 = new double[6];\n        double[] d2 = new double[6];\n        boolean done = iterator1.isDone() && iterator2.isDone();\n        while (!done) {\n            if (iterator1.isDone() != iterator2.isDone()) {\n                return false;\n            }\n            int seg1 = iterator1.currentSegment(d1);\n            int seg2 = iterator2.currentSegment(d2);\n            if (seg1 != seg2) {\n                return false;\n            }\n            if (!Arrays.equals(d1, d2)) {\n                return false;\n            }\n            iterator1.next();\n            iterator2.next();\n            done = iterator1.isDone() && iterator2.isDone();\n        }\n        return true;\n    }\n\n    \n    public static Shape createTranslatedShape(Shape shape, double transX, double transY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                transX, transY);\n        return transform.createTransformedShape(shape);\n    }\n\n    \n    public static Shape createTranslatedShape(Shape shape, RectangleAnchor anchor, double locationX, double locationY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        if (anchor == null) {\n            throw new IllegalArgumentException(\"Null 'anchor' argument.\");\n        }\n        Point2D anchorPoint = RectangleAnchor.coordinates(shape.getBounds2D(),\n                anchor);\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                locationX - anchorPoint.getX(), locationY - anchorPoint.getY());\n        return transform.createTransformedShape(shape);\n    }\n\n    \n    public static Shape rotateShape(Shape base, double angle, float x, float y) {\n        if (base == null) {\n            return null;\n        }\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        Shape result = rotate.createTransformedShape(base);\n        return result;\n    }\n\n    \n    public static void drawRotatedShape(Graphics2D g2, Shape shape, double angle, float x, float y) {\n\n        AffineTransform saved = g2.getTransform();\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        g2.transform(rotate);\n        g2.draw(shape);\n        g2.setTransform(saved);\n\n    }\n\n    \n    private static final float SQRT2 = (float) Math.pow(2.0, 0.5); public static Shape createDiagonalCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l - t, -l + t);\n        p0.lineTo(-l + t, -l - t);\n        p0.lineTo(0.0f, -t * SQRT2);\n        p0.lineTo(l - t, -l - t);\n        p0.lineTo(l + t, -l + t);\n        p0.lineTo(t * SQRT2, 0.0f);\n        p0.lineTo(l + t, l - t);\n        p0.lineTo(l - t, l + t);\n        p0.lineTo(0.0f, t * SQRT2);\n        p0.lineTo(-l + t, l + t);\n        p0.lineTo(-l - t, l - t);\n        p0.lineTo(-t * SQRT2, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    \n    public static Shape createRegularCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l, t);\n        p0.lineTo(-t, t);\n        p0.lineTo(-t, l);\n        p0.lineTo(t, l);\n        p0.lineTo(t, t);\n        p0.lineTo(l, t);\n        p0.lineTo(l, -t);\n        p0.lineTo(t, -t);\n        p0.lineTo(t, -l);\n        p0.lineTo(-t, -l);\n        p0.lineTo(-t, -t);\n        p0.lineTo(-l, -t);\n        p0.closePath();\n        return p0;\n    }\n\n    \n    public static Shape createDiamond(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, 0.0f);\n        p0.lineTo(0.0f, s);\n        p0.lineTo(-s, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    \n    public static Shape createUpTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, s);\n        p0.lineTo(-s, s);\n        p0.closePath();\n        return p0;\n    }\n\n    \n    public static Shape createDownTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, s);\n        p0.lineTo(s, -s);\n        p0.lineTo(-s, -s);\n        p0.closePath();\n        return p0;\n    }\n\n    \n    public static Shape createLineRegion(Line2D line, float width) {\n        GeneralPath result = new GeneralPath();\n        float x1 = (float) line.getX1();\n        float x2 = (float) line.getX2();\n        float y1 = (float) line.getY1();\n        float y2 = (float) line.getY2();\n        if ((x2 - x1) != 0.0) {\n            double theta = Math.atan((y2 - y1) / (x2 - x1));\n            float dx = (float) Math.sin(theta) * width;\n            float dy = (float) Math.cos(theta) * width;\n            result.moveTo(x1 - dx, y1 + dy);\n            result.lineTo(x1 + dx, y1 - dy);\n            result.lineTo(x2 + dx, y2 - dy);\n            result.lineTo(x2 - dx, y2 + dy);\n            result.closePath();\n        }\n        else {\n            \n            result.moveTo(x1 - width / 2.0f, y1);\n            result.lineTo(x1 + width / 2.0f, y1);\n            result.lineTo(x2 + width / 2.0f, y2);\n            result.lineTo(x2 - width / 2.0f, y2);\n            result.closePath();\n        }\n        return result;\n    }\n\n    \n    public static Point2D getPointInRectangle(double x, double y, Rectangle2D area) {\n\n        x = Math.max(area.getMinX(), Math.min(x, area.getMaxX()));\n        y = Math.max(area.getMinY(), Math.min(y, area.getMaxY()));\n        return new Point2D.Double(x, y);\n\n    }\n\n    \n    public static boolean contains(Rectangle2D rect1, Rectangle2D rect2) {\n\n        double x0 = rect1.getX();\n        double y0 = rect1.getY();\n        double x = rect2.getX();\n        double y = rect2.getY();\n        double w = rect2.getWidth();\n        double h = rect2.getHeight();\n\n        return ((x >= x0) && (y >= y0)\n                && ((x + w) <= (x0 + rect1.getWidth()))\n                && ((y + h) <= (y0 + rect1.getHeight())));\n\n    }\n\n\n    \n    public static boolean intersects(Rectangle2D rect1, Rectangle2D rect2) {\n\n      double x0 = rect1.getX();\n      double y0 = rect1.getY();\n\n      double x = rect2.getX();\n      double width = rect2.getWidth();\n      double y = rect2.getY();\n      double height = rect2.getHeight();\n      return (x + width >= x0 && y + height >= y0 && x <= x0 + rect1.getWidth()\n              && y <= y0 + rect1.getHeight());\n    }\n}\n",
      "fixed_full_code": "\n\npackage org.jfree.chart.util;\n\nimport java.awt.Graphics2D;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.PathIterator;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.util.Arrays;\n\n\npublic class ShapeUtilities { private ShapeUtilities() {\n    }\n\n    \n    public static Shape clone(Shape shape) {\n        if (shape instanceof Cloneable) {\n            try {\n                return (Shape) ObjectUtilities.clone(shape);\n            }\n            catch (CloneNotSupportedException cnse) {\n            }\n        }\n        Shape result = null;\n        return result;\n    }\n\n    \n    public static boolean equal(Shape s1, Shape s2) {\n        if (s1 instanceof Line2D && s2 instanceof Line2D) {\n            return equal((Line2D) s1, (Line2D) s2);\n        }\n        else if (s1 instanceof Ellipse2D && s2 instanceof Ellipse2D) {\n            return equal((Ellipse2D) s1, (Ellipse2D) s2);\n        }\n        else if (s1 instanceof Arc2D && s2 instanceof Arc2D) {\n            return equal((Arc2D) s1, (Arc2D) s2);\n        }\n        else if (s1 instanceof Polygon && s2 instanceof Polygon) {\n            return equal((Polygon) s1, (Polygon) s2);\n        }\n        else if (s1 instanceof GeneralPath && s2 instanceof GeneralPath) {\n            return equal((GeneralPath) s1, (GeneralPath) s2);\n        }\n        else {\n            \n            return ObjectUtilities.equal(s1, s2);\n        }\n    }\n\n    \n    public static boolean equal(Line2D l1, Line2D l2) {\n        if (l1 == null) {\n            return (l2 == null);\n        }\n        if (l2 == null) {\n            return false;\n        }\n        if (!l1.getP1().equals(l2.getP1())) {\n            return false;\n        }\n        if (!l1.getP2().equals(l2.getP2())) {\n            return false;\n        }\n        return true;\n    }\n\n    \n    public static boolean equal(Ellipse2D e1, Ellipse2D e2) {\n        if (e1 == null) {\n            return (e2 == null);\n        }\n        if (e2 == null) {\n            return false;\n        }\n        if (!e1.getFrame().equals(e2.getFrame())) {\n            return false;\n        }\n        return true;\n    }\n\n    \n    public static boolean equal(Arc2D a1, Arc2D a2) {\n        if (a1 == null) {\n            return (a2 == null);\n        }\n        if (a2 == null) {\n            return false;\n        }\n        if (!a1.getFrame().equals(a2.getFrame())) {\n            return false;\n        }\n        if (a1.getAngleStart() != a2.getAngleStart()) {\n            return false;\n        }\n        if (a1.getAngleExtent() != a2.getAngleExtent()) {\n            return false;\n        }\n        if (a1.getArcType() != a2.getArcType()) {\n            return false;\n        }\n        return true;\n    }\n\n    \n    public static boolean equal(Polygon p1, Polygon p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.npoints != p2.npoints) {\n            return false;\n        }\n        if (!Arrays.equals(p1.xpoints, p2.xpoints)) {\n            return false;\n        }\n        if (!Arrays.equals(p1.ypoints, p2.ypoints)) {\n            return false;\n        }\n        return true;\n    }\n\n    \n    public static boolean equal(GeneralPath p1, GeneralPath p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.getWindingRule() != p2.getWindingRule()) {\n            return false;\n        }\n        PathIterator iterator1 = p1.getPathIterator(null);\n        PathIterator iterator2 = p2.getPathIterator(null);\n        double[] d1 = new double[6];\n        double[] d2 = new double[6];\n        boolean done = iterator1.isDone() && iterator2.isDone();\n        while (!done) {\n            if (iterator1.isDone() != iterator2.isDone()) {\n                return false;\n            }\n            int seg1 = iterator1.currentSegment(d1);\n            int seg2 = iterator2.currentSegment(d2);\n            if (seg1 != seg2) {\n                return false;\n            }\n            if (!Arrays.equals(d1, d2)) {\n                return false;\n            }\n            iterator1.next();\n            iterator2.next();\n            done = iterator1.isDone() && iterator2.isDone();\n        }\n        return true;\n    }\n\n    \n    public static Shape createTranslatedShape(Shape shape, double transX, double transY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                transX, transY);\n        return transform.createTransformedShape(shape);\n    }\n\n    \n    public static Shape createTranslatedShape(Shape shape, RectangleAnchor anchor, double locationX, double locationY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        if (anchor == null) {\n            throw new IllegalArgumentException(\"Null 'anchor' argument.\");\n        }\n        Point2D anchorPoint = RectangleAnchor.coordinates(shape.getBounds2D(),\n                anchor);\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                locationX - anchorPoint.getX(), locationY - anchorPoint.getY());\n        return transform.createTransformedShape(shape);\n    }\n\n    \n    public static Shape rotateShape(Shape base, double angle, float x, float y) {\n        if (base == null) {\n            return null;\n        }\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        Shape result = rotate.createTransformedShape(base);\n        return result;\n    }\n\n    \n    public static void drawRotatedShape(Graphics2D g2, Shape shape, double angle, float x, float y) {\n\n        AffineTransform saved = g2.getTransform();\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        g2.transform(rotate);\n        g2.draw(shape);\n        g2.setTransform(saved);\n\n    }\n\n    \n    private static final float SQRT2 = (float) Math.pow(2.0, 0.5); public static Shape createDiagonalCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l - t, -l + t);\n        p0.lineTo(-l + t, -l - t);\n        p0.lineTo(0.0f, -t * SQRT2);\n        p0.lineTo(l - t, -l - t);\n        p0.lineTo(l + t, -l + t);\n        p0.lineTo(t * SQRT2, 0.0f);\n        p0.lineTo(l + t, l - t);\n        p0.lineTo(l - t, l + t);\n        p0.lineTo(0.0f, t * SQRT2);\n        p0.lineTo(-l + t, l + t);\n        p0.lineTo(-l - t, l - t);\n        p0.lineTo(-t * SQRT2, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    \n    public static Shape createRegularCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l, t);\n        p0.lineTo(-t, t);\n        p0.lineTo(-t, l);\n        p0.lineTo(t, l);\n        p0.lineTo(t, t);\n        p0.lineTo(l, t);\n        p0.lineTo(l, -t);\n        p0.lineTo(t, -t);\n        p0.lineTo(t, -l);\n        p0.lineTo(-t, -l);\n        p0.lineTo(-t, -t);\n        p0.lineTo(-l, -t);\n        p0.closePath();\n        return p0;\n    }\n\n    \n    public static Shape createDiamond(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, 0.0f);\n        p0.lineTo(0.0f, s);\n        p0.lineTo(-s, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    \n    public static Shape createUpTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, s);\n        p0.lineTo(-s, s);\n        p0.closePath();\n        return p0;\n    }\n\n    \n    public static Shape createDownTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, s);\n        p0.lineTo(s, -s);\n        p0.lineTo(-s, -s);\n        p0.closePath();\n        return p0;\n    }\n\n    \n    public static Shape createLineRegion(Line2D line, float width) {\n        GeneralPath result = new GeneralPath();\n        float x1 = (float) line.getX1();\n        float x2 = (float) line.getX2();\n        float y1 = (float) line.getY1();\n        float y2 = (float) line.getY2();\n        if ((x2 - x1) != 0.0) {\n            double theta = Math.atan((y2 - y1) / (x2 - x1));\n            float dx = (float) Math.sin(theta) * width;\n            float dy = (float) Math.cos(theta) * width;\n            result.moveTo(x1 - dx, y1 + dy);\n            result.lineTo(x1 + dx, y1 - dy);\n            result.lineTo(x2 + dx, y2 - dy);\n            result.lineTo(x2 - dx, y2 + dy);\n            result.closePath();\n        }\n        else {\n            \n            result.moveTo(x1 - width / 2.0f, y1);\n            result.lineTo(x1 + width / 2.0f, y1);\n            result.lineTo(x2 + width / 2.0f, y2);\n            result.lineTo(x2 - width / 2.0f, y2);\n            result.closePath();\n        }\n        return result;\n    }\n\n    \n    public static Point2D getPointInRectangle(double x, double y, Rectangle2D area) {\n\n        x = Math.max(area.getMinX(), Math.min(x, area.getMaxX()));\n        y = Math.max(area.getMinY(), Math.min(y, area.getMaxY()));\n        return new Point2D.Double(x, y);\n\n    }\n\n    \n    public static boolean contains(Rectangle2D rect1, Rectangle2D rect2) {\n\n        double x0 = rect1.getX();\n        double y0 = rect1.getY();\n        double x = rect2.getX();\n        double y = rect2.getY();\n        double w = rect2.getWidth();\n        double h = rect2.getHeight();\n\n        return ((x >= x0) && (y >= y0)\n                && ((x + w) <= (x0 + rect1.getWidth()))\n                && ((y + h) <= (y0 + rect1.getHeight())));\n\n    }\n\n\n    \n    public static boolean intersects(Rectangle2D rect1, Rectangle2D rect2) {\n\n      double x0 = rect1.getX();\n      double y0 = rect1.getY();\n\n      double x = rect2.getX();\n      double width = rect2.getWidth();\n      double y = rect2.getY();\n      double height = rect2.getHeight();\n      return (x + width >= x0 && y + height >= y0 && x <= x0 + rect1.getWidth()\n              && y <= y0 + rect1.getHeight());\n    }\n}\n",
      "buggy_signatures": [
        "public class ShapeUtilities { private ShapeUtilities()",
        "public static Shape clone(Shape shape)",
        "public static boolean equal(Shape s1, Shape s2)",
        "public static boolean equal(Line2D l1, Line2D l2)",
        "public static boolean equal(Ellipse2D e1, Ellipse2D e2)",
        "public static boolean equal(Arc2D a1, Arc2D a2)",
        "public static boolean equal(Polygon p1, Polygon p2)",
        "public static boolean equal(GeneralPath p1, GeneralPath p2)",
        "public static Shape createTranslatedShape(Shape shape, double transX, double transY)",
        "public static Shape createTranslatedShape(Shape shape, RectangleAnchor anchor, double locationX, double locationY)",
        "public static Shape rotateShape(Shape base, double angle, float x, float y)",
        "public static void drawRotatedShape(Graphics2D g2, Shape shape, double angle, float x, float y)",
        "public static Shape createRegularCross(float l, float t)",
        "public static Shape createDiamond(float s)",
        "public static Shape createUpTriangle(float s)",
        "public static Shape createDownTriangle(float s)",
        "public static Shape createLineRegion(Line2D line, float width)",
        "public static Point2D getPointInRectangle(double x, double y, Rectangle2D area)",
        "public static boolean contains(Rectangle2D rect1, Rectangle2D rect2)",
        "public static boolean intersects(Rectangle2D rect1, Rectangle2D rect2)"
      ],
      "fixed_signatures": [
        "public class ShapeUtilities { private ShapeUtilities()",
        "public static Shape clone(Shape shape)",
        "public static boolean equal(Shape s1, Shape s2)",
        "public static boolean equal(Line2D l1, Line2D l2)",
        "public static boolean equal(Ellipse2D e1, Ellipse2D e2)",
        "public static boolean equal(Arc2D a1, Arc2D a2)",
        "public static boolean equal(Polygon p1, Polygon p2)",
        "public static boolean equal(GeneralPath p1, GeneralPath p2)",
        "public static Shape createTranslatedShape(Shape shape, double transX, double transY)",
        "public static Shape createTranslatedShape(Shape shape, RectangleAnchor anchor, double locationX, double locationY)",
        "public static Shape rotateShape(Shape base, double angle, float x, float y)",
        "public static void drawRotatedShape(Graphics2D g2, Shape shape, double angle, float x, float y)",
        "public static Shape createRegularCross(float l, float t)",
        "public static Shape createDiamond(float s)",
        "public static Shape createUpTriangle(float s)",
        "public static Shape createDownTriangle(float s)",
        "public static Shape createLineRegion(Line2D line, float width)",
        "public static Point2D getPointInRectangle(double x, double y, Rectangle2D area)",
        "public static boolean contains(Rectangle2D rect1, Rectangle2D rect2)",
        "public static boolean intersects(Rectangle2D rect1, Rectangle2D rect2)"
      ],
      "methods": [
        {
          "buggy_method": "  public static boolean equal(GeneralPath p1, GeneralPath p2) {\n  if (p1 == null) {\n  return (p2 == null);\n  }\n  if (p2 == null) {\n  return false;\n  }\n  if (p1.getWindingRule() != p2.getWindingRule()) {\n  return false;\n  }\n  PathIterator iterator1 = p1.getPathIterator(null);\n  PathIterator iterator2 = p1.getPathIterator(null);\n  double[] d1 = new double[6];\n  double[] d2 = new double[6];\n  boolean done = iterator1.isDone() && iterator2.isDone();\n  while (!done) {\n  if (iterator1.isDone() != iterator2.isDone()) {\n  return false;\n  }\n  int seg1 = iterator1.currentSegment(d1);\n  int seg2 = iterator2.currentSegment(d2);\n  if (seg1 != seg2) {\n  return false;\n  }\n  if (!Arrays.equals(d1, d2)) {\n  return false;\n  }\n  iterator1.next();\n  iterator2.next();\n  done = iterator1.isDone() && iterator2.isDone();\n  }\n  return true;\n  }",
          "fixed_method": "  public static boolean equal(GeneralPath p1, GeneralPath p2) {\n  if (p1 == null) {\n  return (p2 == null);\n  }\n  if (p2 == null) {\n  return false;\n  }\n  if (p1.getWindingRule() != p2.getWindingRule()) {\n  return false;\n  }\n  PathIterator iterator1 = p1.getPathIterator(null);\n  PathIterator iterator2 = p2.getPathIterator(null);\n  double[] d1 = new double[6];\n  double[] d2 = new double[6];\n  boolean done = iterator1.isDone() && iterator2.isDone();\n  while (!done) {\n  if (iterator1.isDone() != iterator2.isDone()) {\n  return false;\n  }\n  int seg1 = iterator1.currentSegment(d1);\n  int seg2 = iterator2.currentSegment(d2);\n  if (seg1 != seg2) {\n  return false;\n  }\n  if (!Arrays.equals(d1, d2)) {\n  return false;\n  }\n  iterator1.next();\n  iterator2.next();\n  done = iterator1.isDone() && iterator2.isDone();\n  }\n  return true;\n  }",
          "diff": [
            "@@ -272,7 +272,7 @@",
            "             return false;\n",
            "         }\n",
            "         PathIterator iterator1 = p1.getPathIterator(null);\n",
            "-        PathIterator iterator2 = p1.getPathIterator(null);\n",
            "+        PathIterator iterator2 = p2.getPathIterator(null);\n",
            "         double[] d1 = new double[6];\n",
            "         double[] d2 = new double[6];\n",
            "         boolean done = iterator1.isDone() && iterator2.isDone();\n"
          ],
          "changed_lines": 2
        }
      ]
    }
  ]
}
