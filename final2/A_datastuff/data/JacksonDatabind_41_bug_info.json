{
  "bug_id": "41",
  "failed_tests": {
    "com.fasterxml.jackson.databind.interop.DeprecatedTypeHandling1102Test": [
      {
        "methodName": "testDeprecatedTypeResolution",
        "error": "java.lang.IllegalArgumentException",
        "message": "Unrecognized Type: [null]",
        "fail_line": "        JavaType t2 = tf.constructType(Point.class, (Class<?>) null);",
        "test_source": "  public void testDeprecatedTypeResolution() throws Exception {\n  TypeFactory tf = MAPPER.getTypeFactory();\n\n  // first, with real (if irrelevant) context\n  JavaType t = tf.constructType(Point.class, getClass());\n  assertEquals(Point.class, t.getRawClass());\n\n  // and then missing context\n  JavaType t2 = tf.constructType(Point.class, (Class<?>) null);\n  assertEquals(Point.class, t2.getRawClass());\n\n  JavaType ctxt = tf.constructType(getClass());\n  JavaType t3 = tf.constructType(Point.class, ctxt);\n  assertEquals(Point.class, t3.getRawClass());\n  }",
        "stack": [
          "TypeFactory._fromAny line 1109, TypeFactory.constructType line 566, TypeFactory.constructType line 602, DeprecatedTypeHandling1102Test.testDeprecatedTypeResolution line 102"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "com/fasterxml/jackson/databind/type/TypeFactory.java",
      "buggy_full_code": "package com.fasterxml.jackson.databind.type;\n\nimport java.util.*;\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.lang.reflect.*;\n\nimport com.fasterxml.jackson.core.type.TypeReference;\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.util.ArrayBuilders;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\nimport com.fasterxml.jackson.databind.util.LRUMap;\n\n\n@SuppressWarnings({\"rawtypes\" })\npublic final class TypeFactory implements java.io.Serializable { private static final long serialVersionUID = 1L; private final static JavaType[] NO_TYPES = new JavaType[0]; protected final static TypeFactory instance = new TypeFactory(); protected final static TypeBindings EMPTY_BINDINGS = TypeBindings.emptyBindings(); private final static Class<?> CLS_STRING = String.class; private final static Class<?> CLS_OBJECT = Object.class; private final static Class<?> CLS_COMPARABLE = Comparable.class; private final static Class<?> CLS_CLASS = Class.class; private final static Class<?> CLS_ENUM = Enum.class; private final static Class<?> CLS_BOOL = Boolean.TYPE; private final static Class<?> CLS_INT = Integer.TYPE; private final static Class<?> CLS_LONG = Long.TYPE; protected final static SimpleType CORE_TYPE_BOOL = new SimpleType(CLS_BOOL); protected final static SimpleType CORE_TYPE_INT = new SimpleType(CLS_INT); protected final static SimpleType CORE_TYPE_LONG = new SimpleType(CLS_LONG); protected final static SimpleType CORE_TYPE_STRING = new SimpleType(CLS_STRING); protected final static SimpleType CORE_TYPE_OBJECT = new SimpleType(CLS_OBJECT); protected final static SimpleType CORE_TYPE_COMPARABLE = new SimpleType(CLS_COMPARABLE); protected final static SimpleType CORE_TYPE_ENUM = new SimpleType(CLS_ENUM); protected final static SimpleType CORE_TYPE_CLASS = new SimpleType(CLS_CLASS); protected final LRUMap<Class<?>, JavaType> _typeCache = new LRUMap<Class<?>, JavaType>(16, 100); protected final TypeModifier[] _modifiers; protected final TypeParser _parser; protected final ClassLoader _classLoader; private TypeFactory() {\n        _parser = new TypeParser(this);\n        _modifiers = null;\n        _classLoader = null;\n    }\n\n    protected TypeFactory(TypeParser p, TypeModifier[] mods) {\n        this(p, mods, null);\n    }\n    \n    protected TypeFactory(TypeParser p, TypeModifier[] mods, ClassLoader classLoader) {\n        \n        _parser = p.withFactory(this);\n        _modifiers = mods;\n        _classLoader = classLoader;\n    }\n\n    public TypeFactory withModifier(TypeModifier mod) {\n        if (mod == null) { \n            return new TypeFactory(_parser, _modifiers, _classLoader);\n        }\n        if (_modifiers == null) {\n            return new TypeFactory(_parser, new TypeModifier[] { mod }, _classLoader);\n        }\n        return new TypeFactory(_parser, ArrayBuilders.insertInListNoDup(_modifiers, mod), _classLoader);\n    }\n    \n    public TypeFactory withClassLoader(ClassLoader classLoader) {\n        return new TypeFactory(_parser, _modifiers, classLoader);\n    }\n\n    \n    public static TypeFactory defaultInstance() { return instance; }\n\n    \n    public void clearCache() {\n        _typeCache.clear();\n    }\n    \n    \n    public ClassLoader getClassLoader() {\n        return _classLoader;\n    }\n    \n    \n    \n    \n    public static JavaType unknownType() {\n        return defaultInstance()._unknownType();\n    }\n\n    \n    public static Class<?> rawClass(Type t) {\n        if (t instanceof Class<?>) {\n            return (Class<?>) t;\n        }\n        \n        return defaultInstance().constructType(t).getRawClass();\n    }\n\n    \n\n    \n    public Class<?> findClass(String className) throws ClassNotFoundException {\n        if (className.indexOf('.') < 0) {\n            Class<?> prim = _findPrimitive(className);\n            if (prim != null) {\n                return prim;\n            }\n        }\n        \n        Throwable prob = null;\n        ClassLoader loader = this.getClassLoader();\n        if (loader == null) {\n          loader = \tThread.currentThread().getContextClassLoader();\n        }\n        if (loader != null) {\n            try {\n                return classForName(className, true, loader);\n            } catch (Exception e) {\n                prob = ClassUtil.getRootCause(e);\n            }\n        }\n        try {\n            return classForName(className);\n        } catch (Exception e) {\n            if (prob == null) {\n                prob = ClassUtil.getRootCause(e);\n            }\n        }\n        if (prob instanceof RuntimeException) {\n            throw (RuntimeException) prob;\n        }\n        throw new ClassNotFoundException(prob.getMessage(), prob);\n    }\n    \n    protected Class<?> classForName(String name, boolean initialize, ClassLoader loader) throws ClassNotFoundException {\n    \treturn Class.forName(name, true, loader);\n    }\n    \n    protected Class<?> classForName(String name) throws ClassNotFoundException {\n        return Class.forName(name);\n    }\n\n    protected Class<?> _findPrimitive(String className) {\n        if (\"int\".equals(className)) return Integer.TYPE;\n        if (\"long\".equals(className)) return Long.TYPE;\n        if (\"float\".equals(className)) return Float.TYPE;\n        if (\"double\".equals(className)) return Double.TYPE;\n        if (\"boolean\".equals(className)) return Boolean.TYPE;\n        if (\"byte\".equals(className)) return Byte.TYPE;\n        if (\"char\".equals(className)) return Character.TYPE;\n        if (\"short\".equals(className)) return Short.TYPE;\n        if (\"void\".equals(className)) return Void.TYPE;\n        return null;\n    }\n    \n    \n\n    \n    public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass) {\n        \n        final Class<?> rawBase = baseType.getRawClass();\n        if (rawBase == subclass) {\n            return baseType;\n        }\n        \n        JavaType newType;\n\n        \n        do { \n            if (rawBase == Object.class) {\n                newType = _fromClass(null, subclass, TypeBindings.emptyBindings());\n                break;\n            }\n            if (!rawBase.isAssignableFrom(subclass)) {\n                throw new IllegalArgumentException(String.format(\n                        \"Class %s not subtype of %s\", subclass.getName(), baseType));\n            }\n            \n\n            \n            if (baseType.getBindings().isEmpty()) {\n                newType = _fromClass(null, subclass, TypeBindings.emptyBindings());     \n                break;\n            }\n            \n            if (baseType.isContainerType()) {\n                if (baseType.isMapLikeType()) {\n                    if ((subclass == HashMap.class)\n                            || (subclass == LinkedHashMap.class)\n                            || (subclass == EnumMap.class)\n                            || (subclass == TreeMap.class)) {\n                        newType = _fromClass(null, subclass,\n                                TypeBindings.create(subclass, baseType.getKeyType(), baseType.getContentType()));\n                        break;\n                    }\n                } else if (baseType.isCollectionLikeType()) {\n                    if ((subclass == ArrayList.class)\n                            || (subclass == LinkedList.class)\n                            || (subclass == HashSet.class)\n                            || (subclass == TreeSet.class)) {\n                        newType = _fromClass(null, subclass,\n                                TypeBindings.create(subclass, baseType.getContentType()));\n                        break;\n                    }\n                    \n                    \n                    if (rawBase == EnumSet.class) {\n                        return baseType;\n                    }\n                }\n            }\n            \n            if (subclass.getTypeParameters().length == 0) {\n                newType = _fromClass(null, subclass, TypeBindings.emptyBindings());     \n                break;\n            }\n\n            \n            \n\n            \n            \n            \n            \n            \n            if (baseType.isInterface()) {\n                newType = baseType.refine(subclass, TypeBindings.emptyBindings(), null,\n                        new JavaType[] { baseType });\n            } else {\n                newType = baseType.refine(subclass, TypeBindings.emptyBindings(), baseType,\n                        NO_TYPES);\n            }\n            \n            if (newType == null) {\n                \n                \n                newType = _fromClass(null, subclass, TypeBindings.emptyBindings());        \n            }\n        } while (false);\n\n        \n\n        return newType;\n\n        \n        \n        \n    }\n\n    \n    public JavaType constructGeneralizedType(JavaType baseType, Class<?> superClass) {\n        \n        final Class<?> rawBase = baseType.getRawClass();\n        if (rawBase == superClass) {\n            return baseType;\n        }\n        JavaType superType = baseType.findSuperType(superClass);\n        if (superType == null) {\n            \n            if (!superClass.isAssignableFrom(rawBase)) {\n                throw new IllegalArgumentException(String.format(\n                        \"Class %s not a super-type of %s\", superClass.getName(), baseType));\n            }\n            \n            throw new IllegalArgumentException(String.format(\n                    \"Internal error: class %s not included as super-type for %s\",\n                    superClass.getName(), baseType));\n        }\n        return superType;\n    }\n\n    \n    public JavaType constructFromCanonical(String canonical) throws IllegalArgumentException {\n        return _parser.parse(canonical);\n    }\n\n    \n    public JavaType[] findTypeParameters(JavaType type, Class<?> expType) {\n        JavaType match = type.findSuperType(expType);\n        if (match == null) {\n            return NO_TYPES;\n        }\n        return match.getBindings().typeParameterArray();\n    }\n\n    \n    @Deprecated \n    public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType, TypeBindings bindings) {\n        return findTypeParameters(constructType(clz, bindings), expType);\n    }\n    \n    \n    @Deprecated \n    public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType) {\n        return findTypeParameters(constructType(clz), expType);\n    }\n\n    \n    public JavaType moreSpecificType(JavaType type1, JavaType type2) {\n        if (type1 == null) {\n            return type2;\n        }\n        if (type2 == null) {\n            return type1;\n        }\n        Class<?> raw1 = type1.getRawClass();\n        Class<?> raw2 = type2.getRawClass();\n        if (raw1 == raw2) {\n            return type1;\n        }\n        \n        if (raw1.isAssignableFrom(raw2)) {\n            return type2;\n        }\n        return type1;\n    }\n    \n    \n\n    public JavaType constructType(Type type) {\n        return _fromAny(null, type, EMPTY_BINDINGS);\n    }\n\n    public JavaType constructType(Type type, TypeBindings bindings) {\n        return _fromAny(null, type, bindings);\n    }\n    \n    public JavaType constructType(TypeReference<?> typeRef) {\n        \n        return _fromAny(null, typeRef.getType(), EMPTY_BINDINGS);\n\n        \n        \n\n        \n    }\n\n    \n    @Deprecated\n    public JavaType constructType(Type type, Class<?> contextClass) {\n        return constructType(type, constructType(contextClass));\n    }\n\n    \n    @Deprecated\n    public JavaType constructType(Type type, JavaType contextType) {\n        return _fromAny(null, type, contextType.getBindings());\n    }\n\n    \n\n    \n    public ArrayType constructArrayType(Class<?> elementType) {\n        return ArrayType.construct(_fromAny(null, elementType, null), null);\n    }\n    \n    \n    public ArrayType constructArrayType(JavaType elementType) {\n        return ArrayType.construct(elementType, null);\n    }\n\n    \n    public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, Class<?> elementClass) {\n        return constructCollectionType(collectionClass,\n                _fromClass(null, elementClass, EMPTY_BINDINGS));\n    }\n\n    \n    public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, JavaType elementType) {\n        \n        \n        return (CollectionType) _fromClass(null, collectionClass,\n                TypeBindings.create(collectionClass, elementType));\n    }\n\n    \n    public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, Class<?> elementClass) {\n        return constructCollectionLikeType(collectionClass,\n                _fromClass(null, elementClass, EMPTY_BINDINGS));\n    }\n    \n    \n    public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, JavaType elementType) {\n        JavaType type = _fromClass(null, collectionClass,\n                TypeBindings.createIfNeeded(collectionClass, elementType));\n        if (type instanceof CollectionLikeType) {\n            return (CollectionLikeType) type;\n        }\n        return CollectionLikeType.upgradeFrom(type, elementType);\n    }\n\n    \n    public MapType constructMapType(Class<? extends Map> mapClass, Class<?> keyClass, Class<?> valueClass) {\n        JavaType kt, vt;\n        if (mapClass == Properties.class) {\n            kt = vt = CORE_TYPE_STRING;\n        } else {\n            kt = _fromClass(null, keyClass, EMPTY_BINDINGS);\n            vt = _fromClass(null, valueClass, EMPTY_BINDINGS);\n        }\n        return constructMapType(mapClass, kt, vt);\n    }\n\n    \n    public MapType constructMapType(Class<? extends Map> mapClass, JavaType keyType, JavaType valueType) {\n        return (MapType) _fromClass(null, mapClass,\n                TypeBindings.create(mapClass, new JavaType[] {\n                        keyType, valueType\n                }));\n    }\n\n    \n    public MapLikeType constructMapLikeType(Class<?> mapClass, Class<?> keyClass, Class<?> valueClass) {\n        return constructMapLikeType(mapClass,\n                _fromClass(null, keyClass, EMPTY_BINDINGS),\n                _fromClass(null, valueClass, EMPTY_BINDINGS));\n    }\n\n    \n    public MapLikeType constructMapLikeType(Class<?> mapClass, JavaType keyType, JavaType valueType) {\n        \n        \n        JavaType type = _fromClass(null, mapClass,\n                TypeBindings.createIfNeeded(mapClass, new JavaType[] { keyType, valueType }));\n        if (type instanceof MapLikeType) {\n            return (MapLikeType) type;\n        }\n        return MapLikeType.upgradeFrom(type, keyType, valueType);\n    }\n\n    \n    public JavaType constructSimpleType(Class<?> rawType, JavaType[] parameterTypes) {\n        return _fromClass(null, rawType, TypeBindings.create(rawType, parameterTypes));\n    }\n\n    \n    @Deprecated\n    public JavaType constructSimpleType(Class<?> rawType, Class<?> parameterTarget, JavaType[] parameterTypes) {\n        return constructSimpleType(rawType, parameterTypes);\n    } \n\n    \n    public JavaType constructReferenceType(Class<?> rawType, JavaType referredType) {\n        return ReferenceType.construct(rawType, null, \n                null, null, \n                referredType);\n    }\n\n    \n    public JavaType uncheckedSimpleType(Class<?> cls) {\n        \n        return _constructSimple(cls, EMPTY_BINDINGS, null, null);\n    }\n\n    \n    public JavaType constructParametricType(Class<?> parametrized, Class<?>... parameterClasses) {\n        int len = parameterClasses.length;\n        JavaType[] pt = new JavaType[len];\n        for (int i = 0; i < len; ++i) {\n            pt[i] = _fromClass(null, parameterClasses[i], null);\n        }\n        return constructParametricType(parametrized, pt);\n    }\n\n    \n    public JavaType constructParametricType(Class<?> rawType, JavaType... parameterTypes) {\n        return _fromClass(null, rawType, TypeBindings.create(rawType, parameterTypes));\n    }\n\n    \n    public JavaType constructParametrizedType(Class<?> parametrized, Class<?> parametersFor, JavaType... parameterTypes) {\n        return constructParametricType(parametrized, parameterTypes);\n    }\n\n    \n    public JavaType constructParametrizedType(Class<?> parametrized, Class<?> parametersFor, Class<?>... parameterClasses) {\n        return constructParametricType(parametrized, parameterClasses);\n    }\n\n    \n\n    \n    public CollectionType constructRawCollectionType(Class<? extends Collection> collectionClass) {\n        return constructCollectionType(collectionClass, unknownType());\n    }\n\n    \n    public CollectionLikeType constructRawCollectionLikeType(Class<?> collectionClass) {\n        return constructCollectionLikeType(collectionClass, unknownType());\n    }\n\n    \n    public MapType constructRawMapType(Class<? extends Map> mapClass) {\n        return constructMapType(mapClass, unknownType(), unknownType());\n    }\n\n    \n    public MapLikeType constructRawMapLikeType(Class<?> mapClass) {\n        return constructMapLikeType(mapClass, unknownType(), unknownType());\n    }\n\n    \n\n    private JavaType _mapType(Class<?> rawClass, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) {\n        JavaType kt, vt;\n        \n        \n        if (rawClass == Properties.class) {\n            kt = vt = CORE_TYPE_STRING;\n        } else {\n            List<JavaType> typeParams = bindings.getTypeParameters();\n            \n            switch (typeParams.size()) {\n            case 0: \n                kt = vt = _unknownType();\n                break;\n            case 2:\n                kt = typeParams.get(0);\n                vt = typeParams.get(1);\n                break;\n            default:\n                throw new IllegalArgumentException(\"Strange Map type \"+rawClass.getName()+\": can not determine type parameters\");\n            }\n        }\n        return MapType.construct(rawClass, bindings, superClass, superInterfaces, kt, vt);\n    }\n\n    private JavaType _collectionType(Class<?> rawClass, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) {\n        List<JavaType> typeParams = bindings.getTypeParameters();\n        \n        JavaType ct;\n        if (typeParams.isEmpty()) {\n            ct = _unknownType();\n        } else if (typeParams.size() == 1) {\n            ct = typeParams.get(0);\n        } else {\n            throw new IllegalArgumentException(\"Strange Collection type \"+rawClass.getName()+\": can not determine type parameters\");\n        }\n        return CollectionType.construct(rawClass, bindings, superClass, superInterfaces, ct);\n    }\n\n    private JavaType _referenceType(Class<?> rawClass, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) {\n        List<JavaType> typeParams = bindings.getTypeParameters();\n        \n        JavaType ct;\n        if (typeParams.isEmpty()) {\n            ct = _unknownType();\n        } else if (typeParams.size() == 1) {\n            ct = typeParams.get(0);\n        } else {\n            throw new IllegalArgumentException(\"Strange Reference type \"+rawClass.getName()+\": can not determine type parameters\");\n        }\n        return ReferenceType.construct(rawClass, bindings, superClass, superInterfaces, ct);\n    }\n\n    \n    protected JavaType _constructSimple(Class<?> raw, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) {\n        if (bindings.isEmpty()) {\n            JavaType result = _findWellKnownSimple(raw);\n            if (result != null) {\n                return result;\n            }\n        }\n        return _newSimpleType(raw, bindings, superClass, superInterfaces);\n    }\n\n    \n    protected JavaType _newSimpleType(Class<?> raw, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) {\n        return new SimpleType(raw, bindings, superClass, superInterfaces);\n    }\n\n    protected JavaType _unknownType() {\n        \n        return CORE_TYPE_OBJECT;\n    }\n\n    \n    protected JavaType _findWellKnownSimple(Class<?> clz) {\n        if (clz.isPrimitive()) {\n            if (clz == CLS_BOOL) return CORE_TYPE_BOOL;\n            if (clz == CLS_INT) return CORE_TYPE_INT;\n            if (clz == CLS_LONG) return CORE_TYPE_LONG;\n        } else {\n            if (clz == CLS_STRING) return CORE_TYPE_STRING;\n            if (clz == CLS_OBJECT) return CORE_TYPE_OBJECT; \n        }\n        return null;\n    }\n\n    \n\n    \n    protected JavaType _fromAny(ClassStack context, Type type, TypeBindings bindings) {\n        JavaType resultType;\n\n        \n        if (type instanceof Class<?>) {\n            \n            resultType = _fromClass(context, (Class<?>) type, EMPTY_BINDINGS);\n        }\n        \n        else if (type instanceof ParameterizedType) {\n            resultType = _fromParamType(context, (ParameterizedType) type, bindings);\n        }\n        else if (type instanceof JavaType) { \n            \n            return (JavaType) type;\n        }\n        else if (type instanceof GenericArrayType) {\n            resultType = _fromArrayType(context, (GenericArrayType) type, bindings);\n        }\n        else if (type instanceof TypeVariable<?>) {\n            resultType = _fromVariable(context, (TypeVariable<?>) type, bindings);\n        }\n        else if (type instanceof WildcardType) {\n            resultType = _fromWildcard(context, (WildcardType) type, bindings);\n        } else {\n            \n            throw new IllegalArgumentException(\"Unrecognized Type: \"+((type == null) ? \"[null]\" : type.toString()));\n        }\n        \n        if (_modifiers != null && !resultType.isContainerType()) {\n            TypeBindings b = resultType.getBindings();\n            if (b == null) {\n                b = EMPTY_BINDINGS;\n            }\n            for (TypeModifier mod : _modifiers) {\n                resultType = mod.modifyType(resultType, type, b, this);\n            }\n        }\n        return resultType;\n    }\n\n    \n    protected JavaType _fromClass(ClassStack context, Class<?> rawType, TypeBindings bindings) {\n        \n        JavaType result = _findWellKnownSimple(rawType);\n        if (result != null) {\n            return result;\n        }\n        \n        \n        \n        boolean cachable = (bindings == null) || bindings.isEmpty();\n        if (cachable) {\n            result = _typeCache.get(rawType); \n            if (result != null) {\n                return result;\n            }\n        }\n\n        \n        if (context == null) {\n            context = new ClassStack(rawType);\n        } else {\n            ClassStack prev = context.find(rawType);\n            if (prev != null) {\n                \n                ResolvedRecursiveType selfRef = new ResolvedRecursiveType(rawType, EMPTY_BINDINGS);\n                prev.addSelfReference(selfRef);\n                return selfRef;\n            }\n            \n            context = context.child(rawType);\n        }\n\n        \n        if (rawType.isArray()) {\n            result = ArrayType.construct(_fromAny(context, rawType.getComponentType(), bindings),\n                    bindings);\n        } else {\n            \n            \n            JavaType superClass;\n            JavaType[] superInterfaces;\n\n            if (rawType.isInterface()) {\n                superClass = null;\n                superInterfaces = _resolveSuperInterfaces(context, rawType, bindings);\n            } else {\n                \n                superClass = _resolveSuperClass(context, rawType, bindings);\n                superInterfaces = _resolveSuperInterfaces(context, rawType, bindings);\n            }\n\n            \n            if (rawType == Properties.class) {\n                result = MapType.construct(rawType, bindings, superClass, superInterfaces,\n                        CORE_TYPE_STRING, CORE_TYPE_STRING);\n            }\n            \n            \n            else if (superClass != null) {\n                result = superClass.refine(rawType, bindings, superClass, superInterfaces);\n            }\n            \n            if (result == null) {\n                result = _fromWellKnownClass(context, rawType, bindings, superClass, superInterfaces); \n                if (result == null) {\n                    result = _fromWellKnownInterface(context, rawType, bindings, superClass, superInterfaces);\n                    if (result == null) {\n                        \n                        result = _newSimpleType(rawType, bindings, superClass, superInterfaces);\n                    }\n                }\n            }\n        }\n        context.resolveSelfReferences(result);\n\n        if (cachable) {\n            _typeCache.putIfAbsent(rawType, result); \n        }\n        return result;\n    }\n\n    protected JavaType _resolveSuperClass(ClassStack context, Class<?> rawType, TypeBindings parentBindings) {\n        Type parent = ClassUtil.getGenericSuperclass(rawType);\n        if (parent == null) {\n            return null;\n        }\n        return _fromAny(context, parent, parentBindings);\n    }\n\n    protected JavaType[] _resolveSuperInterfaces(ClassStack context, Class<?> rawType, TypeBindings parentBindings) {\n        Type[] types = ClassUtil.getGenericInterfaces(rawType);\n        if (types == null || types.length == 0) {\n            return NO_TYPES;\n        }\n        int len = types.length;\n        JavaType[] resolved = new JavaType[len];\n        for (int i = 0; i < len; ++i) {\n            Type type = types[i];\n            resolved[i] = _fromAny(context, type, parentBindings);\n        }\n        return resolved;\n    }\n\n    \n    protected JavaType _fromWellKnownClass(ClassStack context, Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) {\n        \n        if (rawType == Map.class) {\n            return _mapType(rawType, bindings, superClass, superInterfaces);\n        }\n        if (rawType == Collection.class) {\n            return _collectionType(rawType, bindings, superClass, superInterfaces);\n        }\n        \n        if (rawType == AtomicReference.class) {\n            return _referenceType(rawType, bindings, superClass, superInterfaces);\n        }\n        \n        \n        \n        \n        return null;\n    }\n\n    protected JavaType _fromWellKnownInterface(ClassStack context, Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) {\n        \n        \n        final int intCount = superInterfaces.length;\n\n        for (int i = 0; i < intCount; ++i) {\n            JavaType result = superInterfaces[i].refine(rawType, bindings, superClass, superInterfaces);\n            if (result != null) {\n                return result;\n            }\n        }\n        return null;\n    }\n\n    \n    protected JavaType _fromParamType(ClassStack context, ParameterizedType ptype, TypeBindings parentBindings) {\n        \n        Class<?> rawType = (Class<?>) ptype.getRawType();\n\n        \n        \n        if (rawType == CLS_ENUM) {\n            return CORE_TYPE_ENUM;\n        }\n        if (rawType == CLS_COMPARABLE) {\n            return CORE_TYPE_COMPARABLE;\n        }\n        if (rawType == CLS_CLASS) {\n            return CORE_TYPE_CLASS;\n        }\n\n        \n        \n        \n        Type[] args = ptype.getActualTypeArguments();\n        int paramCount = (args == null) ? 0 : args.length;\n        JavaType[] pt;\n        TypeBindings newBindings;        \n\n        if (paramCount == 0) {\n            newBindings = EMPTY_BINDINGS;\n        } else {\n            pt = new JavaType[paramCount];\n            for (int i = 0; i < paramCount; ++i) {\n                pt[i] = _fromAny(context, args[i], parentBindings);\n            }\n            newBindings = TypeBindings.create(rawType, pt);\n        }\n        return _fromClass(context, rawType, newBindings);\n    }\n\n    protected JavaType _fromArrayType(ClassStack context, GenericArrayType type, TypeBindings bindings) {\n        JavaType elementType = _fromAny(context, type.getGenericComponentType(), bindings);\n        return ArrayType.construct(elementType, bindings);\n    }\n\n    protected JavaType _fromVariable(ClassStack context, TypeVariable<?> var, TypeBindings bindings) {\n        \n        final String name = var.getName();\n        JavaType type = bindings.findBoundType(name);\n        if (type != null) {\n            return type;\n        }\n        \n        \n        if (bindings.hasUnbound(name)) {\n            return CORE_TYPE_OBJECT;\n        }\n        bindings = bindings.withUnboundVariable(name);\n\n        Type[] bounds = var.getBounds();\n        return _fromAny(context, bounds[0], bindings);\n    }\n\n    protected JavaType _fromWildcard(ClassStack context, WildcardType type, TypeBindings bindings) {\n        \n        return _fromAny(context, type.getUpperBounds()[0], bindings);\n    }\n}\n",
      "fixed_full_code": "package com.fasterxml.jackson.databind.type;\n\nimport java.util.*;\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.lang.reflect.*;\n\nimport com.fasterxml.jackson.core.type.TypeReference;\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.util.ArrayBuilders;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\nimport com.fasterxml.jackson.databind.util.LRUMap;\n\n\n@SuppressWarnings({\"rawtypes\" })\npublic final class TypeFactory implements java.io.Serializable { private static final long serialVersionUID = 1L; private final static JavaType[] NO_TYPES = new JavaType[0]; protected final static TypeFactory instance = new TypeFactory(); protected final static TypeBindings EMPTY_BINDINGS = TypeBindings.emptyBindings(); private final static Class<?> CLS_STRING = String.class; private final static Class<?> CLS_OBJECT = Object.class; private final static Class<?> CLS_COMPARABLE = Comparable.class; private final static Class<?> CLS_CLASS = Class.class; private final static Class<?> CLS_ENUM = Enum.class; private final static Class<?> CLS_BOOL = Boolean.TYPE; private final static Class<?> CLS_INT = Integer.TYPE; private final static Class<?> CLS_LONG = Long.TYPE; protected final static SimpleType CORE_TYPE_BOOL = new SimpleType(CLS_BOOL); protected final static SimpleType CORE_TYPE_INT = new SimpleType(CLS_INT); protected final static SimpleType CORE_TYPE_LONG = new SimpleType(CLS_LONG); protected final static SimpleType CORE_TYPE_STRING = new SimpleType(CLS_STRING); protected final static SimpleType CORE_TYPE_OBJECT = new SimpleType(CLS_OBJECT); protected final static SimpleType CORE_TYPE_COMPARABLE = new SimpleType(CLS_COMPARABLE); protected final static SimpleType CORE_TYPE_ENUM = new SimpleType(CLS_ENUM); protected final static SimpleType CORE_TYPE_CLASS = new SimpleType(CLS_CLASS); protected final LRUMap<Class<?>, JavaType> _typeCache = new LRUMap<Class<?>, JavaType>(16, 100); protected final TypeModifier[] _modifiers; protected final TypeParser _parser; protected final ClassLoader _classLoader; private TypeFactory() {\n        _parser = new TypeParser(this);\n        _modifiers = null;\n        _classLoader = null;\n    }\n\n    protected TypeFactory(TypeParser p, TypeModifier[] mods) {\n        this(p, mods, null);\n    }\n    \n    protected TypeFactory(TypeParser p, TypeModifier[] mods, ClassLoader classLoader) {\n        \n        _parser = p.withFactory(this);\n        _modifiers = mods;\n        _classLoader = classLoader;\n    }\n\n    public TypeFactory withModifier(TypeModifier mod) {\n        if (mod == null) { \n            return new TypeFactory(_parser, _modifiers, _classLoader);\n        }\n        if (_modifiers == null) {\n            return new TypeFactory(_parser, new TypeModifier[] { mod }, _classLoader);\n        }\n        return new TypeFactory(_parser, ArrayBuilders.insertInListNoDup(_modifiers, mod), _classLoader);\n    }\n    \n    public TypeFactory withClassLoader(ClassLoader classLoader) {\n        return new TypeFactory(_parser, _modifiers, classLoader);\n    }\n\n    \n    public static TypeFactory defaultInstance() { return instance; }\n\n    \n    public void clearCache() {\n        _typeCache.clear();\n    }\n    \n    \n    public ClassLoader getClassLoader() {\n        return _classLoader;\n    }\n    \n    \n    \n    \n    public static JavaType unknownType() {\n        return defaultInstance()._unknownType();\n    }\n\n    \n    public static Class<?> rawClass(Type t) {\n        if (t instanceof Class<?>) {\n            return (Class<?>) t;\n        }\n        \n        return defaultInstance().constructType(t).getRawClass();\n    }\n\n    \n\n    \n    public Class<?> findClass(String className) throws ClassNotFoundException {\n        if (className.indexOf('.') < 0) {\n            Class<?> prim = _findPrimitive(className);\n            if (prim != null) {\n                return prim;\n            }\n        }\n        \n        Throwable prob = null;\n        ClassLoader loader = this.getClassLoader();\n        if (loader == null) {\n          loader = \tThread.currentThread().getContextClassLoader();\n        }\n        if (loader != null) {\n            try {\n                return classForName(className, true, loader);\n            } catch (Exception e) {\n                prob = ClassUtil.getRootCause(e);\n            }\n        }\n        try {\n            return classForName(className);\n        } catch (Exception e) {\n            if (prob == null) {\n                prob = ClassUtil.getRootCause(e);\n            }\n        }\n        if (prob instanceof RuntimeException) {\n            throw (RuntimeException) prob;\n        }\n        throw new ClassNotFoundException(prob.getMessage(), prob);\n    }\n    \n    protected Class<?> classForName(String name, boolean initialize, ClassLoader loader) throws ClassNotFoundException {\n    \treturn Class.forName(name, true, loader);\n    }\n    \n    protected Class<?> classForName(String name) throws ClassNotFoundException {\n        return Class.forName(name);\n    }\n\n    protected Class<?> _findPrimitive(String className) {\n        if (\"int\".equals(className)) return Integer.TYPE;\n        if (\"long\".equals(className)) return Long.TYPE;\n        if (\"float\".equals(className)) return Float.TYPE;\n        if (\"double\".equals(className)) return Double.TYPE;\n        if (\"boolean\".equals(className)) return Boolean.TYPE;\n        if (\"byte\".equals(className)) return Byte.TYPE;\n        if (\"char\".equals(className)) return Character.TYPE;\n        if (\"short\".equals(className)) return Short.TYPE;\n        if (\"void\".equals(className)) return Void.TYPE;\n        return null;\n    }\n    \n    \n\n    \n    public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass) {\n        \n        final Class<?> rawBase = baseType.getRawClass();\n        if (rawBase == subclass) {\n            return baseType;\n        }\n        \n        JavaType newType;\n\n        \n        do { \n            if (rawBase == Object.class) {\n                newType = _fromClass(null, subclass, TypeBindings.emptyBindings());\n                break;\n            }\n            if (!rawBase.isAssignableFrom(subclass)) {\n                throw new IllegalArgumentException(String.format(\n                        \"Class %s not subtype of %s\", subclass.getName(), baseType));\n            }\n            \n\n            \n            if (baseType.getBindings().isEmpty()) {\n                newType = _fromClass(null, subclass, TypeBindings.emptyBindings());     \n                break;\n            }\n            \n            if (baseType.isContainerType()) {\n                if (baseType.isMapLikeType()) {\n                    if ((subclass == HashMap.class)\n                            || (subclass == LinkedHashMap.class)\n                            || (subclass == EnumMap.class)\n                            || (subclass == TreeMap.class)) {\n                        newType = _fromClass(null, subclass,\n                                TypeBindings.create(subclass, baseType.getKeyType(), baseType.getContentType()));\n                        break;\n                    }\n                } else if (baseType.isCollectionLikeType()) {\n                    if ((subclass == ArrayList.class)\n                            || (subclass == LinkedList.class)\n                            || (subclass == HashSet.class)\n                            || (subclass == TreeSet.class)) {\n                        newType = _fromClass(null, subclass,\n                                TypeBindings.create(subclass, baseType.getContentType()));\n                        break;\n                    }\n                    \n                    \n                    if (rawBase == EnumSet.class) {\n                        return baseType;\n                    }\n                }\n            }\n            \n            if (subclass.getTypeParameters().length == 0) {\n                newType = _fromClass(null, subclass, TypeBindings.emptyBindings());     \n                break;\n            }\n\n            \n            \n\n            \n            \n            \n            \n            \n            if (baseType.isInterface()) {\n                newType = baseType.refine(subclass, TypeBindings.emptyBindings(), null,\n                        new JavaType[] { baseType });\n            } else {\n                newType = baseType.refine(subclass, TypeBindings.emptyBindings(), baseType,\n                        NO_TYPES);\n            }\n            \n            if (newType == null) {\n                \n                \n                newType = _fromClass(null, subclass, TypeBindings.emptyBindings());        \n            }\n        } while (false);\n\n        \n\n        return newType;\n\n        \n        \n        \n    }\n\n    \n    public JavaType constructGeneralizedType(JavaType baseType, Class<?> superClass) {\n        \n        final Class<?> rawBase = baseType.getRawClass();\n        if (rawBase == superClass) {\n            return baseType;\n        }\n        JavaType superType = baseType.findSuperType(superClass);\n        if (superType == null) {\n            \n            if (!superClass.isAssignableFrom(rawBase)) {\n                throw new IllegalArgumentException(String.format(\n                        \"Class %s not a super-type of %s\", superClass.getName(), baseType));\n            }\n            \n            throw new IllegalArgumentException(String.format(\n                    \"Internal error: class %s not included as super-type for %s\",\n                    superClass.getName(), baseType));\n        }\n        return superType;\n    }\n\n    \n    public JavaType constructFromCanonical(String canonical) throws IllegalArgumentException {\n        return _parser.parse(canonical);\n    }\n\n    \n    public JavaType[] findTypeParameters(JavaType type, Class<?> expType) {\n        JavaType match = type.findSuperType(expType);\n        if (match == null) {\n            return NO_TYPES;\n        }\n        return match.getBindings().typeParameterArray();\n    }\n\n    \n    @Deprecated \n    public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType, TypeBindings bindings) {\n        return findTypeParameters(constructType(clz, bindings), expType);\n    }\n    \n    \n    @Deprecated \n    public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType) {\n        return findTypeParameters(constructType(clz), expType);\n    }\n\n    \n    public JavaType moreSpecificType(JavaType type1, JavaType type2) {\n        if (type1 == null) {\n            return type2;\n        }\n        if (type2 == null) {\n            return type1;\n        }\n        Class<?> raw1 = type1.getRawClass();\n        Class<?> raw2 = type2.getRawClass();\n        if (raw1 == raw2) {\n            return type1;\n        }\n        \n        if (raw1.isAssignableFrom(raw2)) {\n            return type2;\n        }\n        return type1;\n    }\n    \n    \n\n    public JavaType constructType(Type type) {\n        return _fromAny(null, type, EMPTY_BINDINGS);\n    }\n\n    public JavaType constructType(Type type, TypeBindings bindings) {\n        return _fromAny(null, type, bindings);\n    }\n    \n    public JavaType constructType(TypeReference<?> typeRef) {\n        \n        return _fromAny(null, typeRef.getType(), EMPTY_BINDINGS);\n\n        \n        \n\n        \n    }\n\n    \n    @Deprecated\n    public JavaType constructType(Type type, Class<?> contextClass) {\n        TypeBindings bindings = (contextClass == null)\n                ? TypeBindings.emptyBindings() : constructType(contextClass).getBindings();\n        return _fromAny(null, type, bindings);\n    }\n\n    \n    @Deprecated\n    public JavaType constructType(Type type, JavaType contextType) {\n        TypeBindings bindings = (contextType == null)\n                ? TypeBindings.emptyBindings() : contextType.getBindings();\n        return _fromAny(null, type, bindings);\n    }\n\n    \n\n    \n    public ArrayType constructArrayType(Class<?> elementType) {\n        return ArrayType.construct(_fromAny(null, elementType, null), null);\n    }\n    \n    \n    public ArrayType constructArrayType(JavaType elementType) {\n        return ArrayType.construct(elementType, null);\n    }\n\n    \n    public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, Class<?> elementClass) {\n        return constructCollectionType(collectionClass,\n                _fromClass(null, elementClass, EMPTY_BINDINGS));\n    }\n\n    \n    public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, JavaType elementType) {\n        \n        \n        return (CollectionType) _fromClass(null, collectionClass,\n                TypeBindings.create(collectionClass, elementType));\n    }\n\n    \n    public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, Class<?> elementClass) {\n        return constructCollectionLikeType(collectionClass,\n                _fromClass(null, elementClass, EMPTY_BINDINGS));\n    }\n    \n    \n    public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, JavaType elementType) {\n        JavaType type = _fromClass(null, collectionClass,\n                TypeBindings.createIfNeeded(collectionClass, elementType));\n        if (type instanceof CollectionLikeType) {\n            return (CollectionLikeType) type;\n        }\n        return CollectionLikeType.upgradeFrom(type, elementType);\n    }\n\n    \n    public MapType constructMapType(Class<? extends Map> mapClass, Class<?> keyClass, Class<?> valueClass) {\n        JavaType kt, vt;\n        if (mapClass == Properties.class) {\n            kt = vt = CORE_TYPE_STRING;\n        } else {\n            kt = _fromClass(null, keyClass, EMPTY_BINDINGS);\n            vt = _fromClass(null, valueClass, EMPTY_BINDINGS);\n        }\n        return constructMapType(mapClass, kt, vt);\n    }\n\n    \n    public MapType constructMapType(Class<? extends Map> mapClass, JavaType keyType, JavaType valueType) {\n        return (MapType) _fromClass(null, mapClass,\n                TypeBindings.create(mapClass, new JavaType[] {\n                        keyType, valueType\n                }));\n    }\n\n    \n    public MapLikeType constructMapLikeType(Class<?> mapClass, Class<?> keyClass, Class<?> valueClass) {\n        return constructMapLikeType(mapClass,\n                _fromClass(null, keyClass, EMPTY_BINDINGS),\n                _fromClass(null, valueClass, EMPTY_BINDINGS));\n    }\n\n    \n    public MapLikeType constructMapLikeType(Class<?> mapClass, JavaType keyType, JavaType valueType) {\n        \n        \n        JavaType type = _fromClass(null, mapClass,\n                TypeBindings.createIfNeeded(mapClass, new JavaType[] { keyType, valueType }));\n        if (type instanceof MapLikeType) {\n            return (MapLikeType) type;\n        }\n        return MapLikeType.upgradeFrom(type, keyType, valueType);\n    }\n\n    \n    public JavaType constructSimpleType(Class<?> rawType, JavaType[] parameterTypes) {\n        return _fromClass(null, rawType, TypeBindings.create(rawType, parameterTypes));\n    }\n\n    \n    @Deprecated\n    public JavaType constructSimpleType(Class<?> rawType, Class<?> parameterTarget, JavaType[] parameterTypes) {\n        return constructSimpleType(rawType, parameterTypes);\n    } \n\n    \n    public JavaType constructReferenceType(Class<?> rawType, JavaType referredType) {\n        return ReferenceType.construct(rawType, null, \n                null, null, \n                referredType);\n    }\n\n    \n    public JavaType uncheckedSimpleType(Class<?> cls) {\n        \n        return _constructSimple(cls, EMPTY_BINDINGS, null, null);\n    }\n\n    \n    public JavaType constructParametricType(Class<?> parametrized, Class<?>... parameterClasses) {\n        int len = parameterClasses.length;\n        JavaType[] pt = new JavaType[len];\n        for (int i = 0; i < len; ++i) {\n            pt[i] = _fromClass(null, parameterClasses[i], null);\n        }\n        return constructParametricType(parametrized, pt);\n    }\n\n    \n    public JavaType constructParametricType(Class<?> rawType, JavaType... parameterTypes) {\n        return _fromClass(null, rawType, TypeBindings.create(rawType, parameterTypes));\n    }\n\n    \n    public JavaType constructParametrizedType(Class<?> parametrized, Class<?> parametersFor, JavaType... parameterTypes) {\n        return constructParametricType(parametrized, parameterTypes);\n    }\n\n    \n    public JavaType constructParametrizedType(Class<?> parametrized, Class<?> parametersFor, Class<?>... parameterClasses) {\n        return constructParametricType(parametrized, parameterClasses);\n    }\n\n    \n\n    \n    public CollectionType constructRawCollectionType(Class<? extends Collection> collectionClass) {\n        return constructCollectionType(collectionClass, unknownType());\n    }\n\n    \n    public CollectionLikeType constructRawCollectionLikeType(Class<?> collectionClass) {\n        return constructCollectionLikeType(collectionClass, unknownType());\n    }\n\n    \n    public MapType constructRawMapType(Class<? extends Map> mapClass) {\n        return constructMapType(mapClass, unknownType(), unknownType());\n    }\n\n    \n    public MapLikeType constructRawMapLikeType(Class<?> mapClass) {\n        return constructMapLikeType(mapClass, unknownType(), unknownType());\n    }\n\n    \n\n    private JavaType _mapType(Class<?> rawClass, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) {\n        JavaType kt, vt;\n        \n        \n        if (rawClass == Properties.class) {\n            kt = vt = CORE_TYPE_STRING;\n        } else {\n            List<JavaType> typeParams = bindings.getTypeParameters();\n            \n            switch (typeParams.size()) {\n            case 0: \n                kt = vt = _unknownType();\n                break;\n            case 2:\n                kt = typeParams.get(0);\n                vt = typeParams.get(1);\n                break;\n            default:\n                throw new IllegalArgumentException(\"Strange Map type \"+rawClass.getName()+\": can not determine type parameters\");\n            }\n        }\n        return MapType.construct(rawClass, bindings, superClass, superInterfaces, kt, vt);\n    }\n\n    private JavaType _collectionType(Class<?> rawClass, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) {\n        List<JavaType> typeParams = bindings.getTypeParameters();\n        \n        JavaType ct;\n        if (typeParams.isEmpty()) {\n            ct = _unknownType();\n        } else if (typeParams.size() == 1) {\n            ct = typeParams.get(0);\n        } else {\n            throw new IllegalArgumentException(\"Strange Collection type \"+rawClass.getName()+\": can not determine type parameters\");\n        }\n        return CollectionType.construct(rawClass, bindings, superClass, superInterfaces, ct);\n    }\n\n    private JavaType _referenceType(Class<?> rawClass, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) {\n        List<JavaType> typeParams = bindings.getTypeParameters();\n        \n        JavaType ct;\n        if (typeParams.isEmpty()) {\n            ct = _unknownType();\n        } else if (typeParams.size() == 1) {\n            ct = typeParams.get(0);\n        } else {\n            throw new IllegalArgumentException(\"Strange Reference type \"+rawClass.getName()+\": can not determine type parameters\");\n        }\n        return ReferenceType.construct(rawClass, bindings, superClass, superInterfaces, ct);\n    }\n\n    \n    protected JavaType _constructSimple(Class<?> raw, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) {\n        if (bindings.isEmpty()) {\n            JavaType result = _findWellKnownSimple(raw);\n            if (result != null) {\n                return result;\n            }\n        }\n        return _newSimpleType(raw, bindings, superClass, superInterfaces);\n    }\n\n    \n    protected JavaType _newSimpleType(Class<?> raw, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) {\n        return new SimpleType(raw, bindings, superClass, superInterfaces);\n    }\n\n    protected JavaType _unknownType() {\n        \n        return CORE_TYPE_OBJECT;\n    }\n\n    \n    protected JavaType _findWellKnownSimple(Class<?> clz) {\n        if (clz.isPrimitive()) {\n            if (clz == CLS_BOOL) return CORE_TYPE_BOOL;\n            if (clz == CLS_INT) return CORE_TYPE_INT;\n            if (clz == CLS_LONG) return CORE_TYPE_LONG;\n        } else {\n            if (clz == CLS_STRING) return CORE_TYPE_STRING;\n            if (clz == CLS_OBJECT) return CORE_TYPE_OBJECT; \n        }\n        return null;\n    }\n\n    \n\n    \n    protected JavaType _fromAny(ClassStack context, Type type, TypeBindings bindings) {\n        JavaType resultType;\n\n        \n        if (type instanceof Class<?>) {\n            \n            resultType = _fromClass(context, (Class<?>) type, EMPTY_BINDINGS);\n        }\n        \n        else if (type instanceof ParameterizedType) {\n            resultType = _fromParamType(context, (ParameterizedType) type, bindings);\n        }\n        else if (type instanceof JavaType) { \n            \n            return (JavaType) type;\n        }\n        else if (type instanceof GenericArrayType) {\n            resultType = _fromArrayType(context, (GenericArrayType) type, bindings);\n        }\n        else if (type instanceof TypeVariable<?>) {\n            resultType = _fromVariable(context, (TypeVariable<?>) type, bindings);\n        }\n        else if (type instanceof WildcardType) {\n            resultType = _fromWildcard(context, (WildcardType) type, bindings);\n        } else {\n            \n            throw new IllegalArgumentException(\"Unrecognized Type: \"+((type == null) ? \"[null]\" : type.toString()));\n        }\n        \n        if (_modifiers != null && !resultType.isContainerType()) {\n            TypeBindings b = resultType.getBindings();\n            if (b == null) {\n                b = EMPTY_BINDINGS;\n            }\n            for (TypeModifier mod : _modifiers) {\n                resultType = mod.modifyType(resultType, type, b, this);\n            }\n        }\n        return resultType;\n    }\n\n    \n    protected JavaType _fromClass(ClassStack context, Class<?> rawType, TypeBindings bindings) {\n        \n        JavaType result = _findWellKnownSimple(rawType);\n        if (result != null) {\n            return result;\n        }\n        \n        \n        \n        boolean cachable = (bindings == null) || bindings.isEmpty();\n        if (cachable) {\n            result = _typeCache.get(rawType); \n            if (result != null) {\n                return result;\n            }\n        }\n\n        \n        if (context == null) {\n            context = new ClassStack(rawType);\n        } else {\n            ClassStack prev = context.find(rawType);\n            if (prev != null) {\n                \n                ResolvedRecursiveType selfRef = new ResolvedRecursiveType(rawType, EMPTY_BINDINGS);\n                prev.addSelfReference(selfRef);\n                return selfRef;\n            }\n            \n            context = context.child(rawType);\n        }\n\n        \n        if (rawType.isArray()) {\n            result = ArrayType.construct(_fromAny(context, rawType.getComponentType(), bindings),\n                    bindings);\n        } else {\n            \n            \n            JavaType superClass;\n            JavaType[] superInterfaces;\n\n            if (rawType.isInterface()) {\n                superClass = null;\n                superInterfaces = _resolveSuperInterfaces(context, rawType, bindings);\n            } else {\n                \n                superClass = _resolveSuperClass(context, rawType, bindings);\n                superInterfaces = _resolveSuperInterfaces(context, rawType, bindings);\n            }\n\n            \n            if (rawType == Properties.class) {\n                result = MapType.construct(rawType, bindings, superClass, superInterfaces,\n                        CORE_TYPE_STRING, CORE_TYPE_STRING);\n            }\n            \n            \n            else if (superClass != null) {\n                result = superClass.refine(rawType, bindings, superClass, superInterfaces);\n            }\n            \n            if (result == null) {\n                result = _fromWellKnownClass(context, rawType, bindings, superClass, superInterfaces); \n                if (result == null) {\n                    result = _fromWellKnownInterface(context, rawType, bindings, superClass, superInterfaces);\n                    if (result == null) {\n                        \n                        result = _newSimpleType(rawType, bindings, superClass, superInterfaces);\n                    }\n                }\n            }\n        }\n        context.resolveSelfReferences(result);\n\n        if (cachable) {\n            _typeCache.putIfAbsent(rawType, result); \n        }\n        return result;\n    }\n\n    protected JavaType _resolveSuperClass(ClassStack context, Class<?> rawType, TypeBindings parentBindings) {\n        Type parent = ClassUtil.getGenericSuperclass(rawType);\n        if (parent == null) {\n            return null;\n        }\n        return _fromAny(context, parent, parentBindings);\n    }\n\n    protected JavaType[] _resolveSuperInterfaces(ClassStack context, Class<?> rawType, TypeBindings parentBindings) {\n        Type[] types = ClassUtil.getGenericInterfaces(rawType);\n        if (types == null || types.length == 0) {\n            return NO_TYPES;\n        }\n        int len = types.length;\n        JavaType[] resolved = new JavaType[len];\n        for (int i = 0; i < len; ++i) {\n            Type type = types[i];\n            resolved[i] = _fromAny(context, type, parentBindings);\n        }\n        return resolved;\n    }\n\n    \n    protected JavaType _fromWellKnownClass(ClassStack context, Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) {\n        \n        if (rawType == Map.class) {\n            return _mapType(rawType, bindings, superClass, superInterfaces);\n        }\n        if (rawType == Collection.class) {\n            return _collectionType(rawType, bindings, superClass, superInterfaces);\n        }\n        \n        if (rawType == AtomicReference.class) {\n            return _referenceType(rawType, bindings, superClass, superInterfaces);\n        }\n        \n        \n        \n        \n        return null;\n    }\n\n    protected JavaType _fromWellKnownInterface(ClassStack context, Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) {\n        \n        \n        final int intCount = superInterfaces.length;\n\n        for (int i = 0; i < intCount; ++i) {\n            JavaType result = superInterfaces[i].refine(rawType, bindings, superClass, superInterfaces);\n            if (result != null) {\n                return result;\n            }\n        }\n        return null;\n    }\n\n    \n    protected JavaType _fromParamType(ClassStack context, ParameterizedType ptype, TypeBindings parentBindings) {\n        \n        Class<?> rawType = (Class<?>) ptype.getRawType();\n\n        \n        \n        if (rawType == CLS_ENUM) {\n            return CORE_TYPE_ENUM;\n        }\n        if (rawType == CLS_COMPARABLE) {\n            return CORE_TYPE_COMPARABLE;\n        }\n        if (rawType == CLS_CLASS) {\n            return CORE_TYPE_CLASS;\n        }\n\n        \n        \n        \n        Type[] args = ptype.getActualTypeArguments();\n        int paramCount = (args == null) ? 0 : args.length;\n        JavaType[] pt;\n        TypeBindings newBindings;        \n\n        if (paramCount == 0) {\n            newBindings = EMPTY_BINDINGS;\n        } else {\n            pt = new JavaType[paramCount];\n            for (int i = 0; i < paramCount; ++i) {\n                pt[i] = _fromAny(context, args[i], parentBindings);\n            }\n            newBindings = TypeBindings.create(rawType, pt);\n        }\n        return _fromClass(context, rawType, newBindings);\n    }\n\n    protected JavaType _fromArrayType(ClassStack context, GenericArrayType type, TypeBindings bindings) {\n        JavaType elementType = _fromAny(context, type.getGenericComponentType(), bindings);\n        return ArrayType.construct(elementType, bindings);\n    }\n\n    protected JavaType _fromVariable(ClassStack context, TypeVariable<?> var, TypeBindings bindings) {\n        \n        final String name = var.getName();\n        JavaType type = bindings.findBoundType(name);\n        if (type != null) {\n            return type;\n        }\n        \n        \n        if (bindings.hasUnbound(name)) {\n            return CORE_TYPE_OBJECT;\n        }\n        bindings = bindings.withUnboundVariable(name);\n\n        Type[] bounds = var.getBounds();\n        return _fromAny(context, bounds[0], bindings);\n    }\n\n    protected JavaType _fromWildcard(ClassStack context, WildcardType type, TypeBindings bindings) {\n        \n        return _fromAny(context, type.getUpperBounds()[0], bindings);\n    }\n}\n",
      "buggy_signatures": [
        "protected TypeFactory(TypeParser p, TypeModifier[] mods)",
        "protected TypeFactory(TypeParser p, TypeModifier[] mods, ClassLoader classLoader)",
        "public TypeFactory withModifier(TypeModifier mod)",
        "public TypeFactory withClassLoader(ClassLoader classLoader)",
        "public static TypeFactory defaultInstance()",
        "public void clearCache()",
        "public ClassLoader getClassLoader()",
        "public static JavaType unknownType()",
        "public static Class<?> rawClass(Type t)",
        "public Class<?> findClass(String className) throws ClassNotFoundException",
        "protected Class<?> classForName(String name, boolean initialize, ClassLoader loader) throws ClassNotFoundException",
        "protected Class<?> classForName(String name) throws ClassNotFoundException",
        "protected Class<?> _findPrimitive(String className)",
        "public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass)",
        "public JavaType constructGeneralizedType(JavaType baseType, Class<?> superClass)",
        "public JavaType constructFromCanonical(String canonical) throws IllegalArgumentException",
        "public JavaType[] findTypeParameters(JavaType type, Class<?> expType)",
        "public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType, TypeBindings bindings)",
        "public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType)",
        "public JavaType moreSpecificType(JavaType type1, JavaType type2)",
        "public JavaType constructType(Type type)",
        "public JavaType constructType(Type type, TypeBindings bindings)",
        "public JavaType constructType(TypeReference<?> typeRef)",
        "public JavaType constructType(Type type, Class<?> contextClass)",
        "public JavaType constructType(Type type, JavaType contextType)",
        "public ArrayType constructArrayType(Class<?> elementType)",
        "public ArrayType constructArrayType(JavaType elementType)",
        "public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, Class<?> elementClass)",
        "public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, JavaType elementType)",
        "public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, Class<?> elementClass)",
        "public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, JavaType elementType)",
        "public MapType constructMapType(Class<? extends Map> mapClass, Class<?> keyClass, Class<?> valueClass)",
        "public MapType constructMapType(Class<? extends Map> mapClass, JavaType keyType, JavaType valueType)",
        "public MapLikeType constructMapLikeType(Class<?> mapClass, Class<?> keyClass, Class<?> valueClass)",
        "public MapLikeType constructMapLikeType(Class<?> mapClass, JavaType keyType, JavaType valueType)",
        "public JavaType constructSimpleType(Class<?> rawType, JavaType[] parameterTypes)",
        "public JavaType constructSimpleType(Class<?> rawType, Class<?> parameterTarget, JavaType[] parameterTypes)",
        "public JavaType constructReferenceType(Class<?> rawType, JavaType referredType)",
        "public JavaType uncheckedSimpleType(Class<?> cls)",
        "public JavaType constructParametricType(Class<?> parametrized, Class<?>... parameterClasses)",
        "public JavaType constructParametricType(Class<?> rawType, JavaType... parameterTypes)",
        "public JavaType constructParametrizedType(Class<?> parametrized, Class<?> parametersFor, JavaType... parameterTypes)",
        "public JavaType constructParametrizedType(Class<?> parametrized, Class<?> parametersFor, Class<?>... parameterClasses)",
        "public CollectionType constructRawCollectionType(Class<? extends Collection> collectionClass)",
        "public CollectionLikeType constructRawCollectionLikeType(Class<?> collectionClass)",
        "public MapType constructRawMapType(Class<? extends Map> mapClass)",
        "public MapLikeType constructRawMapLikeType(Class<?> mapClass)",
        "private JavaType _mapType(Class<?> rawClass, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces)",
        "private JavaType _collectionType(Class<?> rawClass, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces)",
        "private JavaType _referenceType(Class<?> rawClass, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces)",
        "protected JavaType _constructSimple(Class<?> raw, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces)",
        "protected JavaType _newSimpleType(Class<?> raw, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces)",
        "protected JavaType _unknownType()",
        "protected JavaType _findWellKnownSimple(Class<?> clz)",
        "protected JavaType _fromAny(ClassStack context, Type type, TypeBindings bindings)",
        "protected JavaType _fromClass(ClassStack context, Class<?> rawType, TypeBindings bindings)",
        "protected JavaType _resolveSuperClass(ClassStack context, Class<?> rawType, TypeBindings parentBindings)",
        "protected JavaType[] _resolveSuperInterfaces(ClassStack context, Class<?> rawType, TypeBindings parentBindings)",
        "protected JavaType _fromWellKnownClass(ClassStack context, Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces)",
        "protected JavaType _fromWellKnownInterface(ClassStack context, Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces)",
        "protected JavaType _fromParamType(ClassStack context, ParameterizedType ptype, TypeBindings parentBindings)",
        "protected JavaType _fromArrayType(ClassStack context, GenericArrayType type, TypeBindings bindings)",
        "protected JavaType _fromVariable(ClassStack context, TypeVariable<?> var, TypeBindings bindings)",
        "protected JavaType _fromWildcard(ClassStack context, WildcardType type, TypeBindings bindings)"
      ],
      "fixed_signatures": [
        "protected TypeFactory(TypeParser p, TypeModifier[] mods)",
        "protected TypeFactory(TypeParser p, TypeModifier[] mods, ClassLoader classLoader)",
        "public TypeFactory withModifier(TypeModifier mod)",
        "public TypeFactory withClassLoader(ClassLoader classLoader)",
        "public static TypeFactory defaultInstance()",
        "public void clearCache()",
        "public ClassLoader getClassLoader()",
        "public static JavaType unknownType()",
        "public static Class<?> rawClass(Type t)",
        "public Class<?> findClass(String className) throws ClassNotFoundException",
        "protected Class<?> classForName(String name, boolean initialize, ClassLoader loader) throws ClassNotFoundException",
        "protected Class<?> classForName(String name) throws ClassNotFoundException",
        "protected Class<?> _findPrimitive(String className)",
        "public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass)",
        "public JavaType constructGeneralizedType(JavaType baseType, Class<?> superClass)",
        "public JavaType constructFromCanonical(String canonical) throws IllegalArgumentException",
        "public JavaType[] findTypeParameters(JavaType type, Class<?> expType)",
        "public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType, TypeBindings bindings)",
        "public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType)",
        "public JavaType moreSpecificType(JavaType type1, JavaType type2)",
        "public JavaType constructType(Type type)",
        "public JavaType constructType(Type type, TypeBindings bindings)",
        "public JavaType constructType(TypeReference<?> typeRef)",
        "public JavaType constructType(Type type, Class<?> contextClass)",
        "public JavaType constructType(Type type, JavaType contextType)",
        "public ArrayType constructArrayType(Class<?> elementType)",
        "public ArrayType constructArrayType(JavaType elementType)",
        "public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, Class<?> elementClass)",
        "public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, JavaType elementType)",
        "public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, Class<?> elementClass)",
        "public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, JavaType elementType)",
        "public MapType constructMapType(Class<? extends Map> mapClass, Class<?> keyClass, Class<?> valueClass)",
        "public MapType constructMapType(Class<? extends Map> mapClass, JavaType keyType, JavaType valueType)",
        "public MapLikeType constructMapLikeType(Class<?> mapClass, Class<?> keyClass, Class<?> valueClass)",
        "public MapLikeType constructMapLikeType(Class<?> mapClass, JavaType keyType, JavaType valueType)",
        "public JavaType constructSimpleType(Class<?> rawType, JavaType[] parameterTypes)",
        "public JavaType constructSimpleType(Class<?> rawType, Class<?> parameterTarget, JavaType[] parameterTypes)",
        "public JavaType constructReferenceType(Class<?> rawType, JavaType referredType)",
        "public JavaType uncheckedSimpleType(Class<?> cls)",
        "public JavaType constructParametricType(Class<?> parametrized, Class<?>... parameterClasses)",
        "public JavaType constructParametricType(Class<?> rawType, JavaType... parameterTypes)",
        "public JavaType constructParametrizedType(Class<?> parametrized, Class<?> parametersFor, JavaType... parameterTypes)",
        "public JavaType constructParametrizedType(Class<?> parametrized, Class<?> parametersFor, Class<?>... parameterClasses)",
        "public CollectionType constructRawCollectionType(Class<? extends Collection> collectionClass)",
        "public CollectionLikeType constructRawCollectionLikeType(Class<?> collectionClass)",
        "public MapType constructRawMapType(Class<? extends Map> mapClass)",
        "public MapLikeType constructRawMapLikeType(Class<?> mapClass)",
        "private JavaType _mapType(Class<?> rawClass, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces)",
        "private JavaType _collectionType(Class<?> rawClass, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces)",
        "private JavaType _referenceType(Class<?> rawClass, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces)",
        "protected JavaType _constructSimple(Class<?> raw, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces)",
        "protected JavaType _newSimpleType(Class<?> raw, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces)",
        "protected JavaType _unknownType()",
        "protected JavaType _findWellKnownSimple(Class<?> clz)",
        "protected JavaType _fromAny(ClassStack context, Type type, TypeBindings bindings)",
        "protected JavaType _fromClass(ClassStack context, Class<?> rawType, TypeBindings bindings)",
        "protected JavaType _resolveSuperClass(ClassStack context, Class<?> rawType, TypeBindings parentBindings)",
        "protected JavaType[] _resolveSuperInterfaces(ClassStack context, Class<?> rawType, TypeBindings parentBindings)",
        "protected JavaType _fromWellKnownClass(ClassStack context, Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces)",
        "protected JavaType _fromWellKnownInterface(ClassStack context, Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces)",
        "protected JavaType _fromParamType(ClassStack context, ParameterizedType ptype, TypeBindings parentBindings)",
        "protected JavaType _fromArrayType(ClassStack context, GenericArrayType type, TypeBindings bindings)",
        "protected JavaType _fromVariable(ClassStack context, TypeVariable<?> var, TypeBindings bindings)",
        "protected JavaType _fromWildcard(ClassStack context, WildcardType type, TypeBindings bindings)"
      ],
      "methods": [
        {
          "buggy_method": "  public JavaType constructType(Type type, Class<?> contextClass) {\n  return constructType(type, constructType(contextClass));\n  }",
          "fixed_method": "  public JavaType constructType(Type type, Class<?> contextClass) {\n  TypeBindings bindings = (contextClass == null)\n  ? TypeBindings.emptyBindings() : constructType(contextClass).getBindings();\n  return _fromAny(null, type, bindings);\n  }",
          "diff": [
            "@@ -599,7 +599,9 @@",
            "      */\n",
            "     @Deprecated\n",
            "     public JavaType constructType(Type type, Class<?> contextClass) {\n",
            "-        return constructType(type, constructType(contextClass));\n",
            "+        TypeBindings bindings = (contextClass == null)\n",
            "+                ? TypeBindings.emptyBindings() : constructType(contextClass).getBindings();\n",
            "+        return _fromAny(null, type, bindings);\n",
            "     }\n",
            " \n",
            "     /**\n"
          ],
          "changed_lines": 4
        },
        {
          "buggy_method": "  public JavaType constructType(Type type, JavaType contextType) {\n  return _fromAny(null, type, contextType.getBindings());\n  }",
          "fixed_method": "  public JavaType constructType(Type type, JavaType contextType) {\n  TypeBindings bindings = (contextType == null)\n  ? TypeBindings.emptyBindings() : contextType.getBindings();\n  return _fromAny(null, type, bindings);\n  }",
          "diff": [
            "@@ -607,7 +609,9 @@",
            "      */\n",
            "     @Deprecated\n",
            "     public JavaType constructType(Type type, JavaType contextType) {\n",
            "-        return _fromAny(null, type, contextType.getBindings());\n",
            "+        TypeBindings bindings = (contextType == null)\n",
            "+                ? TypeBindings.emptyBindings() : contextType.getBindings();\n",
            "+        return _fromAny(null, type, bindings);\n",
            "     }\n",
            " \n",
            "     /*\n"
          ],
          "changed_lines": 4
        }
      ]
    }
  ]
}
