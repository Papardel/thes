{
  "bug_id": "23",
  "failed_tests": {
    "org.apache.commons.compress.archivers.sevenz.SevenZFileTest": [
      {
        "methodName": "testCompressedHeaderWithNonDefaultDictionarySize",
        "error": "org.tukaani.xz.UnsupportedOptionsException",
        "message": "LZMA dictionary is too big for this implementation",
        "fail_line": "        SevenZFile sevenZFile = new SevenZFile(getFile(\"COMPRESS-256.7z\"));",
        "test_source": "  public void testCompressedHeaderWithNonDefaultDictionarySize() throws Exception {\n  SevenZFile sevenZFile = new SevenZFile(getFile(\"COMPRESS-256.7z\"));\n  try {\n  int count = 0;\n  while (sevenZFile.getNextEntry() != null) {\n  count++;\n  }\n  assertEquals(446, count);\n  } finally {\n  sevenZFile.close();\n  }\n  }",
        "stack": [
          "Coders$LZMADecoder.decode line 117, Coders.addDecoder line 48, SevenZFile.readEncodedHeader line 278, SevenZFile.readHeaders line 191, SevenZFile.<init> line 94, SevenZFile.<init> line 116, SevenZFileTest.testCompressedHeaderWithNonDefaultDictionarySize line 79"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/compress/archivers/sevenz/Coders.java",
      "buggy_full_code": "\npackage org.apache.commons.compress.archivers.sevenz;\n\nimport java.io.FilterInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.security.GeneralSecurityException;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Arrays;\nimport java.util.zip.Deflater;\nimport java.util.zip.DeflaterOutputStream;\nimport java.util.zip.Inflater;\nimport java.util.zip.InflaterInputStream;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.CipherInputStream;\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n\nimport org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream;\nimport org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream;\nimport org.tukaani.xz.LZMAInputStream;\n\nclass Coders {\n    static InputStream addDecoder(final InputStream is, final Coder coder, final byte[] password) throws IOException {\n        for (final CoderId coderId : coderTable) {\n            if (Arrays.equals(coderId.method.getId(), coder.decompressionMethodId)) {\n                return coderId.coder.decode(is, coder, password);\n            }\n        }\n        throw new IOException(\"Unsupported compression method \" +\n                Arrays.toString(coder.decompressionMethodId));\n    }\n    \n    static OutputStream addEncoder(final OutputStream out, final SevenZMethod method, final byte[] password) throws IOException {\n        for (final CoderId coderId : coderTable) {\n            if (coderId.method.equals(method)) {\n                return coderId.coder.encode(out, password);\n            }\n        }\n        throw new IOException(\"Unsupported compression method \" + method);\n    }\n\n    static CoderId[] coderTable = new CoderId[] { new CoderId(SevenZMethod.COPY, new CopyDecoder()), new CoderId(SevenZMethod.LZMA, new LZMADecoder()), new CoderId(SevenZMethod.LZMA2, new LZMA2Decoder()), new CoderId(SevenZMethod.DEFLATE, new DeflateDecoder()), new CoderId(SevenZMethod.BZIP2, new BZIP2Decoder()), new CoderId(SevenZMethod.AES256SHA256, new AES256SHA256Decoder()) }; static class CoderId {\n        CoderId(SevenZMethod method, final CoderBase coder) {\n            this.method = method;\n            this.coder = coder;\n        }\n\n        final SevenZMethod method;\n        final CoderBase coder;\n    }\n    \n    static abstract class CoderBase { abstract InputStream decode(final InputStream in, final Coder coder, byte[] password) throws IOException; OutputStream encode(final OutputStream out, final byte[] password) throws IOException {\n            throw new UnsupportedOperationException(\"method doesn't support writing\");\n        }\n    }\n    \n    static class CopyDecoder extends CoderBase { @Override InputStream decode(final InputStream in, final Coder coder, byte[] password) throws IOException {\n            return in; \n        }\n        @Override\n        OutputStream encode(final OutputStream out, final byte[] password) {\n            return out;\n        }\n    }\n\n    static class LZMADecoder extends CoderBase { @Override InputStream decode(final InputStream in, final Coder coder, byte[] password) throws IOException {\n            byte propsByte = coder.properties[0];\n            long dictSize = coder.properties[1];\n            for (int i = 1; i < 4; i++) {\n                dictSize |= (coder.properties[i + 1] << (8 * i));\n            }\n            if (dictSize > LZMAInputStream.DICT_SIZE_MAX) {\n                throw new IOException(\"Dictionary larger than 4GiB maximum size\");\n            }\n            return new LZMAInputStream(in, -1, propsByte, (int) dictSize);\n        }\n    }\n    \n    static class DeflateDecoder extends CoderBase { @Override InputStream decode(final InputStream in, final Coder coder, final byte[] password) throws IOException {\n            return new InflaterInputStream(new DummyByteAddingInputStream(in),\n                                           new Inflater(true));\n        }\n        @Override\n        OutputStream encode(final OutputStream out, final byte[] password) {\n            return new DeflaterOutputStream(out, new Deflater(9, true));\n        }\n    }\n\n    static class BZIP2Decoder extends CoderBase { @Override InputStream decode(final InputStream in, final Coder coder, final byte[] password) throws IOException {\n            return new BZip2CompressorInputStream(in);\n        }\n        @Override\n        OutputStream encode(final OutputStream out, final byte[] password)\n                throws IOException {\n            return new BZip2CompressorOutputStream(out);\n        }\n    }\n\n    static class AES256SHA256Decoder extends CoderBase { @Override InputStream decode(final InputStream in, final Coder coder, final byte[] passwordBytes) throws IOException {\n            return new InputStream() {\n                private boolean isInitialized = false; private CipherInputStream cipherInputStream = null; private CipherInputStream init() throws IOException {\n                    if (isInitialized) {\n                        return cipherInputStream;\n                    }\n                    final int byte0 = 0xff & coder.properties[0];\n                    final int numCyclesPower = byte0 & 0x3f;\n                    final int byte1 = 0xff & coder.properties[1];\n                    final int ivSize = ((byte0 >> 6) & 1) + (byte1 & 0x0f);\n                    final int saltSize = ((byte0 >> 7) & 1) + (byte1 >> 4);\n                    if (2 + saltSize + ivSize > coder.properties.length) {\n                        throw new IOException(\"Salt size + IV size too long\");\n                    }\n                    final byte[] salt = new byte[saltSize];\n                    System.arraycopy(coder.properties, 2, salt, 0, saltSize);\n                    final byte[] iv = new byte[16];\n                    System.arraycopy(coder.properties, 2 + saltSize, iv, 0, ivSize);\n                    \n                    if (passwordBytes == null) {\n                        throw new IOException(\"Cannot read encrypted files without a password\");\n                    }\n                    final byte[] aesKeyBytes;\n                    if (numCyclesPower == 0x3f) {\n                        aesKeyBytes = new byte[32];\n                        System.arraycopy(salt, 0, aesKeyBytes, 0, saltSize);\n                        System.arraycopy(passwordBytes, 0, aesKeyBytes, saltSize,\n                                Math.min(passwordBytes.length, aesKeyBytes.length - saltSize));\n                    } else {\n                        final MessageDigest digest;\n                        try {\n                            digest = MessageDigest.getInstance(\"SHA-256\");\n                        } catch (NoSuchAlgorithmException noSuchAlgorithmException) {\n                            IOException ioe = new IOException(\"SHA-256 is unsupported by your Java implementation\");\n                            ioe.initCause(noSuchAlgorithmException);\n                            throw ioe;\n        \n\n\n                        }\n                        final byte[] extra = new byte[8];\n                        for (long j = 0; j < (1L << numCyclesPower); j++) {\n                            digest.update(salt);\n                            digest.update(passwordBytes);\n                            digest.update(extra);\n                            for (int k = 0; k < extra.length; k++) {\n                                ++extra[k];\n                                if (extra[k] != 0) {\n                                    break;\n                                }\n                            }\n                        }\n                        aesKeyBytes = digest.digest();\n                    }\n                    \n                    final SecretKey aesKey = new SecretKeySpec(aesKeyBytes, \"AES\");\n                    try {\n                        final Cipher cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n                        cipher.init(Cipher.DECRYPT_MODE, aesKey, new IvParameterSpec(iv));\n                        cipherInputStream = new CipherInputStream(in, cipher);\n                        isInitialized = true;\n                        return cipherInputStream;\n                    } catch (GeneralSecurityException generalSecurityException) {\n                        IOException ioe = new IOException(\"Decryption error \" +\n                                \"(do you have the JCE Unlimited Strength Jurisdiction Policy Files installed?)\");\n                        ioe.initCause(generalSecurityException);\n                        throw ioe;\n        \n\n\n\n                    }\n                }\n                \n                @Override\n                public int read() throws IOException {\n                    return init().read();\n                }\n                \n                @Override\n                public int read(byte[] b, int off, int len) throws IOException {\n                    return init().read(b, off, len);\n                }\n                \n                @Override\n                public void close() {\n                }\n            };\n        }\n    }\n\n    \n    private static class DummyByteAddingInputStream extends FilterInputStream { private boolean addDummyByte = true; private DummyByteAddingInputStream(InputStream in) {\n            super(in);\n        }\n\n        @Override\n        public int read() throws IOException {\n            int result = super.read();\n            if (result == -1 && addDummyByte) {\n                addDummyByte = false;\n                result = 0;\n            }\n            return result;\n        }\n\n        @Override\n        public int read(byte[] b, int off, int len) throws IOException {\n            int result = super.read(b, off, len);\n            if (result == -1 && addDummyByte) {\n                addDummyByte = false;\n                b[off] = 0;\n                return 1;\n            }\n            return result;\n        }\n    }\n}\n",
      "fixed_full_code": "\npackage org.apache.commons.compress.archivers.sevenz;\n\nimport java.io.FilterInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.security.GeneralSecurityException;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Arrays;\nimport java.util.zip.Deflater;\nimport java.util.zip.DeflaterOutputStream;\nimport java.util.zip.Inflater;\nimport java.util.zip.InflaterInputStream;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.CipherInputStream;\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n\nimport org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream;\nimport org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream;\nimport org.tukaani.xz.LZMAInputStream;\n\nclass Coders {\n    static InputStream addDecoder(final InputStream is, final Coder coder, final byte[] password) throws IOException {\n        for (final CoderId coderId : coderTable) {\n            if (Arrays.equals(coderId.method.getId(), coder.decompressionMethodId)) {\n                return coderId.coder.decode(is, coder, password);\n            }\n        }\n        throw new IOException(\"Unsupported compression method \" +\n                Arrays.toString(coder.decompressionMethodId));\n    }\n    \n    static OutputStream addEncoder(final OutputStream out, final SevenZMethod method, final byte[] password) throws IOException {\n        for (final CoderId coderId : coderTable) {\n            if (coderId.method.equals(method)) {\n                return coderId.coder.encode(out, password);\n            }\n        }\n        throw new IOException(\"Unsupported compression method \" + method);\n    }\n\n    static CoderId[] coderTable = new CoderId[] { new CoderId(SevenZMethod.COPY, new CopyDecoder()), new CoderId(SevenZMethod.LZMA, new LZMADecoder()), new CoderId(SevenZMethod.LZMA2, new LZMA2Decoder()), new CoderId(SevenZMethod.DEFLATE, new DeflateDecoder()), new CoderId(SevenZMethod.BZIP2, new BZIP2Decoder()), new CoderId(SevenZMethod.AES256SHA256, new AES256SHA256Decoder()) }; static class CoderId {\n        CoderId(SevenZMethod method, final CoderBase coder) {\n            this.method = method;\n            this.coder = coder;\n        }\n\n        final SevenZMethod method;\n        final CoderBase coder;\n    }\n    \n    static abstract class CoderBase { abstract InputStream decode(final InputStream in, final Coder coder, byte[] password) throws IOException; OutputStream encode(final OutputStream out, final byte[] password) throws IOException {\n            throw new UnsupportedOperationException(\"method doesn't support writing\");\n        }\n    }\n    \n    static class CopyDecoder extends CoderBase { @Override InputStream decode(final InputStream in, final Coder coder, byte[] password) throws IOException {\n            return in; \n        }\n        @Override\n        OutputStream encode(final OutputStream out, final byte[] password) {\n            return out;\n        }\n    }\n\n    static class LZMADecoder extends CoderBase { @Override InputStream decode(final InputStream in, final Coder coder, byte[] password) throws IOException {\n            byte propsByte = coder.properties[0];\n            long dictSize = coder.properties[1];\n            for (int i = 1; i < 4; i++) {\n                dictSize |= (coder.properties[i + 1] & 0xffl) << (8 * i);\n            }\n            if (dictSize > LZMAInputStream.DICT_SIZE_MAX) {\n                throw new IOException(\"Dictionary larger than 4GiB maximum size\");\n            }\n            return new LZMAInputStream(in, -1, propsByte, (int) dictSize);\n        }\n    }\n    \n    static class DeflateDecoder extends CoderBase { @Override InputStream decode(final InputStream in, final Coder coder, final byte[] password) throws IOException {\n            return new InflaterInputStream(new DummyByteAddingInputStream(in),\n                                           new Inflater(true));\n        }\n        @Override\n        OutputStream encode(final OutputStream out, final byte[] password) {\n            return new DeflaterOutputStream(out, new Deflater(9, true));\n        }\n    }\n\n    static class BZIP2Decoder extends CoderBase { @Override InputStream decode(final InputStream in, final Coder coder, final byte[] password) throws IOException {\n            return new BZip2CompressorInputStream(in);\n        }\n        @Override\n        OutputStream encode(final OutputStream out, final byte[] password)\n                throws IOException {\n            return new BZip2CompressorOutputStream(out);\n        }\n    }\n\n    static class AES256SHA256Decoder extends CoderBase { @Override InputStream decode(final InputStream in, final Coder coder, final byte[] passwordBytes) throws IOException {\n            return new InputStream() {\n                private boolean isInitialized = false; private CipherInputStream cipherInputStream = null; private CipherInputStream init() throws IOException {\n                    if (isInitialized) {\n                        return cipherInputStream;\n                    }\n                    final int byte0 = 0xff & coder.properties[0];\n                    final int numCyclesPower = byte0 & 0x3f;\n                    final int byte1 = 0xff & coder.properties[1];\n                    final int ivSize = ((byte0 >> 6) & 1) + (byte1 & 0x0f);\n                    final int saltSize = ((byte0 >> 7) & 1) + (byte1 >> 4);\n                    if (2 + saltSize + ivSize > coder.properties.length) {\n                        throw new IOException(\"Salt size + IV size too long\");\n                    }\n                    final byte[] salt = new byte[saltSize];\n                    System.arraycopy(coder.properties, 2, salt, 0, saltSize);\n                    final byte[] iv = new byte[16];\n                    System.arraycopy(coder.properties, 2 + saltSize, iv, 0, ivSize);\n                    \n                    if (passwordBytes == null) {\n                        throw new IOException(\"Cannot read encrypted files without a password\");\n                    }\n                    final byte[] aesKeyBytes;\n                    if (numCyclesPower == 0x3f) {\n                        aesKeyBytes = new byte[32];\n                        System.arraycopy(salt, 0, aesKeyBytes, 0, saltSize);\n                        System.arraycopy(passwordBytes, 0, aesKeyBytes, saltSize,\n                                Math.min(passwordBytes.length, aesKeyBytes.length - saltSize));\n                    } else {\n                        final MessageDigest digest;\n                        try {\n                            digest = MessageDigest.getInstance(\"SHA-256\");\n                        } catch (NoSuchAlgorithmException noSuchAlgorithmException) {\n                            IOException ioe = new IOException(\"SHA-256 is unsupported by your Java implementation\");\n                            ioe.initCause(noSuchAlgorithmException);\n                            throw ioe;\n        \n\n\n                        }\n                        final byte[] extra = new byte[8];\n                        for (long j = 0; j < (1L << numCyclesPower); j++) {\n                            digest.update(salt);\n                            digest.update(passwordBytes);\n                            digest.update(extra);\n                            for (int k = 0; k < extra.length; k++) {\n                                ++extra[k];\n                                if (extra[k] != 0) {\n                                    break;\n                                }\n                            }\n                        }\n                        aesKeyBytes = digest.digest();\n                    }\n                    \n                    final SecretKey aesKey = new SecretKeySpec(aesKeyBytes, \"AES\");\n                    try {\n                        final Cipher cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n                        cipher.init(Cipher.DECRYPT_MODE, aesKey, new IvParameterSpec(iv));\n                        cipherInputStream = new CipherInputStream(in, cipher);\n                        isInitialized = true;\n                        return cipherInputStream;\n                    } catch (GeneralSecurityException generalSecurityException) {\n                        IOException ioe = new IOException(\"Decryption error \" +\n                                \"(do you have the JCE Unlimited Strength Jurisdiction Policy Files installed?)\");\n                        ioe.initCause(generalSecurityException);\n                        throw ioe;\n        \n\n\n\n                    }\n                }\n                \n                @Override\n                public int read() throws IOException {\n                    return init().read();\n                }\n                \n                @Override\n                public int read(byte[] b, int off, int len) throws IOException {\n                    return init().read(b, off, len);\n                }\n                \n                @Override\n                public void close() {\n                }\n            };\n        }\n    }\n\n    \n    private static class DummyByteAddingInputStream extends FilterInputStream { private boolean addDummyByte = true; private DummyByteAddingInputStream(InputStream in) {\n            super(in);\n        }\n\n        @Override\n        public int read() throws IOException {\n            int result = super.read();\n            if (result == -1 && addDummyByte) {\n                addDummyByte = false;\n                result = 0;\n            }\n            return result;\n        }\n\n        @Override\n        public int read(byte[] b, int off, int len) throws IOException {\n            int result = super.read(b, off, len);\n            if (result == -1 && addDummyByte) {\n                addDummyByte = false;\n                b[off] = 0;\n                return 1;\n            }\n            return result;\n        }\n    }\n}\n",
      "buggy_signatures": [
        "static InputStream addDecoder(final InputStream is, final Coder coder, final byte[] password) throws IOException",
        "static OutputStream addEncoder(final OutputStream out, final SevenZMethod method, final byte[] password) throws IOException",
        "static abstract class CoderBase { abstract InputStream decode(final InputStream in, final Coder coder, byte[] password) throws IOException; OutputStream encode(final OutputStream out, final byte[] password) throws IOException",
        "static class CopyDecoder extends CoderBase { @Override InputStream decode(final InputStream in, final Coder coder, byte[] password) throws IOException",
        "static class LZMADecoder extends CoderBase { @Override InputStream decode(final InputStream in, final Coder coder, byte[] password) throws IOException",
        "static class DeflateDecoder extends CoderBase { @Override InputStream decode(final InputStream in, final Coder coder, final byte[] password) throws IOException",
        "static class BZIP2Decoder extends CoderBase { @Override InputStream decode(final InputStream in, final Coder coder, final byte[] password) throws IOException",
        "static class AES256SHA256Decoder extends CoderBase { @Override InputStream decode(final InputStream in, final Coder coder, final byte[] passwordBytes) throws IOException",
        "public int read() throws IOException",
        "public int read(byte[] b, int off, int len) throws IOException",
        "public void close()",
        "public int read() throws IOException",
        "public int read(byte[] b, int off, int len) throws IOException"
      ],
      "fixed_signatures": [
        "static InputStream addDecoder(final InputStream is, final Coder coder, final byte[] password) throws IOException",
        "static OutputStream addEncoder(final OutputStream out, final SevenZMethod method, final byte[] password) throws IOException",
        "static abstract class CoderBase { abstract InputStream decode(final InputStream in, final Coder coder, byte[] password) throws IOException; OutputStream encode(final OutputStream out, final byte[] password) throws IOException",
        "static class CopyDecoder extends CoderBase { @Override InputStream decode(final InputStream in, final Coder coder, byte[] password) throws IOException",
        "static class LZMADecoder extends CoderBase { @Override InputStream decode(final InputStream in, final Coder coder, byte[] password) throws IOException",
        "static class DeflateDecoder extends CoderBase { @Override InputStream decode(final InputStream in, final Coder coder, final byte[] password) throws IOException",
        "static class BZIP2Decoder extends CoderBase { @Override InputStream decode(final InputStream in, final Coder coder, final byte[] password) throws IOException",
        "static class AES256SHA256Decoder extends CoderBase { @Override InputStream decode(final InputStream in, final Coder coder, final byte[] passwordBytes) throws IOException",
        "public int read() throws IOException",
        "public int read(byte[] b, int off, int len) throws IOException",
        "public void close()",
        "public int read() throws IOException",
        "public int read(byte[] b, int off, int len) throws IOException"
      ],
      "methods": [
        {
          "buggy_method": "  static OutputStream addEncoder(final OutputStream out, final SevenZMethod method, final byte[] password) throws IOException {\n  for (final CoderId coderId : coderTable) {\n  if (coderId.method.equals(method)) {\n  return coderId.coder.encode(out, password);\n  }\n  }\n  throw new IOException(\"Unsupported compression method \" + method);\n  }",
          "fixed_method": "  static OutputStream addEncoder(final OutputStream out, final SevenZMethod method, final byte[] password) throws IOException {\n  for (final CoderId coderId : coderTable) {\n  if (coderId.method.equals(method)) {\n  return coderId.coder.encode(out, password);\n  }\n  }\n  throw new IOException(\"Unsupported compression method \" + method);\n  }",
          "diff": [
            "@@ -109,7 +109,7 @@",
            "             byte propsByte = coder.properties[0];\n",
            "             long dictSize = coder.properties[1];\n",
            "             for (int i = 1; i < 4; i++) {\n",
            "-                dictSize |= (coder.properties[i + 1] << (8 * i));\n",
            "+                dictSize |= (coder.properties[i + 1] & 0xffl) << (8 * i);\n",
            "             }\n",
            "             if (dictSize > LZMAInputStream.DICT_SIZE_MAX) {\n",
            "                 throw new IOException(\"Dictionary larger than 4GiB maximum size\");\n"
          ],
          "changed_lines": 2
        }
      ]
    }
  ]
}
