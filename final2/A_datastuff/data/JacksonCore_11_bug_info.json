{
  "bug_id": "11",
  "failed_tests": {
    "com.fasterxml.jackson.core.sym.SymbolsViaParserTest": [
      {
        "methodName": "testSymbolTableExpansionBytes",
        "error": "java.lang.ArrayIndexOutOfBoundsException",
        "message": "Index 512 out of bounds for length 512",
        "fail_line": "        _testSymbolTableExpansion(true);",
        "test_source": "  public void testSymbolTableExpansionBytes() throws Exception {\n  _testSymbolTableExpansion(true);\n  }",
        "stack": [
          "ByteQuadsCanonicalizer.addName line 824, UTF8StreamJsonParser.addName line 2340, UTF8StreamJsonParser.findName line 2185, UTF8StreamJsonParser._parseName line 1686, UTF8StreamJsonParser.nextToken line 740, SymbolsViaParserTest._testSymbolTableExpansion line 87, SymbolsViaParserTest.testSymbolTableExpansionBytes line 32"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "com/fasterxml/jackson/core/sym/ByteQuadsCanonicalizer.java",
      "buggy_full_code": "package com.fasterxml.jackson.core.sym;\n\nimport java.util.Arrays;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport com.fasterxml.jackson.core.JsonFactory;\nimport com.fasterxml.jackson.core.util.InternCache;\n\n\npublic final class ByteQuadsCanonicalizer { private static final int DEFAULT_T_SIZE = 64; private static final int MAX_T_SIZE = 0x10000; final static int MIN_HASH_SIZE = 16; final static int MAX_ENTRIES_FOR_REUSE = 6000; final protected ByteQuadsCanonicalizer _parent; final protected AtomicReference<TableInfo> _tableInfo; final private int _seed; protected boolean _intern; protected final boolean _failOnDoS; protected int[] _hashArea; protected int _hashSize; protected int _secondaryStart; protected int _tertiaryStart; protected int _tertiaryShift; protected int _count; protected String[] _names; protected int _spilloverEnd; protected int _longNameOffset; private transient boolean _needRehash; private boolean _hashShared; private ByteQuadsCanonicalizer(int sz, boolean intern, int seed, boolean failOnDoS) {\n        _parent = null;\n        _seed = seed;\n        _intern = intern;\n        _failOnDoS = failOnDoS;\n        \n        if (sz < MIN_HASH_SIZE) {\n            sz = MIN_HASH_SIZE;\n        } else {\n            \n            \n            if ((sz & (sz - 1)) != 0) { \n                int curr = MIN_HASH_SIZE;\n                while (curr < sz) {\n                    curr += curr;\n                }\n                sz = curr;\n            }\n        }\n        _tableInfo = new AtomicReference<TableInfo>(TableInfo.createInitial(sz));\n    }\n\n    \n    private ByteQuadsCanonicalizer(ByteQuadsCanonicalizer parent, boolean intern, int seed, boolean failOnDoS, TableInfo state) {\n        _parent = parent;\n        _seed = seed;\n        _intern = intern;\n        _failOnDoS = failOnDoS;\n        _tableInfo = null; \n\n        \n        _count = state.count;\n        _hashSize = state.size;\n        _secondaryStart = _hashSize << 2; \n        _tertiaryStart = _secondaryStart + (_secondaryStart >> 1); \n        _tertiaryShift = state.tertiaryShift;\n        \n        _hashArea = state.mainHash;\n        _names = state.names;\n\n        _spilloverEnd = state.spilloverEnd;\n        _longNameOffset = state.longNameOffset;\n\n        \n        _needRehash = false;\n        _hashShared = true;\n    }\n\n    \n    \n    \n    public static ByteQuadsCanonicalizer createRoot() {\n        \n        long now = System.currentTimeMillis();\n        \n        int seed = (((int) now) + ((int) (now >>> 32))) | 1;\n        return createRoot(seed);\n    }\n\n    \n    protected static ByteQuadsCanonicalizer createRoot(int seed) {\n        return new ByteQuadsCanonicalizer(DEFAULT_T_SIZE, true, seed, true);\n    }\n    \n    \n    public ByteQuadsCanonicalizer makeChild(int flags) {\n        return new ByteQuadsCanonicalizer(this,\n                JsonFactory.Feature.INTERN_FIELD_NAMES.enabledIn(flags),\n                _seed,\n                JsonFactory.Feature.FAIL_ON_SYMBOL_HASH_OVERFLOW.enabledIn(flags),\n                _tableInfo.get());\n    }\n\n    \n    public void release() {\n        \n        if (_parent != null && maybeDirty()) {\n            _parent.mergeChild(new TableInfo(this));\n            \n            _hashShared = true;\n        }\n    }\n\n    private void mergeChild(TableInfo childState) {\n        final int childCount = childState.count;\n        TableInfo currState = _tableInfo.get();\n\n        \n        \n        if (childCount == currState.count) {\n            return;\n        }\n\n        \n        \n        \n        \n        if (childCount > MAX_ENTRIES_FOR_REUSE) {\n            \n            childState = TableInfo.createInitial(DEFAULT_T_SIZE);\n        }\n        _tableInfo.compareAndSet(currState, childState);\n    }\n\n    \n\n    public int size() {\n        if (_tableInfo != null) { \n            return _tableInfo.get().count;\n        }\n        \n        return _count;\n    }\n\n    \n    public int bucketCount() { return _hashSize; }\n\n    \n    public boolean maybeDirty() { return !_hashShared; }\n\n    public int hashSeed() { return _seed; }\n    \n    \n    public int primaryCount() {\n        int count = 0;\n        for (int offset = 3, end = _secondaryStart; offset < end; offset += 4) {\n            if (_hashArea[offset] != 0) {\n                ++count;\n            }\n        }\n        return count;\n    }\n\n    \n    public int secondaryCount() {\n        int count = 0;\n        int offset = _secondaryStart + 3;\n        for (int end = _tertiaryStart; offset < end; offset += 4) {\n            if (_hashArea[offset] != 0) {\n                ++count;\n            }\n        }\n        return count;\n    }\n\n    \n    public int tertiaryCount() {\n        int count = 0;\n        int offset = _tertiaryStart + 3; \n        for (int end = offset + _hashSize; offset < end; offset += 4) {\n            if (_hashArea[offset] != 0) {\n                ++count;\n            }\n        }\n        return count;\n    }\n\n    \n    public int spilloverCount() {\n        \n        return (_spilloverEnd - _spilloverStart()) >> 2;\n    }\n\n    public int totalCount() {\n        int count = 0;\n        for (int offset = 3, end = (_hashSize << 3); offset < end; offset += 4) {\n            if (_hashArea[offset] != 0) {\n                ++count;\n            }\n        }\n        return count;\n    }\n\n    @Override\n    public String toString() {\n        int pri = primaryCount();\n        int sec = secondaryCount();\n        int tert = tertiaryCount();\n        int spill = spilloverCount();\n        int total = totalCount();\n        return String.format(\"[%s: size=%d, hashSize=%d, %d/%d/%d/%d pri/sec/ter/spill (=%s), total:%d]\",\n                getClass().getName(), _count, _hashSize,\n                pri, sec, tert, spill, total, (pri+sec+tert+spill), total);\n    }\n\n    \n\n    public String findName(int q1) {\n        int offset = _calcOffset(calcHash(q1));\n        \n        final int[] hashArea = _hashArea;\n\n        int len = hashArea[offset+3];\n\n        if (len == 1) {\n            if (hashArea[offset] == q1) {\n                return _names[offset >> 2];\n            }\n        } else if (len == 0) { \n            return null;\n        }\n        \n        int offset2 = _secondaryStart + ((offset >> 3) << 2);\n\n        len = hashArea[offset2+3];\n\n        if (len == 1) {\n            if (hashArea[offset2] == q1) {\n                return _names[offset2 >> 2];\n            }\n        } else if (len == 0) { \n            return null;\n        }\n\n        \n        return _findSecondary(offset, q1);\n    }\n\n    public String findName(int q1, int q2) {\n        int offset = _calcOffset(calcHash(q1, q2));\n\n        final int[] hashArea = _hashArea;\n\n        int len = hashArea[offset+3];\n\n        if (len == 2) {\n            if ((q1 == hashArea[offset]) && (q2 == hashArea[offset+1])) {\n                return _names[offset >> 2];\n            }\n        } else if (len == 0) { \n            return null;\n        }\n        \n        int offset2 = _secondaryStart + ((offset >> 3) << 2);\n\n        len = hashArea[offset2+3];\n\n        if (len == 2) {\n            if ((q1 == hashArea[offset2]) && (q2 == hashArea[offset2+1])) {\n                return _names[offset2 >> 2];\n            }\n        } else if (len == 0) { \n            return null;\n        }\n        return _findSecondary(offset, q1, q2);\n    }\n\n    public String findName(int q1, int q2, int q3) {\n        int offset = _calcOffset(calcHash(q1, q2, q3));\n        final int[] hashArea = _hashArea;\n        int len = hashArea[offset+3];\n\n        if (len == 3) {\n            if ((q1 == hashArea[offset]) && (hashArea[offset+1] == q2) && (hashArea[offset+2] == q3)) {\n                return _names[offset >> 2];\n            }\n        } else if (len == 0) { \n            return null;\n        }\n        \n        int offset2 = _secondaryStart + ((offset >> 3) << 2);\n\n        len = hashArea[offset2+3];\n\n        if (len == 3) {\n            if ((q1 == hashArea[offset2]) && (hashArea[offset2+1] == q2) && (hashArea[offset2+2] == q3)) {\n                return _names[offset2 >> 2];\n            }\n        } else if (len == 0) { \n            return null;\n        }\n        return _findSecondary(offset, q1, q2, q3);\n    }\n\n    public String findName(int[] q, int qlen) {\n        \n        if (qlen < 4) { \n            if (qlen == 3) {\n                return findName(q[0], q[1], q[2]);\n            }\n            if (qlen == 2) {\n                return findName(q[0], q[1]);\n            }\n            return findName(q[0]);\n        }\n        final int hash = calcHash(q, qlen);\n        int offset = _calcOffset(hash);\n\n        final int[] hashArea = _hashArea;\n\n        final int len = hashArea[offset+3];\n        \n        if ((hash == hashArea[offset]) && (len == qlen)) {\n            \n            if (_verifyLongName(q, qlen, hashArea[offset+1])) {\n                return _names[offset >> 2];\n            }\n        }\n        if (len == 0) { \n            return null;\n        }\n        \n        int offset2 = _secondaryStart + ((offset >> 3) << 2);\n\n        final int len2 = hashArea[offset2+3];\n        if ((hash == hashArea[offset2]) && (len2 == qlen)) {\n            if (_verifyLongName(q, qlen, hashArea[offset2+1])) {\n                return _names[offset2 >> 2];\n            }\n        }\n        if (len == 0) { \n            return null;\n        }\n        return _findSecondary(offset, hash, q, qlen);\n    }\n    \n    private final int _calcOffset(int hash) {\n        \n        \n        \n        int ix = hash & (_hashSize-1);\n        \n        return (ix << 2);\n    }\n\n    \n\n    private String _findSecondary(int origOffset, int q1) {\n        \n        \n        \n        \n        int offset = _tertiaryStart + ((origOffset >> (_tertiaryShift + 2)) << _tertiaryShift);\n        final int[] hashArea = _hashArea;\n        final int bucketSize = (1 << _tertiaryShift);\n        for (int end = offset + bucketSize; offset < end; offset += 4) {\n            int len = hashArea[offset+3];\n            if ((q1 == hashArea[offset]) && (1 == len)) {\n                return _names[offset >> 2];\n            }\n            if (len == 0) {\n                return null;\n            }\n        }\n        \n        \n        \n        for (offset = _spilloverStart(); offset < _spilloverEnd; offset += 4) {\n            if ((q1 == hashArea[offset]) && (1 == hashArea[offset+3])) {\n                return _names[offset >> 2];\n            }\n        }\n        return null;\n    }\n\n    private String _findSecondary(int origOffset, int q1, int q2) {\n        int offset = _tertiaryStart + ((origOffset >> (_tertiaryShift + 2)) << _tertiaryShift);\n        final int[] hashArea = _hashArea;\n\n        final int bucketSize = (1 << _tertiaryShift);\n        for (int end = offset + bucketSize; offset < end; offset += 4) {\n            int len = hashArea[offset+3];\n            if ((q1 == hashArea[offset]) && (q2 == hashArea[offset+1]) && (2 == len)) {\n                return _names[offset >> 2];\n            }\n            if (len == 0) {\n                return null;\n            }\n        }\n        for (offset = _spilloverStart(); offset < _spilloverEnd; offset += 4) {\n            if ((q1 == hashArea[offset]) && (q2 == hashArea[offset+1]) && (2 == hashArea[offset+3])) {\n                return _names[offset >> 2];\n            }\n        }\n        return null;\n    }\n\n    private String _findSecondary(int origOffset, int q1, int q2, int q3) {\n        int offset = _tertiaryStart + ((origOffset >> (_tertiaryShift + 2)) << _tertiaryShift);\n        final int[] hashArea = _hashArea;\n\n        final int bucketSize = (1 << _tertiaryShift);\n        for (int end = offset + bucketSize; offset < end; offset += 4) {\n            int len = hashArea[offset+3];\n            if ((q1 == hashArea[offset]) && (q2 == hashArea[offset+1]) && (q3 == hashArea[offset+2]) && (3 == len)) {\n                return _names[offset >> 2];\n            }\n            if (len == 0) {\n                return null;\n            }\n        }\n        for (offset = _spilloverStart(); offset < _spilloverEnd; offset += 4) {\n            if ((q1 == hashArea[offset]) && (q2 == hashArea[offset+1]) && (q3 == hashArea[offset+2])\n                    && (3 == hashArea[offset+3])) {\n                return _names[offset >> 2];\n            }\n        }\n        return null;\n    }\n\n    private String _findSecondary(int origOffset, int hash, int[] q, int qlen) {\n        int offset = _tertiaryStart + ((origOffset >> (_tertiaryShift + 2)) << _tertiaryShift);\n        final int[] hashArea = _hashArea;\n\n        final int bucketSize = (1 << _tertiaryShift);\n        for (int end = offset + bucketSize; offset < end; offset += 4) {\n            int len = hashArea[offset+3];\n            if ((hash == hashArea[offset]) && (qlen == len)) {\n                if (_verifyLongName(q, qlen, hashArea[offset+1])) {\n                    return _names[offset >> 2];\n                }\n            }\n            if (len == 0) {\n                return null;\n            }\n        }\n        for (offset = _spilloverStart(); offset < _spilloverEnd; offset += 4) {\n            if ((hash == hashArea[offset]) && (qlen == hashArea[offset+3])) {\n                if (_verifyLongName(q, qlen, hashArea[offset+1])) {\n                    return _names[offset >> 2];\n                }\n            }\n        }\n        return null;\n    }\n    \n    private boolean _verifyLongName(int[] q, int qlen, int spillOffset) {\n        final int[] hashArea = _hashArea;\n        \n        int ix = 0;\n\n        switch (qlen) {\n        default:\n            return _verifyLongName2(q, qlen, spillOffset);\n        case 8:\n            if (q[ix++] != hashArea[spillOffset++]) return false;\n        case 7:\n            if (q[ix++] != hashArea[spillOffset++]) return false;\n        case 6:\n            if (q[ix++] != hashArea[spillOffset++]) return false;\n        case 5:\n            if (q[ix++] != hashArea[spillOffset++]) return false;\n        case 4: \n            if (q[ix++] != hashArea[spillOffset++]) return false;\n            if (q[ix++] != hashArea[spillOffset++]) return false;\n            if (q[ix++] != hashArea[spillOffset++]) return false;\n            if (q[ix++] != hashArea[spillOffset++]) return false;\n        }\n        return true;\n    }\n\n    private boolean _verifyLongName2(int[] q, int qlen, int spillOffset) {\n        int ix = 0;\n        do {\n            if (q[ix++] != _hashArea[spillOffset++]) {\n                return false;\n            }\n        } while (ix < qlen);\n        return true;\n    }\n\n    \n\n    public String addName(String name, int q1) {\n        _verifySharing();\n        if (_intern) {\n            name = InternCache.instance.intern(name);\n        }\n        int offset = _findOffsetForAdd(calcHash(q1));\n        _hashArea[offset] = q1;\n        _hashArea[offset+3] = 1;\n        _names[offset >> 2] = name;\n        ++_count;\n        _verifyNeedForRehash();\n        return name;\n    }\n\n    public String addName(String name, int q1, int q2) {\n        _verifySharing();\n        if (_intern) {\n            name = InternCache.instance.intern(name);\n        }\n        int hash = (q2 == 0) ? calcHash(q1) : calcHash(q1, q2);\n        int offset = _findOffsetForAdd(hash);\n        _hashArea[offset] = q1;\n        _hashArea[offset+1] = q2;\n        _hashArea[offset+3] = 2;\n        _names[offset >> 2] = name;\n        ++_count;\n        _verifyNeedForRehash();\n        return name;\n    }\n\n    public String addName(String name, int q1, int q2, int q3) {\n        _verifySharing();\n        if (_intern) {\n            name = InternCache.instance.intern(name);\n        }\n        int offset = _findOffsetForAdd(calcHash(q1, q2, q3));\n        _hashArea[offset] = q1;\n        _hashArea[offset+1] = q2;\n        _hashArea[offset+2] = q3;\n        _hashArea[offset+3] = 3;\n        _names[offset >> 2] = name;\n        ++_count;\n        _verifyNeedForRehash();\n        return name;\n    }\n\n    public String addName(String name, int[] q, int qlen) {\n        _verifySharing();\n        if (_intern) {\n            name = InternCache.instance.intern(name);\n        }\n        int offset;\n        \n        switch (qlen) {\n        case 1:\n        {\n                offset = _findOffsetForAdd(calcHash(q[0]));\n                _hashArea[offset] = q[0];\n                _hashArea[offset+3] = 1;\n            }\n            break;\n        case 2:\n            {\n                offset = _findOffsetForAdd(calcHash(q[0], q[1]));\n                _hashArea[offset] = q[0];\n                _hashArea[offset+1] = q[1];\n                _hashArea[offset+3] = 2;\n            }\n            break;\n        case 3:\n            {\n                offset = _findOffsetForAdd(calcHash(q[0], q[1], q[2]));\n                _hashArea[offset] = q[0];\n                _hashArea[offset+1] = q[1];\n                _hashArea[offset+2] = q[2];\n                _hashArea[offset+3] = 3;\n            }\n            break;\n        default:\n            final int hash = calcHash(q, qlen);\n            offset = _findOffsetForAdd(hash);\n\n            _hashArea[offset] = hash;\n            int longStart = _appendLongName(q, qlen);\n            _hashArea[offset+1] = longStart;\n            _hashArea[offset+3] = qlen;\n        }\n        \n        _names[offset >> 2] = name;\n\n        \n        ++_count;\n        _verifyNeedForRehash();\n        return name;\n    }\n\n    private void _verifyNeedForRehash() {\n        \n        if (_count > (_hashSize >> 1)) { \n            int spillCount = (_spilloverEnd - _spilloverStart()) >> 2;\n            if ((spillCount > (1 + _count >> 7))\n                    || (_count > (_hashSize * 0.80))) {\n                _needRehash = true;\n            }\n        }\n    }\n\n    private void _verifySharing() {\n        if (_hashShared) {\n            _hashArea = Arrays.copyOf(_hashArea, _hashArea.length);\n            _names = Arrays.copyOf(_names, _names.length);\n            _hashShared = false;\n            \n            \n        }\n        if (_needRehash) {\n            rehash();\n        }\n    }\n\n    \n    private int _findOffsetForAdd(int hash) {\n        \n        int offset = _calcOffset(hash);\n        final int[] hashArea = _hashArea;\n        if (hashArea[offset+3] == 0) {\n\n            return offset;\n        }\n        \n        int offset2 = _secondaryStart + ((offset >> 3) << 2);\n        if (hashArea[offset2+3] == 0) {\n\n            return offset2;\n        }\n        \n\n        offset2 = _tertiaryStart + ((offset >> (_tertiaryShift + 2)) << _tertiaryShift);\n        final int bucketSize = (1 << _tertiaryShift);\n        for (int end = offset2 + bucketSize; offset2 < end; offset2 += 4) {\n            if (hashArea[offset2+3] == 0) {\n\n                return offset2;\n            }\n        }\n\n        \n        offset = _spilloverEnd;\n        _spilloverEnd += 4;\n\n\n        \n        \n        \n        \n        \n        final int end = (_hashSize << 3);\n        if (_spilloverEnd >= end) {\n            if (_failOnDoS) {\n                _reportTooManyCollisions();\n            }\n            \n            \n            _needRehash = true;\n        }\n        return offset;\n    }\n\n    private int _appendLongName(int[] quads, int qlen) {\n        int start = _longNameOffset;\n        \n        \n        if ((start + qlen) > _hashArea.length) {\n            \n            int toAdd = (start + qlen) - _hashArea.length;\n            \n            int minAdd = Math.min(4096, _hashSize);\n\n            int newSize = _hashArea.length + Math.max(toAdd, minAdd);\n            _hashArea = Arrays.copyOf(_hashArea, newSize);\n        }\n        System.arraycopy(quads, 0, _hashArea, start, qlen);\n        _longNameOffset += qlen;\n        return start;\n    }\n\n    \n\n    \n    \n    \n    \n    \n    private final static int MULT = 33; private final static int MULT2 = 65599; private final static int MULT3 = 31; public int calcHash(int q1) {\n        int hash = q1 ^ _seed;\n        \n        hash += (hash >>> 16); \n        hash ^= (hash << 3); \n        hash += (hash >>> 12); \n        return hash;\n    }\n\n    public int calcHash(int q1, int q2) {\n        \n        \n        int hash = q1;\n\n        hash += (hash >>> 15); \n        hash ^= (hash >>> 9); \n        hash += (q2 * MULT); \n        hash ^= _seed;\n        hash += (hash >>> 16); \n        hash ^= (hash >>> 4);\n        hash += (hash << 3);\n        \n        return hash;\n    }\n\n    public int calcHash(int q1, int q2, int q3) { \n        int hash = q1 ^ _seed;\n        hash += (hash >>> 9);\n        hash *= MULT3;\n        hash += q2;\n        hash *= MULT;\n        hash += (hash >>> 15);\n        hash ^= q3;\n        \n        hash += (hash >>> 4);\n\n        hash += (hash >>> 15);\n        hash ^= (hash << 9);\n\n        return hash;\n    }\n\n    public int calcHash(int[] q, int qlen) {\n        if (qlen < 4) {\n            throw new IllegalArgumentException();\n        }\n        \n        int hash = q[0] ^ _seed;\n        hash += (hash >>> 9);\n        hash += q[1];\n        hash += (hash >>> 15);\n        hash *= MULT;\n        hash ^= q[2];\n        hash += (hash >>> 4);\n\n        for (int i = 3; i < qlen; ++i) {\n            int next = q[i];\n            next = next ^ (next >> 21);\n            hash += next;\n        }\n        hash *= MULT2;\n        \n        \n        hash += (hash >>> 19);\n        hash ^= (hash << 5);\n        return hash;\n    }\n\n    \n\n    private void rehash() {\n        _needRehash = false;\n        \n        _hashShared = false;\n\n        \n        \n        final int[] oldHashArea = _hashArea;\n        final String[] oldNames = _names;\n        final int oldSize = _hashSize;\n        final int oldCount = _count;\n        final int newSize = oldSize + oldSize;\n        final int oldEnd = _spilloverEnd;\n\n        \n        if (newSize > MAX_T_SIZE) {\n            nukeSymbols(true);\n            return;\n        }\n        \n        _hashArea = new int[oldHashArea.length + (oldSize<<3)];\n        _hashSize = newSize;\n        _secondaryStart = (newSize << 2); \n        _tertiaryStart = _secondaryStart + (_secondaryStart >> 1); \n        _tertiaryShift = _calcTertiaryShift(newSize);\n        \n        \n        _names = new String[oldNames.length << 1];\n        nukeSymbols(false);\n\n        \n        \n        \n        \n\n        int copyCount = 0;\n        int[] q = new int[16];\n        for (int offset = 0, end = oldEnd; offset < end; offset += 4) {\n            int len = oldHashArea[offset+3];\n            if (len == 0) { \n                continue;\n            }\n            ++copyCount;\n            String name = oldNames[offset>>2];\n            switch (len) {\n            case 1:\n                q[0] = oldHashArea[offset];\n                addName(name, q, 1);\n                break;\n            case 2:\n                q[0] = oldHashArea[offset];\n                q[1] = oldHashArea[offset+1];\n                addName(name, q, 2);\n                break;\n            case 3:\n                q[0] = oldHashArea[offset];\n                q[1] = oldHashArea[offset+1];\n                q[2] = oldHashArea[offset+2];\n                addName(name, q, 3);\n                break;\n            default:\n                if (len > q.length) {\n                    q = new int[len];\n                }\n                \n                int qoff = oldHashArea[offset+1];\n                System.arraycopy(oldHashArea, qoff, q, 0, len);\n                addName(name, q, len);\n                break;\n            }\n        }\n\n        \n        \n        if (copyCount != oldCount) {\n            throw new IllegalStateException(\"Failed rehash(): old count=\"+oldCount+\", copyCount=\"+copyCount);\n        }\n    }\n\n    \n    private void nukeSymbols(boolean fill) {\n        _count = 0;\n        \n        _spilloverEnd = _spilloverStart();\n        \n        _longNameOffset = _hashSize << 3;\n        if (fill) {\n            Arrays.fill(_hashArea, 0);\n            Arrays.fill(_names, null);\n        }\n    }\n\n    \n\n    \n    private final int _spilloverStart() {\n        \n        \n        int offset = _hashSize;\n        return (offset << 3) - offset;\n    }\n\n    protected void _reportTooManyCollisions() {\n        \n        if (_hashSize <= 1024) { \n            return;\n        }\n        throw new IllegalStateException(\"Spill-over slots in symbol table with \"+_count\n                +\" entries, hash area of \"+_hashSize+\" slots is now full (all \"\n                +(_hashSize >> 3)+\" slots -- suspect a DoS attack based on hash collisions.\"\n                +\" You can disable the check via `JsonFactory.Feature.FAIL_ON_SYMBOL_HASH_OVERFLOW`\");\n    }\n\n    static int _calcTertiaryShift(int primarySlots) {\n        \n        int tertSlots = (primarySlots) >> 2;\n        \n        \n        if (tertSlots < 64) {\n            return 4;\n        }\n        if (tertSlots <= 256) { \n            return 5;\n        }\n        if (tertSlots <= 1024) { \n            return 6;\n        }\n        \n        return 7;\n    }\n\n    \n\n    \n    private final static class TableInfo { public final int size; public final int count; public final int tertiaryShift; public final int[] mainHash; public final String[] names; public final int spilloverEnd; public final int longNameOffset; public TableInfo(int size, int count, int tertiaryShift, int[] mainHash, String[] names, int spilloverEnd, int longNameOffset) {\n            this.size = size;\n            this.count = count;\n            this.tertiaryShift = tertiaryShift;\n            this.mainHash = mainHash;\n            this.names = names;\n            this.spilloverEnd = spilloverEnd;\n            this.longNameOffset = longNameOffset;\n        }\n\n        public TableInfo(ByteQuadsCanonicalizer src) {\n            size = src._hashSize;\n            count = src._count;\n            tertiaryShift = src._tertiaryShift;\n            mainHash = src._hashArea;\n            names = src._names;\n            spilloverEnd = src._spilloverEnd;\n            longNameOffset = src._longNameOffset;\n        }\n\n        public static TableInfo createInitial(int sz) {\n            int hashAreaSize = sz << 3;\n            int tertShift = _calcTertiaryShift(sz);\n\n            return new TableInfo(sz, \n                    0, \n                    tertShift,\n                    new int[hashAreaSize], \n                    new String[sz << 1], \n                    hashAreaSize - sz, \n                    hashAreaSize \n            );\n        }\n    }\n}\n",
      "fixed_full_code": "package com.fasterxml.jackson.core.sym;\n\nimport java.util.Arrays;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport com.fasterxml.jackson.core.JsonFactory;\nimport com.fasterxml.jackson.core.util.InternCache;\n\n\npublic final class ByteQuadsCanonicalizer { private static final int DEFAULT_T_SIZE = 64; private static final int MAX_T_SIZE = 0x10000; final static int MIN_HASH_SIZE = 16; final static int MAX_ENTRIES_FOR_REUSE = 6000; final protected ByteQuadsCanonicalizer _parent; final protected AtomicReference<TableInfo> _tableInfo; final private int _seed; protected boolean _intern; protected final boolean _failOnDoS; protected int[] _hashArea; protected int _hashSize; protected int _secondaryStart; protected int _tertiaryStart; protected int _tertiaryShift; protected int _count; protected String[] _names; protected int _spilloverEnd; protected int _longNameOffset; private transient boolean _needRehash; private boolean _hashShared; private ByteQuadsCanonicalizer(int sz, boolean intern, int seed, boolean failOnDoS) {\n        _parent = null;\n        _seed = seed;\n        _intern = intern;\n        _failOnDoS = failOnDoS;\n        \n        if (sz < MIN_HASH_SIZE) {\n            sz = MIN_HASH_SIZE;\n        } else {\n            \n            \n            if ((sz & (sz - 1)) != 0) { \n                int curr = MIN_HASH_SIZE;\n                while (curr < sz) {\n                    curr += curr;\n                }\n                sz = curr;\n            }\n        }\n        _tableInfo = new AtomicReference<TableInfo>(TableInfo.createInitial(sz));\n    }\n\n    \n    private ByteQuadsCanonicalizer(ByteQuadsCanonicalizer parent, boolean intern, int seed, boolean failOnDoS, TableInfo state) {\n        _parent = parent;\n        _seed = seed;\n        _intern = intern;\n        _failOnDoS = failOnDoS;\n        _tableInfo = null; \n\n        \n        _count = state.count;\n        _hashSize = state.size;\n        _secondaryStart = _hashSize << 2; \n        _tertiaryStart = _secondaryStart + (_secondaryStart >> 1); \n        _tertiaryShift = state.tertiaryShift;\n        \n        _hashArea = state.mainHash;\n        _names = state.names;\n\n        _spilloverEnd = state.spilloverEnd;\n        _longNameOffset = state.longNameOffset;\n\n        \n        _needRehash = false;\n        _hashShared = true;\n    }\n\n    \n    \n    \n    public static ByteQuadsCanonicalizer createRoot() {\n        \n        long now = System.currentTimeMillis();\n        \n        int seed = (((int) now) + ((int) (now >>> 32))) | 1;\n        return createRoot(seed);\n    }\n\n    \n    protected static ByteQuadsCanonicalizer createRoot(int seed) {\n        return new ByteQuadsCanonicalizer(DEFAULT_T_SIZE, true, seed, true);\n    }\n    \n    \n    public ByteQuadsCanonicalizer makeChild(int flags) {\n        return new ByteQuadsCanonicalizer(this,\n                JsonFactory.Feature.INTERN_FIELD_NAMES.enabledIn(flags),\n                _seed,\n                JsonFactory.Feature.FAIL_ON_SYMBOL_HASH_OVERFLOW.enabledIn(flags),\n                _tableInfo.get());\n    }\n\n    \n    public void release() {\n        \n        if (_parent != null && maybeDirty()) {\n            _parent.mergeChild(new TableInfo(this));\n            \n            _hashShared = true;\n        }\n    }\n\n    private void mergeChild(TableInfo childState) {\n        final int childCount = childState.count;\n        TableInfo currState = _tableInfo.get();\n\n        \n        \n        if (childCount == currState.count) {\n            return;\n        }\n\n        \n        \n        \n        \n        if (childCount > MAX_ENTRIES_FOR_REUSE) {\n            \n            childState = TableInfo.createInitial(DEFAULT_T_SIZE);\n        }\n        _tableInfo.compareAndSet(currState, childState);\n    }\n\n    \n\n    public int size() {\n        if (_tableInfo != null) { \n            return _tableInfo.get().count;\n        }\n        \n        return _count;\n    }\n\n    \n    public int bucketCount() { return _hashSize; }\n\n    \n    public boolean maybeDirty() { return !_hashShared; }\n\n    public int hashSeed() { return _seed; }\n    \n    \n    public int primaryCount() {\n        int count = 0;\n        for (int offset = 3, end = _secondaryStart; offset < end; offset += 4) {\n            if (_hashArea[offset] != 0) {\n                ++count;\n            }\n        }\n        return count;\n    }\n\n    \n    public int secondaryCount() {\n        int count = 0;\n        int offset = _secondaryStart + 3;\n        for (int end = _tertiaryStart; offset < end; offset += 4) {\n            if (_hashArea[offset] != 0) {\n                ++count;\n            }\n        }\n        return count;\n    }\n\n    \n    public int tertiaryCount() {\n        int count = 0;\n        int offset = _tertiaryStart + 3; \n        for (int end = offset + _hashSize; offset < end; offset += 4) {\n            if (_hashArea[offset] != 0) {\n                ++count;\n            }\n        }\n        return count;\n    }\n\n    \n    public int spilloverCount() {\n        \n        return (_spilloverEnd - _spilloverStart()) >> 2;\n    }\n\n    public int totalCount() {\n        int count = 0;\n        for (int offset = 3, end = (_hashSize << 3); offset < end; offset += 4) {\n            if (_hashArea[offset] != 0) {\n                ++count;\n            }\n        }\n        return count;\n    }\n\n    @Override\n    public String toString() {\n        int pri = primaryCount();\n        int sec = secondaryCount();\n        int tert = tertiaryCount();\n        int spill = spilloverCount();\n        int total = totalCount();\n        return String.format(\"[%s: size=%d, hashSize=%d, %d/%d/%d/%d pri/sec/ter/spill (=%s), total:%d]\",\n                getClass().getName(), _count, _hashSize,\n                pri, sec, tert, spill, total, (pri+sec+tert+spill), total);\n    }\n\n    \n\n    public String findName(int q1) {\n        int offset = _calcOffset(calcHash(q1));\n        \n        final int[] hashArea = _hashArea;\n\n        int len = hashArea[offset+3];\n\n        if (len == 1) {\n            if (hashArea[offset] == q1) {\n                return _names[offset >> 2];\n            }\n        } else if (len == 0) { \n            return null;\n        }\n        \n        int offset2 = _secondaryStart + ((offset >> 3) << 2);\n\n        len = hashArea[offset2+3];\n\n        if (len == 1) {\n            if (hashArea[offset2] == q1) {\n                return _names[offset2 >> 2];\n            }\n        } else if (len == 0) { \n            return null;\n        }\n\n        \n        return _findSecondary(offset, q1);\n    }\n\n    public String findName(int q1, int q2) {\n        int offset = _calcOffset(calcHash(q1, q2));\n\n        final int[] hashArea = _hashArea;\n\n        int len = hashArea[offset+3];\n\n        if (len == 2) {\n            if ((q1 == hashArea[offset]) && (q2 == hashArea[offset+1])) {\n                return _names[offset >> 2];\n            }\n        } else if (len == 0) { \n            return null;\n        }\n        \n        int offset2 = _secondaryStart + ((offset >> 3) << 2);\n\n        len = hashArea[offset2+3];\n\n        if (len == 2) {\n            if ((q1 == hashArea[offset2]) && (q2 == hashArea[offset2+1])) {\n                return _names[offset2 >> 2];\n            }\n        } else if (len == 0) { \n            return null;\n        }\n        return _findSecondary(offset, q1, q2);\n    }\n\n    public String findName(int q1, int q2, int q3) {\n        int offset = _calcOffset(calcHash(q1, q2, q3));\n        final int[] hashArea = _hashArea;\n        int len = hashArea[offset+3];\n\n        if (len == 3) {\n            if ((q1 == hashArea[offset]) && (hashArea[offset+1] == q2) && (hashArea[offset+2] == q3)) {\n                return _names[offset >> 2];\n            }\n        } else if (len == 0) { \n            return null;\n        }\n        \n        int offset2 = _secondaryStart + ((offset >> 3) << 2);\n\n        len = hashArea[offset2+3];\n\n        if (len == 3) {\n            if ((q1 == hashArea[offset2]) && (hashArea[offset2+1] == q2) && (hashArea[offset2+2] == q3)) {\n                return _names[offset2 >> 2];\n            }\n        } else if (len == 0) { \n            return null;\n        }\n        return _findSecondary(offset, q1, q2, q3);\n    }\n\n    public String findName(int[] q, int qlen) {\n        \n        if (qlen < 4) { \n            if (qlen == 3) {\n                return findName(q[0], q[1], q[2]);\n            }\n            if (qlen == 2) {\n                return findName(q[0], q[1]);\n            }\n            return findName(q[0]);\n        }\n        final int hash = calcHash(q, qlen);\n        int offset = _calcOffset(hash);\n\n        final int[] hashArea = _hashArea;\n\n        final int len = hashArea[offset+3];\n        \n        if ((hash == hashArea[offset]) && (len == qlen)) {\n            \n            if (_verifyLongName(q, qlen, hashArea[offset+1])) {\n                return _names[offset >> 2];\n            }\n        }\n        if (len == 0) { \n            return null;\n        }\n        \n        int offset2 = _secondaryStart + ((offset >> 3) << 2);\n\n        final int len2 = hashArea[offset2+3];\n        if ((hash == hashArea[offset2]) && (len2 == qlen)) {\n            if (_verifyLongName(q, qlen, hashArea[offset2+1])) {\n                return _names[offset2 >> 2];\n            }\n        }\n        if (len == 0) { \n            return null;\n        }\n        return _findSecondary(offset, hash, q, qlen);\n    }\n    \n    private final int _calcOffset(int hash) {\n        \n        \n        \n        int ix = hash & (_hashSize-1);\n        \n        return (ix << 2);\n    }\n\n    \n\n    private String _findSecondary(int origOffset, int q1) {\n        \n        \n        \n        \n        int offset = _tertiaryStart + ((origOffset >> (_tertiaryShift + 2)) << _tertiaryShift);\n        final int[] hashArea = _hashArea;\n        final int bucketSize = (1 << _tertiaryShift);\n        for (int end = offset + bucketSize; offset < end; offset += 4) {\n            int len = hashArea[offset+3];\n            if ((q1 == hashArea[offset]) && (1 == len)) {\n                return _names[offset >> 2];\n            }\n            if (len == 0) {\n                return null;\n            }\n        }\n        \n        \n        \n        for (offset = _spilloverStart(); offset < _spilloverEnd; offset += 4) {\n            if ((q1 == hashArea[offset]) && (1 == hashArea[offset+3])) {\n                return _names[offset >> 2];\n            }\n        }\n        return null;\n    }\n\n    private String _findSecondary(int origOffset, int q1, int q2) {\n        int offset = _tertiaryStart + ((origOffset >> (_tertiaryShift + 2)) << _tertiaryShift);\n        final int[] hashArea = _hashArea;\n\n        final int bucketSize = (1 << _tertiaryShift);\n        for (int end = offset + bucketSize; offset < end; offset += 4) {\n            int len = hashArea[offset+3];\n            if ((q1 == hashArea[offset]) && (q2 == hashArea[offset+1]) && (2 == len)) {\n                return _names[offset >> 2];\n            }\n            if (len == 0) {\n                return null;\n            }\n        }\n        for (offset = _spilloverStart(); offset < _spilloverEnd; offset += 4) {\n            if ((q1 == hashArea[offset]) && (q2 == hashArea[offset+1]) && (2 == hashArea[offset+3])) {\n                return _names[offset >> 2];\n            }\n        }\n        return null;\n    }\n\n    private String _findSecondary(int origOffset, int q1, int q2, int q3) {\n        int offset = _tertiaryStart + ((origOffset >> (_tertiaryShift + 2)) << _tertiaryShift);\n        final int[] hashArea = _hashArea;\n\n        final int bucketSize = (1 << _tertiaryShift);\n        for (int end = offset + bucketSize; offset < end; offset += 4) {\n            int len = hashArea[offset+3];\n            if ((q1 == hashArea[offset]) && (q2 == hashArea[offset+1]) && (q3 == hashArea[offset+2]) && (3 == len)) {\n                return _names[offset >> 2];\n            }\n            if (len == 0) {\n                return null;\n            }\n        }\n        for (offset = _spilloverStart(); offset < _spilloverEnd; offset += 4) {\n            if ((q1 == hashArea[offset]) && (q2 == hashArea[offset+1]) && (q3 == hashArea[offset+2])\n                    && (3 == hashArea[offset+3])) {\n                return _names[offset >> 2];\n            }\n        }\n        return null;\n    }\n\n    private String _findSecondary(int origOffset, int hash, int[] q, int qlen) {\n        int offset = _tertiaryStart + ((origOffset >> (_tertiaryShift + 2)) << _tertiaryShift);\n        final int[] hashArea = _hashArea;\n\n        final int bucketSize = (1 << _tertiaryShift);\n        for (int end = offset + bucketSize; offset < end; offset += 4) {\n            int len = hashArea[offset+3];\n            if ((hash == hashArea[offset]) && (qlen == len)) {\n                if (_verifyLongName(q, qlen, hashArea[offset+1])) {\n                    return _names[offset >> 2];\n                }\n            }\n            if (len == 0) {\n                return null;\n            }\n        }\n        for (offset = _spilloverStart(); offset < _spilloverEnd; offset += 4) {\n            if ((hash == hashArea[offset]) && (qlen == hashArea[offset+3])) {\n                if (_verifyLongName(q, qlen, hashArea[offset+1])) {\n                    return _names[offset >> 2];\n                }\n            }\n        }\n        return null;\n    }\n    \n    private boolean _verifyLongName(int[] q, int qlen, int spillOffset) {\n        final int[] hashArea = _hashArea;\n        \n        int ix = 0;\n\n        switch (qlen) {\n        default:\n            return _verifyLongName2(q, qlen, spillOffset);\n        case 8:\n            if (q[ix++] != hashArea[spillOffset++]) return false;\n        case 7:\n            if (q[ix++] != hashArea[spillOffset++]) return false;\n        case 6:\n            if (q[ix++] != hashArea[spillOffset++]) return false;\n        case 5:\n            if (q[ix++] != hashArea[spillOffset++]) return false;\n        case 4: \n            if (q[ix++] != hashArea[spillOffset++]) return false;\n            if (q[ix++] != hashArea[spillOffset++]) return false;\n            if (q[ix++] != hashArea[spillOffset++]) return false;\n            if (q[ix++] != hashArea[spillOffset++]) return false;\n        }\n        return true;\n    }\n\n    private boolean _verifyLongName2(int[] q, int qlen, int spillOffset) {\n        int ix = 0;\n        do {\n            if (q[ix++] != _hashArea[spillOffset++]) {\n                return false;\n            }\n        } while (ix < qlen);\n        return true;\n    }\n\n    \n\n    public String addName(String name, int q1) {\n        _verifySharing();\n        if (_intern) {\n            name = InternCache.instance.intern(name);\n        }\n        int offset = _findOffsetForAdd(calcHash(q1));\n        _hashArea[offset] = q1;\n        _hashArea[offset+3] = 1;\n        _names[offset >> 2] = name;\n        ++_count;\n        _verifyNeedForRehash();\n        return name;\n    }\n\n    public String addName(String name, int q1, int q2) {\n        _verifySharing();\n        if (_intern) {\n            name = InternCache.instance.intern(name);\n        }\n        int hash = (q2 == 0) ? calcHash(q1) : calcHash(q1, q2);\n        int offset = _findOffsetForAdd(hash);\n        _hashArea[offset] = q1;\n        _hashArea[offset+1] = q2;\n        _hashArea[offset+3] = 2;\n        _names[offset >> 2] = name;\n        ++_count;\n        _verifyNeedForRehash();\n        return name;\n    }\n\n    public String addName(String name, int q1, int q2, int q3) {\n        _verifySharing();\n        if (_intern) {\n            name = InternCache.instance.intern(name);\n        }\n        int offset = _findOffsetForAdd(calcHash(q1, q2, q3));\n        _hashArea[offset] = q1;\n        _hashArea[offset+1] = q2;\n        _hashArea[offset+2] = q3;\n        _hashArea[offset+3] = 3;\n        _names[offset >> 2] = name;\n        ++_count;\n        _verifyNeedForRehash();\n        return name;\n    }\n\n    public String addName(String name, int[] q, int qlen) {\n        _verifySharing();\n        if (_intern) {\n            name = InternCache.instance.intern(name);\n        }\n        int offset;\n        \n        switch (qlen) {\n        case 1:\n        {\n                offset = _findOffsetForAdd(calcHash(q[0]));\n                _hashArea[offset] = q[0];\n                _hashArea[offset+3] = 1;\n            }\n            break;\n        case 2:\n            {\n                offset = _findOffsetForAdd(calcHash(q[0], q[1]));\n                _hashArea[offset] = q[0];\n                _hashArea[offset+1] = q[1];\n                _hashArea[offset+3] = 2;\n            }\n            break;\n        case 3:\n            {\n                offset = _findOffsetForAdd(calcHash(q[0], q[1], q[2]));\n                _hashArea[offset] = q[0];\n                _hashArea[offset+1] = q[1];\n                _hashArea[offset+2] = q[2];\n                _hashArea[offset+3] = 3;\n            }\n            break;\n        default:\n            final int hash = calcHash(q, qlen);\n            offset = _findOffsetForAdd(hash);\n\n            _hashArea[offset] = hash;\n            int longStart = _appendLongName(q, qlen);\n            _hashArea[offset+1] = longStart;\n            _hashArea[offset+3] = qlen;\n        }\n        \n        _names[offset >> 2] = name;\n\n        \n        ++_count;\n        _verifyNeedForRehash();\n        return name;\n    }\n\n    private void _verifyNeedForRehash() {\n        \n        if (_count > (_hashSize >> 1)) { \n            int spillCount = (_spilloverEnd - _spilloverStart()) >> 2;\n            if ((spillCount > (1 + _count >> 7))\n                    || (_count > (_hashSize * 0.80))) {\n                _needRehash = true;\n            }\n        }\n    }\n\n    private void _verifySharing() {\n        if (_hashShared) {\n            _hashArea = Arrays.copyOf(_hashArea, _hashArea.length);\n            _names = Arrays.copyOf(_names, _names.length);\n            _hashShared = false;\n            \n            \n            _verifyNeedForRehash();\n        }\n        if (_needRehash) {\n            rehash();\n        }\n    }\n\n    \n    private int _findOffsetForAdd(int hash) {\n        \n        int offset = _calcOffset(hash);\n        final int[] hashArea = _hashArea;\n        if (hashArea[offset+3] == 0) {\n\n            return offset;\n        }\n        \n        int offset2 = _secondaryStart + ((offset >> 3) << 2);\n        if (hashArea[offset2+3] == 0) {\n\n            return offset2;\n        }\n        \n\n        offset2 = _tertiaryStart + ((offset >> (_tertiaryShift + 2)) << _tertiaryShift);\n        final int bucketSize = (1 << _tertiaryShift);\n        for (int end = offset2 + bucketSize; offset2 < end; offset2 += 4) {\n            if (hashArea[offset2+3] == 0) {\n\n                return offset2;\n            }\n        }\n\n        \n        offset = _spilloverEnd;\n        _spilloverEnd += 4;\n\n\n        \n        \n        \n        \n        \n        final int end = (_hashSize << 3);\n        if (_spilloverEnd >= end) {\n            if (_failOnDoS) {\n                _reportTooManyCollisions();\n            }\n            \n            \n            _needRehash = true;\n        }\n        return offset;\n    }\n\n    private int _appendLongName(int[] quads, int qlen) {\n        int start = _longNameOffset;\n        \n        \n        if ((start + qlen) > _hashArea.length) {\n            \n            int toAdd = (start + qlen) - _hashArea.length;\n            \n            int minAdd = Math.min(4096, _hashSize);\n\n            int newSize = _hashArea.length + Math.max(toAdd, minAdd);\n            _hashArea = Arrays.copyOf(_hashArea, newSize);\n        }\n        System.arraycopy(quads, 0, _hashArea, start, qlen);\n        _longNameOffset += qlen;\n        return start;\n    }\n\n    \n\n    \n    \n    \n    \n    \n    private final static int MULT = 33; private final static int MULT2 = 65599; private final static int MULT3 = 31; public int calcHash(int q1) {\n        int hash = q1 ^ _seed;\n        \n        hash += (hash >>> 16); \n        hash ^= (hash << 3); \n        hash += (hash >>> 12); \n        return hash;\n    }\n\n    public int calcHash(int q1, int q2) {\n        \n        \n        int hash = q1;\n\n        hash += (hash >>> 15); \n        hash ^= (hash >>> 9); \n        hash += (q2 * MULT); \n        hash ^= _seed;\n        hash += (hash >>> 16); \n        hash ^= (hash >>> 4);\n        hash += (hash << 3);\n        \n        return hash;\n    }\n\n    public int calcHash(int q1, int q2, int q3) { \n        int hash = q1 ^ _seed;\n        hash += (hash >>> 9);\n        hash *= MULT3;\n        hash += q2;\n        hash *= MULT;\n        hash += (hash >>> 15);\n        hash ^= q3;\n        \n        hash += (hash >>> 4);\n\n        hash += (hash >>> 15);\n        hash ^= (hash << 9);\n\n        return hash;\n    }\n\n    public int calcHash(int[] q, int qlen) {\n        if (qlen < 4) {\n            throw new IllegalArgumentException();\n        }\n        \n        int hash = q[0] ^ _seed;\n        hash += (hash >>> 9);\n        hash += q[1];\n        hash += (hash >>> 15);\n        hash *= MULT;\n        hash ^= q[2];\n        hash += (hash >>> 4);\n\n        for (int i = 3; i < qlen; ++i) {\n            int next = q[i];\n            next = next ^ (next >> 21);\n            hash += next;\n        }\n        hash *= MULT2;\n        \n        \n        hash += (hash >>> 19);\n        hash ^= (hash << 5);\n        return hash;\n    }\n\n    \n\n    private void rehash() {\n        _needRehash = false;\n        \n        _hashShared = false;\n\n        \n        \n        final int[] oldHashArea = _hashArea;\n        final String[] oldNames = _names;\n        final int oldSize = _hashSize;\n        final int oldCount = _count;\n        final int newSize = oldSize + oldSize;\n        final int oldEnd = _spilloverEnd;\n\n        \n        if (newSize > MAX_T_SIZE) {\n            nukeSymbols(true);\n            return;\n        }\n        \n        _hashArea = new int[oldHashArea.length + (oldSize<<3)];\n        _hashSize = newSize;\n        _secondaryStart = (newSize << 2); \n        _tertiaryStart = _secondaryStart + (_secondaryStart >> 1); \n        _tertiaryShift = _calcTertiaryShift(newSize);\n        \n        \n        _names = new String[oldNames.length << 1];\n        nukeSymbols(false);\n\n        \n        \n        \n        \n\n        int copyCount = 0;\n        int[] q = new int[16];\n        for (int offset = 0, end = oldEnd; offset < end; offset += 4) {\n            int len = oldHashArea[offset+3];\n            if (len == 0) { \n                continue;\n            }\n            ++copyCount;\n            String name = oldNames[offset>>2];\n            switch (len) {\n            case 1:\n                q[0] = oldHashArea[offset];\n                addName(name, q, 1);\n                break;\n            case 2:\n                q[0] = oldHashArea[offset];\n                q[1] = oldHashArea[offset+1];\n                addName(name, q, 2);\n                break;\n            case 3:\n                q[0] = oldHashArea[offset];\n                q[1] = oldHashArea[offset+1];\n                q[2] = oldHashArea[offset+2];\n                addName(name, q, 3);\n                break;\n            default:\n                if (len > q.length) {\n                    q = new int[len];\n                }\n                \n                int qoff = oldHashArea[offset+1];\n                System.arraycopy(oldHashArea, qoff, q, 0, len);\n                addName(name, q, len);\n                break;\n            }\n        }\n\n        \n        \n        if (copyCount != oldCount) {\n            throw new IllegalStateException(\"Failed rehash(): old count=\"+oldCount+\", copyCount=\"+copyCount);\n        }\n    }\n\n    \n    private void nukeSymbols(boolean fill) {\n        _count = 0;\n        \n        _spilloverEnd = _spilloverStart();\n        \n        _longNameOffset = _hashSize << 3;\n        if (fill) {\n            Arrays.fill(_hashArea, 0);\n            Arrays.fill(_names, null);\n        }\n    }\n\n    \n\n    \n    private final int _spilloverStart() {\n        \n        \n        int offset = _hashSize;\n        return (offset << 3) - offset;\n    }\n\n    protected void _reportTooManyCollisions() {\n        \n        if (_hashSize <= 1024) { \n            return;\n        }\n        throw new IllegalStateException(\"Spill-over slots in symbol table with \"+_count\n                +\" entries, hash area of \"+_hashSize+\" slots is now full (all \"\n                +(_hashSize >> 3)+\" slots -- suspect a DoS attack based on hash collisions.\"\n                +\" You can disable the check via `JsonFactory.Feature.FAIL_ON_SYMBOL_HASH_OVERFLOW`\");\n    }\n\n    static int _calcTertiaryShift(int primarySlots) {\n        \n        int tertSlots = (primarySlots) >> 2;\n        \n        \n        if (tertSlots < 64) {\n            return 4;\n        }\n        if (tertSlots <= 256) { \n            return 5;\n        }\n        if (tertSlots <= 1024) { \n            return 6;\n        }\n        \n        return 7;\n    }\n\n    \n\n    \n    private final static class TableInfo { public final int size; public final int count; public final int tertiaryShift; public final int[] mainHash; public final String[] names; public final int spilloverEnd; public final int longNameOffset; public TableInfo(int size, int count, int tertiaryShift, int[] mainHash, String[] names, int spilloverEnd, int longNameOffset) {\n            this.size = size;\n            this.count = count;\n            this.tertiaryShift = tertiaryShift;\n            this.mainHash = mainHash;\n            this.names = names;\n            this.spilloverEnd = spilloverEnd;\n            this.longNameOffset = longNameOffset;\n        }\n\n        public TableInfo(ByteQuadsCanonicalizer src) {\n            size = src._hashSize;\n            count = src._count;\n            tertiaryShift = src._tertiaryShift;\n            mainHash = src._hashArea;\n            names = src._names;\n            spilloverEnd = src._spilloverEnd;\n            longNameOffset = src._longNameOffset;\n        }\n\n        public static TableInfo createInitial(int sz) {\n            int hashAreaSize = sz << 3;\n            int tertShift = _calcTertiaryShift(sz);\n\n            return new TableInfo(sz, \n                    0, \n                    tertShift,\n                    new int[hashAreaSize], \n                    new String[sz << 1], \n                    hashAreaSize - sz, \n                    hashAreaSize \n            );\n        }\n    }\n}\n",
      "buggy_signatures": [
        "private ByteQuadsCanonicalizer(ByteQuadsCanonicalizer parent, boolean intern, int seed, boolean failOnDoS, TableInfo state)",
        "public static ByteQuadsCanonicalizer createRoot()",
        "protected static ByteQuadsCanonicalizer createRoot(int seed)",
        "public ByteQuadsCanonicalizer makeChild(int flags)",
        "public void release()",
        "private void mergeChild(TableInfo childState)",
        "public int size()",
        "public int bucketCount()",
        "public boolean maybeDirty()",
        "public int hashSeed()",
        "public int primaryCount()",
        "public int secondaryCount()",
        "public int tertiaryCount()",
        "public int spilloverCount()",
        "public int totalCount()",
        "public String toString()",
        "public String findName(int q1)",
        "public String findName(int q1, int q2)",
        "public String findName(int q1, int q2, int q3)",
        "public String findName(int[] q, int qlen)",
        "private final int _calcOffset(int hash)",
        "private String _findSecondary(int origOffset, int q1)",
        "private String _findSecondary(int origOffset, int q1, int q2)",
        "private String _findSecondary(int origOffset, int q1, int q2, int q3)",
        "private String _findSecondary(int origOffset, int hash, int[] q, int qlen)",
        "private boolean _verifyLongName(int[] q, int qlen, int spillOffset)",
        "private boolean _verifyLongName2(int[] q, int qlen, int spillOffset)",
        "public String addName(String name, int q1)",
        "public String addName(String name, int q1, int q2)",
        "public String addName(String name, int q1, int q2, int q3)",
        "public String addName(String name, int[] q, int qlen)",
        "private void _verifyNeedForRehash()",
        "private void _verifySharing()",
        "private int _findOffsetForAdd(int hash)",
        "private int _appendLongName(int[] quads, int qlen)",
        "public int calcHash(int q1, int q2)",
        "public int calcHash(int q1, int q2, int q3)",
        "public int calcHash(int[] q, int qlen)",
        "private void rehash()",
        "private void nukeSymbols(boolean fill)",
        "private final int _spilloverStart()",
        "protected void _reportTooManyCollisions()",
        "static int _calcTertiaryShift(int primarySlots)",
        "private final static class TableInfo { public final int size; public final int count; public final int tertiaryShift; public final int[] mainHash; public final String[] names; public final int spilloverEnd; public final int longNameOffset; public TableInfo(int size, int count, int tertiaryShift, int[] mainHash, String[] names, int spilloverEnd, int longNameOffset)",
        "public TableInfo(ByteQuadsCanonicalizer src)",
        "public static TableInfo createInitial(int sz)"
      ],
      "fixed_signatures": [
        "private ByteQuadsCanonicalizer(ByteQuadsCanonicalizer parent, boolean intern, int seed, boolean failOnDoS, TableInfo state)",
        "public static ByteQuadsCanonicalizer createRoot()",
        "protected static ByteQuadsCanonicalizer createRoot(int seed)",
        "public ByteQuadsCanonicalizer makeChild(int flags)",
        "public void release()",
        "private void mergeChild(TableInfo childState)",
        "public int size()",
        "public int bucketCount()",
        "public boolean maybeDirty()",
        "public int hashSeed()",
        "public int primaryCount()",
        "public int secondaryCount()",
        "public int tertiaryCount()",
        "public int spilloverCount()",
        "public int totalCount()",
        "public String toString()",
        "public String findName(int q1)",
        "public String findName(int q1, int q2)",
        "public String findName(int q1, int q2, int q3)",
        "public String findName(int[] q, int qlen)",
        "private final int _calcOffset(int hash)",
        "private String _findSecondary(int origOffset, int q1)",
        "private String _findSecondary(int origOffset, int q1, int q2)",
        "private String _findSecondary(int origOffset, int q1, int q2, int q3)",
        "private String _findSecondary(int origOffset, int hash, int[] q, int qlen)",
        "private boolean _verifyLongName(int[] q, int qlen, int spillOffset)",
        "private boolean _verifyLongName2(int[] q, int qlen, int spillOffset)",
        "public String addName(String name, int q1)",
        "public String addName(String name, int q1, int q2)",
        "public String addName(String name, int q1, int q2, int q3)",
        "public String addName(String name, int[] q, int qlen)",
        "private void _verifyNeedForRehash()",
        "private void _verifySharing()",
        "private int _findOffsetForAdd(int hash)",
        "private int _appendLongName(int[] quads, int qlen)",
        "public int calcHash(int q1, int q2)",
        "public int calcHash(int q1, int q2, int q3)",
        "public int calcHash(int[] q, int qlen)",
        "private void rehash()",
        "private void nukeSymbols(boolean fill)",
        "private final int _spilloverStart()",
        "protected void _reportTooManyCollisions()",
        "static int _calcTertiaryShift(int primarySlots)",
        "private final static class TableInfo { public final int size; public final int count; public final int tertiaryShift; public final int[] mainHash; public final String[] names; public final int spilloverEnd; public final int longNameOffset; public TableInfo(int size, int count, int tertiaryShift, int[] mainHash, String[] names, int spilloverEnd, int longNameOffset)",
        "public TableInfo(ByteQuadsCanonicalizer src)",
        "public static TableInfo createInitial(int sz)"
      ],
      "methods": [
        {
          "buggy_method": "  private void _verifySharing() {\n  if (_hashShared) {\n  _hashArea = Arrays.copyOf(_hashArea, _hashArea.length);\n  _names = Arrays.copyOf(_names, _names.length);\n  _hashShared = false;\n  \n  \n  }\n  if (_needRehash) {\n  rehash();\n  }\n  }",
          "fixed_method": "  private void _verifySharing() {\n  if (_hashShared) {\n  _hashArea = Arrays.copyOf(_hashArea, _hashArea.length);\n  _names = Arrays.copyOf(_names, _names.length);\n  _hashShared = false;\n  \n  \n  _verifyNeedForRehash();\n  }\n  if (_needRehash) {\n  rehash();\n  }\n  }",
          "diff": [
            "@@ -879,6 +879,7 @@",
            "             _hashShared = false;\n",
            "             // 09-Sep-2015, tatu: As per [jackson-core#216], also need to ensure\n",
            "             //    we rehash as needed, as need-rehash flag is not copied from parent\n",
            "+            _verifyNeedForRehash();\n",
            "         }\n",
            "         if (_needRehash) {\n",
            "             rehash();\n"
          ],
          "changed_lines": 1
        }
      ]
    }
  ]
}
