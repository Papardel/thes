{
  "bug_id": "20",
  "failed_tests": {
    "org.apache.commons.lang3.StringUtilsTest": [
      {
        "methodName": "testJoin_ArrayChar",
        "error": "java.lang.NullPointerException",
        "message": "",
        "fail_line": "        assertEquals(\"null\", StringUtils.join(NULL_TO_STRING_LIST,'/', 0, 1));",
        "test_source": "  public void testJoin_ArrayChar() {\n  assertEquals(null, StringUtils.join((Object[]) null, ','));\n  assertEquals(TEXT_LIST_CHAR, StringUtils.join(ARRAY_LIST, SEPARATOR_CHAR));\n  assertEquals(\"\", StringUtils.join(EMPTY_ARRAY_LIST, SEPARATOR_CHAR));\n  assertEquals(\";;foo\", StringUtils.join(MIXED_ARRAY_LIST, SEPARATOR_CHAR));\n  assertEquals(\"foo;2\", StringUtils.join(MIXED_TYPE_LIST, SEPARATOR_CHAR));\n\n  assertEquals(\"/\", StringUtils.join(MIXED_ARRAY_LIST, '/', 0, MIXED_ARRAY_LIST.length-1));\n  assertEquals(\"foo\", StringUtils.join(MIXED_TYPE_LIST, '/', 0, 1));\n  assertEquals(\"null\", StringUtils.join(NULL_TO_STRING_LIST,'/', 0, 1));\n  assertEquals(\"foo/2\", StringUtils.join(MIXED_TYPE_LIST, '/', 0, 2));\n  assertEquals(\"2\", StringUtils.join(MIXED_TYPE_LIST, '/', 1, 2));\n  assertEquals(\"\", StringUtils.join(MIXED_TYPE_LIST, '/', 2, 1));\n  }",
        "stack": [
          "StringUtils.join line 3298, StringUtilsTest.testJoin_ArrayChar line 209"
        ]
      },
      {
        "methodName": "testJoin_Objectarray",
        "error": "java.lang.NullPointerException",
        "message": "",
        "fail_line": "        assertEquals(\"null\", StringUtils.join(NULL_TO_STRING_LIST));",
        "test_source": "  public void testJoin_Objectarray() {\n//  assertEquals(null, StringUtils.join(null)); // generates warning\n  assertEquals(null, StringUtils.join((Object[]) null)); // equivalent explicit cast\n  // test additional varargs calls\n  assertEquals(\"\", StringUtils.join()); // empty array\n  assertEquals(\"\", StringUtils.join((Object) null)); // => new Object[]{null}\n\n  assertEquals(\"\", StringUtils.join(EMPTY_ARRAY_LIST));\n  assertEquals(\"\", StringUtils.join(NULL_ARRAY_LIST));\n  assertEquals(\"null\", StringUtils.join(NULL_TO_STRING_LIST));\n  assertEquals(\"abc\", StringUtils.join(new String[] {\"a\", \"b\", \"c\"}));\n  assertEquals(\"a\", StringUtils.join(new String[] {null, \"a\", \"\"}));\n  assertEquals(\"foo\", StringUtils.join(MIXED_ARRAY_LIST));\n  assertEquals(\"foo2\", StringUtils.join(MIXED_TYPE_LIST));\n  }",
        "stack": [
          "StringUtils.join line 3383, StringUtils.join line 3338, StringUtils.join line 3230, StringUtilsTest.testJoin_Objectarray line 193"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/lang3/StringUtils.java",
      "buggy_full_code": "\npackage org.apache.commons.lang3;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.regex.Pattern;\n\n\n\npublic class StringUtils { public static final String EMPTY = \"\"; public static final int INDEX_NOT_FOUND = -1; private static final int PAD_LIMIT = 8192; private static final Pattern WHITESPACE_BLOCK = Pattern.compile(\"\\\\s+\"); public StringUtils() {\n        super();\n    }\n\n    \n    \n    \n    public static boolean isEmpty(CharSequence cs) {\n        return cs == null || cs.length() == 0;\n    }\n\n    \n    public static boolean isNotEmpty(CharSequence cs) {\n        return !StringUtils.isEmpty(cs);\n    }\n\n    \n    public static boolean isBlank(CharSequence cs) {\n        int strLen;\n        if (cs == null || (strLen = cs.length()) == 0) {\n            return true;\n        }\n        for (int i = 0; i < strLen; i++) {\n            if ((Character.isWhitespace(cs.charAt(i)) == false)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public static boolean isNotBlank(CharSequence cs) {\n        return !StringUtils.isBlank(cs);\n    }\n\n    \n    \n    \n    public static String trim(String str) {\n        return str == null ? null : str.trim();\n    }\n\n    \n    public static String trimToNull(String str) {\n        String ts = trim(str);\n        return isEmpty(ts) ? null : ts;\n    }\n\n    \n    public static String trimToEmpty(String str) {\n        return str == null ? EMPTY : str.trim();\n    }\n\n    \n    \n    \n    public static String strip(String str) {\n        return strip(str, null);\n    }\n\n    \n    public static String stripToNull(String str) {\n        if (str == null) {\n            return null;\n        }\n        str = strip(str, null);\n        return str.length() == 0 ? null : str;\n    }\n\n    \n    public static String stripToEmpty(String str) {\n        return str == null ? EMPTY : strip(str, null);\n    }\n\n    \n    public static String strip(String str, String stripChars) {\n        if (isEmpty(str)) {\n            return str;\n        }\n        str = stripStart(str, stripChars);\n        return stripEnd(str, stripChars);\n    }\n\n    \n    public static String stripStart(String str, String stripChars) {\n        int strLen;\n        if (str == null || (strLen = str.length()) == 0) {\n            return str;\n        }\n        int start = 0;\n        if (stripChars == null) {\n            while ((start != strLen) && Character.isWhitespace(str.charAt(start))) {\n                start++;\n            }\n        } else if (stripChars.length() == 0) {\n            return str;\n        } else {\n            while ((start != strLen) && (stripChars.indexOf(str.charAt(start)) != INDEX_NOT_FOUND)) {\n                start++;\n            }\n        }\n        return str.substring(start);\n    }\n\n    \n    public static String stripEnd(String str, String stripChars) {\n        int end;\n        if (str == null || (end = str.length()) == 0) {\n            return str;\n        }\n\n        if (stripChars == null) {\n            while ((end != 0) && Character.isWhitespace(str.charAt(end - 1))) {\n                end--;\n            }\n        } else if (stripChars.length() == 0) {\n            return str;\n        } else {\n            while ((end != 0) && (stripChars.indexOf(str.charAt(end - 1)) != INDEX_NOT_FOUND)) {\n                end--;\n            }\n        }\n        return str.substring(0, end);\n    }\n\n    \n    \n    \n    public static String[] stripAll(String... strs) {\n        return stripAll(strs, null);\n    }\n\n    \n    public static String[] stripAll(String[] strs, String stripChars) {\n        int strsLen;\n        if (strs == null || (strsLen = strs.length) == 0) {\n            return strs;\n        }\n        String[] newArr = new String[strsLen];\n        for (int i = 0; i < strsLen; i++) {\n            newArr[i] = strip(strs[i], stripChars);\n        }\n        return newArr;\n    }\n\n    \n    \n    public static String stripAccents(String input) {\n        if(input == null) {\n            return null;\n        }\n        try {\n            String result = null;\n            if (java6Available) {\n                result = removeAccentsJava6(input);\n            } else if (sunAvailable) {\n                result = removeAccentsSUN(input);\n            } else {\n                throw new UnsupportedOperationException(\n                    \"The stripAccents(CharSequence) method requires at least Java 1.6 or a Sun JVM\");\n            }\n            \n            return result;\n        } catch(IllegalArgumentException iae) {\n            throw new RuntimeException(\"IllegalArgumentException occurred\", iae);\n        } catch(IllegalAccessException iae) {\n            throw new RuntimeException(\"IllegalAccessException occurred\", iae);\n        } catch(InvocationTargetException ite) {\n            throw new RuntimeException(\"InvocationTargetException occurred\", ite);\n        } catch(SecurityException se) {\n            throw new RuntimeException(\"SecurityException occurred\", se);\n        }\n    }\n\n    \n    private static String removeAccentsJava6(CharSequence text) throws IllegalAccessException, InvocationTargetException {\n        \n        if (!java6Available || java6NormalizerFormNFD == null) {\n            throw new IllegalStateException(\"java.text.Normalizer is not available\");\n        }\n        String result;\n        result = (String) java6NormalizeMethod.invoke(null, new Object[] {text, java6NormalizerFormNFD});\n        result = java6Pattern.matcher(result).replaceAll(\"\");\n        return result;\n    }\n\n    \n    private static String removeAccentsSUN(CharSequence text) throws IllegalAccessException, InvocationTargetException {\n        \n        if (! sunAvailable) {\n            throw new IllegalStateException(\"sun.text.Normalizer is not available\");\n        }\n        String result;\n        result = (String) sunDecomposeMethod.invoke(null, new Object[] {text, Boolean.FALSE, Integer.valueOf(0)});\n        result = sunPattern.matcher(result).replaceAll(\"\");\n        return result;\n    }\n\n    \n    private static boolean sunAvailable = false; private static Method sunDecomposeMethod = null; private static final Pattern sunPattern = Pattern.compile(\"\\\\p{InCombiningDiacriticalMarks}+\"); private static boolean java6Available = false; private static Method java6NormalizeMethod = null; private static Object java6NormalizerFormNFD = null; private static final Pattern java6Pattern = sunPattern; static {\n        try {\n            \n            \n            Class<?> normalizerFormClass = Thread.currentThread().getContextClassLoader()\n                .loadClass(\"java.text.Normalizer$Form\");\n            java6NormalizerFormNFD = normalizerFormClass.getField(\"NFD\").get(null);\n            Class<?> normalizerClass = Thread.currentThread().getContextClassLoader()\n                .loadClass(\"java.text.Normalizer\");\n            java6NormalizeMethod = normalizerClass.getMethod(\"normalize\",\n                    new Class[] {CharSequence.class, normalizerFormClass});\n            java6Available = true;\n        } catch (ClassNotFoundException e) {\n            java6Available = false;\n        } catch (NoSuchFieldException e) {\n            java6Available = false;\n        } catch (IllegalAccessException e) {\n            java6Available = false;\n        } catch (NoSuchMethodException e) {\n            java6Available = false;\n        }\n\n        try {\n            \n            Class<?> normalizerClass = Thread.currentThread().getContextClassLoader()\n                .loadClass(\"sun.text.Normalizer\");\n            sunDecomposeMethod = normalizerClass.getMethod(\"decompose\",\n                    new Class[] {String.class, Boolean.TYPE, Integer.TYPE});\n            sunAvailable = true;\n        } catch (ClassNotFoundException e) {\n            sunAvailable = false;\n        } catch (NoSuchMethodException e) {\n            sunAvailable = false;\n        }\n    }\n\n    \n    \n    \n    public static boolean equals(CharSequence cs1, CharSequence cs2) {\n        return cs1 == null ? cs2 == null : cs1.equals(cs2);\n    }\n\n    \n    public static boolean equalsIgnoreCase(CharSequence str1, CharSequence str2) {\n        if (str1 == null || str2 == null) {\n            return str1 == str2;\n        } else {\n            return CharSequenceUtils.regionMatches(str1, true, 0, str2, 0, Math.max(str1.length(), str2.length()));\n        }\n    }\n\n    \n    \n    \n    public static int indexOf(CharSequence seq, int searchChar) {\n        if (isEmpty(seq)) {\n            return INDEX_NOT_FOUND;\n        }\n        return CharSequenceUtils.indexOf(seq, searchChar, 0);\n    }\n\n    \n    public static int indexOf(CharSequence seq, int searchChar, int startPos) {\n        if (isEmpty(seq)) {\n            return INDEX_NOT_FOUND;\n        }\n        return CharSequenceUtils.indexOf(seq, searchChar, startPos);\n    }\n\n    \n    public static int indexOf(CharSequence seq, CharSequence searchSeq) {\n        if (seq == null || searchSeq == null) {\n            return INDEX_NOT_FOUND;\n        }\n        return CharSequenceUtils.indexOf(seq, searchSeq, 0);\n    }\n\n    \n    public static int indexOf(CharSequence seq, CharSequence searchSeq, int startPos) {\n        if (seq == null || searchSeq == null) {\n            return INDEX_NOT_FOUND;\n        }\n        return CharSequenceUtils.indexOf(seq, searchSeq, startPos);\n    }\n\n    \n    public static int ordinalIndexOf(CharSequence str, CharSequence searchStr, int ordinal) {\n        return ordinalIndexOf(str, searchStr, ordinal, false);\n    }\n\n    \n    \n    private static int ordinalIndexOf(CharSequence str, CharSequence searchStr, int ordinal, boolean lastIndex) {\n        if (str == null || searchStr == null || ordinal <= 0) {\n            return INDEX_NOT_FOUND;\n        }\n        if (searchStr.length() == 0) {\n            return lastIndex ? str.length() : 0;\n        }\n        int found = 0;\n        int index = lastIndex ? str.length() : INDEX_NOT_FOUND;\n        do {\n            if (lastIndex) {\n                index = CharSequenceUtils.lastIndexOf(str, searchStr, index - 1);\n            } else {\n                index = CharSequenceUtils.indexOf(str, searchStr, index + 1);\n            }\n            if (index < 0) {\n                return index;\n            }\n            found++;\n        } while (found < ordinal);\n        return index;\n    }\n\n    \n    public static int indexOfIgnoreCase(CharSequence str, CharSequence searchStr) {\n        return indexOfIgnoreCase(str, searchStr, 0);\n    }\n\n    \n    public static int indexOfIgnoreCase(CharSequence str, CharSequence searchStr, int startPos) {\n        if (str == null || searchStr == null) {\n            return INDEX_NOT_FOUND;\n        }\n        if (startPos < 0) {\n            startPos = 0;\n        }\n        int endLimit = (str.length() - searchStr.length()) + 1;\n        if (startPos > endLimit) {\n            return INDEX_NOT_FOUND;\n        }\n        if (searchStr.length() == 0) {\n            return startPos;\n        }\n        for (int i = startPos; i < endLimit; i++) {\n            if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, searchStr.length())) {\n                return i;\n            }\n        }\n        return INDEX_NOT_FOUND;\n    }\n\n    \n    \n    \n    public static int lastIndexOf(CharSequence seq, int searchChar) {\n        if (isEmpty(seq)) {\n            return INDEX_NOT_FOUND;\n        }\n        return CharSequenceUtils.lastIndexOf(seq, searchChar, seq.length());\n    }\n\n    \n    public static int lastIndexOf(CharSequence seq, int searchChar, int startPos) {\n        if (isEmpty(seq)) {\n            return INDEX_NOT_FOUND;\n        }\n        return CharSequenceUtils.lastIndexOf(seq, searchChar, startPos);\n    }\n\n    \n    public static int lastIndexOf(CharSequence seq, CharSequence searchSeq) {\n        if (seq == null || searchSeq == null) {\n            return INDEX_NOT_FOUND;\n        }\n        return CharSequenceUtils.lastIndexOf(seq, searchSeq, seq.length());\n    }\n\n    \n    public static int lastOrdinalIndexOf(CharSequence str, CharSequence searchStr, int ordinal) {\n        return ordinalIndexOf(str, searchStr, ordinal, true);\n    }\n\n    \n    public static int lastIndexOf(CharSequence seq, CharSequence searchSeq, int startPos) {\n        if (seq == null || searchSeq == null) {\n            return INDEX_NOT_FOUND;\n        }\n        return CharSequenceUtils.lastIndexOf(seq, searchSeq, startPos);\n    }\n\n    \n    public static int lastIndexOfIgnoreCase(CharSequence str, CharSequence searchStr) {\n        if (str == null || searchStr == null) {\n            return INDEX_NOT_FOUND;\n        }\n        return lastIndexOfIgnoreCase(str, searchStr, str.length());\n    }\n\n    \n    public static int lastIndexOfIgnoreCase(CharSequence str, CharSequence searchStr, int startPos) {\n        if (str == null || searchStr == null) {\n            return INDEX_NOT_FOUND;\n        }\n        if (startPos > (str.length() - searchStr.length())) {\n            startPos = str.length() - searchStr.length();\n        }\n        if (startPos < 0) {\n            return INDEX_NOT_FOUND;\n        }\n        if (searchStr.length() == 0) {\n            return startPos;\n        }\n\n        for (int i = startPos; i >= 0; i--) {\n            if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, searchStr.length())) {\n                return i;\n            }\n        }\n        return INDEX_NOT_FOUND;\n    }\n\n    \n    \n    \n    public static boolean contains(CharSequence seq, int searchChar) {\n        if (isEmpty(seq)) {\n            return false;\n        }\n        return CharSequenceUtils.indexOf(seq, searchChar, 0) >= 0;\n    }\n\n    \n    public static boolean contains(CharSequence seq, CharSequence searchSeq) {\n        if (seq == null || searchSeq == null) {\n            return false;\n        }\n        return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;\n    }\n\n    \n    public static boolean containsIgnoreCase(CharSequence str, CharSequence searchStr) {\n        if (str == null || searchStr == null) {\n            return false;\n        }\n        int len = searchStr.length();\n        int max = str.length() - len;\n        for (int i = 0; i <= max; i++) {\n            if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, len)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    \n    \n    public static boolean containsWhitespace(CharSequence seq) {\n        if (isEmpty(seq)) {\n            return false;\n        }\n        int strLen = seq.length();\n        for (int i = 0; i < strLen; i++) {\n            if (Character.isWhitespace(seq.charAt(i))) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    \n    \n    \n    public static int indexOfAny(CharSequence cs, char... searchChars) {\n        if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n            return INDEX_NOT_FOUND;\n        }\n        int csLen = cs.length();\n        int csLast = csLen - 1;\n        int searchLen = searchChars.length;\n        int searchLast = searchLen - 1;\n        for (int i = 0; i < csLen; i++) {\n            char ch = cs.charAt(i);\n            for (int j = 0; j < searchLen; j++) {\n                if (searchChars[j] == ch) {\n                    if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) {\n                        \n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return i;\n                        }\n                    } else {\n                        return i;\n                    }\n                }\n            }\n        }\n        return INDEX_NOT_FOUND;\n    }\n\n    \n    public static int indexOfAny(CharSequence cs, String searchChars) {\n        if (isEmpty(cs) || isEmpty(searchChars)) {\n            return INDEX_NOT_FOUND;\n        }\n        return indexOfAny(cs, searchChars.toCharArray());\n    }\n\n    \n    \n    \n    public static boolean containsAny(CharSequence cs, char... searchChars) {\n        if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n            return false;\n        }\n        int csLength = cs.length();\n        int searchLength = searchChars.length;\n        int csLast = csLength - 1;\n        int searchLast = searchLength - 1;\n        for (int i = 0; i < csLength; i++) {\n            char ch = cs.charAt(i);\n            for (int j = 0; j < searchLength; j++) {\n                if (searchChars[j] == ch) {\n                    if (Character.isHighSurrogate(ch)) {\n                        if (j == searchLast) {\n                            \n                            return true;\n                        }\n                        if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\n    \n    public static boolean containsAny(CharSequence cs, CharSequence searchChars) {\n        if (searchChars == null) {\n            return false;\n        }\n        return containsAny(cs, CharSequenceUtils.toCharArray(searchChars));\n    }\n\n    \n    \n    \n    public static int indexOfAnyBut(CharSequence cs, char... searchChars) {\n        if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n            return INDEX_NOT_FOUND;\n        }\n        int csLen = cs.length();\n        int csLast = csLen - 1;\n        int searchLen = searchChars.length;\n        int searchLast = searchLen - 1;\n        outer:\n        for (int i = 0; i < csLen; i++) {\n            char ch = cs.charAt(i);\n            for (int j = 0; j < searchLen; j++) {\n                if (searchChars[j] == ch) {\n                    if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) {\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            continue outer;\n                        }\n                    } else {\n                        continue outer;\n                    }\n                }\n            }\n            return i;\n        }\n        return INDEX_NOT_FOUND;\n    }\n\n    \n    public static int indexOfAnyBut(CharSequence seq, CharSequence searchChars) {\n        if (isEmpty(seq) || isEmpty(searchChars)) {\n            return INDEX_NOT_FOUND;\n        }\n        int strLen = seq.length();\n        for (int i = 0; i < strLen; i++) {\n            char ch = seq.charAt(i);\n            boolean chFound = CharSequenceUtils.indexOf(searchChars, ch, 0) >= 0;\n            if (i + 1 < strLen && Character.isHighSurrogate(ch)) {\n                char ch2 = seq.charAt(i + 1);\n                if (chFound && CharSequenceUtils.indexOf(searchChars, ch2, 0) < 0) {\n                    return i;\n                }\n            } else {\n                if (!chFound) {\n                    return i;\n                }\n            }\n        }\n        return INDEX_NOT_FOUND;\n    }\n\n    \n    \n    \n    public static boolean containsOnly(CharSequence cs, char... valid) {\n        \n        if (valid == null || cs == null) {\n            return false;\n        }\n        if (cs.length() == 0) {\n            return true;\n        }\n        if (valid.length == 0) {\n            return false;\n        }\n        return indexOfAnyBut(cs, valid) == INDEX_NOT_FOUND;\n    }\n\n    \n    public static boolean containsOnly(CharSequence cs, String validChars) {\n        if (cs == null || validChars == null) {\n            return false;\n        }\n        return containsOnly(cs, validChars.toCharArray());\n    }\n\n    \n    \n    \n    public static boolean containsNone(CharSequence cs, char... searchChars) {\n        if (cs == null || searchChars == null) {\n            return true;\n        }\n        int csLen = cs.length();\n        int csLast = csLen - 1;\n        int searchLen = searchChars.length;\n        int searchLast = searchLen - 1;\n        for (int i = 0; i < csLen; i++) {\n            char ch = cs.charAt(i);\n            for (int j = 0; j < searchLen; j++) {\n                if (searchChars[j] == ch) {\n                    if (Character.isHighSurrogate(ch)) {\n                        if (j == searchLast) {\n                            \n                            return false;\n                        }\n                        if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return false;\n                        }\n                    } else {\n                        \n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n\n    \n    public static boolean containsNone(CharSequence cs, String invalidChars) {\n        if (cs == null || invalidChars == null) {\n            return true;\n        }\n        return containsNone(cs, invalidChars.toCharArray());\n    }\n\n    \n    \n    \n    public static int indexOfAny(CharSequence str, CharSequence... searchStrs) {\n        if (str == null || searchStrs == null) {\n            return INDEX_NOT_FOUND;\n        }\n        int sz = searchStrs.length;\n\n        \n        int ret = Integer.MAX_VALUE;\n\n        int tmp = 0;\n        for (int i = 0; i < sz; i++) {\n            CharSequence search = searchStrs[i];\n            if (search == null) {\n                continue;\n            }\n            tmp = CharSequenceUtils.indexOf(str, search, 0);\n            if (tmp == INDEX_NOT_FOUND) {\n                continue;\n            }\n\n            if (tmp < ret) {\n                ret = tmp;\n            }\n        }\n\n        return (ret == Integer.MAX_VALUE) ? INDEX_NOT_FOUND : ret;\n    }\n\n    \n    public static int lastIndexOfAny(CharSequence str, CharSequence... searchStrs) {\n        if (str == null || searchStrs == null) {\n            return INDEX_NOT_FOUND;\n        }\n        int sz = searchStrs.length;\n        int ret = INDEX_NOT_FOUND;\n        int tmp = 0;\n        for (int i = 0; i < sz; i++) {\n            CharSequence search = searchStrs[i];\n            if (search == null) {\n                continue;\n            }\n            tmp = CharSequenceUtils.lastIndexOf(str, search, str.length());\n            if (tmp > ret) {\n                ret = tmp;\n            }\n        }\n        return ret;\n    }\n\n    \n    \n    \n    public static String substring(String str, int start) {\n        if (str == null) {\n            return null;\n        }\n\n        \n        if (start < 0) {\n            start = str.length() + start; \n        }\n\n        if (start < 0) {\n            start = 0;\n        }\n        if (start > str.length()) {\n            return EMPTY;\n        }\n\n        return str.substring(start);\n    }\n\n    \n    public static String substring(String str, int start, int end) {\n        if (str == null) {\n            return null;\n        }\n\n        \n        if (end < 0) {\n            end = str.length() + end; \n        }\n        if (start < 0) {\n            start = str.length() + start; \n        }\n\n        \n        if (end > str.length()) {\n            end = str.length();\n        }\n\n        \n        if (start > end) {\n            return EMPTY;\n        }\n\n        if (start < 0) {\n            start = 0;\n        }\n        if (end < 0) {\n            end = 0;\n        }\n\n        return str.substring(start, end);\n    }\n\n    \n    \n    \n    public static String left(String str, int len) {\n        if (str == null) {\n            return null;\n        }\n        if (len < 0) {\n            return EMPTY;\n        }\n        if (str.length() <= len) {\n            return str;\n        }\n        return str.substring(0, len);\n    }\n\n    \n    public static String right(String str, int len) {\n        if (str == null) {\n            return null;\n        }\n        if (len < 0) {\n            return EMPTY;\n        }\n        if (str.length() <= len) {\n            return str;\n        }\n        return str.substring(str.length() - len);\n    }\n\n    \n    public static String mid(String str, int pos, int len) {\n        if (str == null) {\n            return null;\n        }\n        if (len < 0 || pos > str.length()) {\n            return EMPTY;\n        }\n        if (pos < 0) {\n            pos = 0;\n        }\n        if (str.length() <= (pos + len)) {\n            return str.substring(pos);\n        }\n        return str.substring(pos, pos + len);\n    }\n\n    \n    \n    \n    public static String substringBefore(String str, String separator) {\n        if (isEmpty(str) || separator == null) {\n            return str;\n        }\n        if (separator.length() == 0) {\n            return EMPTY;\n        }\n        int pos = str.indexOf(separator);\n        if (pos == INDEX_NOT_FOUND) {\n            return str;\n        }\n        return str.substring(0, pos);\n    }\n\n    \n    public static String substringAfter(String str, String separator) {\n        if (isEmpty(str)) {\n            return str;\n        }\n        if (separator == null) {\n            return EMPTY;\n        }\n        int pos = str.indexOf(separator);\n        if (pos == INDEX_NOT_FOUND) {\n            return EMPTY;\n        }\n        return str.substring(pos + separator.length());\n    }\n\n    \n    public static String substringBeforeLast(String str, String separator) {\n        if (isEmpty(str) || isEmpty(separator)) {\n            return str;\n        }\n        int pos = str.lastIndexOf(separator);\n        if (pos == INDEX_NOT_FOUND) {\n            return str;\n        }\n        return str.substring(0, pos);\n    }\n\n    \n    public static String substringAfterLast(String str, String separator) {\n        if (isEmpty(str)) {\n            return str;\n        }\n        if (isEmpty(separator)) {\n            return EMPTY;\n        }\n        int pos = str.lastIndexOf(separator);\n        if (pos == INDEX_NOT_FOUND || pos == (str.length() - separator.length())) {\n            return EMPTY;\n        }\n        return str.substring(pos + separator.length());\n    }\n\n    \n    \n    \n    public static String substringBetween(String str, String tag) {\n        return substringBetween(str, tag, tag);\n    }\n\n    \n    public static String substringBetween(String str, String open, String close) {\n        if (str == null || open == null || close == null) {\n            return null;\n        }\n        int start = str.indexOf(open);\n        if (start != INDEX_NOT_FOUND) {\n            int end = str.indexOf(close, start + open.length());\n            if (end != INDEX_NOT_FOUND) {\n                return str.substring(start + open.length(), end);\n            }\n        }\n        return null;\n    }\n\n    \n    public static String[] substringsBetween(String str, String open, String close) {\n        if (str == null || isEmpty(open) || isEmpty(close)) {\n            return null;\n        }\n        int strLen = str.length();\n        if (strLen == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n        int closeLen = close.length();\n        int openLen = open.length();\n        List<String> list = new ArrayList<String>();\n        int pos = 0;\n        while (pos < (strLen - closeLen)) {\n            int start = str.indexOf(open, pos);\n            if (start < 0) {\n                break;\n            }\n            start += openLen;\n            int end = str.indexOf(close, start);\n            if (end < 0) {\n                break;\n            }\n            list.add(str.substring(start, end));\n            pos = end + closeLen;\n        }\n        if (list.isEmpty()) {\n            return null;\n        }\n        return list.toArray(new String [list.size()]);\n    }\n\n    \n    \n\n    \n    \n    \n    public static String[] split(String str) {\n        return split(str, null, -1);\n    }\n\n    \n    public static String[] split(String str, char separatorChar) {\n        return splitWorker(str, separatorChar, false);\n    }\n\n    \n    public static String[] split(String str, String separatorChars) {\n        return splitWorker(str, separatorChars, -1, false);\n    }\n\n    \n    public static String[] split(String str, String separatorChars, int max) {\n        return splitWorker(str, separatorChars, max, false);\n    }\n\n    \n    public static String[] splitByWholeSeparator(String str, String separator) {\n        return splitByWholeSeparatorWorker( str, separator, -1, false ) ;\n    }\n\n    \n    public static String[] splitByWholeSeparator( String str, String separator, int max ) {\n        return splitByWholeSeparatorWorker(str, separator, max, false);\n    }\n\n    \n    public static String[] splitByWholeSeparatorPreserveAllTokens(String str, String separator) {\n        return splitByWholeSeparatorWorker(str, separator, -1, true);\n    }\n\n    \n    public static String[] splitByWholeSeparatorPreserveAllTokens(String str, String separator, int max) {\n        return splitByWholeSeparatorWorker(str, separator, max, true);\n    }\n\n    \n    private static String[] splitByWholeSeparatorWorker( String str, String separator, int max, boolean preserveAllTokens) {\n        if (str == null) {\n            return null;\n        }\n\n        int len = str.length();\n\n        if (len == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n\n        if ((separator == null) || (EMPTY.equals(separator))) {\n            \n            return splitWorker(str, null, max, preserveAllTokens);\n        }\n\n        int separatorLength = separator.length();\n\n        ArrayList<String> substrings = new ArrayList<String>();\n        int numberOfSubstrings = 0;\n        int beg = 0;\n        int end = 0;\n        while (end < len) {\n            end = str.indexOf(separator, beg);\n\n            if (end > -1) {\n                if (end > beg) {\n                    numberOfSubstrings += 1;\n\n                    if (numberOfSubstrings == max) {\n                        end = len;\n                        substrings.add(str.substring(beg));\n                    } else {\n                        \n                        \n                        substrings.add(str.substring(beg, end));\n\n                        \n                        \n                        \n                        beg = end + separatorLength;\n                    }\n                } else {\n                    \n                    if (preserveAllTokens) {\n                        numberOfSubstrings += 1;\n                        if (numberOfSubstrings == max) {\n                            end = len;\n                            substrings.add(str.substring(beg));\n                        } else {\n                            substrings.add(EMPTY);\n                        }\n                    }\n                    beg = end + separatorLength;\n                }\n            } else {\n                \n                substrings.add(str.substring(beg));\n                end = len;\n            }\n        }\n\n        return substrings.toArray(new String[substrings.size()]);\n    }\n\n    \n    \n    public static String[] splitPreserveAllTokens(String str) {\n        return splitWorker(str, null, -1, true);\n    }\n\n    \n    public static String[] splitPreserveAllTokens(String str, char separatorChar) {\n        return splitWorker(str, separatorChar, true);\n    }\n\n    \n    private static String[] splitWorker(String str, char separatorChar, boolean preserveAllTokens) {\n        \n\n        if (str == null) {\n            return null;\n        }\n        int len = str.length();\n        if (len == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n        List<String> list = new ArrayList<String>();\n        int i = 0, start = 0;\n        boolean match = false;\n        boolean lastMatch = false;\n        while (i < len) {\n            if (str.charAt(i) == separatorChar) {\n                if (match || preserveAllTokens) {\n                    list.add(str.substring(start, i));\n                    match = false;\n                    lastMatch = true;\n                }\n                start = ++i;\n                continue;\n            }\n            lastMatch = false;\n            match = true;\n            i++;\n        }\n        if (match || (preserveAllTokens && lastMatch)) {\n            list.add(str.substring(start, i));\n        }\n        return list.toArray(new String[list.size()]);\n    }\n\n    \n    public static String[] splitPreserveAllTokens(String str, String separatorChars) {\n        return splitWorker(str, separatorChars, -1, true);\n    }\n\n    \n    public static String[] splitPreserveAllTokens(String str, String separatorChars, int max) {\n        return splitWorker(str, separatorChars, max, true);\n    }\n\n    \n    private static String[] splitWorker(String str, String separatorChars, int max, boolean preserveAllTokens) {\n        \n        \n        \n\n        if (str == null) {\n            return null;\n        }\n        int len = str.length();\n        if (len == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n        List<String> list = new ArrayList<String>();\n        int sizePlus1 = 1;\n        int i = 0, start = 0;\n        boolean match = false;\n        boolean lastMatch = false;\n        if (separatorChars == null) {\n            \n            while (i < len) {\n                if (Character.isWhitespace(str.charAt(i))) {\n                    if (match || preserveAllTokens) {\n                        lastMatch = true;\n                        if (sizePlus1++ == max) {\n                            i = len;\n                            lastMatch = false;\n                        }\n                        list.add(str.substring(start, i));\n                        match = false;\n                    }\n                    start = ++i;\n                    continue;\n                }\n                lastMatch = false;\n                match = true;\n                i++;\n            }\n        } else if (separatorChars.length() == 1) {\n            \n            char sep = separatorChars.charAt(0);\n            while (i < len) {\n                if (str.charAt(i) == sep) {\n                    if (match || preserveAllTokens) {\n                        lastMatch = true;\n                        if (sizePlus1++ == max) {\n                            i = len;\n                            lastMatch = false;\n                        }\n                        list.add(str.substring(start, i));\n                        match = false;\n                    }\n                    start = ++i;\n                    continue;\n                }\n                lastMatch = false;\n                match = true;\n                i++;\n            }\n        } else {\n            \n            while (i < len) {\n                if (separatorChars.indexOf(str.charAt(i)) >= 0) {\n                    if (match || preserveAllTokens) {\n                        lastMatch = true;\n                        if (sizePlus1++ == max) {\n                            i = len;\n                            lastMatch = false;\n                        }\n                        list.add(str.substring(start, i));\n                        match = false;\n                    }\n                    start = ++i;\n                    continue;\n                }\n                lastMatch = false;\n                match = true;\n                i++;\n            }\n        }\n        if (match || (preserveAllTokens && lastMatch)) {\n            list.add(str.substring(start, i));\n        }\n        return list.toArray(new String[list.size()]);\n    }\n\n    \n    public static String[] splitByCharacterType(String str) {\n        return splitByCharacterType(str, false);\n    }\n\n    \n    public static String[] splitByCharacterTypeCamelCase(String str) {\n        return splitByCharacterType(str, true);\n    }\n\n    \n    private static String[] splitByCharacterType(String str, boolean camelCase) {\n        if (str == null) {\n            return null;\n        }\n        if (str.length() == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n        char[] c = str.toCharArray();\n        List<String> list = new ArrayList<String>();\n        int tokenStart = 0;\n        int currentType = Character.getType(c[tokenStart]);\n        for (int pos = tokenStart + 1; pos < c.length; pos++) {\n            int type = Character.getType(c[pos]);\n            if (type == currentType) {\n                continue;\n            }\n            if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n                int newTokenStart = pos - 1;\n                if (newTokenStart != tokenStart) {\n                    list.add(new String(c, tokenStart, newTokenStart - tokenStart));\n                    tokenStart = newTokenStart;\n                }\n            } else {\n                list.add(new String(c, tokenStart, pos - tokenStart));\n                tokenStart = pos;\n            }\n            currentType = type;\n        }\n        list.add(new String(c, tokenStart, c.length - tokenStart));\n        return list.toArray(new String[list.size()]);\n    }\n\n    \n    \n    \n    public static <T> String join(T... elements) {\n        return join(elements, null);\n    }\n\n    \n    public static String join(Object[] array, char separator) {\n        if (array == null) {\n            return null;\n        }\n\n        return join(array, separator, 0, array.length);\n    }\n\n    \n    public static String join(Object[] array, char separator, int startIndex, int endIndex) {\n        if (array == null) {\n            return null;\n        }\n        int noOfItems = (endIndex - startIndex);\n        if (noOfItems <= 0) {\n            return EMPTY;\n        }\n        \n        StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1);\n\n        for (int i = startIndex; i < endIndex; i++) {\n            if (i > startIndex) {\n                buf.append(separator);\n            }\n            if (array[i] != null) {\n                buf.append(array[i]);\n            }\n        }\n        return buf.toString();\n    }\n\n    \n    public static String join(Object[] array, String separator) {\n        if (array == null) {\n            return null;\n        }\n        return join(array, separator, 0, array.length);\n    }\n\n    \n    public static String join(Object[] array, String separator, int startIndex, int endIndex) {\n        if (array == null) {\n            return null;\n        }\n        if (separator == null) {\n            separator = EMPTY;\n        }\n\n        \n        \n        int noOfItems = (endIndex - startIndex);\n        if (noOfItems <= 0) {\n            return EMPTY;\n        }\n\n        StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + separator.length());\n\n        for (int i = startIndex; i < endIndex; i++) {\n            if (i > startIndex) {\n                buf.append(separator);\n            }\n            if (array[i] != null) {\n                buf.append(array[i]);\n            }\n        }\n        return buf.toString();\n    }\n\n    \n    public static String join(Iterator<?> iterator, char separator) {\n\n        \n        if (iterator == null) {\n            return null;\n        }\n        if (!iterator.hasNext()) {\n            return EMPTY;\n        }\n        Object first = iterator.next();\n        if (!iterator.hasNext()) {\n            return ObjectUtils.toString(first);\n        }\n\n        \n        StringBuilder buf = new StringBuilder(256); \n        if (first != null) {\n            buf.append(first);\n        }\n\n        while (iterator.hasNext()) {\n            buf.append(separator);\n            Object obj = iterator.next();\n            if (obj != null) {\n                buf.append(obj);\n            }\n        }\n\n        return buf.toString();\n    }\n\n    \n    public static String join(Iterator<?> iterator, String separator) {\n\n        \n        if (iterator == null) {\n            return null;\n        }\n        if (!iterator.hasNext()) {\n            return EMPTY;\n        }\n        Object first = iterator.next();\n        if (!iterator.hasNext()) {\n            return ObjectUtils.toString(first);\n        }\n\n        \n        StringBuilder buf = new StringBuilder(256); \n        if (first != null) {\n            buf.append(first);\n        }\n\n        while (iterator.hasNext()) {\n            if (separator != null) {\n                buf.append(separator);\n            }\n            Object obj = iterator.next();\n            if (obj != null) {\n                buf.append(obj);\n            }\n        }\n        return buf.toString();\n    }\n\n    \n    public static String join(Iterable<?> iterable, char separator) {\n        if (iterable == null) {\n            return null;\n        }\n        return join(iterable.iterator(), separator);\n    }\n\n    \n    public static String join(Iterable<?> iterable, String separator) {\n        if (iterable == null) {\n            return null;\n        }\n        return join(iterable.iterator(), separator);\n    }\n\n    \n    \n    \n    public static String deleteWhitespace(String str) {\n        if (isEmpty(str)) {\n            return str;\n        }\n        int sz = str.length();\n        char[] chs = new char[sz];\n        int count = 0;\n        for (int i = 0; i < sz; i++) {\n            if (!Character.isWhitespace(str.charAt(i))) {\n                chs[count++] = str.charAt(i);\n            }\n        }\n        if (count == sz) {\n            return str;\n        }\n        return new String(chs, 0, count);\n    }\n\n    \n    \n    \n    public static String removeStart(String str, String remove) {\n        if (isEmpty(str) || isEmpty(remove)) {\n            return str;\n        }\n        if (str.startsWith(remove)){\n            return str.substring(remove.length());\n        }\n        return str;\n    }\n\n    \n    public static String removeStartIgnoreCase(String str, String remove) {\n        if (isEmpty(str) || isEmpty(remove)) {\n            return str;\n        }\n        if (startsWithIgnoreCase(str, remove)) {\n            return str.substring(remove.length());\n        }\n        return str;\n    }\n\n    \n    public static String removeEnd(String str, String remove) {\n        if (isEmpty(str) || isEmpty(remove)) {\n            return str;\n        }\n        if (str.endsWith(remove)) {\n            return str.substring(0, str.length() - remove.length());\n        }\n        return str;\n    }\n\n    \n    public static String removeEndIgnoreCase(String str, String remove) {\n        if (isEmpty(str) || isEmpty(remove)) {\n            return str;\n        }\n        if (endsWithIgnoreCase(str, remove)) {\n            return str.substring(0, str.length() - remove.length());\n        }\n        return str;\n    }\n\n    \n    public static String remove(String str, String remove) {\n        if (isEmpty(str) || isEmpty(remove)) {\n            return str;\n        }\n        return replace(str, remove, EMPTY, -1);\n    }\n\n    \n    public static String remove(String str, char remove) {\n        if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {\n            return str;\n        }\n        char[] chars = str.toCharArray();\n        int pos = 0;\n        for (int i = 0; i < chars.length; i++) {\n            if (chars[i] != remove) {\n                chars[pos++] = chars[i];\n            }\n        }\n        return new String(chars, 0, pos);\n    }\n\n    \n    \n    \n    public static String replaceOnce(String text, String searchString, String replacement) {\n        return replace(text, searchString, replacement, 1);\n    }\n\n    \n    public static String replace(String text, String searchString, String replacement) {\n        return replace(text, searchString, replacement, -1);\n    }\n\n    \n    public static String replace(String text, String searchString, String replacement, int max) {\n        if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {\n            return text;\n        }\n        int start = 0;\n        int end = text.indexOf(searchString, start);\n        if (end == INDEX_NOT_FOUND) {\n            return text;\n        }\n        int replLength = searchString.length();\n        int increase = replacement.length() - replLength;\n        increase = (increase < 0 ? 0 : increase);\n        increase *= (max < 0 ? 16 : (max > 64 ? 64 : max));\n        StringBuilder buf = new StringBuilder(text.length() + increase);\n        while (end != INDEX_NOT_FOUND) {\n            buf.append(text.substring(start, end)).append(replacement);\n            start = end + replLength;\n            if (--max == 0) {\n                break;\n            }\n            end = text.indexOf(searchString, start);\n        }\n        buf.append(text.substring(start));\n        return buf.toString();\n    }\n\n    \n    public static String replaceEach(String text, String[] searchList, String[] replacementList) {\n        return replaceEach(text, searchList, replacementList, false, 0);\n    }\n\n    \n    public static String replaceEachRepeatedly(String text, String[] searchList, String[] replacementList) {\n        \n        \n        int timeToLive = searchList == null ? 0 : searchList.length;\n        return replaceEach(text, searchList, replacementList, true, timeToLive);\n    }\n\n    \n    private static String replaceEach( String text, String[] searchList, String[] replacementList, boolean repeat, int timeToLive) {\n\n        \n        \n\n        if (text == null || text.length() == 0 || searchList == null ||\n                searchList.length == 0 || replacementList == null || replacementList.length == 0) {\n            return text;\n        }\n\n        \n        if (timeToLive < 0) {\n            throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n        }\n\n        int searchLength = searchList.length;\n        int replacementLength = replacementList.length;\n\n        \n        if (searchLength != replacementLength) {\n            throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n                + searchLength\n                + \" vs \"\n                + replacementLength);\n        }\n\n        \n        boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n\n        \n        int textIndex = -1;\n        int replaceIndex = -1;\n        int tempIndex = -1;\n\n        \n        \n        for (int i = 0; i < searchLength; i++) {\n            if (noMoreMatchesForReplIndex[i] || searchList[i] == null ||\n                    searchList[i].length() == 0 || replacementList[i] == null) {\n                continue;\n            }\n            tempIndex = text.indexOf(searchList[i]);\n\n            \n            if (tempIndex == -1) {\n                noMoreMatchesForReplIndex[i] = true;\n            } else {\n                if (textIndex == -1 || tempIndex < textIndex) {\n                    textIndex = tempIndex;\n                    replaceIndex = i;\n                }\n            }\n        }\n        \n\n        \n        if (textIndex == -1) {\n            return text;\n        }\n\n        int start = 0;\n\n        \n        int increase = 0;\n\n        \n        for (int i = 0; i < searchList.length; i++) {\n            if (searchList[i] == null || replacementList[i] == null) {\n                continue;\n            }\n            int greater = replacementList[i].length() - searchList[i].length();\n            if (greater > 0) {\n                increase += 3 * greater; \n            }\n        }\n        \n        increase = Math.min(increase, text.length() / 5);\n\n        StringBuilder buf = new StringBuilder(text.length() + increase);\n\n        while (textIndex != -1) {\n\n            for (int i = start; i < textIndex; i++) {\n                buf.append(text.charAt(i));\n            }\n            buf.append(replacementList[replaceIndex]);\n\n            start = textIndex + searchList[replaceIndex].length();\n\n            textIndex = -1;\n            replaceIndex = -1;\n            tempIndex = -1;\n            \n            \n            for (int i = 0; i < searchLength; i++) {\n                if (noMoreMatchesForReplIndex[i] || searchList[i] == null ||\n                        searchList[i].length() == 0 || replacementList[i] == null) {\n                    continue;\n                }\n                tempIndex = text.indexOf(searchList[i], start);\n\n                \n                if (tempIndex == -1) {\n                    noMoreMatchesForReplIndex[i] = true;\n                } else {\n                    if (textIndex == -1 || tempIndex < textIndex) {\n                        textIndex = tempIndex;\n                        replaceIndex = i;\n                    }\n                }\n            }\n            \n\n        }\n        int textLength = text.length();\n        for (int i = start; i < textLength; i++) {\n            buf.append(text.charAt(i));\n        }\n        String result = buf.toString();\n        if (!repeat) {\n            return result;\n        }\n\n        return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n    }\n\n    \n    \n    \n    public static String replaceChars(String str, char searchChar, char replaceChar) {\n        if (str == null) {\n            return null;\n        }\n        return str.replace(searchChar, replaceChar);\n    }\n\n    \n    public static String replaceChars(String str, String searchChars, String replaceChars) {\n        if (isEmpty(str) || isEmpty(searchChars)) {\n            return str;\n        }\n        if (replaceChars == null) {\n            replaceChars = EMPTY;\n        }\n        boolean modified = false;\n        int replaceCharsLength = replaceChars.length();\n        int strLength = str.length();\n        StringBuilder buf = new StringBuilder(strLength);\n        for (int i = 0; i < strLength; i++) {\n            char ch = str.charAt(i);\n            int index = searchChars.indexOf(ch);\n            if (index >= 0) {\n                modified = true;\n                if (index < replaceCharsLength) {\n                    buf.append(replaceChars.charAt(index));\n                }\n            } else {\n                buf.append(ch);\n            }\n        }\n        if (modified) {\n            return buf.toString();\n        }\n        return str;\n    }\n\n    \n    \n    \n    public static String overlay(String str, String overlay, int start, int end) {\n        if (str == null) {\n            return null;\n        }\n        if (overlay == null) {\n            overlay = EMPTY;\n        }\n        int len = str.length();\n        if (start < 0) {\n            start = 0;\n        }\n        if (start > len) {\n            start = len;\n        }\n        if (end < 0) {\n            end = 0;\n        }\n        if (end > len) {\n            end = len;\n        }\n        if (start > end) {\n            int temp = start;\n            start = end;\n            end = temp;\n        }\n        return new StringBuilder(len + start - end + overlay.length() + 1)\n            .append(str.substring(0, start))\n            .append(overlay)\n            .append(str.substring(end))\n            .toString();\n    }\n\n    \n    \n    \n    public static String chomp(String str) {\n        if (isEmpty(str)) {\n            return str;\n        }\n\n        if (str.length() == 1) {\n            char ch = str.charAt(0);\n            if (ch == CharUtils.CR || ch == CharUtils.LF) {\n                return EMPTY;\n            }\n            return str;\n        }\n\n        int lastIdx = str.length() - 1;\n        char last = str.charAt(lastIdx);\n\n        if (last == CharUtils.LF) {\n            if (str.charAt(lastIdx - 1) == CharUtils.CR) {\n                lastIdx--;\n            }\n        } else if (last != CharUtils.CR) {\n            lastIdx++;\n        }\n        return str.substring(0, lastIdx);\n    }\n\n    \n    public static String chomp(String str, String separator) {\n        if (isEmpty(str) || separator == null) {\n            return str;\n        }\n        if (str.endsWith(separator)) {\n            return str.substring(0, str.length() - separator.length());\n        }\n        return str;\n    }\n\n    \n    \n    \n    public static String chop(String str) {\n        if (str == null) {\n            return null;\n        }\n        int strLen = str.length();\n        if (strLen < 2) {\n            return EMPTY;\n        }\n        int lastIdx = strLen - 1;\n        String ret = str.substring(0, lastIdx);\n        char last = str.charAt(lastIdx);\n        if (last == CharUtils.LF) {\n            if (ret.charAt(lastIdx - 1) == CharUtils.CR) {\n                return ret.substring(0, lastIdx - 1);\n            }\n        }\n        return ret;\n    }\n\n    \n    \n\n    \n    \n    \n    public static String repeat(String str, int repeat) {\n        \n\n        if (str == null) {\n            return null;\n        }\n        if (repeat <= 0) {\n            return EMPTY;\n        }\n        int inputLength = str.length();\n        if (repeat == 1 || inputLength == 0) {\n            return str;\n        }\n        if (inputLength == 1 && repeat <= PAD_LIMIT) {\n            return repeat(str.charAt(0), repeat);\n        }\n\n        int outputLength = inputLength * repeat;\n        switch (inputLength) {\n            case 1 :\n                return repeat(str.charAt(0), repeat);\n            case 2 :\n                char ch0 = str.charAt(0);\n                char ch1 = str.charAt(1);\n                char[] output2 = new char[outputLength];\n                for (int i = repeat * 2 - 2; i >= 0; i--, i--) {\n                    output2[i] = ch0;\n                    output2[i + 1] = ch1;\n                }\n                return new String(output2);\n            default :\n                StringBuilder buf = new StringBuilder(outputLength);\n                for (int i = 0; i < repeat; i++) {\n                    buf.append(str);\n                }\n                return buf.toString();\n        }\n    }\n\n    \n    public static String repeat(String str, String separator, int repeat) {\n        if(str == null || separator == null) {\n            return repeat(str, repeat);\n        } else {\n            \n            String result = repeat(str + separator, repeat);\n            return removeEnd(result, separator);\n        }\n    }\n\n    \n    public static String repeat(char ch, int repeat) {\n        char[] buf = new char[repeat];\n        for (int i = repeat - 1; i >= 0; i--) {\n            buf[i] = ch;\n        }\n        return new String(buf);\n    }\n\n    \n    public static String rightPad(String str, int size) {\n        return rightPad(str, size, ' ');\n    }\n\n    \n    public static String rightPad(String str, int size, char padChar) {\n        if (str == null) {\n            return null;\n        }\n        int pads = size - str.length();\n        if (pads <= 0) {\n            return str; \n        }\n        if (pads > PAD_LIMIT) {\n            return rightPad(str, size, String.valueOf(padChar));\n        }\n        return str.concat(repeat(padChar, pads));\n    }\n\n    \n    public static String rightPad(String str, int size, String padStr) {\n        if (str == null) {\n            return null;\n        }\n        if (isEmpty(padStr)) {\n            padStr = \" \";\n        }\n        int padLen = padStr.length();\n        int strLen = str.length();\n        int pads = size - strLen;\n        if (pads <= 0) {\n            return str; \n        }\n        if (padLen == 1 && pads <= PAD_LIMIT) {\n            return rightPad(str, size, padStr.charAt(0));\n        }\n\n        if (pads == padLen) {\n            return str.concat(padStr);\n        } else if (pads < padLen) {\n            return str.concat(padStr.substring(0, pads));\n        } else {\n            char[] padding = new char[pads];\n            char[] padChars = padStr.toCharArray();\n            for (int i = 0; i < pads; i++) {\n                padding[i] = padChars[i % padLen];\n            }\n            return str.concat(new String(padding));\n        }\n    }\n\n    \n    public static String leftPad(String str, int size) {\n        return leftPad(str, size, ' ');\n    }\n\n    \n    public static String leftPad(String str, int size, char padChar) {\n        if (str == null) {\n            return null;\n        }\n        int pads = size - str.length();\n        if (pads <= 0) {\n            return str; \n        }\n        if (pads > PAD_LIMIT) {\n            return leftPad(str, size, String.valueOf(padChar));\n        }\n        return repeat(padChar, pads).concat(str);\n    }\n\n    \n    public static String leftPad(String str, int size, String padStr) {\n        if (str == null) {\n            return null;\n        }\n        if (isEmpty(padStr)) {\n            padStr = \" \";\n        }\n        int padLen = padStr.length();\n        int strLen = str.length();\n        int pads = size - strLen;\n        if (pads <= 0) {\n            return str; \n        }\n        if (padLen == 1 && pads <= PAD_LIMIT) {\n            return leftPad(str, size, padStr.charAt(0));\n        }\n\n        if (pads == padLen) {\n            return padStr.concat(str);\n        } else if (pads < padLen) {\n            return padStr.substring(0, pads).concat(str);\n        } else {\n            char[] padding = new char[pads];\n            char[] padChars = padStr.toCharArray();\n            for (int i = 0; i < pads; i++) {\n                padding[i] = padChars[i % padLen];\n            }\n            return new String(padding).concat(str);\n        }\n    }\n\n    \n    public static int length(CharSequence cs) {\n        return cs == null ? 0 : cs.length();\n    }\n\n    \n    \n    \n    public static String center(String str, int size) {\n        return center(str, size, ' ');\n    }\n\n    \n    public static String center(String str, int size, char padChar) {\n        if (str == null || size <= 0) {\n            return str;\n        }\n        int strLen = str.length();\n        int pads = size - strLen;\n        if (pads <= 0) {\n            return str;\n        }\n        str = leftPad(str, strLen + pads / 2, padChar);\n        str = rightPad(str, size, padChar);\n        return str;\n    }\n\n    \n    public static String center(String str, int size, String padStr) {\n        if (str == null || size <= 0) {\n            return str;\n        }\n        if (isEmpty(padStr)) {\n            padStr = \" \";\n        }\n        int strLen = str.length();\n        int pads = size - strLen;\n        if (pads <= 0) {\n            return str;\n        }\n        str = leftPad(str, strLen + pads / 2, padStr);\n        str = rightPad(str, size, padStr);\n        return str;\n    }\n\n    \n    \n    \n    public static String upperCase(String str) {\n        if (str == null) {\n            return null;\n        }\n        return str.toUpperCase();\n    }\n\n    \n    public static String upperCase(String str, Locale locale) {\n        if (str == null) {\n            return null;\n        }\n        return str.toUpperCase(locale);\n    }\n\n    \n    public static String lowerCase(String str) {\n        if (str == null) {\n            return null;\n        }\n        return str.toLowerCase();\n    }\n\n    \n    public static String lowerCase(String str, Locale locale) {\n        if (str == null) {\n            return null;\n        }\n        return str.toLowerCase(locale);\n    }\n\n    \n    public static String capitalize(String str) {\n        int strLen;\n        if (str == null || (strLen = str.length()) == 0) {\n            return str;\n        }\n        return new StringBuilder(strLen)\n            .append(Character.toTitleCase(str.charAt(0)))\n            .append(str.substring(1))\n            .toString();\n    }\n\n    \n    public static String uncapitalize(String str) {\n        int strLen;\n        if (str == null || (strLen = str.length()) == 0) {\n            return str;\n        }\n        return new StringBuilder(strLen)\n            .append(Character.toLowerCase(str.charAt(0)))\n            .append(str.substring(1))\n            .toString();\n    }\n\n    \n    public static String swapCase(String str) {\n        int strLen;\n        if (str == null || (strLen = str.length()) == 0) {\n            return str;\n        }\n        StringBuilder buffer = new StringBuilder(strLen);\n\n        char ch = 0;\n        for (int i = 0; i < strLen; i++) {\n            ch = str.charAt(i);\n            if (Character.isUpperCase(ch)) {\n                ch = Character.toLowerCase(ch);\n            } else if (Character.isTitleCase(ch)) {\n                ch = Character.toLowerCase(ch);\n            } else if (Character.isLowerCase(ch)) {\n                ch = Character.toUpperCase(ch);\n            }\n            buffer.append(ch);\n        }\n        return buffer.toString();\n    }\n\n    \n    \n    \n    public static int countMatches(CharSequence str, CharSequence sub) {\n        if (isEmpty(str) || isEmpty(sub)) {\n            return 0;\n        }\n        int count = 0;\n        int idx = 0;\n        while ((idx = CharSequenceUtils.indexOf(str, sub, idx)) != INDEX_NOT_FOUND) {\n            count++;\n            idx += sub.length();\n        }\n        return count;\n    }\n\n    \n    \n    \n    public static boolean isAlpha(CharSequence cs) {\n        if (cs == null || cs.length() == 0) {\n            return false;\n        }\n        int sz = cs.length();\n        for (int i = 0; i < sz; i++) {\n            if (Character.isLetter(cs.charAt(i)) == false) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public static boolean isAlphaSpace(CharSequence cs) {\n        if (cs == null) {\n            return false;\n        }\n        int sz = cs.length();\n        for (int i = 0; i < sz; i++) {\n            if ((Character.isLetter(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public static boolean isAlphanumeric(CharSequence cs) {\n        if (cs == null || cs.length() == 0) {\n            return false;\n        }\n        int sz = cs.length();\n        for (int i = 0; i < sz; i++) {\n            if (Character.isLetterOrDigit(cs.charAt(i)) == false) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public static boolean isAlphanumericSpace(CharSequence cs) {\n        if (cs == null) {\n            return false;\n        }\n        int sz = cs.length();\n        for (int i = 0; i < sz; i++) {\n            if ((Character.isLetterOrDigit(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public static boolean isAsciiPrintable(CharSequence cs) {\n        if (cs == null) {\n            return false;\n        }\n        int sz = cs.length();\n        for (int i = 0; i < sz; i++) {\n            if (CharUtils.isAsciiPrintable(cs.charAt(i)) == false) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public static boolean isNumeric(CharSequence cs) {\n        if (cs == null || cs.length() == 0) {\n            return false;\n        }\n        int sz = cs.length();\n        for (int i = 0; i < sz; i++) {\n            if (Character.isDigit(cs.charAt(i)) == false) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public static boolean isNumericSpace(CharSequence cs) {\n        if (cs == null) {\n            return false;\n        }\n        int sz = cs.length();\n        for (int i = 0; i < sz; i++) {\n            if ((Character.isDigit(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public static boolean isWhitespace(CharSequence cs) {\n        if (cs == null) {\n            return false;\n        }\n        int sz = cs.length();\n        for (int i = 0; i < sz; i++) {\n            if ((Character.isWhitespace(cs.charAt(i)) == false)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public static boolean isAllLowerCase(CharSequence cs) {\n        if (cs == null || isEmpty(cs)) {\n            return false;\n        }\n        int sz = cs.length();\n        for (int i = 0; i < sz; i++) {\n            if (Character.isLowerCase(cs.charAt(i)) == false) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public static boolean isAllUpperCase(CharSequence cs) {\n        if (cs == null || isEmpty(cs)) {\n            return false;\n        }\n        int sz = cs.length();\n        for (int i = 0; i < sz; i++) {\n            if (Character.isUpperCase(cs.charAt(i)) == false) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    \n    \n    public static String defaultString(String str) {\n        return str == null ? EMPTY : str;\n    }\n\n    \n    public static String defaultString(String str, String defaultStr) {\n        return str == null ? defaultStr : str;\n    }\n\n    \n    public static <T extends CharSequence> T defaultIfBlank(T str, T defaultStr) {\n        return StringUtils.isBlank(str) ? defaultStr : str;\n    }\n\n    \n    public static <T extends CharSequence> T defaultIfEmpty(T str, T defaultStr) {\n        return StringUtils.isEmpty(str) ? defaultStr : str;\n    }\n\n    \n    \n    \n    public static String reverse(String str) {\n        if (str == null) {\n            return null;\n        }\n        return new StringBuilder(str).reverse().toString();\n    }\n\n    \n    public static String reverseDelimited(String str, char separatorChar) {\n        if (str == null) {\n            return null;\n        }\n        \n        \n        String[] strs = split(str, separatorChar);\n        ArrayUtils.reverse(strs);\n        return join(strs, separatorChar);\n    }\n\n    \n    \n    \n    public static String abbreviate(String str, int maxWidth) {\n        return abbreviate(str, 0, maxWidth);\n    }\n\n    \n    public static String abbreviate(String str, int offset, int maxWidth) {\n        if (str == null) {\n            return null;\n        }\n        if (maxWidth < 4) {\n            throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n        }\n        if (str.length() <= maxWidth) {\n            return str;\n        }\n        if (offset > str.length()) {\n            offset = str.length();\n        }\n        if ((str.length() - offset) < (maxWidth - 3)) {\n            offset = str.length() - (maxWidth - 3);\n        }\n        final String abrevMarker = \"...\";\n        if (offset <= 4) {\n            return str.substring(0, maxWidth - 3) + abrevMarker;\n        }\n        if (maxWidth < 7) {\n            throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n        }\n        if ((offset + (maxWidth - 3)) < str.length()) {\n            return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n        }\n        return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n    }\n\n    \n    public static String abbreviateMiddle(String str, String middle, int length) {\n        if (isEmpty(str) || isEmpty(middle)) {\n            return str;\n        }\n\n        if (length >= str.length() || length < (middle.length()+2)) {\n            return str;\n        }\n\n        int targetSting = length-middle.length();\n        int startOffset = targetSting/2+targetSting%2;\n        int endOffset = str.length()-targetSting/2;\n\n        StringBuilder builder = new StringBuilder(length);\n        builder.append(str.substring(0,startOffset));\n        builder.append(middle);\n        builder.append(str.substring(endOffset));\n\n        return builder.toString();\n    }\n\n    \n    \n    \n    public static String difference(String str1, String str2) {\n        if (str1 == null) {\n            return str2;\n        }\n        if (str2 == null) {\n            return str1;\n        }\n        int at = indexOfDifference(str1, str2);\n        if (at == INDEX_NOT_FOUND) {\n            return EMPTY;\n        }\n        return str2.substring(at);\n    }\n\n    \n    public static int indexOfDifference(CharSequence cs1, CharSequence cs2) {\n        if (cs1 == cs2) {\n            return INDEX_NOT_FOUND;\n        }\n        if (cs1 == null || cs2 == null) {\n            return 0;\n        }\n        int i;\n        for (i = 0; i < cs1.length() && i < cs2.length(); ++i) {\n            if (cs1.charAt(i) != cs2.charAt(i)) {\n                break;\n            }\n        }\n        if (i < cs2.length() || i < cs1.length()) {\n            return i;\n        }\n        return INDEX_NOT_FOUND;\n    }\n\n    \n    public static int indexOfDifference(CharSequence... css) {\n        if (css == null || css.length <= 1) {\n            return INDEX_NOT_FOUND;\n        }\n        boolean anyStringNull = false;\n        boolean allStringsNull = true;\n        int arrayLen = css.length;\n        int shortestStrLen = Integer.MAX_VALUE;\n        int longestStrLen = 0;\n\n        \n        \n        \n        for (int i = 0; i < arrayLen; i++) {\n            if (css[i] == null) {\n                anyStringNull = true;\n                shortestStrLen = 0;\n            } else {\n                allStringsNull = false;\n                shortestStrLen = Math.min(css[i].length(), shortestStrLen);\n                longestStrLen = Math.max(css[i].length(), longestStrLen);\n            }\n        }\n\n        \n        if (allStringsNull || (longestStrLen == 0 && !anyStringNull)) {\n            return INDEX_NOT_FOUND;\n        }\n\n        \n        if (shortestStrLen == 0) {\n            return 0;\n        }\n\n        \n        int firstDiff = -1;\n        for (int stringPos = 0; stringPos < shortestStrLen; stringPos++) {\n            char comparisonChar = css[0].charAt(stringPos);\n            for (int arrayPos = 1; arrayPos < arrayLen; arrayPos++) {\n                if (css[arrayPos].charAt(stringPos) != comparisonChar) {\n                    firstDiff = stringPos;\n                    break;\n                }\n            }\n            if (firstDiff != -1) {\n                break;\n            }\n        }\n\n        if (firstDiff == -1 && shortestStrLen != longestStrLen) {\n            \n            \n            \n            return shortestStrLen;\n        }\n        return firstDiff;\n    }\n\n    \n    public static String getCommonPrefix(String... strs) {\n        if (strs == null || strs.length == 0) {\n            return EMPTY;\n        }\n        int smallestIndexOfDiff = indexOfDifference(strs);\n        if (smallestIndexOfDiff == INDEX_NOT_FOUND) {\n            \n            if (strs[0] == null) {\n                return EMPTY;\n            }\n            return strs[0];\n        } else if (smallestIndexOfDiff == 0) {\n            \n            return EMPTY;\n        } else {\n            \n            return strs[0].substring(0, smallestIndexOfDiff);\n        }\n    }\n\n    \n    \n    \n    public static int getLevenshteinDistance(CharSequence s, CharSequence t) {\n        if (s == null || t == null) {\n            throw new IllegalArgumentException(\"Strings must not be null\");\n        }\n\n        \n\n        int n = s.length(); \n        int m = t.length(); \n\n        if (n == 0) {\n            return m;\n        } else if (m == 0) {\n            return n;\n        }\n\n        if (n > m) {\n            \n            CharSequence tmp = s;\n            s = t;\n            t = tmp;\n            n = m;\n            m = t.length();\n        }\n\n        int p[] = new int[n + 1]; \n        int d[] = new int[n + 1]; \n        int _d[]; \n\n        \n        int i; \n        int j; \n\n        char t_j; \n\n        int cost; \n\n        for (i = 0; i <= n; i++) {\n            p[i] = i;\n        }\n\n        for (j = 1; j <= m; j++) {\n            t_j = t.charAt(j - 1);\n            d[0] = j;\n\n            for (i = 1; i <= n; i++) {\n                cost = s.charAt(i - 1) == t_j ? 0 : 1;\n                \n                d[i] = Math.min(Math.min(d[i - 1] + 1, p[i] + 1), p[i - 1] + cost);\n            }\n\n            \n            _d = p;\n            p = d;\n            d = _d;\n        }\n\n        \n        \n        return p[n];\n    }\n\n    \n    public static int getLevenshteinDistance(CharSequence s, CharSequence t, int threshold) {\n        if (s == null || t == null) {\n            throw new IllegalArgumentException(\"Strings must not be null\");\n        }\n        if (threshold < 0) {\n            throw new IllegalArgumentException(\"Threshold must not be negative\");\n        }\n\n        \n\n        int n = s.length(); \n        int m = t.length(); \n\n        \n        if (n == 0) {\n            return m <= threshold ? m : -1;\n        } else if (m == 0) {\n            return n <= threshold ? n : -1;\n        }\n\n        if (n > m) {\n            \n            CharSequence tmp = s;\n            s = t;\n            t = tmp;\n            n = m;\n            m = t.length();\n        }\n\n        int p[] = new int[n + 1]; \n        int d[] = new int[n + 1]; \n        int _d[]; \n\n        \n        int boundary = Math.min(n, threshold) + 1;\n        for (int i = 0; i < boundary; i++) {\n            p[i] = i;\n        }\n        \n        \n        Arrays.fill(p, boundary, p.length, Integer.MAX_VALUE);\n        Arrays.fill(d, Integer.MAX_VALUE);\n\n        \n        for (int j = 1; j <= m; j++) {\n            char t_j = t.charAt(j - 1); \n            d[0] = j;\n\n            \n            int min = Math.max(1, j - threshold);\n            int max = Math.min(n, j + threshold);\n\n            \n            if (min > max) {\n                return -1;\n            }\n\n            \n            if (min > 1) {\n                d[min - 1] = Integer.MAX_VALUE;\n            }\n\n            \n            for (int i = min; i <= max; i++) {\n                if (s.charAt(i - 1) == t_j) {\n                    \n                    d[i] = p[i - 1];\n                } else {\n                    \n                    d[i] = 1 + Math.min(Math.min(d[i - 1], p[i]), p[i - 1]);\n                }\n            }\n\n            \n            _d = p;\n            p = d;\n            d = _d;\n        }\n\n        \n        \n        if (p[n] <= threshold) {\n            return p[n];\n        } else {\n            return -1;\n        }\n    }\n\n    \n    \n\n    \n    public static boolean startsWith(CharSequence str, CharSequence prefix) {\n        return startsWith(str, prefix, false);\n    }\n\n    \n    public static boolean startsWithIgnoreCase(CharSequence str, CharSequence prefix) {\n        return startsWith(str, prefix, true);\n    }\n\n    \n    private static boolean startsWith(CharSequence str, CharSequence prefix, boolean ignoreCase) {\n        if (str == null || prefix == null) {\n            return (str == null && prefix == null);\n        }\n        if (prefix.length() > str.length()) {\n            return false;\n        }\n        return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());\n    }\n\n    \n    public static boolean startsWithAny(CharSequence string, CharSequence... searchStrings) {\n        if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) {\n            return false;\n        }\n        for (int i = 0; i < searchStrings.length; i++) {\n            CharSequence searchString = searchStrings[i];\n            if (StringUtils.startsWith(string, searchString)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    \n    \n\n    \n    public static boolean endsWith(CharSequence str, CharSequence suffix) {\n        return endsWith(str, suffix, false);\n    }\n\n    \n    public static boolean endsWithIgnoreCase(CharSequence str, CharSequence suffix) {\n        return endsWith(str, suffix, true);\n    }\n\n    \n    private static boolean endsWith(CharSequence str, CharSequence suffix, boolean ignoreCase) {\n        if (str == null || suffix == null) {\n            return str == null && suffix == null;\n        }\n        if (suffix.length() > str.length()) {\n            return false;\n        }\n        int strOffset = str.length() - suffix.length();\n        return CharSequenceUtils.regionMatches(str, ignoreCase, strOffset, suffix, 0, suffix.length());\n    }\n\n    \n    public static String normalizeSpace(String str) {\n        if (str == null) {\n            return null;\n        }\n        return WHITESPACE_BLOCK.matcher(trim(str)).replaceAll(\" \");\n    }\n\n    \n    public static boolean endsWithAny(CharSequence string, CharSequence... searchStrings) {\n        if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) {\n            return false;\n        }\n        for (int i = 0; i < searchStrings.length; i++) {\n            CharSequence searchString = searchStrings[i];\n            if (StringUtils.endsWith(string, searchString)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n}\n",
      "fixed_full_code": "\npackage org.apache.commons.lang3;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.regex.Pattern;\n\n\n\npublic class StringUtils { public static final String EMPTY = \"\"; public static final int INDEX_NOT_FOUND = -1; private static final int PAD_LIMIT = 8192; private static final Pattern WHITESPACE_BLOCK = Pattern.compile(\"\\\\s+\"); public StringUtils() {\n        super();\n    }\n\n    \n    \n    \n    public static boolean isEmpty(CharSequence cs) {\n        return cs == null || cs.length() == 0;\n    }\n\n    \n    public static boolean isNotEmpty(CharSequence cs) {\n        return !StringUtils.isEmpty(cs);\n    }\n\n    \n    public static boolean isBlank(CharSequence cs) {\n        int strLen;\n        if (cs == null || (strLen = cs.length()) == 0) {\n            return true;\n        }\n        for (int i = 0; i < strLen; i++) {\n            if ((Character.isWhitespace(cs.charAt(i)) == false)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public static boolean isNotBlank(CharSequence cs) {\n        return !StringUtils.isBlank(cs);\n    }\n\n    \n    \n    \n    public static String trim(String str) {\n        return str == null ? null : str.trim();\n    }\n\n    \n    public static String trimToNull(String str) {\n        String ts = trim(str);\n        return isEmpty(ts) ? null : ts;\n    }\n\n    \n    public static String trimToEmpty(String str) {\n        return str == null ? EMPTY : str.trim();\n    }\n\n    \n    \n    \n    public static String strip(String str) {\n        return strip(str, null);\n    }\n\n    \n    public static String stripToNull(String str) {\n        if (str == null) {\n            return null;\n        }\n        str = strip(str, null);\n        return str.length() == 0 ? null : str;\n    }\n\n    \n    public static String stripToEmpty(String str) {\n        return str == null ? EMPTY : strip(str, null);\n    }\n\n    \n    public static String strip(String str, String stripChars) {\n        if (isEmpty(str)) {\n            return str;\n        }\n        str = stripStart(str, stripChars);\n        return stripEnd(str, stripChars);\n    }\n\n    \n    public static String stripStart(String str, String stripChars) {\n        int strLen;\n        if (str == null || (strLen = str.length()) == 0) {\n            return str;\n        }\n        int start = 0;\n        if (stripChars == null) {\n            while ((start != strLen) && Character.isWhitespace(str.charAt(start))) {\n                start++;\n            }\n        } else if (stripChars.length() == 0) {\n            return str;\n        } else {\n            while ((start != strLen) && (stripChars.indexOf(str.charAt(start)) != INDEX_NOT_FOUND)) {\n                start++;\n            }\n        }\n        return str.substring(start);\n    }\n\n    \n    public static String stripEnd(String str, String stripChars) {\n        int end;\n        if (str == null || (end = str.length()) == 0) {\n            return str;\n        }\n\n        if (stripChars == null) {\n            while ((end != 0) && Character.isWhitespace(str.charAt(end - 1))) {\n                end--;\n            }\n        } else if (stripChars.length() == 0) {\n            return str;\n        } else {\n            while ((end != 0) && (stripChars.indexOf(str.charAt(end - 1)) != INDEX_NOT_FOUND)) {\n                end--;\n            }\n        }\n        return str.substring(0, end);\n    }\n\n    \n    \n    \n    public static String[] stripAll(String... strs) {\n        return stripAll(strs, null);\n    }\n\n    \n    public static String[] stripAll(String[] strs, String stripChars) {\n        int strsLen;\n        if (strs == null || (strsLen = strs.length) == 0) {\n            return strs;\n        }\n        String[] newArr = new String[strsLen];\n        for (int i = 0; i < strsLen; i++) {\n            newArr[i] = strip(strs[i], stripChars);\n        }\n        return newArr;\n    }\n\n    \n    \n    public static String stripAccents(String input) {\n        if(input == null) {\n            return null;\n        }\n        try {\n            String result = null;\n            if (java6Available) {\n                result = removeAccentsJava6(input);\n            } else if (sunAvailable) {\n                result = removeAccentsSUN(input);\n            } else {\n                throw new UnsupportedOperationException(\n                    \"The stripAccents(CharSequence) method requires at least Java 1.6 or a Sun JVM\");\n            }\n            \n            return result;\n        } catch(IllegalArgumentException iae) {\n            throw new RuntimeException(\"IllegalArgumentException occurred\", iae);\n        } catch(IllegalAccessException iae) {\n            throw new RuntimeException(\"IllegalAccessException occurred\", iae);\n        } catch(InvocationTargetException ite) {\n            throw new RuntimeException(\"InvocationTargetException occurred\", ite);\n        } catch(SecurityException se) {\n            throw new RuntimeException(\"SecurityException occurred\", se);\n        }\n    }\n\n    \n    private static String removeAccentsJava6(CharSequence text) throws IllegalAccessException, InvocationTargetException {\n        \n        if (!java6Available || java6NormalizerFormNFD == null) {\n            throw new IllegalStateException(\"java.text.Normalizer is not available\");\n        }\n        String result;\n        result = (String) java6NormalizeMethod.invoke(null, new Object[] {text, java6NormalizerFormNFD});\n        result = java6Pattern.matcher(result).replaceAll(\"\");\n        return result;\n    }\n\n    \n    private static String removeAccentsSUN(CharSequence text) throws IllegalAccessException, InvocationTargetException {\n        \n        if (! sunAvailable) {\n            throw new IllegalStateException(\"sun.text.Normalizer is not available\");\n        }\n        String result;\n        result = (String) sunDecomposeMethod.invoke(null, new Object[] {text, Boolean.FALSE, Integer.valueOf(0)});\n        result = sunPattern.matcher(result).replaceAll(\"\");\n        return result;\n    }\n\n    \n    private static boolean sunAvailable = false; private static Method sunDecomposeMethod = null; private static final Pattern sunPattern = Pattern.compile(\"\\\\p{InCombiningDiacriticalMarks}+\"); private static boolean java6Available = false; private static Method java6NormalizeMethod = null; private static Object java6NormalizerFormNFD = null; private static final Pattern java6Pattern = sunPattern; static {\n        try {\n            \n            \n            Class<?> normalizerFormClass = Thread.currentThread().getContextClassLoader()\n                .loadClass(\"java.text.Normalizer$Form\");\n            java6NormalizerFormNFD = normalizerFormClass.getField(\"NFD\").get(null);\n            Class<?> normalizerClass = Thread.currentThread().getContextClassLoader()\n                .loadClass(\"java.text.Normalizer\");\n            java6NormalizeMethod = normalizerClass.getMethod(\"normalize\",\n                    new Class[] {CharSequence.class, normalizerFormClass});\n            java6Available = true;\n        } catch (ClassNotFoundException e) {\n            java6Available = false;\n        } catch (NoSuchFieldException e) {\n            java6Available = false;\n        } catch (IllegalAccessException e) {\n            java6Available = false;\n        } catch (NoSuchMethodException e) {\n            java6Available = false;\n        }\n\n        try {\n            \n            Class<?> normalizerClass = Thread.currentThread().getContextClassLoader()\n                .loadClass(\"sun.text.Normalizer\");\n            sunDecomposeMethod = normalizerClass.getMethod(\"decompose\",\n                    new Class[] {String.class, Boolean.TYPE, Integer.TYPE});\n            sunAvailable = true;\n        } catch (ClassNotFoundException e) {\n            sunAvailable = false;\n        } catch (NoSuchMethodException e) {\n            sunAvailable = false;\n        }\n    }\n\n    \n    \n    \n    public static boolean equals(CharSequence cs1, CharSequence cs2) {\n        return cs1 == null ? cs2 == null : cs1.equals(cs2);\n    }\n\n    \n    public static boolean equalsIgnoreCase(CharSequence str1, CharSequence str2) {\n        if (str1 == null || str2 == null) {\n            return str1 == str2;\n        } else {\n            return CharSequenceUtils.regionMatches(str1, true, 0, str2, 0, Math.max(str1.length(), str2.length()));\n        }\n    }\n\n    \n    \n    \n    public static int indexOf(CharSequence seq, int searchChar) {\n        if (isEmpty(seq)) {\n            return INDEX_NOT_FOUND;\n        }\n        return CharSequenceUtils.indexOf(seq, searchChar, 0);\n    }\n\n    \n    public static int indexOf(CharSequence seq, int searchChar, int startPos) {\n        if (isEmpty(seq)) {\n            return INDEX_NOT_FOUND;\n        }\n        return CharSequenceUtils.indexOf(seq, searchChar, startPos);\n    }\n\n    \n    public static int indexOf(CharSequence seq, CharSequence searchSeq) {\n        if (seq == null || searchSeq == null) {\n            return INDEX_NOT_FOUND;\n        }\n        return CharSequenceUtils.indexOf(seq, searchSeq, 0);\n    }\n\n    \n    public static int indexOf(CharSequence seq, CharSequence searchSeq, int startPos) {\n        if (seq == null || searchSeq == null) {\n            return INDEX_NOT_FOUND;\n        }\n        return CharSequenceUtils.indexOf(seq, searchSeq, startPos);\n    }\n\n    \n    public static int ordinalIndexOf(CharSequence str, CharSequence searchStr, int ordinal) {\n        return ordinalIndexOf(str, searchStr, ordinal, false);\n    }\n\n    \n    \n    private static int ordinalIndexOf(CharSequence str, CharSequence searchStr, int ordinal, boolean lastIndex) {\n        if (str == null || searchStr == null || ordinal <= 0) {\n            return INDEX_NOT_FOUND;\n        }\n        if (searchStr.length() == 0) {\n            return lastIndex ? str.length() : 0;\n        }\n        int found = 0;\n        int index = lastIndex ? str.length() : INDEX_NOT_FOUND;\n        do {\n            if (lastIndex) {\n                index = CharSequenceUtils.lastIndexOf(str, searchStr, index - 1);\n            } else {\n                index = CharSequenceUtils.indexOf(str, searchStr, index + 1);\n            }\n            if (index < 0) {\n                return index;\n            }\n            found++;\n        } while (found < ordinal);\n        return index;\n    }\n\n    \n    public static int indexOfIgnoreCase(CharSequence str, CharSequence searchStr) {\n        return indexOfIgnoreCase(str, searchStr, 0);\n    }\n\n    \n    public static int indexOfIgnoreCase(CharSequence str, CharSequence searchStr, int startPos) {\n        if (str == null || searchStr == null) {\n            return INDEX_NOT_FOUND;\n        }\n        if (startPos < 0) {\n            startPos = 0;\n        }\n        int endLimit = (str.length() - searchStr.length()) + 1;\n        if (startPos > endLimit) {\n            return INDEX_NOT_FOUND;\n        }\n        if (searchStr.length() == 0) {\n            return startPos;\n        }\n        for (int i = startPos; i < endLimit; i++) {\n            if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, searchStr.length())) {\n                return i;\n            }\n        }\n        return INDEX_NOT_FOUND;\n    }\n\n    \n    \n    \n    public static int lastIndexOf(CharSequence seq, int searchChar) {\n        if (isEmpty(seq)) {\n            return INDEX_NOT_FOUND;\n        }\n        return CharSequenceUtils.lastIndexOf(seq, searchChar, seq.length());\n    }\n\n    \n    public static int lastIndexOf(CharSequence seq, int searchChar, int startPos) {\n        if (isEmpty(seq)) {\n            return INDEX_NOT_FOUND;\n        }\n        return CharSequenceUtils.lastIndexOf(seq, searchChar, startPos);\n    }\n\n    \n    public static int lastIndexOf(CharSequence seq, CharSequence searchSeq) {\n        if (seq == null || searchSeq == null) {\n            return INDEX_NOT_FOUND;\n        }\n        return CharSequenceUtils.lastIndexOf(seq, searchSeq, seq.length());\n    }\n\n    \n    public static int lastOrdinalIndexOf(CharSequence str, CharSequence searchStr, int ordinal) {\n        return ordinalIndexOf(str, searchStr, ordinal, true);\n    }\n\n    \n    public static int lastIndexOf(CharSequence seq, CharSequence searchSeq, int startPos) {\n        if (seq == null || searchSeq == null) {\n            return INDEX_NOT_FOUND;\n        }\n        return CharSequenceUtils.lastIndexOf(seq, searchSeq, startPos);\n    }\n\n    \n    public static int lastIndexOfIgnoreCase(CharSequence str, CharSequence searchStr) {\n        if (str == null || searchStr == null) {\n            return INDEX_NOT_FOUND;\n        }\n        return lastIndexOfIgnoreCase(str, searchStr, str.length());\n    }\n\n    \n    public static int lastIndexOfIgnoreCase(CharSequence str, CharSequence searchStr, int startPos) {\n        if (str == null || searchStr == null) {\n            return INDEX_NOT_FOUND;\n        }\n        if (startPos > (str.length() - searchStr.length())) {\n            startPos = str.length() - searchStr.length();\n        }\n        if (startPos < 0) {\n            return INDEX_NOT_FOUND;\n        }\n        if (searchStr.length() == 0) {\n            return startPos;\n        }\n\n        for (int i = startPos; i >= 0; i--) {\n            if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, searchStr.length())) {\n                return i;\n            }\n        }\n        return INDEX_NOT_FOUND;\n    }\n\n    \n    \n    \n    public static boolean contains(CharSequence seq, int searchChar) {\n        if (isEmpty(seq)) {\n            return false;\n        }\n        return CharSequenceUtils.indexOf(seq, searchChar, 0) >= 0;\n    }\n\n    \n    public static boolean contains(CharSequence seq, CharSequence searchSeq) {\n        if (seq == null || searchSeq == null) {\n            return false;\n        }\n        return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;\n    }\n\n    \n    public static boolean containsIgnoreCase(CharSequence str, CharSequence searchStr) {\n        if (str == null || searchStr == null) {\n            return false;\n        }\n        int len = searchStr.length();\n        int max = str.length() - len;\n        for (int i = 0; i <= max; i++) {\n            if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, len)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    \n    \n    public static boolean containsWhitespace(CharSequence seq) {\n        if (isEmpty(seq)) {\n            return false;\n        }\n        int strLen = seq.length();\n        for (int i = 0; i < strLen; i++) {\n            if (Character.isWhitespace(seq.charAt(i))) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    \n    \n    \n    public static int indexOfAny(CharSequence cs, char... searchChars) {\n        if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n            return INDEX_NOT_FOUND;\n        }\n        int csLen = cs.length();\n        int csLast = csLen - 1;\n        int searchLen = searchChars.length;\n        int searchLast = searchLen - 1;\n        for (int i = 0; i < csLen; i++) {\n            char ch = cs.charAt(i);\n            for (int j = 0; j < searchLen; j++) {\n                if (searchChars[j] == ch) {\n                    if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) {\n                        \n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return i;\n                        }\n                    } else {\n                        return i;\n                    }\n                }\n            }\n        }\n        return INDEX_NOT_FOUND;\n    }\n\n    \n    public static int indexOfAny(CharSequence cs, String searchChars) {\n        if (isEmpty(cs) || isEmpty(searchChars)) {\n            return INDEX_NOT_FOUND;\n        }\n        return indexOfAny(cs, searchChars.toCharArray());\n    }\n\n    \n    \n    \n    public static boolean containsAny(CharSequence cs, char... searchChars) {\n        if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n            return false;\n        }\n        int csLength = cs.length();\n        int searchLength = searchChars.length;\n        int csLast = csLength - 1;\n        int searchLast = searchLength - 1;\n        for (int i = 0; i < csLength; i++) {\n            char ch = cs.charAt(i);\n            for (int j = 0; j < searchLength; j++) {\n                if (searchChars[j] == ch) {\n                    if (Character.isHighSurrogate(ch)) {\n                        if (j == searchLast) {\n                            \n                            return true;\n                        }\n                        if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\n    \n    public static boolean containsAny(CharSequence cs, CharSequence searchChars) {\n        if (searchChars == null) {\n            return false;\n        }\n        return containsAny(cs, CharSequenceUtils.toCharArray(searchChars));\n    }\n\n    \n    \n    \n    public static int indexOfAnyBut(CharSequence cs, char... searchChars) {\n        if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n            return INDEX_NOT_FOUND;\n        }\n        int csLen = cs.length();\n        int csLast = csLen - 1;\n        int searchLen = searchChars.length;\n        int searchLast = searchLen - 1;\n        outer:\n        for (int i = 0; i < csLen; i++) {\n            char ch = cs.charAt(i);\n            for (int j = 0; j < searchLen; j++) {\n                if (searchChars[j] == ch) {\n                    if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) {\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            continue outer;\n                        }\n                    } else {\n                        continue outer;\n                    }\n                }\n            }\n            return i;\n        }\n        return INDEX_NOT_FOUND;\n    }\n\n    \n    public static int indexOfAnyBut(CharSequence seq, CharSequence searchChars) {\n        if (isEmpty(seq) || isEmpty(searchChars)) {\n            return INDEX_NOT_FOUND;\n        }\n        int strLen = seq.length();\n        for (int i = 0; i < strLen; i++) {\n            char ch = seq.charAt(i);\n            boolean chFound = CharSequenceUtils.indexOf(searchChars, ch, 0) >= 0;\n            if (i + 1 < strLen && Character.isHighSurrogate(ch)) {\n                char ch2 = seq.charAt(i + 1);\n                if (chFound && CharSequenceUtils.indexOf(searchChars, ch2, 0) < 0) {\n                    return i;\n                }\n            } else {\n                if (!chFound) {\n                    return i;\n                }\n            }\n        }\n        return INDEX_NOT_FOUND;\n    }\n\n    \n    \n    \n    public static boolean containsOnly(CharSequence cs, char... valid) {\n        \n        if (valid == null || cs == null) {\n            return false;\n        }\n        if (cs.length() == 0) {\n            return true;\n        }\n        if (valid.length == 0) {\n            return false;\n        }\n        return indexOfAnyBut(cs, valid) == INDEX_NOT_FOUND;\n    }\n\n    \n    public static boolean containsOnly(CharSequence cs, String validChars) {\n        if (cs == null || validChars == null) {\n            return false;\n        }\n        return containsOnly(cs, validChars.toCharArray());\n    }\n\n    \n    \n    \n    public static boolean containsNone(CharSequence cs, char... searchChars) {\n        if (cs == null || searchChars == null) {\n            return true;\n        }\n        int csLen = cs.length();\n        int csLast = csLen - 1;\n        int searchLen = searchChars.length;\n        int searchLast = searchLen - 1;\n        for (int i = 0; i < csLen; i++) {\n            char ch = cs.charAt(i);\n            for (int j = 0; j < searchLen; j++) {\n                if (searchChars[j] == ch) {\n                    if (Character.isHighSurrogate(ch)) {\n                        if (j == searchLast) {\n                            \n                            return false;\n                        }\n                        if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return false;\n                        }\n                    } else {\n                        \n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n\n    \n    public static boolean containsNone(CharSequence cs, String invalidChars) {\n        if (cs == null || invalidChars == null) {\n            return true;\n        }\n        return containsNone(cs, invalidChars.toCharArray());\n    }\n\n    \n    \n    \n    public static int indexOfAny(CharSequence str, CharSequence... searchStrs) {\n        if (str == null || searchStrs == null) {\n            return INDEX_NOT_FOUND;\n        }\n        int sz = searchStrs.length;\n\n        \n        int ret = Integer.MAX_VALUE;\n\n        int tmp = 0;\n        for (int i = 0; i < sz; i++) {\n            CharSequence search = searchStrs[i];\n            if (search == null) {\n                continue;\n            }\n            tmp = CharSequenceUtils.indexOf(str, search, 0);\n            if (tmp == INDEX_NOT_FOUND) {\n                continue;\n            }\n\n            if (tmp < ret) {\n                ret = tmp;\n            }\n        }\n\n        return (ret == Integer.MAX_VALUE) ? INDEX_NOT_FOUND : ret;\n    }\n\n    \n    public static int lastIndexOfAny(CharSequence str, CharSequence... searchStrs) {\n        if (str == null || searchStrs == null) {\n            return INDEX_NOT_FOUND;\n        }\n        int sz = searchStrs.length;\n        int ret = INDEX_NOT_FOUND;\n        int tmp = 0;\n        for (int i = 0; i < sz; i++) {\n            CharSequence search = searchStrs[i];\n            if (search == null) {\n                continue;\n            }\n            tmp = CharSequenceUtils.lastIndexOf(str, search, str.length());\n            if (tmp > ret) {\n                ret = tmp;\n            }\n        }\n        return ret;\n    }\n\n    \n    \n    \n    public static String substring(String str, int start) {\n        if (str == null) {\n            return null;\n        }\n\n        \n        if (start < 0) {\n            start = str.length() + start; \n        }\n\n        if (start < 0) {\n            start = 0;\n        }\n        if (start > str.length()) {\n            return EMPTY;\n        }\n\n        return str.substring(start);\n    }\n\n    \n    public static String substring(String str, int start, int end) {\n        if (str == null) {\n            return null;\n        }\n\n        \n        if (end < 0) {\n            end = str.length() + end; \n        }\n        if (start < 0) {\n            start = str.length() + start; \n        }\n\n        \n        if (end > str.length()) {\n            end = str.length();\n        }\n\n        \n        if (start > end) {\n            return EMPTY;\n        }\n\n        if (start < 0) {\n            start = 0;\n        }\n        if (end < 0) {\n            end = 0;\n        }\n\n        return str.substring(start, end);\n    }\n\n    \n    \n    \n    public static String left(String str, int len) {\n        if (str == null) {\n            return null;\n        }\n        if (len < 0) {\n            return EMPTY;\n        }\n        if (str.length() <= len) {\n            return str;\n        }\n        return str.substring(0, len);\n    }\n\n    \n    public static String right(String str, int len) {\n        if (str == null) {\n            return null;\n        }\n        if (len < 0) {\n            return EMPTY;\n        }\n        if (str.length() <= len) {\n            return str;\n        }\n        return str.substring(str.length() - len);\n    }\n\n    \n    public static String mid(String str, int pos, int len) {\n        if (str == null) {\n            return null;\n        }\n        if (len < 0 || pos > str.length()) {\n            return EMPTY;\n        }\n        if (pos < 0) {\n            pos = 0;\n        }\n        if (str.length() <= (pos + len)) {\n            return str.substring(pos);\n        }\n        return str.substring(pos, pos + len);\n    }\n\n    \n    \n    \n    public static String substringBefore(String str, String separator) {\n        if (isEmpty(str) || separator == null) {\n            return str;\n        }\n        if (separator.length() == 0) {\n            return EMPTY;\n        }\n        int pos = str.indexOf(separator);\n        if (pos == INDEX_NOT_FOUND) {\n            return str;\n        }\n        return str.substring(0, pos);\n    }\n\n    \n    public static String substringAfter(String str, String separator) {\n        if (isEmpty(str)) {\n            return str;\n        }\n        if (separator == null) {\n            return EMPTY;\n        }\n        int pos = str.indexOf(separator);\n        if (pos == INDEX_NOT_FOUND) {\n            return EMPTY;\n        }\n        return str.substring(pos + separator.length());\n    }\n\n    \n    public static String substringBeforeLast(String str, String separator) {\n        if (isEmpty(str) || isEmpty(separator)) {\n            return str;\n        }\n        int pos = str.lastIndexOf(separator);\n        if (pos == INDEX_NOT_FOUND) {\n            return str;\n        }\n        return str.substring(0, pos);\n    }\n\n    \n    public static String substringAfterLast(String str, String separator) {\n        if (isEmpty(str)) {\n            return str;\n        }\n        if (isEmpty(separator)) {\n            return EMPTY;\n        }\n        int pos = str.lastIndexOf(separator);\n        if (pos == INDEX_NOT_FOUND || pos == (str.length() - separator.length())) {\n            return EMPTY;\n        }\n        return str.substring(pos + separator.length());\n    }\n\n    \n    \n    \n    public static String substringBetween(String str, String tag) {\n        return substringBetween(str, tag, tag);\n    }\n\n    \n    public static String substringBetween(String str, String open, String close) {\n        if (str == null || open == null || close == null) {\n            return null;\n        }\n        int start = str.indexOf(open);\n        if (start != INDEX_NOT_FOUND) {\n            int end = str.indexOf(close, start + open.length());\n            if (end != INDEX_NOT_FOUND) {\n                return str.substring(start + open.length(), end);\n            }\n        }\n        return null;\n    }\n\n    \n    public static String[] substringsBetween(String str, String open, String close) {\n        if (str == null || isEmpty(open) || isEmpty(close)) {\n            return null;\n        }\n        int strLen = str.length();\n        if (strLen == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n        int closeLen = close.length();\n        int openLen = open.length();\n        List<String> list = new ArrayList<String>();\n        int pos = 0;\n        while (pos < (strLen - closeLen)) {\n            int start = str.indexOf(open, pos);\n            if (start < 0) {\n                break;\n            }\n            start += openLen;\n            int end = str.indexOf(close, start);\n            if (end < 0) {\n                break;\n            }\n            list.add(str.substring(start, end));\n            pos = end + closeLen;\n        }\n        if (list.isEmpty()) {\n            return null;\n        }\n        return list.toArray(new String [list.size()]);\n    }\n\n    \n    \n\n    \n    \n    \n    public static String[] split(String str) {\n        return split(str, null, -1);\n    }\n\n    \n    public static String[] split(String str, char separatorChar) {\n        return splitWorker(str, separatorChar, false);\n    }\n\n    \n    public static String[] split(String str, String separatorChars) {\n        return splitWorker(str, separatorChars, -1, false);\n    }\n\n    \n    public static String[] split(String str, String separatorChars, int max) {\n        return splitWorker(str, separatorChars, max, false);\n    }\n\n    \n    public static String[] splitByWholeSeparator(String str, String separator) {\n        return splitByWholeSeparatorWorker( str, separator, -1, false ) ;\n    }\n\n    \n    public static String[] splitByWholeSeparator( String str, String separator, int max ) {\n        return splitByWholeSeparatorWorker(str, separator, max, false);\n    }\n\n    \n    public static String[] splitByWholeSeparatorPreserveAllTokens(String str, String separator) {\n        return splitByWholeSeparatorWorker(str, separator, -1, true);\n    }\n\n    \n    public static String[] splitByWholeSeparatorPreserveAllTokens(String str, String separator, int max) {\n        return splitByWholeSeparatorWorker(str, separator, max, true);\n    }\n\n    \n    private static String[] splitByWholeSeparatorWorker( String str, String separator, int max, boolean preserveAllTokens) {\n        if (str == null) {\n            return null;\n        }\n\n        int len = str.length();\n\n        if (len == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n\n        if ((separator == null) || (EMPTY.equals(separator))) {\n            \n            return splitWorker(str, null, max, preserveAllTokens);\n        }\n\n        int separatorLength = separator.length();\n\n        ArrayList<String> substrings = new ArrayList<String>();\n        int numberOfSubstrings = 0;\n        int beg = 0;\n        int end = 0;\n        while (end < len) {\n            end = str.indexOf(separator, beg);\n\n            if (end > -1) {\n                if (end > beg) {\n                    numberOfSubstrings += 1;\n\n                    if (numberOfSubstrings == max) {\n                        end = len;\n                        substrings.add(str.substring(beg));\n                    } else {\n                        \n                        \n                        substrings.add(str.substring(beg, end));\n\n                        \n                        \n                        \n                        beg = end + separatorLength;\n                    }\n                } else {\n                    \n                    if (preserveAllTokens) {\n                        numberOfSubstrings += 1;\n                        if (numberOfSubstrings == max) {\n                            end = len;\n                            substrings.add(str.substring(beg));\n                        } else {\n                            substrings.add(EMPTY);\n                        }\n                    }\n                    beg = end + separatorLength;\n                }\n            } else {\n                \n                substrings.add(str.substring(beg));\n                end = len;\n            }\n        }\n\n        return substrings.toArray(new String[substrings.size()]);\n    }\n\n    \n    \n    public static String[] splitPreserveAllTokens(String str) {\n        return splitWorker(str, null, -1, true);\n    }\n\n    \n    public static String[] splitPreserveAllTokens(String str, char separatorChar) {\n        return splitWorker(str, separatorChar, true);\n    }\n\n    \n    private static String[] splitWorker(String str, char separatorChar, boolean preserveAllTokens) {\n        \n\n        if (str == null) {\n            return null;\n        }\n        int len = str.length();\n        if (len == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n        List<String> list = new ArrayList<String>();\n        int i = 0, start = 0;\n        boolean match = false;\n        boolean lastMatch = false;\n        while (i < len) {\n            if (str.charAt(i) == separatorChar) {\n                if (match || preserveAllTokens) {\n                    list.add(str.substring(start, i));\n                    match = false;\n                    lastMatch = true;\n                }\n                start = ++i;\n                continue;\n            }\n            lastMatch = false;\n            match = true;\n            i++;\n        }\n        if (match || (preserveAllTokens && lastMatch)) {\n            list.add(str.substring(start, i));\n        }\n        return list.toArray(new String[list.size()]);\n    }\n\n    \n    public static String[] splitPreserveAllTokens(String str, String separatorChars) {\n        return splitWorker(str, separatorChars, -1, true);\n    }\n\n    \n    public static String[] splitPreserveAllTokens(String str, String separatorChars, int max) {\n        return splitWorker(str, separatorChars, max, true);\n    }\n\n    \n    private static String[] splitWorker(String str, String separatorChars, int max, boolean preserveAllTokens) {\n        \n        \n        \n\n        if (str == null) {\n            return null;\n        }\n        int len = str.length();\n        if (len == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n        List<String> list = new ArrayList<String>();\n        int sizePlus1 = 1;\n        int i = 0, start = 0;\n        boolean match = false;\n        boolean lastMatch = false;\n        if (separatorChars == null) {\n            \n            while (i < len) {\n                if (Character.isWhitespace(str.charAt(i))) {\n                    if (match || preserveAllTokens) {\n                        lastMatch = true;\n                        if (sizePlus1++ == max) {\n                            i = len;\n                            lastMatch = false;\n                        }\n                        list.add(str.substring(start, i));\n                        match = false;\n                    }\n                    start = ++i;\n                    continue;\n                }\n                lastMatch = false;\n                match = true;\n                i++;\n            }\n        } else if (separatorChars.length() == 1) {\n            \n            char sep = separatorChars.charAt(0);\n            while (i < len) {\n                if (str.charAt(i) == sep) {\n                    if (match || preserveAllTokens) {\n                        lastMatch = true;\n                        if (sizePlus1++ == max) {\n                            i = len;\n                            lastMatch = false;\n                        }\n                        list.add(str.substring(start, i));\n                        match = false;\n                    }\n                    start = ++i;\n                    continue;\n                }\n                lastMatch = false;\n                match = true;\n                i++;\n            }\n        } else {\n            \n            while (i < len) {\n                if (separatorChars.indexOf(str.charAt(i)) >= 0) {\n                    if (match || preserveAllTokens) {\n                        lastMatch = true;\n                        if (sizePlus1++ == max) {\n                            i = len;\n                            lastMatch = false;\n                        }\n                        list.add(str.substring(start, i));\n                        match = false;\n                    }\n                    start = ++i;\n                    continue;\n                }\n                lastMatch = false;\n                match = true;\n                i++;\n            }\n        }\n        if (match || (preserveAllTokens && lastMatch)) {\n            list.add(str.substring(start, i));\n        }\n        return list.toArray(new String[list.size()]);\n    }\n\n    \n    public static String[] splitByCharacterType(String str) {\n        return splitByCharacterType(str, false);\n    }\n\n    \n    public static String[] splitByCharacterTypeCamelCase(String str) {\n        return splitByCharacterType(str, true);\n    }\n\n    \n    private static String[] splitByCharacterType(String str, boolean camelCase) {\n        if (str == null) {\n            return null;\n        }\n        if (str.length() == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n        char[] c = str.toCharArray();\n        List<String> list = new ArrayList<String>();\n        int tokenStart = 0;\n        int currentType = Character.getType(c[tokenStart]);\n        for (int pos = tokenStart + 1; pos < c.length; pos++) {\n            int type = Character.getType(c[pos]);\n            if (type == currentType) {\n                continue;\n            }\n            if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n                int newTokenStart = pos - 1;\n                if (newTokenStart != tokenStart) {\n                    list.add(new String(c, tokenStart, newTokenStart - tokenStart));\n                    tokenStart = newTokenStart;\n                }\n            } else {\n                list.add(new String(c, tokenStart, pos - tokenStart));\n                tokenStart = pos;\n            }\n            currentType = type;\n        }\n        list.add(new String(c, tokenStart, c.length - tokenStart));\n        return list.toArray(new String[list.size()]);\n    }\n\n    \n    \n    \n    public static <T> String join(T... elements) {\n        return join(elements, null);\n    }\n\n    \n    public static String join(Object[] array, char separator) {\n        if (array == null) {\n            return null;\n        }\n\n        return join(array, separator, 0, array.length);\n    }\n\n    \n    public static String join(Object[] array, char separator, int startIndex, int endIndex) {\n        if (array == null) {\n            return null;\n        }\n        int noOfItems = (endIndex - startIndex);\n        if (noOfItems <= 0) {\n            return EMPTY;\n        }\n        \n        StringBuilder buf = new StringBuilder(noOfItems * 16);\n\n        for (int i = startIndex; i < endIndex; i++) {\n            if (i > startIndex) {\n                buf.append(separator);\n            }\n            if (array[i] != null) {\n                buf.append(array[i]);\n            }\n        }\n        return buf.toString();\n    }\n\n    \n    public static String join(Object[] array, String separator) {\n        if (array == null) {\n            return null;\n        }\n        return join(array, separator, 0, array.length);\n    }\n\n    \n    public static String join(Object[] array, String separator, int startIndex, int endIndex) {\n        if (array == null) {\n            return null;\n        }\n        if (separator == null) {\n            separator = EMPTY;\n        }\n\n        \n        \n        int noOfItems = (endIndex - startIndex);\n        if (noOfItems <= 0) {\n            return EMPTY;\n        }\n\n        StringBuilder buf = new StringBuilder(noOfItems * 16);\n\n        for (int i = startIndex; i < endIndex; i++) {\n            if (i > startIndex) {\n                buf.append(separator);\n            }\n            if (array[i] != null) {\n                buf.append(array[i]);\n            }\n        }\n        return buf.toString();\n    }\n\n    \n    public static String join(Iterator<?> iterator, char separator) {\n\n        \n        if (iterator == null) {\n            return null;\n        }\n        if (!iterator.hasNext()) {\n            return EMPTY;\n        }\n        Object first = iterator.next();\n        if (!iterator.hasNext()) {\n            return ObjectUtils.toString(first);\n        }\n\n        \n        StringBuilder buf = new StringBuilder(256); \n        if (first != null) {\n            buf.append(first);\n        }\n\n        while (iterator.hasNext()) {\n            buf.append(separator);\n            Object obj = iterator.next();\n            if (obj != null) {\n                buf.append(obj);\n            }\n        }\n\n        return buf.toString();\n    }\n\n    \n    public static String join(Iterator<?> iterator, String separator) {\n\n        \n        if (iterator == null) {\n            return null;\n        }\n        if (!iterator.hasNext()) {\n            return EMPTY;\n        }\n        Object first = iterator.next();\n        if (!iterator.hasNext()) {\n            return ObjectUtils.toString(first);\n        }\n\n        \n        StringBuilder buf = new StringBuilder(256); \n        if (first != null) {\n            buf.append(first);\n        }\n\n        while (iterator.hasNext()) {\n            if (separator != null) {\n                buf.append(separator);\n            }\n            Object obj = iterator.next();\n            if (obj != null) {\n                buf.append(obj);\n            }\n        }\n        return buf.toString();\n    }\n\n    \n    public static String join(Iterable<?> iterable, char separator) {\n        if (iterable == null) {\n            return null;\n        }\n        return join(iterable.iterator(), separator);\n    }\n\n    \n    public static String join(Iterable<?> iterable, String separator) {\n        if (iterable == null) {\n            return null;\n        }\n        return join(iterable.iterator(), separator);\n    }\n\n    \n    \n    \n    public static String deleteWhitespace(String str) {\n        if (isEmpty(str)) {\n            return str;\n        }\n        int sz = str.length();\n        char[] chs = new char[sz];\n        int count = 0;\n        for (int i = 0; i < sz; i++) {\n            if (!Character.isWhitespace(str.charAt(i))) {\n                chs[count++] = str.charAt(i);\n            }\n        }\n        if (count == sz) {\n            return str;\n        }\n        return new String(chs, 0, count);\n    }\n\n    \n    \n    \n    public static String removeStart(String str, String remove) {\n        if (isEmpty(str) || isEmpty(remove)) {\n            return str;\n        }\n        if (str.startsWith(remove)){\n            return str.substring(remove.length());\n        }\n        return str;\n    }\n\n    \n    public static String removeStartIgnoreCase(String str, String remove) {\n        if (isEmpty(str) || isEmpty(remove)) {\n            return str;\n        }\n        if (startsWithIgnoreCase(str, remove)) {\n            return str.substring(remove.length());\n        }\n        return str;\n    }\n\n    \n    public static String removeEnd(String str, String remove) {\n        if (isEmpty(str) || isEmpty(remove)) {\n            return str;\n        }\n        if (str.endsWith(remove)) {\n            return str.substring(0, str.length() - remove.length());\n        }\n        return str;\n    }\n\n    \n    public static String removeEndIgnoreCase(String str, String remove) {\n        if (isEmpty(str) || isEmpty(remove)) {\n            return str;\n        }\n        if (endsWithIgnoreCase(str, remove)) {\n            return str.substring(0, str.length() - remove.length());\n        }\n        return str;\n    }\n\n    \n    public static String remove(String str, String remove) {\n        if (isEmpty(str) || isEmpty(remove)) {\n            return str;\n        }\n        return replace(str, remove, EMPTY, -1);\n    }\n\n    \n    public static String remove(String str, char remove) {\n        if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {\n            return str;\n        }\n        char[] chars = str.toCharArray();\n        int pos = 0;\n        for (int i = 0; i < chars.length; i++) {\n            if (chars[i] != remove) {\n                chars[pos++] = chars[i];\n            }\n        }\n        return new String(chars, 0, pos);\n    }\n\n    \n    \n    \n    public static String replaceOnce(String text, String searchString, String replacement) {\n        return replace(text, searchString, replacement, 1);\n    }\n\n    \n    public static String replace(String text, String searchString, String replacement) {\n        return replace(text, searchString, replacement, -1);\n    }\n\n    \n    public static String replace(String text, String searchString, String replacement, int max) {\n        if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {\n            return text;\n        }\n        int start = 0;\n        int end = text.indexOf(searchString, start);\n        if (end == INDEX_NOT_FOUND) {\n            return text;\n        }\n        int replLength = searchString.length();\n        int increase = replacement.length() - replLength;\n        increase = (increase < 0 ? 0 : increase);\n        increase *= (max < 0 ? 16 : (max > 64 ? 64 : max));\n        StringBuilder buf = new StringBuilder(text.length() + increase);\n        while (end != INDEX_NOT_FOUND) {\n            buf.append(text.substring(start, end)).append(replacement);\n            start = end + replLength;\n            if (--max == 0) {\n                break;\n            }\n            end = text.indexOf(searchString, start);\n        }\n        buf.append(text.substring(start));\n        return buf.toString();\n    }\n\n    \n    public static String replaceEach(String text, String[] searchList, String[] replacementList) {\n        return replaceEach(text, searchList, replacementList, false, 0);\n    }\n\n    \n    public static String replaceEachRepeatedly(String text, String[] searchList, String[] replacementList) {\n        \n        \n        int timeToLive = searchList == null ? 0 : searchList.length;\n        return replaceEach(text, searchList, replacementList, true, timeToLive);\n    }\n\n    \n    private static String replaceEach( String text, String[] searchList, String[] replacementList, boolean repeat, int timeToLive) {\n\n        \n        \n\n        if (text == null || text.length() == 0 || searchList == null ||\n                searchList.length == 0 || replacementList == null || replacementList.length == 0) {\n            return text;\n        }\n\n        \n        if (timeToLive < 0) {\n            throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n        }\n\n        int searchLength = searchList.length;\n        int replacementLength = replacementList.length;\n\n        \n        if (searchLength != replacementLength) {\n            throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n                + searchLength\n                + \" vs \"\n                + replacementLength);\n        }\n\n        \n        boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n\n        \n        int textIndex = -1;\n        int replaceIndex = -1;\n        int tempIndex = -1;\n\n        \n        \n        for (int i = 0; i < searchLength; i++) {\n            if (noMoreMatchesForReplIndex[i] || searchList[i] == null ||\n                    searchList[i].length() == 0 || replacementList[i] == null) {\n                continue;\n            }\n            tempIndex = text.indexOf(searchList[i]);\n\n            \n            if (tempIndex == -1) {\n                noMoreMatchesForReplIndex[i] = true;\n            } else {\n                if (textIndex == -1 || tempIndex < textIndex) {\n                    textIndex = tempIndex;\n                    replaceIndex = i;\n                }\n            }\n        }\n        \n\n        \n        if (textIndex == -1) {\n            return text;\n        }\n\n        int start = 0;\n\n        \n        int increase = 0;\n\n        \n        for (int i = 0; i < searchList.length; i++) {\n            if (searchList[i] == null || replacementList[i] == null) {\n                continue;\n            }\n            int greater = replacementList[i].length() - searchList[i].length();\n            if (greater > 0) {\n                increase += 3 * greater; \n            }\n        }\n        \n        increase = Math.min(increase, text.length() / 5);\n\n        StringBuilder buf = new StringBuilder(text.length() + increase);\n\n        while (textIndex != -1) {\n\n            for (int i = start; i < textIndex; i++) {\n                buf.append(text.charAt(i));\n            }\n            buf.append(replacementList[replaceIndex]);\n\n            start = textIndex + searchList[replaceIndex].length();\n\n            textIndex = -1;\n            replaceIndex = -1;\n            tempIndex = -1;\n            \n            \n            for (int i = 0; i < searchLength; i++) {\n                if (noMoreMatchesForReplIndex[i] || searchList[i] == null ||\n                        searchList[i].length() == 0 || replacementList[i] == null) {\n                    continue;\n                }\n                tempIndex = text.indexOf(searchList[i], start);\n\n                \n                if (tempIndex == -1) {\n                    noMoreMatchesForReplIndex[i] = true;\n                } else {\n                    if (textIndex == -1 || tempIndex < textIndex) {\n                        textIndex = tempIndex;\n                        replaceIndex = i;\n                    }\n                }\n            }\n            \n\n        }\n        int textLength = text.length();\n        for (int i = start; i < textLength; i++) {\n            buf.append(text.charAt(i));\n        }\n        String result = buf.toString();\n        if (!repeat) {\n            return result;\n        }\n\n        return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n    }\n\n    \n    \n    \n    public static String replaceChars(String str, char searchChar, char replaceChar) {\n        if (str == null) {\n            return null;\n        }\n        return str.replace(searchChar, replaceChar);\n    }\n\n    \n    public static String replaceChars(String str, String searchChars, String replaceChars) {\n        if (isEmpty(str) || isEmpty(searchChars)) {\n            return str;\n        }\n        if (replaceChars == null) {\n            replaceChars = EMPTY;\n        }\n        boolean modified = false;\n        int replaceCharsLength = replaceChars.length();\n        int strLength = str.length();\n        StringBuilder buf = new StringBuilder(strLength);\n        for (int i = 0; i < strLength; i++) {\n            char ch = str.charAt(i);\n            int index = searchChars.indexOf(ch);\n            if (index >= 0) {\n                modified = true;\n                if (index < replaceCharsLength) {\n                    buf.append(replaceChars.charAt(index));\n                }\n            } else {\n                buf.append(ch);\n            }\n        }\n        if (modified) {\n            return buf.toString();\n        }\n        return str;\n    }\n\n    \n    \n    \n    public static String overlay(String str, String overlay, int start, int end) {\n        if (str == null) {\n            return null;\n        }\n        if (overlay == null) {\n            overlay = EMPTY;\n        }\n        int len = str.length();\n        if (start < 0) {\n            start = 0;\n        }\n        if (start > len) {\n            start = len;\n        }\n        if (end < 0) {\n            end = 0;\n        }\n        if (end > len) {\n            end = len;\n        }\n        if (start > end) {\n            int temp = start;\n            start = end;\n            end = temp;\n        }\n        return new StringBuilder(len + start - end + overlay.length() + 1)\n            .append(str.substring(0, start))\n            .append(overlay)\n            .append(str.substring(end))\n            .toString();\n    }\n\n    \n    \n    \n    public static String chomp(String str) {\n        if (isEmpty(str)) {\n            return str;\n        }\n\n        if (str.length() == 1) {\n            char ch = str.charAt(0);\n            if (ch == CharUtils.CR || ch == CharUtils.LF) {\n                return EMPTY;\n            }\n            return str;\n        }\n\n        int lastIdx = str.length() - 1;\n        char last = str.charAt(lastIdx);\n\n        if (last == CharUtils.LF) {\n            if (str.charAt(lastIdx - 1) == CharUtils.CR) {\n                lastIdx--;\n            }\n        } else if (last != CharUtils.CR) {\n            lastIdx++;\n        }\n        return str.substring(0, lastIdx);\n    }\n\n    \n    public static String chomp(String str, String separator) {\n        if (isEmpty(str) || separator == null) {\n            return str;\n        }\n        if (str.endsWith(separator)) {\n            return str.substring(0, str.length() - separator.length());\n        }\n        return str;\n    }\n\n    \n    \n    \n    public static String chop(String str) {\n        if (str == null) {\n            return null;\n        }\n        int strLen = str.length();\n        if (strLen < 2) {\n            return EMPTY;\n        }\n        int lastIdx = strLen - 1;\n        String ret = str.substring(0, lastIdx);\n        char last = str.charAt(lastIdx);\n        if (last == CharUtils.LF) {\n            if (ret.charAt(lastIdx - 1) == CharUtils.CR) {\n                return ret.substring(0, lastIdx - 1);\n            }\n        }\n        return ret;\n    }\n\n    \n    \n\n    \n    \n    \n    public static String repeat(String str, int repeat) {\n        \n\n        if (str == null) {\n            return null;\n        }\n        if (repeat <= 0) {\n            return EMPTY;\n        }\n        int inputLength = str.length();\n        if (repeat == 1 || inputLength == 0) {\n            return str;\n        }\n        if (inputLength == 1 && repeat <= PAD_LIMIT) {\n            return repeat(str.charAt(0), repeat);\n        }\n\n        int outputLength = inputLength * repeat;\n        switch (inputLength) {\n            case 1 :\n                return repeat(str.charAt(0), repeat);\n            case 2 :\n                char ch0 = str.charAt(0);\n                char ch1 = str.charAt(1);\n                char[] output2 = new char[outputLength];\n                for (int i = repeat * 2 - 2; i >= 0; i--, i--) {\n                    output2[i] = ch0;\n                    output2[i + 1] = ch1;\n                }\n                return new String(output2);\n            default :\n                StringBuilder buf = new StringBuilder(outputLength);\n                for (int i = 0; i < repeat; i++) {\n                    buf.append(str);\n                }\n                return buf.toString();\n        }\n    }\n\n    \n    public static String repeat(String str, String separator, int repeat) {\n        if(str == null || separator == null) {\n            return repeat(str, repeat);\n        } else {\n            \n            String result = repeat(str + separator, repeat);\n            return removeEnd(result, separator);\n        }\n    }\n\n    \n    public static String repeat(char ch, int repeat) {\n        char[] buf = new char[repeat];\n        for (int i = repeat - 1; i >= 0; i--) {\n            buf[i] = ch;\n        }\n        return new String(buf);\n    }\n\n    \n    public static String rightPad(String str, int size) {\n        return rightPad(str, size, ' ');\n    }\n\n    \n    public static String rightPad(String str, int size, char padChar) {\n        if (str == null) {\n            return null;\n        }\n        int pads = size - str.length();\n        if (pads <= 0) {\n            return str; \n        }\n        if (pads > PAD_LIMIT) {\n            return rightPad(str, size, String.valueOf(padChar));\n        }\n        return str.concat(repeat(padChar, pads));\n    }\n\n    \n    public static String rightPad(String str, int size, String padStr) {\n        if (str == null) {\n            return null;\n        }\n        if (isEmpty(padStr)) {\n            padStr = \" \";\n        }\n        int padLen = padStr.length();\n        int strLen = str.length();\n        int pads = size - strLen;\n        if (pads <= 0) {\n            return str; \n        }\n        if (padLen == 1 && pads <= PAD_LIMIT) {\n            return rightPad(str, size, padStr.charAt(0));\n        }\n\n        if (pads == padLen) {\n            return str.concat(padStr);\n        } else if (pads < padLen) {\n            return str.concat(padStr.substring(0, pads));\n        } else {\n            char[] padding = new char[pads];\n            char[] padChars = padStr.toCharArray();\n            for (int i = 0; i < pads; i++) {\n                padding[i] = padChars[i % padLen];\n            }\n            return str.concat(new String(padding));\n        }\n    }\n\n    \n    public static String leftPad(String str, int size) {\n        return leftPad(str, size, ' ');\n    }\n\n    \n    public static String leftPad(String str, int size, char padChar) {\n        if (str == null) {\n            return null;\n        }\n        int pads = size - str.length();\n        if (pads <= 0) {\n            return str; \n        }\n        if (pads > PAD_LIMIT) {\n            return leftPad(str, size, String.valueOf(padChar));\n        }\n        return repeat(padChar, pads).concat(str);\n    }\n\n    \n    public static String leftPad(String str, int size, String padStr) {\n        if (str == null) {\n            return null;\n        }\n        if (isEmpty(padStr)) {\n            padStr = \" \";\n        }\n        int padLen = padStr.length();\n        int strLen = str.length();\n        int pads = size - strLen;\n        if (pads <= 0) {\n            return str; \n        }\n        if (padLen == 1 && pads <= PAD_LIMIT) {\n            return leftPad(str, size, padStr.charAt(0));\n        }\n\n        if (pads == padLen) {\n            return padStr.concat(str);\n        } else if (pads < padLen) {\n            return padStr.substring(0, pads).concat(str);\n        } else {\n            char[] padding = new char[pads];\n            char[] padChars = padStr.toCharArray();\n            for (int i = 0; i < pads; i++) {\n                padding[i] = padChars[i % padLen];\n            }\n            return new String(padding).concat(str);\n        }\n    }\n\n    \n    public static int length(CharSequence cs) {\n        return cs == null ? 0 : cs.length();\n    }\n\n    \n    \n    \n    public static String center(String str, int size) {\n        return center(str, size, ' ');\n    }\n\n    \n    public static String center(String str, int size, char padChar) {\n        if (str == null || size <= 0) {\n            return str;\n        }\n        int strLen = str.length();\n        int pads = size - strLen;\n        if (pads <= 0) {\n            return str;\n        }\n        str = leftPad(str, strLen + pads / 2, padChar);\n        str = rightPad(str, size, padChar);\n        return str;\n    }\n\n    \n    public static String center(String str, int size, String padStr) {\n        if (str == null || size <= 0) {\n            return str;\n        }\n        if (isEmpty(padStr)) {\n            padStr = \" \";\n        }\n        int strLen = str.length();\n        int pads = size - strLen;\n        if (pads <= 0) {\n            return str;\n        }\n        str = leftPad(str, strLen + pads / 2, padStr);\n        str = rightPad(str, size, padStr);\n        return str;\n    }\n\n    \n    \n    \n    public static String upperCase(String str) {\n        if (str == null) {\n            return null;\n        }\n        return str.toUpperCase();\n    }\n\n    \n    public static String upperCase(String str, Locale locale) {\n        if (str == null) {\n            return null;\n        }\n        return str.toUpperCase(locale);\n    }\n\n    \n    public static String lowerCase(String str) {\n        if (str == null) {\n            return null;\n        }\n        return str.toLowerCase();\n    }\n\n    \n    public static String lowerCase(String str, Locale locale) {\n        if (str == null) {\n            return null;\n        }\n        return str.toLowerCase(locale);\n    }\n\n    \n    public static String capitalize(String str) {\n        int strLen;\n        if (str == null || (strLen = str.length()) == 0) {\n            return str;\n        }\n        return new StringBuilder(strLen)\n            .append(Character.toTitleCase(str.charAt(0)))\n            .append(str.substring(1))\n            .toString();\n    }\n\n    \n    public static String uncapitalize(String str) {\n        int strLen;\n        if (str == null || (strLen = str.length()) == 0) {\n            return str;\n        }\n        return new StringBuilder(strLen)\n            .append(Character.toLowerCase(str.charAt(0)))\n            .append(str.substring(1))\n            .toString();\n    }\n\n    \n    public static String swapCase(String str) {\n        int strLen;\n        if (str == null || (strLen = str.length()) == 0) {\n            return str;\n        }\n        StringBuilder buffer = new StringBuilder(strLen);\n\n        char ch = 0;\n        for (int i = 0; i < strLen; i++) {\n            ch = str.charAt(i);\n            if (Character.isUpperCase(ch)) {\n                ch = Character.toLowerCase(ch);\n            } else if (Character.isTitleCase(ch)) {\n                ch = Character.toLowerCase(ch);\n            } else if (Character.isLowerCase(ch)) {\n                ch = Character.toUpperCase(ch);\n            }\n            buffer.append(ch);\n        }\n        return buffer.toString();\n    }\n\n    \n    \n    \n    public static int countMatches(CharSequence str, CharSequence sub) {\n        if (isEmpty(str) || isEmpty(sub)) {\n            return 0;\n        }\n        int count = 0;\n        int idx = 0;\n        while ((idx = CharSequenceUtils.indexOf(str, sub, idx)) != INDEX_NOT_FOUND) {\n            count++;\n            idx += sub.length();\n        }\n        return count;\n    }\n\n    \n    \n    \n    public static boolean isAlpha(CharSequence cs) {\n        if (cs == null || cs.length() == 0) {\n            return false;\n        }\n        int sz = cs.length();\n        for (int i = 0; i < sz; i++) {\n            if (Character.isLetter(cs.charAt(i)) == false) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public static boolean isAlphaSpace(CharSequence cs) {\n        if (cs == null) {\n            return false;\n        }\n        int sz = cs.length();\n        for (int i = 0; i < sz; i++) {\n            if ((Character.isLetter(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public static boolean isAlphanumeric(CharSequence cs) {\n        if (cs == null || cs.length() == 0) {\n            return false;\n        }\n        int sz = cs.length();\n        for (int i = 0; i < sz; i++) {\n            if (Character.isLetterOrDigit(cs.charAt(i)) == false) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public static boolean isAlphanumericSpace(CharSequence cs) {\n        if (cs == null) {\n            return false;\n        }\n        int sz = cs.length();\n        for (int i = 0; i < sz; i++) {\n            if ((Character.isLetterOrDigit(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public static boolean isAsciiPrintable(CharSequence cs) {\n        if (cs == null) {\n            return false;\n        }\n        int sz = cs.length();\n        for (int i = 0; i < sz; i++) {\n            if (CharUtils.isAsciiPrintable(cs.charAt(i)) == false) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public static boolean isNumeric(CharSequence cs) {\n        if (cs == null || cs.length() == 0) {\n            return false;\n        }\n        int sz = cs.length();\n        for (int i = 0; i < sz; i++) {\n            if (Character.isDigit(cs.charAt(i)) == false) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public static boolean isNumericSpace(CharSequence cs) {\n        if (cs == null) {\n            return false;\n        }\n        int sz = cs.length();\n        for (int i = 0; i < sz; i++) {\n            if ((Character.isDigit(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public static boolean isWhitespace(CharSequence cs) {\n        if (cs == null) {\n            return false;\n        }\n        int sz = cs.length();\n        for (int i = 0; i < sz; i++) {\n            if ((Character.isWhitespace(cs.charAt(i)) == false)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public static boolean isAllLowerCase(CharSequence cs) {\n        if (cs == null || isEmpty(cs)) {\n            return false;\n        }\n        int sz = cs.length();\n        for (int i = 0; i < sz; i++) {\n            if (Character.isLowerCase(cs.charAt(i)) == false) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public static boolean isAllUpperCase(CharSequence cs) {\n        if (cs == null || isEmpty(cs)) {\n            return false;\n        }\n        int sz = cs.length();\n        for (int i = 0; i < sz; i++) {\n            if (Character.isUpperCase(cs.charAt(i)) == false) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    \n    \n    public static String defaultString(String str) {\n        return str == null ? EMPTY : str;\n    }\n\n    \n    public static String defaultString(String str, String defaultStr) {\n        return str == null ? defaultStr : str;\n    }\n\n    \n    public static <T extends CharSequence> T defaultIfBlank(T str, T defaultStr) {\n        return StringUtils.isBlank(str) ? defaultStr : str;\n    }\n\n    \n    public static <T extends CharSequence> T defaultIfEmpty(T str, T defaultStr) {\n        return StringUtils.isEmpty(str) ? defaultStr : str;\n    }\n\n    \n    \n    \n    public static String reverse(String str) {\n        if (str == null) {\n            return null;\n        }\n        return new StringBuilder(str).reverse().toString();\n    }\n\n    \n    public static String reverseDelimited(String str, char separatorChar) {\n        if (str == null) {\n            return null;\n        }\n        \n        \n        String[] strs = split(str, separatorChar);\n        ArrayUtils.reverse(strs);\n        return join(strs, separatorChar);\n    }\n\n    \n    \n    \n    public static String abbreviate(String str, int maxWidth) {\n        return abbreviate(str, 0, maxWidth);\n    }\n\n    \n    public static String abbreviate(String str, int offset, int maxWidth) {\n        if (str == null) {\n            return null;\n        }\n        if (maxWidth < 4) {\n            throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n        }\n        if (str.length() <= maxWidth) {\n            return str;\n        }\n        if (offset > str.length()) {\n            offset = str.length();\n        }\n        if ((str.length() - offset) < (maxWidth - 3)) {\n            offset = str.length() - (maxWidth - 3);\n        }\n        final String abrevMarker = \"...\";\n        if (offset <= 4) {\n            return str.substring(0, maxWidth - 3) + abrevMarker;\n        }\n        if (maxWidth < 7) {\n            throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n        }\n        if ((offset + (maxWidth - 3)) < str.length()) {\n            return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n        }\n        return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n    }\n\n    \n    public static String abbreviateMiddle(String str, String middle, int length) {\n        if (isEmpty(str) || isEmpty(middle)) {\n            return str;\n        }\n\n        if (length >= str.length() || length < (middle.length()+2)) {\n            return str;\n        }\n\n        int targetSting = length-middle.length();\n        int startOffset = targetSting/2+targetSting%2;\n        int endOffset = str.length()-targetSting/2;\n\n        StringBuilder builder = new StringBuilder(length);\n        builder.append(str.substring(0,startOffset));\n        builder.append(middle);\n        builder.append(str.substring(endOffset));\n\n        return builder.toString();\n    }\n\n    \n    \n    \n    public static String difference(String str1, String str2) {\n        if (str1 == null) {\n            return str2;\n        }\n        if (str2 == null) {\n            return str1;\n        }\n        int at = indexOfDifference(str1, str2);\n        if (at == INDEX_NOT_FOUND) {\n            return EMPTY;\n        }\n        return str2.substring(at);\n    }\n\n    \n    public static int indexOfDifference(CharSequence cs1, CharSequence cs2) {\n        if (cs1 == cs2) {\n            return INDEX_NOT_FOUND;\n        }\n        if (cs1 == null || cs2 == null) {\n            return 0;\n        }\n        int i;\n        for (i = 0; i < cs1.length() && i < cs2.length(); ++i) {\n            if (cs1.charAt(i) != cs2.charAt(i)) {\n                break;\n            }\n        }\n        if (i < cs2.length() || i < cs1.length()) {\n            return i;\n        }\n        return INDEX_NOT_FOUND;\n    }\n\n    \n    public static int indexOfDifference(CharSequence... css) {\n        if (css == null || css.length <= 1) {\n            return INDEX_NOT_FOUND;\n        }\n        boolean anyStringNull = false;\n        boolean allStringsNull = true;\n        int arrayLen = css.length;\n        int shortestStrLen = Integer.MAX_VALUE;\n        int longestStrLen = 0;\n\n        \n        \n        \n        for (int i = 0; i < arrayLen; i++) {\n            if (css[i] == null) {\n                anyStringNull = true;\n                shortestStrLen = 0;\n            } else {\n                allStringsNull = false;\n                shortestStrLen = Math.min(css[i].length(), shortestStrLen);\n                longestStrLen = Math.max(css[i].length(), longestStrLen);\n            }\n        }\n\n        \n        if (allStringsNull || (longestStrLen == 0 && !anyStringNull)) {\n            return INDEX_NOT_FOUND;\n        }\n\n        \n        if (shortestStrLen == 0) {\n            return 0;\n        }\n\n        \n        int firstDiff = -1;\n        for (int stringPos = 0; stringPos < shortestStrLen; stringPos++) {\n            char comparisonChar = css[0].charAt(stringPos);\n            for (int arrayPos = 1; arrayPos < arrayLen; arrayPos++) {\n                if (css[arrayPos].charAt(stringPos) != comparisonChar) {\n                    firstDiff = stringPos;\n                    break;\n                }\n            }\n            if (firstDiff != -1) {\n                break;\n            }\n        }\n\n        if (firstDiff == -1 && shortestStrLen != longestStrLen) {\n            \n            \n            \n            return shortestStrLen;\n        }\n        return firstDiff;\n    }\n\n    \n    public static String getCommonPrefix(String... strs) {\n        if (strs == null || strs.length == 0) {\n            return EMPTY;\n        }\n        int smallestIndexOfDiff = indexOfDifference(strs);\n        if (smallestIndexOfDiff == INDEX_NOT_FOUND) {\n            \n            if (strs[0] == null) {\n                return EMPTY;\n            }\n            return strs[0];\n        } else if (smallestIndexOfDiff == 0) {\n            \n            return EMPTY;\n        } else {\n            \n            return strs[0].substring(0, smallestIndexOfDiff);\n        }\n    }\n\n    \n    \n    \n    public static int getLevenshteinDistance(CharSequence s, CharSequence t) {\n        if (s == null || t == null) {\n            throw new IllegalArgumentException(\"Strings must not be null\");\n        }\n\n        \n\n        int n = s.length(); \n        int m = t.length(); \n\n        if (n == 0) {\n            return m;\n        } else if (m == 0) {\n            return n;\n        }\n\n        if (n > m) {\n            \n            CharSequence tmp = s;\n            s = t;\n            t = tmp;\n            n = m;\n            m = t.length();\n        }\n\n        int p[] = new int[n + 1]; \n        int d[] = new int[n + 1]; \n        int _d[]; \n\n        \n        int i; \n        int j; \n\n        char t_j; \n\n        int cost; \n\n        for (i = 0; i <= n; i++) {\n            p[i] = i;\n        }\n\n        for (j = 1; j <= m; j++) {\n            t_j = t.charAt(j - 1);\n            d[0] = j;\n\n            for (i = 1; i <= n; i++) {\n                cost = s.charAt(i - 1) == t_j ? 0 : 1;\n                \n                d[i] = Math.min(Math.min(d[i - 1] + 1, p[i] + 1), p[i - 1] + cost);\n            }\n\n            \n            _d = p;\n            p = d;\n            d = _d;\n        }\n\n        \n        \n        return p[n];\n    }\n\n    \n    public static int getLevenshteinDistance(CharSequence s, CharSequence t, int threshold) {\n        if (s == null || t == null) {\n            throw new IllegalArgumentException(\"Strings must not be null\");\n        }\n        if (threshold < 0) {\n            throw new IllegalArgumentException(\"Threshold must not be negative\");\n        }\n\n        \n\n        int n = s.length(); \n        int m = t.length(); \n\n        \n        if (n == 0) {\n            return m <= threshold ? m : -1;\n        } else if (m == 0) {\n            return n <= threshold ? n : -1;\n        }\n\n        if (n > m) {\n            \n            CharSequence tmp = s;\n            s = t;\n            t = tmp;\n            n = m;\n            m = t.length();\n        }\n\n        int p[] = new int[n + 1]; \n        int d[] = new int[n + 1]; \n        int _d[]; \n\n        \n        int boundary = Math.min(n, threshold) + 1;\n        for (int i = 0; i < boundary; i++) {\n            p[i] = i;\n        }\n        \n        \n        Arrays.fill(p, boundary, p.length, Integer.MAX_VALUE);\n        Arrays.fill(d, Integer.MAX_VALUE);\n\n        \n        for (int j = 1; j <= m; j++) {\n            char t_j = t.charAt(j - 1); \n            d[0] = j;\n\n            \n            int min = Math.max(1, j - threshold);\n            int max = Math.min(n, j + threshold);\n\n            \n            if (min > max) {\n                return -1;\n            }\n\n            \n            if (min > 1) {\n                d[min - 1] = Integer.MAX_VALUE;\n            }\n\n            \n            for (int i = min; i <= max; i++) {\n                if (s.charAt(i - 1) == t_j) {\n                    \n                    d[i] = p[i - 1];\n                } else {\n                    \n                    d[i] = 1 + Math.min(Math.min(d[i - 1], p[i]), p[i - 1]);\n                }\n            }\n\n            \n            _d = p;\n            p = d;\n            d = _d;\n        }\n\n        \n        \n        if (p[n] <= threshold) {\n            return p[n];\n        } else {\n            return -1;\n        }\n    }\n\n    \n    \n\n    \n    public static boolean startsWith(CharSequence str, CharSequence prefix) {\n        return startsWith(str, prefix, false);\n    }\n\n    \n    public static boolean startsWithIgnoreCase(CharSequence str, CharSequence prefix) {\n        return startsWith(str, prefix, true);\n    }\n\n    \n    private static boolean startsWith(CharSequence str, CharSequence prefix, boolean ignoreCase) {\n        if (str == null || prefix == null) {\n            return (str == null && prefix == null);\n        }\n        if (prefix.length() > str.length()) {\n            return false;\n        }\n        return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());\n    }\n\n    \n    public static boolean startsWithAny(CharSequence string, CharSequence... searchStrings) {\n        if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) {\n            return false;\n        }\n        for (int i = 0; i < searchStrings.length; i++) {\n            CharSequence searchString = searchStrings[i];\n            if (StringUtils.startsWith(string, searchString)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    \n    \n\n    \n    public static boolean endsWith(CharSequence str, CharSequence suffix) {\n        return endsWith(str, suffix, false);\n    }\n\n    \n    public static boolean endsWithIgnoreCase(CharSequence str, CharSequence suffix) {\n        return endsWith(str, suffix, true);\n    }\n\n    \n    private static boolean endsWith(CharSequence str, CharSequence suffix, boolean ignoreCase) {\n        if (str == null || suffix == null) {\n            return str == null && suffix == null;\n        }\n        if (suffix.length() > str.length()) {\n            return false;\n        }\n        int strOffset = str.length() - suffix.length();\n        return CharSequenceUtils.regionMatches(str, ignoreCase, strOffset, suffix, 0, suffix.length());\n    }\n\n    \n    public static String normalizeSpace(String str) {\n        if (str == null) {\n            return null;\n        }\n        return WHITESPACE_BLOCK.matcher(trim(str)).replaceAll(\" \");\n    }\n\n    \n    public static boolean endsWithAny(CharSequence string, CharSequence... searchStrings) {\n        if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) {\n            return false;\n        }\n        for (int i = 0; i < searchStrings.length; i++) {\n            CharSequence searchString = searchStrings[i];\n            if (StringUtils.endsWith(string, searchString)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n}\n",
      "buggy_signatures": [
        "public static boolean isEmpty(CharSequence cs)",
        "public static boolean isNotEmpty(CharSequence cs)",
        "public static boolean isBlank(CharSequence cs)",
        "public static boolean isNotBlank(CharSequence cs)",
        "public static String trim(String str)",
        "public static String trimToNull(String str)",
        "public static String trimToEmpty(String str)",
        "public static String strip(String str)",
        "public static String stripToNull(String str)",
        "public static String stripToEmpty(String str)",
        "public static String strip(String str, String stripChars)",
        "public static String stripStart(String str, String stripChars)",
        "public static String stripEnd(String str, String stripChars)",
        "public static String[] stripAll(String... strs)",
        "public static String[] stripAll(String[] strs, String stripChars)",
        "public static String stripAccents(String input)",
        "private static String removeAccentsJava6(CharSequence text) throws IllegalAccessException, InvocationTargetException",
        "private static String removeAccentsSUN(CharSequence text) throws IllegalAccessException, InvocationTargetException",
        "public static boolean equals(CharSequence cs1, CharSequence cs2)",
        "public static boolean equalsIgnoreCase(CharSequence str1, CharSequence str2)",
        "public static int indexOf(CharSequence seq, int searchChar)",
        "public static int indexOf(CharSequence seq, int searchChar, int startPos)",
        "public static int indexOf(CharSequence seq, CharSequence searchSeq)",
        "public static int indexOf(CharSequence seq, CharSequence searchSeq, int startPos)",
        "public static int ordinalIndexOf(CharSequence str, CharSequence searchStr, int ordinal)",
        "private static int ordinalIndexOf(CharSequence str, CharSequence searchStr, int ordinal, boolean lastIndex)",
        "public static int indexOfIgnoreCase(CharSequence str, CharSequence searchStr)",
        "public static int indexOfIgnoreCase(CharSequence str, CharSequence searchStr, int startPos)",
        "public static int lastIndexOf(CharSequence seq, int searchChar)",
        "public static int lastIndexOf(CharSequence seq, int searchChar, int startPos)",
        "public static int lastIndexOf(CharSequence seq, CharSequence searchSeq)",
        "public static int lastOrdinalIndexOf(CharSequence str, CharSequence searchStr, int ordinal)",
        "public static int lastIndexOf(CharSequence seq, CharSequence searchSeq, int startPos)",
        "public static int lastIndexOfIgnoreCase(CharSequence str, CharSequence searchStr)",
        "public static int lastIndexOfIgnoreCase(CharSequence str, CharSequence searchStr, int startPos)",
        "public static boolean contains(CharSequence seq, int searchChar)",
        "public static boolean contains(CharSequence seq, CharSequence searchSeq)",
        "public static boolean containsIgnoreCase(CharSequence str, CharSequence searchStr)",
        "public static boolean containsWhitespace(CharSequence seq)",
        "public static int indexOfAny(CharSequence cs, char... searchChars)",
        "public static int indexOfAny(CharSequence cs, String searchChars)",
        "public static boolean containsAny(CharSequence cs, char... searchChars)",
        "public static boolean containsAny(CharSequence cs, CharSequence searchChars)",
        "public static int indexOfAnyBut(CharSequence cs, char... searchChars)",
        "public static int indexOfAnyBut(CharSequence seq, CharSequence searchChars)",
        "public static boolean containsOnly(CharSequence cs, char... valid)",
        "public static boolean containsOnly(CharSequence cs, String validChars)",
        "public static boolean containsNone(CharSequence cs, char... searchChars)",
        "public static boolean containsNone(CharSequence cs, String invalidChars)",
        "public static int indexOfAny(CharSequence str, CharSequence... searchStrs)",
        "public static int lastIndexOfAny(CharSequence str, CharSequence... searchStrs)",
        "public static String substring(String str, int start)",
        "public static String substring(String str, int start, int end)",
        "public static String left(String str, int len)",
        "public static String right(String str, int len)",
        "public static String mid(String str, int pos, int len)",
        "public static String substringBefore(String str, String separator)",
        "public static String substringAfter(String str, String separator)",
        "public static String substringBeforeLast(String str, String separator)",
        "public static String substringAfterLast(String str, String separator)",
        "public static String substringBetween(String str, String tag)",
        "public static String substringBetween(String str, String open, String close)",
        "public static String[] substringsBetween(String str, String open, String close)",
        "public static String[] split(String str)",
        "public static String[] split(String str, char separatorChar)",
        "public static String[] split(String str, String separatorChars)",
        "public static String[] split(String str, String separatorChars, int max)",
        "public static String[] splitByWholeSeparator(String str, String separator)",
        "public static String[] splitByWholeSeparator( String str, String separator, int max )",
        "public static String[] splitByWholeSeparatorPreserveAllTokens(String str, String separator)",
        "public static String[] splitByWholeSeparatorPreserveAllTokens(String str, String separator, int max)",
        "private static String[] splitByWholeSeparatorWorker( String str, String separator, int max, boolean preserveAllTokens)",
        "public static String[] splitPreserveAllTokens(String str)",
        "public static String[] splitPreserveAllTokens(String str, char separatorChar)",
        "private static String[] splitWorker(String str, char separatorChar, boolean preserveAllTokens)",
        "public static String[] splitPreserveAllTokens(String str, String separatorChars)",
        "public static String[] splitPreserveAllTokens(String str, String separatorChars, int max)",
        "private static String[] splitWorker(String str, String separatorChars, int max, boolean preserveAllTokens)",
        "public static String[] splitByCharacterType(String str)",
        "public static String[] splitByCharacterTypeCamelCase(String str)",
        "private static String[] splitByCharacterType(String str, boolean camelCase)",
        "public static <T> String join(T... elements)",
        "public static String join(Object[] array, char separator)",
        "public static String join(Object[] array, char separator, int startIndex, int endIndex)",
        "public static String join(Object[] array, String separator)",
        "public static String join(Object[] array, String separator, int startIndex, int endIndex)",
        "public static String join(Iterator<?> iterator, char separator)",
        "public static String join(Iterator<?> iterator, String separator)",
        "public static String join(Iterable<?> iterable, char separator)",
        "public static String join(Iterable<?> iterable, String separator)",
        "public static String deleteWhitespace(String str)",
        "public static String removeStart(String str, String remove)",
        "public static String removeStartIgnoreCase(String str, String remove)",
        "public static String removeEnd(String str, String remove)",
        "public static String removeEndIgnoreCase(String str, String remove)",
        "public static String remove(String str, String remove)",
        "public static String remove(String str, char remove)",
        "public static String replaceOnce(String text, String searchString, String replacement)",
        "public static String replace(String text, String searchString, String replacement)",
        "public static String replace(String text, String searchString, String replacement, int max)",
        "public static String replaceEach(String text, String[] searchList, String[] replacementList)",
        "public static String replaceEachRepeatedly(String text, String[] searchList, String[] replacementList)",
        "private static String replaceEach( String text, String[] searchList, String[] replacementList, boolean repeat, int timeToLive)",
        "public static String replaceChars(String str, char searchChar, char replaceChar)",
        "public static String replaceChars(String str, String searchChars, String replaceChars)",
        "public static String overlay(String str, String overlay, int start, int end)",
        "public static String chomp(String str)",
        "public static String chomp(String str, String separator)",
        "public static String chop(String str)",
        "public static String repeat(String str, int repeat)",
        "public static String repeat(String str, String separator, int repeat)",
        "public static String repeat(char ch, int repeat)",
        "public static String rightPad(String str, int size)",
        "public static String rightPad(String str, int size, char padChar)",
        "public static String rightPad(String str, int size, String padStr)",
        "public static String leftPad(String str, int size)",
        "public static String leftPad(String str, int size, char padChar)",
        "public static String leftPad(String str, int size, String padStr)",
        "public static int length(CharSequence cs)",
        "public static String center(String str, int size)",
        "public static String center(String str, int size, char padChar)",
        "public static String center(String str, int size, String padStr)",
        "public static String upperCase(String str)",
        "public static String upperCase(String str, Locale locale)",
        "public static String lowerCase(String str)",
        "public static String lowerCase(String str, Locale locale)",
        "public static String capitalize(String str)",
        "public static String uncapitalize(String str)",
        "public static String swapCase(String str)",
        "public static int countMatches(CharSequence str, CharSequence sub)",
        "public static boolean isAlpha(CharSequence cs)",
        "public static boolean isAlphaSpace(CharSequence cs)",
        "public static boolean isAlphanumeric(CharSequence cs)",
        "public static boolean isAlphanumericSpace(CharSequence cs)",
        "public static boolean isAsciiPrintable(CharSequence cs)",
        "public static boolean isNumeric(CharSequence cs)",
        "public static boolean isNumericSpace(CharSequence cs)",
        "public static boolean isWhitespace(CharSequence cs)",
        "public static boolean isAllLowerCase(CharSequence cs)",
        "public static boolean isAllUpperCase(CharSequence cs)",
        "public static String defaultString(String str)",
        "public static String defaultString(String str, String defaultStr)",
        "public static <T extends CharSequence> T defaultIfBlank(T str, T defaultStr)",
        "public static <T extends CharSequence> T defaultIfEmpty(T str, T defaultStr)",
        "public static String reverse(String str)",
        "public static String reverseDelimited(String str, char separatorChar)",
        "public static String abbreviate(String str, int maxWidth)",
        "public static String abbreviate(String str, int offset, int maxWidth)",
        "public static String abbreviateMiddle(String str, String middle, int length)",
        "public static String difference(String str1, String str2)",
        "public static int indexOfDifference(CharSequence cs1, CharSequence cs2)",
        "public static int indexOfDifference(CharSequence... css)",
        "public static String getCommonPrefix(String... strs)",
        "public static int getLevenshteinDistance(CharSequence s, CharSequence t)",
        "public static int getLevenshteinDistance(CharSequence s, CharSequence t, int threshold)",
        "public static boolean startsWith(CharSequence str, CharSequence prefix)",
        "public static boolean startsWithIgnoreCase(CharSequence str, CharSequence prefix)",
        "private static boolean startsWith(CharSequence str, CharSequence prefix, boolean ignoreCase)",
        "public static boolean startsWithAny(CharSequence string, CharSequence... searchStrings)",
        "public static boolean endsWith(CharSequence str, CharSequence suffix)",
        "public static boolean endsWithIgnoreCase(CharSequence str, CharSequence suffix)",
        "private static boolean endsWith(CharSequence str, CharSequence suffix, boolean ignoreCase)",
        "public static String normalizeSpace(String str)",
        "public static boolean endsWithAny(CharSequence string, CharSequence... searchStrings)"
      ],
      "fixed_signatures": [
        "public static boolean isEmpty(CharSequence cs)",
        "public static boolean isNotEmpty(CharSequence cs)",
        "public static boolean isBlank(CharSequence cs)",
        "public static boolean isNotBlank(CharSequence cs)",
        "public static String trim(String str)",
        "public static String trimToNull(String str)",
        "public static String trimToEmpty(String str)",
        "public static String strip(String str)",
        "public static String stripToNull(String str)",
        "public static String stripToEmpty(String str)",
        "public static String strip(String str, String stripChars)",
        "public static String stripStart(String str, String stripChars)",
        "public static String stripEnd(String str, String stripChars)",
        "public static String[] stripAll(String... strs)",
        "public static String[] stripAll(String[] strs, String stripChars)",
        "public static String stripAccents(String input)",
        "private static String removeAccentsJava6(CharSequence text) throws IllegalAccessException, InvocationTargetException",
        "private static String removeAccentsSUN(CharSequence text) throws IllegalAccessException, InvocationTargetException",
        "public static boolean equals(CharSequence cs1, CharSequence cs2)",
        "public static boolean equalsIgnoreCase(CharSequence str1, CharSequence str2)",
        "public static int indexOf(CharSequence seq, int searchChar)",
        "public static int indexOf(CharSequence seq, int searchChar, int startPos)",
        "public static int indexOf(CharSequence seq, CharSequence searchSeq)",
        "public static int indexOf(CharSequence seq, CharSequence searchSeq, int startPos)",
        "public static int ordinalIndexOf(CharSequence str, CharSequence searchStr, int ordinal)",
        "private static int ordinalIndexOf(CharSequence str, CharSequence searchStr, int ordinal, boolean lastIndex)",
        "public static int indexOfIgnoreCase(CharSequence str, CharSequence searchStr)",
        "public static int indexOfIgnoreCase(CharSequence str, CharSequence searchStr, int startPos)",
        "public static int lastIndexOf(CharSequence seq, int searchChar)",
        "public static int lastIndexOf(CharSequence seq, int searchChar, int startPos)",
        "public static int lastIndexOf(CharSequence seq, CharSequence searchSeq)",
        "public static int lastOrdinalIndexOf(CharSequence str, CharSequence searchStr, int ordinal)",
        "public static int lastIndexOf(CharSequence seq, CharSequence searchSeq, int startPos)",
        "public static int lastIndexOfIgnoreCase(CharSequence str, CharSequence searchStr)",
        "public static int lastIndexOfIgnoreCase(CharSequence str, CharSequence searchStr, int startPos)",
        "public static boolean contains(CharSequence seq, int searchChar)",
        "public static boolean contains(CharSequence seq, CharSequence searchSeq)",
        "public static boolean containsIgnoreCase(CharSequence str, CharSequence searchStr)",
        "public static boolean containsWhitespace(CharSequence seq)",
        "public static int indexOfAny(CharSequence cs, char... searchChars)",
        "public static int indexOfAny(CharSequence cs, String searchChars)",
        "public static boolean containsAny(CharSequence cs, char... searchChars)",
        "public static boolean containsAny(CharSequence cs, CharSequence searchChars)",
        "public static int indexOfAnyBut(CharSequence cs, char... searchChars)",
        "public static int indexOfAnyBut(CharSequence seq, CharSequence searchChars)",
        "public static boolean containsOnly(CharSequence cs, char... valid)",
        "public static boolean containsOnly(CharSequence cs, String validChars)",
        "public static boolean containsNone(CharSequence cs, char... searchChars)",
        "public static boolean containsNone(CharSequence cs, String invalidChars)",
        "public static int indexOfAny(CharSequence str, CharSequence... searchStrs)",
        "public static int lastIndexOfAny(CharSequence str, CharSequence... searchStrs)",
        "public static String substring(String str, int start)",
        "public static String substring(String str, int start, int end)",
        "public static String left(String str, int len)",
        "public static String right(String str, int len)",
        "public static String mid(String str, int pos, int len)",
        "public static String substringBefore(String str, String separator)",
        "public static String substringAfter(String str, String separator)",
        "public static String substringBeforeLast(String str, String separator)",
        "public static String substringAfterLast(String str, String separator)",
        "public static String substringBetween(String str, String tag)",
        "public static String substringBetween(String str, String open, String close)",
        "public static String[] substringsBetween(String str, String open, String close)",
        "public static String[] split(String str)",
        "public static String[] split(String str, char separatorChar)",
        "public static String[] split(String str, String separatorChars)",
        "public static String[] split(String str, String separatorChars, int max)",
        "public static String[] splitByWholeSeparator(String str, String separator)",
        "public static String[] splitByWholeSeparator( String str, String separator, int max )",
        "public static String[] splitByWholeSeparatorPreserveAllTokens(String str, String separator)",
        "public static String[] splitByWholeSeparatorPreserveAllTokens(String str, String separator, int max)",
        "private static String[] splitByWholeSeparatorWorker( String str, String separator, int max, boolean preserveAllTokens)",
        "public static String[] splitPreserveAllTokens(String str)",
        "public static String[] splitPreserveAllTokens(String str, char separatorChar)",
        "private static String[] splitWorker(String str, char separatorChar, boolean preserveAllTokens)",
        "public static String[] splitPreserveAllTokens(String str, String separatorChars)",
        "public static String[] splitPreserveAllTokens(String str, String separatorChars, int max)",
        "private static String[] splitWorker(String str, String separatorChars, int max, boolean preserveAllTokens)",
        "public static String[] splitByCharacterType(String str)",
        "public static String[] splitByCharacterTypeCamelCase(String str)",
        "private static String[] splitByCharacterType(String str, boolean camelCase)",
        "public static <T> String join(T... elements)",
        "public static String join(Object[] array, char separator)",
        "public static String join(Object[] array, char separator, int startIndex, int endIndex)",
        "public static String join(Object[] array, String separator)",
        "public static String join(Object[] array, String separator, int startIndex, int endIndex)",
        "public static String join(Iterator<?> iterator, char separator)",
        "public static String join(Iterator<?> iterator, String separator)",
        "public static String join(Iterable<?> iterable, char separator)",
        "public static String join(Iterable<?> iterable, String separator)",
        "public static String deleteWhitespace(String str)",
        "public static String removeStart(String str, String remove)",
        "public static String removeStartIgnoreCase(String str, String remove)",
        "public static String removeEnd(String str, String remove)",
        "public static String removeEndIgnoreCase(String str, String remove)",
        "public static String remove(String str, String remove)",
        "public static String remove(String str, char remove)",
        "public static String replaceOnce(String text, String searchString, String replacement)",
        "public static String replace(String text, String searchString, String replacement)",
        "public static String replace(String text, String searchString, String replacement, int max)",
        "public static String replaceEach(String text, String[] searchList, String[] replacementList)",
        "public static String replaceEachRepeatedly(String text, String[] searchList, String[] replacementList)",
        "private static String replaceEach( String text, String[] searchList, String[] replacementList, boolean repeat, int timeToLive)",
        "public static String replaceChars(String str, char searchChar, char replaceChar)",
        "public static String replaceChars(String str, String searchChars, String replaceChars)",
        "public static String overlay(String str, String overlay, int start, int end)",
        "public static String chomp(String str)",
        "public static String chomp(String str, String separator)",
        "public static String chop(String str)",
        "public static String repeat(String str, int repeat)",
        "public static String repeat(String str, String separator, int repeat)",
        "public static String repeat(char ch, int repeat)",
        "public static String rightPad(String str, int size)",
        "public static String rightPad(String str, int size, char padChar)",
        "public static String rightPad(String str, int size, String padStr)",
        "public static String leftPad(String str, int size)",
        "public static String leftPad(String str, int size, char padChar)",
        "public static String leftPad(String str, int size, String padStr)",
        "public static int length(CharSequence cs)",
        "public static String center(String str, int size)",
        "public static String center(String str, int size, char padChar)",
        "public static String center(String str, int size, String padStr)",
        "public static String upperCase(String str)",
        "public static String upperCase(String str, Locale locale)",
        "public static String lowerCase(String str)",
        "public static String lowerCase(String str, Locale locale)",
        "public static String capitalize(String str)",
        "public static String uncapitalize(String str)",
        "public static String swapCase(String str)",
        "public static int countMatches(CharSequence str, CharSequence sub)",
        "public static boolean isAlpha(CharSequence cs)",
        "public static boolean isAlphaSpace(CharSequence cs)",
        "public static boolean isAlphanumeric(CharSequence cs)",
        "public static boolean isAlphanumericSpace(CharSequence cs)",
        "public static boolean isAsciiPrintable(CharSequence cs)",
        "public static boolean isNumeric(CharSequence cs)",
        "public static boolean isNumericSpace(CharSequence cs)",
        "public static boolean isWhitespace(CharSequence cs)",
        "public static boolean isAllLowerCase(CharSequence cs)",
        "public static boolean isAllUpperCase(CharSequence cs)",
        "public static String defaultString(String str)",
        "public static String defaultString(String str, String defaultStr)",
        "public static <T extends CharSequence> T defaultIfBlank(T str, T defaultStr)",
        "public static <T extends CharSequence> T defaultIfEmpty(T str, T defaultStr)",
        "public static String reverse(String str)",
        "public static String reverseDelimited(String str, char separatorChar)",
        "public static String abbreviate(String str, int maxWidth)",
        "public static String abbreviate(String str, int offset, int maxWidth)",
        "public static String abbreviateMiddle(String str, String middle, int length)",
        "public static String difference(String str1, String str2)",
        "public static int indexOfDifference(CharSequence cs1, CharSequence cs2)",
        "public static int indexOfDifference(CharSequence... css)",
        "public static String getCommonPrefix(String... strs)",
        "public static int getLevenshteinDistance(CharSequence s, CharSequence t)",
        "public static int getLevenshteinDistance(CharSequence s, CharSequence t, int threshold)",
        "public static boolean startsWith(CharSequence str, CharSequence prefix)",
        "public static boolean startsWithIgnoreCase(CharSequence str, CharSequence prefix)",
        "private static boolean startsWith(CharSequence str, CharSequence prefix, boolean ignoreCase)",
        "public static boolean startsWithAny(CharSequence string, CharSequence... searchStrings)",
        "public static boolean endsWith(CharSequence str, CharSequence suffix)",
        "public static boolean endsWithIgnoreCase(CharSequence str, CharSequence suffix)",
        "private static boolean endsWith(CharSequence str, CharSequence suffix, boolean ignoreCase)",
        "public static String normalizeSpace(String str)",
        "public static boolean endsWithAny(CharSequence string, CharSequence... searchStrings)"
      ],
      "methods": [
        {
          "buggy_method": "  public static String join(Object[] array, char separator, int startIndex, int endIndex) {\n  if (array == null) {\n  return null;\n  }\n  int noOfItems = (endIndex - startIndex);\n  if (noOfItems <= 0) {\n  return EMPTY;\n  }\n  \n  StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1);\n\n  for (int i = startIndex; i < endIndex; i++) {\n  if (i > startIndex) {\n  buf.append(separator);\n  }\n  if (array[i] != null) {\n  buf.append(array[i]);\n  }\n  }\n  return buf.toString();\n  }",
          "fixed_method": "  public static String join(Object[] array, char separator, int startIndex, int endIndex) {\n  if (array == null) {\n  return null;\n  }\n  int noOfItems = (endIndex - startIndex);\n  if (noOfItems <= 0) {\n  return EMPTY;\n  }\n  \n  StringBuilder buf = new StringBuilder(noOfItems * 16);\n\n  for (int i = startIndex; i < endIndex; i++) {\n  if (i > startIndex) {\n  buf.append(separator);\n  }\n  if (array[i] != null) {\n  buf.append(array[i]);\n  }\n  }\n  return buf.toString();\n  }",
          "diff": [
            "@@ -3295,7 +3295,7 @@",
            "             return EMPTY;\n",
            "         }\n",
            "         \n",
            "-        StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1);\n",
            "+        StringBuilder buf = new StringBuilder(noOfItems * 16);\n",
            " \n",
            "         for (int i = startIndex; i < endIndex; i++) {\n",
            "             if (i > startIndex) {\n"
          ],
          "changed_lines": 2
        },
        {
          "buggy_method": "  public static String join(Object[] array, String separator, int startIndex, int endIndex) {\n  if (array == null) {\n  return null;\n  }\n  if (separator == null) {\n  separator = EMPTY;\n  }\n\n  \n  \n  int noOfItems = (endIndex - startIndex);\n  if (noOfItems <= 0) {\n  return EMPTY;\n  }\n\n  StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + separator.length());\n\n  for (int i = startIndex; i < endIndex; i++) {\n  if (i > startIndex) {\n  buf.append(separator);\n  }\n  if (array[i] != null) {\n  buf.append(array[i]);\n  }\n  }\n  return buf.toString();\n  }",
          "fixed_method": "  public static String join(Object[] array, String separator, int startIndex, int endIndex) {\n  if (array == null) {\n  return null;\n  }\n  if (separator == null) {\n  separator = EMPTY;\n  }\n\n  \n  \n  int noOfItems = (endIndex - startIndex);\n  if (noOfItems <= 0) {\n  return EMPTY;\n  }\n\n  StringBuilder buf = new StringBuilder(noOfItems * 16);\n\n  for (int i = startIndex; i < endIndex; i++) {\n  if (i > startIndex) {\n  buf.append(separator);\n  }\n  if (array[i] != null) {\n  buf.append(array[i]);\n  }\n  }\n  return buf.toString();\n  }",
          "diff": [
            "@@ -3380,7 +3380,7 @@",
            "             return EMPTY;\n",
            "         }\n",
            " \n",
            "-        StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + separator.length());\n",
            "+        StringBuilder buf = new StringBuilder(noOfItems * 16);\n",
            " \n",
            "         for (int i = startIndex; i < endIndex; i++) {\n",
            "             if (i > startIndex) {\n"
          ],
          "changed_lines": 2
        }
      ]
    }
  ]
}
