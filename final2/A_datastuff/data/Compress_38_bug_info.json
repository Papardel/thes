{
  "bug_id": "38",
  "failed_tests": {
    "org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest": [
      {
        "methodName": "survivesPaxHeaderWithNameEndingInSlash",
        "error": "java.io.IOException",
        "message": "Error detected parsing the header",
        "fail_line": "            final TarArchiveEntry entry = is.getNextTarEntry();",
        "test_source": "  public void survivesPaxHeaderWithNameEndingInSlash() throws Exception {\n  final TarArchiveInputStream is = getTestStream(\"/COMPRESS-356.tar\");\n  try {\n  final TarArchiveEntry entry = is.getNextTarEntry();\n  assertEquals(\"package/package.json\", entry.getName());\n  assertNull(is.getNextTarEntry());\n  } finally {\n  is.close();\n  }\n  }",
        "stack": [
          "TarArchiveInputStream.getNextTarEntry line 286, TarArchiveInputStream.getNextEntry line 600, TarArchiveInputStream.paxHeaders line 445, TarArchiveInputStream.getNextTarEntry line 319, TarArchiveInputStreamTest.survivesPaxHeaderWithNameEndingInSlash line 323, TarUtils.parseOctal line 141, TarUtils.parseOctalOrBinary line 171, TarArchiveEntry.parseTarHeader line 1096, TarArchiveEntry.parseTarHeader line 1085, TarArchiveEntry.<init> line 368, TarArchiveInputStream.getNextTarEntry line 284"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/compress/archivers/tar/TarArchiveEntry.java",
      "buggy_full_code": "\npackage org.apache.commons.compress.archivers.tar;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Date;\nimport java.util.Locale;\nimport java.util.Map;\n\nimport org.apache.commons.compress.archivers.ArchiveEntry;\nimport org.apache.commons.compress.archivers.zip.ZipEncoding;\nimport org.apache.commons.compress.utils.ArchiveUtils;\n\n\n\npublic class TarArchiveEntry implements TarConstants, ArchiveEntry { private static final TarArchiveEntry[] EMPTY_TAR_ARCHIVE_ENTRIES = new TarArchiveEntry[0]; private String name = \"\"; private boolean preserveLeadingSlashes; private int mode; private long userId = 0; private long groupId = 0; private long size = 0; private long modTime; private boolean checkSumOK; private byte linkFlag; private String linkName = \"\"; private String magic = MAGIC_POSIX; private String version = VERSION_POSIX; private String userName; private String groupName = \"\"; private int devMajor = 0; private int devMinor = 0; private boolean isExtended; private long realSize; private boolean paxGNUSparse; private boolean starSparse; private final File file; public static final int MAX_NAMELEN = 31; public static final int DEFAULT_DIR_MODE = 040755; public static final int DEFAULT_FILE_MODE = 0100644; public static final int MILLIS_PER_SECOND = 1000; private TarArchiveEntry() {\n        String user = System.getProperty(\"user.name\", \"\");\n\n        if (user.length() > MAX_NAMELEN) {\n            user = user.substring(0, MAX_NAMELEN);\n        }\n\n        this.userName = user;\n        this.file = null;\n    }\n\n    \n    public TarArchiveEntry(final String name) {\n        this(name, false);\n    }\n\n    \n    public TarArchiveEntry(String name, final boolean preserveLeadingSlashes) {\n        this();\n\n        this.preserveLeadingSlashes = preserveLeadingSlashes;\n\n        name = normalizeFileName(name, preserveLeadingSlashes);\n        final boolean isDir = name.endsWith(\"/\");\n\n        this.name = name;\n        this.mode = isDir ? DEFAULT_DIR_MODE : DEFAULT_FILE_MODE;\n        this.linkFlag = isDir ? LF_DIR : LF_NORMAL;\n        this.modTime = new Date().getTime() / MILLIS_PER_SECOND;\n        this.userName = \"\";\n    }\n\n    \n    public TarArchiveEntry(final String name, final byte linkFlag) {\n        this(name, linkFlag, false);\n    }\n\n    \n    public TarArchiveEntry(final String name, final byte linkFlag, final boolean preserveLeadingSlashes) {\n        this(name, preserveLeadingSlashes);\n        this.linkFlag = linkFlag;\n        if (linkFlag == LF_GNUTYPE_LONGNAME) {\n            magic = MAGIC_GNU;\n            version = VERSION_GNU_SPACE;\n        }\n    }\n\n    \n    public TarArchiveEntry(final File file) {\n        this(file, file.getPath());\n    }\n\n    \n    public TarArchiveEntry(final File file, final String fileName) {\n        final String normalizedName = normalizeFileName(fileName, false);\n        this.file = file;\n\n        if (file.isDirectory()) {\n            this.mode = DEFAULT_DIR_MODE;\n            this.linkFlag = LF_DIR;\n\n            final int nameLength = normalizedName.length();\n            if (nameLength == 0 || normalizedName.charAt(nameLength - 1) != '/') {\n                this.name = normalizedName + \"/\";\n            } else {\n                this.name = normalizedName;\n            }\n        } else {\n            this.mode = DEFAULT_FILE_MODE;\n            this.linkFlag = LF_NORMAL;\n            this.size = file.length();\n            this.name = normalizedName;\n        }\n\n        this.modTime = file.lastModified() / MILLIS_PER_SECOND;\n        this.userName = \"\";\n    }\n\n    \n    public TarArchiveEntry(final byte[] headerBuf) {\n        this();\n        parseTarHeader(headerBuf);\n    }\n\n    \n    public TarArchiveEntry(final byte[] headerBuf, final ZipEncoding encoding) throws IOException {\n        this();\n        parseTarHeader(headerBuf, encoding);\n    }\n\n    \n    public boolean equals(final TarArchiveEntry it) {\n        return getName().equals(it.getName());\n    }\n\n    \n    @Override\n    public boolean equals(final Object it) {\n        if (it == null || getClass() != it.getClass()) {\n            return false;\n        }\n        return equals((TarArchiveEntry) it);\n    }\n\n    \n    @Override\n    public int hashCode() {\n        return getName().hashCode();\n    }\n\n    \n    public boolean isDescendent(final TarArchiveEntry desc) {\n        return desc.getName().startsWith(getName());\n    }\n\n    \n    @Override\n    public String getName() {\n        return name;\n    }\n\n    \n    public void setName(final String name) {\n        this.name = normalizeFileName(name, this.preserveLeadingSlashes);\n    }\n\n    \n    public void setMode(final int mode) {\n        this.mode = mode;\n    }\n\n    \n    public String getLinkName() {\n        return linkName;\n    }\n\n    \n    public void setLinkName(final String link) {\n        this.linkName = link;\n    }\n\n    \n    @Deprecated\n    public int getUserId() {\n        return (int) (userId & 0xffffffff);\n    }\n\n    \n    public void setUserId(final int userId) {\n        setUserId((long) userId);\n    }\n\n    \n    public long getLongUserId() {\n        return userId;\n    }\n\n    \n    public void setUserId(final long userId) {\n        this.userId = userId;\n    }\n\n    \n    @Deprecated\n    public int getGroupId() {\n        return (int) (groupId & 0xffffffff);\n    }\n\n    \n    public void setGroupId(final int groupId) {\n        setGroupId((long) groupId);\n    }\n\n    \n    public long getLongGroupId() {\n        return groupId;\n    }\n\n    \n    public void setGroupId(final long groupId) {\n        this.groupId = groupId;\n    }\n\n    \n    public String getUserName() {\n        return userName;\n    }\n\n    \n    public void setUserName(final String userName) {\n        this.userName = userName;\n    }\n\n    \n    public String getGroupName() {\n        return groupName;\n    }\n\n    \n    public void setGroupName(final String groupName) {\n        this.groupName = groupName;\n    }\n\n    \n    public void setIds(final int userId, final int groupId) {\n        setUserId(userId);\n        setGroupId(groupId);\n    }\n\n    \n    public void setNames(final String userName, final String groupName) {\n        setUserName(userName);\n        setGroupName(groupName);\n    }\n\n    \n    public void setModTime(final long time) {\n        modTime = time / MILLIS_PER_SECOND;\n    }\n\n    \n    public void setModTime(final Date time) {\n        modTime = time.getTime() / MILLIS_PER_SECOND;\n    }\n\n    \n    public Date getModTime() {\n        return new Date(modTime * MILLIS_PER_SECOND);\n    }\n\n    @Override\n    public Date getLastModifiedDate() {\n        return getModTime();\n    }\n\n    \n    public boolean isCheckSumOK() {\n        return checkSumOK;\n    }\n\n    \n    public File getFile() {\n        return file;\n    }\n\n    \n    public int getMode() {\n        return mode;\n    }\n\n    \n    @Override\n    public long getSize() {\n        return size;\n    }\n\n    \n    public void setSize(final long size) {\n        if (size < 0){\n            throw new IllegalArgumentException(\"Size is out of range: \"+size);\n        }\n        this.size = size;\n    }\n\n    \n    public int getDevMajor() {\n        return devMajor;\n    }\n\n    \n    public void setDevMajor(final int devNo) {\n        if (devNo < 0){\n            throw new IllegalArgumentException(\"Major device number is out of \"\n                                               + \"range: \" + devNo);\n        }\n        this.devMajor = devNo;\n    }\n\n    \n    public int getDevMinor() {\n        return devMinor;\n    }\n\n    \n    public void setDevMinor(final int devNo) {\n        if (devNo < 0){\n            throw new IllegalArgumentException(\"Minor device number is out of \"\n                                               + \"range: \" + devNo);\n        }\n        this.devMinor = devNo;\n    }\n\n    \n    public boolean isExtended() {\n        return isExtended;\n    }\n\n    \n    public long getRealSize() {\n        return realSize;\n    }\n\n    \n    public boolean isGNUSparse() {\n        return isOldGNUSparse() || isPaxGNUSparse();\n    }\n\n    \n    public boolean isOldGNUSparse() {\n        return linkFlag == LF_GNUTYPE_SPARSE;\n    }\n\n    \n    public boolean isPaxGNUSparse() {\n        return paxGNUSparse;\n    }\n\n    \n    public boolean isStarSparse() {\n        return starSparse;\n    }\n\n    \n    public boolean isGNULongLinkEntry() {\n        return linkFlag == LF_GNUTYPE_LONGLINK;\n    }\n\n    \n    public boolean isGNULongNameEntry() {\n        return linkFlag == LF_GNUTYPE_LONGNAME;\n    }\n\n    \n    public boolean isPaxHeader() {\n        return linkFlag == LF_PAX_EXTENDED_HEADER_LC\n            || linkFlag == LF_PAX_EXTENDED_HEADER_UC;\n    }\n\n    \n    public boolean isGlobalPaxHeader() {\n        return linkFlag == LF_PAX_GLOBAL_EXTENDED_HEADER;\n    }\n\n    \n    @Override\n    public boolean isDirectory() {\n        if (file != null) {\n            return file.isDirectory();\n        }\n\n        if (linkFlag == LF_DIR) {\n            return true;\n        }\n\n        if (getName().endsWith(\"/\")) {\n            return true;\n        }\n\n        return false;\n    }\n\n    \n    public boolean isFile() {\n        if (file != null) {\n            return file.isFile();\n        }\n        if (linkFlag == LF_OLDNORM || linkFlag == LF_NORMAL) {\n            return true;\n        }\n        return !getName().endsWith(\"/\");\n    }\n\n    \n    public boolean isSymbolicLink() {\n        return linkFlag == LF_SYMLINK;\n    }\n\n    \n    public boolean isLink() {\n        return linkFlag == LF_LINK;\n    }\n\n    \n    public boolean isCharacterDevice() {\n        return linkFlag == LF_CHR;\n    }\n\n    \n    public boolean isBlockDevice() {\n        return linkFlag == LF_BLK;\n    }\n\n    \n    public boolean isFIFO() {\n        return linkFlag == LF_FIFO;\n    }\n\n    \n    public boolean isSparse() {\n        return isGNUSparse() || isStarSparse();\n    }\n\n    \n    public TarArchiveEntry[] getDirectoryEntries() {\n        if (file == null || !file.isDirectory()) {\n            return EMPTY_TAR_ARCHIVE_ENTRIES;\n        }\n\n        final String[] list = file.list();\n        if (list == null) {\n            return EMPTY_TAR_ARCHIVE_ENTRIES;\n        }\n        final TarArchiveEntry[] result = new TarArchiveEntry[list.length];\n\n        for (int i = 0; i < result.length; ++i) {\n            result[i] = new TarArchiveEntry(new File(file, list[i]));\n        }\n\n        return result;\n    }\n\n    \n    public void writeEntryHeader(final byte[] outbuf) {\n        try {\n            writeEntryHeader(outbuf, TarUtils.DEFAULT_ENCODING, false);\n        } catch (final IOException ex) {\n            try {\n                writeEntryHeader(outbuf, TarUtils.FALLBACK_ENCODING, false);\n            } catch (final IOException ex2) {\n                \n                throw new RuntimeException(ex2);\n            }\n        }\n    }\n\n    \n    public void writeEntryHeader(final byte[] outbuf, final ZipEncoding encoding, final boolean starMode) throws IOException {\n        int offset = 0;\n\n        offset = TarUtils.formatNameBytes(name, outbuf, offset, NAMELEN,\n                                          encoding);\n        offset = writeEntryHeaderField(mode, outbuf, offset, MODELEN, starMode);\n        offset = writeEntryHeaderField(userId, outbuf, offset, UIDLEN,\n                                       starMode);\n        offset = writeEntryHeaderField(groupId, outbuf, offset, GIDLEN,\n                                       starMode);\n        offset = writeEntryHeaderField(size, outbuf, offset, SIZELEN, starMode);\n        offset = writeEntryHeaderField(modTime, outbuf, offset, MODTIMELEN,\n                                       starMode);\n\n        final int csOffset = offset;\n\n        for (int c = 0; c < CHKSUMLEN; ++c) {\n            outbuf[offset++] = (byte) ' ';\n        }\n\n        outbuf[offset++] = linkFlag;\n        offset = TarUtils.formatNameBytes(linkName, outbuf, offset, NAMELEN,\n                                          encoding);\n        offset = TarUtils.formatNameBytes(magic, outbuf, offset, MAGICLEN);\n        offset = TarUtils.formatNameBytes(version, outbuf, offset, VERSIONLEN);\n        offset = TarUtils.formatNameBytes(userName, outbuf, offset, UNAMELEN,\n                                          encoding);\n        offset = TarUtils.formatNameBytes(groupName, outbuf, offset, GNAMELEN,\n                                          encoding);\n        offset = writeEntryHeaderField(devMajor, outbuf, offset, DEVLEN,\n                                       starMode);\n        offset = writeEntryHeaderField(devMinor, outbuf, offset, DEVLEN,\n                                       starMode);\n\n        while (offset < outbuf.length) {\n            outbuf[offset++] = 0;\n        }\n\n        final long chk = TarUtils.computeCheckSum(outbuf);\n\n        TarUtils.formatCheckSumOctalBytes(chk, outbuf, csOffset, CHKSUMLEN);\n    }\n\n    private int writeEntryHeaderField(final long value, final byte[] outbuf, final int offset, final int length, final boolean starMode) {\n        if (!starMode && (value < 0\n                          || value >= 1l << 3 * (length - 1))) {\n            \n            \n            \n            return TarUtils.formatLongOctalBytes(0, outbuf, offset, length);\n        }\n        return TarUtils.formatLongOctalOrBinaryBytes(value, outbuf, offset,\n                                                     length);\n    }\n\n    \n    public void parseTarHeader(final byte[] header) {\n        try {\n            parseTarHeader(header, TarUtils.DEFAULT_ENCODING);\n        } catch (final IOException ex) {\n            try {\n                parseTarHeader(header, TarUtils.DEFAULT_ENCODING, true);\n            } catch (final IOException ex2) {\n                \n                throw new RuntimeException(ex2);\n            }\n        }\n    }\n\n    \n    public void parseTarHeader(final byte[] header, final ZipEncoding encoding) throws IOException {\n        parseTarHeader(header, encoding, false);\n    }\n\n    private void parseTarHeader(final byte[] header, final ZipEncoding encoding, final boolean oldStyle) throws IOException {\n        int offset = 0;\n\n        name = oldStyle ? TarUtils.parseName(header, offset, NAMELEN)\n            : TarUtils.parseName(header, offset, NAMELEN, encoding);\n        offset += NAMELEN;\n        mode = (int) TarUtils.parseOctalOrBinary(header, offset, MODELEN);\n        offset += MODELEN;\n        userId = (int) TarUtils.parseOctalOrBinary(header, offset, UIDLEN);\n        offset += UIDLEN;\n        groupId = (int) TarUtils.parseOctalOrBinary(header, offset, GIDLEN);\n        offset += GIDLEN;\n        size = TarUtils.parseOctalOrBinary(header, offset, SIZELEN);\n        offset += SIZELEN;\n        modTime = TarUtils.parseOctalOrBinary(header, offset, MODTIMELEN);\n        offset += MODTIMELEN;\n        checkSumOK = TarUtils.verifyCheckSum(header);\n        offset += CHKSUMLEN;\n        linkFlag = header[offset++];\n        linkName = oldStyle ? TarUtils.parseName(header, offset, NAMELEN)\n            : TarUtils.parseName(header, offset, NAMELEN, encoding);\n        offset += NAMELEN;\n        magic = TarUtils.parseName(header, offset, MAGICLEN);\n        offset += MAGICLEN;\n        version = TarUtils.parseName(header, offset, VERSIONLEN);\n        offset += VERSIONLEN;\n        userName = oldStyle ? TarUtils.parseName(header, offset, UNAMELEN)\n            : TarUtils.parseName(header, offset, UNAMELEN, encoding);\n        offset += UNAMELEN;\n        groupName = oldStyle ? TarUtils.parseName(header, offset, GNAMELEN)\n            : TarUtils.parseName(header, offset, GNAMELEN, encoding);\n        offset += GNAMELEN;\n        devMajor = (int) TarUtils.parseOctalOrBinary(header, offset, DEVLEN);\n        offset += DEVLEN;\n        devMinor = (int) TarUtils.parseOctalOrBinary(header, offset, DEVLEN);\n        offset += DEVLEN;\n\n        final int type = evaluateType(header);\n        switch (type) {\n        case FORMAT_OLDGNU: {\n            offset += ATIMELEN_GNU;\n            offset += CTIMELEN_GNU;\n            offset += OFFSETLEN_GNU;\n            offset += LONGNAMESLEN_GNU;\n            offset += PAD2LEN_GNU;\n            offset += SPARSELEN_GNU;\n            isExtended = TarUtils.parseBoolean(header, offset);\n            offset += ISEXTENDEDLEN_GNU;\n            realSize = TarUtils.parseOctal(header, offset, REALSIZELEN_GNU);\n            offset += REALSIZELEN_GNU;\n            break;\n        }\n        case FORMAT_XSTAR: {\n            final String xstarPrefix = oldStyle\n                ? TarUtils.parseName(header, offset, PREFIXLEN_XSTAR)\n                : TarUtils.parseName(header, offset, PREFIXLEN_XSTAR, encoding);\n            if (xstarPrefix.length() > 0) {\n                name = xstarPrefix + \"/\" + name;\n            }\n            break;\n        }\n        case FORMAT_POSIX:\n        default: {\n            final String prefix = oldStyle\n                ? TarUtils.parseName(header, offset, PREFIXLEN)\n                : TarUtils.parseName(header, offset, PREFIXLEN, encoding);\n            \n            \n            if (isDirectory() && !name.endsWith(\"/\")){\n                name = name + \"/\";\n            }\n            if (prefix.length() > 0){\n                name = prefix + \"/\" + name;\n            }\n        }\n        }\n    }\n\n    \n    private static String normalizeFileName(String fileName, final boolean preserveLeadingSlashes) {\n        final String osname = System.getProperty(\"os.name\").toLowerCase(Locale.ENGLISH);\n\n        if (osname != null) {\n\n            \n            \n\n            if (osname.startsWith(\"windows\")) {\n                if (fileName.length() > 2) {\n                    final char ch1 = fileName.charAt(0);\n                    final char ch2 = fileName.charAt(1);\n\n                    if (ch2 == ':'\n                        && (ch1 >= 'a' && ch1 <= 'z'\n                            || ch1 >= 'A' && ch1 <= 'Z')) {\n                        fileName = fileName.substring(2);\n                    }\n                }\n            } else if (osname.contains(\"netware\")) {\n                final int colon = fileName.indexOf(':');\n                if (colon != -1) {\n                    fileName = fileName.substring(colon + 1);\n                }\n            }\n        }\n\n        fileName = fileName.replace(File.separatorChar, '/');\n\n        \n        \n        \n        while (!preserveLeadingSlashes && fileName.startsWith(\"/\")) {\n            fileName = fileName.substring(1);\n        }\n        return fileName;\n    }\n\n    \n    private int evaluateType(final byte[] header) {\n        if (ArchiveUtils.matchAsciiBuffer(MAGIC_GNU, header, MAGIC_OFFSET, MAGICLEN)) {\n            return FORMAT_OLDGNU;\n        }\n        if (ArchiveUtils.matchAsciiBuffer(MAGIC_POSIX, header, MAGIC_OFFSET, MAGICLEN)) {\n            if (ArchiveUtils.matchAsciiBuffer(MAGIC_XSTAR, header, XSTAR_MAGIC_OFFSET,\n                                              XSTAR_MAGIC_LEN)) {\n                return FORMAT_XSTAR;\n            }\n            return FORMAT_POSIX;\n        }\n        return 0;\n    }\n\n    void fillGNUSparse0xData(final Map<String, String> headers) {\n        paxGNUSparse = true;\n        realSize = Integer.parseInt(headers.get(\"GNU.sparse.size\"));\n        if (headers.containsKey(\"GNU.sparse.name\")) {\n            \n            name = headers.get(\"GNU.sparse.name\");\n        }\n    }\n\n    void fillGNUSparse1xData(final Map<String, String> headers) {\n        paxGNUSparse = true;\n        realSize = Integer.parseInt(headers.get(\"GNU.sparse.realsize\"));\n        name = headers.get(\"GNU.sparse.name\");\n    }\n\n    void fillStarSparseData(final Map<String, String> headers) {\n        starSparse = true;\n        if (headers.containsKey(\"SCHILY.realsize\")) {\n            realSize = Long.parseLong(headers.get(\"SCHILY.realsize\"));\n        }\n    }\n}\n\n",
      "fixed_full_code": "\npackage org.apache.commons.compress.archivers.tar;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Date;\nimport java.util.Locale;\nimport java.util.Map;\n\nimport org.apache.commons.compress.archivers.ArchiveEntry;\nimport org.apache.commons.compress.archivers.zip.ZipEncoding;\nimport org.apache.commons.compress.utils.ArchiveUtils;\n\n\n\npublic class TarArchiveEntry implements TarConstants, ArchiveEntry { private static final TarArchiveEntry[] EMPTY_TAR_ARCHIVE_ENTRIES = new TarArchiveEntry[0]; private String name = \"\"; private boolean preserveLeadingSlashes; private int mode; private long userId = 0; private long groupId = 0; private long size = 0; private long modTime; private boolean checkSumOK; private byte linkFlag; private String linkName = \"\"; private String magic = MAGIC_POSIX; private String version = VERSION_POSIX; private String userName; private String groupName = \"\"; private int devMajor = 0; private int devMinor = 0; private boolean isExtended; private long realSize; private boolean paxGNUSparse; private boolean starSparse; private final File file; public static final int MAX_NAMELEN = 31; public static final int DEFAULT_DIR_MODE = 040755; public static final int DEFAULT_FILE_MODE = 0100644; public static final int MILLIS_PER_SECOND = 1000; private TarArchiveEntry() {\n        String user = System.getProperty(\"user.name\", \"\");\n\n        if (user.length() > MAX_NAMELEN) {\n            user = user.substring(0, MAX_NAMELEN);\n        }\n\n        this.userName = user;\n        this.file = null;\n    }\n\n    \n    public TarArchiveEntry(final String name) {\n        this(name, false);\n    }\n\n    \n    public TarArchiveEntry(String name, final boolean preserveLeadingSlashes) {\n        this();\n\n        this.preserveLeadingSlashes = preserveLeadingSlashes;\n\n        name = normalizeFileName(name, preserveLeadingSlashes);\n        final boolean isDir = name.endsWith(\"/\");\n\n        this.name = name;\n        this.mode = isDir ? DEFAULT_DIR_MODE : DEFAULT_FILE_MODE;\n        this.linkFlag = isDir ? LF_DIR : LF_NORMAL;\n        this.modTime = new Date().getTime() / MILLIS_PER_SECOND;\n        this.userName = \"\";\n    }\n\n    \n    public TarArchiveEntry(final String name, final byte linkFlag) {\n        this(name, linkFlag, false);\n    }\n\n    \n    public TarArchiveEntry(final String name, final byte linkFlag, final boolean preserveLeadingSlashes) {\n        this(name, preserveLeadingSlashes);\n        this.linkFlag = linkFlag;\n        if (linkFlag == LF_GNUTYPE_LONGNAME) {\n            magic = MAGIC_GNU;\n            version = VERSION_GNU_SPACE;\n        }\n    }\n\n    \n    public TarArchiveEntry(final File file) {\n        this(file, file.getPath());\n    }\n\n    \n    public TarArchiveEntry(final File file, final String fileName) {\n        final String normalizedName = normalizeFileName(fileName, false);\n        this.file = file;\n\n        if (file.isDirectory()) {\n            this.mode = DEFAULT_DIR_MODE;\n            this.linkFlag = LF_DIR;\n\n            final int nameLength = normalizedName.length();\n            if (nameLength == 0 || normalizedName.charAt(nameLength - 1) != '/') {\n                this.name = normalizedName + \"/\";\n            } else {\n                this.name = normalizedName;\n            }\n        } else {\n            this.mode = DEFAULT_FILE_MODE;\n            this.linkFlag = LF_NORMAL;\n            this.size = file.length();\n            this.name = normalizedName;\n        }\n\n        this.modTime = file.lastModified() / MILLIS_PER_SECOND;\n        this.userName = \"\";\n    }\n\n    \n    public TarArchiveEntry(final byte[] headerBuf) {\n        this();\n        parseTarHeader(headerBuf);\n    }\n\n    \n    public TarArchiveEntry(final byte[] headerBuf, final ZipEncoding encoding) throws IOException {\n        this();\n        parseTarHeader(headerBuf, encoding);\n    }\n\n    \n    public boolean equals(final TarArchiveEntry it) {\n        return getName().equals(it.getName());\n    }\n\n    \n    @Override\n    public boolean equals(final Object it) {\n        if (it == null || getClass() != it.getClass()) {\n            return false;\n        }\n        return equals((TarArchiveEntry) it);\n    }\n\n    \n    @Override\n    public int hashCode() {\n        return getName().hashCode();\n    }\n\n    \n    public boolean isDescendent(final TarArchiveEntry desc) {\n        return desc.getName().startsWith(getName());\n    }\n\n    \n    @Override\n    public String getName() {\n        return name;\n    }\n\n    \n    public void setName(final String name) {\n        this.name = normalizeFileName(name, this.preserveLeadingSlashes);\n    }\n\n    \n    public void setMode(final int mode) {\n        this.mode = mode;\n    }\n\n    \n    public String getLinkName() {\n        return linkName;\n    }\n\n    \n    public void setLinkName(final String link) {\n        this.linkName = link;\n    }\n\n    \n    @Deprecated\n    public int getUserId() {\n        return (int) (userId & 0xffffffff);\n    }\n\n    \n    public void setUserId(final int userId) {\n        setUserId((long) userId);\n    }\n\n    \n    public long getLongUserId() {\n        return userId;\n    }\n\n    \n    public void setUserId(final long userId) {\n        this.userId = userId;\n    }\n\n    \n    @Deprecated\n    public int getGroupId() {\n        return (int) (groupId & 0xffffffff);\n    }\n\n    \n    public void setGroupId(final int groupId) {\n        setGroupId((long) groupId);\n    }\n\n    \n    public long getLongGroupId() {\n        return groupId;\n    }\n\n    \n    public void setGroupId(final long groupId) {\n        this.groupId = groupId;\n    }\n\n    \n    public String getUserName() {\n        return userName;\n    }\n\n    \n    public void setUserName(final String userName) {\n        this.userName = userName;\n    }\n\n    \n    public String getGroupName() {\n        return groupName;\n    }\n\n    \n    public void setGroupName(final String groupName) {\n        this.groupName = groupName;\n    }\n\n    \n    public void setIds(final int userId, final int groupId) {\n        setUserId(userId);\n        setGroupId(groupId);\n    }\n\n    \n    public void setNames(final String userName, final String groupName) {\n        setUserName(userName);\n        setGroupName(groupName);\n    }\n\n    \n    public void setModTime(final long time) {\n        modTime = time / MILLIS_PER_SECOND;\n    }\n\n    \n    public void setModTime(final Date time) {\n        modTime = time.getTime() / MILLIS_PER_SECOND;\n    }\n\n    \n    public Date getModTime() {\n        return new Date(modTime * MILLIS_PER_SECOND);\n    }\n\n    @Override\n    public Date getLastModifiedDate() {\n        return getModTime();\n    }\n\n    \n    public boolean isCheckSumOK() {\n        return checkSumOK;\n    }\n\n    \n    public File getFile() {\n        return file;\n    }\n\n    \n    public int getMode() {\n        return mode;\n    }\n\n    \n    @Override\n    public long getSize() {\n        return size;\n    }\n\n    \n    public void setSize(final long size) {\n        if (size < 0){\n            throw new IllegalArgumentException(\"Size is out of range: \"+size);\n        }\n        this.size = size;\n    }\n\n    \n    public int getDevMajor() {\n        return devMajor;\n    }\n\n    \n    public void setDevMajor(final int devNo) {\n        if (devNo < 0){\n            throw new IllegalArgumentException(\"Major device number is out of \"\n                                               + \"range: \" + devNo);\n        }\n        this.devMajor = devNo;\n    }\n\n    \n    public int getDevMinor() {\n        return devMinor;\n    }\n\n    \n    public void setDevMinor(final int devNo) {\n        if (devNo < 0){\n            throw new IllegalArgumentException(\"Minor device number is out of \"\n                                               + \"range: \" + devNo);\n        }\n        this.devMinor = devNo;\n    }\n\n    \n    public boolean isExtended() {\n        return isExtended;\n    }\n\n    \n    public long getRealSize() {\n        return realSize;\n    }\n\n    \n    public boolean isGNUSparse() {\n        return isOldGNUSparse() || isPaxGNUSparse();\n    }\n\n    \n    public boolean isOldGNUSparse() {\n        return linkFlag == LF_GNUTYPE_SPARSE;\n    }\n\n    \n    public boolean isPaxGNUSparse() {\n        return paxGNUSparse;\n    }\n\n    \n    public boolean isStarSparse() {\n        return starSparse;\n    }\n\n    \n    public boolean isGNULongLinkEntry() {\n        return linkFlag == LF_GNUTYPE_LONGLINK;\n    }\n\n    \n    public boolean isGNULongNameEntry() {\n        return linkFlag == LF_GNUTYPE_LONGNAME;\n    }\n\n    \n    public boolean isPaxHeader() {\n        return linkFlag == LF_PAX_EXTENDED_HEADER_LC\n            || linkFlag == LF_PAX_EXTENDED_HEADER_UC;\n    }\n\n    \n    public boolean isGlobalPaxHeader() {\n        return linkFlag == LF_PAX_GLOBAL_EXTENDED_HEADER;\n    }\n\n    \n    @Override\n    public boolean isDirectory() {\n        if (file != null) {\n            return file.isDirectory();\n        }\n\n        if (linkFlag == LF_DIR) {\n            return true;\n        }\n\n        if (!isPaxHeader() && !isGlobalPaxHeader() && getName().endsWith(\"/\")) {\n            return true;\n        }\n\n        return false;\n    }\n\n    \n    public boolean isFile() {\n        if (file != null) {\n            return file.isFile();\n        }\n        if (linkFlag == LF_OLDNORM || linkFlag == LF_NORMAL) {\n            return true;\n        }\n        return !getName().endsWith(\"/\");\n    }\n\n    \n    public boolean isSymbolicLink() {\n        return linkFlag == LF_SYMLINK;\n    }\n\n    \n    public boolean isLink() {\n        return linkFlag == LF_LINK;\n    }\n\n    \n    public boolean isCharacterDevice() {\n        return linkFlag == LF_CHR;\n    }\n\n    \n    public boolean isBlockDevice() {\n        return linkFlag == LF_BLK;\n    }\n\n    \n    public boolean isFIFO() {\n        return linkFlag == LF_FIFO;\n    }\n\n    \n    public boolean isSparse() {\n        return isGNUSparse() || isStarSparse();\n    }\n\n    \n    public TarArchiveEntry[] getDirectoryEntries() {\n        if (file == null || !file.isDirectory()) {\n            return EMPTY_TAR_ARCHIVE_ENTRIES;\n        }\n\n        final String[] list = file.list();\n        if (list == null) {\n            return EMPTY_TAR_ARCHIVE_ENTRIES;\n        }\n        final TarArchiveEntry[] result = new TarArchiveEntry[list.length];\n\n        for (int i = 0; i < result.length; ++i) {\n            result[i] = new TarArchiveEntry(new File(file, list[i]));\n        }\n\n        return result;\n    }\n\n    \n    public void writeEntryHeader(final byte[] outbuf) {\n        try {\n            writeEntryHeader(outbuf, TarUtils.DEFAULT_ENCODING, false);\n        } catch (final IOException ex) {\n            try {\n                writeEntryHeader(outbuf, TarUtils.FALLBACK_ENCODING, false);\n            } catch (final IOException ex2) {\n                \n                throw new RuntimeException(ex2);\n            }\n        }\n    }\n\n    \n    public void writeEntryHeader(final byte[] outbuf, final ZipEncoding encoding, final boolean starMode) throws IOException {\n        int offset = 0;\n\n        offset = TarUtils.formatNameBytes(name, outbuf, offset, NAMELEN,\n                                          encoding);\n        offset = writeEntryHeaderField(mode, outbuf, offset, MODELEN, starMode);\n        offset = writeEntryHeaderField(userId, outbuf, offset, UIDLEN,\n                                       starMode);\n        offset = writeEntryHeaderField(groupId, outbuf, offset, GIDLEN,\n                                       starMode);\n        offset = writeEntryHeaderField(size, outbuf, offset, SIZELEN, starMode);\n        offset = writeEntryHeaderField(modTime, outbuf, offset, MODTIMELEN,\n                                       starMode);\n\n        final int csOffset = offset;\n\n        for (int c = 0; c < CHKSUMLEN; ++c) {\n            outbuf[offset++] = (byte) ' ';\n        }\n\n        outbuf[offset++] = linkFlag;\n        offset = TarUtils.formatNameBytes(linkName, outbuf, offset, NAMELEN,\n                                          encoding);\n        offset = TarUtils.formatNameBytes(magic, outbuf, offset, MAGICLEN);\n        offset = TarUtils.formatNameBytes(version, outbuf, offset, VERSIONLEN);\n        offset = TarUtils.formatNameBytes(userName, outbuf, offset, UNAMELEN,\n                                          encoding);\n        offset = TarUtils.formatNameBytes(groupName, outbuf, offset, GNAMELEN,\n                                          encoding);\n        offset = writeEntryHeaderField(devMajor, outbuf, offset, DEVLEN,\n                                       starMode);\n        offset = writeEntryHeaderField(devMinor, outbuf, offset, DEVLEN,\n                                       starMode);\n\n        while (offset < outbuf.length) {\n            outbuf[offset++] = 0;\n        }\n\n        final long chk = TarUtils.computeCheckSum(outbuf);\n\n        TarUtils.formatCheckSumOctalBytes(chk, outbuf, csOffset, CHKSUMLEN);\n    }\n\n    private int writeEntryHeaderField(final long value, final byte[] outbuf, final int offset, final int length, final boolean starMode) {\n        if (!starMode && (value < 0\n                          || value >= 1l << 3 * (length - 1))) {\n            \n            \n            \n            return TarUtils.formatLongOctalBytes(0, outbuf, offset, length);\n        }\n        return TarUtils.formatLongOctalOrBinaryBytes(value, outbuf, offset,\n                                                     length);\n    }\n\n    \n    public void parseTarHeader(final byte[] header) {\n        try {\n            parseTarHeader(header, TarUtils.DEFAULT_ENCODING);\n        } catch (final IOException ex) {\n            try {\n                parseTarHeader(header, TarUtils.DEFAULT_ENCODING, true);\n            } catch (final IOException ex2) {\n                \n                throw new RuntimeException(ex2);\n            }\n        }\n    }\n\n    \n    public void parseTarHeader(final byte[] header, final ZipEncoding encoding) throws IOException {\n        parseTarHeader(header, encoding, false);\n    }\n\n    private void parseTarHeader(final byte[] header, final ZipEncoding encoding, final boolean oldStyle) throws IOException {\n        int offset = 0;\n\n        name = oldStyle ? TarUtils.parseName(header, offset, NAMELEN)\n            : TarUtils.parseName(header, offset, NAMELEN, encoding);\n        offset += NAMELEN;\n        mode = (int) TarUtils.parseOctalOrBinary(header, offset, MODELEN);\n        offset += MODELEN;\n        userId = (int) TarUtils.parseOctalOrBinary(header, offset, UIDLEN);\n        offset += UIDLEN;\n        groupId = (int) TarUtils.parseOctalOrBinary(header, offset, GIDLEN);\n        offset += GIDLEN;\n        size = TarUtils.parseOctalOrBinary(header, offset, SIZELEN);\n        offset += SIZELEN;\n        modTime = TarUtils.parseOctalOrBinary(header, offset, MODTIMELEN);\n        offset += MODTIMELEN;\n        checkSumOK = TarUtils.verifyCheckSum(header);\n        offset += CHKSUMLEN;\n        linkFlag = header[offset++];\n        linkName = oldStyle ? TarUtils.parseName(header, offset, NAMELEN)\n            : TarUtils.parseName(header, offset, NAMELEN, encoding);\n        offset += NAMELEN;\n        magic = TarUtils.parseName(header, offset, MAGICLEN);\n        offset += MAGICLEN;\n        version = TarUtils.parseName(header, offset, VERSIONLEN);\n        offset += VERSIONLEN;\n        userName = oldStyle ? TarUtils.parseName(header, offset, UNAMELEN)\n            : TarUtils.parseName(header, offset, UNAMELEN, encoding);\n        offset += UNAMELEN;\n        groupName = oldStyle ? TarUtils.parseName(header, offset, GNAMELEN)\n            : TarUtils.parseName(header, offset, GNAMELEN, encoding);\n        offset += GNAMELEN;\n        devMajor = (int) TarUtils.parseOctalOrBinary(header, offset, DEVLEN);\n        offset += DEVLEN;\n        devMinor = (int) TarUtils.parseOctalOrBinary(header, offset, DEVLEN);\n        offset += DEVLEN;\n\n        final int type = evaluateType(header);\n        switch (type) {\n        case FORMAT_OLDGNU: {\n            offset += ATIMELEN_GNU;\n            offset += CTIMELEN_GNU;\n            offset += OFFSETLEN_GNU;\n            offset += LONGNAMESLEN_GNU;\n            offset += PAD2LEN_GNU;\n            offset += SPARSELEN_GNU;\n            isExtended = TarUtils.parseBoolean(header, offset);\n            offset += ISEXTENDEDLEN_GNU;\n            realSize = TarUtils.parseOctal(header, offset, REALSIZELEN_GNU);\n            offset += REALSIZELEN_GNU;\n            break;\n        }\n        case FORMAT_XSTAR: {\n            final String xstarPrefix = oldStyle\n                ? TarUtils.parseName(header, offset, PREFIXLEN_XSTAR)\n                : TarUtils.parseName(header, offset, PREFIXLEN_XSTAR, encoding);\n            if (xstarPrefix.length() > 0) {\n                name = xstarPrefix + \"/\" + name;\n            }\n            break;\n        }\n        case FORMAT_POSIX:\n        default: {\n            final String prefix = oldStyle\n                ? TarUtils.parseName(header, offset, PREFIXLEN)\n                : TarUtils.parseName(header, offset, PREFIXLEN, encoding);\n            \n            \n            if (isDirectory() && !name.endsWith(\"/\")){\n                name = name + \"/\";\n            }\n            if (prefix.length() > 0){\n                name = prefix + \"/\" + name;\n            }\n        }\n        }\n    }\n\n    \n    private static String normalizeFileName(String fileName, final boolean preserveLeadingSlashes) {\n        final String osname = System.getProperty(\"os.name\").toLowerCase(Locale.ENGLISH);\n\n        if (osname != null) {\n\n            \n            \n\n            if (osname.startsWith(\"windows\")) {\n                if (fileName.length() > 2) {\n                    final char ch1 = fileName.charAt(0);\n                    final char ch2 = fileName.charAt(1);\n\n                    if (ch2 == ':'\n                        && (ch1 >= 'a' && ch1 <= 'z'\n                            || ch1 >= 'A' && ch1 <= 'Z')) {\n                        fileName = fileName.substring(2);\n                    }\n                }\n            } else if (osname.contains(\"netware\")) {\n                final int colon = fileName.indexOf(':');\n                if (colon != -1) {\n                    fileName = fileName.substring(colon + 1);\n                }\n            }\n        }\n\n        fileName = fileName.replace(File.separatorChar, '/');\n\n        \n        \n        \n        while (!preserveLeadingSlashes && fileName.startsWith(\"/\")) {\n            fileName = fileName.substring(1);\n        }\n        return fileName;\n    }\n\n    \n    private int evaluateType(final byte[] header) {\n        if (ArchiveUtils.matchAsciiBuffer(MAGIC_GNU, header, MAGIC_OFFSET, MAGICLEN)) {\n            return FORMAT_OLDGNU;\n        }\n        if (ArchiveUtils.matchAsciiBuffer(MAGIC_POSIX, header, MAGIC_OFFSET, MAGICLEN)) {\n            if (ArchiveUtils.matchAsciiBuffer(MAGIC_XSTAR, header, XSTAR_MAGIC_OFFSET,\n                                              XSTAR_MAGIC_LEN)) {\n                return FORMAT_XSTAR;\n            }\n            return FORMAT_POSIX;\n        }\n        return 0;\n    }\n\n    void fillGNUSparse0xData(final Map<String, String> headers) {\n        paxGNUSparse = true;\n        realSize = Integer.parseInt(headers.get(\"GNU.sparse.size\"));\n        if (headers.containsKey(\"GNU.sparse.name\")) {\n            \n            name = headers.get(\"GNU.sparse.name\");\n        }\n    }\n\n    void fillGNUSparse1xData(final Map<String, String> headers) {\n        paxGNUSparse = true;\n        realSize = Integer.parseInt(headers.get(\"GNU.sparse.realsize\"));\n        name = headers.get(\"GNU.sparse.name\");\n    }\n\n    void fillStarSparseData(final Map<String, String> headers) {\n        starSparse = true;\n        if (headers.containsKey(\"SCHILY.realsize\")) {\n            realSize = Long.parseLong(headers.get(\"SCHILY.realsize\"));\n        }\n    }\n}\n\n",
      "buggy_signatures": [
        "public TarArchiveEntry(final String name)",
        "public TarArchiveEntry(String name, final boolean preserveLeadingSlashes)",
        "public TarArchiveEntry(final String name, final byte linkFlag)",
        "public TarArchiveEntry(final String name, final byte linkFlag, final boolean preserveLeadingSlashes)",
        "public TarArchiveEntry(final File file)",
        "public TarArchiveEntry(final File file, final String fileName)",
        "public TarArchiveEntry(final byte[] headerBuf)",
        "public TarArchiveEntry(final byte[] headerBuf, final ZipEncoding encoding) throws IOException",
        "public boolean equals(final TarArchiveEntry it)",
        "public boolean equals(final Object it)",
        "public int hashCode()",
        "public boolean isDescendent(final TarArchiveEntry desc)",
        "public String getName()",
        "public void setName(final String name)",
        "public void setMode(final int mode)",
        "public String getLinkName()",
        "public void setLinkName(final String link)",
        "public int getUserId()",
        "public void setUserId(final int userId)",
        "public long getLongUserId()",
        "public void setUserId(final long userId)",
        "public int getGroupId()",
        "public void setGroupId(final int groupId)",
        "public long getLongGroupId()",
        "public void setGroupId(final long groupId)",
        "public String getUserName()",
        "public void setUserName(final String userName)",
        "public String getGroupName()",
        "public void setGroupName(final String groupName)",
        "public void setIds(final int userId, final int groupId)",
        "public void setNames(final String userName, final String groupName)",
        "public void setModTime(final long time)",
        "public void setModTime(final Date time)",
        "public Date getModTime()",
        "public Date getLastModifiedDate()",
        "public boolean isCheckSumOK()",
        "public File getFile()",
        "public int getMode()",
        "public long getSize()",
        "public void setSize(final long size)",
        "public int getDevMajor()",
        "public void setDevMajor(final int devNo)",
        "public int getDevMinor()",
        "public void setDevMinor(final int devNo)",
        "public boolean isExtended()",
        "public long getRealSize()",
        "public boolean isGNUSparse()",
        "public boolean isOldGNUSparse()",
        "public boolean isPaxGNUSparse()",
        "public boolean isStarSparse()",
        "public boolean isGNULongLinkEntry()",
        "public boolean isGNULongNameEntry()",
        "public boolean isPaxHeader()",
        "public boolean isGlobalPaxHeader()",
        "public boolean isDirectory()",
        "public boolean isFile()",
        "public boolean isSymbolicLink()",
        "public boolean isLink()",
        "public boolean isCharacterDevice()",
        "public boolean isBlockDevice()",
        "public boolean isFIFO()",
        "public boolean isSparse()",
        "public TarArchiveEntry[] getDirectoryEntries()",
        "public void writeEntryHeader(final byte[] outbuf)",
        "public void writeEntryHeader(final byte[] outbuf, final ZipEncoding encoding, final boolean starMode) throws IOException",
        "private int writeEntryHeaderField(final long value, final byte[] outbuf, final int offset, final int length, final boolean starMode)",
        "public void parseTarHeader(final byte[] header)",
        "public void parseTarHeader(final byte[] header, final ZipEncoding encoding) throws IOException",
        "private void parseTarHeader(final byte[] header, final ZipEncoding encoding, final boolean oldStyle) throws IOException",
        "private static String normalizeFileName(String fileName, final boolean preserveLeadingSlashes)",
        "private int evaluateType(final byte[] header)"
      ],
      "fixed_signatures": [
        "public TarArchiveEntry(final String name)",
        "public TarArchiveEntry(String name, final boolean preserveLeadingSlashes)",
        "public TarArchiveEntry(final String name, final byte linkFlag)",
        "public TarArchiveEntry(final String name, final byte linkFlag, final boolean preserveLeadingSlashes)",
        "public TarArchiveEntry(final File file)",
        "public TarArchiveEntry(final File file, final String fileName)",
        "public TarArchiveEntry(final byte[] headerBuf)",
        "public TarArchiveEntry(final byte[] headerBuf, final ZipEncoding encoding) throws IOException",
        "public boolean equals(final TarArchiveEntry it)",
        "public boolean equals(final Object it)",
        "public int hashCode()",
        "public boolean isDescendent(final TarArchiveEntry desc)",
        "public String getName()",
        "public void setName(final String name)",
        "public void setMode(final int mode)",
        "public String getLinkName()",
        "public void setLinkName(final String link)",
        "public int getUserId()",
        "public void setUserId(final int userId)",
        "public long getLongUserId()",
        "public void setUserId(final long userId)",
        "public int getGroupId()",
        "public void setGroupId(final int groupId)",
        "public long getLongGroupId()",
        "public void setGroupId(final long groupId)",
        "public String getUserName()",
        "public void setUserName(final String userName)",
        "public String getGroupName()",
        "public void setGroupName(final String groupName)",
        "public void setIds(final int userId, final int groupId)",
        "public void setNames(final String userName, final String groupName)",
        "public void setModTime(final long time)",
        "public void setModTime(final Date time)",
        "public Date getModTime()",
        "public Date getLastModifiedDate()",
        "public boolean isCheckSumOK()",
        "public File getFile()",
        "public int getMode()",
        "public long getSize()",
        "public void setSize(final long size)",
        "public int getDevMajor()",
        "public void setDevMajor(final int devNo)",
        "public int getDevMinor()",
        "public void setDevMinor(final int devNo)",
        "public boolean isExtended()",
        "public long getRealSize()",
        "public boolean isGNUSparse()",
        "public boolean isOldGNUSparse()",
        "public boolean isPaxGNUSparse()",
        "public boolean isStarSparse()",
        "public boolean isGNULongLinkEntry()",
        "public boolean isGNULongNameEntry()",
        "public boolean isPaxHeader()",
        "public boolean isGlobalPaxHeader()",
        "public boolean isDirectory()",
        "public boolean isFile()",
        "public boolean isSymbolicLink()",
        "public boolean isLink()",
        "public boolean isCharacterDevice()",
        "public boolean isBlockDevice()",
        "public boolean isFIFO()",
        "public boolean isSparse()",
        "public TarArchiveEntry[] getDirectoryEntries()",
        "public void writeEntryHeader(final byte[] outbuf)",
        "public void writeEntryHeader(final byte[] outbuf, final ZipEncoding encoding, final boolean starMode) throws IOException",
        "private int writeEntryHeaderField(final long value, final byte[] outbuf, final int offset, final int length, final boolean starMode)",
        "public void parseTarHeader(final byte[] header)",
        "public void parseTarHeader(final byte[] header, final ZipEncoding encoding) throws IOException",
        "private void parseTarHeader(final byte[] header, final ZipEncoding encoding, final boolean oldStyle) throws IOException",
        "private static String normalizeFileName(String fileName, final boolean preserveLeadingSlashes)",
        "private int evaluateType(final byte[] header)"
      ],
      "methods": [
        {
          "buggy_method": "  public boolean isDirectory() {\n  if (file != null) {\n  return file.isDirectory();\n  }\n\n  if (linkFlag == LF_DIR) {\n  return true;\n  }\n\n  if (getName().endsWith(\"/\")) {\n  return true;\n  }\n\n  return false;\n  }",
          "fixed_method": "  public boolean isDirectory() {\n  if (file != null) {\n  return file.isDirectory();\n  }\n\n  if (linkFlag == LF_DIR) {\n  return true;\n  }\n\n  if (!isPaxHeader() && !isGlobalPaxHeader() && getName().endsWith(\"/\")) {\n  return true;\n  }\n\n  return false;\n  }",
          "diff": [
            "@@ -856,7 +856,7 @@",
            "             return true;\n",
            "         }\n",
            " \n",
            "-        if (getName().endsWith(\"/\")) {\n",
            "+        if (!isPaxHeader() && !isGlobalPaxHeader() && getName().endsWith(\"/\")) {\n",
            "             return true;\n",
            "         }\n",
            " \n"
          ],
          "changed_lines": 2
        }
      ]
    }
  ]
}
