{
  "bug_id": "10",
  "failed_tests": {
    "org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest": [
      {
        "methodName": "testReadWinZipArchive",
        "error": "junit.framework.AssertionFailedError",
        "message": "InputStream is null",
        "fail_line": "            assertCanRead(zf, EURO_FOR_DOLLAR_TXT);",
        "test_source": "  public void testReadWinZipArchive() throws IOException, URISyntaxException {\n  URL zip = getClass().getResource(\"/utf8-winzip-test.zip\");\n  File archive = new File(new URI(zip.toString()));\n  ZipFile zf = null;\n  try {\n  zf = new ZipFile(archive, null, true);\n  assertCanRead(zf, ASCII_TXT);\n  assertCanRead(zf, EURO_FOR_DOLLAR_TXT);\n  assertCanRead(zf, OIL_BARREL_TXT);\n  } finally {\n  ZipFile.closeQuietly(zf);\n  }\n  }",
        "stack": [
          "UTF8ZipFilesTest.assertCanRead line 144, UTF8ZipFilesTest.testReadWinZipArchive line 133"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/compress/archivers/zip/ZipFile.java",
      "buggy_full_code": "\npackage org.apache.commons.compress.archivers.zip;\n\nimport java.io.EOFException;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.RandomAccessFile;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\nimport java.util.zip.Inflater;\nimport java.util.zip.InflaterInputStream;\nimport java.util.zip.ZipException;\n\nimport static org.apache.commons.compress.archivers.zip.ZipConstants.DWORD; import static org.apache.commons.compress.archivers.zip.ZipConstants.SHORT; import static org.apache.commons.compress.archivers.zip.ZipConstants.WORD; import static org.apache.commons.compress.archivers.zip.ZipConstants.ZIP64_MAGIC; import static org.apache.commons.compress.archivers.zip.ZipConstants.ZIP64_MAGIC_SHORT; public class ZipFile { private static final int HASH_SIZE = 509; static final int NIBLET_MASK = 0x0f; static final int BYTE_SHIFT = 8; private static final int POS_0 = 0; private static final int POS_1 = 1; private static final int POS_2 = 2; private static final int POS_3 = 3; private final Map<ZipArchiveEntry, OffsetEntry> entries = new LinkedHashMap<ZipArchiveEntry, OffsetEntry>(HASH_SIZE); private final Map<String, ZipArchiveEntry> nameMap = new HashMap<String, ZipArchiveEntry>(HASH_SIZE); private static final class OffsetEntry {\n        private long headerOffset = -1; private long dataOffset = -1; } private final String encoding; private final ZipEncoding zipEncoding; private final String archiveName; private final RandomAccessFile archive; private final boolean useUnicodeExtraFields; private boolean closed; public ZipFile(File f) throws IOException {\n        this(f, ZipEncodingHelper.UTF8);\n    }\n\n    \n    public ZipFile(String name) throws IOException {\n        this(new File(name), ZipEncodingHelper.UTF8);\n    }\n\n    \n    public ZipFile(String name, String encoding) throws IOException {\n        this(new File(name), encoding, true);\n    }\n\n    \n    public ZipFile(File f, String encoding) throws IOException {\n        this(f, encoding, true);\n    }\n\n    \n    public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException {\n        this.archiveName = f.getAbsolutePath();\n        this.encoding = encoding;\n        this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n        this.useUnicodeExtraFields = useUnicodeExtraFields;\n        archive = new RandomAccessFile(f, \"r\");\n        boolean success = false;\n        try {\n            Map<ZipArchiveEntry, NameAndComment> entriesWithoutUTF8Flag =\n                populateFromCentralDirectory();\n            resolveLocalFileHeaderData(entriesWithoutUTF8Flag);\n            success = true;\n        } finally {\n            if (!success) {\n                try {\n                    closed = true;\n                    archive.close();\n                } catch (IOException e2) { \n                    \n                }\n            }\n        }\n    }\n\n    \n    public String getEncoding() {\n        return encoding;\n    }\n\n    \n    public void close() throws IOException {\n        \n        \n        \n        closed = true;\n\n        archive.close();\n    }\n\n    \n    public static void closeQuietly(ZipFile zipfile) {\n        if (zipfile != null) {\n            try {\n                zipfile.close();\n            } catch (IOException e) { \n                \n            }\n        }\n    }\n\n    \n    public Enumeration<ZipArchiveEntry> getEntries() {\n        return Collections.enumeration(entries.keySet());\n    }\n\n    \n    public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder() {\n        ZipArchiveEntry[] allEntries =\n            entries.keySet().toArray(new ZipArchiveEntry[0]);\n        Arrays.sort(allEntries, OFFSET_COMPARATOR);\n        return Collections.enumeration(Arrays.asList(allEntries));\n    }\n\n    \n    public ZipArchiveEntry getEntry(String name) {\n        return nameMap.get(name);\n    }\n\n    \n    public boolean canReadEntryData(ZipArchiveEntry ze) {\n        return ZipUtil.canHandleEntryData(ze);\n    }\n\n    \n    public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException {\n        OffsetEntry offsetEntry = entries.get(ze);\n        if (offsetEntry == null) {\n            return null;\n        }\n        ZipUtil.checkRequestedFeatures(ze);\n        long start = offsetEntry.dataOffset;\n        BoundedInputStream bis =\n            new BoundedInputStream(start, ze.getCompressedSize());\n        switch (ze.getMethod()) {\n            case ZipArchiveEntry.STORED:\n                return bis;\n            case ZipArchiveEntry.DEFLATED:\n                bis.addDummy();\n                final Inflater inflater = new Inflater(true);\n                return new InflaterInputStream(bis, inflater) {\n                    @Override\n                    public void close() throws IOException {\n                        super.close();\n                        inflater.end();\n                    }\n                };\n            default:\n                throw new ZipException(\"Found unsupported compression method \"\n                                       + ze.getMethod());\n        }\n    }\n\n    \n    @Override\n    protected void finalize() throws Throwable {\n        try {\n            if (!closed) {\n                System.err.println(\"Cleaning up unclosed ZipFile for archive \"\n                                   + archiveName);\n                close();\n            }\n        } finally {\n            super.finalize();\n        }\n    }\n\n    \n    private static final int CFH_LEN = SHORT + SHORT + SHORT + SHORT + SHORT + SHORT + WORD + WORD + WORD + SHORT + SHORT + SHORT + SHORT + SHORT + WORD + WORD; private static final long CFH_SIG = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG); private Map<ZipArchiveEntry, NameAndComment> populateFromCentralDirectory() throws IOException {\n        HashMap<ZipArchiveEntry, NameAndComment> noUTF8Flag =\n            new HashMap<ZipArchiveEntry, NameAndComment>();\n\n        positionAtCentralDirectory();\n\n        byte[] signatureBytes = new byte[WORD];\n        archive.readFully(signatureBytes);\n        long sig = ZipLong.getValue(signatureBytes);\n\n        if (sig != CFH_SIG && startsWithLocalFileHeader()) {\n            throw new IOException(\"central directory is empty, can't expand\"\n                                  + \" corrupt archive.\");\n        }\n\n        while (sig == CFH_SIG) {\n            readCentralDirectoryEntry(noUTF8Flag);\n            archive.readFully(signatureBytes);\n            sig = ZipLong.getValue(signatureBytes);\n        }\n        return noUTF8Flag;\n    }\n\n    \n    private void readCentralDirectoryEntry(Map<ZipArchiveEntry, NameAndComment> noUTF8Flag) throws IOException {\n        byte[] cfh = new byte[CFH_LEN];\n\n        archive.readFully(cfh);\n        int off = 0;\n        ZipArchiveEntry ze = new ZipArchiveEntry();\n\n        int versionMadeBy = ZipShort.getValue(cfh, off);\n        off += SHORT;\n        ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK);\n\n        off += SHORT; \n\n        final GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(cfh, off);\n        final boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();\n        final ZipEncoding entryEncoding =\n            hasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n        ze.setGeneralPurposeBit(gpFlag);\n\n        off += SHORT;\n\n        ze.setMethod(ZipShort.getValue(cfh, off));\n        off += SHORT;\n\n        long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off));\n        ze.setTime(time);\n        off += WORD;\n\n        ze.setCrc(ZipLong.getValue(cfh, off));\n        off += WORD;\n\n        ze.setCompressedSize(ZipLong.getValue(cfh, off));\n        off += WORD;\n\n        ze.setSize(ZipLong.getValue(cfh, off));\n        off += WORD;\n\n        int fileNameLen = ZipShort.getValue(cfh, off);\n        off += SHORT;\n\n        int extraLen = ZipShort.getValue(cfh, off);\n        off += SHORT;\n\n        int commentLen = ZipShort.getValue(cfh, off);\n        off += SHORT;\n\n        int diskStart = ZipShort.getValue(cfh, off);\n        off += SHORT;\n\n        ze.setInternalAttributes(ZipShort.getValue(cfh, off));\n        off += SHORT;\n\n        ze.setExternalAttributes(ZipLong.getValue(cfh, off));\n        off += WORD;\n\n        byte[] fileName = new byte[fileNameLen];\n        archive.readFully(fileName);\n        ze.setName(entryEncoding.decode(fileName), fileName);\n\n        \n        OffsetEntry offset = new OffsetEntry();\n        offset.headerOffset = ZipLong.getValue(cfh, off);\n        \n        entries.put(ze, offset);\n\n        nameMap.put(ze.getName(), ze);\n\n        byte[] cdExtraData = new byte[extraLen];\n        archive.readFully(cdExtraData);\n        ze.setCentralDirectoryExtra(cdExtraData);\n\n        setSizesAndOffsetFromZip64Extra(ze, offset, diskStart);\n\n        byte[] comment = new byte[commentLen];\n        archive.readFully(comment);\n        ze.setComment(entryEncoding.decode(comment));\n\n        if (!hasUTF8Flag && useUnicodeExtraFields) {\n            noUTF8Flag.put(ze, new NameAndComment(fileName, comment));\n        }\n    }\n\n    \n    private void setSizesAndOffsetFromZip64Extra(ZipArchiveEntry ze, OffsetEntry offset, int diskStart) throws IOException {\n        Zip64ExtendedInformationExtraField z64 =\n            (Zip64ExtendedInformationExtraField)\n            ze.getExtraField(Zip64ExtendedInformationExtraField.HEADER_ID);\n        if (z64 != null) {\n            boolean hasUncompressedSize = ze.getSize() == ZIP64_MAGIC;\n            boolean hasCompressedSize = ze.getCompressedSize() == ZIP64_MAGIC;\n            boolean hasRelativeHeaderOffset =\n                offset.headerOffset == ZIP64_MAGIC;\n            z64.reparseCentralDirectoryData(hasUncompressedSize,\n                                            hasCompressedSize,\n                                            hasRelativeHeaderOffset,\n                                            diskStart == ZIP64_MAGIC_SHORT);\n\n            if (hasUncompressedSize) {\n                ze.setSize(z64.getSize().getLongValue());\n            } else if (hasCompressedSize) {\n                z64.setSize(new ZipEightByteInteger(ze.getSize()));\n            }\n\n            if (hasCompressedSize) {\n                ze.setCompressedSize(z64.getCompressedSize().getLongValue());\n            } else if (hasUncompressedSize) {\n                z64.setCompressedSize(new ZipEightByteInteger(ze.getCompressedSize()));\n            }\n\n            if (hasRelativeHeaderOffset) {\n                offset.headerOffset =\n                    z64.getRelativeHeaderOffset().getLongValue();\n            }\n        }\n    }\n\n    \n    private static final int MIN_EOCD_SIZE = WORD + SHORT + SHORT + SHORT + SHORT + WORD + WORD + SHORT; private static final int MAX_EOCD_SIZE = MIN_EOCD_SIZE + ZIP64_MAGIC_SHORT; private static final int CFD_LOCATOR_OFFSET = WORD + SHORT + SHORT + SHORT + SHORT + WORD; private static final int ZIP64_EOCDL_LENGTH = WORD + WORD + DWORD + WORD; private static final int ZIP64_EOCDL_LOCATOR_OFFSET = WORD + WORD; private static final int ZIP64_EOCD_CFD_LOCATOR_OFFSET = WORD + DWORD + SHORT + SHORT + WORD + WORD + DWORD + DWORD + DWORD; private void positionAtCentralDirectory() throws IOException {\n        boolean found = tryToLocateSignature(MIN_EOCD_SIZE + ZIP64_EOCDL_LENGTH,\n                                             MAX_EOCD_SIZE + ZIP64_EOCDL_LENGTH,\n                                             ZipArchiveOutputStream\n                                             .ZIP64_EOCD_LOC_SIG);\n        if (!found) {\n            \n            positionAtCentralDirectory32();\n        } else {\n            positionAtCentralDirectory64();\n        }\n    }\n\n    \n    private void positionAtCentralDirectory64() throws IOException {\n        skipBytes(ZIP64_EOCDL_LOCATOR_OFFSET);\n        byte[] zip64EocdOffset = new byte[DWORD];\n        archive.readFully(zip64EocdOffset);\n        archive.seek(ZipEightByteInteger.getLongValue(zip64EocdOffset));\n        byte[] sig = new byte[WORD];\n        archive.readFully(sig);\n        if (sig[POS_0] != ZipArchiveOutputStream.ZIP64_EOCD_SIG[POS_0]\n            || sig[POS_1] != ZipArchiveOutputStream.ZIP64_EOCD_SIG[POS_1]\n            || sig[POS_2] != ZipArchiveOutputStream.ZIP64_EOCD_SIG[POS_2]\n            || sig[POS_3] != ZipArchiveOutputStream.ZIP64_EOCD_SIG[POS_3]\n            ) {\n            throw new ZipException(\"archive's ZIP64 end of central \"\n                                   + \"directory locator is corrupt.\");\n        }\n        skipBytes(ZIP64_EOCD_CFD_LOCATOR_OFFSET\n                  - WORD );\n        byte[] cfdOffset = new byte[DWORD];\n        archive.readFully(cfdOffset);\n        archive.seek(ZipEightByteInteger.getLongValue(cfdOffset));\n    }\n\n    \n    private void positionAtCentralDirectory32() throws IOException {\n        boolean found = tryToLocateSignature(MIN_EOCD_SIZE, MAX_EOCD_SIZE,\n                                             ZipArchiveOutputStream.EOCD_SIG);\n        if (!found) {\n            throw new ZipException(\"archive is not a ZIP archive\");\n        }\n        skipBytes(CFD_LOCATOR_OFFSET);\n        byte[] cfdOffset = new byte[WORD];\n        archive.readFully(cfdOffset);\n        archive.seek(ZipLong.getValue(cfdOffset));\n    }\n\n    \n    private boolean tryToLocateSignature(long minDistanceFromEnd, long maxDistanceFromEnd, byte[] sig) throws IOException {\n        boolean found = false;\n        long off = archive.length() - minDistanceFromEnd;\n        final long stopSearching =\n            Math.max(0L, archive.length() - maxDistanceFromEnd);\n        if (off >= 0) {\n            for (; off >= stopSearching; off--) {\n                archive.seek(off);\n                int curr = archive.read();\n                if (curr == -1) {\n                    break;\n                }\n                if (curr == sig[POS_0]) {\n                    curr = archive.read();\n                    if (curr == sig[POS_1]) {\n                        curr = archive.read();\n                        if (curr == sig[POS_2]) {\n                            curr = archive.read();\n                            if (curr == sig[POS_3]) {\n                                found = true;\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if (found) {\n            archive.seek(off);\n        }\n        return found;\n    }\n\n     \n    private void skipBytes(final int count) throws IOException {\n        int totalSkipped = 0;\n        while (totalSkipped < count) {\n            int skippedNow = archive.skipBytes(count - totalSkipped);\n            if (skippedNow <= 0) {\n                throw new EOFException();\n            }\n            totalSkipped += skippedNow;\n        }\n    }\n\n    \n    private static final long LFH_OFFSET_FOR_FILENAME_LENGTH = WORD + SHORT + SHORT + SHORT + SHORT + SHORT + WORD + WORD + WORD; private void resolveLocalFileHeaderData(Map<ZipArchiveEntry, NameAndComment> entriesWithoutUTF8Flag) throws IOException {\n        \n        \n        \n        \n        for (ZipArchiveEntry ze : entries.keySet()) {\n            OffsetEntry offsetEntry = entries.get(ze);\n            long offset = offsetEntry.headerOffset;\n            archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH);\n            byte[] b = new byte[SHORT];\n            archive.readFully(b);\n            int fileNameLen = ZipShort.getValue(b);\n            archive.readFully(b);\n            int extraFieldLen = ZipShort.getValue(b);\n            int lenToSkip = fileNameLen;\n            while (lenToSkip > 0) {\n                int skipped = archive.skipBytes(lenToSkip);\n                if (skipped <= 0) {\n                    throw new RuntimeException(\"failed to skip file name in\"\n                                               + \" local file header\");\n                }\n                lenToSkip -= skipped;\n            }\n            byte[] localExtraData = new byte[extraFieldLen];\n            archive.readFully(localExtraData);\n            ze.setExtra(localExtraData);\n            offsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH\n                + SHORT + SHORT + fileNameLen + extraFieldLen;\n\n            if (entriesWithoutUTF8Flag.containsKey(ze)) {\n                String orig = ze.getName();\n                NameAndComment nc = entriesWithoutUTF8Flag.get(ze);\n                ZipUtil.setNameAndCommentFromExtraFields(ze, nc.name,\n                                                         nc.comment);\n                if (!orig.equals(ze.getName())) {\n                    nameMap.remove(orig);\n                    nameMap.put(ze.getName(), ze);\n                }\n            }\n        }\n    }\n\n    \n    private boolean startsWithLocalFileHeader() throws IOException {\n        archive.seek(0);\n        final byte[] start = new byte[WORD];\n        archive.readFully(start);\n        for (int i = 0; i < start.length; i++) {\n            if (start[i] != ZipArchiveOutputStream.LFH_SIG[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    private class BoundedInputStream extends InputStream { private long remaining; private long loc; private boolean addDummyByte = false; BoundedInputStream(long start, long remaining) {\n            this.remaining = remaining;\n            loc = start;\n        }\n\n        @Override\n        public int read() throws IOException {\n            if (remaining-- <= 0) {\n                if (addDummyByte) {\n                    addDummyByte = false;\n                    return 0;\n                }\n                return -1;\n            }\n            synchronized (archive) {\n                archive.seek(loc++);\n                return archive.read();\n            }\n        }\n\n        @Override\n        public int read(byte[] b, int off, int len) throws IOException {\n            if (remaining <= 0) {\n                if (addDummyByte) {\n                    addDummyByte = false;\n                    b[off] = 0;\n                    return 1;\n                }\n                return -1;\n            }\n\n            if (len <= 0) {\n                return 0;\n            }\n\n            if (len > remaining) {\n                len = (int) remaining;\n            }\n            int ret = -1;\n            synchronized (archive) {\n                archive.seek(loc);\n                ret = archive.read(b, off, len);\n            }\n            if (ret > 0) {\n                loc += ret;\n                remaining -= ret;\n            }\n            return ret;\n        }\n\n        \n        void addDummy() {\n            addDummyByte = true;\n        }\n    }\n\n    private static final class NameAndComment { private final byte[] name; private final byte[] comment; private NameAndComment(byte[] name, byte[] comment) {\n            this.name = name;\n            this.comment = comment;\n        }\n    }\n\n    \n    private final Comparator<ZipArchiveEntry> OFFSET_COMPARATOR = new Comparator<ZipArchiveEntry>() {\n        public int compare(ZipArchiveEntry e1, ZipArchiveEntry e2) {\n            if (e1 == e2)\n                return 0;\n\n            OffsetEntry off1 = entries.get(e1);\n            OffsetEntry off2 = entries.get(e2);\n            if (off1 == null) {\n                return 1;\n            }\n            if (off2 == null) {\n                return -1;\n            }\n            long val = (off1.headerOffset - off2.headerOffset);\n            return val == 0 ? 0 : val < 0 ? -1 : +1;\n        }\n    };\n}\n",
      "fixed_full_code": "\npackage org.apache.commons.compress.archivers.zip;\n\nimport java.io.EOFException;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.RandomAccessFile;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\nimport java.util.zip.Inflater;\nimport java.util.zip.InflaterInputStream;\nimport java.util.zip.ZipException;\n\nimport static org.apache.commons.compress.archivers.zip.ZipConstants.DWORD; import static org.apache.commons.compress.archivers.zip.ZipConstants.SHORT; import static org.apache.commons.compress.archivers.zip.ZipConstants.WORD; import static org.apache.commons.compress.archivers.zip.ZipConstants.ZIP64_MAGIC; import static org.apache.commons.compress.archivers.zip.ZipConstants.ZIP64_MAGIC_SHORT; public class ZipFile { private static final int HASH_SIZE = 509; static final int NIBLET_MASK = 0x0f; static final int BYTE_SHIFT = 8; private static final int POS_0 = 0; private static final int POS_1 = 1; private static final int POS_2 = 2; private static final int POS_3 = 3; private final Map<ZipArchiveEntry, OffsetEntry> entries = new LinkedHashMap<ZipArchiveEntry, OffsetEntry>(HASH_SIZE); private final Map<String, ZipArchiveEntry> nameMap = new HashMap<String, ZipArchiveEntry>(HASH_SIZE); private static final class OffsetEntry {\n        private long headerOffset = -1; private long dataOffset = -1; } private final String encoding; private final ZipEncoding zipEncoding; private final String archiveName; private final RandomAccessFile archive; private final boolean useUnicodeExtraFields; private boolean closed; public ZipFile(File f) throws IOException {\n        this(f, ZipEncodingHelper.UTF8);\n    }\n\n    \n    public ZipFile(String name) throws IOException {\n        this(new File(name), ZipEncodingHelper.UTF8);\n    }\n\n    \n    public ZipFile(String name, String encoding) throws IOException {\n        this(new File(name), encoding, true);\n    }\n\n    \n    public ZipFile(File f, String encoding) throws IOException {\n        this(f, encoding, true);\n    }\n\n    \n    public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException {\n        this.archiveName = f.getAbsolutePath();\n        this.encoding = encoding;\n        this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n        this.useUnicodeExtraFields = useUnicodeExtraFields;\n        archive = new RandomAccessFile(f, \"r\");\n        boolean success = false;\n        try {\n            Map<ZipArchiveEntry, NameAndComment> entriesWithoutUTF8Flag =\n                populateFromCentralDirectory();\n            resolveLocalFileHeaderData(entriesWithoutUTF8Flag);\n            success = true;\n        } finally {\n            if (!success) {\n                try {\n                    closed = true;\n                    archive.close();\n                } catch (IOException e2) { \n                    \n                }\n            }\n        }\n    }\n\n    \n    public String getEncoding() {\n        return encoding;\n    }\n\n    \n    public void close() throws IOException {\n        \n        \n        \n        closed = true;\n\n        archive.close();\n    }\n\n    \n    public static void closeQuietly(ZipFile zipfile) {\n        if (zipfile != null) {\n            try {\n                zipfile.close();\n            } catch (IOException e) { \n                \n            }\n        }\n    }\n\n    \n    public Enumeration<ZipArchiveEntry> getEntries() {\n        return Collections.enumeration(entries.keySet());\n    }\n\n    \n    public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder() {\n        ZipArchiveEntry[] allEntries =\n            entries.keySet().toArray(new ZipArchiveEntry[0]);\n        Arrays.sort(allEntries, OFFSET_COMPARATOR);\n        return Collections.enumeration(Arrays.asList(allEntries));\n    }\n\n    \n    public ZipArchiveEntry getEntry(String name) {\n        return nameMap.get(name);\n    }\n\n    \n    public boolean canReadEntryData(ZipArchiveEntry ze) {\n        return ZipUtil.canHandleEntryData(ze);\n    }\n\n    \n    public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException {\n        OffsetEntry offsetEntry = entries.get(ze);\n        if (offsetEntry == null) {\n            return null;\n        }\n        ZipUtil.checkRequestedFeatures(ze);\n        long start = offsetEntry.dataOffset;\n        BoundedInputStream bis =\n            new BoundedInputStream(start, ze.getCompressedSize());\n        switch (ze.getMethod()) {\n            case ZipArchiveEntry.STORED:\n                return bis;\n            case ZipArchiveEntry.DEFLATED:\n                bis.addDummy();\n                final Inflater inflater = new Inflater(true);\n                return new InflaterInputStream(bis, inflater) {\n                    @Override\n                    public void close() throws IOException {\n                        super.close();\n                        inflater.end();\n                    }\n                };\n            default:\n                throw new ZipException(\"Found unsupported compression method \"\n                                       + ze.getMethod());\n        }\n    }\n\n    \n    @Override\n    protected void finalize() throws Throwable {\n        try {\n            if (!closed) {\n                System.err.println(\"Cleaning up unclosed ZipFile for archive \"\n                                   + archiveName);\n                close();\n            }\n        } finally {\n            super.finalize();\n        }\n    }\n\n    \n    private static final int CFH_LEN = SHORT + SHORT + SHORT + SHORT + SHORT + SHORT + WORD + WORD + WORD + SHORT + SHORT + SHORT + SHORT + SHORT + WORD + WORD; private static final long CFH_SIG = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG); private Map<ZipArchiveEntry, NameAndComment> populateFromCentralDirectory() throws IOException {\n        HashMap<ZipArchiveEntry, NameAndComment> noUTF8Flag =\n            new HashMap<ZipArchiveEntry, NameAndComment>();\n\n        positionAtCentralDirectory();\n\n        byte[] signatureBytes = new byte[WORD];\n        archive.readFully(signatureBytes);\n        long sig = ZipLong.getValue(signatureBytes);\n\n        if (sig != CFH_SIG && startsWithLocalFileHeader()) {\n            throw new IOException(\"central directory is empty, can't expand\"\n                                  + \" corrupt archive.\");\n        }\n\n        while (sig == CFH_SIG) {\n            readCentralDirectoryEntry(noUTF8Flag);\n            archive.readFully(signatureBytes);\n            sig = ZipLong.getValue(signatureBytes);\n        }\n        return noUTF8Flag;\n    }\n\n    \n    private void readCentralDirectoryEntry(Map<ZipArchiveEntry, NameAndComment> noUTF8Flag) throws IOException {\n        byte[] cfh = new byte[CFH_LEN];\n\n        archive.readFully(cfh);\n        int off = 0;\n        ZipArchiveEntry ze = new ZipArchiveEntry();\n\n        int versionMadeBy = ZipShort.getValue(cfh, off);\n        off += SHORT;\n        ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK);\n\n        off += SHORT; \n\n        final GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(cfh, off);\n        final boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();\n        final ZipEncoding entryEncoding =\n            hasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n        ze.setGeneralPurposeBit(gpFlag);\n\n        off += SHORT;\n\n        ze.setMethod(ZipShort.getValue(cfh, off));\n        off += SHORT;\n\n        long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off));\n        ze.setTime(time);\n        off += WORD;\n\n        ze.setCrc(ZipLong.getValue(cfh, off));\n        off += WORD;\n\n        ze.setCompressedSize(ZipLong.getValue(cfh, off));\n        off += WORD;\n\n        ze.setSize(ZipLong.getValue(cfh, off));\n        off += WORD;\n\n        int fileNameLen = ZipShort.getValue(cfh, off);\n        off += SHORT;\n\n        int extraLen = ZipShort.getValue(cfh, off);\n        off += SHORT;\n\n        int commentLen = ZipShort.getValue(cfh, off);\n        off += SHORT;\n\n        int diskStart = ZipShort.getValue(cfh, off);\n        off += SHORT;\n\n        ze.setInternalAttributes(ZipShort.getValue(cfh, off));\n        off += SHORT;\n\n        ze.setExternalAttributes(ZipLong.getValue(cfh, off));\n        off += WORD;\n\n        byte[] fileName = new byte[fileNameLen];\n        archive.readFully(fileName);\n        ze.setName(entryEncoding.decode(fileName), fileName);\n\n        \n        OffsetEntry offset = new OffsetEntry();\n        offset.headerOffset = ZipLong.getValue(cfh, off);\n        \n        entries.put(ze, offset);\n\n        nameMap.put(ze.getName(), ze);\n\n        byte[] cdExtraData = new byte[extraLen];\n        archive.readFully(cdExtraData);\n        ze.setCentralDirectoryExtra(cdExtraData);\n\n        setSizesAndOffsetFromZip64Extra(ze, offset, diskStart);\n\n        byte[] comment = new byte[commentLen];\n        archive.readFully(comment);\n        ze.setComment(entryEncoding.decode(comment));\n\n        if (!hasUTF8Flag && useUnicodeExtraFields) {\n            noUTF8Flag.put(ze, new NameAndComment(fileName, comment));\n        }\n    }\n\n    \n    private void setSizesAndOffsetFromZip64Extra(ZipArchiveEntry ze, OffsetEntry offset, int diskStart) throws IOException {\n        Zip64ExtendedInformationExtraField z64 =\n            (Zip64ExtendedInformationExtraField)\n            ze.getExtraField(Zip64ExtendedInformationExtraField.HEADER_ID);\n        if (z64 != null) {\n            boolean hasUncompressedSize = ze.getSize() == ZIP64_MAGIC;\n            boolean hasCompressedSize = ze.getCompressedSize() == ZIP64_MAGIC;\n            boolean hasRelativeHeaderOffset =\n                offset.headerOffset == ZIP64_MAGIC;\n            z64.reparseCentralDirectoryData(hasUncompressedSize,\n                                            hasCompressedSize,\n                                            hasRelativeHeaderOffset,\n                                            diskStart == ZIP64_MAGIC_SHORT);\n\n            if (hasUncompressedSize) {\n                ze.setSize(z64.getSize().getLongValue());\n            } else if (hasCompressedSize) {\n                z64.setSize(new ZipEightByteInteger(ze.getSize()));\n            }\n\n            if (hasCompressedSize) {\n                ze.setCompressedSize(z64.getCompressedSize().getLongValue());\n            } else if (hasUncompressedSize) {\n                z64.setCompressedSize(new ZipEightByteInteger(ze.getCompressedSize()));\n            }\n\n            if (hasRelativeHeaderOffset) {\n                offset.headerOffset =\n                    z64.getRelativeHeaderOffset().getLongValue();\n            }\n        }\n    }\n\n    \n    private static final int MIN_EOCD_SIZE = WORD + SHORT + SHORT + SHORT + SHORT + WORD + WORD + SHORT; private static final int MAX_EOCD_SIZE = MIN_EOCD_SIZE + ZIP64_MAGIC_SHORT; private static final int CFD_LOCATOR_OFFSET = WORD + SHORT + SHORT + SHORT + SHORT + WORD; private static final int ZIP64_EOCDL_LENGTH = WORD + WORD + DWORD + WORD; private static final int ZIP64_EOCDL_LOCATOR_OFFSET = WORD + WORD; private static final int ZIP64_EOCD_CFD_LOCATOR_OFFSET = WORD + DWORD + SHORT + SHORT + WORD + WORD + DWORD + DWORD + DWORD; private void positionAtCentralDirectory() throws IOException {\n        boolean found = tryToLocateSignature(MIN_EOCD_SIZE + ZIP64_EOCDL_LENGTH,\n                                             MAX_EOCD_SIZE + ZIP64_EOCDL_LENGTH,\n                                             ZipArchiveOutputStream\n                                             .ZIP64_EOCD_LOC_SIG);\n        if (!found) {\n            \n            positionAtCentralDirectory32();\n        } else {\n            positionAtCentralDirectory64();\n        }\n    }\n\n    \n    private void positionAtCentralDirectory64() throws IOException {\n        skipBytes(ZIP64_EOCDL_LOCATOR_OFFSET);\n        byte[] zip64EocdOffset = new byte[DWORD];\n        archive.readFully(zip64EocdOffset);\n        archive.seek(ZipEightByteInteger.getLongValue(zip64EocdOffset));\n        byte[] sig = new byte[WORD];\n        archive.readFully(sig);\n        if (sig[POS_0] != ZipArchiveOutputStream.ZIP64_EOCD_SIG[POS_0]\n            || sig[POS_1] != ZipArchiveOutputStream.ZIP64_EOCD_SIG[POS_1]\n            || sig[POS_2] != ZipArchiveOutputStream.ZIP64_EOCD_SIG[POS_2]\n            || sig[POS_3] != ZipArchiveOutputStream.ZIP64_EOCD_SIG[POS_3]\n            ) {\n            throw new ZipException(\"archive's ZIP64 end of central \"\n                                   + \"directory locator is corrupt.\");\n        }\n        skipBytes(ZIP64_EOCD_CFD_LOCATOR_OFFSET\n                  - WORD );\n        byte[] cfdOffset = new byte[DWORD];\n        archive.readFully(cfdOffset);\n        archive.seek(ZipEightByteInteger.getLongValue(cfdOffset));\n    }\n\n    \n    private void positionAtCentralDirectory32() throws IOException {\n        boolean found = tryToLocateSignature(MIN_EOCD_SIZE, MAX_EOCD_SIZE,\n                                             ZipArchiveOutputStream.EOCD_SIG);\n        if (!found) {\n            throw new ZipException(\"archive is not a ZIP archive\");\n        }\n        skipBytes(CFD_LOCATOR_OFFSET);\n        byte[] cfdOffset = new byte[WORD];\n        archive.readFully(cfdOffset);\n        archive.seek(ZipLong.getValue(cfdOffset));\n    }\n\n    \n    private boolean tryToLocateSignature(long minDistanceFromEnd, long maxDistanceFromEnd, byte[] sig) throws IOException {\n        boolean found = false;\n        long off = archive.length() - minDistanceFromEnd;\n        final long stopSearching =\n            Math.max(0L, archive.length() - maxDistanceFromEnd);\n        if (off >= 0) {\n            for (; off >= stopSearching; off--) {\n                archive.seek(off);\n                int curr = archive.read();\n                if (curr == -1) {\n                    break;\n                }\n                if (curr == sig[POS_0]) {\n                    curr = archive.read();\n                    if (curr == sig[POS_1]) {\n                        curr = archive.read();\n                        if (curr == sig[POS_2]) {\n                            curr = archive.read();\n                            if (curr == sig[POS_3]) {\n                                found = true;\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if (found) {\n            archive.seek(off);\n        }\n        return found;\n    }\n\n     \n    private void skipBytes(final int count) throws IOException {\n        int totalSkipped = 0;\n        while (totalSkipped < count) {\n            int skippedNow = archive.skipBytes(count - totalSkipped);\n            if (skippedNow <= 0) {\n                throw new EOFException();\n            }\n            totalSkipped += skippedNow;\n        }\n    }\n\n    \n    private static final long LFH_OFFSET_FOR_FILENAME_LENGTH = WORD + SHORT + SHORT + SHORT + SHORT + SHORT + WORD + WORD + WORD; private void resolveLocalFileHeaderData(Map<ZipArchiveEntry, NameAndComment> entriesWithoutUTF8Flag) throws IOException {\n        \n        \n        \n        \n        Map<ZipArchiveEntry, OffsetEntry> origMap =\n            new LinkedHashMap<ZipArchiveEntry, OffsetEntry>(entries);\n        entries.clear();\n        for (ZipArchiveEntry ze : origMap.keySet()) {\n            OffsetEntry offsetEntry = origMap.get(ze);\n            long offset = offsetEntry.headerOffset;\n            archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH);\n            byte[] b = new byte[SHORT];\n            archive.readFully(b);\n            int fileNameLen = ZipShort.getValue(b);\n            archive.readFully(b);\n            int extraFieldLen = ZipShort.getValue(b);\n            int lenToSkip = fileNameLen;\n            while (lenToSkip > 0) {\n                int skipped = archive.skipBytes(lenToSkip);\n                if (skipped <= 0) {\n                    throw new RuntimeException(\"failed to skip file name in\"\n                                               + \" local file header\");\n                }\n                lenToSkip -= skipped;\n            }\n            byte[] localExtraData = new byte[extraFieldLen];\n            archive.readFully(localExtraData);\n            ze.setExtra(localExtraData);\n            offsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH\n                + SHORT + SHORT + fileNameLen + extraFieldLen;\n\n            if (entriesWithoutUTF8Flag.containsKey(ze)) {\n                String orig = ze.getName();\n                NameAndComment nc = entriesWithoutUTF8Flag.get(ze);\n                ZipUtil.setNameAndCommentFromExtraFields(ze, nc.name,\n                                                         nc.comment);\n                if (!orig.equals(ze.getName())) {\n                    nameMap.remove(orig);\n                    nameMap.put(ze.getName(), ze);\n                }\n            }\n            entries.put(ze, offsetEntry);\n        }\n    }\n\n    \n    private boolean startsWithLocalFileHeader() throws IOException {\n        archive.seek(0);\n        final byte[] start = new byte[WORD];\n        archive.readFully(start);\n        for (int i = 0; i < start.length; i++) {\n            if (start[i] != ZipArchiveOutputStream.LFH_SIG[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    private class BoundedInputStream extends InputStream { private long remaining; private long loc; private boolean addDummyByte = false; BoundedInputStream(long start, long remaining) {\n            this.remaining = remaining;\n            loc = start;\n        }\n\n        @Override\n        public int read() throws IOException {\n            if (remaining-- <= 0) {\n                if (addDummyByte) {\n                    addDummyByte = false;\n                    return 0;\n                }\n                return -1;\n            }\n            synchronized (archive) {\n                archive.seek(loc++);\n                return archive.read();\n            }\n        }\n\n        @Override\n        public int read(byte[] b, int off, int len) throws IOException {\n            if (remaining <= 0) {\n                if (addDummyByte) {\n                    addDummyByte = false;\n                    b[off] = 0;\n                    return 1;\n                }\n                return -1;\n            }\n\n            if (len <= 0) {\n                return 0;\n            }\n\n            if (len > remaining) {\n                len = (int) remaining;\n            }\n            int ret = -1;\n            synchronized (archive) {\n                archive.seek(loc);\n                ret = archive.read(b, off, len);\n            }\n            if (ret > 0) {\n                loc += ret;\n                remaining -= ret;\n            }\n            return ret;\n        }\n\n        \n        void addDummy() {\n            addDummyByte = true;\n        }\n    }\n\n    private static final class NameAndComment { private final byte[] name; private final byte[] comment; private NameAndComment(byte[] name, byte[] comment) {\n            this.name = name;\n            this.comment = comment;\n        }\n    }\n\n    \n    private final Comparator<ZipArchiveEntry> OFFSET_COMPARATOR = new Comparator<ZipArchiveEntry>() {\n        public int compare(ZipArchiveEntry e1, ZipArchiveEntry e2) {\n            if (e1 == e2)\n                return 0;\n\n            OffsetEntry off1 = entries.get(e1);\n            OffsetEntry off2 = entries.get(e2);\n            if (off1 == null) {\n                return 1;\n            }\n            if (off2 == null) {\n                return -1;\n            }\n            long val = (off1.headerOffset - off2.headerOffset);\n            return val == 0 ? 0 : val < 0 ? -1 : +1;\n        }\n    };\n}\n",
      "buggy_signatures": [
        "public ZipFile(String name) throws IOException",
        "public ZipFile(String name, String encoding) throws IOException",
        "public ZipFile(File f, String encoding) throws IOException",
        "public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException",
        "public String getEncoding()",
        "public void close() throws IOException",
        "public static void closeQuietly(ZipFile zipfile)",
        "public Enumeration<ZipArchiveEntry> getEntries()",
        "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()",
        "public ZipArchiveEntry getEntry(String name)",
        "public boolean canReadEntryData(ZipArchiveEntry ze)",
        "public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException",
        "public void close() throws IOException",
        "protected void finalize() throws Throwable",
        "private void readCentralDirectoryEntry(Map<ZipArchiveEntry, NameAndComment> noUTF8Flag) throws IOException",
        "private void setSizesAndOffsetFromZip64Extra(ZipArchiveEntry ze, OffsetEntry offset, int diskStart) throws IOException",
        "private void positionAtCentralDirectory64() throws IOException",
        "private void positionAtCentralDirectory32() throws IOException",
        "private boolean tryToLocateSignature(long minDistanceFromEnd, long maxDistanceFromEnd, byte[] sig) throws IOException",
        "private void skipBytes(final int count) throws IOException",
        "private boolean startsWithLocalFileHeader() throws IOException",
        "public int read() throws IOException",
        "synchronized (archive)",
        "public int read(byte[] b, int off, int len) throws IOException",
        "synchronized (archive)",
        "private static final class NameAndComment { private final byte[] name; private final byte[] comment; private NameAndComment(byte[] name, byte[] comment)",
        "public int compare(ZipArchiveEntry e1, ZipArchiveEntry e2)"
      ],
      "fixed_signatures": [
        "public ZipFile(String name) throws IOException",
        "public ZipFile(String name, String encoding) throws IOException",
        "public ZipFile(File f, String encoding) throws IOException",
        "public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException",
        "public String getEncoding()",
        "public void close() throws IOException",
        "public static void closeQuietly(ZipFile zipfile)",
        "public Enumeration<ZipArchiveEntry> getEntries()",
        "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()",
        "public ZipArchiveEntry getEntry(String name)",
        "public boolean canReadEntryData(ZipArchiveEntry ze)",
        "public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException",
        "public void close() throws IOException",
        "protected void finalize() throws Throwable",
        "private void readCentralDirectoryEntry(Map<ZipArchiveEntry, NameAndComment> noUTF8Flag) throws IOException",
        "private void setSizesAndOffsetFromZip64Extra(ZipArchiveEntry ze, OffsetEntry offset, int diskStart) throws IOException",
        "private void positionAtCentralDirectory64() throws IOException",
        "private void positionAtCentralDirectory32() throws IOException",
        "private boolean tryToLocateSignature(long minDistanceFromEnd, long maxDistanceFromEnd, byte[] sig) throws IOException",
        "private void skipBytes(final int count) throws IOException",
        "private boolean startsWithLocalFileHeader() throws IOException",
        "public int read() throws IOException",
        "synchronized (archive)",
        "public int read(byte[] b, int off, int len) throws IOException",
        "synchronized (archive)",
        "private static final class NameAndComment { private final byte[] name; private final byte[] comment; private NameAndComment(byte[] name, byte[] comment)",
        "public int compare(ZipArchiveEntry e1, ZipArchiveEntry e2)"
      ],
      "methods": [
        {
          "buggy_method": "  private void resolveLocalFileHeaderData(Map<ZipArchiveEntry, NameAndComment> entriesWithoutUTF8Flag) throws IOException {\n  \n  \n  \n  \n  for (ZipArchiveEntry ze : entries.keySet()) {\n  OffsetEntry offsetEntry = entries.get(ze);\n  long offset = offsetEntry.headerOffset;\n  archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH);\n  byte[] b = new byte[SHORT];\n  archive.readFully(b);\n  int fileNameLen = ZipShort.getValue(b);\n  archive.readFully(b);\n  int extraFieldLen = ZipShort.getValue(b);\n  int lenToSkip = fileNameLen;\n  while (lenToSkip > 0) {\n  int skipped = archive.skipBytes(lenToSkip);\n  if (skipped <= 0) {\n  throw new RuntimeException(\"failed to skip file name in\"\n  + \" local file header\");\n  }\n  lenToSkip -= skipped;\n  }\n  byte[] localExtraData = new byte[extraFieldLen];\n  archive.readFully(localExtraData);\n  ze.setExtra(localExtraData);\n  offsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH\n  + SHORT + SHORT + fileNameLen + extraFieldLen;\n\n  if (entriesWithoutUTF8Flag.containsKey(ze)) {\n  String orig = ze.getName();\n  NameAndComment nc = entriesWithoutUTF8Flag.get(ze);\n  ZipUtil.setNameAndCommentFromExtraFields(ze, nc.name,\n  nc.comment);\n  if (!orig.equals(ze.getName())) {\n  nameMap.remove(orig);\n  nameMap.put(ze.getName(), ze);\n  }\n  }\n  }\n  }",
          "fixed_method": "  private void resolveLocalFileHeaderData(Map<ZipArchiveEntry, NameAndComment> entriesWithoutUTF8Flag) throws IOException {\n  \n  \n  \n  \n  Map<ZipArchiveEntry, OffsetEntry> origMap =\n  new LinkedHashMap<ZipArchiveEntry, OffsetEntry>(entries);\n  entries.clear();\n  for (ZipArchiveEntry ze : origMap.keySet()) {\n  OffsetEntry offsetEntry = origMap.get(ze);\n  long offset = offsetEntry.headerOffset;\n  archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH);\n  byte[] b = new byte[SHORT];\n  archive.readFully(b);\n  int fileNameLen = ZipShort.getValue(b);\n  archive.readFully(b);\n  int extraFieldLen = ZipShort.getValue(b);\n  int lenToSkip = fileNameLen;\n  while (lenToSkip > 0) {\n  int skipped = archive.skipBytes(lenToSkip);\n  if (skipped <= 0) {\n  throw new RuntimeException(\"failed to skip file name in\"\n  + \" local file header\");\n  }\n  lenToSkip -= skipped;\n  }\n  byte[] localExtraData = new byte[extraFieldLen];\n  archive.readFully(localExtraData);\n  ze.setExtra(localExtraData);\n  offsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH\n  + SHORT + SHORT + fileNameLen + extraFieldLen;\n\n  if (entriesWithoutUTF8Flag.containsKey(ze)) {\n  String orig = ze.getName();\n  NameAndComment nc = entriesWithoutUTF8Flag.get(ze);\n  ZipUtil.setNameAndCommentFromExtraFields(ze, nc.name,\n  nc.comment);\n  if (!orig.equals(ze.getName())) {\n  nameMap.remove(orig);\n  nameMap.put(ze.getName(), ze);\n  }\n  }\n  entries.put(ze, offsetEntry);\n  }\n  }",
          "diff": [
            "@@ -805,8 +805,11 @@",
            "         // the hashcode - see COMPRESS-164\n",
            "         // Map needs to be reconstructed in order to keep central\n",
            "         // directory order\n",
            "-        for (ZipArchiveEntry ze : entries.keySet()) {\n",
            "-            OffsetEntry offsetEntry = entries.get(ze);\n",
            "+        Map<ZipArchiveEntry, OffsetEntry> origMap =\n",
            "+            new LinkedHashMap<ZipArchiveEntry, OffsetEntry>(entries);\n",
            "+        entries.clear();\n",
            "+        for (ZipArchiveEntry ze : origMap.keySet()) {\n",
            "+            OffsetEntry offsetEntry = origMap.get(ze);\n",
            "             long offset = offsetEntry.headerOffset;\n",
            "             archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH);\n",
            "             byte[] b = new byte[SHORT];\n",
            "@@ -839,6 +842,7 @@",
            "                     nameMap.put(ze.getName(), ze);\n",
            "                 }\n",
            "             }\n",
            "+            entries.put(ze, offsetEntry);\n",
            "         }\n",
            "     }\n",
            " \n"
          ],
          "changed_lines": 8
        }
      ]
    }
  ]
}
