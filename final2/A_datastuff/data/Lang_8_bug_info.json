{
  "bug_id": "8",
  "failed_tests": {
    "org.apache.commons.lang3.time.FastDateFormat_PrinterTest": [
      {
        "methodName": "testCalendarTimezoneRespected",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<2:53AM [IC]T> but was:<2:53AM [PS]T>",
        "fail_line": "",
        "test_source": "",
        "stack": [
          "FastDatePrinterTest.testCalendarTimezoneRespected line 286"
        ]
      }
    ],
    "org.apache.commons.lang3.time.FastDatePrinterTest": [
      {
        "methodName": "testCalendarTimezoneRespected",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<2:53AM [IC]T> but was:<2:53AM [PS]T>",
        "fail_line": "        assertEquals(expectedValue, actualValue);",
        "test_source": "  public void testCalendarTimezoneRespected() {\n  String[] availableZones = TimeZone.getAvailableIDs();\n  TimeZone currentZone = TimeZone.getDefault();\n  \n  TimeZone anotherZone = null;\n  for (String zone : availableZones) {\n  if (!zone.equals(currentZone.getID())) {\n  anotherZone = TimeZone.getTimeZone(zone);\n  }\n  }\n  \n  assertNotNull(\"Cannot find another timezone\", anotherZone);\n  \n  final String pattern = \"h:mma z\";\n  final Calendar cal = Calendar.getInstance(anotherZone);\n  \n  SimpleDateFormat sdf = new SimpleDateFormat(pattern);\n  sdf.setTimeZone(anotherZone);\n  String expectedValue = sdf.format(cal.getTime());\n  String actualValue = FastDateFormat.getInstance(pattern).format(cal);\n  assertEquals(expectedValue, actualValue);\n  }",
        "stack": [
          "FastDatePrinterTest.testCalendarTimezoneRespected line 286"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/lang3/time/FastDatePrinter.java",
      "buggy_full_code": "\npackage org.apache.commons.lang3.time;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.Serializable;\nimport java.text.DateFormat;\nimport java.text.DateFormatSymbols;\nimport java.text.FieldPosition;\nimport java.util.ArrayList;\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.GregorianCalendar;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.TimeZone;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\n\nimport org.apache.commons.lang3.Validate;\n\n\npublic class FastDatePrinter implements DatePrinter, Serializable { private static final long serialVersionUID = 1L; public static final int FULL = DateFormat.FULL; public static final int LONG = DateFormat.LONG; public static final int MEDIUM = DateFormat.MEDIUM; public static final int SHORT = DateFormat.SHORT; private final String mPattern; private final TimeZone mTimeZone; private final Locale mLocale; private transient Rule[] mRules; private transient int mMaxLengthEstimate; protected FastDatePrinter(String pattern, TimeZone timeZone, Locale locale) {\n        mPattern = pattern;\n        mTimeZone = timeZone;\n        mLocale = locale;\n\n        init();\n    }\n\n    \n    private void init() {\n        List<Rule> rulesList = parsePattern();\n        mRules = rulesList.toArray(new Rule[rulesList.size()]);\n\n        int len = 0;\n        for (int i=mRules.length; --i >= 0; ) {\n            len += mRules[i].estimateLength();\n        }\n\n        mMaxLengthEstimate = len;\n    }\n\n    \n    \n    \n    protected List<Rule> parsePattern() {\n        DateFormatSymbols symbols = new DateFormatSymbols(mLocale);\n        List<Rule> rules = new ArrayList<Rule>();\n\n        String[] ERAs = symbols.getEras();\n        String[] months = symbols.getMonths();\n        String[] shortMonths = symbols.getShortMonths();\n        String[] weekdays = symbols.getWeekdays();\n        String[] shortWeekdays = symbols.getShortWeekdays();\n        String[] AmPmStrings = symbols.getAmPmStrings();\n\n        int length = mPattern.length();\n        int[] indexRef = new int[1];\n\n        for (int i = 0; i < length; i++) {\n            indexRef[0] = i;\n            String token = parseToken(mPattern, indexRef);\n            i = indexRef[0];\n\n            int tokenLen = token.length();\n            if (tokenLen == 0) {\n                break;\n            }\n\n            Rule rule;\n            char c = token.charAt(0);\n\n            switch (c) {\n            case 'G': \n                rule = new TextField(Calendar.ERA, ERAs);\n                break;\n            case 'y': \n                if (tokenLen == 2) {\n                    rule = TwoDigitYearField.INSTANCE;\n                } else {\n                    rule = selectNumberRule(Calendar.YEAR, tokenLen < 4 ? 4 : tokenLen);\n                }\n                break;\n            case 'M': \n                if (tokenLen >= 4) {\n                    rule = new TextField(Calendar.MONTH, months);\n                } else if (tokenLen == 3) {\n                    rule = new TextField(Calendar.MONTH, shortMonths);\n                } else if (tokenLen == 2) {\n                    rule = TwoDigitMonthField.INSTANCE;\n                } else {\n                    rule = UnpaddedMonthField.INSTANCE;\n                }\n                break;\n            case 'd': \n                rule = selectNumberRule(Calendar.DAY_OF_MONTH, tokenLen);\n                break;\n            case 'h': \n                rule = new TwelveHourField(selectNumberRule(Calendar.HOUR, tokenLen));\n                break;\n            case 'H': \n                rule = selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen);\n                break;\n            case 'm': \n                rule = selectNumberRule(Calendar.MINUTE, tokenLen);\n                break;\n            case 's': \n                rule = selectNumberRule(Calendar.SECOND, tokenLen);\n                break;\n            case 'S': \n                rule = selectNumberRule(Calendar.MILLISECOND, tokenLen);\n                break;\n            case 'E': \n                rule = new TextField(Calendar.DAY_OF_WEEK, tokenLen < 4 ? shortWeekdays : weekdays);\n                break;\n            case 'D': \n                rule = selectNumberRule(Calendar.DAY_OF_YEAR, tokenLen);\n                break;\n            case 'F': \n                rule = selectNumberRule(Calendar.DAY_OF_WEEK_IN_MONTH, tokenLen);\n                break;\n            case 'w': \n                rule = selectNumberRule(Calendar.WEEK_OF_YEAR, tokenLen);\n                break;\n            case 'W': \n                rule = selectNumberRule(Calendar.WEEK_OF_MONTH, tokenLen);\n                break;\n            case 'a': \n                rule = new TextField(Calendar.AM_PM, AmPmStrings);\n                break;\n            case 'k': \n                rule = new TwentyFourHourField(selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen));\n                break;\n            case 'K': \n                rule = selectNumberRule(Calendar.HOUR, tokenLen);\n                break;\n            case 'z': \n                if (tokenLen >= 4) {\n                    rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.LONG);\n                } else {\n                    rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.SHORT);\n                }\n                break;\n            case 'Z': \n                if (tokenLen == 1) {\n                    rule = TimeZoneNumberRule.INSTANCE_NO_COLON;\n                } else {\n                    rule = TimeZoneNumberRule.INSTANCE_COLON;\n                }\n                break;\n            case '\\'': \n                String sub = token.substring(1);\n                if (sub.length() == 1) {\n                    rule = new CharacterLiteral(sub.charAt(0));\n                } else {\n                    rule = new StringLiteral(sub);\n                }\n                break;\n            default:\n                throw new IllegalArgumentException(\"Illegal pattern component: \" + token);\n            }\n\n            rules.add(rule);\n        }\n\n        return rules;\n    }\n\n    \n    protected String parseToken(String pattern, int[] indexRef) {\n        StringBuilder buf = new StringBuilder();\n\n        int i = indexRef[0];\n        int length = pattern.length();\n\n        char c = pattern.charAt(i);\n        if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') {\n            \n            \n            buf.append(c);\n\n            while (i + 1 < length) {\n                char peek = pattern.charAt(i + 1);\n                if (peek == c) {\n                    buf.append(c);\n                    i++;\n                } else {\n                    break;\n                }\n            }\n        } else {\n            \n            buf.append('\\'');\n\n            boolean inLiteral = false;\n\n            for (; i < length; i++) {\n                c = pattern.charAt(i);\n\n                if (c == '\\'') {\n                    if (i + 1 < length && pattern.charAt(i + 1) == '\\'') {\n                        \n                        i++;\n                        buf.append(c);\n                    } else {\n                        inLiteral = !inLiteral;\n                    }\n                } else if (!inLiteral &&\n                         (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z')) {\n                    i--;\n                    break;\n                } else {\n                    buf.append(c);\n                }\n            }\n        }\n\n        indexRef[0] = i;\n        return buf.toString();\n    }\n\n    \n    protected NumberRule selectNumberRule(int field, int padding) {\n        switch (padding) {\n        case 1:\n            return new UnpaddedNumberField(field);\n        case 2:\n            return new TwoDigitNumberField(field);\n        default:\n            return new PaddedNumberField(field, padding);\n        }\n    }\n\n    \n    \n    \n    @Override\n    public StringBuffer format(Object obj, StringBuffer toAppendTo, FieldPosition pos) {\n        if (obj instanceof Date) {\n            return format((Date) obj, toAppendTo);\n        } else if (obj instanceof Calendar) {\n            return format((Calendar) obj, toAppendTo);\n        } else if (obj instanceof Long) {\n            return format(((Long) obj).longValue(), toAppendTo);\n        } else {\n            throw new IllegalArgumentException(\"Unknown class: \" +\n                (obj == null ? \"<null>\" : obj.getClass().getName()));\n        }\n    }\n\n    \n    @Override\n    public String format(long millis) {\n        return format(new Date(millis));\n    }\n\n    \n    @Override\n    public String format(Date date) {\n        Calendar c = new GregorianCalendar(mTimeZone, mLocale);  \n        c.setTime(date);\n        return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();\n    }\n\n    \n    @Override\n    public String format(Calendar calendar) {\n        return format(calendar, new StringBuffer(mMaxLengthEstimate)).toString();\n    }\n\n    \n    @Override\n    public StringBuffer format(long millis, StringBuffer buf) {\n        return format(new Date(millis), buf);\n    }\n\n    \n    @Override\n    public StringBuffer format(Date date, StringBuffer buf) {\n        Calendar c = new GregorianCalendar(mTimeZone, mLocale);  \n        c.setTime(date);\n        return applyRules(c, buf);\n    }\n\n    \n    @Override\n    public StringBuffer format(Calendar calendar, StringBuffer buf) {\n        return applyRules(calendar, buf);\n    }\n\n    \n    protected StringBuffer applyRules(Calendar calendar, StringBuffer buf) {\n        for (Rule rule : mRules) {\n            rule.appendTo(buf, calendar);\n        }\n        return buf;\n    }\n\n    \n    \n    \n    @Override\n    public String getPattern() {\n        return mPattern;\n    }\n\n    \n    @Override\n    public TimeZone getTimeZone() {\n        return mTimeZone;\n    }\n\n    \n    @Override\n    public Locale getLocale() {\n        return mLocale;\n    }\n\n    \n    public int getMaxLengthEstimate() {\n        return mMaxLengthEstimate;\n    }\n\n    \n    \n    \n    @Override\n    public boolean equals(Object obj) {\n        if (obj instanceof FastDatePrinter == false) {\n            return false;\n        }\n        FastDatePrinter other = (FastDatePrinter) obj;\n        return mPattern.equals(other.mPattern)\n            && mTimeZone.equals(other.mTimeZone) \n            && mLocale.equals(other.mLocale);\n    }\n\n    \n    @Override\n    public int hashCode() {\n        return mPattern.hashCode() + 13 * (mTimeZone.hashCode() + 13 * mLocale.hashCode());\n    }\n\n    \n    @Override\n    public String toString() {\n        return \"FastDatePrinter[\" + mPattern + \",\" + mLocale + \",\" + mTimeZone.getID() + \"]\";\n    }\n\n    \n    \n    \n    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        init();\n    }\n\n    \n    \n    \n    private interface Rule { int estimateLength(); void appendTo(StringBuffer buffer, Calendar calendar); } private interface NumberRule extends Rule {\n        \n        void appendTo(StringBuffer buffer, int value);\n    }\n\n    \n    private static class CharacterLiteral implements Rule { private final char mValue; CharacterLiteral(char value) {\n            mValue = value;\n        }\n\n        \n        @Override\n        public int estimateLength() {\n            return 1;\n        }\n\n        \n        @Override\n        public void appendTo(StringBuffer buffer, Calendar calendar) {\n            buffer.append(mValue);\n        }\n    }\n\n    \n    private static class StringLiteral implements Rule { private final String mValue; StringLiteral(String value) {\n            mValue = value;\n        }\n\n        \n        @Override\n        public int estimateLength() {\n            return mValue.length();\n        }\n\n        \n        @Override\n        public void appendTo(StringBuffer buffer, Calendar calendar) {\n            buffer.append(mValue);\n        }\n    }\n\n    \n    private static class TextField implements Rule { private final int mField; private final String[] mValues; TextField(int field, String[] values) {\n            mField = field;\n            mValues = values;\n        }\n\n        \n        @Override\n        public int estimateLength() {\n            int max = 0;\n            for (int i=mValues.length; --i >= 0; ) {\n                int len = mValues[i].length();\n                if (len > max) {\n                    max = len;\n                }\n            }\n            return max;\n        }\n\n        \n        @Override\n        public void appendTo(StringBuffer buffer, Calendar calendar) {\n            buffer.append(mValues[calendar.get(mField)]);\n        }\n    }\n\n    \n    private static class UnpaddedNumberField implements NumberRule { private final int mField; UnpaddedNumberField(int field) {\n            mField = field;\n        }\n\n        \n        @Override\n        public int estimateLength() {\n            return 4;\n        }\n\n        \n        @Override\n        public void appendTo(StringBuffer buffer, Calendar calendar) {\n            appendTo(buffer, calendar.get(mField));\n        }\n\n        \n        @Override\n        public final void appendTo(StringBuffer buffer, int value) {\n            if (value < 10) {\n                buffer.append((char)(value + '0'));\n            } else if (value < 100) {\n                buffer.append((char)(value / 10 + '0'));\n                buffer.append((char)(value % 10 + '0'));\n            } else {\n                buffer.append(Integer.toString(value));\n            }\n        }\n    }\n\n    \n    private static class UnpaddedMonthField implements NumberRule { static final UnpaddedMonthField INSTANCE = new UnpaddedMonthField(); UnpaddedMonthField() {\n            super();\n        }\n\n        \n        @Override\n        public int estimateLength() {\n            return 2;\n        }\n\n        \n        @Override\n        public void appendTo(StringBuffer buffer, Calendar calendar) {\n            appendTo(buffer, calendar.get(Calendar.MONTH) + 1);\n        }\n\n        \n        @Override\n        public final void appendTo(StringBuffer buffer, int value) {\n            if (value < 10) {\n                buffer.append((char)(value + '0'));\n            } else {\n                buffer.append((char)(value / 10 + '0'));\n                buffer.append((char)(value % 10 + '0'));\n            }\n        }\n    }\n\n    \n    private static class PaddedNumberField implements NumberRule { private final int mField; private final int mSize; PaddedNumberField(int field, int size) {\n            if (size < 3) {\n                \n                throw new IllegalArgumentException();\n            }\n            mField = field;\n            mSize = size;\n        }\n\n        \n        @Override\n        public int estimateLength() {\n            return 4;\n        }\n\n        \n        @Override\n        public void appendTo(StringBuffer buffer, Calendar calendar) {\n            appendTo(buffer, calendar.get(mField));\n        }\n\n        \n        @Override\n        public final void appendTo(StringBuffer buffer, int value) {\n            if (value < 100) {\n                for (int i = mSize; --i >= 2; ) {\n                    buffer.append('0');\n                }\n                buffer.append((char)(value / 10 + '0'));\n                buffer.append((char)(value % 10 + '0'));\n            } else {\n                int digits;\n                if (value < 1000) {\n                    digits = 3;\n                } else {\n                    Validate.isTrue(value > -1, \"Negative values should not be possible\", value);\n                    digits = Integer.toString(value).length();\n                }\n                for (int i = mSize; --i >= digits; ) {\n                    buffer.append('0');\n                }\n                buffer.append(Integer.toString(value));\n            }\n        }\n    }\n\n    \n    private static class TwoDigitNumberField implements NumberRule { private final int mField; TwoDigitNumberField(int field) {\n            mField = field;\n        }\n\n        \n        @Override\n        public int estimateLength() {\n            return 2;\n        }\n\n        \n        @Override\n        public void appendTo(StringBuffer buffer, Calendar calendar) {\n            appendTo(buffer, calendar.get(mField));\n        }\n\n        \n        @Override\n        public final void appendTo(StringBuffer buffer, int value) {\n            if (value < 100) {\n                buffer.append((char)(value / 10 + '0'));\n                buffer.append((char)(value % 10 + '0'));\n            } else {\n                buffer.append(Integer.toString(value));\n            }\n        }\n    }\n\n    \n    private static class TwoDigitYearField implements NumberRule { static final TwoDigitYearField INSTANCE = new TwoDigitYearField(); TwoDigitYearField() {\n            super();\n        }\n\n        \n        @Override\n        public int estimateLength() {\n            return 2;\n        }\n\n        \n        @Override\n        public void appendTo(StringBuffer buffer, Calendar calendar) {\n            appendTo(buffer, calendar.get(Calendar.YEAR) % 100);\n        }\n\n        \n        @Override\n        public final void appendTo(StringBuffer buffer, int value) {\n            buffer.append((char)(value / 10 + '0'));\n            buffer.append((char)(value % 10 + '0'));\n        }\n    }\n\n    \n    private static class TwoDigitMonthField implements NumberRule { static final TwoDigitMonthField INSTANCE = new TwoDigitMonthField(); TwoDigitMonthField() {\n            super();\n        }\n\n        \n        @Override\n        public int estimateLength() {\n            return 2;\n        }\n\n        \n        @Override\n        public void appendTo(StringBuffer buffer, Calendar calendar) {\n            appendTo(buffer, calendar.get(Calendar.MONTH) + 1);\n        }\n\n        \n        @Override\n        public final void appendTo(StringBuffer buffer, int value) {\n            buffer.append((char)(value / 10 + '0'));\n            buffer.append((char)(value % 10 + '0'));\n        }\n    }\n\n    \n    private static class TwelveHourField implements NumberRule { private final NumberRule mRule; TwelveHourField(NumberRule rule) {\n            mRule = rule;\n        }\n\n        \n        @Override\n        public int estimateLength() {\n            return mRule.estimateLength();\n        }\n\n        \n        @Override\n        public void appendTo(StringBuffer buffer, Calendar calendar) {\n            int value = calendar.get(Calendar.HOUR);\n            if (value == 0) {\n                value = calendar.getLeastMaximum(Calendar.HOUR) + 1;\n            }\n            mRule.appendTo(buffer, value);\n        }\n\n        \n        @Override\n        public void appendTo(StringBuffer buffer, int value) {\n            mRule.appendTo(buffer, value);\n        }\n    }\n\n    \n    private static class TwentyFourHourField implements NumberRule { private final NumberRule mRule; TwentyFourHourField(NumberRule rule) {\n            mRule = rule;\n        }\n\n        \n        @Override\n        public int estimateLength() {\n            return mRule.estimateLength();\n        }\n\n        \n        @Override\n        public void appendTo(StringBuffer buffer, Calendar calendar) {\n            int value = calendar.get(Calendar.HOUR_OF_DAY);\n            if (value == 0) {\n                value = calendar.getMaximum(Calendar.HOUR_OF_DAY) + 1;\n            }\n            mRule.appendTo(buffer, value);\n        }\n\n        \n        @Override\n        public void appendTo(StringBuffer buffer, int value) {\n            mRule.appendTo(buffer, value);\n        }\n    }\n\n    \n\n    private static ConcurrentMap<TimeZoneDisplayKey, String> cTimeZoneDisplayCache = new ConcurrentHashMap<TimeZoneDisplayKey, String>(7); static String getTimeZoneDisplay(TimeZone tz, boolean daylight, int style, Locale locale) {\n        TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n        String value = cTimeZoneDisplayCache.get(key);\n        if (value == null) {\n            \n            value = tz.getDisplayName(daylight, style, locale);\n            String prior = cTimeZoneDisplayCache.putIfAbsent(key, value);\n            if (prior != null) {\n                value= prior;\n            }\n        }\n        return value;\n    }\n\n    \n    private static class TimeZoneNameRule implements Rule { private final Locale mLocale; private final int mStyle; private final TimeZone zone; private final String mStandard; private final String mDaylight; TimeZoneNameRule(TimeZone timeZone, Locale locale, int style) {\n            mLocale = locale;\n            mStyle = style;\n            zone = timeZone;\n            \n            mStandard = getTimeZoneDisplay(timeZone, false, style, locale);\n            mDaylight = getTimeZoneDisplay(timeZone, true, style, locale);\n        }\n\n        \n        @Override\n        public int estimateLength() {\n            \n            \n            \n            return Math.max(mStandard.length(), mDaylight.length());\n        }\n\n        \n        @Override\n        public void appendTo(StringBuffer buffer, Calendar calendar) {\n            if (zone.useDaylightTime()\n                    && calendar.get(Calendar.DST_OFFSET) != 0) {\n                buffer.append(getTimeZoneDisplay(zone, true, mStyle, mLocale));\n            } else {\n                buffer.append(getTimeZoneDisplay(zone, false, mStyle, mLocale));\n            }\n        }\n    }\n\n    \n    private static class TimeZoneNumberRule implements Rule { static final TimeZoneNumberRule INSTANCE_COLON = new TimeZoneNumberRule(true); static final TimeZoneNumberRule INSTANCE_NO_COLON = new TimeZoneNumberRule(false); final boolean mColon; TimeZoneNumberRule(boolean colon) {\n            mColon = colon;\n        }\n\n        \n        @Override\n        public int estimateLength() {\n            return 5;\n        }\n\n        \n        @Override\n        public void appendTo(StringBuffer buffer, Calendar calendar) {\n            int offset = calendar.get(Calendar.ZONE_OFFSET) + calendar.get(Calendar.DST_OFFSET);\n\n            if (offset < 0) {\n                buffer.append('-');\n                offset = -offset;\n            } else {\n                buffer.append('+');\n            }\n\n            int hours = offset / (60 * 60 * 1000);\n            buffer.append((char)(hours / 10 + '0'));\n            buffer.append((char)(hours % 10 + '0'));\n\n            if (mColon) {\n                buffer.append(':');\n            }\n\n            int minutes = offset / (60 * 1000) - 60 * hours;\n            buffer.append((char)(minutes / 10 + '0'));\n            buffer.append((char)(minutes % 10 + '0'));\n        }\n    }\n\n    \n    \n    private static class TimeZoneDisplayKey { private final TimeZone mTimeZone; private final int mStyle; private final Locale mLocale; TimeZoneDisplayKey(TimeZone timeZone, boolean daylight, int style, Locale locale) {\n            mTimeZone = timeZone;\n            if (daylight) {\n                style |= 0x80000000;\n            }\n            mStyle = style;\n            mLocale = locale;\n        }\n\n        \n        @Override\n        public int hashCode() {\n            return (mStyle * 31 + mLocale.hashCode() ) * 31 + mTimeZone.hashCode();\n        }\n\n        \n        @Override\n        public boolean equals(Object obj) {\n            if (this == obj) {\n                return true;\n            }\n            if (obj instanceof TimeZoneDisplayKey) {\n                TimeZoneDisplayKey other = (TimeZoneDisplayKey)obj;\n                return\n                    mTimeZone.equals(other.mTimeZone) &&\n                    mStyle == other.mStyle &&\n                    mLocale.equals(other.mLocale);\n            }\n            return false;\n        }\n    }\n}\n",
      "fixed_full_code": "\npackage org.apache.commons.lang3.time;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.Serializable;\nimport java.text.DateFormat;\nimport java.text.DateFormatSymbols;\nimport java.text.FieldPosition;\nimport java.util.ArrayList;\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.GregorianCalendar;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.TimeZone;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\n\nimport org.apache.commons.lang3.Validate;\n\n\npublic class FastDatePrinter implements DatePrinter, Serializable { private static final long serialVersionUID = 1L; public static final int FULL = DateFormat.FULL; public static final int LONG = DateFormat.LONG; public static final int MEDIUM = DateFormat.MEDIUM; public static final int SHORT = DateFormat.SHORT; private final String mPattern; private final TimeZone mTimeZone; private final Locale mLocale; private transient Rule[] mRules; private transient int mMaxLengthEstimate; protected FastDatePrinter(String pattern, TimeZone timeZone, Locale locale) {\n        mPattern = pattern;\n        mTimeZone = timeZone;\n        mLocale = locale;\n\n        init();\n    }\n\n    \n    private void init() {\n        List<Rule> rulesList = parsePattern();\n        mRules = rulesList.toArray(new Rule[rulesList.size()]);\n\n        int len = 0;\n        for (int i=mRules.length; --i >= 0; ) {\n            len += mRules[i].estimateLength();\n        }\n\n        mMaxLengthEstimate = len;\n    }\n\n    \n    \n    \n    protected List<Rule> parsePattern() {\n        DateFormatSymbols symbols = new DateFormatSymbols(mLocale);\n        List<Rule> rules = new ArrayList<Rule>();\n\n        String[] ERAs = symbols.getEras();\n        String[] months = symbols.getMonths();\n        String[] shortMonths = symbols.getShortMonths();\n        String[] weekdays = symbols.getWeekdays();\n        String[] shortWeekdays = symbols.getShortWeekdays();\n        String[] AmPmStrings = symbols.getAmPmStrings();\n\n        int length = mPattern.length();\n        int[] indexRef = new int[1];\n\n        for (int i = 0; i < length; i++) {\n            indexRef[0] = i;\n            String token = parseToken(mPattern, indexRef);\n            i = indexRef[0];\n\n            int tokenLen = token.length();\n            if (tokenLen == 0) {\n                break;\n            }\n\n            Rule rule;\n            char c = token.charAt(0);\n\n            switch (c) {\n            case 'G': \n                rule = new TextField(Calendar.ERA, ERAs);\n                break;\n            case 'y': \n                if (tokenLen == 2) {\n                    rule = TwoDigitYearField.INSTANCE;\n                } else {\n                    rule = selectNumberRule(Calendar.YEAR, tokenLen < 4 ? 4 : tokenLen);\n                }\n                break;\n            case 'M': \n                if (tokenLen >= 4) {\n                    rule = new TextField(Calendar.MONTH, months);\n                } else if (tokenLen == 3) {\n                    rule = new TextField(Calendar.MONTH, shortMonths);\n                } else if (tokenLen == 2) {\n                    rule = TwoDigitMonthField.INSTANCE;\n                } else {\n                    rule = UnpaddedMonthField.INSTANCE;\n                }\n                break;\n            case 'd': \n                rule = selectNumberRule(Calendar.DAY_OF_MONTH, tokenLen);\n                break;\n            case 'h': \n                rule = new TwelveHourField(selectNumberRule(Calendar.HOUR, tokenLen));\n                break;\n            case 'H': \n                rule = selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen);\n                break;\n            case 'm': \n                rule = selectNumberRule(Calendar.MINUTE, tokenLen);\n                break;\n            case 's': \n                rule = selectNumberRule(Calendar.SECOND, tokenLen);\n                break;\n            case 'S': \n                rule = selectNumberRule(Calendar.MILLISECOND, tokenLen);\n                break;\n            case 'E': \n                rule = new TextField(Calendar.DAY_OF_WEEK, tokenLen < 4 ? shortWeekdays : weekdays);\n                break;\n            case 'D': \n                rule = selectNumberRule(Calendar.DAY_OF_YEAR, tokenLen);\n                break;\n            case 'F': \n                rule = selectNumberRule(Calendar.DAY_OF_WEEK_IN_MONTH, tokenLen);\n                break;\n            case 'w': \n                rule = selectNumberRule(Calendar.WEEK_OF_YEAR, tokenLen);\n                break;\n            case 'W': \n                rule = selectNumberRule(Calendar.WEEK_OF_MONTH, tokenLen);\n                break;\n            case 'a': \n                rule = new TextField(Calendar.AM_PM, AmPmStrings);\n                break;\n            case 'k': \n                rule = new TwentyFourHourField(selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen));\n                break;\n            case 'K': \n                rule = selectNumberRule(Calendar.HOUR, tokenLen);\n                break;\n            case 'z': \n                if (tokenLen >= 4) {\n                    rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.LONG);\n                } else {\n                    rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.SHORT);\n                }\n                break;\n            case 'Z': \n                if (tokenLen == 1) {\n                    rule = TimeZoneNumberRule.INSTANCE_NO_COLON;\n                } else {\n                    rule = TimeZoneNumberRule.INSTANCE_COLON;\n                }\n                break;\n            case '\\'': \n                String sub = token.substring(1);\n                if (sub.length() == 1) {\n                    rule = new CharacterLiteral(sub.charAt(0));\n                } else {\n                    rule = new StringLiteral(sub);\n                }\n                break;\n            default:\n                throw new IllegalArgumentException(\"Illegal pattern component: \" + token);\n            }\n\n            rules.add(rule);\n        }\n\n        return rules;\n    }\n\n    \n    protected String parseToken(String pattern, int[] indexRef) {\n        StringBuilder buf = new StringBuilder();\n\n        int i = indexRef[0];\n        int length = pattern.length();\n\n        char c = pattern.charAt(i);\n        if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') {\n            \n            \n            buf.append(c);\n\n            while (i + 1 < length) {\n                char peek = pattern.charAt(i + 1);\n                if (peek == c) {\n                    buf.append(c);\n                    i++;\n                } else {\n                    break;\n                }\n            }\n        } else {\n            \n            buf.append('\\'');\n\n            boolean inLiteral = false;\n\n            for (; i < length; i++) {\n                c = pattern.charAt(i);\n\n                if (c == '\\'') {\n                    if (i + 1 < length && pattern.charAt(i + 1) == '\\'') {\n                        \n                        i++;\n                        buf.append(c);\n                    } else {\n                        inLiteral = !inLiteral;\n                    }\n                } else if (!inLiteral &&\n                         (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z')) {\n                    i--;\n                    break;\n                } else {\n                    buf.append(c);\n                }\n            }\n        }\n\n        indexRef[0] = i;\n        return buf.toString();\n    }\n\n    \n    protected NumberRule selectNumberRule(int field, int padding) {\n        switch (padding) {\n        case 1:\n            return new UnpaddedNumberField(field);\n        case 2:\n            return new TwoDigitNumberField(field);\n        default:\n            return new PaddedNumberField(field, padding);\n        }\n    }\n\n    \n    \n    \n    @Override\n    public StringBuffer format(Object obj, StringBuffer toAppendTo, FieldPosition pos) {\n        if (obj instanceof Date) {\n            return format((Date) obj, toAppendTo);\n        } else if (obj instanceof Calendar) {\n            return format((Calendar) obj, toAppendTo);\n        } else if (obj instanceof Long) {\n            return format(((Long) obj).longValue(), toAppendTo);\n        } else {\n            throw new IllegalArgumentException(\"Unknown class: \" +\n                (obj == null ? \"<null>\" : obj.getClass().getName()));\n        }\n    }\n\n    \n    @Override\n    public String format(long millis) {\n        return format(new Date(millis));\n    }\n\n    \n    @Override\n    public String format(Date date) {\n        Calendar c = new GregorianCalendar(mTimeZone, mLocale);  \n        c.setTime(date);\n        return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();\n    }\n\n    \n    @Override\n    public String format(Calendar calendar) {\n        return format(calendar, new StringBuffer(mMaxLengthEstimate)).toString();\n    }\n\n    \n    @Override\n    public StringBuffer format(long millis, StringBuffer buf) {\n        return format(new Date(millis), buf);\n    }\n\n    \n    @Override\n    public StringBuffer format(Date date, StringBuffer buf) {\n        Calendar c = new GregorianCalendar(mTimeZone, mLocale);  \n        c.setTime(date);\n        return applyRules(c, buf);\n    }\n\n    \n    @Override\n    public StringBuffer format(Calendar calendar, StringBuffer buf) {\n        return applyRules(calendar, buf);\n    }\n\n    \n    protected StringBuffer applyRules(Calendar calendar, StringBuffer buf) {\n        for (Rule rule : mRules) {\n            rule.appendTo(buf, calendar);\n        }\n        return buf;\n    }\n\n    \n    \n    \n    @Override\n    public String getPattern() {\n        return mPattern;\n    }\n\n    \n    @Override\n    public TimeZone getTimeZone() {\n        return mTimeZone;\n    }\n\n    \n    @Override\n    public Locale getLocale() {\n        return mLocale;\n    }\n\n    \n    public int getMaxLengthEstimate() {\n        return mMaxLengthEstimate;\n    }\n\n    \n    \n    \n    @Override\n    public boolean equals(Object obj) {\n        if (obj instanceof FastDatePrinter == false) {\n            return false;\n        }\n        FastDatePrinter other = (FastDatePrinter) obj;\n        return mPattern.equals(other.mPattern)\n            && mTimeZone.equals(other.mTimeZone) \n            && mLocale.equals(other.mLocale);\n    }\n\n    \n    @Override\n    public int hashCode() {\n        return mPattern.hashCode() + 13 * (mTimeZone.hashCode() + 13 * mLocale.hashCode());\n    }\n\n    \n    @Override\n    public String toString() {\n        return \"FastDatePrinter[\" + mPattern + \",\" + mLocale + \",\" + mTimeZone.getID() + \"]\";\n    }\n\n    \n    \n    \n    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        init();\n    }\n\n    \n    \n    \n    private interface Rule { int estimateLength(); void appendTo(StringBuffer buffer, Calendar calendar); } private interface NumberRule extends Rule {\n        \n        void appendTo(StringBuffer buffer, int value);\n    }\n\n    \n    private static class CharacterLiteral implements Rule { private final char mValue; CharacterLiteral(char value) {\n            mValue = value;\n        }\n\n        \n        @Override\n        public int estimateLength() {\n            return 1;\n        }\n\n        \n        @Override\n        public void appendTo(StringBuffer buffer, Calendar calendar) {\n            buffer.append(mValue);\n        }\n    }\n\n    \n    private static class StringLiteral implements Rule { private final String mValue; StringLiteral(String value) {\n            mValue = value;\n        }\n\n        \n        @Override\n        public int estimateLength() {\n            return mValue.length();\n        }\n\n        \n        @Override\n        public void appendTo(StringBuffer buffer, Calendar calendar) {\n            buffer.append(mValue);\n        }\n    }\n\n    \n    private static class TextField implements Rule { private final int mField; private final String[] mValues; TextField(int field, String[] values) {\n            mField = field;\n            mValues = values;\n        }\n\n        \n        @Override\n        public int estimateLength() {\n            int max = 0;\n            for (int i=mValues.length; --i >= 0; ) {\n                int len = mValues[i].length();\n                if (len > max) {\n                    max = len;\n                }\n            }\n            return max;\n        }\n\n        \n        @Override\n        public void appendTo(StringBuffer buffer, Calendar calendar) {\n            buffer.append(mValues[calendar.get(mField)]);\n        }\n    }\n\n    \n    private static class UnpaddedNumberField implements NumberRule { private final int mField; UnpaddedNumberField(int field) {\n            mField = field;\n        }\n\n        \n        @Override\n        public int estimateLength() {\n            return 4;\n        }\n\n        \n        @Override\n        public void appendTo(StringBuffer buffer, Calendar calendar) {\n            appendTo(buffer, calendar.get(mField));\n        }\n\n        \n        @Override\n        public final void appendTo(StringBuffer buffer, int value) {\n            if (value < 10) {\n                buffer.append((char)(value + '0'));\n            } else if (value < 100) {\n                buffer.append((char)(value / 10 + '0'));\n                buffer.append((char)(value % 10 + '0'));\n            } else {\n                buffer.append(Integer.toString(value));\n            }\n        }\n    }\n\n    \n    private static class UnpaddedMonthField implements NumberRule { static final UnpaddedMonthField INSTANCE = new UnpaddedMonthField(); UnpaddedMonthField() {\n            super();\n        }\n\n        \n        @Override\n        public int estimateLength() {\n            return 2;\n        }\n\n        \n        @Override\n        public void appendTo(StringBuffer buffer, Calendar calendar) {\n            appendTo(buffer, calendar.get(Calendar.MONTH) + 1);\n        }\n\n        \n        @Override\n        public final void appendTo(StringBuffer buffer, int value) {\n            if (value < 10) {\n                buffer.append((char)(value + '0'));\n            } else {\n                buffer.append((char)(value / 10 + '0'));\n                buffer.append((char)(value % 10 + '0'));\n            }\n        }\n    }\n\n    \n    private static class PaddedNumberField implements NumberRule { private final int mField; private final int mSize; PaddedNumberField(int field, int size) {\n            if (size < 3) {\n                \n                throw new IllegalArgumentException();\n            }\n            mField = field;\n            mSize = size;\n        }\n\n        \n        @Override\n        public int estimateLength() {\n            return 4;\n        }\n\n        \n        @Override\n        public void appendTo(StringBuffer buffer, Calendar calendar) {\n            appendTo(buffer, calendar.get(mField));\n        }\n\n        \n        @Override\n        public final void appendTo(StringBuffer buffer, int value) {\n            if (value < 100) {\n                for (int i = mSize; --i >= 2; ) {\n                    buffer.append('0');\n                }\n                buffer.append((char)(value / 10 + '0'));\n                buffer.append((char)(value % 10 + '0'));\n            } else {\n                int digits;\n                if (value < 1000) {\n                    digits = 3;\n                } else {\n                    Validate.isTrue(value > -1, \"Negative values should not be possible\", value);\n                    digits = Integer.toString(value).length();\n                }\n                for (int i = mSize; --i >= digits; ) {\n                    buffer.append('0');\n                }\n                buffer.append(Integer.toString(value));\n            }\n        }\n    }\n\n    \n    private static class TwoDigitNumberField implements NumberRule { private final int mField; TwoDigitNumberField(int field) {\n            mField = field;\n        }\n\n        \n        @Override\n        public int estimateLength() {\n            return 2;\n        }\n\n        \n        @Override\n        public void appendTo(StringBuffer buffer, Calendar calendar) {\n            appendTo(buffer, calendar.get(mField));\n        }\n\n        \n        @Override\n        public final void appendTo(StringBuffer buffer, int value) {\n            if (value < 100) {\n                buffer.append((char)(value / 10 + '0'));\n                buffer.append((char)(value % 10 + '0'));\n            } else {\n                buffer.append(Integer.toString(value));\n            }\n        }\n    }\n\n    \n    private static class TwoDigitYearField implements NumberRule { static final TwoDigitYearField INSTANCE = new TwoDigitYearField(); TwoDigitYearField() {\n            super();\n        }\n\n        \n        @Override\n        public int estimateLength() {\n            return 2;\n        }\n\n        \n        @Override\n        public void appendTo(StringBuffer buffer, Calendar calendar) {\n            appendTo(buffer, calendar.get(Calendar.YEAR) % 100);\n        }\n\n        \n        @Override\n        public final void appendTo(StringBuffer buffer, int value) {\n            buffer.append((char)(value / 10 + '0'));\n            buffer.append((char)(value % 10 + '0'));\n        }\n    }\n\n    \n    private static class TwoDigitMonthField implements NumberRule { static final TwoDigitMonthField INSTANCE = new TwoDigitMonthField(); TwoDigitMonthField() {\n            super();\n        }\n\n        \n        @Override\n        public int estimateLength() {\n            return 2;\n        }\n\n        \n        @Override\n        public void appendTo(StringBuffer buffer, Calendar calendar) {\n            appendTo(buffer, calendar.get(Calendar.MONTH) + 1);\n        }\n\n        \n        @Override\n        public final void appendTo(StringBuffer buffer, int value) {\n            buffer.append((char)(value / 10 + '0'));\n            buffer.append((char)(value % 10 + '0'));\n        }\n    }\n\n    \n    private static class TwelveHourField implements NumberRule { private final NumberRule mRule; TwelveHourField(NumberRule rule) {\n            mRule = rule;\n        }\n\n        \n        @Override\n        public int estimateLength() {\n            return mRule.estimateLength();\n        }\n\n        \n        @Override\n        public void appendTo(StringBuffer buffer, Calendar calendar) {\n            int value = calendar.get(Calendar.HOUR);\n            if (value == 0) {\n                value = calendar.getLeastMaximum(Calendar.HOUR) + 1;\n            }\n            mRule.appendTo(buffer, value);\n        }\n\n        \n        @Override\n        public void appendTo(StringBuffer buffer, int value) {\n            mRule.appendTo(buffer, value);\n        }\n    }\n\n    \n    private static class TwentyFourHourField implements NumberRule { private final NumberRule mRule; TwentyFourHourField(NumberRule rule) {\n            mRule = rule;\n        }\n\n        \n        @Override\n        public int estimateLength() {\n            return mRule.estimateLength();\n        }\n\n        \n        @Override\n        public void appendTo(StringBuffer buffer, Calendar calendar) {\n            int value = calendar.get(Calendar.HOUR_OF_DAY);\n            if (value == 0) {\n                value = calendar.getMaximum(Calendar.HOUR_OF_DAY) + 1;\n            }\n            mRule.appendTo(buffer, value);\n        }\n\n        \n        @Override\n        public void appendTo(StringBuffer buffer, int value) {\n            mRule.appendTo(buffer, value);\n        }\n    }\n\n    \n\n    private static ConcurrentMap<TimeZoneDisplayKey, String> cTimeZoneDisplayCache = new ConcurrentHashMap<TimeZoneDisplayKey, String>(7); static String getTimeZoneDisplay(TimeZone tz, boolean daylight, int style, Locale locale) {\n        TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n        String value = cTimeZoneDisplayCache.get(key);\n        if (value == null) {\n            \n            value = tz.getDisplayName(daylight, style, locale);\n            String prior = cTimeZoneDisplayCache.putIfAbsent(key, value);\n            if (prior != null) {\n                value= prior;\n            }\n        }\n        return value;\n    }\n\n    \n    private static class TimeZoneNameRule implements Rule { private final Locale mLocale; private final int mStyle; private final String mStandard; private final String mDaylight; TimeZoneNameRule(TimeZone timeZone, Locale locale, int style) {\n            mLocale = locale;\n            mStyle = style;\n            \n            mStandard = getTimeZoneDisplay(timeZone, false, style, locale);\n            mDaylight = getTimeZoneDisplay(timeZone, true, style, locale);\n        }\n\n        \n        @Override\n        public int estimateLength() {\n            \n            \n            \n            return Math.max(mStandard.length(), mDaylight.length());\n        }\n\n        \n        @Override\n        public void appendTo(StringBuffer buffer, Calendar calendar) {\n            TimeZone zone = calendar.getTimeZone();\n            if (zone.useDaylightTime()\n                    && calendar.get(Calendar.DST_OFFSET) != 0) {\n                buffer.append(getTimeZoneDisplay(zone, true, mStyle, mLocale));\n            } else {\n                buffer.append(getTimeZoneDisplay(zone, false, mStyle, mLocale));\n            }\n        }\n    }\n\n    \n    private static class TimeZoneNumberRule implements Rule { static final TimeZoneNumberRule INSTANCE_COLON = new TimeZoneNumberRule(true); static final TimeZoneNumberRule INSTANCE_NO_COLON = new TimeZoneNumberRule(false); final boolean mColon; TimeZoneNumberRule(boolean colon) {\n            mColon = colon;\n        }\n\n        \n        @Override\n        public int estimateLength() {\n            return 5;\n        }\n\n        \n        @Override\n        public void appendTo(StringBuffer buffer, Calendar calendar) {\n            int offset = calendar.get(Calendar.ZONE_OFFSET) + calendar.get(Calendar.DST_OFFSET);\n\n            if (offset < 0) {\n                buffer.append('-');\n                offset = -offset;\n            } else {\n                buffer.append('+');\n            }\n\n            int hours = offset / (60 * 60 * 1000);\n            buffer.append((char)(hours / 10 + '0'));\n            buffer.append((char)(hours % 10 + '0'));\n\n            if (mColon) {\n                buffer.append(':');\n            }\n\n            int minutes = offset / (60 * 1000) - 60 * hours;\n            buffer.append((char)(minutes / 10 + '0'));\n            buffer.append((char)(minutes % 10 + '0'));\n        }\n    }\n\n    \n    \n    private static class TimeZoneDisplayKey { private final TimeZone mTimeZone; private final int mStyle; private final Locale mLocale; TimeZoneDisplayKey(TimeZone timeZone, boolean daylight, int style, Locale locale) {\n            mTimeZone = timeZone;\n            if (daylight) {\n                style |= 0x80000000;\n            }\n            mStyle = style;\n            mLocale = locale;\n        }\n\n        \n        @Override\n        public int hashCode() {\n            return (mStyle * 31 + mLocale.hashCode() ) * 31 + mTimeZone.hashCode();\n        }\n\n        \n        @Override\n        public boolean equals(Object obj) {\n            if (this == obj) {\n                return true;\n            }\n            if (obj instanceof TimeZoneDisplayKey) {\n                TimeZoneDisplayKey other = (TimeZoneDisplayKey)obj;\n                return\n                    mTimeZone.equals(other.mTimeZone) &&\n                    mStyle == other.mStyle &&\n                    mLocale.equals(other.mLocale);\n            }\n            return false;\n        }\n    }\n}\n",
      "buggy_signatures": [
        "private void init()",
        "protected List<Rule> parsePattern()",
        "protected String parseToken(String pattern, int[] indexRef)",
        "protected NumberRule selectNumberRule(int field, int padding)",
        "public StringBuffer format(Object obj, StringBuffer toAppendTo, FieldPosition pos)",
        "public String format(long millis)",
        "public String format(Date date)",
        "public String format(Calendar calendar)",
        "public StringBuffer format(long millis, StringBuffer buf)",
        "public StringBuffer format(Date date, StringBuffer buf)",
        "public StringBuffer format(Calendar calendar, StringBuffer buf)",
        "protected StringBuffer applyRules(Calendar calendar, StringBuffer buf)",
        "public String getPattern()",
        "public TimeZone getTimeZone()",
        "public Locale getLocale()",
        "public int getMaxLengthEstimate()",
        "public boolean equals(Object obj)",
        "public int hashCode()",
        "public String toString()",
        "private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException",
        "private interface Rule { int estimateLength(); void appendTo(StringBuffer buffer, Calendar calendar); } private interface NumberRule extends Rule",
        "private static class CharacterLiteral implements Rule { private final char mValue; CharacterLiteral(char value)",
        "public int estimateLength()",
        "public void appendTo(StringBuffer buffer, Calendar calendar)",
        "private static class StringLiteral implements Rule { private final String mValue; StringLiteral(String value)",
        "public int estimateLength()",
        "public void appendTo(StringBuffer buffer, Calendar calendar)",
        "private static class TextField implements Rule { private final int mField; private final String[] mValues; TextField(int field, String[] values)",
        "public int estimateLength()",
        "public void appendTo(StringBuffer buffer, Calendar calendar)",
        "private static class UnpaddedNumberField implements NumberRule { private final int mField; UnpaddedNumberField(int field)",
        "public int estimateLength()",
        "public void appendTo(StringBuffer buffer, Calendar calendar)",
        "public final void appendTo(StringBuffer buffer, int value)",
        "public int estimateLength()",
        "public void appendTo(StringBuffer buffer, Calendar calendar)",
        "public final void appendTo(StringBuffer buffer, int value)",
        "private static class PaddedNumberField implements NumberRule { private final int mField; private final int mSize; PaddedNumberField(int field, int size)",
        "public int estimateLength()",
        "public void appendTo(StringBuffer buffer, Calendar calendar)",
        "public final void appendTo(StringBuffer buffer, int value)",
        "private static class TwoDigitNumberField implements NumberRule { private final int mField; TwoDigitNumberField(int field)",
        "public int estimateLength()",
        "public void appendTo(StringBuffer buffer, Calendar calendar)",
        "public final void appendTo(StringBuffer buffer, int value)",
        "public int estimateLength()",
        "public void appendTo(StringBuffer buffer, Calendar calendar)",
        "public final void appendTo(StringBuffer buffer, int value)",
        "public int estimateLength()",
        "public void appendTo(StringBuffer buffer, Calendar calendar)",
        "public final void appendTo(StringBuffer buffer, int value)",
        "private static class TwelveHourField implements NumberRule { private final NumberRule mRule; TwelveHourField(NumberRule rule)",
        "public int estimateLength()",
        "public void appendTo(StringBuffer buffer, Calendar calendar)",
        "public void appendTo(StringBuffer buffer, int value)",
        "private static class TwentyFourHourField implements NumberRule { private final NumberRule mRule; TwentyFourHourField(NumberRule rule)",
        "public int estimateLength()",
        "public void appendTo(StringBuffer buffer, Calendar calendar)",
        "public void appendTo(StringBuffer buffer, int value)",
        "private static class TimeZoneNameRule implements Rule { private final Locale mLocale; private final int mStyle; private final TimeZone zone; private final String mStandard; private final String mDaylight; TimeZoneNameRule(TimeZone timeZone, Locale locale, int style)",
        "public int estimateLength()",
        "public void appendTo(StringBuffer buffer, Calendar calendar)",
        "public int estimateLength()",
        "public void appendTo(StringBuffer buffer, Calendar calendar)",
        "private static class TimeZoneDisplayKey { private final TimeZone mTimeZone; private final int mStyle; private final Locale mLocale; TimeZoneDisplayKey(TimeZone timeZone, boolean daylight, int style, Locale locale)",
        "public int hashCode()",
        "public boolean equals(Object obj)"
      ],
      "fixed_signatures": [
        "private void init()",
        "protected List<Rule> parsePattern()",
        "protected String parseToken(String pattern, int[] indexRef)",
        "protected NumberRule selectNumberRule(int field, int padding)",
        "public StringBuffer format(Object obj, StringBuffer toAppendTo, FieldPosition pos)",
        "public String format(long millis)",
        "public String format(Date date)",
        "public String format(Calendar calendar)",
        "public StringBuffer format(long millis, StringBuffer buf)",
        "public StringBuffer format(Date date, StringBuffer buf)",
        "public StringBuffer format(Calendar calendar, StringBuffer buf)",
        "protected StringBuffer applyRules(Calendar calendar, StringBuffer buf)",
        "public String getPattern()",
        "public TimeZone getTimeZone()",
        "public Locale getLocale()",
        "public int getMaxLengthEstimate()",
        "public boolean equals(Object obj)",
        "public int hashCode()",
        "public String toString()",
        "private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException",
        "private interface Rule { int estimateLength(); void appendTo(StringBuffer buffer, Calendar calendar); } private interface NumberRule extends Rule",
        "private static class CharacterLiteral implements Rule { private final char mValue; CharacterLiteral(char value)",
        "public int estimateLength()",
        "public void appendTo(StringBuffer buffer, Calendar calendar)",
        "private static class StringLiteral implements Rule { private final String mValue; StringLiteral(String value)",
        "public int estimateLength()",
        "public void appendTo(StringBuffer buffer, Calendar calendar)",
        "private static class TextField implements Rule { private final int mField; private final String[] mValues; TextField(int field, String[] values)",
        "public int estimateLength()",
        "public void appendTo(StringBuffer buffer, Calendar calendar)",
        "private static class UnpaddedNumberField implements NumberRule { private final int mField; UnpaddedNumberField(int field)",
        "public int estimateLength()",
        "public void appendTo(StringBuffer buffer, Calendar calendar)",
        "public final void appendTo(StringBuffer buffer, int value)",
        "public int estimateLength()",
        "public void appendTo(StringBuffer buffer, Calendar calendar)",
        "public final void appendTo(StringBuffer buffer, int value)",
        "private static class PaddedNumberField implements NumberRule { private final int mField; private final int mSize; PaddedNumberField(int field, int size)",
        "public int estimateLength()",
        "public void appendTo(StringBuffer buffer, Calendar calendar)",
        "public final void appendTo(StringBuffer buffer, int value)",
        "private static class TwoDigitNumberField implements NumberRule { private final int mField; TwoDigitNumberField(int field)",
        "public int estimateLength()",
        "public void appendTo(StringBuffer buffer, Calendar calendar)",
        "public final void appendTo(StringBuffer buffer, int value)",
        "public int estimateLength()",
        "public void appendTo(StringBuffer buffer, Calendar calendar)",
        "public final void appendTo(StringBuffer buffer, int value)",
        "public int estimateLength()",
        "public void appendTo(StringBuffer buffer, Calendar calendar)",
        "public final void appendTo(StringBuffer buffer, int value)",
        "private static class TwelveHourField implements NumberRule { private final NumberRule mRule; TwelveHourField(NumberRule rule)",
        "public int estimateLength()",
        "public void appendTo(StringBuffer buffer, Calendar calendar)",
        "public void appendTo(StringBuffer buffer, int value)",
        "private static class TwentyFourHourField implements NumberRule { private final NumberRule mRule; TwentyFourHourField(NumberRule rule)",
        "public int estimateLength()",
        "public void appendTo(StringBuffer buffer, Calendar calendar)",
        "public void appendTo(StringBuffer buffer, int value)",
        "private static class TimeZoneNameRule implements Rule { private final Locale mLocale; private final int mStyle; private final String mStandard; private final String mDaylight; TimeZoneNameRule(TimeZone timeZone, Locale locale, int style)",
        "public int estimateLength()",
        "public void appendTo(StringBuffer buffer, Calendar calendar)",
        "public int estimateLength()",
        "public void appendTo(StringBuffer buffer, Calendar calendar)",
        "private static class TimeZoneDisplayKey { private final TimeZone mTimeZone; private final int mStyle; private final Locale mLocale; TimeZoneDisplayKey(TimeZone timeZone, boolean daylight, int style, Locale locale)",
        "public int hashCode()",
        "public boolean equals(Object obj)"
      ],
      "methods": [
        {
          "buggy_method": "  static String getTimeZoneDisplay(TimeZone tz, boolean daylight, int style, Locale locale) {\n  TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n  String value = cTimeZoneDisplayCache.get(key);\n  if (value == null) {\n  \n  value = tz.getDisplayName(daylight, style, locale);\n  String prior = cTimeZoneDisplayCache.putIfAbsent(key, value);\n  if (prior != null) {\n  value= prior;\n  }\n  }\n  return value;\n  }",
          "fixed_method": "  static String getTimeZoneDisplay(TimeZone tz, boolean daylight, int style, Locale locale) {\n  TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n  String value = cTimeZoneDisplayCache.get(key);\n  if (value == null) {\n  \n  value = tz.getDisplayName(daylight, style, locale);\n  String prior = cTimeZoneDisplayCache.putIfAbsent(key, value);\n  if (prior != null) {\n  value= prior;\n  }\n  }\n  return value;\n  }",
          "diff": [
            "@@ -1095,7 +1095,6 @@",
            "     private static class TimeZoneNameRule implements Rule {\n",
            "         private final Locale mLocale;\n",
            "         private final int mStyle;\n",
            "-        private final TimeZone zone;\n",
            "         private final String mStandard;\n",
            "         private final String mDaylight;\n",
            " \n",
            "@@ -1109,7 +1108,6 @@",
            "         TimeZoneNameRule(TimeZone timeZone, Locale locale, int style) {\n",
            "             mLocale = locale;\n",
            "             mStyle = style;\n",
            "-            zone = timeZone;\n",
            "             \n",
            "             mStandard = getTimeZoneDisplay(timeZone, false, style, locale);\n",
            "             mDaylight = getTimeZoneDisplay(timeZone, true, style, locale);\n"
          ],
          "changed_lines": 2
        },
        {
          "buggy_method": "  public void appendTo(StringBuffer buffer, Calendar calendar) {\n  if (zone.useDaylightTime()\n  && calendar.get(Calendar.DST_OFFSET) != 0) {\n  buffer.append(getTimeZoneDisplay(zone, true, mStyle, mLocale));\n  } else {\n  buffer.append(getTimeZoneDisplay(zone, false, mStyle, mLocale));\n  }\n  }",
          "fixed_method": "  public void appendTo(StringBuffer buffer, Calendar calendar) {\n  TimeZone zone = calendar.getTimeZone();\n  if (zone.useDaylightTime()\n  && calendar.get(Calendar.DST_OFFSET) != 0) {\n  buffer.append(getTimeZoneDisplay(zone, true, mStyle, mLocale));\n  } else {\n  buffer.append(getTimeZoneDisplay(zone, false, mStyle, mLocale));\n  }\n  }",
          "diff": [
            "@@ -1131,6 +1129,7 @@",
            "          */\n",
            "         @Override\n",
            "         public void appendTo(StringBuffer buffer, Calendar calendar) {\n",
            "+            TimeZone zone = calendar.getTimeZone();\n",
            "             if (zone.useDaylightTime()\n",
            "                     && calendar.get(Calendar.DST_OFFSET) != 0) {\n",
            "                 buffer.append(getTimeZoneDisplay(zone, true, mStyle, mLocale));\n"
          ],
          "changed_lines": 1
        }
      ]
    }
  ]
}
