{
  "bug_id": "18",
  "failed_tests": {
    "com.fasterxml.jackson.databind.seq.ReadRecoveryTest": [
      {
        "methodName": "testSimpleRootRecovery",
        "error": "com.fasterxml.jackson.databind.JsonMappingException",
        "message": "Can not instantiate value of type [simple type, class com.fasterxml.jackson.databind.seq.ReadRecoveryTest$Bean] from Integral number (1); no single-int-arg constructor/factory method",
        "fail_line": "        bean = it.nextValue();",
        "test_source": "  public void testSimpleRootRecovery() throws Exception {\n  final String JSON = aposToQuotes(\"{'a':3}{'a':27,'foo':[1,2],'b':{'x':3}}  {'a':1,'b':2} \");\n\n  MappingIterator<Bean> it = MAPPER.readerFor(Bean.class).readValues(JSON);\n  Bean bean = it.nextValue();\n\n  assertNotNull(bean);\n  assertEquals(3, bean.a);\n\n  // second one problematic\n  try {\n  it.nextValue();\n  } catch (JsonMappingException e) {\n  verifyException(e, \"Unrecognized field \\\"foo\\\"\");\n  }\n\n  // but should recover nicely\n  bean = it.nextValue();\n  assertNotNull(bean);\n  assertEquals(1, bean.a);\n  assertEquals(2, bean.b);\n\n  assertFalse(it.hasNextValue());\n  \n  it.close();\n  }",
        "stack": [
          "JsonMappingException.from line 148, DeserializationContext.mappingException line 860, StdValueInstantiator.createFromInt line 304, BeanDeserializerBase.deserializeFromNumber line 1134, BeanDeserializer._deserializeOther line 145, BeanDeserializer.deserialize line 134, MappingIterator.nextValue line 249, ReadRecoveryTest.testSimpleRootRecovery line 67"
        ]
      },
      {
        "methodName": "testRootBeans",
        "error": "junit.framework.AssertionFailedError",
        "message": "",
        "fail_line": "        assertFalse(it.hasNextValue());",
        "test_source": "  public void testRootBeans() throws Exception {\n  final String JSON = aposToQuotes(\"{'a':3} {'x':5}\");\n  MappingIterator<Bean> it = MAPPER.readerFor(Bean.class).readValues(JSON);\n  // First one should be fine\n  assertTrue(it.hasNextValue());\n  Bean bean = it.nextValue();\n  assertEquals(3, bean.a);\n  // but second one not\n  try {\n  bean = it.nextValue();\n  fail(\"Should not have succeeded\");\n  } catch (JsonMappingException e) {\n  verifyException(e, \"Unrecognized field \\\"x\\\"\");\n  }\n  // 21-May-2015, tatu: With [databind#734], recovery, we now know there's no more data!\n  assertFalse(it.hasNextValue());\n\n  it.close();\n  }",
        "stack": [
          "ReadRecoveryTest.testRootBeans line 41"
        ]
      },
      {
        "methodName": "testSimpleArrayRecovery",
        "error": "com.fasterxml.jackson.databind.JsonMappingException",
        "message": "Can not instantiate value of type [simple type, class com.fasterxml.jackson.databind.seq.ReadRecoveryTest$Bean] from Integral number (1); no single-int-arg constructor/factory method",
        "fail_line": "        bean = it.nextValue();",
        "test_source": "  public void testSimpleArrayRecovery() throws Exception {\n  final String JSON = aposToQuotes(\"[{'a':3},{'a':27,'foo':[1,2],'b':{'x':3}}  ,{'a':1,'b':2}  ]\");\n\n  MappingIterator<Bean> it = MAPPER.readerFor(Bean.class).readValues(JSON);\n  Bean bean = it.nextValue();\n\n  assertNotNull(bean);\n  assertEquals(3, bean.a);\n\n  // second one problematic\n  try {\n  it.nextValue();\n  } catch (JsonMappingException e) {\n  verifyException(e, \"Unrecognized field \\\"foo\\\"\");\n  }\n\n  // but should recover nicely\n  bean = it.nextValue();\n  assertNotNull(bean);\n  assertEquals(1, bean.a);\n  assertEquals(2, bean.b);\n\n  assertFalse(it.hasNextValue());\n  \n  it.close();\n  }",
        "stack": [
          "JsonMappingException.from line 148, DeserializationContext.mappingException line 860, StdValueInstantiator.createFromInt line 304, BeanDeserializerBase.deserializeFromNumber line 1134, BeanDeserializer._deserializeOther line 145, BeanDeserializer.deserialize line 134, MappingIterator.nextValue line 249, ReadRecoveryTest.testSimpleArrayRecovery line 96"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "com/fasterxml/jackson/databind/MappingIterator.java",
      "buggy_full_code": "package com.fasterxml.jackson.databind;\n\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.util.*;\n\nimport com.fasterxml.jackson.core.*;\n\n\npublic class MappingIterator<T> implements Iterator<T>, Closeable { protected final static MappingIterator<?> EMPTY_ITERATOR = new MappingIterator<Object>(null, null, null, null, false, null); protected final JavaType _type; protected final DeserializationContext _context; protected final JsonDeserializer<T> _deserializer; protected JsonParser _parser; protected final T _updatedValue; protected final boolean _closeParser; protected boolean _hasNextChecked; @SuppressWarnings(\"unchecked\") protected MappingIterator(JavaType type, JsonParser p, DeserializationContext ctxt, JsonDeserializer<?> deser, boolean managedParser, Object valueToUpdate) {\n        _type = type;\n        _parser = p;\n        _context = ctxt;\n        _deserializer = (JsonDeserializer<T>) deser;\n        _closeParser = managedParser;\n        if (valueToUpdate == null) {\n            _updatedValue = null;\n        } else {\n            _updatedValue = (T) valueToUpdate;\n        }\n\n        \n        if (managedParser && (p != null) && p.isExpectedStartArrayToken()) {\n                \n                p.clearCurrentToken();\n                \n                \n                \n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    protected static <T> MappingIterator<T> emptyIterator() {\n        return (MappingIterator<T>) EMPTY_ITERATOR;\n    }\n    \n    \n\n    @Override\n    public boolean hasNext() {\n        try {\n            return hasNextValue();\n        } catch (JsonMappingException e) {\n            return (Boolean) _handleMappingException(e);\n        } catch (IOException e) {\n            return (Boolean) _handleIOException(e);\n        }\n    }\n    \n    @Override\n    public T next() {\n        try {\n            return nextValue();\n        } catch (JsonMappingException e) {\n            throw new RuntimeJsonMappingException(e.getMessage(), e);\n        } catch (IOException e) {\n            throw new RuntimeException(e.getMessage(), e);\n        }\n    }\n\n    @Override\n    public void remove() {\n        throw new UnsupportedOperationException();\n    }\n    \n    @Override\n    public void close() throws IOException {\n            if (_parser != null) {\n                _parser.close();\n            }\n    }\n\n    \n\n\n    \n    \n    \n    public boolean hasNextValue() throws IOException {\n        if (_parser == null) {\n            return false;\n            \n        }\n        if (!_hasNextChecked) {\n            JsonToken t = _parser.getCurrentToken();\n            _hasNextChecked = true;\n            if (t == null) { \n                t = _parser.nextToken();\n                \n                if (t == null || t == JsonToken.END_ARRAY) {\n                    JsonParser jp = _parser;\n                    _parser = null;\n                    if (_closeParser) {\n                        jp.close();\n                    }\n                    return false;\n                }\n            }\n            \n        }\n        return true;\n    }\n\n    public T nextValue() throws IOException {\n        if (!_hasNextChecked) {\n            if (!hasNextValue()) {\n                return _throwNoSuchElement();\n            }\n        }\n        if (_parser == null) {\n            return _throwNoSuchElement();\n        }\n        _hasNextChecked = false;\n\n        try {\n            T value;\n            if (_updatedValue == null) {\n                value = _deserializer.deserialize(_parser, _context);\n            } else{\n                _deserializer.deserialize(_parser, _context, _updatedValue);\n                value = _updatedValue;\n            }\n            return value;\n        } finally {\n            \n            _parser.clearCurrentToken();\n        }\n    }\n\n    \n    public List<T> readAll() throws IOException {\n        return readAll(new ArrayList<T>());\n    }\n\n    \n    public <L extends List<? super T>> L readAll(L resultList) throws IOException {\n        while (hasNextValue()) {\n            resultList.add(nextValue());\n        }\n        return resultList;\n    }\n\n    \n    public <C extends Collection<? super T>> C readAll(C results) throws IOException {\n        while (hasNextValue()) {\n            results.add(nextValue());\n        }\n        return results;\n    }\n    \n    \n\n    \n    public JsonParser getParser() {\n        return _parser;\n    }\n\n    \n    public FormatSchema getParserSchema() {\n    \treturn _parser.getSchema();\n    }\n\n    \n    public JsonLocation getCurrentLocation() {\n        return _parser.getCurrentLocation();\n    }\n\n    \n\n        \n\n\n    protected <R> R _throwNoSuchElement() {\n        throw new NoSuchElementException();\n    }\n    \n    protected <R> R _handleMappingException(JsonMappingException e) {\n        throw new RuntimeJsonMappingException(e.getMessage(), e);\n    }\n\n    protected <R> R _handleIOException(IOException e) {\n        throw new RuntimeException(e.getMessage(), e);\n    }\n}\n",
      "fixed_full_code": "package com.fasterxml.jackson.databind;\n\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.util.*;\n\nimport com.fasterxml.jackson.core.*;\n\n\npublic class MappingIterator<T> implements Iterator<T>, Closeable { protected final static MappingIterator<?> EMPTY_ITERATOR = new MappingIterator<Object>(null, null, null, null, false, null); protected final static int STATE_CLOSED = 0; protected final static int STATE_NEED_RESYNC = 1; protected final static int STATE_MAY_HAVE_VALUE = 2; protected final static int STATE_HAS_VALUE = 3; protected final JavaType _type; protected final DeserializationContext _context; protected final JsonDeserializer<T> _deserializer; protected final JsonParser _parser; protected final JsonStreamContext _seqContext; protected final T _updatedValue; protected final boolean _closeParser; protected int _state; @SuppressWarnings(\"unchecked\") protected MappingIterator(JavaType type, JsonParser p, DeserializationContext ctxt, JsonDeserializer<?> deser, boolean managedParser, Object valueToUpdate) {\n        _type = type;\n        _parser = p;\n        _context = ctxt;\n        _deserializer = (JsonDeserializer<T>) deser;\n        _closeParser = managedParser;\n        if (valueToUpdate == null) {\n            _updatedValue = null;\n        } else {\n            _updatedValue = (T) valueToUpdate;\n        }\n\n        \n        if (p == null) { \n            _seqContext = null;\n            _state = STATE_CLOSED;\n        } else {\n            JsonStreamContext sctxt = p.getParsingContext();\n            if (managedParser && p.isExpectedStartArrayToken()) {\n                \n                p.clearCurrentToken();\n            } else {\n                \n                \n                \n                JsonToken t = p.getCurrentToken();\n                if ((t == JsonToken.START_OBJECT) || (t == JsonToken.START_ARRAY)) {\n                    sctxt = sctxt.getParent();\n                }\n            }\n            _seqContext = sctxt;\n            _state = STATE_MAY_HAVE_VALUE;\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    protected static <T> MappingIterator<T> emptyIterator() {\n        return (MappingIterator<T>) EMPTY_ITERATOR;\n    }\n    \n    \n\n    @Override\n    public boolean hasNext() {\n        try {\n            return hasNextValue();\n        } catch (JsonMappingException e) {\n            return (Boolean) _handleMappingException(e);\n        } catch (IOException e) {\n            return (Boolean) _handleIOException(e);\n        }\n    }\n    \n    @Override\n    public T next() {\n        try {\n            return nextValue();\n        } catch (JsonMappingException e) {\n            throw new RuntimeJsonMappingException(e.getMessage(), e);\n        } catch (IOException e) {\n            throw new RuntimeException(e.getMessage(), e);\n        }\n    }\n\n    @Override\n    public void remove() {\n        throw new UnsupportedOperationException();\n    }\n    \n    @Override\n    public void close() throws IOException {\n        if (_state != STATE_CLOSED) {\n            _state = STATE_CLOSED;\n            if (_parser != null) {\n                _parser.close();\n            }\n        }\n    }\n\n    \n\n\n    \n    \n    \n    public boolean hasNextValue() throws IOException {\n        switch (_state) {\n        case STATE_CLOSED:\n            return false;\n        case STATE_NEED_RESYNC:\n            _resync();\n            \n        case STATE_MAY_HAVE_VALUE:\n            JsonToken t = _parser.getCurrentToken();\n            if (t == null) { \n                t = _parser.nextToken();\n                \n                if (t == null || t == JsonToken.END_ARRAY) {\n                    _state = STATE_CLOSED;\n                    if (_closeParser && (_parser != null)) {\n                        _parser.close();\n                    }\n                    return false;\n                }\n            }\n            _state = STATE_HAS_VALUE;\n            return true;\n        case STATE_HAS_VALUE:\n            \n        }\n        return true;\n    }\n\n    public T nextValue() throws IOException {\n        switch (_state) {\n        case STATE_CLOSED:\n            return _throwNoSuchElement();\n        case STATE_NEED_RESYNC: \n        case STATE_MAY_HAVE_VALUE:\n            if (!hasNextValue()) {\n                return _throwNoSuchElement();\n            }\n            break;\n        case STATE_HAS_VALUE:\n            break;\n        }\n\n        int nextState = STATE_NEED_RESYNC;\n        try {\n            T value;\n            if (_updatedValue == null) {\n                value = _deserializer.deserialize(_parser, _context);\n            } else{\n                _deserializer.deserialize(_parser, _context, _updatedValue);\n                value = _updatedValue;\n            }\n            nextState = STATE_MAY_HAVE_VALUE;\n            return value;\n        } finally {\n            _state = nextState;\n            \n            _parser.clearCurrentToken();\n        }\n    }\n\n    \n    public List<T> readAll() throws IOException {\n        return readAll(new ArrayList<T>());\n    }\n\n    \n    public <L extends List<? super T>> L readAll(L resultList) throws IOException {\n        while (hasNextValue()) {\n            resultList.add(nextValue());\n        }\n        return resultList;\n    }\n\n    \n    public <C extends Collection<? super T>> C readAll(C results) throws IOException {\n        while (hasNextValue()) {\n            results.add(nextValue());\n        }\n        return results;\n    }\n    \n    \n\n    \n    public JsonParser getParser() {\n        return _parser;\n    }\n\n    \n    public FormatSchema getParserSchema() {\n    \treturn _parser.getSchema();\n    }\n\n    \n    public JsonLocation getCurrentLocation() {\n        return _parser.getCurrentLocation();\n    }\n\n    \n\n    protected void _resync() throws IOException {\n        final JsonParser p = _parser;\n        \n        if (p.getParsingContext() == _seqContext) {\n            return;\n        }\n\n        while (true) {\n            JsonToken t = p.nextToken();\n            if ((t == JsonToken.END_ARRAY) || (t == JsonToken.END_OBJECT)) {\n                if (p.getParsingContext() == _seqContext) {\n                    p.clearCurrentToken();\n                    return;\n                }\n            } else if ((t == JsonToken.START_ARRAY) || (t == JsonToken.START_OBJECT)) {\n                p.skipChildren();\n            } else if (t == null) {\n                return;\n            }\n        }\n    }\n\n    protected <R> R _throwNoSuchElement() {\n        throw new NoSuchElementException();\n    }\n    \n    protected <R> R _handleMappingException(JsonMappingException e) {\n        throw new RuntimeJsonMappingException(e.getMessage(), e);\n    }\n\n    protected <R> R _handleIOException(IOException e) {\n        throw new RuntimeException(e.getMessage(), e);\n    }\n}\n",
      "buggy_signatures": [
        "protected static <T> MappingIterator<T> emptyIterator()",
        "public boolean hasNext()",
        "public T next()",
        "public void remove()",
        "public void close() throws IOException",
        "public boolean hasNextValue() throws IOException",
        "public T nextValue() throws IOException",
        "public List<T> readAll() throws IOException",
        "public <L extends List<? super T>> L readAll(L resultList) throws IOException",
        "public <C extends Collection<? super T>> C readAll(C results) throws IOException",
        "public JsonParser getParser()",
        "public FormatSchema getParserSchema()",
        "public JsonLocation getCurrentLocation()",
        "protected <R> R _throwNoSuchElement()",
        "protected <R> R _handleMappingException(JsonMappingException e)",
        "protected <R> R _handleIOException(IOException e)"
      ],
      "fixed_signatures": [
        "protected static <T> MappingIterator<T> emptyIterator()",
        "public boolean hasNext()",
        "public T next()",
        "public void remove()",
        "public void close() throws IOException",
        "public boolean hasNextValue() throws IOException",
        "public T nextValue() throws IOException",
        "public List<T> readAll() throws IOException",
        "public <L extends List<? super T>> L readAll(L resultList) throws IOException",
        "public <C extends Collection<? super T>> C readAll(C results) throws IOException",
        "public JsonParser getParser()",
        "public FormatSchema getParserSchema()",
        "public JsonLocation getCurrentLocation()",
        "protected void _resync() throws IOException",
        "protected <R> R _throwNoSuchElement()",
        "protected <R> R _handleMappingException(JsonMappingException e)",
        "protected <R> R _handleIOException(IOException e)"
      ],
      "methods": [
        {
          "buggy_method": "",
          "fixed_method": "",
          "diff": [
            "@@ -25,20 +25,24 @@",
            "     /**\n",
            "      * State in which iterator is closed\n",
            "      */\n",
            "+    protected final static int STATE_CLOSED = 0;\n",
            "     \n",
            "     /**\n",
            "      * State in which value read failed\n",
            "      */\n",
            "+    protected final static int STATE_NEED_RESYNC = 1;\n",
            "     \n",
            "     /**\n",
            "      * State in which no recovery is needed, but \"hasNextValue()\" needs\n",
            "      * to be called first\n",
            "      */\n",
            "+    protected final static int STATE_MAY_HAVE_VALUE = 2;\n",
            " \n",
            "     /**\n",
            "      * State in which \"hasNextValue()\" has been succesfully called\n",
            "      * and deserializer can be called to fetch value\n",
            "      */\n",
            "+    protected final static int STATE_HAS_VALUE = 3;\n",
            " \n",
            "     /*\n",
            "     /**********************************************************\n"
          ],
          "changed_lines": 4
        },
        {
          "buggy_method": "",
          "fixed_method": "",
          "diff": [
            "@@ -66,12 +70,13 @@",
            "      * as not <code>null</code> but set as <code>null</null> when\n",
            "      * iterator is closed, to denote closing.\n",
            "      */\n",
            "-    protected JsonParser _parser;\n",
            "+    protected final JsonParser _parser;\n",
            " \n",
            "     /**\n",
            "      * Context to resynchronize to, in case an exception is encountered\n",
            "      * but caller wants to try to read more elements.\n",
            "      */\n",
            "+    protected final JsonStreamContext _seqContext;\n",
            "     \n",
            "     /**\n",
            "      * If not null, \"value to update\" instead of creating a new instance\n"
          ],
          "changed_lines": 3
        },
        {
          "buggy_method": "",
          "fixed_method": "",
          "diff": [
            "@@ -95,7 +100,7 @@",
            "     /**\n",
            "      * State of the iterator\n",
            "      */\n",
            "-    protected boolean _hasNextChecked;\n",
            "+    protected int _state;\n",
            " \n",
            "     /*\n",
            "     /**********************************************************\n"
          ],
          "changed_lines": 2
        },
        {
          "buggy_method": "  protected MappingIterator(JavaType type, JsonParser p, DeserializationContext ctxt, JsonDeserializer<?> deser, boolean managedParser, Object valueToUpdate) {\n  _type = type;\n  _parser = p;\n  _context = ctxt;\n  _deserializer = (JsonDeserializer<T>) deser;\n  _closeParser = managedParser;\n  if (valueToUpdate == null) {\n  _updatedValue = null;\n  } else {\n  _updatedValue = (T) valueToUpdate;\n  }\n\n  \n  if (managedParser && (p != null) && p.isExpectedStartArrayToken()) {\n  \n  p.clearCurrentToken();\n  \n  \n  \n  }\n  }",
          "fixed_method": "  protected MappingIterator(JavaType type, JsonParser p, DeserializationContext ctxt, JsonDeserializer<?> deser, boolean managedParser, Object valueToUpdate) {\n  _type = type;\n  _parser = p;\n  _context = ctxt;\n  _deserializer = (JsonDeserializer<T>) deser;\n  _closeParser = managedParser;\n  if (valueToUpdate == null) {\n  _updatedValue = null;\n  } else {\n  _updatedValue = (T) valueToUpdate;\n  }\n\n  \n  if (p == null) { \n  _seqContext = null;\n  _state = STATE_CLOSED;\n  } else {\n  JsonStreamContext sctxt = p.getParsingContext();\n  if (managedParser && p.isExpectedStartArrayToken()) {\n  \n  p.clearCurrentToken();\n  } else {\n  \n  \n  \n  JsonToken t = p.getCurrentToken();\n  if ((t == JsonToken.START_OBJECT) || (t == JsonToken.START_ARRAY)) {\n  sctxt = sctxt.getParent();\n  }\n  }\n  _seqContext = sctxt;\n  _state = STATE_MAY_HAVE_VALUE;\n  }\n  }",
          "diff": [
            "@@ -135,12 +140,25 @@",
            "          * and if not, caller needs to hand us JsonParser instead, pointing to\n",
            "          * the first token of the first element.\n",
            "          */\n",
            "-        if (managedParser && (p != null) && p.isExpectedStartArrayToken()) {\n",
            "+        if (p == null) { // can this occur?\n",
            "+            _seqContext = null;\n",
            "+            _state = STATE_CLOSED;\n",
            "+        } else {\n",
            "+            JsonStreamContext sctxt = p.getParsingContext();\n",
            "+            if (managedParser && p.isExpectedStartArrayToken()) {\n",
            "                 // If pointing to START_ARRAY, context should be that ARRAY\n",
            "                 p.clearCurrentToken();\n",
            "+            } else {\n",
            "                 // regardless, recovery context should be whatever context we have now,\n",
            "                 // with sole exception of pointing to a start marker, in which case it's\n",
            "                 // the parent\n",
            "+                JsonToken t = p.getCurrentToken();\n",
            "+                if ((t == JsonToken.START_OBJECT) || (t == JsonToken.START_ARRAY)) {\n",
            "+                    sctxt = sctxt.getParent();\n",
            "+                }\n",
            "+            }\n",
            "+            _seqContext = sctxt;\n",
            "+            _state = STATE_MAY_HAVE_VALUE;\n",
            "         }\n",
            "     }\n",
            " \n"
          ],
          "changed_lines": 15
        },
        {
          "buggy_method": "  public void close() throws IOException {\n  if (_parser != null) {\n  _parser.close();\n  }\n  }",
          "fixed_method": "  public void close() throws IOException {\n  if (_state != STATE_CLOSED) {\n  _state = STATE_CLOSED;\n  if (_parser != null) {\n  _parser.close();\n  }\n  }\n  }",
          "diff": [
            "@@ -186,9 +204,12 @@",
            "     \n",
            "     @Override\n",
            "     public void close() throws IOException {\n",
            "+        if (_state != STATE_CLOSED) {\n",
            "+            _state = STATE_CLOSED;\n",
            "             if (_parser != null) {\n",
            "                 _parser.close();\n",
            "             }\n",
            "+        }\n",
            "     }\n",
            " \n",
            "     /*\n"
          ],
          "changed_lines": 3
        },
        {
          "buggy_method": "  public boolean hasNextValue() throws IOException {\n  if (_parser == null) {\n  return false;\n  \n  }\n  if (!_hasNextChecked) {\n  JsonToken t = _parser.getCurrentToken();\n  _hasNextChecked = true;\n  if (t == null) { \n  t = _parser.nextToken();\n  \n  if (t == null || t == JsonToken.END_ARRAY) {\n  JsonParser jp = _parser;\n  _parser = null;\n  if (_closeParser) {\n  jp.close();\n  }\n  return false;\n  }\n  }\n  \n  }\n  return true;\n  }",
          "fixed_method": "  public boolean hasNextValue() throws IOException {\n  switch (_state) {\n  case STATE_CLOSED:\n  return false;\n  case STATE_NEED_RESYNC:\n  _resync();\n  \n  case STATE_MAY_HAVE_VALUE:\n  JsonToken t = _parser.getCurrentToken();\n  if (t == null) { \n  t = _parser.nextToken();\n  \n  if (t == null || t == JsonToken.END_ARRAY) {\n  _state = STATE_CLOSED;\n  if (_closeParser && (_parser != null)) {\n  _parser.close();\n  }\n  return false;\n  }\n  }\n  _state = STATE_HAS_VALUE;\n  return true;\n  case STATE_HAS_VALUE:\n  \n  }\n  return true;\n  }",
          "diff": [
            "@@ -207,25 +228,28 @@",
            "      */\n",
            "     public boolean hasNextValue() throws IOException\n",
            "     {\n",
            "-        if (_parser == null) {\n",
            "+        switch (_state) {\n",
            "+        case STATE_CLOSED:\n",
            "             return false;\n",
            "+        case STATE_NEED_RESYNC:\n",
            "+            _resync();\n",
            "             // fall-through\n",
            "-        }\n",
            "-        if (!_hasNextChecked) {\n",
            "+        case STATE_MAY_HAVE_VALUE:\n",
            "             JsonToken t = _parser.getCurrentToken();\n",
            "-            _hasNextChecked = true;\n",
            "             if (t == null) { // un-initialized or cleared; find next\n",
            "                 t = _parser.nextToken();\n",
            "                 // If EOF, no more, or if we hit END_ARRAY (although we don't clear the token).\n",
            "                 if (t == null || t == JsonToken.END_ARRAY) {\n",
            "-                    JsonParser jp = _parser;\n",
            "-                    _parser = null;\n",
            "-                    if (_closeParser) {\n",
            "-                        jp.close();\n",
            "+                    _state = STATE_CLOSED;\n",
            "+                    if (_closeParser && (_parser != null)) {\n",
            "+                        _parser.close();\n",
            "                     }\n",
            "                     return false;\n",
            "                 }\n",
            "             }\n",
            "+            _state = STATE_HAS_VALUE;\n",
            "+            return true;\n",
            "+        case STATE_HAS_VALUE:\n",
            "             // fall through\n",
            "         }\n",
            "         return true;\n"
          ],
          "changed_lines": 19
        },
        {
          "buggy_method": "  public T nextValue() throws IOException {\n  if (!_hasNextChecked) {\n  if (!hasNextValue()) {\n  return _throwNoSuchElement();\n  }\n  }\n  if (_parser == null) {\n  return _throwNoSuchElement();\n  }\n  _hasNextChecked = false;\n\n  try {\n  T value;\n  if (_updatedValue == null) {\n  value = _deserializer.deserialize(_parser, _context);\n  } else{\n  _deserializer.deserialize(_parser, _context, _updatedValue);\n  value = _updatedValue;\n  }\n  return value;\n  } finally {\n  \n  _parser.clearCurrentToken();\n  }\n  }",
          "fixed_method": "  public T nextValue() throws IOException {\n  switch (_state) {\n  case STATE_CLOSED:\n  return _throwNoSuchElement();\n  case STATE_NEED_RESYNC: \n  case STATE_MAY_HAVE_VALUE:\n  if (!hasNextValue()) {\n  return _throwNoSuchElement();\n  }\n  break;\n  case STATE_HAS_VALUE:\n  break;\n  }\n\n  int nextState = STATE_NEED_RESYNC;\n  try {\n  T value;\n  if (_updatedValue == null) {\n  value = _deserializer.deserialize(_parser, _context);\n  } else{\n  _deserializer.deserialize(_parser, _context, _updatedValue);\n  value = _updatedValue;\n  }\n  nextState = STATE_MAY_HAVE_VALUE;\n  return value;\n  } finally {\n  _state = nextState;\n  \n  _parser.clearCurrentToken();\n  }\n  }",
          "diff": [
            "@@ -233,16 +257,20 @@",
            " \n",
            "     public T nextValue() throws IOException\n",
            "     {\n",
            "-        if (!_hasNextChecked) {\n",
            "+        switch (_state) {\n",
            "+        case STATE_CLOSED:\n",
            "+            return _throwNoSuchElement();\n",
            "+        case STATE_NEED_RESYNC: // fall-through, will do re-sync\n",
            "+        case STATE_MAY_HAVE_VALUE:\n",
            "             if (!hasNextValue()) {\n",
            "                 return _throwNoSuchElement();\n",
            "             }\n",
            "-        }\n",
            "-        if (_parser == null) {\n",
            "-            return _throwNoSuchElement();\n",
            "-        }\n",
            "-        _hasNextChecked = false;\n",
            "-\n",
            "+            break;\n",
            "+        case STATE_HAS_VALUE:\n",
            "+            break;\n",
            "+        }\n",
            "+\n",
            "+        int nextState = STATE_NEED_RESYNC;\n",
            "         try {\n",
            "             T value;\n",
            "             if (_updatedValue == null) {\n",
            "@@ -251,8 +279,10 @@",
            "                 _deserializer.deserialize(_parser, _context, _updatedValue);\n",
            "                 value = _updatedValue;\n",
            "             }\n",
            "+            nextState = STATE_MAY_HAVE_VALUE;\n",
            "             return value;\n",
            "         } finally {\n",
            "+            _state = nextState;\n",
            "             /* 24-Mar-2015, tatu: As per [#733], need to mark token consumed no\n",
            "              *   matter what, to avoid infinite loop for certain failure cases.\n",
            "              *   For 2.6 need to improve further.\n"
          ],
          "changed_lines": 20
        },
        {
          "buggy_method": "  protected <R> R _throwNoSuchElement() {\n  throw new NoSuchElementException();\n  }",
          "fixed_method": "  protected void _resync() throws IOException {\n  final JsonParser p = _parser;\n  \n  if (p.getParsingContext() == _seqContext) {\n  return;\n  }\n\n  while (true) {\n  JsonToken t = p.nextToken();\n  if ((t == JsonToken.END_ARRAY) || (t == JsonToken.END_OBJECT)) {\n  if (p.getParsingContext() == _seqContext) {\n  p.clearCurrentToken();\n  return;\n  }\n  } else if ((t == JsonToken.START_ARRAY) || (t == JsonToken.START_OBJECT)) {\n  p.skipChildren();\n  } else if (t == null) {\n  return;\n  }\n  }\n  }",
          "diff": [
            "@@ -349,8 +379,28 @@",
            "     /**********************************************************\n",
            "      */\n",
            " \n",
            "+    protected void _resync() throws IOException\n",
            "+    {\n",
            "+        final JsonParser p = _parser;\n",
            "         // First, a quick check to see if we might have been lucky and no re-sync needed\n",
            "-\n",
            "+        if (p.getParsingContext() == _seqContext) {\n",
            "+            return;\n",
            "+        }\n",
            "+\n",
            "+        while (true) {\n",
            "+            JsonToken t = p.nextToken();\n",
            "+            if ((t == JsonToken.END_ARRAY) || (t == JsonToken.END_OBJECT)) {\n",
            "+                if (p.getParsingContext() == _seqContext) {\n",
            "+                    p.clearCurrentToken();\n",
            "+                    return;\n",
            "+                }\n",
            "+            } else if ((t == JsonToken.START_ARRAY) || (t == JsonToken.START_OBJECT)) {\n",
            "+                p.skipChildren();\n",
            "+            } else if (t == null) {\n",
            "+                return;\n",
            "+            }\n",
            "+        }\n",
            "+    }\n",
            " \n",
            "     protected <R> R _throwNoSuchElement() {\n",
            "         throw new NoSuchElementException();\n"
          ],
          "changed_lines": 22
        }
      ]
    }
  ]
}
