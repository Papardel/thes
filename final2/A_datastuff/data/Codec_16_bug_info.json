{
  "bug_id": "16",
  "failed_tests": {
    "org.apache.commons.codec.binary.Base32Test": [
      {
        "methodName": "testCodec200",
        "error": "java.lang.IllegalArgumentException",
        "message": "pad must not be in alphabet or whitespace",
        "fail_line": "        final Base32 codec = new Base32(true, (byte)'W'); // should be allowed",
        "test_source": "  public void testCodec200() {\n  final Base32 codec = new Base32(true, (byte)'W'); // should be allowed\n  assertNotNull(codec);\n  }",
        "stack": [
          "Base32.<init> line 309, Base32.<init> line 193, Base32Test.testCodec200 line 158"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/codec/binary/Base32.java",
      "buggy_full_code": "\n\npackage org.apache.commons.codec.binary;\n\n\npublic class Base32 extends BaseNCodec { private static final int BITS_PER_ENCODED_BYTE = 5; private static final int BYTES_PER_ENCODED_BLOCK = 8; private static final int BYTES_PER_UNENCODED_BLOCK = 5; private static final byte[] CHUNK_SEPARATOR = {'\\r', '\\n'}; private static final byte[] DECODE_TABLE = { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 26, 27, 28, 29, 30, 31, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, }; private static final byte[] ENCODE_TABLE = { 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '2', '3', '4', '5', '6', '7', }; private static final byte[] HEX_DECODE_TABLE = { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, -1, -1, -1, -1, -1, -1, -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, }; private static final byte[] HEX_ENCODE_TABLE = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', }; private static final int MASK_5BITS = 0x1f; private final int decodeSize; private final byte[] decodeTable; private final int encodeSize; private final byte[] encodeTable; private final byte[] lineSeparator; public Base32() {\n        this(false);\n    }\n\n    \n    public Base32(final byte pad) {\n        this(false, pad);\n    }\n\n    \n    public Base32(final boolean useHex) {\n        this(0, null, useHex, PAD_DEFAULT);\n    }\n\n    \n    public Base32(final boolean useHex, final byte pad) {\n        this(0, null, useHex, pad);\n    }\n\n    \n    public Base32(final int lineLength) {\n        this(lineLength, CHUNK_SEPARATOR);\n    }\n\n    \n    public Base32(final int lineLength, final byte[] lineSeparator) {\n        this(lineLength, lineSeparator, false, PAD_DEFAULT);\n    }\n\n    \n    public Base32(final int lineLength, final byte[] lineSeparator, final boolean useHex) {\n        this(lineLength, lineSeparator, useHex, PAD_DEFAULT);\n    }\n\n    \n    public Base32(final int lineLength, final byte[] lineSeparator, final boolean useHex, final byte pad) {\n        super(BYTES_PER_UNENCODED_BLOCK, BYTES_PER_ENCODED_BLOCK, lineLength,\n                lineSeparator == null ? 0 : lineSeparator.length, pad);\n        if (useHex) {\n            this.encodeTable = HEX_ENCODE_TABLE;\n            this.decodeTable = HEX_DECODE_TABLE;\n        } else {\n            this.encodeTable = ENCODE_TABLE;\n            this.decodeTable = DECODE_TABLE;\n        }\n        if (lineLength > 0) {\n            if (lineSeparator == null) {\n                throw new IllegalArgumentException(\"lineLength \" + lineLength + \" > 0, but lineSeparator is null\");\n            }\n            \n            if (containsAlphabetOrPad(lineSeparator)) {\n                final String sep = StringUtils.newStringUtf8(lineSeparator);\n                throw new IllegalArgumentException(\"lineSeparator must not contain Base32 characters: [\" + sep + \"]\");\n            }\n            this.encodeSize = BYTES_PER_ENCODED_BLOCK + lineSeparator.length;\n            this.lineSeparator = new byte[lineSeparator.length];\n            System.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);\n        } else {\n            this.encodeSize = BYTES_PER_ENCODED_BLOCK;\n            this.lineSeparator = null;\n        }\n        this.decodeSize = this.encodeSize - 1;\n\n        if (isInAlphabet(pad) || isWhiteSpace(pad)) {\n            throw new IllegalArgumentException(\"pad must not be in alphabet or whitespace\");\n        }\n    }\n\n    \n    @Override\n    void decode(final byte[] in, int inPos, final int inAvail, final Context context) {\n        \n\n        if (context.eof) {\n            return;\n        }\n        if (inAvail < 0) {\n            context.eof = true;\n        }\n        for (int i = 0; i < inAvail; i++) {\n            final byte b = in[inPos++];\n            if (b == pad) {\n                \n                context.eof = true;\n                break;\n            } else {\n                final byte[] buffer = ensureBufferSize(decodeSize, context);\n                if (b >= 0 && b < this.decodeTable.length) {\n                    final int result = this.decodeTable[b];\n                    if (result >= 0) {\n                        context.modulus = (context.modulus+1) % BYTES_PER_ENCODED_BLOCK;\n                        \n                        context.lbitWorkArea = (context.lbitWorkArea << BITS_PER_ENCODED_BYTE) + result;\n                        if (context.modulus == 0) { \n                            buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 32) & MASK_8BITS);\n                            buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 24) & MASK_8BITS);\n                            buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);\n                            buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);\n                            buffer[context.pos++] = (byte) (context.lbitWorkArea & MASK_8BITS);\n                        }\n                    }\n                }\n            }\n        }\n\n        \n        \n        \n        if (context.eof && context.modulus >= 2) { \n            final byte[] buffer = ensureBufferSize(decodeSize, context);\n\n            \n            switch (context.modulus) {\n                case 2 : \n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 2) & MASK_8BITS);\n                    break;\n                case 3 : \n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 7) & MASK_8BITS);\n                    break;\n                case 4 : \n                    context.lbitWorkArea = context.lbitWorkArea >> 4; \n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);\n                    break;\n                case 5 : \n                    context.lbitWorkArea = context.lbitWorkArea >> 1;\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);\n                    break;\n                case 6 : \n                    context.lbitWorkArea = context.lbitWorkArea >> 6;\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);\n                    break;\n                case 7 : \n                    context.lbitWorkArea = context.lbitWorkArea >> 3;\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 24) & MASK_8BITS);\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);\n                    break;\n                default:\n                    \n                    throw new IllegalStateException(\"Impossible modulus \"+context.modulus);\n            }\n        }\n    }\n\n    \n    @Override\n    void encode(final byte[] in, int inPos, final int inAvail, final Context context) {\n        \n\n        if (context.eof) {\n            return;\n        }\n        \n        \n        if (inAvail < 0) {\n            context.eof = true;\n            if (0 == context.modulus && lineLength == 0) {\n                return; \n            }\n            final byte[] buffer = ensureBufferSize(encodeSize, context);\n            final int savedPos = context.pos;\n            switch (context.modulus) { \n                case 0 :\n                    break;\n                case 1 : \n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 3) & MASK_5BITS]; \n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea << 2) & MASK_5BITS]; \n                    buffer[context.pos++] = pad;\n                    buffer[context.pos++] = pad;\n                    buffer[context.pos++] = pad;\n                    buffer[context.pos++] = pad;\n                    buffer[context.pos++] = pad;\n                    buffer[context.pos++] = pad;\n                    break;\n                case 2 : \n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 11) & MASK_5BITS]; \n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >>  6) & MASK_5BITS]; \n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >>  1) & MASK_5BITS]; \n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea <<  4) & MASK_5BITS]; \n                    buffer[context.pos++] = pad;\n                    buffer[context.pos++] = pad;\n                    buffer[context.pos++] = pad;\n                    buffer[context.pos++] = pad;\n                    break;\n                case 3 : \n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 19) & MASK_5BITS]; \n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 14) & MASK_5BITS]; \n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >>  9) & MASK_5BITS]; \n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >>  4) & MASK_5BITS]; \n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea <<  1) & MASK_5BITS]; \n                    buffer[context.pos++] = pad;\n                    buffer[context.pos++] = pad;\n                    buffer[context.pos++] = pad;\n                    break;\n                case 4 : \n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 27) & MASK_5BITS]; \n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 22) & MASK_5BITS]; \n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 17) & MASK_5BITS]; \n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 12) & MASK_5BITS]; \n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >>  7) & MASK_5BITS]; \n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >>  2) & MASK_5BITS]; \n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea <<  3) & MASK_5BITS]; \n                    buffer[context.pos++] = pad;\n                    break;\n                default:\n                    throw new IllegalStateException(\"Impossible modulus \"+context.modulus);\n            }\n            context.currentLinePos += context.pos - savedPos; \n            \n            if (lineLength > 0 && context.currentLinePos > 0){ \n                System.arraycopy(lineSeparator, 0, buffer, context.pos, lineSeparator.length);\n                context.pos += lineSeparator.length;\n            }\n        } else {\n            for (int i = 0; i < inAvail; i++) {\n                final byte[] buffer = ensureBufferSize(encodeSize, context);\n                context.modulus = (context.modulus+1) % BYTES_PER_UNENCODED_BLOCK;\n                int b = in[inPos++];\n                if (b < 0) {\n                    b += 256;\n                }\n                context.lbitWorkArea = (context.lbitWorkArea << 8) + b; \n                if (0 == context.modulus) { \n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 35) & MASK_5BITS];\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 30) & MASK_5BITS];\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 25) & MASK_5BITS];\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 20) & MASK_5BITS];\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 15) & MASK_5BITS];\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 10) & MASK_5BITS];\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 5) & MASK_5BITS];\n                    buffer[context.pos++] = encodeTable[(int)context.lbitWorkArea & MASK_5BITS];\n                    context.currentLinePos += BYTES_PER_ENCODED_BLOCK;\n                    if (lineLength > 0 && lineLength <= context.currentLinePos) {\n                        System.arraycopy(lineSeparator, 0, buffer, context.pos, lineSeparator.length);\n                        context.pos += lineSeparator.length;\n                        context.currentLinePos = 0;\n                    }\n                }\n            }\n        }\n    }\n\n    \n    @Override\n    public boolean isInAlphabet(final byte octet) {\n        return octet >= 0 && octet < decodeTable.length && decodeTable[octet] != -1;\n    }\n}\n",
      "fixed_full_code": "\n\npackage org.apache.commons.codec.binary;\n\n\npublic class Base32 extends BaseNCodec { private static final int BITS_PER_ENCODED_BYTE = 5; private static final int BYTES_PER_ENCODED_BLOCK = 8; private static final int BYTES_PER_UNENCODED_BLOCK = 5; private static final byte[] CHUNK_SEPARATOR = {'\\r', '\\n'}; private static final byte[] DECODE_TABLE = { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 26, 27, 28, 29, 30, 31, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, }; private static final byte[] ENCODE_TABLE = { 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '2', '3', '4', '5', '6', '7', }; private static final byte[] HEX_DECODE_TABLE = { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, -1, -1, -1, -1, -1, -1, -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, }; private static final byte[] HEX_ENCODE_TABLE = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', }; private static final int MASK_5BITS = 0x1f; private final int decodeSize; private final byte[] decodeTable; private final int encodeSize; private final byte[] encodeTable; private final byte[] lineSeparator; public Base32() {\n        this(false);\n    }\n\n    \n    public Base32(final byte pad) {\n        this(false, pad);\n    }\n\n    \n    public Base32(final boolean useHex) {\n        this(0, null, useHex, PAD_DEFAULT);\n    }\n\n    \n    public Base32(final boolean useHex, final byte pad) {\n        this(0, null, useHex, pad);\n    }\n\n    \n    public Base32(final int lineLength) {\n        this(lineLength, CHUNK_SEPARATOR);\n    }\n\n    \n    public Base32(final int lineLength, final byte[] lineSeparator) {\n        this(lineLength, lineSeparator, false, PAD_DEFAULT);\n    }\n\n    \n    public Base32(final int lineLength, final byte[] lineSeparator, final boolean useHex) {\n        this(lineLength, lineSeparator, useHex, PAD_DEFAULT);\n    }\n\n    \n    public Base32(final int lineLength, final byte[] lineSeparator, final boolean useHex, final byte pad) {\n        super(BYTES_PER_UNENCODED_BLOCK, BYTES_PER_ENCODED_BLOCK, lineLength,\n                lineSeparator == null ? 0 : lineSeparator.length, pad);\n        if (useHex) {\n            this.encodeTable = HEX_ENCODE_TABLE;\n            this.decodeTable = HEX_DECODE_TABLE;\n        } else {\n            this.encodeTable = ENCODE_TABLE;\n            this.decodeTable = DECODE_TABLE;\n        }\n        if (lineLength > 0) {\n            if (lineSeparator == null) {\n                throw new IllegalArgumentException(\"lineLength \" + lineLength + \" > 0, but lineSeparator is null\");\n            }\n            \n            if (containsAlphabetOrPad(lineSeparator)) {\n                final String sep = StringUtils.newStringUtf8(lineSeparator);\n                throw new IllegalArgumentException(\"lineSeparator must not contain Base32 characters: [\" + sep + \"]\");\n            }\n            this.encodeSize = BYTES_PER_ENCODED_BLOCK + lineSeparator.length;\n            this.lineSeparator = new byte[lineSeparator.length];\n            System.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);\n        } else {\n            this.encodeSize = BYTES_PER_ENCODED_BLOCK;\n            this.lineSeparator = null;\n        }\n        this.decodeSize = this.encodeSize - 1;\n\n        if (isInAlphabet(pad) || isWhiteSpace(pad)) {\n            throw new IllegalArgumentException(\"pad must not be in alphabet or whitespace\");\n        }\n    }\n\n    \n    @Override\n    void decode(final byte[] in, int inPos, final int inAvail, final Context context) {\n        \n\n        if (context.eof) {\n            return;\n        }\n        if (inAvail < 0) {\n            context.eof = true;\n        }\n        for (int i = 0; i < inAvail; i++) {\n            final byte b = in[inPos++];\n            if (b == pad) {\n                \n                context.eof = true;\n                break;\n            } else {\n                final byte[] buffer = ensureBufferSize(decodeSize, context);\n                if (b >= 0 && b < this.decodeTable.length) {\n                    final int result = this.decodeTable[b];\n                    if (result >= 0) {\n                        context.modulus = (context.modulus+1) % BYTES_PER_ENCODED_BLOCK;\n                        \n                        context.lbitWorkArea = (context.lbitWorkArea << BITS_PER_ENCODED_BYTE) + result;\n                        if (context.modulus == 0) { \n                            buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 32) & MASK_8BITS);\n                            buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 24) & MASK_8BITS);\n                            buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);\n                            buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);\n                            buffer[context.pos++] = (byte) (context.lbitWorkArea & MASK_8BITS);\n                        }\n                    }\n                }\n            }\n        }\n\n        \n        \n        \n        if (context.eof && context.modulus >= 2) { \n            final byte[] buffer = ensureBufferSize(decodeSize, context);\n\n            \n            switch (context.modulus) {\n                case 2 : \n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 2) & MASK_8BITS);\n                    break;\n                case 3 : \n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 7) & MASK_8BITS);\n                    break;\n                case 4 : \n                    context.lbitWorkArea = context.lbitWorkArea >> 4; \n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);\n                    break;\n                case 5 : \n                    context.lbitWorkArea = context.lbitWorkArea >> 1;\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);\n                    break;\n                case 6 : \n                    context.lbitWorkArea = context.lbitWorkArea >> 6;\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);\n                    break;\n                case 7 : \n                    context.lbitWorkArea = context.lbitWorkArea >> 3;\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 24) & MASK_8BITS);\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);\n                    break;\n                default:\n                    \n                    throw new IllegalStateException(\"Impossible modulus \"+context.modulus);\n            }\n        }\n    }\n\n    \n    @Override\n    void encode(final byte[] in, int inPos, final int inAvail, final Context context) {\n        \n\n        if (context.eof) {\n            return;\n        }\n        \n        \n        if (inAvail < 0) {\n            context.eof = true;\n            if (0 == context.modulus && lineLength == 0) {\n                return; \n            }\n            final byte[] buffer = ensureBufferSize(encodeSize, context);\n            final int savedPos = context.pos;\n            switch (context.modulus) { \n                case 0 :\n                    break;\n                case 1 : \n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 3) & MASK_5BITS]; \n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea << 2) & MASK_5BITS]; \n                    buffer[context.pos++] = pad;\n                    buffer[context.pos++] = pad;\n                    buffer[context.pos++] = pad;\n                    buffer[context.pos++] = pad;\n                    buffer[context.pos++] = pad;\n                    buffer[context.pos++] = pad;\n                    break;\n                case 2 : \n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 11) & MASK_5BITS]; \n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >>  6) & MASK_5BITS]; \n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >>  1) & MASK_5BITS]; \n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea <<  4) & MASK_5BITS]; \n                    buffer[context.pos++] = pad;\n                    buffer[context.pos++] = pad;\n                    buffer[context.pos++] = pad;\n                    buffer[context.pos++] = pad;\n                    break;\n                case 3 : \n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 19) & MASK_5BITS]; \n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 14) & MASK_5BITS]; \n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >>  9) & MASK_5BITS]; \n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >>  4) & MASK_5BITS]; \n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea <<  1) & MASK_5BITS]; \n                    buffer[context.pos++] = pad;\n                    buffer[context.pos++] = pad;\n                    buffer[context.pos++] = pad;\n                    break;\n                case 4 : \n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 27) & MASK_5BITS]; \n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 22) & MASK_5BITS]; \n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 17) & MASK_5BITS]; \n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 12) & MASK_5BITS]; \n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >>  7) & MASK_5BITS]; \n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >>  2) & MASK_5BITS]; \n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea <<  3) & MASK_5BITS]; \n                    buffer[context.pos++] = pad;\n                    break;\n                default:\n                    throw new IllegalStateException(\"Impossible modulus \"+context.modulus);\n            }\n            context.currentLinePos += context.pos - savedPos; \n            \n            if (lineLength > 0 && context.currentLinePos > 0){ \n                System.arraycopy(lineSeparator, 0, buffer, context.pos, lineSeparator.length);\n                context.pos += lineSeparator.length;\n            }\n        } else {\n            for (int i = 0; i < inAvail; i++) {\n                final byte[] buffer = ensureBufferSize(encodeSize, context);\n                context.modulus = (context.modulus+1) % BYTES_PER_UNENCODED_BLOCK;\n                int b = in[inPos++];\n                if (b < 0) {\n                    b += 256;\n                }\n                context.lbitWorkArea = (context.lbitWorkArea << 8) + b; \n                if (0 == context.modulus) { \n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 35) & MASK_5BITS];\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 30) & MASK_5BITS];\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 25) & MASK_5BITS];\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 20) & MASK_5BITS];\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 15) & MASK_5BITS];\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 10) & MASK_5BITS];\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 5) & MASK_5BITS];\n                    buffer[context.pos++] = encodeTable[(int)context.lbitWorkArea & MASK_5BITS];\n                    context.currentLinePos += BYTES_PER_ENCODED_BLOCK;\n                    if (lineLength > 0 && lineLength <= context.currentLinePos) {\n                        System.arraycopy(lineSeparator, 0, buffer, context.pos, lineSeparator.length);\n                        context.pos += lineSeparator.length;\n                        context.currentLinePos = 0;\n                    }\n                }\n            }\n        }\n    }\n\n    \n    @Override\n    public boolean isInAlphabet(final byte octet) {\n        return octet >= 0 && octet < decodeTable.length && decodeTable[octet] != -1;\n    }\n}\n",
      "buggy_signatures": [
        "public Base32(final byte pad)",
        "public Base32(final boolean useHex)",
        "public Base32(final boolean useHex, final byte pad)",
        "public Base32(final int lineLength)",
        "public Base32(final int lineLength, final byte[] lineSeparator)",
        "public Base32(final int lineLength, final byte[] lineSeparator, final boolean useHex)",
        "public Base32(final int lineLength, final byte[] lineSeparator, final boolean useHex, final byte pad)",
        "public boolean isInAlphabet(final byte octet)"
      ],
      "fixed_signatures": [
        "public Base32(final byte pad)",
        "public Base32(final boolean useHex)",
        "public Base32(final boolean useHex, final byte pad)",
        "public Base32(final int lineLength)",
        "public Base32(final int lineLength, final byte[] lineSeparator)",
        "public Base32(final int lineLength, final byte[] lineSeparator, final boolean useHex)",
        "public Base32(final int lineLength, final byte[] lineSeparator, final boolean useHex, final byte pad)",
        "public boolean isInAlphabet(final byte octet)"
      ],
      "methods": [
        {
          "buggy_method": "",
          "fixed_method": "",
          "diff": [
            "@@ -96,7 +96,7 @@",
            "             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 20-2f\n",
            "              0,  1,  2,  3,  4,  5,  6,  7,  8,  9, -1, -1, -1, -1, -1, -1, // 30-3f 2-7\n",
            "             -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, // 40-4f A-O\n",
            "-            25, 26, 27, 28, 29, 30, 31, 32,\n",
            "+            25, 26, 27, 28, 29, 30, 31,                                     // 50-57 P-V\n",
            "     };\n",
            " \n",
            "     /**\n"
          ],
          "changed_lines": 2
        }
      ]
    }
  ]
}
