{
  "bug_id": "1",
  "failed_tests": {
    "com.fasterxml.jackson.dataformat.xml.lists.NestedUnwrappedLists180Test": [
      {
        "methodName": "testNestedUnwrappedLists180",
        "error": "junit.framework.AssertionFailedError",
        "message": "",
        "fail_line": "        assertNotNull(result.records.get(0));",
        "test_source": "  public void testNestedUnwrappedLists180() throws Exception {\n  /*\n  Records recs = new Records();\n  recs.records.add(new Record());\n  recs.records.add(new Record());\n  recs.records.add(new Record());\n  recs.records.get(0).fields.add(new Field(\"a\"));\n  recs.records.get(2).fields.add(new Field(\"b\"));\n\n  String xml = MAPPER.writerWithDefaultPrettyPrinter().writeValueAsString(recs);\n  */\n\n  String xml =\n\"<Records>\\n\"\n// Important: it's the empty CDATA here that causes breakage -- empty element alone would be fine\n//+\"<records>\\n</records>\\n\"\n+\"<records></records>\\n\"\n+\"  <records>\\n\"\n+\"  <fields name='b'/>\\n\"\n+\"  </records>\\n\"\n+\"</Records>\\n\"\n;\n  \n//System.out.println(\"XML: \"+xml);\n\n  Records result = MAPPER.readValue(xml, Records.class);\n  assertNotNull(result.records);\n  assertEquals(2, result.records.size());\n  assertNotNull(result.records.get(1));\n  assertEquals(1, result.records.get(1).fields.size());\n  assertEquals(\"b\", result.records.get(1).fields.get(0).name);\n\n  // also, first one ought not be null should it? Ideally not...\n  assertNotNull(result.records.get(0));\n  }",
        "stack": [
          "NestedUnwrappedLists180Test.testNestedUnwrappedLists180 line 72"
        ]
      }
    ],
    "com.fasterxml.jackson.dataformat.xml.lists.NestedUnwrappedListsTest": [
      {
        "methodName": "testNestedWithEmpty2",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<1> but was:<0>",
        "fail_line": "        assertEquals(1, del.vehicleActivity.size());",
        "test_source": "  public void testNestedWithEmpty2() throws Exception {\n  final String XML =\n\"<ServiceDelivery>\\n\"\n+\"  <ResponseTimestamp>2012-09-12T09:28:17.213-04:00</ResponseTimestamp>\\n\"\n+\"  <VehicleMonitoringDelivery>\\n\"\n+\"  <VehicleActivity>\\n\"\n+\"  </VehicleActivity>\\n\"\n+\"  </VehicleMonitoringDelivery>\\n\"\n+\"</ServiceDelivery>\\n\"\n  ;\n  \n  ServiceDelivery svc = _xmlMapper.readValue(XML, ServiceDelivery.class);\n  assertNotNull(svc);\n  assertNotNull(svc.vehicleMonitoringDelivery);\n  assertEquals(1, svc.vehicleMonitoringDelivery.size());\n  VehicleMonitoringDelivery del = svc.vehicleMonitoringDelivery.get(0);\n  assertNotNull(del.vehicleActivity);\n  // 06-Jan-2015, tatu: Really should have one empty entry, not 0\n  assertEquals(1, del.vehicleActivity.size());\n  }",
        "stack": [
          "NestedUnwrappedListsTest.testNestedWithEmpty2 line 122"
        ]
      },
      {
        "methodName": "testNestedWithEmpty",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<1> but was:<0>",
        "fail_line": "        assertEquals(1, svc.vehicleMonitoringDelivery.size());",
        "test_source": "  public void testNestedWithEmpty() throws Exception {\n  final String XML =\n\"<ServiceDelivery>\\n\"\n+\"  <ResponseTimestamp>2012-09-12T09:28:17.213-04:00</ResponseTimestamp>\\n\"\n+\"  <VehicleMonitoringDelivery>\\n\"\n+\"  </VehicleMonitoringDelivery>\\n\"\n+\"</ServiceDelivery>\\n\"\n  ;\n  \n  ServiceDelivery svc = _xmlMapper.readValue(XML, ServiceDelivery.class);\n  assertNotNull(svc);\n  assertNotNull(svc.vehicleMonitoringDelivery);\n  // 06-Jan-2015, tatu: Really should have one empty entry, not 0\n  assertEquals(1, svc.vehicleMonitoringDelivery.size());\n  }",
        "stack": [
          "NestedUnwrappedListsTest.testNestedWithEmpty line 100"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java",
      "buggy_full_code": "package com.fasterxml.jackson.dataformat.xml.deser;\n\nimport java.io.IOException;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.util.Set;\n\nimport javax.xml.stream.XMLStreamReader;\nimport javax.xml.stream.XMLStreamWriter;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.base.ParserMinimalBase;\nimport com.fasterxml.jackson.core.io.IOContext;\nimport com.fasterxml.jackson.core.util.ByteArrayBuilder;\nimport com.fasterxml.jackson.dataformat.xml.PackageVersion;\nimport com.fasterxml.jackson.dataformat.xml.XmlMapper;\n\n\npublic class FromXmlParser extends ParserMinimalBase { public final static String DEFAULT_UNNAMED_TEXT_PROPERTY = \"\"; public enum Feature implements FormatFeature { ; final boolean _defaultState; final int _mask; public static int collectDefaults() {\n            int flags = 0;\n            for (Feature f : values()) {\n                if (f.enabledByDefault()) {\n                    flags |= f.getMask();\n                }\n            }\n            return flags;\n        }\n        \n        private Feature(boolean defaultState) {\n            _defaultState = defaultState;\n            _mask = (1 << ordinal());\n        }\n\n        @Override public boolean enabledByDefault() { return _defaultState; }\n        @Override public int getMask() { return _mask; }\n        @Override public boolean enabledIn(int flags) { return (flags & getMask()) != 0; }\n    }\n\n    \n    protected String _cfgNameForTextElement = DEFAULT_UNNAMED_TEXT_PROPERTY; protected int _formatFeatures; protected ObjectCodec _objectCodec; protected boolean _closed; final protected IOContext _ioContext; protected XmlReadContext _parsingContext; protected final XmlTokenStream _xmlTokens; protected boolean _mayBeLeaf; protected JsonToken _nextToken; protected String _currText; protected Set<String> _namesToWrap; protected ByteArrayBuilder _byteArrayBuilder = null; protected byte[] _binaryValue; public FromXmlParser(IOContext ctxt, int genericParserFeatures, int xmlFeatures, ObjectCodec codec, XMLStreamReader xmlReader) {\n        super(genericParserFeatures);\n        _formatFeatures = xmlFeatures;\n        _ioContext = ctxt;\n        _objectCodec = codec;\n        _parsingContext = XmlReadContext.createRootContext(-1, -1);\n        \n        _nextToken = JsonToken.START_OBJECT;\n        _xmlTokens = new XmlTokenStream(xmlReader, ctxt.getSourceReference());\n    }\n\n    @Override\n    public Version version() {\n        return PackageVersion.VERSION;\n    }\n    \n    @Override\n    public ObjectCodec getCodec() {\n        return _objectCodec;\n    }\n\n    @Override\n    public void setCodec(ObjectCodec c) {\n        _objectCodec = c;\n    }\n\n    \n    public void setXMLTextElementName(String name) {\n        _cfgNameForTextElement = name;\n    }\n    \n    \n    @Override\n    public boolean requiresCustomCodec() {\n        return true;\n    }\n    \n    \n\n    public FromXmlParser enable(Feature f) {\n        _formatFeatures |= f.getMask();\n        return this;\n    }\n\n    public FromXmlParser disable(Feature f) {\n        _formatFeatures &= ~f.getMask();\n        return this;\n    }\n\n    public final boolean isEnabled(Feature f) {\n        return (_formatFeatures & f.getMask()) != 0;\n    }\n\n    public FromXmlParser configure(Feature f, boolean state) {\n        if (state) {\n            enable(f);\n        } else {\n            disable(f);\n        }\n        return this;\n    }\n\n    \n\n    @Override\n    public int getFormatFeatures() {\n        return _formatFeatures;\n    }\n\n    @Override\n    public JsonParser overrideFormatFeatures(int values, int mask) {\n        _formatFeatures = (_formatFeatures & ~mask) | (values & mask);\n        return this;\n    }\n\n    \n\n    \n    public XMLStreamReader getStaxReader() {\n        return _xmlTokens.getXmlReader();\n    }\n\n    \n\n    \n    public void addVirtualWrapping(Set<String> namesToWrap) {\n        \n        String name = _xmlTokens.getLocalName();\n        if (name != null && namesToWrap.contains(name)) {\n            _xmlTokens.repeatStartElement();\n        }\n        _namesToWrap = namesToWrap;\n        _parsingContext.setNamesToWrap(namesToWrap);\n    }\n\n    \n    \n    \n    @Override\n    public String getCurrentName() throws IOException {\n        \n        String name;\n        if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\n            XmlReadContext parent = _parsingContext.getParent();\n            name = parent.getCurrentName();\n        } else {\n            name = _parsingContext.getCurrentName();\n        }\n        \n        if (name == null) {\n            throw new IllegalStateException(\"Missing name, in state: \"+_currToken);\n        }\n        return name;\n    }\n\n    @Override\n    public void overrideCurrentName(String name) {\n        \n        XmlReadContext ctxt = _parsingContext;\n        if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\n            ctxt = ctxt.getParent();\n        }\n        ctxt.setCurrentName(name);\n    }\n    \n    @Override\n    public void close() throws IOException {\n        if (!_closed) {\n            _closed = true;\n            try {\n                if (_ioContext.isResourceManaged() || isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)) {\n                    _xmlTokens.closeCompletely();\n                } else {\n                    _xmlTokens.close();\n                }\n            } finally {\n                \n                \n                _releaseBuffers();\n            }\n        }\n    }\n\n    @Override\n    public boolean isClosed() { return _closed; }\n\n    @Override\n    public XmlReadContext getParsingContext() {\n        return _parsingContext;\n    }\n\n    \n    @Override\n    public JsonLocation getTokenLocation() {\n        return _xmlTokens.getTokenLocation();\n    }\n\n    \n    @Override\n    public JsonLocation getCurrentLocation() {\n        return _xmlTokens.getCurrentLocation();\n    }\n\n    \n    @Override\n    public boolean isExpectedStartArrayToken() {\n        JsonToken t = _currToken;\n        if (t == JsonToken.START_OBJECT) {        \t\n            _currToken = JsonToken.START_ARRAY;\n            \n            _parsingContext.convertToArray();\n\n            \n            _nextToken = null;\n            \n            _xmlTokens.skipAttributes();\n            return true;\n        }\n\n        return (t == JsonToken.START_ARRAY);\n    }\n\n    \n\n\n    @Override\n    public JsonToken nextToken() throws IOException {\n        _binaryValue = null;\n        if (_nextToken != null) {\n            JsonToken t = _nextToken;\n            _currToken = t;\n            _nextToken = null;\n            switch (t) {\n            case START_OBJECT:\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                break;\n            case START_ARRAY:\n                _parsingContext = _parsingContext.createChildArrayContext(-1, -1);\n                break;\n            case END_OBJECT:\n            case END_ARRAY:\n                _parsingContext = _parsingContext.getParent();\n                _namesToWrap = _parsingContext.getNamesToWrap();\n                break;\n            case FIELD_NAME:\n                _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n                break;\n            default: \n                \n            }\n            return t;\n        }\n        int token = _xmlTokens.next();\n\n        \n        \n        while (token == XmlTokenStream.XML_START_ELEMENT) {\n            \n            if (_mayBeLeaf) {\n                \n                _nextToken = JsonToken.FIELD_NAME;\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                return (_currToken = JsonToken.START_OBJECT);\n            }\n            if (_parsingContext.inArray()) {\n                \n                \n                token = _xmlTokens.next();\n                _mayBeLeaf = true;\n                continue;\n            }\n            String name = _xmlTokens.getLocalName();\n            _parsingContext.setCurrentName(name);\n\n            \n            \n            if (_namesToWrap != null && _namesToWrap.contains(name)) {\n                _xmlTokens.repeatStartElement();\n            }\n\n            _mayBeLeaf = true;\n            \n            \n            return (_currToken = JsonToken.FIELD_NAME);\n        }\n\n        \n        switch (token) {\n        case XmlTokenStream.XML_END_ELEMENT:\n            \n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                    \n                    \n                return (_currToken = JsonToken.VALUE_NULL);\n            }\n            _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n            _parsingContext = _parsingContext.getParent();\n            _namesToWrap = _parsingContext.getNamesToWrap();\n            return _currToken;\n            \n        case XmlTokenStream.XML_ATTRIBUTE_NAME:\n            \n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                _nextToken = JsonToken.FIELD_NAME;\n                _currText = _xmlTokens.getText();\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                return (_currToken = JsonToken.START_OBJECT);\n            }\n            _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n            return (_currToken = JsonToken.FIELD_NAME);\n        case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n            _currText = _xmlTokens.getText();\n            return (_currToken = JsonToken.VALUE_STRING);\n        case XmlTokenStream.XML_TEXT:\n            _currText = _xmlTokens.getText();\n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                \n                \n                _xmlTokens.skipEndElement();\n                if (_parsingContext.inArray()) {\n                    if (_isEmpty(_currText)) {\n                        \n                        \n                        \n                        _currToken = JsonToken.END_ARRAY;\n                        _parsingContext = _parsingContext.getParent();\n                        _namesToWrap = _parsingContext.getNamesToWrap();\n                        return _currToken;\n                    }\n                }\n                return (_currToken = JsonToken.VALUE_STRING);\n            } else {\n                \n                if (_parsingContext.inObject()\n                        && (_currToken != JsonToken.FIELD_NAME) && _isEmpty(_currText)) {\n                    _currToken = JsonToken.END_OBJECT;\n                    _parsingContext = _parsingContext.getParent();\n                    _namesToWrap = _parsingContext.getNamesToWrap();\n                    return _currToken;\n                }\n            }\n            \n            _parsingContext.setCurrentName(_cfgNameForTextElement);\n            _nextToken = JsonToken.VALUE_STRING;\n            return (_currToken = JsonToken.FIELD_NAME);\n        case XmlTokenStream.XML_END:\n            return (_currToken = null);\n        }\n        \n        \n        _throwInternal();\n        return null;\n    }\n    \n    \n\n    \n    @Override\n    public String nextTextValue() throws IOException {\n        _binaryValue = null;\n        if (_nextToken != null) {\n            JsonToken t = _nextToken;\n            _currToken = t;\n            _nextToken = null;\n\n            \n            if (t == JsonToken.VALUE_STRING) {\n                return _currText;\n            }\n            _updateState(t);\n            return null;\n        }\n\n        int token = _xmlTokens.next();\n\n        \n        while (token == XmlTokenStream.XML_START_ELEMENT) {\n            if (_mayBeLeaf) {\n                _nextToken = JsonToken.FIELD_NAME;\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                _currToken = JsonToken.START_OBJECT;\n                return null;\n            }\n            if (_parsingContext.inArray()) {\n                token = _xmlTokens.next();\n                _mayBeLeaf = true;\n                continue;\n            }\n            String name = _xmlTokens.getLocalName();\n            _parsingContext.setCurrentName(name);\n            if (_namesToWrap != null && _namesToWrap.contains(name)) {\n                _xmlTokens.repeatStartElement();\n            }\n            _mayBeLeaf = true;\n            _currToken = JsonToken.FIELD_NAME;\n            return null;\n        }\n\n        \n        switch (token) {\n        case XmlTokenStream.XML_END_ELEMENT:\n            if (_mayBeLeaf) {\n                \n                _mayBeLeaf = false;\n                _currToken = JsonToken.VALUE_STRING;\n                return (_currText = \"\");\n            }\n            _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n            _parsingContext = _parsingContext.getParent();\n            _namesToWrap = _parsingContext.getNamesToWrap();\n            break;\n            \n        case XmlTokenStream.XML_ATTRIBUTE_NAME:\n            \n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                _nextToken = JsonToken.FIELD_NAME;\n                _currText = _xmlTokens.getText();\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                _currToken = JsonToken.START_OBJECT;\n            } else {\n                _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n                _currToken = JsonToken.FIELD_NAME;\n            }\n            break;\n        case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n            _currText = _xmlTokens.getText();\n            _currToken = JsonToken.VALUE_STRING;\n            break;\n        case XmlTokenStream.XML_TEXT:\n            _currText = _xmlTokens.getText();\n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                \n                _xmlTokens.skipEndElement();\n\n                \n                \n                _currToken = JsonToken.VALUE_STRING;\n                return _currText;\n            }\n            \n            _parsingContext.setCurrentName(_cfgNameForTextElement);\n            _nextToken = JsonToken.VALUE_STRING;\n            _currToken = JsonToken.FIELD_NAME;\n            break;\n        case XmlTokenStream.XML_END:\n            _currToken = null;\n        }\n        return null;\n    }\n\n\n    private void _updateState(JsonToken t) {\n        switch (t) {\n        case START_OBJECT:\n            _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n            break;\n        case START_ARRAY:\n            _parsingContext = _parsingContext.createChildArrayContext(-1, -1);\n            break;\n        case END_OBJECT:\n        case END_ARRAY:\n            _parsingContext = _parsingContext.getParent();\n            _namesToWrap = _parsingContext.getNamesToWrap();\n            break;\n        case FIELD_NAME:\n            _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n            break;\n        default:\n        }\n    }\n\n    \n\n    @Override\n    public String getText() throws IOException {\n        if (_currToken == null) {\n            return null;\n        }\n        switch (_currToken) {\n        case FIELD_NAME:\n            return getCurrentName();\n        case VALUE_STRING:\n            return _currText;\n        default:\n            return _currToken.asString();\n        }\n    }\n\n    \n    @Override\n    public final String getValueAsString() throws IOException {\n        return getValueAsString(null);\n    }\n\n    @Override\n    public String getValueAsString(String defValue) throws IOException {\n        JsonToken t = _currToken;\n        if (t == null) {\n            return null;\n        }\n        switch (t) {\n        case FIELD_NAME:\n            return getCurrentName();\n        case VALUE_STRING:\n            return _currText;\n        case START_OBJECT:\n            \n            \n            \n            {\n                String str = _xmlTokens.convertToString();\n                if (str != null) {\n                    \n                    \n                    \n                    _parsingContext = _parsingContext.getParent();\n                    _namesToWrap = _parsingContext.getNamesToWrap();\n                    _currToken = JsonToken.VALUE_STRING;\n                    _nextToken = null;\n                    \n                    _xmlTokens.skipEndElement();\n                    return (_currText = str);\n                }\n                \n            }\n            return null;\n        default:\n            if (_currToken.isScalarValue()) {\n                return _currToken.asString();\n            }\n        }\n        return defValue;\n    }\n    \n    @Override\n    public char[] getTextCharacters() throws IOException {\n        String text = getText();\n        return (text == null)  ? null : text.toCharArray();\n    }\n\n    @Override\n    public int getTextLength() throws IOException {\n        String text = getText();\n        return (text == null)  ? 0 : text.length();\n    }\n\n    @Override\n    public int getTextOffset() throws IOException {\n        return 0;\n    }\n\n    \n    @Override\n    public boolean hasTextCharacters() {\n        return false;\n    }\n\n    \n\n    @Override\n    public Object getEmbeddedObject() throws IOException {\n        \n        return null;\n    }\n\n    @Override\n    public byte[] getBinaryValue(Base64Variant b64variant) throws IOException {\n        if (_currToken != JsonToken.VALUE_STRING &&\n                (_currToken != JsonToken.VALUE_EMBEDDED_OBJECT || _binaryValue == null)) {\n            _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\");\n        }\n        \n        if (_binaryValue == null) {\n            try {\n                _binaryValue = _decodeBase64(b64variant);\n            } catch (IllegalArgumentException iae) {\n                throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage());\n            }\n        }        \n        return _binaryValue;\n    }\n\n    @SuppressWarnings(\"resource\")\n    protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException {\n        ByteArrayBuilder builder = _getByteArrayBuilder();\n        final String str = getText();\n        _decodeBase64(str, builder, b64variant);\n        return builder.toByteArray();\n    }\n    \n    \n\n    @Override\n    public BigInteger getBigIntegerValue() throws IOException {\n        \n        return null;\n    }\n\n    @Override\n    public BigDecimal getDecimalValue() throws IOException {\n        \n        return null;\n    }\n\n    @Override\n    public double getDoubleValue() throws IOException {\n        \n        return 0;\n    }\n\n    @Override\n    public float getFloatValue() throws IOException {\n        \n        return 0;\n    }\n\n    @Override\n    public int getIntValue() throws IOException {\n        \n        return 0;\n    }\n\n    @Override\n    public long getLongValue() throws IOException {\n        \n        return 0;\n    }\n\n    @Override\n    public NumberType getNumberType() throws IOException {\n        \n        return null;\n    }\n\n    @Override\n    public Number getNumberValue() throws IOException {\n        \n        return null;\n    }\n\n    \n\n    \n    @Override\n    protected void _handleEOF() throws JsonParseException {\n        if (!_parsingContext.inRoot()) {\n            _reportInvalidEOF(\": expected close marker for \"+_parsingContext.getTypeDesc()+\" (from \"+_parsingContext.getStartLocation(_ioContext.getSourceReference())+\")\");\n        }\n    }\n    \n    \n\n    \n    protected void _releaseBuffers() throws IOException {\n        \n    }\n\n    protected ByteArrayBuilder _getByteArrayBuilder() {\n        if (_byteArrayBuilder == null) {\n            _byteArrayBuilder = new ByteArrayBuilder();\n        } else {\n            _byteArrayBuilder.reset();\n        }\n        return _byteArrayBuilder;\n    }\n\n    protected boolean _isEmpty(String str) {\n        int len = (str == null) ? 0 : str.length();\n        if (len > 0) {\n            for (int i = 0; i < len; ++i) {\n                if (str.charAt(i) > ' ') {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n}\n",
      "fixed_full_code": "package com.fasterxml.jackson.dataformat.xml.deser;\n\nimport java.io.IOException;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.util.Set;\n\nimport javax.xml.stream.XMLStreamReader;\nimport javax.xml.stream.XMLStreamWriter;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.base.ParserMinimalBase;\nimport com.fasterxml.jackson.core.io.IOContext;\nimport com.fasterxml.jackson.core.util.ByteArrayBuilder;\nimport com.fasterxml.jackson.dataformat.xml.PackageVersion;\nimport com.fasterxml.jackson.dataformat.xml.XmlMapper;\n\n\npublic class FromXmlParser extends ParserMinimalBase { public final static String DEFAULT_UNNAMED_TEXT_PROPERTY = \"\"; public enum Feature implements FormatFeature { ; final boolean _defaultState; final int _mask; public static int collectDefaults() {\n            int flags = 0;\n            for (Feature f : values()) {\n                if (f.enabledByDefault()) {\n                    flags |= f.getMask();\n                }\n            }\n            return flags;\n        }\n        \n        private Feature(boolean defaultState) {\n            _defaultState = defaultState;\n            _mask = (1 << ordinal());\n        }\n\n        @Override public boolean enabledByDefault() { return _defaultState; }\n        @Override public int getMask() { return _mask; }\n        @Override public boolean enabledIn(int flags) { return (flags & getMask()) != 0; }\n    }\n\n    \n    protected String _cfgNameForTextElement = DEFAULT_UNNAMED_TEXT_PROPERTY; protected int _formatFeatures; protected ObjectCodec _objectCodec; protected boolean _closed; final protected IOContext _ioContext; protected XmlReadContext _parsingContext; protected final XmlTokenStream _xmlTokens; protected boolean _mayBeLeaf; protected JsonToken _nextToken; protected String _currText; protected Set<String> _namesToWrap; protected ByteArrayBuilder _byteArrayBuilder = null; protected byte[] _binaryValue; public FromXmlParser(IOContext ctxt, int genericParserFeatures, int xmlFeatures, ObjectCodec codec, XMLStreamReader xmlReader) {\n        super(genericParserFeatures);\n        _formatFeatures = xmlFeatures;\n        _ioContext = ctxt;\n        _objectCodec = codec;\n        _parsingContext = XmlReadContext.createRootContext(-1, -1);\n        \n        _nextToken = JsonToken.START_OBJECT;\n        _xmlTokens = new XmlTokenStream(xmlReader, ctxt.getSourceReference());\n    }\n\n    @Override\n    public Version version() {\n        return PackageVersion.VERSION;\n    }\n    \n    @Override\n    public ObjectCodec getCodec() {\n        return _objectCodec;\n    }\n\n    @Override\n    public void setCodec(ObjectCodec c) {\n        _objectCodec = c;\n    }\n\n    \n    public void setXMLTextElementName(String name) {\n        _cfgNameForTextElement = name;\n    }\n    \n    \n    @Override\n    public boolean requiresCustomCodec() {\n        return true;\n    }\n    \n    \n\n    public FromXmlParser enable(Feature f) {\n        _formatFeatures |= f.getMask();\n        return this;\n    }\n\n    public FromXmlParser disable(Feature f) {\n        _formatFeatures &= ~f.getMask();\n        return this;\n    }\n\n    public final boolean isEnabled(Feature f) {\n        return (_formatFeatures & f.getMask()) != 0;\n    }\n\n    public FromXmlParser configure(Feature f, boolean state) {\n        if (state) {\n            enable(f);\n        } else {\n            disable(f);\n        }\n        return this;\n    }\n\n    \n\n    @Override\n    public int getFormatFeatures() {\n        return _formatFeatures;\n    }\n\n    @Override\n    public JsonParser overrideFormatFeatures(int values, int mask) {\n        _formatFeatures = (_formatFeatures & ~mask) | (values & mask);\n        return this;\n    }\n\n    \n\n    \n    public XMLStreamReader getStaxReader() {\n        return _xmlTokens.getXmlReader();\n    }\n\n    \n\n    \n    public void addVirtualWrapping(Set<String> namesToWrap) {\n        \n        String name = _xmlTokens.getLocalName();\n        if (name != null && namesToWrap.contains(name)) {\n            _xmlTokens.repeatStartElement();\n        }\n        _namesToWrap = namesToWrap;\n        _parsingContext.setNamesToWrap(namesToWrap);\n    }\n\n    \n    \n    \n    @Override\n    public String getCurrentName() throws IOException {\n        \n        String name;\n        if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\n            XmlReadContext parent = _parsingContext.getParent();\n            name = parent.getCurrentName();\n        } else {\n            name = _parsingContext.getCurrentName();\n        }\n        \n        if (name == null) {\n            throw new IllegalStateException(\"Missing name, in state: \"+_currToken);\n        }\n        return name;\n    }\n\n    @Override\n    public void overrideCurrentName(String name) {\n        \n        XmlReadContext ctxt = _parsingContext;\n        if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\n            ctxt = ctxt.getParent();\n        }\n        ctxt.setCurrentName(name);\n    }\n    \n    @Override\n    public void close() throws IOException {\n        if (!_closed) {\n            _closed = true;\n            try {\n                if (_ioContext.isResourceManaged() || isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)) {\n                    _xmlTokens.closeCompletely();\n                } else {\n                    _xmlTokens.close();\n                }\n            } finally {\n                \n                \n                _releaseBuffers();\n            }\n        }\n    }\n\n    @Override\n    public boolean isClosed() { return _closed; }\n\n    @Override\n    public XmlReadContext getParsingContext() {\n        return _parsingContext;\n    }\n\n    \n    @Override\n    public JsonLocation getTokenLocation() {\n        return _xmlTokens.getTokenLocation();\n    }\n\n    \n    @Override\n    public JsonLocation getCurrentLocation() {\n        return _xmlTokens.getCurrentLocation();\n    }\n\n    \n    @Override\n    public boolean isExpectedStartArrayToken() {\n        JsonToken t = _currToken;\n        if (t == JsonToken.START_OBJECT) {        \t\n            _currToken = JsonToken.START_ARRAY;\n            \n            _parsingContext.convertToArray();\n\n            \n            _nextToken = null;\n            \n            _xmlTokens.skipAttributes();\n            return true;\n        }\n\n        return (t == JsonToken.START_ARRAY);\n    }\n\n    \n\n\n    @Override\n    public JsonToken nextToken() throws IOException {\n        _binaryValue = null;\n        if (_nextToken != null) {\n            JsonToken t = _nextToken;\n            _currToken = t;\n            _nextToken = null;\n            switch (t) {\n            case START_OBJECT:\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                break;\n            case START_ARRAY:\n                _parsingContext = _parsingContext.createChildArrayContext(-1, -1);\n                break;\n            case END_OBJECT:\n            case END_ARRAY:\n                _parsingContext = _parsingContext.getParent();\n                _namesToWrap = _parsingContext.getNamesToWrap();\n                break;\n            case FIELD_NAME:\n                _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n                break;\n            default: \n                \n            }\n            return t;\n        }\n        int token = _xmlTokens.next();\n\n        \n        \n        while (token == XmlTokenStream.XML_START_ELEMENT) {\n            \n            if (_mayBeLeaf) {\n                \n                _nextToken = JsonToken.FIELD_NAME;\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                return (_currToken = JsonToken.START_OBJECT);\n            }\n            if (_parsingContext.inArray()) {\n                \n                \n                token = _xmlTokens.next();\n                _mayBeLeaf = true;\n                continue;\n            }\n            String name = _xmlTokens.getLocalName();\n            _parsingContext.setCurrentName(name);\n\n            \n            \n            if (_namesToWrap != null && _namesToWrap.contains(name)) {\n                _xmlTokens.repeatStartElement();\n            }\n\n            _mayBeLeaf = true;\n            \n            \n            return (_currToken = JsonToken.FIELD_NAME);\n        }\n\n        \n        switch (token) {\n        case XmlTokenStream.XML_END_ELEMENT:\n            \n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                if (_parsingContext.inArray()) {\n                    \n                    \n                    _nextToken = JsonToken.END_OBJECT;\n                    _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                    return (_currToken = JsonToken.START_OBJECT);\n                }\n                return (_currToken = JsonToken.VALUE_NULL);\n            }\n            _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n            _parsingContext = _parsingContext.getParent();\n            _namesToWrap = _parsingContext.getNamesToWrap();\n            return _currToken;\n            \n        case XmlTokenStream.XML_ATTRIBUTE_NAME:\n            \n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                _nextToken = JsonToken.FIELD_NAME;\n                _currText = _xmlTokens.getText();\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                return (_currToken = JsonToken.START_OBJECT);\n            }\n            _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n            return (_currToken = JsonToken.FIELD_NAME);\n        case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n            _currText = _xmlTokens.getText();\n            return (_currToken = JsonToken.VALUE_STRING);\n        case XmlTokenStream.XML_TEXT:\n            _currText = _xmlTokens.getText();\n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                \n                \n                _xmlTokens.skipEndElement();\n                if (_parsingContext.inArray()) {\n                    if (_isEmpty(_currText)) {\n                        \n                        \n                        \n                        _nextToken = JsonToken.END_OBJECT;\n                        _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                        return (_currToken = JsonToken.START_OBJECT);\n                    }\n                }\n                return (_currToken = JsonToken.VALUE_STRING);\n            } else {\n                \n                if (_parsingContext.inObject()\n                        && (_currToken != JsonToken.FIELD_NAME) && _isEmpty(_currText)) {\n                    _currToken = JsonToken.END_OBJECT;\n                    _parsingContext = _parsingContext.getParent();\n                    _namesToWrap = _parsingContext.getNamesToWrap();\n                    return _currToken;\n                }\n            }\n            \n            _parsingContext.setCurrentName(_cfgNameForTextElement);\n            _nextToken = JsonToken.VALUE_STRING;\n            return (_currToken = JsonToken.FIELD_NAME);\n        case XmlTokenStream.XML_END:\n            return (_currToken = null);\n        }\n        \n        \n        _throwInternal();\n        return null;\n    }\n    \n    \n\n    \n    @Override\n    public String nextTextValue() throws IOException {\n        _binaryValue = null;\n        if (_nextToken != null) {\n            JsonToken t = _nextToken;\n            _currToken = t;\n            _nextToken = null;\n\n            \n            if (t == JsonToken.VALUE_STRING) {\n                return _currText;\n            }\n            _updateState(t);\n            return null;\n        }\n\n        int token = _xmlTokens.next();\n\n        \n        while (token == XmlTokenStream.XML_START_ELEMENT) {\n            if (_mayBeLeaf) {\n                _nextToken = JsonToken.FIELD_NAME;\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                _currToken = JsonToken.START_OBJECT;\n                return null;\n            }\n            if (_parsingContext.inArray()) {\n                token = _xmlTokens.next();\n                _mayBeLeaf = true;\n                continue;\n            }\n            String name = _xmlTokens.getLocalName();\n            _parsingContext.setCurrentName(name);\n            if (_namesToWrap != null && _namesToWrap.contains(name)) {\n                _xmlTokens.repeatStartElement();\n            }\n            _mayBeLeaf = true;\n            _currToken = JsonToken.FIELD_NAME;\n            return null;\n        }\n\n        \n        switch (token) {\n        case XmlTokenStream.XML_END_ELEMENT:\n            if (_mayBeLeaf) {\n                \n                _mayBeLeaf = false;\n                _currToken = JsonToken.VALUE_STRING;\n                return (_currText = \"\");\n            }\n            _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n            _parsingContext = _parsingContext.getParent();\n            _namesToWrap = _parsingContext.getNamesToWrap();\n            break;\n            \n        case XmlTokenStream.XML_ATTRIBUTE_NAME:\n            \n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                _nextToken = JsonToken.FIELD_NAME;\n                _currText = _xmlTokens.getText();\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                _currToken = JsonToken.START_OBJECT;\n            } else {\n                _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n                _currToken = JsonToken.FIELD_NAME;\n            }\n            break;\n        case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n            _currText = _xmlTokens.getText();\n            _currToken = JsonToken.VALUE_STRING;\n            break;\n        case XmlTokenStream.XML_TEXT:\n            _currText = _xmlTokens.getText();\n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                \n                _xmlTokens.skipEndElement();\n\n                \n                \n                _currToken = JsonToken.VALUE_STRING;\n                return _currText;\n            }\n            \n            _parsingContext.setCurrentName(_cfgNameForTextElement);\n            _nextToken = JsonToken.VALUE_STRING;\n            _currToken = JsonToken.FIELD_NAME;\n            break;\n        case XmlTokenStream.XML_END:\n            _currToken = null;\n        }\n        return null;\n    }\n\n\n    private void _updateState(JsonToken t) {\n        switch (t) {\n        case START_OBJECT:\n            _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n            break;\n        case START_ARRAY:\n            _parsingContext = _parsingContext.createChildArrayContext(-1, -1);\n            break;\n        case END_OBJECT:\n        case END_ARRAY:\n            _parsingContext = _parsingContext.getParent();\n            _namesToWrap = _parsingContext.getNamesToWrap();\n            break;\n        case FIELD_NAME:\n            _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n            break;\n        default:\n        }\n    }\n\n    \n\n    @Override\n    public String getText() throws IOException {\n        if (_currToken == null) {\n            return null;\n        }\n        switch (_currToken) {\n        case FIELD_NAME:\n            return getCurrentName();\n        case VALUE_STRING:\n            return _currText;\n        default:\n            return _currToken.asString();\n        }\n    }\n\n    \n    @Override\n    public final String getValueAsString() throws IOException {\n        return getValueAsString(null);\n    }\n\n    @Override\n    public String getValueAsString(String defValue) throws IOException {\n        JsonToken t = _currToken;\n        if (t == null) {\n            return null;\n        }\n        switch (t) {\n        case FIELD_NAME:\n            return getCurrentName();\n        case VALUE_STRING:\n            return _currText;\n        case START_OBJECT:\n            \n            \n            \n            {\n                String str = _xmlTokens.convertToString();\n                if (str != null) {\n                    \n                    \n                    \n                    _parsingContext = _parsingContext.getParent();\n                    _namesToWrap = _parsingContext.getNamesToWrap();\n                    _currToken = JsonToken.VALUE_STRING;\n                    _nextToken = null;\n                    \n                    _xmlTokens.skipEndElement();\n                    return (_currText = str);\n                }\n                \n            }\n            return null;\n        default:\n            if (_currToken.isScalarValue()) {\n                return _currToken.asString();\n            }\n        }\n        return defValue;\n    }\n    \n    @Override\n    public char[] getTextCharacters() throws IOException {\n        String text = getText();\n        return (text == null)  ? null : text.toCharArray();\n    }\n\n    @Override\n    public int getTextLength() throws IOException {\n        String text = getText();\n        return (text == null)  ? 0 : text.length();\n    }\n\n    @Override\n    public int getTextOffset() throws IOException {\n        return 0;\n    }\n\n    \n    @Override\n    public boolean hasTextCharacters() {\n        return false;\n    }\n\n    \n\n    @Override\n    public Object getEmbeddedObject() throws IOException {\n        \n        return null;\n    }\n\n    @Override\n    public byte[] getBinaryValue(Base64Variant b64variant) throws IOException {\n        if (_currToken != JsonToken.VALUE_STRING &&\n                (_currToken != JsonToken.VALUE_EMBEDDED_OBJECT || _binaryValue == null)) {\n            _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\");\n        }\n        \n        if (_binaryValue == null) {\n            try {\n                _binaryValue = _decodeBase64(b64variant);\n            } catch (IllegalArgumentException iae) {\n                throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage());\n            }\n        }        \n        return _binaryValue;\n    }\n\n    @SuppressWarnings(\"resource\")\n    protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException {\n        ByteArrayBuilder builder = _getByteArrayBuilder();\n        final String str = getText();\n        _decodeBase64(str, builder, b64variant);\n        return builder.toByteArray();\n    }\n    \n    \n\n    @Override\n    public BigInteger getBigIntegerValue() throws IOException {\n        \n        return null;\n    }\n\n    @Override\n    public BigDecimal getDecimalValue() throws IOException {\n        \n        return null;\n    }\n\n    @Override\n    public double getDoubleValue() throws IOException {\n        \n        return 0;\n    }\n\n    @Override\n    public float getFloatValue() throws IOException {\n        \n        return 0;\n    }\n\n    @Override\n    public int getIntValue() throws IOException {\n        \n        return 0;\n    }\n\n    @Override\n    public long getLongValue() throws IOException {\n        \n        return 0;\n    }\n\n    @Override\n    public NumberType getNumberType() throws IOException {\n        \n        return null;\n    }\n\n    @Override\n    public Number getNumberValue() throws IOException {\n        \n        return null;\n    }\n\n    \n\n    \n    @Override\n    protected void _handleEOF() throws JsonParseException {\n        if (!_parsingContext.inRoot()) {\n            _reportInvalidEOF(\": expected close marker for \"+_parsingContext.getTypeDesc()+\" (from \"+_parsingContext.getStartLocation(_ioContext.getSourceReference())+\")\");\n        }\n    }\n    \n    \n\n    \n    protected void _releaseBuffers() throws IOException {\n        \n    }\n\n    protected ByteArrayBuilder _getByteArrayBuilder() {\n        if (_byteArrayBuilder == null) {\n            _byteArrayBuilder = new ByteArrayBuilder();\n        } else {\n            _byteArrayBuilder.reset();\n        }\n        return _byteArrayBuilder;\n    }\n\n    protected boolean _isEmpty(String str) {\n        int len = (str == null) ? 0 : str.length();\n        if (len > 0) {\n            for (int i = 0; i < len; ++i) {\n                if (str.charAt(i) > ' ') {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n}\n",
      "buggy_signatures": [
        "private Feature(boolean defaultState)",
        "public boolean enabledByDefault()",
        "public int getMask()",
        "public boolean enabledIn(int flags)",
        "public Version version()",
        "public ObjectCodec getCodec()",
        "public void setCodec(ObjectCodec c)",
        "public void setXMLTextElementName(String name)",
        "public boolean requiresCustomCodec()",
        "public FromXmlParser enable(Feature f)",
        "public FromXmlParser disable(Feature f)",
        "public final boolean isEnabled(Feature f)",
        "public FromXmlParser configure(Feature f, boolean state)",
        "public int getFormatFeatures()",
        "public JsonParser overrideFormatFeatures(int values, int mask)",
        "public XMLStreamReader getStaxReader()",
        "public void addVirtualWrapping(Set<String> namesToWrap)",
        "public String getCurrentName() throws IOException",
        "public void overrideCurrentName(String name)",
        "public void close() throws IOException",
        "public boolean isClosed()",
        "public XmlReadContext getParsingContext()",
        "public JsonLocation getTokenLocation()",
        "public JsonLocation getCurrentLocation()",
        "public boolean isExpectedStartArrayToken()",
        "public JsonToken nextToken() throws IOException",
        "public String nextTextValue() throws IOException",
        "private void _updateState(JsonToken t)",
        "public String getText() throws IOException",
        "public final String getValueAsString() throws IOException",
        "public String getValueAsString(String defValue) throws IOException",
        "public char[] getTextCharacters() throws IOException",
        "public int getTextLength() throws IOException",
        "public int getTextOffset() throws IOException",
        "public boolean hasTextCharacters()",
        "public Object getEmbeddedObject() throws IOException",
        "public byte[] getBinaryValue(Base64Variant b64variant) throws IOException",
        "protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException",
        "public BigInteger getBigIntegerValue() throws IOException",
        "public BigDecimal getDecimalValue() throws IOException",
        "public double getDoubleValue() throws IOException",
        "public float getFloatValue() throws IOException",
        "public int getIntValue() throws IOException",
        "public long getLongValue() throws IOException",
        "public NumberType getNumberType() throws IOException",
        "public Number getNumberValue() throws IOException",
        "protected void _handleEOF() throws JsonParseException",
        "protected void _releaseBuffers() throws IOException",
        "protected ByteArrayBuilder _getByteArrayBuilder()",
        "protected boolean _isEmpty(String str)"
      ],
      "fixed_signatures": [
        "private Feature(boolean defaultState)",
        "public boolean enabledByDefault()",
        "public int getMask()",
        "public boolean enabledIn(int flags)",
        "public Version version()",
        "public ObjectCodec getCodec()",
        "public void setCodec(ObjectCodec c)",
        "public void setXMLTextElementName(String name)",
        "public boolean requiresCustomCodec()",
        "public FromXmlParser enable(Feature f)",
        "public FromXmlParser disable(Feature f)",
        "public final boolean isEnabled(Feature f)",
        "public FromXmlParser configure(Feature f, boolean state)",
        "public int getFormatFeatures()",
        "public JsonParser overrideFormatFeatures(int values, int mask)",
        "public XMLStreamReader getStaxReader()",
        "public void addVirtualWrapping(Set<String> namesToWrap)",
        "public String getCurrentName() throws IOException",
        "public void overrideCurrentName(String name)",
        "public void close() throws IOException",
        "public boolean isClosed()",
        "public XmlReadContext getParsingContext()",
        "public JsonLocation getTokenLocation()",
        "public JsonLocation getCurrentLocation()",
        "public boolean isExpectedStartArrayToken()",
        "public JsonToken nextToken() throws IOException",
        "public String nextTextValue() throws IOException",
        "private void _updateState(JsonToken t)",
        "public String getText() throws IOException",
        "public final String getValueAsString() throws IOException",
        "public String getValueAsString(String defValue) throws IOException",
        "public char[] getTextCharacters() throws IOException",
        "public int getTextLength() throws IOException",
        "public int getTextOffset() throws IOException",
        "public boolean hasTextCharacters()",
        "public Object getEmbeddedObject() throws IOException",
        "public byte[] getBinaryValue(Base64Variant b64variant) throws IOException",
        "protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException",
        "public BigInteger getBigIntegerValue() throws IOException",
        "public BigDecimal getDecimalValue() throws IOException",
        "public double getDoubleValue() throws IOException",
        "public float getFloatValue() throws IOException",
        "public int getIntValue() throws IOException",
        "public long getLongValue() throws IOException",
        "public NumberType getNumberType() throws IOException",
        "public Number getNumberValue() throws IOException",
        "protected void _handleEOF() throws JsonParseException",
        "protected void _releaseBuffers() throws IOException",
        "protected ByteArrayBuilder _getByteArrayBuilder()",
        "protected boolean _isEmpty(String str)"
      ],
      "methods": [
        {
          "buggy_method": "  public JsonToken nextToken() throws IOException {\n  _binaryValue = null;\n  if (_nextToken != null) {\n  JsonToken t = _nextToken;\n  _currToken = t;\n  _nextToken = null;\n  switch (t) {\n  case START_OBJECT:\n  _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n  break;\n  case START_ARRAY:\n  _parsingContext = _parsingContext.createChildArrayContext(-1, -1);\n  break;\n  case END_OBJECT:\n  case END_ARRAY:\n  _parsingContext = _parsingContext.getParent();\n  _namesToWrap = _parsingContext.getNamesToWrap();\n  break;\n  case FIELD_NAME:\n  _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n  break;\n  default: \n  \n  }\n  return t;\n  }\n  int token = _xmlTokens.next();\n\n  \n  \n  while (token == XmlTokenStream.XML_START_ELEMENT) {\n  \n  if (_mayBeLeaf) {\n  \n  _nextToken = JsonToken.FIELD_NAME;\n  _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n  return (_currToken = JsonToken.START_OBJECT);\n  }\n  if (_parsingContext.inArray()) {\n  \n  \n  token = _xmlTokens.next();\n  _mayBeLeaf = true;\n  continue;\n  }\n  String name = _xmlTokens.getLocalName();\n  _parsingContext.setCurrentName(name);\n\n  \n  \n  if (_namesToWrap != null && _namesToWrap.contains(name)) {\n  _xmlTokens.repeatStartElement();\n  }\n\n  _mayBeLeaf = true;\n  \n  \n  return (_currToken = JsonToken.FIELD_NAME);\n  }\n\n  \n  switch (token) {\n  case XmlTokenStream.XML_END_ELEMENT:\n  \n  if (_mayBeLeaf) {\n  _mayBeLeaf = false;\n  \n  \n  return (_currToken = JsonToken.VALUE_NULL);\n  }\n  _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n  _parsingContext = _parsingContext.getParent();\n  _namesToWrap = _parsingContext.getNamesToWrap();\n  return _currToken;\n  \n  case XmlTokenStream.XML_ATTRIBUTE_NAME:\n  \n  if (_mayBeLeaf) {\n  _mayBeLeaf = false;\n  _nextToken = JsonToken.FIELD_NAME;\n  _currText = _xmlTokens.getText();\n  _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n  return (_currToken = JsonToken.START_OBJECT);\n  }\n  _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n  return (_currToken = JsonToken.FIELD_NAME);\n  case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n  _currText = _xmlTokens.getText();\n  return (_currToken = JsonToken.VALUE_STRING);\n  case XmlTokenStream.XML_TEXT:\n  _currText = _xmlTokens.getText();\n  if (_mayBeLeaf) {\n  _mayBeLeaf = false;\n  \n  \n  _xmlTokens.skipEndElement();\n  if (_parsingContext.inArray()) {\n  if (_isEmpty(_currText)) {\n  \n  \n  \n  _currToken = JsonToken.END_ARRAY;\n  _parsingContext = _parsingContext.getParent();\n  _namesToWrap = _parsingContext.getNamesToWrap();\n  return _currToken;\n  }\n  }\n  return (_currToken = JsonToken.VALUE_STRING);\n  } else {\n  \n  if (_parsingContext.inObject()\n  && (_currToken != JsonToken.FIELD_NAME) && _isEmpty(_currText)) {\n  _currToken = JsonToken.END_OBJECT;\n  _parsingContext = _parsingContext.getParent();\n  _namesToWrap = _parsingContext.getNamesToWrap();\n  return _currToken;\n  }\n  }\n  \n  _parsingContext.setCurrentName(_cfgNameForTextElement);\n  _nextToken = JsonToken.VALUE_STRING;\n  return (_currToken = JsonToken.FIELD_NAME);\n  case XmlTokenStream.XML_END:\n  return (_currToken = null);\n  }\n  \n  \n  _throwInternal();\n  return null;\n  }",
          "fixed_method": "  public JsonToken nextToken() throws IOException {\n  _binaryValue = null;\n  if (_nextToken != null) {\n  JsonToken t = _nextToken;\n  _currToken = t;\n  _nextToken = null;\n  switch (t) {\n  case START_OBJECT:\n  _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n  break;\n  case START_ARRAY:\n  _parsingContext = _parsingContext.createChildArrayContext(-1, -1);\n  break;\n  case END_OBJECT:\n  case END_ARRAY:\n  _parsingContext = _parsingContext.getParent();\n  _namesToWrap = _parsingContext.getNamesToWrap();\n  break;\n  case FIELD_NAME:\n  _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n  break;\n  default: \n  \n  }\n  return t;\n  }\n  int token = _xmlTokens.next();\n\n  \n  \n  while (token == XmlTokenStream.XML_START_ELEMENT) {\n  \n  if (_mayBeLeaf) {\n  \n  _nextToken = JsonToken.FIELD_NAME;\n  _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n  return (_currToken = JsonToken.START_OBJECT);\n  }\n  if (_parsingContext.inArray()) {\n  \n  \n  token = _xmlTokens.next();\n  _mayBeLeaf = true;\n  continue;\n  }\n  String name = _xmlTokens.getLocalName();\n  _parsingContext.setCurrentName(name);\n\n  \n  \n  if (_namesToWrap != null && _namesToWrap.contains(name)) {\n  _xmlTokens.repeatStartElement();\n  }\n\n  _mayBeLeaf = true;\n  \n  \n  return (_currToken = JsonToken.FIELD_NAME);\n  }\n\n  \n  switch (token) {\n  case XmlTokenStream.XML_END_ELEMENT:\n  \n  if (_mayBeLeaf) {\n  _mayBeLeaf = false;\n  if (_parsingContext.inArray()) {\n  \n  \n  _nextToken = JsonToken.END_OBJECT;\n  _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n  return (_currToken = JsonToken.START_OBJECT);\n  }\n  return (_currToken = JsonToken.VALUE_NULL);\n  }\n  _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n  _parsingContext = _parsingContext.getParent();\n  _namesToWrap = _parsingContext.getNamesToWrap();\n  return _currToken;\n  \n  case XmlTokenStream.XML_ATTRIBUTE_NAME:\n  \n  if (_mayBeLeaf) {\n  _mayBeLeaf = false;\n  _nextToken = JsonToken.FIELD_NAME;\n  _currText = _xmlTokens.getText();\n  _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n  return (_currToken = JsonToken.START_OBJECT);\n  }\n  _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n  return (_currToken = JsonToken.FIELD_NAME);\n  case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n  _currText = _xmlTokens.getText();\n  return (_currToken = JsonToken.VALUE_STRING);\n  case XmlTokenStream.XML_TEXT:\n  _currText = _xmlTokens.getText();\n  if (_mayBeLeaf) {\n  _mayBeLeaf = false;\n  \n  \n  _xmlTokens.skipEndElement();\n  if (_parsingContext.inArray()) {\n  if (_isEmpty(_currText)) {\n  \n  \n  \n  _nextToken = JsonToken.END_OBJECT;\n  _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n  return (_currToken = JsonToken.START_OBJECT);\n  }\n  }\n  return (_currToken = JsonToken.VALUE_STRING);\n  } else {\n  \n  if (_parsingContext.inObject()\n  && (_currToken != JsonToken.FIELD_NAME) && _isEmpty(_currText)) {\n  _currToken = JsonToken.END_OBJECT;\n  _parsingContext = _parsingContext.getParent();\n  _namesToWrap = _parsingContext.getNamesToWrap();\n  return _currToken;\n  }\n  }\n  \n  _parsingContext.setCurrentName(_cfgNameForTextElement);\n  _nextToken = JsonToken.VALUE_STRING;\n  return (_currToken = JsonToken.FIELD_NAME);\n  case XmlTokenStream.XML_END:\n  return (_currToken = null);\n  }\n  \n  \n  _throwInternal();\n  return null;\n  }",
          "diff": [
            "@@ -509,8 +509,13 @@",
            "             // Simple, except that if this is a leaf, need to suppress end:\n",
            "             if (_mayBeLeaf) {\n",
            "                 _mayBeLeaf = false;\n",
            "+                if (_parsingContext.inArray()) {\n",
            "                     // 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\n",
            "                     //    expose as empty Object, not null\n",
            "+                    _nextToken = JsonToken.END_OBJECT;\n",
            "+                    _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n",
            "+                    return (_currToken = JsonToken.START_OBJECT);\n",
            "+                }\n",
            "                 return (_currToken = JsonToken.VALUE_NULL);\n",
            "             }\n",
            "             _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n",
            "@@ -547,10 +552,9 @@",
            "                         // 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\n",
            "                         //    expose as empty Object, not null (or, worse, as used to\n",
            "                         //    be done, by swallowing the token)\n",
            "-                        _currToken = JsonToken.END_ARRAY;\n",
            "-                        _parsingContext = _parsingContext.getParent();\n",
            "-                        _namesToWrap = _parsingContext.getNamesToWrap();\n",
            "-                        return _currToken;\n",
            "+                        _nextToken = JsonToken.END_OBJECT;\n",
            "+                        _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n",
            "+                        return (_currToken = JsonToken.START_OBJECT);\n",
            "                     }\n",
            "                 }\n",
            "                 return (_currToken = JsonToken.VALUE_STRING);\n"
          ],
          "changed_lines": 12
        }
      ]
    }
  ]
}
