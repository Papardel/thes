{
  "bug_id": "59",
  "failed_tests": {
    "org.apache.commons.math.util.FastMathTest": [
      {
        "methodName": "testMinMaxFloat",
        "error": "junit.framework.AssertionFailedError",
        "message": "max(50.0, -50.0) expected:<50.0> but was:<-50.0>",
        "fail_line": "            Assert.assertEquals(\"max(\" + pair[1] + \", \" + pair[0] + \")\",",
        "test_source": "  public void testMinMaxFloat() {\n  float[][] pairs = {\n  { -50.0f, 50.0f },\n  {  Float.POSITIVE_INFINITY, 1.0f },\n  {  Float.NEGATIVE_INFINITY, 1.0f },\n  {  Float.NaN, 1.0f },\n  {  Float.POSITIVE_INFINITY, 0.0f },\n  {  Float.NEGATIVE_INFINITY, 0.0f },\n  {  Float.NaN, 0.0f },\n  {  Float.NaN, Float.NEGATIVE_INFINITY },\n  {  Float.NaN, Float.POSITIVE_INFINITY }\n  };\n  for (float[] pair : pairs) {\n  Assert.assertEquals(\"min(\" + pair[0] + \", \" + pair[1] + \")\",\n  Math.min(pair[0], pair[1]),\n  FastMath.min(pair[0], pair[1]),\n  MathUtils.EPSILON);\n  Assert.assertEquals(\"min(\" + pair[1] + \", \" + pair[0] + \")\",\n  Math.min(pair[1], pair[0]),\n  FastMath.min(pair[1], pair[0]),\n  MathUtils.EPSILON);\n  Assert.assertEquals(\"max(\" + pair[0] + \", \" + pair[1] + \")\",\n  Math.max(pair[0], pair[1]),\n  FastMath.max(pair[0], pair[1]),\n  MathUtils.EPSILON);\n  Assert.assertEquals(\"max(\" + pair[1] + \", \" + pair[0] + \")\",\n  Math.max(pair[1], pair[0]),\n  FastMath.max(pair[1], pair[0]),\n  MathUtils.EPSILON);\n  }\n  }",
        "stack": [
          "FastMathTest.testMinMaxFloat line 103"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/math/util/FastMath.java",
      "buggy_full_code": "\npackage org.apache.commons.math.util;\n\n\npublic class FastMath { public static final double PI = 105414357.0 / 33554432.0 + 1.984187159361080883e-9; public static final double E = 2850325.0 / 1048576.0 + 8.254840070411028747e-8; private static final double EXP_INT_TABLE_A[] = new double[1500]; private static final double EXP_INT_TABLE_B[] = new double[1500]; private static final double EXP_FRAC_TABLE_A[] = new double[1025]; private static final double EXP_FRAC_TABLE_B[] = new double[1025]; private static final double FACT[] = new double[20]; private static final double LN_MANT[][] = new double[1024][]; private static final double LN_2_A = 0.693147063255310059; private static final double LN_2_B = 1.17304635250823482e-7; private static final double LN_SPLIT_COEF[][] = { {2.0, 0.0}, {0.6666666269302368, 3.9736429850260626E-8}, {0.3999999761581421, 2.3841857910019882E-8}, {0.2857142686843872, 1.7029898543501842E-8}, {0.2222222089767456, 1.3245471311735498E-8}, {0.1818181574344635, 2.4384203044354907E-8}, {0.1538461446762085, 9.140260083262505E-9}, {0.13333332538604736, 9.220590270857665E-9}, {0.11764700710773468, 1.2393345855018391E-8}, {0.10526403784751892, 8.251545029714408E-9}, {0.0952233225107193, 1.2675934823758863E-8}, {0.08713622391223907, 1.1430250008909141E-8}, {0.07842259109020233, 2.404307984052299E-9}, {0.08371849358081818, 1.176342548272881E-8}, {0.030589580535888672, 1.2958646899018938E-9}, {0.14982303977012634, 1.225743062930824E-8}, }; private static final double LN_QUICK_COEF[][] = { {1.0, 5.669184079525E-24}, {-0.25, -0.25}, {0.3333333134651184, 1.986821492305628E-8}, {-0.25, -6.663542893624021E-14}, {0.19999998807907104, 1.1921056801463227E-8}, {-0.1666666567325592, -7.800414592973399E-9}, {0.1428571343421936, 5.650007086920087E-9}, {-0.12502530217170715, -7.44321345601866E-11}, {0.11113807559013367, 9.219544613762692E-9}, }; private static final double LN_HI_PREC_COEF[][] = { {1.0, -6.032174644509064E-23}, {-0.25, -0.25}, {0.3333333134651184, 1.9868161777724352E-8}, {-0.2499999701976776, -2.957007209750105E-8}, {0.19999954104423523, 1.5830993332061267E-10}, {-0.16624879837036133, -2.6033824355191673E-8} }; private static final double SINE_TABLE_A[] = new double[14]; private static final double SINE_TABLE_B[] = new double[14]; private static final double COSINE_TABLE_A[] = new double[14]; private static final double COSINE_TABLE_B[] = new double[14]; private static final double TANGENT_TABLE_A[] = new double[14]; private static final double TANGENT_TABLE_B[] = new double[14]; private static long RECIP_2PI[] = new long[] { (0x28be60dbL << 32) | 0x9391054aL, (0x7f09d5f4L << 32) | 0x7d4d3770L, (0x36d8a566L << 32) | 0x4f10e410L, (0x7f9458eaL << 32) | 0xf7aef158L, (0x6dc91b8eL << 32) | 0x909374b8L, (0x01924bbaL << 32) | 0x82746487L, (0x3f877ac7L << 32) | 0x2c4a69cfL, (0xba208d7dL << 32) | 0x4baed121L, (0x3a671c09L << 32) | 0xad17df90L, (0x4e64758eL << 32) | 0x60d4ce7dL, (0x272117e2L << 32) | 0xef7e4a0eL, (0xc7fe25ffL << 32) | 0xf7816603L, (0xfbcbc462L << 32) | 0xd6829b47L, (0xdb4d9fb3L << 32) | 0xc9f2c26dL, (0xd3d18fd9L << 32) | 0xa797fa8bL, (0x5d49eeb1L << 32) | 0xfaf97c5eL, (0xcf41ce7dL << 32) | 0xe294a4baL, 0x9afed7ecL << 32 }; private static long PI_O_4_BITS[] = new long[] {\n        (0xc90fdaa2L << 32) | 0x2168c234L,\n        (0xc4c6628bL << 32) | 0x80dc1cd1L };\n\n    \n    private static final double EIGHTHES[] = {0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875, 1.0, 1.125, 1.25, 1.375, 1.5, 1.625}; private static final double CBRTTWO[] = { 0.6299605249474366, 0.7937005259840998, 1.0, 1.2599210498948732, 1.5874010519681994 }; static { int i; FACT[0] = 1.0; for (i = 1; i < 20; i++) {\n            FACT[i] = FACT[i-1] * i;\n        }\n\n        double tmp[] = new double[2];\n        double recip[] = new double[2];\n\n        \n        for (i = 0; i < 750; i++) {\n            expint(i, tmp);\n            EXP_INT_TABLE_A[i+750] = tmp[0];\n            EXP_INT_TABLE_B[i+750] = tmp[1];\n\n            if (i != 0) {\n                \n                splitReciprocal(tmp, recip);\n                EXP_INT_TABLE_A[750-i] = recip[0];\n                EXP_INT_TABLE_B[750-i] = recip[1];\n            }\n        }\n\n        \n        for (i = 0; i < 1025; i++) {\n            slowexp(i/1024.0, tmp);\n            EXP_FRAC_TABLE_A[i] = tmp[0];\n            EXP_FRAC_TABLE_B[i] = tmp[1];\n        }\n\n        \n        for (i = 0; i < 1024; i++) {\n            double d = Double.longBitsToDouble( (((long) i) << 42) | 0x3ff0000000000000L );\n            LN_MANT[i] = slowLog(d);\n        }\n\n        \n        buildSinCosTables();\n    }\n\n    \n    private FastMath() {\n    }\n\n    \n    public static double sqrt(final double a) {\n        return Math.sqrt(a);\n    }\n\n    \n    public static double cosh(double x) {\n      if (x != x) {\n          return x;\n      }\n\n      if (x > 20.0) {\n          return exp(x)/2.0;\n      }\n\n      if (x < -20) {\n          return exp(-x)/2.0;\n      }\n\n      double hiPrec[] = new double[2];\n      if (x < 0.0) {\n          x = -x;\n      }\n      exp(x, 0.0, hiPrec);\n\n      double ya = hiPrec[0] + hiPrec[1];\n      double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n      double temp = ya * 1073741824.0;\n      double yaa = ya + temp - temp;\n      double yab = ya - yaa;\n\n      \n      double recip = 1.0/ya;\n      temp = recip * 1073741824.0;\n      double recipa = recip + temp - temp;\n      double recipb = recip - recipa;\n\n      \n      recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n      \n      recipb += -yb * recip * recip;\n\n      \n      temp = ya + recipa;\n      yb += -(temp - ya - recipa);\n      ya = temp;\n      temp = ya + recipb;\n      yb += -(temp - ya - recipb);\n      ya = temp;\n\n      double result = ya + yb;\n      result *= 0.5;\n      return result;\n    }\n\n    \n    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      if (x > 20.0) {\n          return exp(x)/2.0;\n      }\n\n      if (x < -20) {\n          return -exp(-x)/2.0;\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * 1073741824.0;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          \n          double recip = 1.0/ya;\n          temp = recip * 1073741824.0;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          \n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          \n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          \n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          \n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * 1073741824.0;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * 1073741824.0;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          \n          rb += yb*denomr;                        \n          rb += -ya * denomb * denomr * denomr;   \n\n          \n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }\n\n    \n    public static double tanh(double x) {\n      boolean negate = false;\n\n      if (x != x) {\n          return x;\n      }\n\n      if (x > 20.0) {\n          return 1.0;\n      }\n\n      if (x < -20) {\n          return -1.0;\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n      if (x >= 0.5) {\n          double hiPrec[] = new double[2];\n          \n          exp(x*2.0, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          \n          double na = -1.0 + ya;\n          double nb = -(na + 1.0 - ya);\n          double temp = na + yb;\n          nb += -(temp - na - yb);\n          na = temp;\n\n          \n          double da = 1.0 + ya;\n          double db = -(da - 1.0 - ya);\n          temp = da + yb;\n          db += -(temp - da - yb);\n          da = temp;\n\n          temp = da * 1073741824.0;\n          double daa = da + temp - temp;\n          double dab = da - daa;\n\n          \n          double ratio = na/da;\n          temp = ratio * 1073741824.0;\n          double ratioa = ratio + temp - temp;\n          double ratiob = ratio - ratioa;\n\n          \n          ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\n\n          \n          ratiob += nb / da;\n          \n          ratiob += -db * na / da / da;\n\n          result = ratioa + ratiob;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          \n          expm1(x*2.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          \n          double na = ya;\n          double nb = yb;\n\n          \n          double da = 2.0 + ya;\n          double db = -(da - 2.0 - ya);\n          double temp = da + yb;\n          db += -(temp - da - yb);\n          da = temp;\n\n          temp = da * 1073741824.0;\n          double daa = da + temp - temp;\n          double dab = da - daa;\n\n          \n          double ratio = na/da;\n          temp = ratio * 1073741824.0;\n          double ratioa = ratio + temp - temp;\n          double ratiob = ratio - ratioa;\n\n          \n          ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\n\n          \n          ratiob += nb / da;\n          \n          ratiob += -db * na / da / da;\n\n          result = ratioa + ratiob;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }\n\n    \n    public static double acosh(final double a) {\n        return FastMath.log(a + FastMath.sqrt(a * a - 1));\n    }\n\n    \n    public static double asinh(double a) {\n\n        boolean negative = false;\n        if (a < 0) {\n            negative = true;\n            a = -a;\n        }\n\n        double absAsinh;\n        if (a > 0.167) {\n            absAsinh = FastMath.log(FastMath.sqrt(a * a + 1) + a);\n        } else {\n            final double a2 = a * a;\n            if (a > 0.097) {\n                absAsinh = a * (1 - a2 * (1 / 3.0 - a2 * (1 / 5.0 - a2 * (1 / 7.0 - a2 * (1 / 9.0 - a2 * (1.0 / 11.0 - a2 * (1.0 / 13.0 - a2 * (1.0 / 15.0 - a2 * (1.0 / 17.0) * 15.0 / 16.0) * 13.0 / 14.0) * 11.0 / 12.0) * 9.0 / 10.0) * 7.0 / 8.0) * 5.0 / 6.0) * 3.0 / 4.0) / 2.0);\n            } else if (a > 0.036) {\n                absAsinh = a * (1 - a2 * (1 / 3.0 - a2 * (1 / 5.0 - a2 * (1 / 7.0 - a2 * (1 / 9.0 - a2 * (1.0 / 11.0 - a2 * (1.0 / 13.0) * 11.0 / 12.0) * 9.0 / 10.0) * 7.0 / 8.0) * 5.0 / 6.0) * 3.0 / 4.0) / 2.0);\n            } else if (a > 0.0036) {\n                absAsinh = a * (1 - a2 * (1 / 3.0 - a2 * (1 / 5.0 - a2 * (1 / 7.0 - a2 * (1 / 9.0) * 7.0 / 8.0) * 5.0 / 6.0) * 3.0 / 4.0) / 2.0);\n            } else {\n                absAsinh = a * (1 - a2 * (1 / 3.0 - a2 * (1 / 5.0) * 3.0 / 4.0) / 2.0);\n            }\n        }\n\n        return negative ? -absAsinh : absAsinh;\n\n    }\n\n    \n    public static double atanh(double a) {\n\n        boolean negative = false;\n        if (a < 0) {\n            negative = true;\n            a = -a;\n        }\n\n        double absAtanh;\n        if (a > 0.15) {\n            absAtanh = 0.5 * FastMath.log((1 + a) / (1 - a));\n        } else {\n            final double a2 = a * a;\n            if (a > 0.087) {\n                absAtanh = a * (1 + a2 * (1.0 / 3.0 + a2 * (1.0 / 5.0 + a2 * (1.0 / 7.0 + a2 * (1.0 / 9.0 + a2 * (1.0 / 11.0 + a2 * (1.0 / 13.0 + a2 * (1.0 / 15.0 + a2 * (1.0 / 17.0)))))))));\n            } else if (a > 0.031) {\n                absAtanh = a * (1 + a2 * (1.0 / 3.0 + a2 * (1.0 / 5.0 + a2 * (1.0 / 7.0 + a2 * (1.0 / 9.0 + a2 * (1.0 / 11.0 + a2 * (1.0 / 13.0)))))));\n            } else if (a > 0.003) {\n                absAtanh = a * (1 + a2 * (1.0 / 3.0 + a2 * (1.0 / 5.0 + a2 * (1.0 / 7.0 + a2 * (1.0 / 9.0)))));\n            } else {\n                absAtanh = a * (1 + a2 * (1.0 / 3.0 + a2 * (1.0 / 5.0)));\n            }\n        }\n\n        return negative ? -absAtanh : absAtanh;\n\n    }\n\n    \n    public static double signum(final double a) {\n        return (a < 0.0) ? -1.0 : ((a > 0.0) ? 1.0 : (Double.isNaN(a) ? Double.NaN : 0.0));\n    }\n\n    \n    public static double nextUp(final double a) {\n        return nextAfter(a, Double.POSITIVE_INFINITY);\n    }\n\n    \n    public static double random() {\n        return Math.random();\n    }\n\n    \n    public static double exp(double x) {\n        return exp(x, 0.0, null);\n    }\n\n    \n    private static double exp(double x, double extra, double[] hiPrec) {\n        double intPartA;\n        double intPartB;\n        int intVal;\n\n        \n        if (x < 0.0) {\n            intVal = (int) -x;\n\n            if (intVal > 746) {\n                if (hiPrec != null) {\n                    hiPrec[0] = 0.0;\n                    hiPrec[1] = 0.0;\n                }\n                return 0.0;\n            }\n\n            if (intVal > 709) {\n                \n                final double result = exp(x+40.19140625, extra, hiPrec) / 285040095144011776.0;\n                if (hiPrec != null) {\n                    hiPrec[0] /= 285040095144011776.0;\n                    hiPrec[1] /= 285040095144011776.0;\n                }\n                return result;\n            }\n\n            if (intVal == 709) {\n                \n                final double result = exp(x+1.494140625, extra, hiPrec) / 4.455505956692756620;\n                if (hiPrec != null) {\n                    hiPrec[0] /= 4.455505956692756620;\n                    hiPrec[1] /= 4.455505956692756620;\n                }\n                return result;\n            }\n\n            intVal++;\n\n            intPartA = EXP_INT_TABLE_A[750-intVal];\n            intPartB = EXP_INT_TABLE_B[750-intVal];\n\n            intVal = -intVal;\n        } else {\n            intVal = (int) x;\n\n            if (intVal > 709) {\n                if (hiPrec != null) {\n                    hiPrec[0] = Double.POSITIVE_INFINITY;\n                    hiPrec[1] = 0.0;\n                }\n                return Double.POSITIVE_INFINITY;\n            }\n\n            intPartA = EXP_INT_TABLE_A[750+intVal];\n            intPartB = EXP_INT_TABLE_B[750+intVal];\n        }\n\n        \n        final int intFrac = (int) ((x - intVal) * 1024.0);\n        final double fracPartA = EXP_FRAC_TABLE_A[intFrac];\n        final double fracPartB = EXP_FRAC_TABLE_B[intFrac];\n\n        \n        final double epsilon = x - (intVal + intFrac / 1024.0);\n\n        \n\n        \n        double z = 0.04168701738764507;\n        z = z * epsilon + 0.1666666505023083;\n        z = z * epsilon + 0.5000000000042687;\n        z = z * epsilon + 1.0;\n        z = z * epsilon + -3.940510424527919E-20;\n\n        \n        double tempA = intPartA * fracPartA;\n        double tempB = intPartA * fracPartB + intPartB * fracPartA + intPartB * fracPartB;\n\n        \n        final double tempC = tempB + tempA;\n        final double result;\n        if (extra != 0.0) {\n            result = tempC*extra*z + tempC*extra + tempC*z + tempB + tempA;\n        } else {\n            result = tempC*z + tempB + tempA;\n        }\n\n        if (hiPrec != null) {\n            \n            hiPrec[0] = tempA;\n            hiPrec[1] = tempC*extra*z + tempC*extra + tempC*z + tempB;\n        }\n\n        return result;\n    }\n\n    \n    public static double expm1(double x) {\n      return expm1(x, null);\n    }\n\n    \n    private static double expm1(double x, double hiPrecOut[]) {\n        if (x != x || x == 0.0) { \n            return x;\n        }\n\n        if (x <= -1.0 || x >= 1.0) {\n            \n            \n            double hiPrec[] = new double[2];\n            exp(x, 0.0, hiPrec);\n            if (x > 0.0) {\n                return -1.0 + hiPrec[0] + hiPrec[1];\n            } else {\n                final double ra = -1.0 + hiPrec[0];\n                double rb = -(ra + 1.0 - hiPrec[0]);\n                rb += hiPrec[1];\n                return ra + rb;\n            }\n        }\n\n        double baseA;\n        double baseB;\n        double epsilon;\n        boolean negative = false;\n\n        if (x < 0.0) {\n            x = -x;\n            negative = true;\n        }\n\n        {\n            int intFrac = (int) (x * 1024.0);\n            double tempA = EXP_FRAC_TABLE_A[intFrac] - 1.0;\n            double tempB = EXP_FRAC_TABLE_B[intFrac];\n\n            double temp = tempA + tempB;\n            tempB = -(temp - tempA - tempB);\n            tempA = temp;\n\n            temp = tempA * 1073741824.0;\n            baseA = tempA + temp - temp;\n            baseB = tempB + (tempA - baseA);\n\n            epsilon = x - intFrac/1024.0;\n        }\n\n\n        \n        double zb = 0.008336750013465571;\n        zb = zb * epsilon + 0.041666663879186654;\n        zb = zb * epsilon + 0.16666666666745392;\n        zb = zb * epsilon + 0.49999999999999994;\n        zb = zb * epsilon;\n        zb = zb * epsilon;\n\n        double za = epsilon;\n        double temp = za + zb;\n        zb = -(temp - za - zb);\n        za = temp;\n\n        temp = za * 1073741824.0;\n        temp = za + temp - temp;\n        zb += za - temp;\n        za = temp;\n\n        \n        double ya = za * baseA;\n        \n        temp = ya + za * baseB;\n        double yb = -(temp - ya - za * baseB);\n        ya = temp;\n\n        temp = ya + zb * baseA;\n        yb += -(temp - ya - zb * baseA);\n        ya = temp;\n\n        temp = ya + zb * baseB;\n        yb += -(temp - ya - zb*baseB);\n        ya = temp;\n\n        \n        \n        temp = ya + baseA;\n        yb += -(temp - baseA - ya);\n        ya = temp;\n\n        temp = ya + za;\n        \n        yb += -(temp - ya - za);\n        ya = temp;\n\n        temp = ya + baseB;\n        \n        yb += -(temp - ya - baseB);\n        ya = temp;\n\n        temp = ya + zb;\n        \n        yb += -(temp - ya - zb);\n        ya = temp;\n\n        if (negative) {\n            \n            double denom = 1.0 + ya;\n            double denomr = 1.0 / denom;\n            double denomb = -(denom - 1.0 - ya) + yb;\n            double ratio = ya * denomr;\n            temp = ratio * 1073741824.0;\n            final double ra = ratio + temp - temp;\n            double rb = ratio - ra;\n\n            temp = denom * 1073741824.0;\n            za = denom + temp - temp;\n            zb = denom - za;\n\n            rb += (ya - za * ra - za * rb - zb * ra - zb * rb) * denomr;\n\n            \n            \n            \n            \n            \n            \n            \n\n            \n            rb += yb * denomr;                      \n            rb += -ya * denomb * denomr * denomr;   \n\n            \n            ya = -ra;\n            yb = -rb;\n        }\n\n        if (hiPrecOut != null) {\n            hiPrecOut[0] = ya;\n            hiPrecOut[1] = yb;\n        }\n\n        return ya + yb;\n    }\n\n    \n    private static double slowexp(final double x, final double result[]) {\n        final double xs[] = new double[2];\n        final double ys[] = new double[2];\n        final double facts[] = new double[2];\n        final double as[] = new double[2];\n        split(x, xs);\n        ys[0] = ys[1] = 0.0;\n\n        for (int i = 19; i >= 0; i--) {\n            splitMult(xs, ys, as);\n            ys[0] = as[0];\n            ys[1] = as[1];\n\n            split(FACT[i], as);\n            splitReciprocal(as, facts);\n\n            splitAdd(ys, facts, as);\n            ys[0] = as[0];\n            ys[1] = as[1];\n        }\n\n        if (result != null) {\n            result[0] = ys[0];\n            result[1] = ys[1];\n        }\n\n        return ys[0] + ys[1];\n    }\n\n    \n    private static void split(final double d, final double split[]) {\n        if (d < 8e298 && d > -8e298) {\n            final double a = d * 1073741824.0;\n            split[0] = (d + a) - a;\n            split[1] = d - split[0];\n        } else {\n            final double a = d * 9.31322574615478515625E-10;\n            split[0] = (d + a - d) * 1073741824.0;\n            split[1] = d - split[0];\n        }\n    }\n\n    \n    private static void resplit(final double a[]) {\n        final double c = a[0] + a[1];\n        final double d = -(c - a[0] - a[1]);\n\n        if (c < 8e298 && c > -8e298) {\n            double z = c * 1073741824.0;\n            a[0] = (c + z) - z;\n            a[1] = c - a[0] + d;\n        } else {\n            double z = c * 9.31322574615478515625E-10;\n            a[0] = (c + z - c) * 1073741824.0;\n            a[1] = c - a[0] + d;\n        }\n    }\n\n    \n    private static void splitMult(double a[], double b[], double ans[]) {\n        ans[0] = a[0] * b[0];\n        ans[1] = a[0] * b[1] + a[1] * b[0] + a[1] * b[1];\n\n        \n        resplit(ans);\n    }\n\n    \n    private static void splitAdd(final double a[], final double b[], final double ans[]) {\n        ans[0] = a[0] + b[0];\n        ans[1] = a[1] + b[1];\n\n        resplit(ans);\n    }\n\n    \n    private static void splitReciprocal(final double in[], final double result[]) {\n        final double b = 1.0/4194304.0;\n        final double a = 1.0 - b;\n\n        if (in[0] == 0.0) {\n            in[0] = in[1];\n            in[1] = 0.0;\n        }\n\n        result[0] = a / in[0];\n        result[1] = (b*in[0]-a*in[1]) / (in[0]*in[0] + in[0]*in[1]);\n\n        if (result[1] != result[1]) { \n            result[1] = 0.0;\n        }\n\n        \n        resplit(result);\n\n        for (int i = 0; i < 2; i++) {\n            \n            double err = 1.0 - result[0] * in[0] - result[0] * in[1] -\n            result[1] * in[0] - result[1] * in[1];\n            \n            err = err * (result[0] + result[1]);\n            \n            result[1] += err;\n        }\n    }\n\n    \n    private static void quadMult(final double a[], final double b[], final double result[]) {\n        final double xs[] = new double[2];\n        final double ys[] = new double[2];\n        final double zs[] = new double[2];\n\n        \n        split(a[0], xs);\n        split(b[0], ys);\n        splitMult(xs, ys, zs);\n\n        result[0] = zs[0];\n        result[1] = zs[1];\n\n        \n        split(b[1], ys);\n        splitMult(xs, ys, zs);\n\n        double tmp = result[0] + zs[0];\n        result[1] = result[1] - (tmp - result[0] - zs[0]);\n        result[0] = tmp;\n        tmp = result[0] + zs[1];\n        result[1] = result[1] - (tmp - result[0] - zs[1]);\n        result[0] = tmp;\n\n        \n        split(a[1], xs);\n        split(b[0], ys);\n        splitMult(xs, ys, zs);\n\n        tmp = result[0] + zs[0];\n        result[1] = result[1] - (tmp - result[0] - zs[0]);\n        result[0] = tmp;\n        tmp = result[0] + zs[1];\n        result[1] = result[1] - (tmp - result[0] - zs[1]);\n        result[0] = tmp;\n\n        \n        split(a[1], xs);\n        split(b[1], ys);\n        splitMult(xs, ys, zs);\n\n        tmp = result[0] + zs[0];\n        result[1] = result[1] - (tmp - result[0] - zs[0]);\n        result[0] = tmp;\n        tmp = result[0] + zs[1];\n        result[1] = result[1] - (tmp - result[0] - zs[1]);\n        result[0] = tmp;\n    }\n\n    \n    private static double expint(int p, final double result[]) {\n        \n        final double xs[] = new double[2];\n        final double as[] = new double[2];\n        final double ys[] = new double[2];\n        \n        \n        \n        \n        \n        \n\n        \n        xs[0] = 2.718281828459045;\n        xs[1] = 1.4456468917292502E-16;\n\n        split(1.0, ys);\n\n        while (p > 0) {\n            if ((p & 1) != 0) {\n                quadMult(ys, xs, as);\n                ys[0] = as[0]; ys[1] = as[1];\n            }\n\n            quadMult(xs, xs, as);\n            xs[0] = as[0]; xs[1] = as[1];\n\n            p >>= 1;\n        }\n\n        if (result != null) {\n            result[0] = ys[0];\n            result[1] = ys[1];\n\n            resplit(result);\n        }\n\n        return ys[0] + ys[1];\n    }\n\n\n    \n    public static double log(final double x) {\n        return log(x, null);\n    }\n\n    \n    private static double log(final double x, final double[] hiPrec) {\n        long bits = Double.doubleToLongBits(x);\n\n        \n        if ((bits & 0x8000000000000000L) != 0 || x != x) {\n            if (x != 0.0) {\n                if (hiPrec != null) {\n                    hiPrec[0] = Double.NaN;\n                }\n\n                return Double.NaN;\n            }\n        }\n\n        \n        if (x == Double.POSITIVE_INFINITY) {\n            if (hiPrec != null) {\n                hiPrec[0] = Double.POSITIVE_INFINITY;\n            }\n\n            return Double.POSITIVE_INFINITY;\n        }\n\n        \n        int exp = (int)(bits >> 52)-1023;\n\n        if ((bits & 0x7ff0000000000000L) == 0) {\n            \n            if (x == 0) {\n                \n                if (hiPrec != null) {\n                    hiPrec[0] = Double.NEGATIVE_INFINITY;\n                }\n\n                return Double.NEGATIVE_INFINITY;\n            }\n\n            \n            bits <<= 1;\n            while ( (bits & 0x0010000000000000L) == 0) {\n                exp--;\n                bits <<= 1;\n            }\n        }\n\n\n        if (exp == -1 || exp == 0) {\n            if (x < 1.01 && x > 0.99 && hiPrec == null) {\n                \n\n               \n                double xa = x - 1.0;\n                double xb = xa - x + 1.0;\n                double tmp = xa * 1073741824.0;\n                double aa = xa + tmp - tmp;\n                double ab = xa - aa;\n                xa = aa;\n                xb = ab;\n\n                double ya = LN_QUICK_COEF[LN_QUICK_COEF.length-1][0];\n                double yb = LN_QUICK_COEF[LN_QUICK_COEF.length-1][1];\n\n                for (int i = LN_QUICK_COEF.length - 2; i >= 0; i--) {\n                    \n                    aa = ya * xa;\n                    ab = ya * xb + yb * xa + yb * xb;\n                    \n                    tmp = aa * 1073741824.0;\n                    ya = aa + tmp - tmp;\n                    yb = aa - ya + ab;\n\n                    \n                    aa = ya + LN_QUICK_COEF[i][0];\n                    ab = yb + LN_QUICK_COEF[i][1];\n                    \n                    tmp = aa * 1073741824.0;\n                    ya = aa + tmp - tmp;\n                    yb = aa - ya + ab;\n                }\n\n                \n                aa = ya * xa;\n                ab = ya * xb + yb * xa + yb * xb;\n                \n                tmp = aa * 1073741824.0;\n                ya = aa + tmp - tmp;\n                yb = aa - ya + ab;\n\n                return ya + yb;\n            }\n        }\n\n        \n        double lnm[] = LN_MANT[(int)((bits & 0x000ffc0000000000L) >> 42)];\n\n        \n\n        \n        \n        \n        double epsilon = (double)(bits & 0x3ffffffffffL) / (4503599627370496.0 + (bits & 0x000ffc0000000000L));\n\n        double lnza = 0.0;\n        double lnzb = 0.0;\n\n        if (hiPrec != null) {\n            \n            double tmp = epsilon * 1073741824.0;\n            double aa = epsilon + tmp - tmp;\n            double ab = epsilon - aa;\n            double xa = aa;\n            double xb = ab;\n\n            \n            double numer = (double)(bits & 0x3ffffffffffL);\n            double denom = 4503599627370496.0 + (bits & 0x000ffc0000000000L);\n            aa = numer - xa*denom - xb * denom;\n            xb += aa / denom;\n\n            \n            double ya = LN_HI_PREC_COEF[LN_HI_PREC_COEF.length-1][0];\n            double yb = LN_HI_PREC_COEF[LN_HI_PREC_COEF.length-1][1];\n\n            for (int i = LN_HI_PREC_COEF.length - 2; i >= 0; i--) {\n                \n                aa = ya * xa;\n                ab = ya * xb + yb * xa + yb * xb;\n                \n                tmp = aa * 1073741824.0;\n                ya = aa + tmp - tmp;\n                yb = aa - ya + ab;\n\n                \n                aa = ya + LN_HI_PREC_COEF[i][0];\n                ab = yb + LN_HI_PREC_COEF[i][1];\n                \n                tmp = aa * 1073741824.0;\n                ya = aa + tmp - tmp;\n                yb = aa - ya + ab;\n            }\n\n            \n            aa = ya * xa;\n            ab = ya * xb + yb * xa + yb * xb;\n\n            \n            \n            lnza = aa + ab;\n            lnzb = -(lnza - aa - ab);\n        } else {\n            \n            lnza = -0.16624882440418567;\n            lnza = lnza * epsilon + 0.19999954120254515;\n            lnza = lnza * epsilon + -0.2499999997677497;\n            lnza = lnza * epsilon + 0.3333333333332802;\n            lnza = lnza * epsilon + -0.5;\n            lnza = lnza * epsilon + 1.0;\n            lnza = lnza * epsilon;\n        }\n\n        \n\n        \n\n        \n        double a = LN_2_A*exp;\n        double b = 0.0;\n        double c = a+lnm[0];\n        double d = -(c-a-lnm[0]);\n        a = c;\n        b = b + d;\n\n        c = a + lnza;\n        d = -(c - a - lnza);\n        a = c;\n        b = b + d;\n\n        c = a + LN_2_B*exp;\n        d = -(c - a - LN_2_B*exp);\n        a = c;\n        b = b + d;\n\n        c = a + lnm[1];\n        d = -(c - a - lnm[1]);\n        a = c;\n        b = b + d;\n\n        c = a + lnzb;\n        d = -(c - a - lnzb);\n        a = c;\n        b = b + d;\n\n        if (hiPrec != null) {\n            hiPrec[0] = a;\n            hiPrec[1] = b;\n        }\n\n        return a + b;\n    }\n\n    \n    public static double log1p(final double x) {\n        double xpa = 1.0 + x;\n        double xpb = -(xpa - 1.0 - x);\n\n        if (x == -1) {\n            return x/0.0;   \n        }\n\n        if (x > 0 && 1/x == 0) { \n            return x;\n        }\n\n        if (x>1e-6 || x<-1e-6) {\n            double hiPrec[] = new double[2];\n\n            log(xpa, hiPrec);\n\n            \n            \n            double fx1 = xpb/xpa;\n\n            double epsilon = 0.5 * fx1 + 1.0;\n            epsilon = epsilon * fx1;\n\n            return epsilon + hiPrec[1] + hiPrec[0];\n        }\n\n        \n        double y = x * 0.333333333333333 - 0.5;\n        y = y * x + 1.0;\n        y = y * x;\n\n        return y;\n    }\n\n    \n    public static double log10(final double x) {\n        final double hiPrec[] = new double[2];\n\n        log(x, hiPrec);\n\n        final double tmp = hiPrec[0] * 1073741824.0;\n        final double lna = hiPrec[0] + tmp - tmp;\n        final double lnb = hiPrec[0] - lna + hiPrec[1];\n\n        final double rln10a = 0.4342944622039795;\n        final double rln10b = 1.9699272335463627E-8;\n\n        return rln10b * lnb + rln10b * lna + rln10a * lnb + rln10a * lna;\n    }\n\n    \n    public static double pow(double x, double y) {\n        final double lns[] = new double[2];\n\n        if (y == 0.0) {\n            return 1.0;\n        }\n\n        if (x != x) { \n            return x;\n        }\n\n\n        if (x == 0) {\n            long bits = Double.doubleToLongBits(x);\n            if ((bits & 0x8000000000000000L) != 0) {\n                \n                long yi = (long) y;\n\n                if (y < 0 && y == yi && (yi & 1) == 1) {\n                    return Double.NEGATIVE_INFINITY;\n                }\n\n                if (y < 0 && y == yi && (yi & 1) == 1) {\n                    return -0.0;\n                }\n\n                if (y > 0 && y == yi && (yi & 1) == 1) {\n                    return -0.0;\n                }\n            }\n\n            if (y < 0) {\n                return Double.POSITIVE_INFINITY;\n            }\n            if (y > 0) {\n                return 0.0;\n            }\n\n            return Double.NaN;\n        }\n\n        if (x == Double.POSITIVE_INFINITY) {\n            if (y != y) { \n                return y;\n            }\n            if (y < 0.0) {\n                return 0.0;\n            } else {\n                return Double.POSITIVE_INFINITY;\n            }\n        }\n\n        if (y == Double.POSITIVE_INFINITY) {\n            if (x * x == 1.0)\n              return Double.NaN;\n\n            if (x * x > 1.0) {\n                return Double.POSITIVE_INFINITY;\n            } else {\n                return 0.0;\n            }\n        }\n\n        if (x == Double.NEGATIVE_INFINITY) {\n            if (y != y) { \n                return y;\n            }\n\n            if (y < 0) {\n                long yi = (long) y;\n                if (y == yi && (yi & 1) == 1) {\n                    return -0.0;\n                }\n\n                return 0.0;\n            }\n\n            if (y > 0)  {\n                long yi = (long) y;\n                if (y == yi && (yi & 1) == 1) {\n                    return Double.NEGATIVE_INFINITY;\n                }\n\n                return Double.POSITIVE_INFINITY;\n            }\n        }\n\n        if (y == Double.NEGATIVE_INFINITY) {\n\n            if (x * x == 1.0) {\n                return Double.NaN;\n            }\n\n            if (x * x < 1.0) {\n                return Double.POSITIVE_INFINITY;\n            } else {\n                return 0.0;\n            }\n        }\n\n        \n        if (x < 0) {\n            \n            if (y >= 4503599627370496.0 || y <= -4503599627370496.0) {\n                return pow(-x, y);\n            }\n\n            if (y == (long) y) {\n                \n                return ((long)y & 1) == 0 ? pow(-x, y) : -pow(-x, y);\n            } else {\n                return Double.NaN;\n            }\n        }\n\n        \n        double ya;\n        double yb;\n        if (y < 8e298 && y > -8e298) {\n            double tmp1 = y * 1073741824.0;\n            ya = y + tmp1 - tmp1;\n            yb = y - ya;\n        } else {\n            double tmp1 = y * 9.31322574615478515625E-10;\n            double tmp2 = tmp1 * 9.31322574615478515625E-10;\n            ya = (tmp1 + tmp2 - tmp1) * 1073741824.0 * 1073741824.0;\n            yb = y - ya;\n        }\n\n        \n        log(x, lns);\n        double lna = lns[0];\n        double lnb = lns[1];\n\n        \n        double tmp1 = lna * 1073741824.0;\n        double tmp2 = lna + tmp1 - tmp1;\n        lnb += lna - tmp2;\n        lna = tmp2;\n\n        \n        final double aa = lna * ya;\n        final double ab = lna * yb + lnb * ya + lnb * yb;\n\n        lna = aa+ab;\n        lnb = -(lna - aa - ab);\n\n        double z = 1.0 / 120.0;\n        z = z * lnb + (1.0 / 24.0);\n        z = z * lnb + (1.0 / 6.0);\n        z = z * lnb + 0.5;\n        z = z * lnb + 1.0;\n        z = z * lnb;\n\n        final double result = exp(lna, z, null);\n        \n        return result;\n    }\n\n    \n    private static double[] slowLog(double xi) {\n        double x[] = new double[2];\n        double x2[] = new double[2];\n        double y[] = new double[2];\n        double a[] = new double[2];\n\n        split(xi, x);\n\n        \n        x[0] += 1.0;\n        resplit(x);\n        splitReciprocal(x, a);\n        x[0] -= 2.0;\n        resplit(x);\n        splitMult(x, a, y);\n        x[0] = y[0];\n        x[1] = y[1];\n\n        \n        splitMult(x, x, x2);\n\n\n        \n        \n\n        y[0] = LN_SPLIT_COEF[LN_SPLIT_COEF.length-1][0];\n        y[1] = LN_SPLIT_COEF[LN_SPLIT_COEF.length-1][1];\n\n        for (int i = LN_SPLIT_COEF.length-2; i >= 0; i--) {\n            splitMult(y, x2, a);\n            y[0] = a[0];\n            y[1] = a[1];\n            splitAdd(y, LN_SPLIT_COEF[i], a);\n            y[0] = a[0];\n            y[1] = a[1];\n        }\n\n        splitMult(y, x, a);\n        y[0] = a[0];\n        y[1] = a[1];\n\n        return y;\n    }\n\n    \n    private static double slowSin(final double x, final double result[]) {\n        final double xs[] = new double[2];\n        final double ys[] = new double[2];\n        final double facts[] = new double[2];\n        final double as[] = new double[2];\n        split(x, xs);\n        ys[0] = ys[1] = 0.0;\n\n        for (int i = 19; i >= 0; i--) {\n            splitMult(xs, ys, as);\n            ys[0] = as[0]; ys[1] = as[1];\n\n            if ( (i & 1) == 0) {\n                continue;\n            }\n\n            split(FACT[i], as);\n            splitReciprocal(as, facts);\n\n            if ( (i & 2) != 0 ) {\n                facts[0] = -facts[0];\n                facts[1] = -facts[1];\n            }\n\n            splitAdd(ys, facts, as);\n            ys[0] = as[0]; ys[1] = as[1];\n        }\n\n        if (result != null) {\n            result[0] = ys[0];\n            result[1] = ys[1];\n        }\n\n        return ys[0] + ys[1];\n    }\n\n    \n    private static double slowCos(final double x, final double result[]) {\n\n        final double xs[] = new double[2];\n        final double ys[] = new double[2];\n        final double facts[] = new double[2];\n        final double as[] = new double[2];\n        split(x, xs);\n        ys[0] = ys[1] = 0.0;\n\n        for (int i = 19; i >= 0; i--) {\n            splitMult(xs, ys, as);\n            ys[0] = as[0]; ys[1] = as[1];\n\n            if ( (i & 1) != 0) {\n                continue;\n            }\n\n            split(FACT[i], as);\n            splitReciprocal(as, facts);\n\n            if ( (i & 2) != 0 ) {\n                facts[0] = -facts[0];\n                facts[1] = -facts[1];\n            }\n\n            splitAdd(ys, facts, as);\n            ys[0] = as[0]; ys[1] = as[1];\n        }\n\n        if (result != null) {\n            result[0] = ys[0];\n            result[1] = ys[1];\n        }\n\n        return ys[0] + ys[1];\n    }\n\n    \n    private static void buildSinCosTables() {\n        final double result[] = new double[2];\n\n        \n        for (int i = 0; i < 7; i++) {\n            double x = i / 8.0;\n\n            slowSin(x, result);\n            SINE_TABLE_A[i] = result[0];\n            SINE_TABLE_B[i] = result[1];\n\n            slowCos(x, result);\n            COSINE_TABLE_A[i] = result[0];\n            COSINE_TABLE_B[i] = result[1];\n        }\n\n        \n        for (int i = 7; i < 14; i++) {\n            double xs[] = new double[2];\n            double ys[] = new double[2];\n            double as[] = new double[2];\n            double bs[] = new double[2];\n            double temps[] = new double[2];\n\n            if ( (i & 1) == 0) {\n                \n                xs[0] = SINE_TABLE_A[i/2];\n                xs[1] = SINE_TABLE_B[i/2];\n                ys[0] = COSINE_TABLE_A[i/2];\n                ys[1] = COSINE_TABLE_B[i/2];\n\n                \n                splitMult(xs, ys, result);\n                SINE_TABLE_A[i] = result[0] * 2.0;\n                SINE_TABLE_B[i] = result[1] * 2.0;\n\n                \n                splitMult(ys, ys, as);\n                splitMult(xs, xs, temps);\n                temps[0] = -temps[0];\n                temps[1] = -temps[1];\n                splitAdd(as, temps, result);\n                COSINE_TABLE_A[i] = result[0];\n                COSINE_TABLE_B[i] = result[1];\n            } else {\n                xs[0] = SINE_TABLE_A[i/2];\n                xs[1] = SINE_TABLE_B[i/2];\n                ys[0] = COSINE_TABLE_A[i/2];\n                ys[1] = COSINE_TABLE_B[i/2];\n                as[0] = SINE_TABLE_A[i/2+1];\n                as[1] = SINE_TABLE_B[i/2+1];\n                bs[0] = COSINE_TABLE_A[i/2+1];\n                bs[1] = COSINE_TABLE_B[i/2+1];\n\n                \n                splitMult(xs, bs, temps);\n                splitMult(ys, as, result);\n                splitAdd(result, temps, result);\n                SINE_TABLE_A[i] = result[0];\n                SINE_TABLE_B[i] = result[1];\n\n                \n                splitMult(ys, bs, result);\n                splitMult(xs, as, temps);\n                temps[0] = -temps[0];\n                temps[1] = -temps[1];\n                splitAdd(result, temps, result);\n                COSINE_TABLE_A[i] = result[0];\n                COSINE_TABLE_B[i] = result[1];\n            }\n        }\n\n        \n        for (int i = 0; i < 14; i++) {\n            double xs[] = new double[2];\n            double ys[] = new double[2];\n            double as[] = new double[2];\n\n            as[0] = COSINE_TABLE_A[i];\n            as[1] = COSINE_TABLE_B[i];\n\n            splitReciprocal(as, ys);\n\n            xs[0] = SINE_TABLE_A[i];\n            xs[1] = SINE_TABLE_B[i];\n\n            splitMult(xs, ys, as);\n\n            TANGENT_TABLE_A[i] = as[0];\n            TANGENT_TABLE_B[i] = as[1];\n        }\n\n    }\n\n    \n    private static double polySine(final double x) {\n        double x2 = x*x;\n\n        double p = 2.7553817452272217E-6;\n        p = p * x2 + -1.9841269659586505E-4;\n        p = p * x2 + 0.008333333333329196;\n        p = p * x2 + -0.16666666666666666;\n        \n        \n        p = p * x2 * x;\n\n        return p;\n    }\n\n    \n    private static double polyCosine(double x) {\n        double x2 = x*x;\n\n        double p = 2.479773539153719E-5;\n        p = p * x2 + -0.0013888888689039883;\n        p = p * x2 + 0.041666666666621166;\n        p = p * x2 + -0.49999999999999994;\n        p *= x2;\n\n        return p;\n    }\n\n    \n    private static double sinQ(double xa, double xb) {\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHES[idx]; \n\n        \n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        \n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        \n        final double temp = sinEpsA * 1073741824.0;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        \n        double result;\n\n        \n\n        \n        \n\n        \n        \n        double a = 0;\n        double b = 0;\n\n        double t = sintA;\n        double c = a + t;\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA * sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA * cosEpsB + costA * sinEpsB;\n        \n\n        b = b + sintB + costB * sinEpsA + sintB * cosEpsB + costB * sinEpsB;\n        \n\n        if (xb != 0.0) {\n            t = ((costA + costB) * (cosEpsA + cosEpsB) -\n                 (sintA + sintB) * (sinEpsA + sinEpsB)) * xb;  \n            c = a + t;\n            d = -(c - a - t);\n            a = c;\n            b = b + d;\n        }\n\n        result = a + b;\n\n        return result;\n    }\n\n    \n    private static double cosQ(double xa, double xb) {\n        final double pi2a = 1.5707963267948966;\n        final double pi2b = 6.123233995736766E-17;\n\n        final double a = pi2a - xa;\n        double b = -(a - pi2a + xa);\n        b += pi2b - xb;\n\n        return sinQ(a, b);\n    }\n\n    \n    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHES[idx]; \n\n        \n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        \n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        \n        double temp = sinEpsA * 1073741824.0;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        \n\n        \n\n        \n        \n\n        \n        \n        double a = 0;\n        double b = 0;\n\n        \n        double t = sintA;\n        double c = a + t;\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        \n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        \n        \n\n        \n\n        double est = sina/cosa;\n\n        \n        temp = est * 1073741824.0;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * 1073741824.0;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        \n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  \n        err += sinb/cosa;                     \n        err += -sina * cosb / cosa / cosa;    \n\n        if (xb != 0.0) {\n            \n            \n            double xbadj = xb + est*est*xb;\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }\n\n    \n    private static void reducePayneHanek(double x, double result[]) {\n        \n        long inbits = Double.doubleToLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        \n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        \n        exponent++;\n        inbits <<= 11;\n\n        \n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        \n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        \n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        \n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        \n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        \n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        \n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        \n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        \n\n        \n        int intPart = (int)(prodA >>> 62);\n\n        \n        prodA <<= 2;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        \n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        \n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        \n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        \n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        \n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        \n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        \n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        \n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        \n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        \n        double tmpA = (prod2A >>> 12) / 4503599627370496.0;  \n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / 4503599627370496.0 / 4503599627370496.0; \n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        \n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }\n\n    \n    public static double sin(double x) {\n        boolean negative = false;\n        int quadrant = 0;\n        double xa;\n        double xb = 0.0;\n\n        \n        xa = x;\n        if (x < 0) {\n            negative = true;\n            xa = -xa;\n        }\n\n        \n        if (xa == 0.0) {\n            long bits = Double.doubleToLongBits(x);\n            if (bits < 0) {\n                return -0.0;\n            }\n            return 0.0;\n        }\n\n        if (xa != xa || xa == Double.POSITIVE_INFINITY) {\n            return Double.NaN;\n        }\n\n        \n        if (xa > 3294198.0) {\n            \n            \n            \n            double reduceResults[] = new double[3];\n            reducePayneHanek(xa, reduceResults);\n            quadrant = ((int) reduceResults[0]) & 3;\n            xa = reduceResults[1];\n            xb = reduceResults[2];\n        } else if (xa > 1.5707963267948966) {\n            \n\n            \n            \n            int k = (int)(xa * 0.6366197723675814);\n\n            \n            double remA;\n            double remB;\n            while (true) {\n                double a = -k * 1.570796251296997;\n                remA = xa + a;\n                remB = -(remA - xa - a);\n\n                a = -k * 7.549789948768648E-8;\n                double b = remA;\n                remA = a + b;\n                remB += -(remA - b - a);\n\n                a = -k * 6.123233995736766E-17;\n                b = remA;\n                remA = a + b;\n                remB += -(remA - b - a);\n\n                if (remA > 0.0)\n                    break;\n\n                \n                \n                \n                k--;\n            }\n            quadrant = k & 3;\n            xa = remA;\n            xb = remB;\n        }\n\n        if (negative) {\n            quadrant ^= 2;  \n        }\n\n        switch (quadrant) {\n            case 0:\n                return sinQ(xa, xb);\n            case 1:\n                return cosQ(xa, xb);\n            case 2:\n                return -sinQ(xa, xb);\n            case 3:\n                return -cosQ(xa, xb);\n            default:\n                return Double.NaN;\n        }\n    }\n\n    \n    public static double cos(double x) {\n        int quadrant = 0;\n\n        \n        double xa = x;\n        if (x < 0) {\n            xa = -xa;\n        }\n\n        if (xa != xa || xa == Double.POSITIVE_INFINITY) {\n            return Double.NaN;\n        }\n\n        \n        double xb = 0;\n        if (xa > 3294198.0) {\n            \n            \n            \n            double reduceResults[] = new double[3];\n            reducePayneHanek(xa, reduceResults);\n            quadrant = ((int) reduceResults[0]) & 3;\n            xa = reduceResults[1];\n            xb = reduceResults[2];\n        } else if (xa > 1.5707963267948966) {\n            \n\n            \n            \n            int k = (int)(xa * 0.6366197723675814);\n\n            \n            double remA;\n            double remB;\n            while (true) {\n                double a = -k * 1.570796251296997;\n                remA = xa + a;\n                remB = -(remA - xa - a);\n\n                a = -k * 7.549789948768648E-8;\n                double b = remA;\n                remA = a + b;\n                remB += -(remA - b - a);\n\n                a = -k * 6.123233995736766E-17;\n                b = remA;\n                remA = a + b;\n                remB += -(remA - b - a);\n\n                if (remA > 0.0)\n                    break;\n\n                \n                \n                \n                k--;\n            }\n            quadrant = k & 3;\n            xa = remA;\n            xb = remB;\n        }\n\n        \n        \n\n        switch (quadrant) {\n            case 0:\n                return cosQ(xa, xb);\n            case 1:\n                return -sinQ(xa, xb);\n            case 2:\n                return -cosQ(xa, xb);\n            case 3:\n                return sinQ(xa, xb);\n            default:\n                return Double.NaN;\n        }\n    }\n\n    \n    public static double tan(double x) {\n        boolean negative = false;\n        int quadrant = 0;\n\n        \n        double xa = x;\n        if (x < 0) {\n            negative = true;\n            xa = -xa;\n        }\n\n        \n        if (xa == 0.0) {\n            long bits = Double.doubleToLongBits(x);\n            if (bits < 0) {\n                return -0.0;\n            }\n            return 0.0;\n        }\n\n        if (xa != xa || xa == Double.POSITIVE_INFINITY) {\n            return Double.NaN;\n        }\n\n        \n        double xb = 0;\n        if (xa > 3294198.0) {\n            \n            \n            \n            double reduceResults[] = new double[3];\n            reducePayneHanek(xa, reduceResults);\n            quadrant = ((int) reduceResults[0]) & 3;\n            xa = reduceResults[1];\n            xb = reduceResults[2];\n        } else if (xa > 1.5707963267948966) {\n            \n\n            \n            \n            int k = (int)(xa * 0.6366197723675814);\n\n            \n            double remA;\n            double remB;\n            while (true) {\n                double a = -k * 1.570796251296997;\n                remA = xa + a;\n                remB = -(remA - xa - a);\n\n                a = -k * 7.549789948768648E-8;\n                double b = remA;\n                remA = a + b;\n                remB += -(remA - b - a);\n\n                a = -k * 6.123233995736766E-17;\n                b = remA;\n                remA = a + b;\n                remB += -(remA - b - a);\n\n                if (remA > 0.0)\n                    break;\n\n                \n                \n                \n                k--;\n            }\n            quadrant = k & 3;\n            xa = remA;\n            xb = remB;\n        }\n\n        if (xa > 1.5) {\n            \n            final double pi2a = 1.5707963267948966;\n            final double pi2b = 6.123233995736766E-17;\n\n            final double a = pi2a - xa;\n            double b = -(a - pi2a + xa);\n            b += pi2b - xb;\n\n            xa = a + b;\n            xb = -(xa - a - b);\n            quadrant ^= 1;\n            negative ^= true;\n        }\n\n        double result;\n        if ((quadrant & 1) == 0) {\n            result = tanQ(xa, xb, false);\n        } else {\n            result = -tanQ(xa, xb, true);\n        }\n\n        if (negative) {\n            result = -result;\n        }\n\n        return result;\n    }\n\n    \n    public static double atan(double x) {\n        return atan(x, 0.0, false);\n    }\n\n    \n    private static double atan(double xa, double xb, boolean leftPlane) {\n        boolean negate = false;\n        int idx;\n\n        if (xa < 0) {\n            \n            xa = -xa;\n            xb = -xb;\n            negate = true;\n        }\n\n        if (xa > 1.633123935319537E16) { \n            return (negate ^ leftPlane) ? (-Math.PI/2.0) : (Math.PI/2.0);\n        }\n\n        \n        if (xa < 1.0) {\n            idx = (int) (((-1.7168146928204136 * xa * xa + 8.0) * xa) + 0.5);\n        } else {\n            double temp = 1.0/xa;\n            idx = (int) (-((-1.7168146928204136 * temp * temp + 8.0) * temp) + 13.07);\n        }\n        double epsA = xa - TANGENT_TABLE_A[idx];\n        double epsB = -(epsA - xa + TANGENT_TABLE_A[idx]);\n        epsB += xb - TANGENT_TABLE_B[idx];\n\n        double temp = epsA + epsB;\n        epsB = -(temp - epsA - epsB);\n        epsA = temp;\n\n        \n        temp = xa * 1073741824.0;\n        double ya = xa + temp - temp;\n        double yb = xb + xa - ya;\n        xa = ya;\n        xb += yb;\n\n        \n        if (idx == 0) {\n            \n            \n            double denom = 1.0 / (1.0 + (xa + xb) * (TANGENT_TABLE_A[idx] + TANGENT_TABLE_B[idx]));\n            \n            ya = epsA * denom;\n            yb = epsB * denom;\n        } else {\n            double temp2 = xa * TANGENT_TABLE_A[idx];\n            double za = 1.0 + temp2;\n            double zb = -(za - 1.0 - temp2);\n            temp2 = xb * TANGENT_TABLE_A[idx] + xa * TANGENT_TABLE_B[idx];\n            temp = za + temp2;\n            zb += -(temp - za - temp2);\n            za = temp;\n\n            zb += xb * TANGENT_TABLE_B[idx];\n            ya = epsA / za;\n\n            temp = ya * 1073741824.0;\n            final double yaa = (ya + temp) - temp;\n            final double yab = ya - yaa;\n\n            temp = za * 1073741824.0;\n            final double zaa = (za + temp) - temp;\n            final double zab = za - zaa;\n\n            \n            yb = (epsA - yaa * zaa - yaa * zab - yab * zaa - yab * zab) / za;\n\n            yb += -epsA * zb / za / za;\n            yb += epsB / za;\n        }\n\n\n        epsA = ya;\n        epsB = yb;\n\n        \n        double epsA2 = epsA*epsA;\n\n        \n\n        yb = 0.07490822288864472;\n        yb = yb * epsA2 + -0.09088450866185192;\n        yb = yb * epsA2 + 0.11111095942313305;\n        yb = yb * epsA2 + -0.1428571423679182;\n        yb = yb * epsA2 + 0.19999999999923582;\n        yb = yb * epsA2 + -0.33333333333333287;\n        yb = yb * epsA2 * epsA;\n\n\n        ya = epsA;\n\n        temp = ya + yb;\n        yb = -(temp - ya - yb);\n        ya = temp;\n\n        \n        yb += epsB / (1.0 + epsA * epsA);\n\n        double result;\n        double resultb;\n\n        \n        double za = EIGHTHES[idx] + ya;\n        double zb = -(za - EIGHTHES[idx] - ya);\n        temp = za + yb;\n        zb += -(temp - za - yb);\n        za = temp;\n\n        result = za + zb;\n        resultb = -(result - za - zb);\n\n        if (leftPlane) {\n            \n            final double pia = 1.5707963267948966*2.0;\n            final double pib = 6.123233995736766E-17*2.0;\n\n            za = pia - result;\n            zb = -(za - pia + result);\n            zb += pib - resultb;\n\n            result = za + zb;\n            resultb = -(result - za - zb);\n        }\n\n\n        if (negate ^ leftPlane) {\n            result = -result;\n        }\n\n        return result;\n    }\n\n    \n    public static double atan2(double y, double x) {\n        if (x !=x || y != y) {\n            return Double.NaN;\n        }\n\n        if (y == 0.0) {\n            double result = x*y;\n            double invx = 1.0/x;\n            double invy = 1.0/y;\n\n            if (invx == 0.0) { \n                if (x > 0) {\n                    return 0.0;\n                } else {\n                    return Math.PI;\n                }\n            }\n\n            if (result != result) { \n                return x/y;\n            }\n\n            if (x < 0.0 || invx < 0.0) {\n                if (y < 0.0 || invy < 0.0) {\n                    return -Math.PI;\n                } else {\n                    return Math.PI;\n                }\n            } else {\n                return result;\n            }\n        }\n\n        if (y == Double.POSITIVE_INFINITY) {\n            if (x == Double.POSITIVE_INFINITY) {\n                return Math.PI/4.0;\n            }\n\n            if (x == Double.NEGATIVE_INFINITY) {\n                return Math.PI*3.0/4.0;\n            }\n\n            return Math.PI/2.0;\n        }\n\n        if (y == Double.NEGATIVE_INFINITY) {\n            if (x == Double.POSITIVE_INFINITY) {\n                return -Math.PI/4.0;\n            }\n\n            if (x == Double.NEGATIVE_INFINITY) {\n                return -Math.PI*3.0/4.0;\n            }\n\n            return -Math.PI/2.0;\n        }\n\n        if (x == Double.POSITIVE_INFINITY) {\n            if (y > 0.0 || 1/y > 0.0) {\n                return 0.0;\n            }\n\n            if (y < 0.0 || 1/y < 0.0) {\n                return -0.0;\n            }\n        }\n\n        if (x == Double.NEGATIVE_INFINITY)\n        {\n            if (y > 0.0 || 1/y > 0.0) {\n                return Math.PI;\n            }\n\n            if (y < 0.0 || 1/y < 0.0) {\n                return -Math.PI;\n            }\n        }\n\n        if (x == 0) {\n            if (y > 0.0 || 1/y > 0.0) {\n                return Math.PI/2.0;\n            }\n\n            if (y < 0.0 || 1/y < 0.0) {\n                return -Math.PI/2.0;\n            }\n        }\n\n        if (x > 8e298 || x < -8e298) { \n            x *= 9.31322574615478515625E-10;\n            y *= 9.31322574615478515625E-10;\n        }\n\n        \n        double temp = x * 1073741824.0;\n        final double xa = x + temp - temp;\n        final double xb = x - xa;\n\n        \n        final double r = y/x;\n        temp = r * 1073741824.0;\n        double ra = r + temp - temp;\n        double rb = r - ra;\n\n        rb += (y - ra * xa - ra * xb - rb * xa - rb * xb) / x;\n\n        temp = ra + rb;\n        rb = -(temp - ra - rb);\n        ra = temp;\n\n        \n        double result = atan(ra, rb, x < 0);\n\n        return result;\n    }\n\n    \n    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      \n\n      \n      double temp = x * 1073741824.0;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      \n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      \n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      \n      double y;\n      y = sqrt(za);\n      temp = y * 1073741824.0;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      \n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      \n      double dx = zb / (2.0*y);\n\n      \n      double r = x/y;\n      temp = r * 1073741824.0;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  \n      rb += -x * dx / y / y;  \n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }\n\n    \n    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      \n\n      \n      double temp = x * 1073741824.0;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      \n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      \n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      \n      double y = sqrt(za);\n      temp = y * 1073741824.0;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      \n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      \n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      \n      double r = y/x;\n      temp = r * 1073741824.0;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  \n      rb += yb / x;  \n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }\n\n    \n    public static double cbrt(double x) {\n      \n      long inbits = Double.doubleToLongBits(x);\n      int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      boolean subnormal = false;\n\n      if (exponent == -1023) {\n          if (x == 0) {\n              return x;\n          }\n\n          \n          subnormal = true;\n          x *= 1.8014398509481984E16;  \n          inbits = Double.doubleToLongBits(x);\n          exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      }\n\n      if (exponent == 1024) {\n          \n          return x;\n      }\n\n      \n      int exp3 = exponent / 3;\n\n      \n      double p2 = Double.longBitsToDouble((inbits & 0x8000000000000000L) |\n                                          (long)(((exp3 + 1023) & 0x7ff)) << 52);\n\n      \n      final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L);\n\n      \n      double est = -0.010714690733195933;\n      est = est * mant + 0.0875862700108075;\n      est = est * mant + -0.3058015757857271;\n      est = est * mant + 0.7249995199969751;\n      est = est * mant + 0.5039018405998233;\n\n      est *= CBRTTWO[exponent % 3 + 2];\n\n      \n      \n      \n      final double xs = x / (p2*p2*p2);\n      est += (xs - est*est*est) / (3*est*est);\n      est += (xs - est*est*est) / (3*est*est);\n\n      \n      double temp = est * 1073741824.0;\n      double ya = est + temp - temp;\n      double yb = est - ya;\n\n      double za = ya * ya;\n      double zb = ya * yb * 2.0 + yb * yb;\n      temp = za * 1073741824.0;\n      double temp2 = za + temp - temp;\n      zb += za - temp2;\n      za = temp2;\n\n      zb = za * yb + ya * zb + zb * yb;\n      za = za * ya;\n\n      double na = xs - za;\n      double nb = -(na - xs + za);\n      nb -= zb;\n\n      est += (na+nb)/(3*est*est);\n\n      \n      est *= p2;\n\n      if (subnormal) {\n          est *= 3.814697265625E-6;  \n      }\n\n      return est;\n    }\n\n    \n    public static double toRadians(double x) {\n        final double facta = 0.01745329052209854;\n        final double factb = 1.997844754509471E-9;\n\n        double temp = x * 1073741824.0;\n        double xa = x + temp - temp;\n        double xb = x - xa;\n\n        return xb * factb + xb * facta + xa * factb + xa * facta;\n    }\n\n    \n    public static double toDegrees(double x) {\n        final double facta = 57.2957763671875;\n        final double factb = 3.145894820876798E-6;\n\n        double temp = x * 1073741824.0;\n        double xa = x + temp - temp;\n        double xb = x - xa;\n\n        return xb * factb + xb * facta + xa * factb + xa * facta;\n    }\n\n    \n    public static int abs(final int x) {\n        return (x < 0) ? -x : x;\n    }\n\n    \n    public static long abs(final long x) {\n        return (x < 0l) ? -x : x;\n    }\n\n    \n    public static float abs(final float x) {\n        return (x < 0.0f) ? -x : x;\n    }\n\n    \n    public static double abs(double x) {\n        return (x < 0.0) ? -x : x;\n    }\n\n    \n\n    public static double ulp(double x) {\n        return abs(x - Double.longBitsToDouble(Double.doubleToLongBits(x) ^ 1));\n    }\n\n    \n    public static double nextAfter(double d, double direction) {\n\n        \n        if (Double.isNaN(d) || Double.isInfinite(d)) {\n            return d;\n        } else if (d == 0) {\n            return (direction < 0) ? -Double.MIN_VALUE : Double.MIN_VALUE;\n        }\n        \n        \n\n        \n        long bits     = Double.doubleToLongBits(d);\n        long sign     = bits & 0x8000000000000000L;\n        long exponent = bits & 0x7ff0000000000000L;\n        long mantissa = bits & 0x000fffffffffffffL;\n\n        if (d * (direction - d) >= 0) {\n            \n            if (mantissa == 0x000fffffffffffffL) {\n                return Double.longBitsToDouble(sign |\n                                               (exponent + 0x0010000000000000L));\n            } else {\n                return Double.longBitsToDouble(sign |\n                                               exponent | (mantissa + 1));\n            }\n        } else {\n            \n            if (mantissa == 0L) {\n                return Double.longBitsToDouble(sign |\n                                               (exponent - 0x0010000000000000L) |\n                                               0x000fffffffffffffL);\n            } else {\n                return Double.longBitsToDouble(sign |\n                                               exponent | (mantissa - 1));\n            }\n        }\n\n    }\n\n    \n    public static double floor(double x) {\n        long y;\n\n        if (x != x) { \n            return x;\n        }\n\n        if (x >= 4503599627370496.0 || x <= -4503599627370496.0) {\n            return x;\n        }\n\n        y = (long) x;\n        if (x < 0 && y != x) {\n            y--;\n        }\n\n        if (y == 0) {\n            return x*y;\n        }\n\n        return (double) y;\n    }\n\n    \n    public static double ceil(double x) {\n        double y;\n\n        if (x != x) { \n            return x;\n        }\n\n        y = floor(x);\n        if (y == x) {\n            return y;\n        }\n\n        y += 1.0;\n\n        if (y == 0) {\n            return x*y;\n        }\n\n        return y;\n    }\n\n    \n    public static double rint(double x) {\n        double y = floor(x);\n        double d = x - y;\n\n        if (d > 0.5) {\n            return y+1.0;\n        }\n        if (d < 0.5) {\n            return y;\n        }\n\n        \n        long z = (long) y;\n        return (z & 1) == 0 ? y : y + 1.0;\n    }\n\n    \n    public static long round(double x) {\n        return (long) floor(x + 0.5);\n    }\n\n    \n    public static int round(final float x) {\n        return Math.round(x);\n    }\n\n    \n    public static int min(final int a, final int b) {\n        return (a <= b) ? a : b;\n    }\n\n    \n    public static long min(final long a, final long b) {\n        return (a <= b) ? a : b;\n    }\n\n    \n    public static float min(final float a, final float b) {\n        return (a <= b) ? a : (Float.isNaN(a + b) ? Float.NaN : b);\n    }\n\n    \n    public static double min(final double a, final double b) {\n        return (a <= b) ? a : (Double.isNaN(a + b) ? Double.NaN : b);\n    }\n\n    \n    public static int max(final int a, final int b) {\n        return (a <= b) ? b : a;\n    }\n\n    \n    public static long max(final long a, final long b) {\n        return (a <= b) ? b : a;\n    }\n\n    \n    public static float max(final float a, final float b) {\n        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);\n    }\n\n    \n    public static double max(final double a, final double b) {\n        return (a <= b) ? b : (Double.isNaN(a + b) ? Double.NaN : a);\n    }\n\n}\n",
      "fixed_full_code": "\npackage org.apache.commons.math.util;\n\n\npublic class FastMath { public static final double PI = 105414357.0 / 33554432.0 + 1.984187159361080883e-9; public static final double E = 2850325.0 / 1048576.0 + 8.254840070411028747e-8; private static final double EXP_INT_TABLE_A[] = new double[1500]; private static final double EXP_INT_TABLE_B[] = new double[1500]; private static final double EXP_FRAC_TABLE_A[] = new double[1025]; private static final double EXP_FRAC_TABLE_B[] = new double[1025]; private static final double FACT[] = new double[20]; private static final double LN_MANT[][] = new double[1024][]; private static final double LN_2_A = 0.693147063255310059; private static final double LN_2_B = 1.17304635250823482e-7; private static final double LN_SPLIT_COEF[][] = { {2.0, 0.0}, {0.6666666269302368, 3.9736429850260626E-8}, {0.3999999761581421, 2.3841857910019882E-8}, {0.2857142686843872, 1.7029898543501842E-8}, {0.2222222089767456, 1.3245471311735498E-8}, {0.1818181574344635, 2.4384203044354907E-8}, {0.1538461446762085, 9.140260083262505E-9}, {0.13333332538604736, 9.220590270857665E-9}, {0.11764700710773468, 1.2393345855018391E-8}, {0.10526403784751892, 8.251545029714408E-9}, {0.0952233225107193, 1.2675934823758863E-8}, {0.08713622391223907, 1.1430250008909141E-8}, {0.07842259109020233, 2.404307984052299E-9}, {0.08371849358081818, 1.176342548272881E-8}, {0.030589580535888672, 1.2958646899018938E-9}, {0.14982303977012634, 1.225743062930824E-8}, }; private static final double LN_QUICK_COEF[][] = { {1.0, 5.669184079525E-24}, {-0.25, -0.25}, {0.3333333134651184, 1.986821492305628E-8}, {-0.25, -6.663542893624021E-14}, {0.19999998807907104, 1.1921056801463227E-8}, {-0.1666666567325592, -7.800414592973399E-9}, {0.1428571343421936, 5.650007086920087E-9}, {-0.12502530217170715, -7.44321345601866E-11}, {0.11113807559013367, 9.219544613762692E-9}, }; private static final double LN_HI_PREC_COEF[][] = { {1.0, -6.032174644509064E-23}, {-0.25, -0.25}, {0.3333333134651184, 1.9868161777724352E-8}, {-0.2499999701976776, -2.957007209750105E-8}, {0.19999954104423523, 1.5830993332061267E-10}, {-0.16624879837036133, -2.6033824355191673E-8} }; private static final double SINE_TABLE_A[] = new double[14]; private static final double SINE_TABLE_B[] = new double[14]; private static final double COSINE_TABLE_A[] = new double[14]; private static final double COSINE_TABLE_B[] = new double[14]; private static final double TANGENT_TABLE_A[] = new double[14]; private static final double TANGENT_TABLE_B[] = new double[14]; private static long RECIP_2PI[] = new long[] { (0x28be60dbL << 32) | 0x9391054aL, (0x7f09d5f4L << 32) | 0x7d4d3770L, (0x36d8a566L << 32) | 0x4f10e410L, (0x7f9458eaL << 32) | 0xf7aef158L, (0x6dc91b8eL << 32) | 0x909374b8L, (0x01924bbaL << 32) | 0x82746487L, (0x3f877ac7L << 32) | 0x2c4a69cfL, (0xba208d7dL << 32) | 0x4baed121L, (0x3a671c09L << 32) | 0xad17df90L, (0x4e64758eL << 32) | 0x60d4ce7dL, (0x272117e2L << 32) | 0xef7e4a0eL, (0xc7fe25ffL << 32) | 0xf7816603L, (0xfbcbc462L << 32) | 0xd6829b47L, (0xdb4d9fb3L << 32) | 0xc9f2c26dL, (0xd3d18fd9L << 32) | 0xa797fa8bL, (0x5d49eeb1L << 32) | 0xfaf97c5eL, (0xcf41ce7dL << 32) | 0xe294a4baL, 0x9afed7ecL << 32 }; private static long PI_O_4_BITS[] = new long[] {\n        (0xc90fdaa2L << 32) | 0x2168c234L,\n        (0xc4c6628bL << 32) | 0x80dc1cd1L };\n\n    \n    private static final double EIGHTHES[] = {0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875, 1.0, 1.125, 1.25, 1.375, 1.5, 1.625}; private static final double CBRTTWO[] = { 0.6299605249474366, 0.7937005259840998, 1.0, 1.2599210498948732, 1.5874010519681994 }; static { int i; FACT[0] = 1.0; for (i = 1; i < 20; i++) {\n            FACT[i] = FACT[i-1] * i;\n        }\n\n        double tmp[] = new double[2];\n        double recip[] = new double[2];\n\n        \n        for (i = 0; i < 750; i++) {\n            expint(i, tmp);\n            EXP_INT_TABLE_A[i+750] = tmp[0];\n            EXP_INT_TABLE_B[i+750] = tmp[1];\n\n            if (i != 0) {\n                \n                splitReciprocal(tmp, recip);\n                EXP_INT_TABLE_A[750-i] = recip[0];\n                EXP_INT_TABLE_B[750-i] = recip[1];\n            }\n        }\n\n        \n        for (i = 0; i < 1025; i++) {\n            slowexp(i/1024.0, tmp);\n            EXP_FRAC_TABLE_A[i] = tmp[0];\n            EXP_FRAC_TABLE_B[i] = tmp[1];\n        }\n\n        \n        for (i = 0; i < 1024; i++) {\n            double d = Double.longBitsToDouble( (((long) i) << 42) | 0x3ff0000000000000L );\n            LN_MANT[i] = slowLog(d);\n        }\n\n        \n        buildSinCosTables();\n    }\n\n    \n    private FastMath() {\n    }\n\n    \n    public static double sqrt(final double a) {\n        return Math.sqrt(a);\n    }\n\n    \n    public static double cosh(double x) {\n      if (x != x) {\n          return x;\n      }\n\n      if (x > 20.0) {\n          return exp(x)/2.0;\n      }\n\n      if (x < -20) {\n          return exp(-x)/2.0;\n      }\n\n      double hiPrec[] = new double[2];\n      if (x < 0.0) {\n          x = -x;\n      }\n      exp(x, 0.0, hiPrec);\n\n      double ya = hiPrec[0] + hiPrec[1];\n      double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n      double temp = ya * 1073741824.0;\n      double yaa = ya + temp - temp;\n      double yab = ya - yaa;\n\n      \n      double recip = 1.0/ya;\n      temp = recip * 1073741824.0;\n      double recipa = recip + temp - temp;\n      double recipb = recip - recipa;\n\n      \n      recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n      \n      recipb += -yb * recip * recip;\n\n      \n      temp = ya + recipa;\n      yb += -(temp - ya - recipa);\n      ya = temp;\n      temp = ya + recipb;\n      yb += -(temp - ya - recipb);\n      ya = temp;\n\n      double result = ya + yb;\n      result *= 0.5;\n      return result;\n    }\n\n    \n    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      if (x > 20.0) {\n          return exp(x)/2.0;\n      }\n\n      if (x < -20) {\n          return -exp(-x)/2.0;\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * 1073741824.0;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          \n          double recip = 1.0/ya;\n          temp = recip * 1073741824.0;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          \n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          \n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          \n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          \n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * 1073741824.0;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * 1073741824.0;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          \n          rb += yb*denomr;                        \n          rb += -ya * denomb * denomr * denomr;   \n\n          \n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }\n\n    \n    public static double tanh(double x) {\n      boolean negate = false;\n\n      if (x != x) {\n          return x;\n      }\n\n      if (x > 20.0) {\n          return 1.0;\n      }\n\n      if (x < -20) {\n          return -1.0;\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n      if (x >= 0.5) {\n          double hiPrec[] = new double[2];\n          \n          exp(x*2.0, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          \n          double na = -1.0 + ya;\n          double nb = -(na + 1.0 - ya);\n          double temp = na + yb;\n          nb += -(temp - na - yb);\n          na = temp;\n\n          \n          double da = 1.0 + ya;\n          double db = -(da - 1.0 - ya);\n          temp = da + yb;\n          db += -(temp - da - yb);\n          da = temp;\n\n          temp = da * 1073741824.0;\n          double daa = da + temp - temp;\n          double dab = da - daa;\n\n          \n          double ratio = na/da;\n          temp = ratio * 1073741824.0;\n          double ratioa = ratio + temp - temp;\n          double ratiob = ratio - ratioa;\n\n          \n          ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\n\n          \n          ratiob += nb / da;\n          \n          ratiob += -db * na / da / da;\n\n          result = ratioa + ratiob;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          \n          expm1(x*2.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          \n          double na = ya;\n          double nb = yb;\n\n          \n          double da = 2.0 + ya;\n          double db = -(da - 2.0 - ya);\n          double temp = da + yb;\n          db += -(temp - da - yb);\n          da = temp;\n\n          temp = da * 1073741824.0;\n          double daa = da + temp - temp;\n          double dab = da - daa;\n\n          \n          double ratio = na/da;\n          temp = ratio * 1073741824.0;\n          double ratioa = ratio + temp - temp;\n          double ratiob = ratio - ratioa;\n\n          \n          ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\n\n          \n          ratiob += nb / da;\n          \n          ratiob += -db * na / da / da;\n\n          result = ratioa + ratiob;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }\n\n    \n    public static double acosh(final double a) {\n        return FastMath.log(a + FastMath.sqrt(a * a - 1));\n    }\n\n    \n    public static double asinh(double a) {\n\n        boolean negative = false;\n        if (a < 0) {\n            negative = true;\n            a = -a;\n        }\n\n        double absAsinh;\n        if (a > 0.167) {\n            absAsinh = FastMath.log(FastMath.sqrt(a * a + 1) + a);\n        } else {\n            final double a2 = a * a;\n            if (a > 0.097) {\n                absAsinh = a * (1 - a2 * (1 / 3.0 - a2 * (1 / 5.0 - a2 * (1 / 7.0 - a2 * (1 / 9.0 - a2 * (1.0 / 11.0 - a2 * (1.0 / 13.0 - a2 * (1.0 / 15.0 - a2 * (1.0 / 17.0) * 15.0 / 16.0) * 13.0 / 14.0) * 11.0 / 12.0) * 9.0 / 10.0) * 7.0 / 8.0) * 5.0 / 6.0) * 3.0 / 4.0) / 2.0);\n            } else if (a > 0.036) {\n                absAsinh = a * (1 - a2 * (1 / 3.0 - a2 * (1 / 5.0 - a2 * (1 / 7.0 - a2 * (1 / 9.0 - a2 * (1.0 / 11.0 - a2 * (1.0 / 13.0) * 11.0 / 12.0) * 9.0 / 10.0) * 7.0 / 8.0) * 5.0 / 6.0) * 3.0 / 4.0) / 2.0);\n            } else if (a > 0.0036) {\n                absAsinh = a * (1 - a2 * (1 / 3.0 - a2 * (1 / 5.0 - a2 * (1 / 7.0 - a2 * (1 / 9.0) * 7.0 / 8.0) * 5.0 / 6.0) * 3.0 / 4.0) / 2.0);\n            } else {\n                absAsinh = a * (1 - a2 * (1 / 3.0 - a2 * (1 / 5.0) * 3.0 / 4.0) / 2.0);\n            }\n        }\n\n        return negative ? -absAsinh : absAsinh;\n\n    }\n\n    \n    public static double atanh(double a) {\n\n        boolean negative = false;\n        if (a < 0) {\n            negative = true;\n            a = -a;\n        }\n\n        double absAtanh;\n        if (a > 0.15) {\n            absAtanh = 0.5 * FastMath.log((1 + a) / (1 - a));\n        } else {\n            final double a2 = a * a;\n            if (a > 0.087) {\n                absAtanh = a * (1 + a2 * (1.0 / 3.0 + a2 * (1.0 / 5.0 + a2 * (1.0 / 7.0 + a2 * (1.0 / 9.0 + a2 * (1.0 / 11.0 + a2 * (1.0 / 13.0 + a2 * (1.0 / 15.0 + a2 * (1.0 / 17.0)))))))));\n            } else if (a > 0.031) {\n                absAtanh = a * (1 + a2 * (1.0 / 3.0 + a2 * (1.0 / 5.0 + a2 * (1.0 / 7.0 + a2 * (1.0 / 9.0 + a2 * (1.0 / 11.0 + a2 * (1.0 / 13.0)))))));\n            } else if (a > 0.003) {\n                absAtanh = a * (1 + a2 * (1.0 / 3.0 + a2 * (1.0 / 5.0 + a2 * (1.0 / 7.0 + a2 * (1.0 / 9.0)))));\n            } else {\n                absAtanh = a * (1 + a2 * (1.0 / 3.0 + a2 * (1.0 / 5.0)));\n            }\n        }\n\n        return negative ? -absAtanh : absAtanh;\n\n    }\n\n    \n    public static double signum(final double a) {\n        return (a < 0.0) ? -1.0 : ((a > 0.0) ? 1.0 : (Double.isNaN(a) ? Double.NaN : 0.0));\n    }\n\n    \n    public static double nextUp(final double a) {\n        return nextAfter(a, Double.POSITIVE_INFINITY);\n    }\n\n    \n    public static double random() {\n        return Math.random();\n    }\n\n    \n    public static double exp(double x) {\n        return exp(x, 0.0, null);\n    }\n\n    \n    private static double exp(double x, double extra, double[] hiPrec) {\n        double intPartA;\n        double intPartB;\n        int intVal;\n\n        \n        if (x < 0.0) {\n            intVal = (int) -x;\n\n            if (intVal > 746) {\n                if (hiPrec != null) {\n                    hiPrec[0] = 0.0;\n                    hiPrec[1] = 0.0;\n                }\n                return 0.0;\n            }\n\n            if (intVal > 709) {\n                \n                final double result = exp(x+40.19140625, extra, hiPrec) / 285040095144011776.0;\n                if (hiPrec != null) {\n                    hiPrec[0] /= 285040095144011776.0;\n                    hiPrec[1] /= 285040095144011776.0;\n                }\n                return result;\n            }\n\n            if (intVal == 709) {\n                \n                final double result = exp(x+1.494140625, extra, hiPrec) / 4.455505956692756620;\n                if (hiPrec != null) {\n                    hiPrec[0] /= 4.455505956692756620;\n                    hiPrec[1] /= 4.455505956692756620;\n                }\n                return result;\n            }\n\n            intVal++;\n\n            intPartA = EXP_INT_TABLE_A[750-intVal];\n            intPartB = EXP_INT_TABLE_B[750-intVal];\n\n            intVal = -intVal;\n        } else {\n            intVal = (int) x;\n\n            if (intVal > 709) {\n                if (hiPrec != null) {\n                    hiPrec[0] = Double.POSITIVE_INFINITY;\n                    hiPrec[1] = 0.0;\n                }\n                return Double.POSITIVE_INFINITY;\n            }\n\n            intPartA = EXP_INT_TABLE_A[750+intVal];\n            intPartB = EXP_INT_TABLE_B[750+intVal];\n        }\n\n        \n        final int intFrac = (int) ((x - intVal) * 1024.0);\n        final double fracPartA = EXP_FRAC_TABLE_A[intFrac];\n        final double fracPartB = EXP_FRAC_TABLE_B[intFrac];\n\n        \n        final double epsilon = x - (intVal + intFrac / 1024.0);\n\n        \n\n        \n        double z = 0.04168701738764507;\n        z = z * epsilon + 0.1666666505023083;\n        z = z * epsilon + 0.5000000000042687;\n        z = z * epsilon + 1.0;\n        z = z * epsilon + -3.940510424527919E-20;\n\n        \n        double tempA = intPartA * fracPartA;\n        double tempB = intPartA * fracPartB + intPartB * fracPartA + intPartB * fracPartB;\n\n        \n        final double tempC = tempB + tempA;\n        final double result;\n        if (extra != 0.0) {\n            result = tempC*extra*z + tempC*extra + tempC*z + tempB + tempA;\n        } else {\n            result = tempC*z + tempB + tempA;\n        }\n\n        if (hiPrec != null) {\n            \n            hiPrec[0] = tempA;\n            hiPrec[1] = tempC*extra*z + tempC*extra + tempC*z + tempB;\n        }\n\n        return result;\n    }\n\n    \n    public static double expm1(double x) {\n      return expm1(x, null);\n    }\n\n    \n    private static double expm1(double x, double hiPrecOut[]) {\n        if (x != x || x == 0.0) { \n            return x;\n        }\n\n        if (x <= -1.0 || x >= 1.0) {\n            \n            \n            double hiPrec[] = new double[2];\n            exp(x, 0.0, hiPrec);\n            if (x > 0.0) {\n                return -1.0 + hiPrec[0] + hiPrec[1];\n            } else {\n                final double ra = -1.0 + hiPrec[0];\n                double rb = -(ra + 1.0 - hiPrec[0]);\n                rb += hiPrec[1];\n                return ra + rb;\n            }\n        }\n\n        double baseA;\n        double baseB;\n        double epsilon;\n        boolean negative = false;\n\n        if (x < 0.0) {\n            x = -x;\n            negative = true;\n        }\n\n        {\n            int intFrac = (int) (x * 1024.0);\n            double tempA = EXP_FRAC_TABLE_A[intFrac] - 1.0;\n            double tempB = EXP_FRAC_TABLE_B[intFrac];\n\n            double temp = tempA + tempB;\n            tempB = -(temp - tempA - tempB);\n            tempA = temp;\n\n            temp = tempA * 1073741824.0;\n            baseA = tempA + temp - temp;\n            baseB = tempB + (tempA - baseA);\n\n            epsilon = x - intFrac/1024.0;\n        }\n\n\n        \n        double zb = 0.008336750013465571;\n        zb = zb * epsilon + 0.041666663879186654;\n        zb = zb * epsilon + 0.16666666666745392;\n        zb = zb * epsilon + 0.49999999999999994;\n        zb = zb * epsilon;\n        zb = zb * epsilon;\n\n        double za = epsilon;\n        double temp = za + zb;\n        zb = -(temp - za - zb);\n        za = temp;\n\n        temp = za * 1073741824.0;\n        temp = za + temp - temp;\n        zb += za - temp;\n        za = temp;\n\n        \n        double ya = za * baseA;\n        \n        temp = ya + za * baseB;\n        double yb = -(temp - ya - za * baseB);\n        ya = temp;\n\n        temp = ya + zb * baseA;\n        yb += -(temp - ya - zb * baseA);\n        ya = temp;\n\n        temp = ya + zb * baseB;\n        yb += -(temp - ya - zb*baseB);\n        ya = temp;\n\n        \n        \n        temp = ya + baseA;\n        yb += -(temp - baseA - ya);\n        ya = temp;\n\n        temp = ya + za;\n        \n        yb += -(temp - ya - za);\n        ya = temp;\n\n        temp = ya + baseB;\n        \n        yb += -(temp - ya - baseB);\n        ya = temp;\n\n        temp = ya + zb;\n        \n        yb += -(temp - ya - zb);\n        ya = temp;\n\n        if (negative) {\n            \n            double denom = 1.0 + ya;\n            double denomr = 1.0 / denom;\n            double denomb = -(denom - 1.0 - ya) + yb;\n            double ratio = ya * denomr;\n            temp = ratio * 1073741824.0;\n            final double ra = ratio + temp - temp;\n            double rb = ratio - ra;\n\n            temp = denom * 1073741824.0;\n            za = denom + temp - temp;\n            zb = denom - za;\n\n            rb += (ya - za * ra - za * rb - zb * ra - zb * rb) * denomr;\n\n            \n            \n            \n            \n            \n            \n            \n\n            \n            rb += yb * denomr;                      \n            rb += -ya * denomb * denomr * denomr;   \n\n            \n            ya = -ra;\n            yb = -rb;\n        }\n\n        if (hiPrecOut != null) {\n            hiPrecOut[0] = ya;\n            hiPrecOut[1] = yb;\n        }\n\n        return ya + yb;\n    }\n\n    \n    private static double slowexp(final double x, final double result[]) {\n        final double xs[] = new double[2];\n        final double ys[] = new double[2];\n        final double facts[] = new double[2];\n        final double as[] = new double[2];\n        split(x, xs);\n        ys[0] = ys[1] = 0.0;\n\n        for (int i = 19; i >= 0; i--) {\n            splitMult(xs, ys, as);\n            ys[0] = as[0];\n            ys[1] = as[1];\n\n            split(FACT[i], as);\n            splitReciprocal(as, facts);\n\n            splitAdd(ys, facts, as);\n            ys[0] = as[0];\n            ys[1] = as[1];\n        }\n\n        if (result != null) {\n            result[0] = ys[0];\n            result[1] = ys[1];\n        }\n\n        return ys[0] + ys[1];\n    }\n\n    \n    private static void split(final double d, final double split[]) {\n        if (d < 8e298 && d > -8e298) {\n            final double a = d * 1073741824.0;\n            split[0] = (d + a) - a;\n            split[1] = d - split[0];\n        } else {\n            final double a = d * 9.31322574615478515625E-10;\n            split[0] = (d + a - d) * 1073741824.0;\n            split[1] = d - split[0];\n        }\n    }\n\n    \n    private static void resplit(final double a[]) {\n        final double c = a[0] + a[1];\n        final double d = -(c - a[0] - a[1]);\n\n        if (c < 8e298 && c > -8e298) {\n            double z = c * 1073741824.0;\n            a[0] = (c + z) - z;\n            a[1] = c - a[0] + d;\n        } else {\n            double z = c * 9.31322574615478515625E-10;\n            a[0] = (c + z - c) * 1073741824.0;\n            a[1] = c - a[0] + d;\n        }\n    }\n\n    \n    private static void splitMult(double a[], double b[], double ans[]) {\n        ans[0] = a[0] * b[0];\n        ans[1] = a[0] * b[1] + a[1] * b[0] + a[1] * b[1];\n\n        \n        resplit(ans);\n    }\n\n    \n    private static void splitAdd(final double a[], final double b[], final double ans[]) {\n        ans[0] = a[0] + b[0];\n        ans[1] = a[1] + b[1];\n\n        resplit(ans);\n    }\n\n    \n    private static void splitReciprocal(final double in[], final double result[]) {\n        final double b = 1.0/4194304.0;\n        final double a = 1.0 - b;\n\n        if (in[0] == 0.0) {\n            in[0] = in[1];\n            in[1] = 0.0;\n        }\n\n        result[0] = a / in[0];\n        result[1] = (b*in[0]-a*in[1]) / (in[0]*in[0] + in[0]*in[1]);\n\n        if (result[1] != result[1]) { \n            result[1] = 0.0;\n        }\n\n        \n        resplit(result);\n\n        for (int i = 0; i < 2; i++) {\n            \n            double err = 1.0 - result[0] * in[0] - result[0] * in[1] -\n            result[1] * in[0] - result[1] * in[1];\n            \n            err = err * (result[0] + result[1]);\n            \n            result[1] += err;\n        }\n    }\n\n    \n    private static void quadMult(final double a[], final double b[], final double result[]) {\n        final double xs[] = new double[2];\n        final double ys[] = new double[2];\n        final double zs[] = new double[2];\n\n        \n        split(a[0], xs);\n        split(b[0], ys);\n        splitMult(xs, ys, zs);\n\n        result[0] = zs[0];\n        result[1] = zs[1];\n\n        \n        split(b[1], ys);\n        splitMult(xs, ys, zs);\n\n        double tmp = result[0] + zs[0];\n        result[1] = result[1] - (tmp - result[0] - zs[0]);\n        result[0] = tmp;\n        tmp = result[0] + zs[1];\n        result[1] = result[1] - (tmp - result[0] - zs[1]);\n        result[0] = tmp;\n\n        \n        split(a[1], xs);\n        split(b[0], ys);\n        splitMult(xs, ys, zs);\n\n        tmp = result[0] + zs[0];\n        result[1] = result[1] - (tmp - result[0] - zs[0]);\n        result[0] = tmp;\n        tmp = result[0] + zs[1];\n        result[1] = result[1] - (tmp - result[0] - zs[1]);\n        result[0] = tmp;\n\n        \n        split(a[1], xs);\n        split(b[1], ys);\n        splitMult(xs, ys, zs);\n\n        tmp = result[0] + zs[0];\n        result[1] = result[1] - (tmp - result[0] - zs[0]);\n        result[0] = tmp;\n        tmp = result[0] + zs[1];\n        result[1] = result[1] - (tmp - result[0] - zs[1]);\n        result[0] = tmp;\n    }\n\n    \n    private static double expint(int p, final double result[]) {\n        \n        final double xs[] = new double[2];\n        final double as[] = new double[2];\n        final double ys[] = new double[2];\n        \n        \n        \n        \n        \n        \n\n        \n        xs[0] = 2.718281828459045;\n        xs[1] = 1.4456468917292502E-16;\n\n        split(1.0, ys);\n\n        while (p > 0) {\n            if ((p & 1) != 0) {\n                quadMult(ys, xs, as);\n                ys[0] = as[0]; ys[1] = as[1];\n            }\n\n            quadMult(xs, xs, as);\n            xs[0] = as[0]; xs[1] = as[1];\n\n            p >>= 1;\n        }\n\n        if (result != null) {\n            result[0] = ys[0];\n            result[1] = ys[1];\n\n            resplit(result);\n        }\n\n        return ys[0] + ys[1];\n    }\n\n\n    \n    public static double log(final double x) {\n        return log(x, null);\n    }\n\n    \n    private static double log(final double x, final double[] hiPrec) {\n        long bits = Double.doubleToLongBits(x);\n\n        \n        if ((bits & 0x8000000000000000L) != 0 || x != x) {\n            if (x != 0.0) {\n                if (hiPrec != null) {\n                    hiPrec[0] = Double.NaN;\n                }\n\n                return Double.NaN;\n            }\n        }\n\n        \n        if (x == Double.POSITIVE_INFINITY) {\n            if (hiPrec != null) {\n                hiPrec[0] = Double.POSITIVE_INFINITY;\n            }\n\n            return Double.POSITIVE_INFINITY;\n        }\n\n        \n        int exp = (int)(bits >> 52)-1023;\n\n        if ((bits & 0x7ff0000000000000L) == 0) {\n            \n            if (x == 0) {\n                \n                if (hiPrec != null) {\n                    hiPrec[0] = Double.NEGATIVE_INFINITY;\n                }\n\n                return Double.NEGATIVE_INFINITY;\n            }\n\n            \n            bits <<= 1;\n            while ( (bits & 0x0010000000000000L) == 0) {\n                exp--;\n                bits <<= 1;\n            }\n        }\n\n\n        if (exp == -1 || exp == 0) {\n            if (x < 1.01 && x > 0.99 && hiPrec == null) {\n                \n\n               \n                double xa = x - 1.0;\n                double xb = xa - x + 1.0;\n                double tmp = xa * 1073741824.0;\n                double aa = xa + tmp - tmp;\n                double ab = xa - aa;\n                xa = aa;\n                xb = ab;\n\n                double ya = LN_QUICK_COEF[LN_QUICK_COEF.length-1][0];\n                double yb = LN_QUICK_COEF[LN_QUICK_COEF.length-1][1];\n\n                for (int i = LN_QUICK_COEF.length - 2; i >= 0; i--) {\n                    \n                    aa = ya * xa;\n                    ab = ya * xb + yb * xa + yb * xb;\n                    \n                    tmp = aa * 1073741824.0;\n                    ya = aa + tmp - tmp;\n                    yb = aa - ya + ab;\n\n                    \n                    aa = ya + LN_QUICK_COEF[i][0];\n                    ab = yb + LN_QUICK_COEF[i][1];\n                    \n                    tmp = aa * 1073741824.0;\n                    ya = aa + tmp - tmp;\n                    yb = aa - ya + ab;\n                }\n\n                \n                aa = ya * xa;\n                ab = ya * xb + yb * xa + yb * xb;\n                \n                tmp = aa * 1073741824.0;\n                ya = aa + tmp - tmp;\n                yb = aa - ya + ab;\n\n                return ya + yb;\n            }\n        }\n\n        \n        double lnm[] = LN_MANT[(int)((bits & 0x000ffc0000000000L) >> 42)];\n\n        \n\n        \n        \n        \n        double epsilon = (double)(bits & 0x3ffffffffffL) / (4503599627370496.0 + (bits & 0x000ffc0000000000L));\n\n        double lnza = 0.0;\n        double lnzb = 0.0;\n\n        if (hiPrec != null) {\n            \n            double tmp = epsilon * 1073741824.0;\n            double aa = epsilon + tmp - tmp;\n            double ab = epsilon - aa;\n            double xa = aa;\n            double xb = ab;\n\n            \n            double numer = (double)(bits & 0x3ffffffffffL);\n            double denom = 4503599627370496.0 + (bits & 0x000ffc0000000000L);\n            aa = numer - xa*denom - xb * denom;\n            xb += aa / denom;\n\n            \n            double ya = LN_HI_PREC_COEF[LN_HI_PREC_COEF.length-1][0];\n            double yb = LN_HI_PREC_COEF[LN_HI_PREC_COEF.length-1][1];\n\n            for (int i = LN_HI_PREC_COEF.length - 2; i >= 0; i--) {\n                \n                aa = ya * xa;\n                ab = ya * xb + yb * xa + yb * xb;\n                \n                tmp = aa * 1073741824.0;\n                ya = aa + tmp - tmp;\n                yb = aa - ya + ab;\n\n                \n                aa = ya + LN_HI_PREC_COEF[i][0];\n                ab = yb + LN_HI_PREC_COEF[i][1];\n                \n                tmp = aa * 1073741824.0;\n                ya = aa + tmp - tmp;\n                yb = aa - ya + ab;\n            }\n\n            \n            aa = ya * xa;\n            ab = ya * xb + yb * xa + yb * xb;\n\n            \n            \n            lnza = aa + ab;\n            lnzb = -(lnza - aa - ab);\n        } else {\n            \n            lnza = -0.16624882440418567;\n            lnza = lnza * epsilon + 0.19999954120254515;\n            lnza = lnza * epsilon + -0.2499999997677497;\n            lnza = lnza * epsilon + 0.3333333333332802;\n            lnza = lnza * epsilon + -0.5;\n            lnza = lnza * epsilon + 1.0;\n            lnza = lnza * epsilon;\n        }\n\n        \n\n        \n\n        \n        double a = LN_2_A*exp;\n        double b = 0.0;\n        double c = a+lnm[0];\n        double d = -(c-a-lnm[0]);\n        a = c;\n        b = b + d;\n\n        c = a + lnza;\n        d = -(c - a - lnza);\n        a = c;\n        b = b + d;\n\n        c = a + LN_2_B*exp;\n        d = -(c - a - LN_2_B*exp);\n        a = c;\n        b = b + d;\n\n        c = a + lnm[1];\n        d = -(c - a - lnm[1]);\n        a = c;\n        b = b + d;\n\n        c = a + lnzb;\n        d = -(c - a - lnzb);\n        a = c;\n        b = b + d;\n\n        if (hiPrec != null) {\n            hiPrec[0] = a;\n            hiPrec[1] = b;\n        }\n\n        return a + b;\n    }\n\n    \n    public static double log1p(final double x) {\n        double xpa = 1.0 + x;\n        double xpb = -(xpa - 1.0 - x);\n\n        if (x == -1) {\n            return x/0.0;   \n        }\n\n        if (x > 0 && 1/x == 0) { \n            return x;\n        }\n\n        if (x>1e-6 || x<-1e-6) {\n            double hiPrec[] = new double[2];\n\n            log(xpa, hiPrec);\n\n            \n            \n            double fx1 = xpb/xpa;\n\n            double epsilon = 0.5 * fx1 + 1.0;\n            epsilon = epsilon * fx1;\n\n            return epsilon + hiPrec[1] + hiPrec[0];\n        }\n\n        \n        double y = x * 0.333333333333333 - 0.5;\n        y = y * x + 1.0;\n        y = y * x;\n\n        return y;\n    }\n\n    \n    public static double log10(final double x) {\n        final double hiPrec[] = new double[2];\n\n        log(x, hiPrec);\n\n        final double tmp = hiPrec[0] * 1073741824.0;\n        final double lna = hiPrec[0] + tmp - tmp;\n        final double lnb = hiPrec[0] - lna + hiPrec[1];\n\n        final double rln10a = 0.4342944622039795;\n        final double rln10b = 1.9699272335463627E-8;\n\n        return rln10b * lnb + rln10b * lna + rln10a * lnb + rln10a * lna;\n    }\n\n    \n    public static double pow(double x, double y) {\n        final double lns[] = new double[2];\n\n        if (y == 0.0) {\n            return 1.0;\n        }\n\n        if (x != x) { \n            return x;\n        }\n\n\n        if (x == 0) {\n            long bits = Double.doubleToLongBits(x);\n            if ((bits & 0x8000000000000000L) != 0) {\n                \n                long yi = (long) y;\n\n                if (y < 0 && y == yi && (yi & 1) == 1) {\n                    return Double.NEGATIVE_INFINITY;\n                }\n\n                if (y < 0 && y == yi && (yi & 1) == 1) {\n                    return -0.0;\n                }\n\n                if (y > 0 && y == yi && (yi & 1) == 1) {\n                    return -0.0;\n                }\n            }\n\n            if (y < 0) {\n                return Double.POSITIVE_INFINITY;\n            }\n            if (y > 0) {\n                return 0.0;\n            }\n\n            return Double.NaN;\n        }\n\n        if (x == Double.POSITIVE_INFINITY) {\n            if (y != y) { \n                return y;\n            }\n            if (y < 0.0) {\n                return 0.0;\n            } else {\n                return Double.POSITIVE_INFINITY;\n            }\n        }\n\n        if (y == Double.POSITIVE_INFINITY) {\n            if (x * x == 1.0)\n              return Double.NaN;\n\n            if (x * x > 1.0) {\n                return Double.POSITIVE_INFINITY;\n            } else {\n                return 0.0;\n            }\n        }\n\n        if (x == Double.NEGATIVE_INFINITY) {\n            if (y != y) { \n                return y;\n            }\n\n            if (y < 0) {\n                long yi = (long) y;\n                if (y == yi && (yi & 1) == 1) {\n                    return -0.0;\n                }\n\n                return 0.0;\n            }\n\n            if (y > 0)  {\n                long yi = (long) y;\n                if (y == yi && (yi & 1) == 1) {\n                    return Double.NEGATIVE_INFINITY;\n                }\n\n                return Double.POSITIVE_INFINITY;\n            }\n        }\n\n        if (y == Double.NEGATIVE_INFINITY) {\n\n            if (x * x == 1.0) {\n                return Double.NaN;\n            }\n\n            if (x * x < 1.0) {\n                return Double.POSITIVE_INFINITY;\n            } else {\n                return 0.0;\n            }\n        }\n\n        \n        if (x < 0) {\n            \n            if (y >= 4503599627370496.0 || y <= -4503599627370496.0) {\n                return pow(-x, y);\n            }\n\n            if (y == (long) y) {\n                \n                return ((long)y & 1) == 0 ? pow(-x, y) : -pow(-x, y);\n            } else {\n                return Double.NaN;\n            }\n        }\n\n        \n        double ya;\n        double yb;\n        if (y < 8e298 && y > -8e298) {\n            double tmp1 = y * 1073741824.0;\n            ya = y + tmp1 - tmp1;\n            yb = y - ya;\n        } else {\n            double tmp1 = y * 9.31322574615478515625E-10;\n            double tmp2 = tmp1 * 9.31322574615478515625E-10;\n            ya = (tmp1 + tmp2 - tmp1) * 1073741824.0 * 1073741824.0;\n            yb = y - ya;\n        }\n\n        \n        log(x, lns);\n        double lna = lns[0];\n        double lnb = lns[1];\n\n        \n        double tmp1 = lna * 1073741824.0;\n        double tmp2 = lna + tmp1 - tmp1;\n        lnb += lna - tmp2;\n        lna = tmp2;\n\n        \n        final double aa = lna * ya;\n        final double ab = lna * yb + lnb * ya + lnb * yb;\n\n        lna = aa+ab;\n        lnb = -(lna - aa - ab);\n\n        double z = 1.0 / 120.0;\n        z = z * lnb + (1.0 / 24.0);\n        z = z * lnb + (1.0 / 6.0);\n        z = z * lnb + 0.5;\n        z = z * lnb + 1.0;\n        z = z * lnb;\n\n        final double result = exp(lna, z, null);\n        \n        return result;\n    }\n\n    \n    private static double[] slowLog(double xi) {\n        double x[] = new double[2];\n        double x2[] = new double[2];\n        double y[] = new double[2];\n        double a[] = new double[2];\n\n        split(xi, x);\n\n        \n        x[0] += 1.0;\n        resplit(x);\n        splitReciprocal(x, a);\n        x[0] -= 2.0;\n        resplit(x);\n        splitMult(x, a, y);\n        x[0] = y[0];\n        x[1] = y[1];\n\n        \n        splitMult(x, x, x2);\n\n\n        \n        \n\n        y[0] = LN_SPLIT_COEF[LN_SPLIT_COEF.length-1][0];\n        y[1] = LN_SPLIT_COEF[LN_SPLIT_COEF.length-1][1];\n\n        for (int i = LN_SPLIT_COEF.length-2; i >= 0; i--) {\n            splitMult(y, x2, a);\n            y[0] = a[0];\n            y[1] = a[1];\n            splitAdd(y, LN_SPLIT_COEF[i], a);\n            y[0] = a[0];\n            y[1] = a[1];\n        }\n\n        splitMult(y, x, a);\n        y[0] = a[0];\n        y[1] = a[1];\n\n        return y;\n    }\n\n    \n    private static double slowSin(final double x, final double result[]) {\n        final double xs[] = new double[2];\n        final double ys[] = new double[2];\n        final double facts[] = new double[2];\n        final double as[] = new double[2];\n        split(x, xs);\n        ys[0] = ys[1] = 0.0;\n\n        for (int i = 19; i >= 0; i--) {\n            splitMult(xs, ys, as);\n            ys[0] = as[0]; ys[1] = as[1];\n\n            if ( (i & 1) == 0) {\n                continue;\n            }\n\n            split(FACT[i], as);\n            splitReciprocal(as, facts);\n\n            if ( (i & 2) != 0 ) {\n                facts[0] = -facts[0];\n                facts[1] = -facts[1];\n            }\n\n            splitAdd(ys, facts, as);\n            ys[0] = as[0]; ys[1] = as[1];\n        }\n\n        if (result != null) {\n            result[0] = ys[0];\n            result[1] = ys[1];\n        }\n\n        return ys[0] + ys[1];\n    }\n\n    \n    private static double slowCos(final double x, final double result[]) {\n\n        final double xs[] = new double[2];\n        final double ys[] = new double[2];\n        final double facts[] = new double[2];\n        final double as[] = new double[2];\n        split(x, xs);\n        ys[0] = ys[1] = 0.0;\n\n        for (int i = 19; i >= 0; i--) {\n            splitMult(xs, ys, as);\n            ys[0] = as[0]; ys[1] = as[1];\n\n            if ( (i & 1) != 0) {\n                continue;\n            }\n\n            split(FACT[i], as);\n            splitReciprocal(as, facts);\n\n            if ( (i & 2) != 0 ) {\n                facts[0] = -facts[0];\n                facts[1] = -facts[1];\n            }\n\n            splitAdd(ys, facts, as);\n            ys[0] = as[0]; ys[1] = as[1];\n        }\n\n        if (result != null) {\n            result[0] = ys[0];\n            result[1] = ys[1];\n        }\n\n        return ys[0] + ys[1];\n    }\n\n    \n    private static void buildSinCosTables() {\n        final double result[] = new double[2];\n\n        \n        for (int i = 0; i < 7; i++) {\n            double x = i / 8.0;\n\n            slowSin(x, result);\n            SINE_TABLE_A[i] = result[0];\n            SINE_TABLE_B[i] = result[1];\n\n            slowCos(x, result);\n            COSINE_TABLE_A[i] = result[0];\n            COSINE_TABLE_B[i] = result[1];\n        }\n\n        \n        for (int i = 7; i < 14; i++) {\n            double xs[] = new double[2];\n            double ys[] = new double[2];\n            double as[] = new double[2];\n            double bs[] = new double[2];\n            double temps[] = new double[2];\n\n            if ( (i & 1) == 0) {\n                \n                xs[0] = SINE_TABLE_A[i/2];\n                xs[1] = SINE_TABLE_B[i/2];\n                ys[0] = COSINE_TABLE_A[i/2];\n                ys[1] = COSINE_TABLE_B[i/2];\n\n                \n                splitMult(xs, ys, result);\n                SINE_TABLE_A[i] = result[0] * 2.0;\n                SINE_TABLE_B[i] = result[1] * 2.0;\n\n                \n                splitMult(ys, ys, as);\n                splitMult(xs, xs, temps);\n                temps[0] = -temps[0];\n                temps[1] = -temps[1];\n                splitAdd(as, temps, result);\n                COSINE_TABLE_A[i] = result[0];\n                COSINE_TABLE_B[i] = result[1];\n            } else {\n                xs[0] = SINE_TABLE_A[i/2];\n                xs[1] = SINE_TABLE_B[i/2];\n                ys[0] = COSINE_TABLE_A[i/2];\n                ys[1] = COSINE_TABLE_B[i/2];\n                as[0] = SINE_TABLE_A[i/2+1];\n                as[1] = SINE_TABLE_B[i/2+1];\n                bs[0] = COSINE_TABLE_A[i/2+1];\n                bs[1] = COSINE_TABLE_B[i/2+1];\n\n                \n                splitMult(xs, bs, temps);\n                splitMult(ys, as, result);\n                splitAdd(result, temps, result);\n                SINE_TABLE_A[i] = result[0];\n                SINE_TABLE_B[i] = result[1];\n\n                \n                splitMult(ys, bs, result);\n                splitMult(xs, as, temps);\n                temps[0] = -temps[0];\n                temps[1] = -temps[1];\n                splitAdd(result, temps, result);\n                COSINE_TABLE_A[i] = result[0];\n                COSINE_TABLE_B[i] = result[1];\n            }\n        }\n\n        \n        for (int i = 0; i < 14; i++) {\n            double xs[] = new double[2];\n            double ys[] = new double[2];\n            double as[] = new double[2];\n\n            as[0] = COSINE_TABLE_A[i];\n            as[1] = COSINE_TABLE_B[i];\n\n            splitReciprocal(as, ys);\n\n            xs[0] = SINE_TABLE_A[i];\n            xs[1] = SINE_TABLE_B[i];\n\n            splitMult(xs, ys, as);\n\n            TANGENT_TABLE_A[i] = as[0];\n            TANGENT_TABLE_B[i] = as[1];\n        }\n\n    }\n\n    \n    private static double polySine(final double x) {\n        double x2 = x*x;\n\n        double p = 2.7553817452272217E-6;\n        p = p * x2 + -1.9841269659586505E-4;\n        p = p * x2 + 0.008333333333329196;\n        p = p * x2 + -0.16666666666666666;\n        \n        \n        p = p * x2 * x;\n\n        return p;\n    }\n\n    \n    private static double polyCosine(double x) {\n        double x2 = x*x;\n\n        double p = 2.479773539153719E-5;\n        p = p * x2 + -0.0013888888689039883;\n        p = p * x2 + 0.041666666666621166;\n        p = p * x2 + -0.49999999999999994;\n        p *= x2;\n\n        return p;\n    }\n\n    \n    private static double sinQ(double xa, double xb) {\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHES[idx]; \n\n        \n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        \n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        \n        final double temp = sinEpsA * 1073741824.0;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        \n        double result;\n\n        \n\n        \n        \n\n        \n        \n        double a = 0;\n        double b = 0;\n\n        double t = sintA;\n        double c = a + t;\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA * sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA * cosEpsB + costA * sinEpsB;\n        \n\n        b = b + sintB + costB * sinEpsA + sintB * cosEpsB + costB * sinEpsB;\n        \n\n        if (xb != 0.0) {\n            t = ((costA + costB) * (cosEpsA + cosEpsB) -\n                 (sintA + sintB) * (sinEpsA + sinEpsB)) * xb;  \n            c = a + t;\n            d = -(c - a - t);\n            a = c;\n            b = b + d;\n        }\n\n        result = a + b;\n\n        return result;\n    }\n\n    \n    private static double cosQ(double xa, double xb) {\n        final double pi2a = 1.5707963267948966;\n        final double pi2b = 6.123233995736766E-17;\n\n        final double a = pi2a - xa;\n        double b = -(a - pi2a + xa);\n        b += pi2b - xb;\n\n        return sinQ(a, b);\n    }\n\n    \n    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHES[idx]; \n\n        \n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        \n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        \n        double temp = sinEpsA * 1073741824.0;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        \n\n        \n\n        \n        \n\n        \n        \n        double a = 0;\n        double b = 0;\n\n        \n        double t = sintA;\n        double c = a + t;\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        \n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        \n        \n\n        \n\n        double est = sina/cosa;\n\n        \n        temp = est * 1073741824.0;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * 1073741824.0;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        \n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  \n        err += sinb/cosa;                     \n        err += -sina * cosb / cosa / cosa;    \n\n        if (xb != 0.0) {\n            \n            \n            double xbadj = xb + est*est*xb;\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }\n\n    \n    private static void reducePayneHanek(double x, double result[]) {\n        \n        long inbits = Double.doubleToLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        \n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        \n        exponent++;\n        inbits <<= 11;\n\n        \n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        \n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        \n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        \n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        \n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        \n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        \n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        \n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        \n\n        \n        int intPart = (int)(prodA >>> 62);\n\n        \n        prodA <<= 2;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        \n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        \n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        \n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        \n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        \n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        \n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        \n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        \n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        \n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        \n        double tmpA = (prod2A >>> 12) / 4503599627370496.0;  \n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / 4503599627370496.0 / 4503599627370496.0; \n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        \n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }\n\n    \n    public static double sin(double x) {\n        boolean negative = false;\n        int quadrant = 0;\n        double xa;\n        double xb = 0.0;\n\n        \n        xa = x;\n        if (x < 0) {\n            negative = true;\n            xa = -xa;\n        }\n\n        \n        if (xa == 0.0) {\n            long bits = Double.doubleToLongBits(x);\n            if (bits < 0) {\n                return -0.0;\n            }\n            return 0.0;\n        }\n\n        if (xa != xa || xa == Double.POSITIVE_INFINITY) {\n            return Double.NaN;\n        }\n\n        \n        if (xa > 3294198.0) {\n            \n            \n            \n            double reduceResults[] = new double[3];\n            reducePayneHanek(xa, reduceResults);\n            quadrant = ((int) reduceResults[0]) & 3;\n            xa = reduceResults[1];\n            xb = reduceResults[2];\n        } else if (xa > 1.5707963267948966) {\n            \n\n            \n            \n            int k = (int)(xa * 0.6366197723675814);\n\n            \n            double remA;\n            double remB;\n            while (true) {\n                double a = -k * 1.570796251296997;\n                remA = xa + a;\n                remB = -(remA - xa - a);\n\n                a = -k * 7.549789948768648E-8;\n                double b = remA;\n                remA = a + b;\n                remB += -(remA - b - a);\n\n                a = -k * 6.123233995736766E-17;\n                b = remA;\n                remA = a + b;\n                remB += -(remA - b - a);\n\n                if (remA > 0.0)\n                    break;\n\n                \n                \n                \n                k--;\n            }\n            quadrant = k & 3;\n            xa = remA;\n            xb = remB;\n        }\n\n        if (negative) {\n            quadrant ^= 2;  \n        }\n\n        switch (quadrant) {\n            case 0:\n                return sinQ(xa, xb);\n            case 1:\n                return cosQ(xa, xb);\n            case 2:\n                return -sinQ(xa, xb);\n            case 3:\n                return -cosQ(xa, xb);\n            default:\n                return Double.NaN;\n        }\n    }\n\n    \n    public static double cos(double x) {\n        int quadrant = 0;\n\n        \n        double xa = x;\n        if (x < 0) {\n            xa = -xa;\n        }\n\n        if (xa != xa || xa == Double.POSITIVE_INFINITY) {\n            return Double.NaN;\n        }\n\n        \n        double xb = 0;\n        if (xa > 3294198.0) {\n            \n            \n            \n            double reduceResults[] = new double[3];\n            reducePayneHanek(xa, reduceResults);\n            quadrant = ((int) reduceResults[0]) & 3;\n            xa = reduceResults[1];\n            xb = reduceResults[2];\n        } else if (xa > 1.5707963267948966) {\n            \n\n            \n            \n            int k = (int)(xa * 0.6366197723675814);\n\n            \n            double remA;\n            double remB;\n            while (true) {\n                double a = -k * 1.570796251296997;\n                remA = xa + a;\n                remB = -(remA - xa - a);\n\n                a = -k * 7.549789948768648E-8;\n                double b = remA;\n                remA = a + b;\n                remB += -(remA - b - a);\n\n                a = -k * 6.123233995736766E-17;\n                b = remA;\n                remA = a + b;\n                remB += -(remA - b - a);\n\n                if (remA > 0.0)\n                    break;\n\n                \n                \n                \n                k--;\n            }\n            quadrant = k & 3;\n            xa = remA;\n            xb = remB;\n        }\n\n        \n        \n\n        switch (quadrant) {\n            case 0:\n                return cosQ(xa, xb);\n            case 1:\n                return -sinQ(xa, xb);\n            case 2:\n                return -cosQ(xa, xb);\n            case 3:\n                return sinQ(xa, xb);\n            default:\n                return Double.NaN;\n        }\n    }\n\n    \n    public static double tan(double x) {\n        boolean negative = false;\n        int quadrant = 0;\n\n        \n        double xa = x;\n        if (x < 0) {\n            negative = true;\n            xa = -xa;\n        }\n\n        \n        if (xa == 0.0) {\n            long bits = Double.doubleToLongBits(x);\n            if (bits < 0) {\n                return -0.0;\n            }\n            return 0.0;\n        }\n\n        if (xa != xa || xa == Double.POSITIVE_INFINITY) {\n            return Double.NaN;\n        }\n\n        \n        double xb = 0;\n        if (xa > 3294198.0) {\n            \n            \n            \n            double reduceResults[] = new double[3];\n            reducePayneHanek(xa, reduceResults);\n            quadrant = ((int) reduceResults[0]) & 3;\n            xa = reduceResults[1];\n            xb = reduceResults[2];\n        } else if (xa > 1.5707963267948966) {\n            \n\n            \n            \n            int k = (int)(xa * 0.6366197723675814);\n\n            \n            double remA;\n            double remB;\n            while (true) {\n                double a = -k * 1.570796251296997;\n                remA = xa + a;\n                remB = -(remA - xa - a);\n\n                a = -k * 7.549789948768648E-8;\n                double b = remA;\n                remA = a + b;\n                remB += -(remA - b - a);\n\n                a = -k * 6.123233995736766E-17;\n                b = remA;\n                remA = a + b;\n                remB += -(remA - b - a);\n\n                if (remA > 0.0)\n                    break;\n\n                \n                \n                \n                k--;\n            }\n            quadrant = k & 3;\n            xa = remA;\n            xb = remB;\n        }\n\n        if (xa > 1.5) {\n            \n            final double pi2a = 1.5707963267948966;\n            final double pi2b = 6.123233995736766E-17;\n\n            final double a = pi2a - xa;\n            double b = -(a - pi2a + xa);\n            b += pi2b - xb;\n\n            xa = a + b;\n            xb = -(xa - a - b);\n            quadrant ^= 1;\n            negative ^= true;\n        }\n\n        double result;\n        if ((quadrant & 1) == 0) {\n            result = tanQ(xa, xb, false);\n        } else {\n            result = -tanQ(xa, xb, true);\n        }\n\n        if (negative) {\n            result = -result;\n        }\n\n        return result;\n    }\n\n    \n    public static double atan(double x) {\n        return atan(x, 0.0, false);\n    }\n\n    \n    private static double atan(double xa, double xb, boolean leftPlane) {\n        boolean negate = false;\n        int idx;\n\n        if (xa < 0) {\n            \n            xa = -xa;\n            xb = -xb;\n            negate = true;\n        }\n\n        if (xa > 1.633123935319537E16) { \n            return (negate ^ leftPlane) ? (-Math.PI/2.0) : (Math.PI/2.0);\n        }\n\n        \n        if (xa < 1.0) {\n            idx = (int) (((-1.7168146928204136 * xa * xa + 8.0) * xa) + 0.5);\n        } else {\n            double temp = 1.0/xa;\n            idx = (int) (-((-1.7168146928204136 * temp * temp + 8.0) * temp) + 13.07);\n        }\n        double epsA = xa - TANGENT_TABLE_A[idx];\n        double epsB = -(epsA - xa + TANGENT_TABLE_A[idx]);\n        epsB += xb - TANGENT_TABLE_B[idx];\n\n        double temp = epsA + epsB;\n        epsB = -(temp - epsA - epsB);\n        epsA = temp;\n\n        \n        temp = xa * 1073741824.0;\n        double ya = xa + temp - temp;\n        double yb = xb + xa - ya;\n        xa = ya;\n        xb += yb;\n\n        \n        if (idx == 0) {\n            \n            \n            double denom = 1.0 / (1.0 + (xa + xb) * (TANGENT_TABLE_A[idx] + TANGENT_TABLE_B[idx]));\n            \n            ya = epsA * denom;\n            yb = epsB * denom;\n        } else {\n            double temp2 = xa * TANGENT_TABLE_A[idx];\n            double za = 1.0 + temp2;\n            double zb = -(za - 1.0 - temp2);\n            temp2 = xb * TANGENT_TABLE_A[idx] + xa * TANGENT_TABLE_B[idx];\n            temp = za + temp2;\n            zb += -(temp - za - temp2);\n            za = temp;\n\n            zb += xb * TANGENT_TABLE_B[idx];\n            ya = epsA / za;\n\n            temp = ya * 1073741824.0;\n            final double yaa = (ya + temp) - temp;\n            final double yab = ya - yaa;\n\n            temp = za * 1073741824.0;\n            final double zaa = (za + temp) - temp;\n            final double zab = za - zaa;\n\n            \n            yb = (epsA - yaa * zaa - yaa * zab - yab * zaa - yab * zab) / za;\n\n            yb += -epsA * zb / za / za;\n            yb += epsB / za;\n        }\n\n\n        epsA = ya;\n        epsB = yb;\n\n        \n        double epsA2 = epsA*epsA;\n\n        \n\n        yb = 0.07490822288864472;\n        yb = yb * epsA2 + -0.09088450866185192;\n        yb = yb * epsA2 + 0.11111095942313305;\n        yb = yb * epsA2 + -0.1428571423679182;\n        yb = yb * epsA2 + 0.19999999999923582;\n        yb = yb * epsA2 + -0.33333333333333287;\n        yb = yb * epsA2 * epsA;\n\n\n        ya = epsA;\n\n        temp = ya + yb;\n        yb = -(temp - ya - yb);\n        ya = temp;\n\n        \n        yb += epsB / (1.0 + epsA * epsA);\n\n        double result;\n        double resultb;\n\n        \n        double za = EIGHTHES[idx] + ya;\n        double zb = -(za - EIGHTHES[idx] - ya);\n        temp = za + yb;\n        zb += -(temp - za - yb);\n        za = temp;\n\n        result = za + zb;\n        resultb = -(result - za - zb);\n\n        if (leftPlane) {\n            \n            final double pia = 1.5707963267948966*2.0;\n            final double pib = 6.123233995736766E-17*2.0;\n\n            za = pia - result;\n            zb = -(za - pia + result);\n            zb += pib - resultb;\n\n            result = za + zb;\n            resultb = -(result - za - zb);\n        }\n\n\n        if (negate ^ leftPlane) {\n            result = -result;\n        }\n\n        return result;\n    }\n\n    \n    public static double atan2(double y, double x) {\n        if (x !=x || y != y) {\n            return Double.NaN;\n        }\n\n        if (y == 0.0) {\n            double result = x*y;\n            double invx = 1.0/x;\n            double invy = 1.0/y;\n\n            if (invx == 0.0) { \n                if (x > 0) {\n                    return 0.0;\n                } else {\n                    return Math.PI;\n                }\n            }\n\n            if (result != result) { \n                return x/y;\n            }\n\n            if (x < 0.0 || invx < 0.0) {\n                if (y < 0.0 || invy < 0.0) {\n                    return -Math.PI;\n                } else {\n                    return Math.PI;\n                }\n            } else {\n                return result;\n            }\n        }\n\n        if (y == Double.POSITIVE_INFINITY) {\n            if (x == Double.POSITIVE_INFINITY) {\n                return Math.PI/4.0;\n            }\n\n            if (x == Double.NEGATIVE_INFINITY) {\n                return Math.PI*3.0/4.0;\n            }\n\n            return Math.PI/2.0;\n        }\n\n        if (y == Double.NEGATIVE_INFINITY) {\n            if (x == Double.POSITIVE_INFINITY) {\n                return -Math.PI/4.0;\n            }\n\n            if (x == Double.NEGATIVE_INFINITY) {\n                return -Math.PI*3.0/4.0;\n            }\n\n            return -Math.PI/2.0;\n        }\n\n        if (x == Double.POSITIVE_INFINITY) {\n            if (y > 0.0 || 1/y > 0.0) {\n                return 0.0;\n            }\n\n            if (y < 0.0 || 1/y < 0.0) {\n                return -0.0;\n            }\n        }\n\n        if (x == Double.NEGATIVE_INFINITY)\n        {\n            if (y > 0.0 || 1/y > 0.0) {\n                return Math.PI;\n            }\n\n            if (y < 0.0 || 1/y < 0.0) {\n                return -Math.PI;\n            }\n        }\n\n        if (x == 0) {\n            if (y > 0.0 || 1/y > 0.0) {\n                return Math.PI/2.0;\n            }\n\n            if (y < 0.0 || 1/y < 0.0) {\n                return -Math.PI/2.0;\n            }\n        }\n\n        if (x > 8e298 || x < -8e298) { \n            x *= 9.31322574615478515625E-10;\n            y *= 9.31322574615478515625E-10;\n        }\n\n        \n        double temp = x * 1073741824.0;\n        final double xa = x + temp - temp;\n        final double xb = x - xa;\n\n        \n        final double r = y/x;\n        temp = r * 1073741824.0;\n        double ra = r + temp - temp;\n        double rb = r - ra;\n\n        rb += (y - ra * xa - ra * xb - rb * xa - rb * xb) / x;\n\n        temp = ra + rb;\n        rb = -(temp - ra - rb);\n        ra = temp;\n\n        \n        double result = atan(ra, rb, x < 0);\n\n        return result;\n    }\n\n    \n    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      \n\n      \n      double temp = x * 1073741824.0;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      \n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      \n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      \n      double y;\n      y = sqrt(za);\n      temp = y * 1073741824.0;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      \n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      \n      double dx = zb / (2.0*y);\n\n      \n      double r = x/y;\n      temp = r * 1073741824.0;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  \n      rb += -x * dx / y / y;  \n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }\n\n    \n    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      \n\n      \n      double temp = x * 1073741824.0;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      \n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      \n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      \n      double y = sqrt(za);\n      temp = y * 1073741824.0;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      \n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      \n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      \n      double r = y/x;\n      temp = r * 1073741824.0;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  \n      rb += yb / x;  \n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }\n\n    \n    public static double cbrt(double x) {\n      \n      long inbits = Double.doubleToLongBits(x);\n      int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      boolean subnormal = false;\n\n      if (exponent == -1023) {\n          if (x == 0) {\n              return x;\n          }\n\n          \n          subnormal = true;\n          x *= 1.8014398509481984E16;  \n          inbits = Double.doubleToLongBits(x);\n          exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      }\n\n      if (exponent == 1024) {\n          \n          return x;\n      }\n\n      \n      int exp3 = exponent / 3;\n\n      \n      double p2 = Double.longBitsToDouble((inbits & 0x8000000000000000L) |\n                                          (long)(((exp3 + 1023) & 0x7ff)) << 52);\n\n      \n      final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L);\n\n      \n      double est = -0.010714690733195933;\n      est = est * mant + 0.0875862700108075;\n      est = est * mant + -0.3058015757857271;\n      est = est * mant + 0.7249995199969751;\n      est = est * mant + 0.5039018405998233;\n\n      est *= CBRTTWO[exponent % 3 + 2];\n\n      \n      \n      \n      final double xs = x / (p2*p2*p2);\n      est += (xs - est*est*est) / (3*est*est);\n      est += (xs - est*est*est) / (3*est*est);\n\n      \n      double temp = est * 1073741824.0;\n      double ya = est + temp - temp;\n      double yb = est - ya;\n\n      double za = ya * ya;\n      double zb = ya * yb * 2.0 + yb * yb;\n      temp = za * 1073741824.0;\n      double temp2 = za + temp - temp;\n      zb += za - temp2;\n      za = temp2;\n\n      zb = za * yb + ya * zb + zb * yb;\n      za = za * ya;\n\n      double na = xs - za;\n      double nb = -(na - xs + za);\n      nb -= zb;\n\n      est += (na+nb)/(3*est*est);\n\n      \n      est *= p2;\n\n      if (subnormal) {\n          est *= 3.814697265625E-6;  \n      }\n\n      return est;\n    }\n\n    \n    public static double toRadians(double x) {\n        final double facta = 0.01745329052209854;\n        final double factb = 1.997844754509471E-9;\n\n        double temp = x * 1073741824.0;\n        double xa = x + temp - temp;\n        double xb = x - xa;\n\n        return xb * factb + xb * facta + xa * factb + xa * facta;\n    }\n\n    \n    public static double toDegrees(double x) {\n        final double facta = 57.2957763671875;\n        final double factb = 3.145894820876798E-6;\n\n        double temp = x * 1073741824.0;\n        double xa = x + temp - temp;\n        double xb = x - xa;\n\n        return xb * factb + xb * facta + xa * factb + xa * facta;\n    }\n\n    \n    public static int abs(final int x) {\n        return (x < 0) ? -x : x;\n    }\n\n    \n    public static long abs(final long x) {\n        return (x < 0l) ? -x : x;\n    }\n\n    \n    public static float abs(final float x) {\n        return (x < 0.0f) ? -x : x;\n    }\n\n    \n    public static double abs(double x) {\n        return (x < 0.0) ? -x : x;\n    }\n\n    \n\n    public static double ulp(double x) {\n        return abs(x - Double.longBitsToDouble(Double.doubleToLongBits(x) ^ 1));\n    }\n\n    \n    public static double nextAfter(double d, double direction) {\n\n        \n        if (Double.isNaN(d) || Double.isInfinite(d)) {\n            return d;\n        } else if (d == 0) {\n            return (direction < 0) ? -Double.MIN_VALUE : Double.MIN_VALUE;\n        }\n        \n        \n\n        \n        long bits     = Double.doubleToLongBits(d);\n        long sign     = bits & 0x8000000000000000L;\n        long exponent = bits & 0x7ff0000000000000L;\n        long mantissa = bits & 0x000fffffffffffffL;\n\n        if (d * (direction - d) >= 0) {\n            \n            if (mantissa == 0x000fffffffffffffL) {\n                return Double.longBitsToDouble(sign |\n                                               (exponent + 0x0010000000000000L));\n            } else {\n                return Double.longBitsToDouble(sign |\n                                               exponent | (mantissa + 1));\n            }\n        } else {\n            \n            if (mantissa == 0L) {\n                return Double.longBitsToDouble(sign |\n                                               (exponent - 0x0010000000000000L) |\n                                               0x000fffffffffffffL);\n            } else {\n                return Double.longBitsToDouble(sign |\n                                               exponent | (mantissa - 1));\n            }\n        }\n\n    }\n\n    \n    public static double floor(double x) {\n        long y;\n\n        if (x != x) { \n            return x;\n        }\n\n        if (x >= 4503599627370496.0 || x <= -4503599627370496.0) {\n            return x;\n        }\n\n        y = (long) x;\n        if (x < 0 && y != x) {\n            y--;\n        }\n\n        if (y == 0) {\n            return x*y;\n        }\n\n        return (double) y;\n    }\n\n    \n    public static double ceil(double x) {\n        double y;\n\n        if (x != x) { \n            return x;\n        }\n\n        y = floor(x);\n        if (y == x) {\n            return y;\n        }\n\n        y += 1.0;\n\n        if (y == 0) {\n            return x*y;\n        }\n\n        return y;\n    }\n\n    \n    public static double rint(double x) {\n        double y = floor(x);\n        double d = x - y;\n\n        if (d > 0.5) {\n            return y+1.0;\n        }\n        if (d < 0.5) {\n            return y;\n        }\n\n        \n        long z = (long) y;\n        return (z & 1) == 0 ? y : y + 1.0;\n    }\n\n    \n    public static long round(double x) {\n        return (long) floor(x + 0.5);\n    }\n\n    \n    public static int round(final float x) {\n        return Math.round(x);\n    }\n\n    \n    public static int min(final int a, final int b) {\n        return (a <= b) ? a : b;\n    }\n\n    \n    public static long min(final long a, final long b) {\n        return (a <= b) ? a : b;\n    }\n\n    \n    public static float min(final float a, final float b) {\n        return (a <= b) ? a : (Float.isNaN(a + b) ? Float.NaN : b);\n    }\n\n    \n    public static double min(final double a, final double b) {\n        return (a <= b) ? a : (Double.isNaN(a + b) ? Double.NaN : b);\n    }\n\n    \n    public static int max(final int a, final int b) {\n        return (a <= b) ? b : a;\n    }\n\n    \n    public static long max(final long a, final long b) {\n        return (a <= b) ? b : a;\n    }\n\n    \n    public static float max(final float a, final float b) {\n        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : a);\n    }\n\n    \n    public static double max(final double a, final double b) {\n        return (a <= b) ? b : (Double.isNaN(a + b) ? Double.NaN : a);\n    }\n\n}\n",
      "buggy_signatures": [
        "private FastMath()",
        "public static double sqrt(final double a)",
        "public static double cosh(double x)",
        "public static double sinh(double x)",
        "public static double tanh(double x)",
        "public static double acosh(final double a)",
        "public static double asinh(double a)",
        "public static double atanh(double a)",
        "public static double signum(final double a)",
        "public static double nextUp(final double a)",
        "public static double random()",
        "public static double exp(double x)",
        "private static double exp(double x, double extra, double[] hiPrec)",
        "public static double expm1(double x)",
        "private static double expm1(double x, double hiPrecOut[])",
        "private static double slowexp(final double x, final double result[])",
        "private static void split(final double d, final double split[])",
        "private static void resplit(final double a[])",
        "private static void splitMult(double a[], double b[], double ans[])",
        "private static void splitAdd(final double a[], final double b[], final double ans[])",
        "private static void splitReciprocal(final double in[], final double result[])",
        "private static void quadMult(final double a[], final double b[], final double result[])",
        "private static double expint(int p, final double result[])",
        "public static double log(final double x)",
        "private static double log(final double x, final double[] hiPrec)",
        "public static double log1p(final double x)",
        "public static double log10(final double x)",
        "public static double pow(double x, double y)",
        "private static double[] slowLog(double xi)",
        "private static double slowSin(final double x, final double result[])",
        "private static double slowCos(final double x, final double result[])",
        "private static void buildSinCosTables()",
        "private static double polySine(final double x)",
        "private static double polyCosine(double x)",
        "private static double sinQ(double xa, double xb)",
        "private static double cosQ(double xa, double xb)",
        "private static double tanQ(double xa, double xb, boolean cotanFlag)",
        "private static void reducePayneHanek(double x, double result[])",
        "public static double sin(double x)",
        "public static double cos(double x)",
        "public static double tan(double x)",
        "public static double atan(double x)",
        "private static double atan(double xa, double xb, boolean leftPlane)",
        "public static double atan2(double y, double x)",
        "public static double asin(double x)",
        "public static double acos(double x)",
        "public static double cbrt(double x)",
        "public static double toRadians(double x)",
        "public static double toDegrees(double x)",
        "public static int abs(final int x)",
        "public static long abs(final long x)",
        "public static float abs(final float x)",
        "public static double abs(double x)",
        "public static double ulp(double x)",
        "public static double nextAfter(double d, double direction)",
        "public static double floor(double x)",
        "public static double ceil(double x)",
        "public static double rint(double x)",
        "public static long round(double x)",
        "public static int round(final float x)",
        "public static int min(final int a, final int b)",
        "public static long min(final long a, final long b)",
        "public static float min(final float a, final float b)",
        "public static double min(final double a, final double b)",
        "public static int max(final int a, final int b)",
        "public static long max(final long a, final long b)",
        "public static float max(final float a, final float b)",
        "public static double max(final double a, final double b)"
      ],
      "fixed_signatures": [
        "private FastMath()",
        "public static double sqrt(final double a)",
        "public static double cosh(double x)",
        "public static double sinh(double x)",
        "public static double tanh(double x)",
        "public static double acosh(final double a)",
        "public static double asinh(double a)",
        "public static double atanh(double a)",
        "public static double signum(final double a)",
        "public static double nextUp(final double a)",
        "public static double random()",
        "public static double exp(double x)",
        "private static double exp(double x, double extra, double[] hiPrec)",
        "public static double expm1(double x)",
        "private static double expm1(double x, double hiPrecOut[])",
        "private static double slowexp(final double x, final double result[])",
        "private static void split(final double d, final double split[])",
        "private static void resplit(final double a[])",
        "private static void splitMult(double a[], double b[], double ans[])",
        "private static void splitAdd(final double a[], final double b[], final double ans[])",
        "private static void splitReciprocal(final double in[], final double result[])",
        "private static void quadMult(final double a[], final double b[], final double result[])",
        "private static double expint(int p, final double result[])",
        "public static double log(final double x)",
        "private static double log(final double x, final double[] hiPrec)",
        "public static double log1p(final double x)",
        "public static double log10(final double x)",
        "public static double pow(double x, double y)",
        "private static double[] slowLog(double xi)",
        "private static double slowSin(final double x, final double result[])",
        "private static double slowCos(final double x, final double result[])",
        "private static void buildSinCosTables()",
        "private static double polySine(final double x)",
        "private static double polyCosine(double x)",
        "private static double sinQ(double xa, double xb)",
        "private static double cosQ(double xa, double xb)",
        "private static double tanQ(double xa, double xb, boolean cotanFlag)",
        "private static void reducePayneHanek(double x, double result[])",
        "public static double sin(double x)",
        "public static double cos(double x)",
        "public static double tan(double x)",
        "public static double atan(double x)",
        "private static double atan(double xa, double xb, boolean leftPlane)",
        "public static double atan2(double y, double x)",
        "public static double asin(double x)",
        "public static double acos(double x)",
        "public static double cbrt(double x)",
        "public static double toRadians(double x)",
        "public static double toDegrees(double x)",
        "public static int abs(final int x)",
        "public static long abs(final long x)",
        "public static float abs(final float x)",
        "public static double abs(double x)",
        "public static double ulp(double x)",
        "public static double nextAfter(double d, double direction)",
        "public static double floor(double x)",
        "public static double ceil(double x)",
        "public static double rint(double x)",
        "public static long round(double x)",
        "public static int round(final float x)",
        "public static int min(final int a, final int b)",
        "public static long min(final long a, final long b)",
        "public static float min(final float a, final float b)",
        "public static double min(final double a, final double b)",
        "public static int max(final int a, final int b)",
        "public static long max(final long a, final long b)",
        "public static float max(final float a, final float b)",
        "public static double max(final double a, final double b)"
      ],
      "methods": [
        {
          "buggy_method": "  public static float max(final float a, final float b) {\n  return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);\n  }",
          "fixed_method": "  public static float max(final float a, final float b) {\n  return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : a);\n  }",
          "diff": [
            "@@ -3479,7 +3479,7 @@",
            "      * @return b if a is lesser or equal to b, a otherwise\n",
            "      */\n",
            "     public static float max(final float a, final float b) {\n",
            "-        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);\n",
            "+        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : a);\n",
            "     }\n",
            " \n",
            "     /** Compute the maximum of two values\n"
          ],
          "changed_lines": 2
        }
      ]
    }
  ]
}
