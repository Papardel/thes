{
  "bug_id": "57",
  "failed_tests": {
    "com.fasterxml.jackson.databind.seq.ReadValuesTest": [
      {
        "methodName": "testRootBeans",
        "error": "java.io.CharConversionException",
        "message": "Invalid UTF-32 character 0x2261223a(above 10ffff)  at char #1, byte #7)",
        "fail_line": "            _testRootBeans(src);",
        "test_source": "  public void testRootBeans() throws Exception {\n  for (Source src : Source.values()) {\n  _testRootBeans(src);\n  }\n  }",
        "stack": [
          "UTF32Reader.reportInvalid line 189, UTF32Reader.read line 150, ReaderBasedJsonParser.loadMore line 180, ReaderBasedJsonParser._skipWSOrEnd line 2259, ReaderBasedJsonParser.nextToken line 601, ObjectReader._bindAndReadValues line 1630, ObjectReader.readValues line 1441, ReadValuesTest._iterator line 71, ReadValuesTest._testRootBeans line 87, ReadValuesTest.testRootBeans line 49"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "com/fasterxml/jackson/databind/ObjectReader.java",
      "buggy_full_code": "package com.fasterxml.jackson.databind;\n\nimport java.io.*;\nimport java.net.URL;\nimport java.util.*;\nimport java.util.concurrent.ConcurrentHashMap;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.filter.FilteringParserDelegate;\nimport com.fasterxml.jackson.core.filter.JsonPointerBasedFilter;\nimport com.fasterxml.jackson.core.filter.TokenFilter;\nimport com.fasterxml.jackson.core.type.ResolvedType;\nimport com.fasterxml.jackson.core.type.TypeReference;\nimport com.fasterxml.jackson.databind.cfg.ContextAttributes;\nimport com.fasterxml.jackson.databind.deser.DataFormatReaders;\nimport com.fasterxml.jackson.databind.deser.DefaultDeserializationContext;\nimport com.fasterxml.jackson.databind.deser.DeserializationProblemHandler;\nimport com.fasterxml.jackson.databind.node.JsonNodeFactory;\nimport com.fasterxml.jackson.databind.node.NullNode;\nimport com.fasterxml.jackson.databind.node.TreeTraversingParser;\nimport com.fasterxml.jackson.databind.type.SimpleType;\nimport com.fasterxml.jackson.databind.type.TypeFactory;\n\n\npublic class ObjectReader extends ObjectCodec implements Versioned, java.io.Serializable { private static final long serialVersionUID = 1L; private final static JavaType JSON_NODE_TYPE = SimpleType.constructUnsafe(JsonNode.class); protected final DeserializationConfig _config; protected final DefaultDeserializationContext _context; protected final JsonFactory _parserFactory; protected final boolean _unwrapRoot; private final TokenFilter _filter; protected final JavaType _valueType; protected final JsonDeserializer<Object> _rootDeserializer; protected final Object _valueToUpdate; protected final FormatSchema _schema; protected final InjectableValues _injectableValues; protected final DataFormatReaders _dataFormatReaders; final protected ConcurrentHashMap<JavaType, JsonDeserializer<Object>> _rootDeserializers; protected ObjectReader(ObjectMapper mapper, DeserializationConfig config) {\n        this(mapper, config, null, null, null, null);\n    }\n\n    \n    protected ObjectReader(ObjectMapper mapper, DeserializationConfig config, JavaType valueType, Object valueToUpdate, FormatSchema schema, InjectableValues injectableValues) {\n        _config = config;\n        _context = mapper._deserializationContext;\n        _rootDeserializers = mapper._rootDeserializers;\n        _parserFactory = mapper._jsonFactory;\n        _valueType = valueType;\n        _valueToUpdate = valueToUpdate;\n        if (valueToUpdate != null && valueType.isArrayType()) {\n            throw new IllegalArgumentException(\"Can not update an array value\");\n        }\n        _schema = schema;\n        _injectableValues = injectableValues;\n        _unwrapRoot = config.useRootWrapping();\n\n        _rootDeserializer = _prefetchRootDeserializer(valueType);\n        _dataFormatReaders = null;        \n        _filter = null;\n    }\n    \n    \n    protected ObjectReader(ObjectReader base, DeserializationConfig config, JavaType valueType, JsonDeserializer<Object> rootDeser, Object valueToUpdate, FormatSchema schema, InjectableValues injectableValues, DataFormatReaders dataFormatReaders) {\n        _config = config;\n        _context = base._context;\n\n        _rootDeserializers = base._rootDeserializers;\n        _parserFactory = base._parserFactory;\n\n        _valueType = valueType;\n        _rootDeserializer = rootDeser;\n        _valueToUpdate = valueToUpdate;\n        if (valueToUpdate != null && valueType.isArrayType()) {\n            throw new IllegalArgumentException(\"Can not update an array value\");\n        }\n        _schema = schema;\n        _injectableValues = injectableValues;\n        _unwrapRoot = config.useRootWrapping();\n        _dataFormatReaders = dataFormatReaders;\n        _filter = base._filter;\n    }\n\n    \n    protected ObjectReader(ObjectReader base, DeserializationConfig config) {\n        _config = config;\n        _context = base._context;\n\n        _rootDeserializers = base._rootDeserializers;\n        _parserFactory = base._parserFactory;\n\n        _valueType = base._valueType;\n        _rootDeserializer = base._rootDeserializer;\n        _valueToUpdate = base._valueToUpdate;\n        _schema = base._schema;\n        _injectableValues = base._injectableValues;\n        _unwrapRoot = config.useRootWrapping();\n        _dataFormatReaders = base._dataFormatReaders;\n        _filter = base._filter;\n    }\n    \n    protected ObjectReader(ObjectReader base, JsonFactory f) {\n        \n        _config = base._config\n            .with(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY, f.requiresPropertyOrdering());\n        _context = base._context;\n\n        _rootDeserializers = base._rootDeserializers;\n        _parserFactory = f;\n\n        _valueType = base._valueType;\n        _rootDeserializer = base._rootDeserializer;\n        _valueToUpdate = base._valueToUpdate;\n        _schema = base._schema;\n        _injectableValues = base._injectableValues;\n        _unwrapRoot = base._unwrapRoot;\n        _dataFormatReaders = base._dataFormatReaders;\n        _filter = base._filter;\n    }\n    \n    protected ObjectReader(ObjectReader base, TokenFilter filter) {\n        _config = base._config;\n        _context = base._context;\n        _rootDeserializers = base._rootDeserializers;\n        _parserFactory = base._parserFactory;\n        _valueType = base._valueType;\n        _rootDeserializer = base._rootDeserializer;\n        _valueToUpdate = base._valueToUpdate;\n        _schema = base._schema;\n        _injectableValues = base._injectableValues;\n        _unwrapRoot = base._unwrapRoot;\n        _dataFormatReaders = base._dataFormatReaders;\n        _filter = filter;\n    }\n    \n    \n    @Override\n    public Version version() {\n        return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION;\n    }\n\n    \n\n    \n    protected ObjectReader _new(ObjectReader base, JsonFactory f) {\n        return new ObjectReader(base, f);\n    }\n\n    \n    protected ObjectReader _new(ObjectReader base, DeserializationConfig config) {\n        return new ObjectReader(base, config);\n    }\n\n    \n    protected ObjectReader _new(ObjectReader base, DeserializationConfig config, JavaType valueType, JsonDeserializer<Object> rootDeser, Object valueToUpdate, FormatSchema schema, InjectableValues injectableValues, DataFormatReaders dataFormatReaders) {\n        return new ObjectReader(base, config, valueType, rootDeser,  valueToUpdate,\n                 schema,  injectableValues, dataFormatReaders);\n    }\n\n    \n    protected <T> MappingIterator<T> _newIterator(JsonParser p, DeserializationContext ctxt, JsonDeserializer<?> deser, boolean parserManaged) {\n        return new MappingIterator<T>(_valueType, p, ctxt,\n                deser, parserManaged, _valueToUpdate);\n    }\n\n    \n\n    \n    protected JsonToken _initForReading(JsonParser p) throws IOException {\n        if (_schema != null) {\n            p.setSchema(_schema);\n        }\n        _config.initialize(p); \n\n        \n        JsonToken t = p.getCurrentToken();\n        if (t == null) { \n            t = p.nextToken();\n            if (t == null) {\n                \n                throw JsonMappingException.from(p, \"No content to map due to end-of-input\");\n            }\n        }\n        return t;\n    }\n\n    \n    protected void _initForMultiRead(JsonParser p) throws IOException {\n        if (_schema != null) {\n            p.setSchema(_schema);\n        }\n        _config.initialize(p); \n    }\n\n    \n\n    \n    public ObjectReader with(DeserializationFeature feature) {\n        return _with(_config.with(feature));\n    }\n\n    \n    public ObjectReader with(DeserializationFeature first, DeserializationFeature... other) {\n        return _with(_config.with(first, other));\n    }    \n\n    \n    public ObjectReader withFeatures(DeserializationFeature... features) {\n        return _with(_config.withFeatures(features));\n    }    \n\n    \n    public ObjectReader without(DeserializationFeature feature) {\n        return _with(_config.without(feature)); \n    }\n\n    \n    public ObjectReader without(DeserializationFeature first, DeserializationFeature... other) {\n        return _with(_config.without(first, other));\n    }    \n\n    \n    public ObjectReader withoutFeatures(DeserializationFeature... features) {\n        return _with(_config.withoutFeatures(features));\n    }    \n\n    \n\n    \n    public ObjectReader with(JsonParser.Feature feature) {\n        return _with(_config.with(feature));\n    }\n\n    \n    public ObjectReader withFeatures(JsonParser.Feature... features) {\n        return _with(_config.withFeatures(features));\n    }    \n\n    \n    public ObjectReader without(JsonParser.Feature feature) {\n        return _with(_config.without(feature)); \n    }\n\n    \n    public ObjectReader withoutFeatures(JsonParser.Feature... features) {\n        return _with(_config.withoutFeatures(features));\n    }\n\n    \n\n    \n    public ObjectReader with(FormatFeature feature) {\n        return _with(_config.with(feature));\n    }\n\n    \n    public ObjectReader withFeatures(FormatFeature... features) {\n        return _with(_config.withFeatures(features));\n    }    \n\n    \n    public ObjectReader without(FormatFeature feature) {\n        return _with(_config.without(feature)); \n    }\n\n    \n    public ObjectReader withoutFeatures(FormatFeature... features) {\n        return _with(_config.withoutFeatures(features));\n    }\n    \n    \n\n    \n    public ObjectReader with(DeserializationConfig config) {\n        return _with(config);\n    }    \n\n    \n    public ObjectReader with(InjectableValues injectableValues) {\n        if (_injectableValues == injectableValues) {\n            return this;\n        }\n        return _new(this, _config,\n                _valueType, _rootDeserializer, _valueToUpdate,\n                _schema, injectableValues, _dataFormatReaders);\n    }\n\n    \n    public ObjectReader with(JsonNodeFactory f) {\n        return _with(_config.with(f));\n    }\n\n    \n    public ObjectReader with(JsonFactory f) {\n        if (f == _parserFactory) {\n            return this;\n        }\n        ObjectReader r = _new(this, f);\n        \n        if (f.getCodec() == null) {\n            f.setCodec(r);\n        }\n        return r;\n    }\n    \n    \n    public ObjectReader withRootName(String rootName) {\n        return _with(_config.withRootName(rootName));\n    }\n\n    \n    public ObjectReader withRootName(PropertyName rootName) {\n        return _with(_config.withRootName(rootName));\n    }\n    \n    \n    public ObjectReader withoutRootName() {\n        return _with(_config.withRootName(PropertyName.NO_NAME));\n    }\n    \n    \n    public ObjectReader with(FormatSchema schema) {\n        if (_schema == schema) {\n            return this;\n        }\n        _verifySchemaType(schema);\n        return _new(this, _config, _valueType, _rootDeserializer, _valueToUpdate,\n                schema, _injectableValues, _dataFormatReaders);\n    }\n\n    \n    public ObjectReader forType(JavaType valueType) {\n        if (valueType != null && valueType.equals(_valueType)) {\n            return this;\n        }\n        JsonDeserializer<Object> rootDeser = _prefetchRootDeserializer(valueType);\n        \n        DataFormatReaders det = _dataFormatReaders;\n        if (det != null) {\n            det = det.withType(valueType);\n        }\n        return _new(this, _config, valueType, rootDeser,\n                _valueToUpdate, _schema, _injectableValues, det);\n    }    \n\n    \n    public ObjectReader forType(Class<?> valueType) {\n        return forType(_config.constructType(valueType));\n    }    \n\n    \n    public ObjectReader forType(TypeReference<?> valueTypeRef) {\n        return forType(_config.getTypeFactory().constructType(valueTypeRef.getType()));\n    }    \n\n    \n    @Deprecated\n    public ObjectReader withType(JavaType valueType) {\n        return forType(valueType);\n    }\n\n    \n    @Deprecated\n    public ObjectReader withType(Class<?> valueType) {\n        return forType(_config.constructType(valueType));\n    }    \n\n    \n    @Deprecated\n    public ObjectReader withType(java.lang.reflect.Type valueType) {\n        return forType(_config.getTypeFactory().constructType(valueType));\n    }\n\n    \n    @Deprecated\n    public ObjectReader withType(TypeReference<?> valueTypeRef) {\n        return forType(_config.getTypeFactory().constructType(valueTypeRef.getType()));\n    }    \n\n    \n    public ObjectReader withValueToUpdate(Object value) {\n        if (value == _valueToUpdate) return this;\n        if (value == null) {\n            throw new IllegalArgumentException(\"cat not update null value\");\n        }\n        JavaType t;\n        \n        \n        if (_valueType == null) {\n            t = _config.constructType(value.getClass());\n        } else {\n            t = _valueType;\n        }\n        return _new(this, _config, t, _rootDeserializer, value,\n                _schema, _injectableValues, _dataFormatReaders);\n    }\n\n    \n    public ObjectReader withView(Class<?> activeView) {\n        return _with(_config.withView(activeView));\n    }\n\n    public ObjectReader with(Locale l) {\n        return _with(_config.with(l));\n    }\n\n    public ObjectReader with(TimeZone tz) {\n        return _with(_config.with(tz));\n    }\n\n    public ObjectReader withHandler(DeserializationProblemHandler h) {\n        return _with(_config.withHandler(h));\n    }\n\n    public ObjectReader with(Base64Variant defaultBase64) {\n        return _with(_config.with(defaultBase64));\n    }\n\n    \n    public ObjectReader withFormatDetection(ObjectReader... readers) {\n        return withFormatDetection(new DataFormatReaders(readers));\n    }\n\n    \n    public ObjectReader withFormatDetection(DataFormatReaders readers) {\n        return _new(this, _config, _valueType, _rootDeserializer, _valueToUpdate,\n                _schema, _injectableValues, readers);\n    }\n\n    \n    public ObjectReader with(ContextAttributes attrs) {\n        return _with(_config.with(attrs));\n    }\n\n    \n    public ObjectReader withAttributes(Map<?,?> attrs) {\n        return _with(_config.withAttributes(attrs));\n    }\n\n    \n    public ObjectReader withAttribute(Object key, Object value) {\n        return _with( _config.withAttribute(key, value));\n    }\n\n    \n    public ObjectReader withoutAttribute(Object key) {\n        return _with(_config.withoutAttribute(key));\n    }\n\n    \n    \n    protected ObjectReader _with(DeserializationConfig newConfig) {\n        if (newConfig == _config) {\n            return this;\n        }\n        ObjectReader r = _new(this, newConfig);\n        if (_dataFormatReaders != null) {\n            r  = r.withFormatDetection(_dataFormatReaders.with(newConfig));\n        }\n        return r;\n    }\n    \n    \n    \n    public boolean isEnabled(DeserializationFeature f) {\n        return _config.isEnabled(f);\n    }\n\n    public boolean isEnabled(MapperFeature f) {\n        return _config.isEnabled(f);\n    }\n\n    public boolean isEnabled(JsonParser.Feature f) {\n        return _parserFactory.isEnabled(f);\n    }\n\n    \n    public DeserializationConfig getConfig() {\n        return _config;\n    }\n    \n    \n    @Override\n    public JsonFactory getFactory() {\n        return _parserFactory;\n    }\n\n    public TypeFactory getTypeFactory() {\n        return _config.getTypeFactory();\n    }\n\n    \n    public ContextAttributes getAttributes() {\n        return _config.getAttributes();\n    }\n\n    \n    public InjectableValues getInjectableValues() {\n        return _injectableValues;\n    }\n\n    \n\n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(JsonParser p) throws IOException {\n        return (T) _bind(p, _valueToUpdate);\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public <T> T readValue(JsonParser p, Class<T> valueType) throws IOException {\n        return (T) forType(valueType).readValue(p);\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public <T> T readValue(JsonParser p, TypeReference<?> valueTypeRef) throws IOException {\n        return (T) forType(valueTypeRef).readValue(p);\n    }\n\n    \n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(JsonParser p, ResolvedType valueType) throws IOException, JsonProcessingException {\n        return (T) forType((JavaType)valueType).readValue(p);\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(JsonParser p, JavaType valueType) throws IOException {\n        return (T) forType(valueType).readValue(p);\n    }\n\n    \n    @Override\n    public <T> Iterator<T> readValues(JsonParser p, Class<T> valueType) throws IOException {\n        return forType(valueType).readValues(p);\n    }\n\n    \n    @Override\n    public <T> Iterator<T> readValues(JsonParser p, TypeReference<?> valueTypeRef) throws IOException {\n        return forType(valueTypeRef).readValues(p);\n    }\n    \n    \n    @Override\n    public <T> Iterator<T> readValues(JsonParser p, ResolvedType valueType) throws IOException {\n        return readValues(p, (JavaType) valueType);\n    }\n\n    \n    public <T> Iterator<T> readValues(JsonParser p, JavaType valueType) throws IOException {\n        return forType(valueType).readValues(p);\n    }\n\n    \n\n    @Override\n    public JsonNode createArrayNode() {\n        return _config.getNodeFactory().arrayNode();\n    }\n\n    @Override\n    public JsonNode createObjectNode() {\n        return _config.getNodeFactory().objectNode();\n    }\n\n    @Override\n    public JsonParser treeAsTokens(TreeNode n) {\n        return new TreeTraversingParser((JsonNode) n, this);\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public <T extends TreeNode> T readTree(JsonParser p) throws IOException {\n        return (T) _bindAsTree(p);\n    }\n     \n    @Override\n    public void writeTree(JsonGenerator jgen, TreeNode rootNode) {\n        throw new UnsupportedOperationException();\n    }\n    \n    \n    \n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(InputStream src) throws IOException, JsonProcessingException {\n        if (_dataFormatReaders != null) {\n            return (T) _detectBindAndClose(_dataFormatReaders.findFormat(src), false);\n        }\n        \n        return (T) _bindAndClose(_considerFilter(_parserFactory.createParser(src), false));\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(Reader src) throws IOException, JsonProcessingException {\n        if (_dataFormatReaders != null) {\n            _reportUndetectableSource(src);\n        }\n\n        return (T) _bindAndClose(_considerFilter(_parserFactory.createParser(src), false));\n    }\n    \n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(String src) throws IOException, JsonProcessingException {\n        if (_dataFormatReaders != null) {\n            _reportUndetectableSource(src);\n        }\n        \n        return (T) _bindAndClose(_considerFilter(_parserFactory.createParser(src), false));\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(byte[] src) throws IOException, JsonProcessingException {\n        if (_dataFormatReaders != null) {\n            return (T) _detectBindAndClose(src, 0, src.length);\n        }\n        \n        return (T) _bindAndClose(_considerFilter(_parserFactory.createParser(src), false));\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(byte[] src, int offset, int length) throws IOException, JsonProcessingException {\n        if (_dataFormatReaders != null) {\n            return (T) _detectBindAndClose(src, offset, length);\n        }\n\n        return (T) _bindAndClose(_considerFilter(_parserFactory.createParser(src, offset, length),\n                false));\n    }\n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(File src) throws IOException, JsonProcessingException {\n        if (_dataFormatReaders != null) {\n            return (T) _detectBindAndClose(_dataFormatReaders.findFormat(_inputStream(src)), true);\n        }\n\n        return (T) _bindAndClose(_considerFilter(_parserFactory.createParser(src), false));\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(URL src) throws IOException, JsonProcessingException {\n        if (_dataFormatReaders != null) {\n            return (T) _detectBindAndClose(_dataFormatReaders.findFormat(_inputStream(src)), true);\n        }\n\n        return (T) _bindAndClose(_considerFilter(_parserFactory.createParser(src), false));\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(JsonNode src) throws IOException, JsonProcessingException {\n        if (_dataFormatReaders != null) {\n            _reportUndetectableSource(src);\n        }\n        \n        return (T) _bindAndClose(_considerFilter(treeAsTokens(src), false));\n    }\n    \n    \n    public JsonNode readTree(InputStream in) throws IOException, JsonProcessingException {\n        if (_dataFormatReaders != null) {\n            return _detectBindAndCloseAsTree(in);\n        }\n\n        return _bindAndCloseAsTree(_considerFilter(_parserFactory.createParser(in), false));\n    }\n    \n    \n    public JsonNode readTree(Reader r) throws IOException, JsonProcessingException {\n        if (_dataFormatReaders != null) {\n            _reportUndetectableSource(r);\n        }\n        \n        return _bindAndCloseAsTree(_considerFilter(_parserFactory.createParser(r), false));\n    }\n\n    \n    public JsonNode readTree(String json) throws IOException, JsonProcessingException {\n        if (_dataFormatReaders != null) {\n            _reportUndetectableSource(json);\n        }\n\n        return _bindAndCloseAsTree(_considerFilter(_parserFactory.createParser(json), false));\n    }\n\n    \n    \n    \n    public <T> MappingIterator<T> readValues(JsonParser p) throws IOException, JsonProcessingException {\n        DeserializationContext ctxt = createDeserializationContext(p);\n        \n        return _newIterator(p, ctxt, _findRootDeserializer(ctxt), false);\n    }\n    \n    \n    public <T> MappingIterator<T> readValues(InputStream src) throws IOException, JsonProcessingException {\n        if (_dataFormatReaders != null) {\n            return _detectBindAndReadValues(_dataFormatReaders.findFormat(src), false);\n        }\n        \n        return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), true));\n    }\n    \n    \n    @SuppressWarnings(\"resource\")\n    public <T> MappingIterator<T> readValues(Reader src) throws IOException, JsonProcessingException {\n        if (_dataFormatReaders != null) {\n            _reportUndetectableSource(src);\n        }\n        JsonParser p = _considerFilter(_parserFactory.createParser(src), true);\n        _initForMultiRead(p);\n        p.nextToken();\n        DeserializationContext ctxt = createDeserializationContext(p);\n        return _newIterator(p, ctxt, _findRootDeserializer(ctxt), true);\n    }\n    \n    \n    @SuppressWarnings(\"resource\")\n    public <T> MappingIterator<T> readValues(String json) throws IOException, JsonProcessingException {\n        if (_dataFormatReaders != null) {\n            _reportUndetectableSource(json);\n        }\n        JsonParser p = _considerFilter(_parserFactory.createParser(json), true);\n        _initForMultiRead(p);\n        p.nextToken();\n        DeserializationContext ctxt = createDeserializationContext(p);\n        return _newIterator(p, ctxt, _findRootDeserializer(ctxt), true);\n    }\n\n    \n    public <T> MappingIterator<T> readValues(byte[] src, int offset, int length) throws IOException, JsonProcessingException {\n        if (_dataFormatReaders != null) {\n            return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n        }\n        return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n                true));\n    }\n\n    \n    public final <T> MappingIterator<T> readValues(byte[] src) throws IOException, JsonProcessingException {\n        return readValues(src, 0, src.length);\n    }\n    \n    \n    public <T> MappingIterator<T> readValues(File src) throws IOException, JsonProcessingException {\n        if (_dataFormatReaders != null) {\n            return _detectBindAndReadValues(\n                    _dataFormatReaders.findFormat(_inputStream(src)), false);\n        }\n        return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), true));\n    }\n\n    \n    public <T> MappingIterator<T> readValues(URL src) throws IOException, JsonProcessingException {\n        if (_dataFormatReaders != null) {\n            return _detectBindAndReadValues(\n                    _dataFormatReaders.findFormat(_inputStream(src)), true);\n        }\n        return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), true));\n    }\n\n    \n\n    @Override\n    public <T> T treeToValue(TreeNode n, Class<T> valueType) throws JsonProcessingException {\n        try {\n            return readValue(treeAsTokens(n), valueType);\n        } catch (JsonProcessingException e) {\n            throw e;\n        } catch (IOException e) { \n            throw new IllegalArgumentException(e.getMessage(), e);\n        }\n    }    \n\n    @Override\n    public void writeValue(JsonGenerator gen, Object value) throws IOException, JsonProcessingException {\n        throw new UnsupportedOperationException(\"Not implemented for ObjectReader\");\n    }\n\n    \n    \n    \n    protected Object _bind(JsonParser p, Object valueToUpdate) throws IOException {\n        \n        Object result;\n        JsonToken t = _initForReading(p);\n        if (t == JsonToken.VALUE_NULL) {\n            if (valueToUpdate == null) {\n                DeserializationContext ctxt = createDeserializationContext(p);\n                result = _findRootDeserializer(ctxt).getNullValue(ctxt);\n            } else {\n                result = valueToUpdate;\n            }\n        } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {\n            result = valueToUpdate;\n        } else { \n            DeserializationContext ctxt = createDeserializationContext(p);\n            JsonDeserializer<Object> deser = _findRootDeserializer(ctxt);\n            if (_unwrapRoot) {\n                result = _unwrapAndDeserialize(p, ctxt, _valueType, deser);\n            } else {\n                if (valueToUpdate == null) {\n                    result = deser.deserialize(p, ctxt);\n                } else {\n                    deser.deserialize(p, ctxt, valueToUpdate);\n                    result = valueToUpdate;\n                }\n            }\n        }\n        \n        p.clearCurrentToken();\n        return result;\n    }\n    \n    \n    protected JsonParser _considerFilter(final JsonParser p, boolean multiValue) {\n        \n        \n        return ((_filter == null) || FilteringParserDelegate.class.isInstance(p))\n                ? p : new FilteringParserDelegate(p, _filter, false, multiValue);\n    }\n    \n    protected Object _bindAndClose(JsonParser p) throws IOException {\n        try {\n            Object result;\n            JsonToken t = _initForReading(p);\n            if (t == JsonToken.VALUE_NULL) {\n                if (_valueToUpdate == null) {\n                    DeserializationContext ctxt = createDeserializationContext(p);\n                    result = _findRootDeserializer(ctxt).getNullValue(ctxt);\n                } else {\n                    result = _valueToUpdate;\n                }\n            } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {\n                result = _valueToUpdate;\n            } else {\n                DeserializationContext ctxt = createDeserializationContext(p);\n                JsonDeserializer<Object> deser = _findRootDeserializer(ctxt);\n                if (_unwrapRoot) {\n                    result = _unwrapAndDeserialize(p, ctxt, _valueType, deser);\n                } else {\n                    if (_valueToUpdate == null) {\n                        result = deser.deserialize(p, ctxt);\n                    } else {\n                        deser.deserialize(p, ctxt, _valueToUpdate);\n                        result = _valueToUpdate;                    \n                    }\n                }\n            }\n            return result;\n        } finally {\n            try {\n                p.close();\n            } catch (IOException ioe) { }\n        }\n    }\n\n    protected JsonNode _bindAndCloseAsTree(JsonParser p) throws IOException {\n        try {\n            return _bindAsTree(p);\n        } finally {\n            try {\n                p.close();\n            } catch (IOException ioe) { }\n        }\n    }\n    \n    protected JsonNode _bindAsTree(JsonParser p) throws IOException {\n        JsonNode result;\n        JsonToken t = _initForReading(p);\n        if (t == JsonToken.VALUE_NULL || t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {\n            result = NullNode.instance;\n        } else {\n            DeserializationContext ctxt = createDeserializationContext(p);\n            JsonDeserializer<Object> deser = _findTreeDeserializer(ctxt);\n            if (_unwrapRoot) {\n                result = (JsonNode) _unwrapAndDeserialize(p, ctxt, JSON_NODE_TYPE, deser);\n            } else {\n                result = (JsonNode) deser.deserialize(p, ctxt);\n            }\n        }\n        \n        p.clearCurrentToken();\n        return result;\n    }\n    \n    \n    protected <T> MappingIterator<T> _bindAndReadValues(JsonParser p) throws IOException {\n        _initForMultiRead(p);\n        p.nextToken();\n        DeserializationContext ctxt = createDeserializationContext(p);\n        return _newIterator(p, ctxt, _findRootDeserializer(ctxt), true);\n    }\n\n    protected Object _unwrapAndDeserialize(JsonParser p, DeserializationContext ctxt, JavaType rootType, JsonDeserializer<Object> deser) throws IOException {\n        PropertyName expRootName = _config.findRootName(rootType);\n        \n        String expSimpleName = expRootName.getSimpleName();\n\n        if (p.getCurrentToken() != JsonToken.START_OBJECT) {\n            throw JsonMappingException.from(p, \"Current token not START_OBJECT (needed to unwrap root name '\"\n                    +expSimpleName+\"'), but \"+p.getCurrentToken());\n        }\n        if (p.nextToken() != JsonToken.FIELD_NAME) {\n            throw JsonMappingException.from(p, \"Current token not FIELD_NAME (to contain expected root name '\"\n                    +expSimpleName+\"'), but \"+p.getCurrentToken());\n        }\n        String actualName = p.getCurrentName();\n        if (!expSimpleName.equals(actualName)) {\n            throw JsonMappingException.from(p, \"Root name '\"+actualName+\"' does not match expected ('\"\n                    +expSimpleName+\"') for type \"+rootType);\n        }\n        \n        p.nextToken();\n        Object result;\n        if (_valueToUpdate == null) {\n            result = deser.deserialize(p, ctxt);\n        } else {\n            deser.deserialize(p, ctxt, _valueToUpdate);\n            result = _valueToUpdate;                    \n        }\n        \n        if (p.nextToken() != JsonToken.END_OBJECT) {\n            throw JsonMappingException.from(p, \"Current token not END_OBJECT (to match wrapper object with root name '\"\n                    +expSimpleName+\"'), but \"+p.getCurrentToken());\n        }\n        return result;\n    }\n\n    \n    \n    @SuppressWarnings(\"resource\")\n    protected Object _detectBindAndClose(byte[] src, int offset, int length) throws IOException {\n        DataFormatReaders.Match match = _dataFormatReaders.findFormat(src, offset, length);\n        if (!match.hasMatch()) {\n            _reportUnkownFormat(_dataFormatReaders, match);\n        }\n        JsonParser p = match.createParserWithMatch();\n        return match.getReader()._bindAndClose(p);\n    }\n\n    @SuppressWarnings(\"resource\")\n    protected Object _detectBindAndClose(DataFormatReaders.Match match, boolean forceClosing) throws IOException {\n        if (!match.hasMatch()) {\n            _reportUnkownFormat(_dataFormatReaders, match);\n        }\n        JsonParser p = match.createParserWithMatch();\n        \n        \n        if (forceClosing) {\n            p.enable(JsonParser.Feature.AUTO_CLOSE_SOURCE);\n        }\n        \n        return match.getReader()._bindAndClose(p);\n    }\n\n    @SuppressWarnings(\"resource\")\n    protected <T> MappingIterator<T> _detectBindAndReadValues(DataFormatReaders.Match match, boolean forceClosing) throws IOException, JsonProcessingException {\n        if (!match.hasMatch()) {\n            _reportUnkownFormat(_dataFormatReaders, match);\n        }\n        JsonParser p = match.createParserWithMatch();\n        \n        \n        if (forceClosing) {\n            p.enable(JsonParser.Feature.AUTO_CLOSE_SOURCE);\n        }\n        \n        return match.getReader()._bindAndReadValues(p);\n    }\n    \n    @SuppressWarnings(\"resource\")\n    protected JsonNode _detectBindAndCloseAsTree(InputStream in) throws IOException {\n        DataFormatReaders.Match match = _dataFormatReaders.findFormat(in);\n        if (!match.hasMatch()) {\n            _reportUnkownFormat(_dataFormatReaders, match);\n        }\n        JsonParser p = match.createParserWithMatch();\n        p.enable(JsonParser.Feature.AUTO_CLOSE_SOURCE);\n        return match.getReader()._bindAndCloseAsTree(p);\n    }\n    \n    \n    protected void _reportUnkownFormat(DataFormatReaders detector, DataFormatReaders.Match match) throws JsonProcessingException {\n        \n        throw new JsonParseException(null, \"Can not detect format from input, does not look like any of detectable formats \"\n                +detector.toString());\n    }\n\n    \n\n    \n    protected void _verifySchemaType(FormatSchema schema) {\n        if (schema != null) {\n            if (!_parserFactory.canUseSchema(schema)) {\n                    throw new IllegalArgumentException(\"Can not use FormatSchema of type \"+schema.getClass().getName()\n                            +\" for format \"+_parserFactory.getFormatName());\n            }\n        }\n    }\n\n    \n    protected DefaultDeserializationContext createDeserializationContext(JsonParser p) {\n        return _context.createInstance(_config, p, _injectableValues);\n    }\n\n    protected void _reportUndetectableSource(Object src) throws JsonProcessingException {\n        \n        throw new JsonParseException(null, \"Can not use source of type \"\n                +src.getClass().getName()+\" with format auto-detection: must be byte- not char-based\");\n    }\n\n    protected InputStream _inputStream(URL src) throws IOException {\n        return src.openStream();\n    }\n\n    protected InputStream _inputStream(File f) throws IOException {\n        return new FileInputStream(f);\n    }\n\n    \n    \n    \n    protected JsonDeserializer<Object> _findRootDeserializer(DeserializationContext ctxt) throws JsonMappingException {\n        if (_rootDeserializer != null) {\n            return _rootDeserializer;\n        }\n\n        \n        JavaType t = _valueType;\n        if (t == null) {\n            throw JsonMappingException.from(ctxt, \"No value type configured for ObjectReader\");\n        }\n        \n        \n        JsonDeserializer<Object> deser = _rootDeserializers.get(t);\n        if (deser != null) {\n            return deser;\n        }\n        \n        deser = ctxt.findRootValueDeserializer(t);\n        if (deser == null) { \n            throw JsonMappingException.from(ctxt, \"Can not find a deserializer for type \"+t);\n        }\n        _rootDeserializers.put(t, deser);\n        return deser;\n    }\n\n    \n    protected JsonDeserializer<Object> _findTreeDeserializer(DeserializationContext ctxt) throws JsonMappingException {\n        JsonDeserializer<Object> deser = _rootDeserializers.get(JSON_NODE_TYPE);\n        if (deser == null) {\n            \n            deser = ctxt.findRootValueDeserializer(JSON_NODE_TYPE);\n            if (deser == null) { \n                throw JsonMappingException.from(ctxt,\n                        \"Can not find a deserializer for type \"+JSON_NODE_TYPE);\n            }\n            _rootDeserializers.put(JSON_NODE_TYPE, deser);\n        }\n        return deser;\n    }\n\n    \n    protected JsonDeserializer<Object> _prefetchRootDeserializer(JavaType valueType) {\n        if (valueType == null || !_config.isEnabled(DeserializationFeature.EAGER_DESERIALIZER_FETCH)) {\n            return null;\n        }\n        \n        JsonDeserializer<Object> deser = _rootDeserializers.get(valueType);\n        if (deser == null) {\n            try {\n                \n                DeserializationContext ctxt = createDeserializationContext(null);\n                deser = ctxt.findRootValueDeserializer(valueType);\n                if (deser != null) {\n                    _rootDeserializers.put(valueType, deser);\n                }\n                return deser;\n            } catch (JsonProcessingException e) {\n                \n            }\n        }\n        return deser;\n    }\n\n    \n    public ObjectReader at(final String value) {\n        return new ObjectReader(this, new JsonPointerBasedFilter(value));\n    }\n\n    \n    public ObjectReader at(final JsonPointer pointer) {\n        return new ObjectReader(this, new JsonPointerBasedFilter(pointer));\n    }\n}\n",
      "fixed_full_code": "package com.fasterxml.jackson.databind;\n\nimport java.io.*;\nimport java.net.URL;\nimport java.util.*;\nimport java.util.concurrent.ConcurrentHashMap;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.filter.FilteringParserDelegate;\nimport com.fasterxml.jackson.core.filter.JsonPointerBasedFilter;\nimport com.fasterxml.jackson.core.filter.TokenFilter;\nimport com.fasterxml.jackson.core.type.ResolvedType;\nimport com.fasterxml.jackson.core.type.TypeReference;\nimport com.fasterxml.jackson.databind.cfg.ContextAttributes;\nimport com.fasterxml.jackson.databind.deser.DataFormatReaders;\nimport com.fasterxml.jackson.databind.deser.DefaultDeserializationContext;\nimport com.fasterxml.jackson.databind.deser.DeserializationProblemHandler;\nimport com.fasterxml.jackson.databind.node.JsonNodeFactory;\nimport com.fasterxml.jackson.databind.node.NullNode;\nimport com.fasterxml.jackson.databind.node.TreeTraversingParser;\nimport com.fasterxml.jackson.databind.type.SimpleType;\nimport com.fasterxml.jackson.databind.type.TypeFactory;\n\n\npublic class ObjectReader extends ObjectCodec implements Versioned, java.io.Serializable { private static final long serialVersionUID = 1L; private final static JavaType JSON_NODE_TYPE = SimpleType.constructUnsafe(JsonNode.class); protected final DeserializationConfig _config; protected final DefaultDeserializationContext _context; protected final JsonFactory _parserFactory; protected final boolean _unwrapRoot; private final TokenFilter _filter; protected final JavaType _valueType; protected final JsonDeserializer<Object> _rootDeserializer; protected final Object _valueToUpdate; protected final FormatSchema _schema; protected final InjectableValues _injectableValues; protected final DataFormatReaders _dataFormatReaders; final protected ConcurrentHashMap<JavaType, JsonDeserializer<Object>> _rootDeserializers; protected ObjectReader(ObjectMapper mapper, DeserializationConfig config) {\n        this(mapper, config, null, null, null, null);\n    }\n\n    \n    protected ObjectReader(ObjectMapper mapper, DeserializationConfig config, JavaType valueType, Object valueToUpdate, FormatSchema schema, InjectableValues injectableValues) {\n        _config = config;\n        _context = mapper._deserializationContext;\n        _rootDeserializers = mapper._rootDeserializers;\n        _parserFactory = mapper._jsonFactory;\n        _valueType = valueType;\n        _valueToUpdate = valueToUpdate;\n        if (valueToUpdate != null && valueType.isArrayType()) {\n            throw new IllegalArgumentException(\"Can not update an array value\");\n        }\n        _schema = schema;\n        _injectableValues = injectableValues;\n        _unwrapRoot = config.useRootWrapping();\n\n        _rootDeserializer = _prefetchRootDeserializer(valueType);\n        _dataFormatReaders = null;        \n        _filter = null;\n    }\n    \n    \n    protected ObjectReader(ObjectReader base, DeserializationConfig config, JavaType valueType, JsonDeserializer<Object> rootDeser, Object valueToUpdate, FormatSchema schema, InjectableValues injectableValues, DataFormatReaders dataFormatReaders) {\n        _config = config;\n        _context = base._context;\n\n        _rootDeserializers = base._rootDeserializers;\n        _parserFactory = base._parserFactory;\n\n        _valueType = valueType;\n        _rootDeserializer = rootDeser;\n        _valueToUpdate = valueToUpdate;\n        if (valueToUpdate != null && valueType.isArrayType()) {\n            throw new IllegalArgumentException(\"Can not update an array value\");\n        }\n        _schema = schema;\n        _injectableValues = injectableValues;\n        _unwrapRoot = config.useRootWrapping();\n        _dataFormatReaders = dataFormatReaders;\n        _filter = base._filter;\n    }\n\n    \n    protected ObjectReader(ObjectReader base, DeserializationConfig config) {\n        _config = config;\n        _context = base._context;\n\n        _rootDeserializers = base._rootDeserializers;\n        _parserFactory = base._parserFactory;\n\n        _valueType = base._valueType;\n        _rootDeserializer = base._rootDeserializer;\n        _valueToUpdate = base._valueToUpdate;\n        _schema = base._schema;\n        _injectableValues = base._injectableValues;\n        _unwrapRoot = config.useRootWrapping();\n        _dataFormatReaders = base._dataFormatReaders;\n        _filter = base._filter;\n    }\n    \n    protected ObjectReader(ObjectReader base, JsonFactory f) {\n        \n        _config = base._config\n            .with(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY, f.requiresPropertyOrdering());\n        _context = base._context;\n\n        _rootDeserializers = base._rootDeserializers;\n        _parserFactory = f;\n\n        _valueType = base._valueType;\n        _rootDeserializer = base._rootDeserializer;\n        _valueToUpdate = base._valueToUpdate;\n        _schema = base._schema;\n        _injectableValues = base._injectableValues;\n        _unwrapRoot = base._unwrapRoot;\n        _dataFormatReaders = base._dataFormatReaders;\n        _filter = base._filter;\n    }\n    \n    protected ObjectReader(ObjectReader base, TokenFilter filter) {\n        _config = base._config;\n        _context = base._context;\n        _rootDeserializers = base._rootDeserializers;\n        _parserFactory = base._parserFactory;\n        _valueType = base._valueType;\n        _rootDeserializer = base._rootDeserializer;\n        _valueToUpdate = base._valueToUpdate;\n        _schema = base._schema;\n        _injectableValues = base._injectableValues;\n        _unwrapRoot = base._unwrapRoot;\n        _dataFormatReaders = base._dataFormatReaders;\n        _filter = filter;\n    }\n    \n    \n    @Override\n    public Version version() {\n        return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION;\n    }\n\n    \n\n    \n    protected ObjectReader _new(ObjectReader base, JsonFactory f) {\n        return new ObjectReader(base, f);\n    }\n\n    \n    protected ObjectReader _new(ObjectReader base, DeserializationConfig config) {\n        return new ObjectReader(base, config);\n    }\n\n    \n    protected ObjectReader _new(ObjectReader base, DeserializationConfig config, JavaType valueType, JsonDeserializer<Object> rootDeser, Object valueToUpdate, FormatSchema schema, InjectableValues injectableValues, DataFormatReaders dataFormatReaders) {\n        return new ObjectReader(base, config, valueType, rootDeser,  valueToUpdate,\n                 schema,  injectableValues, dataFormatReaders);\n    }\n\n    \n    protected <T> MappingIterator<T> _newIterator(JsonParser p, DeserializationContext ctxt, JsonDeserializer<?> deser, boolean parserManaged) {\n        return new MappingIterator<T>(_valueType, p, ctxt,\n                deser, parserManaged, _valueToUpdate);\n    }\n\n    \n\n    \n    protected JsonToken _initForReading(JsonParser p) throws IOException {\n        if (_schema != null) {\n            p.setSchema(_schema);\n        }\n        _config.initialize(p); \n\n        \n        JsonToken t = p.getCurrentToken();\n        if (t == null) { \n            t = p.nextToken();\n            if (t == null) {\n                \n                throw JsonMappingException.from(p, \"No content to map due to end-of-input\");\n            }\n        }\n        return t;\n    }\n\n    \n    protected void _initForMultiRead(JsonParser p) throws IOException {\n        if (_schema != null) {\n            p.setSchema(_schema);\n        }\n        _config.initialize(p); \n    }\n\n    \n\n    \n    public ObjectReader with(DeserializationFeature feature) {\n        return _with(_config.with(feature));\n    }\n\n    \n    public ObjectReader with(DeserializationFeature first, DeserializationFeature... other) {\n        return _with(_config.with(first, other));\n    }    \n\n    \n    public ObjectReader withFeatures(DeserializationFeature... features) {\n        return _with(_config.withFeatures(features));\n    }    \n\n    \n    public ObjectReader without(DeserializationFeature feature) {\n        return _with(_config.without(feature)); \n    }\n\n    \n    public ObjectReader without(DeserializationFeature first, DeserializationFeature... other) {\n        return _with(_config.without(first, other));\n    }    \n\n    \n    public ObjectReader withoutFeatures(DeserializationFeature... features) {\n        return _with(_config.withoutFeatures(features));\n    }    \n\n    \n\n    \n    public ObjectReader with(JsonParser.Feature feature) {\n        return _with(_config.with(feature));\n    }\n\n    \n    public ObjectReader withFeatures(JsonParser.Feature... features) {\n        return _with(_config.withFeatures(features));\n    }    \n\n    \n    public ObjectReader without(JsonParser.Feature feature) {\n        return _with(_config.without(feature)); \n    }\n\n    \n    public ObjectReader withoutFeatures(JsonParser.Feature... features) {\n        return _with(_config.withoutFeatures(features));\n    }\n\n    \n\n    \n    public ObjectReader with(FormatFeature feature) {\n        return _with(_config.with(feature));\n    }\n\n    \n    public ObjectReader withFeatures(FormatFeature... features) {\n        return _with(_config.withFeatures(features));\n    }    \n\n    \n    public ObjectReader without(FormatFeature feature) {\n        return _with(_config.without(feature)); \n    }\n\n    \n    public ObjectReader withoutFeatures(FormatFeature... features) {\n        return _with(_config.withoutFeatures(features));\n    }\n    \n    \n\n    \n    public ObjectReader with(DeserializationConfig config) {\n        return _with(config);\n    }    \n\n    \n    public ObjectReader with(InjectableValues injectableValues) {\n        if (_injectableValues == injectableValues) {\n            return this;\n        }\n        return _new(this, _config,\n                _valueType, _rootDeserializer, _valueToUpdate,\n                _schema, injectableValues, _dataFormatReaders);\n    }\n\n    \n    public ObjectReader with(JsonNodeFactory f) {\n        return _with(_config.with(f));\n    }\n\n    \n    public ObjectReader with(JsonFactory f) {\n        if (f == _parserFactory) {\n            return this;\n        }\n        ObjectReader r = _new(this, f);\n        \n        if (f.getCodec() == null) {\n            f.setCodec(r);\n        }\n        return r;\n    }\n    \n    \n    public ObjectReader withRootName(String rootName) {\n        return _with(_config.withRootName(rootName));\n    }\n\n    \n    public ObjectReader withRootName(PropertyName rootName) {\n        return _with(_config.withRootName(rootName));\n    }\n    \n    \n    public ObjectReader withoutRootName() {\n        return _with(_config.withRootName(PropertyName.NO_NAME));\n    }\n    \n    \n    public ObjectReader with(FormatSchema schema) {\n        if (_schema == schema) {\n            return this;\n        }\n        _verifySchemaType(schema);\n        return _new(this, _config, _valueType, _rootDeserializer, _valueToUpdate,\n                schema, _injectableValues, _dataFormatReaders);\n    }\n\n    \n    public ObjectReader forType(JavaType valueType) {\n        if (valueType != null && valueType.equals(_valueType)) {\n            return this;\n        }\n        JsonDeserializer<Object> rootDeser = _prefetchRootDeserializer(valueType);\n        \n        DataFormatReaders det = _dataFormatReaders;\n        if (det != null) {\n            det = det.withType(valueType);\n        }\n        return _new(this, _config, valueType, rootDeser,\n                _valueToUpdate, _schema, _injectableValues, det);\n    }    \n\n    \n    public ObjectReader forType(Class<?> valueType) {\n        return forType(_config.constructType(valueType));\n    }    \n\n    \n    public ObjectReader forType(TypeReference<?> valueTypeRef) {\n        return forType(_config.getTypeFactory().constructType(valueTypeRef.getType()));\n    }    \n\n    \n    @Deprecated\n    public ObjectReader withType(JavaType valueType) {\n        return forType(valueType);\n    }\n\n    \n    @Deprecated\n    public ObjectReader withType(Class<?> valueType) {\n        return forType(_config.constructType(valueType));\n    }    \n\n    \n    @Deprecated\n    public ObjectReader withType(java.lang.reflect.Type valueType) {\n        return forType(_config.getTypeFactory().constructType(valueType));\n    }\n\n    \n    @Deprecated\n    public ObjectReader withType(TypeReference<?> valueTypeRef) {\n        return forType(_config.getTypeFactory().constructType(valueTypeRef.getType()));\n    }    \n\n    \n    public ObjectReader withValueToUpdate(Object value) {\n        if (value == _valueToUpdate) return this;\n        if (value == null) {\n            throw new IllegalArgumentException(\"cat not update null value\");\n        }\n        JavaType t;\n        \n        \n        if (_valueType == null) {\n            t = _config.constructType(value.getClass());\n        } else {\n            t = _valueType;\n        }\n        return _new(this, _config, t, _rootDeserializer, value,\n                _schema, _injectableValues, _dataFormatReaders);\n    }\n\n    \n    public ObjectReader withView(Class<?> activeView) {\n        return _with(_config.withView(activeView));\n    }\n\n    public ObjectReader with(Locale l) {\n        return _with(_config.with(l));\n    }\n\n    public ObjectReader with(TimeZone tz) {\n        return _with(_config.with(tz));\n    }\n\n    public ObjectReader withHandler(DeserializationProblemHandler h) {\n        return _with(_config.withHandler(h));\n    }\n\n    public ObjectReader with(Base64Variant defaultBase64) {\n        return _with(_config.with(defaultBase64));\n    }\n\n    \n    public ObjectReader withFormatDetection(ObjectReader... readers) {\n        return withFormatDetection(new DataFormatReaders(readers));\n    }\n\n    \n    public ObjectReader withFormatDetection(DataFormatReaders readers) {\n        return _new(this, _config, _valueType, _rootDeserializer, _valueToUpdate,\n                _schema, _injectableValues, readers);\n    }\n\n    \n    public ObjectReader with(ContextAttributes attrs) {\n        return _with(_config.with(attrs));\n    }\n\n    \n    public ObjectReader withAttributes(Map<?,?> attrs) {\n        return _with(_config.withAttributes(attrs));\n    }\n\n    \n    public ObjectReader withAttribute(Object key, Object value) {\n        return _with( _config.withAttribute(key, value));\n    }\n\n    \n    public ObjectReader withoutAttribute(Object key) {\n        return _with(_config.withoutAttribute(key));\n    }\n\n    \n    \n    protected ObjectReader _with(DeserializationConfig newConfig) {\n        if (newConfig == _config) {\n            return this;\n        }\n        ObjectReader r = _new(this, newConfig);\n        if (_dataFormatReaders != null) {\n            r  = r.withFormatDetection(_dataFormatReaders.with(newConfig));\n        }\n        return r;\n    }\n    \n    \n    \n    public boolean isEnabled(DeserializationFeature f) {\n        return _config.isEnabled(f);\n    }\n\n    public boolean isEnabled(MapperFeature f) {\n        return _config.isEnabled(f);\n    }\n\n    public boolean isEnabled(JsonParser.Feature f) {\n        return _parserFactory.isEnabled(f);\n    }\n\n    \n    public DeserializationConfig getConfig() {\n        return _config;\n    }\n    \n    \n    @Override\n    public JsonFactory getFactory() {\n        return _parserFactory;\n    }\n\n    public TypeFactory getTypeFactory() {\n        return _config.getTypeFactory();\n    }\n\n    \n    public ContextAttributes getAttributes() {\n        return _config.getAttributes();\n    }\n\n    \n    public InjectableValues getInjectableValues() {\n        return _injectableValues;\n    }\n\n    \n\n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(JsonParser p) throws IOException {\n        return (T) _bind(p, _valueToUpdate);\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public <T> T readValue(JsonParser p, Class<T> valueType) throws IOException {\n        return (T) forType(valueType).readValue(p);\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public <T> T readValue(JsonParser p, TypeReference<?> valueTypeRef) throws IOException {\n        return (T) forType(valueTypeRef).readValue(p);\n    }\n\n    \n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(JsonParser p, ResolvedType valueType) throws IOException, JsonProcessingException {\n        return (T) forType((JavaType)valueType).readValue(p);\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(JsonParser p, JavaType valueType) throws IOException {\n        return (T) forType(valueType).readValue(p);\n    }\n\n    \n    @Override\n    public <T> Iterator<T> readValues(JsonParser p, Class<T> valueType) throws IOException {\n        return forType(valueType).readValues(p);\n    }\n\n    \n    @Override\n    public <T> Iterator<T> readValues(JsonParser p, TypeReference<?> valueTypeRef) throws IOException {\n        return forType(valueTypeRef).readValues(p);\n    }\n    \n    \n    @Override\n    public <T> Iterator<T> readValues(JsonParser p, ResolvedType valueType) throws IOException {\n        return readValues(p, (JavaType) valueType);\n    }\n\n    \n    public <T> Iterator<T> readValues(JsonParser p, JavaType valueType) throws IOException {\n        return forType(valueType).readValues(p);\n    }\n\n    \n\n    @Override\n    public JsonNode createArrayNode() {\n        return _config.getNodeFactory().arrayNode();\n    }\n\n    @Override\n    public JsonNode createObjectNode() {\n        return _config.getNodeFactory().objectNode();\n    }\n\n    @Override\n    public JsonParser treeAsTokens(TreeNode n) {\n        return new TreeTraversingParser((JsonNode) n, this);\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public <T extends TreeNode> T readTree(JsonParser p) throws IOException {\n        return (T) _bindAsTree(p);\n    }\n     \n    @Override\n    public void writeTree(JsonGenerator jgen, TreeNode rootNode) {\n        throw new UnsupportedOperationException();\n    }\n    \n    \n    \n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(InputStream src) throws IOException, JsonProcessingException {\n        if (_dataFormatReaders != null) {\n            return (T) _detectBindAndClose(_dataFormatReaders.findFormat(src), false);\n        }\n        \n        return (T) _bindAndClose(_considerFilter(_parserFactory.createParser(src), false));\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(Reader src) throws IOException, JsonProcessingException {\n        if (_dataFormatReaders != null) {\n            _reportUndetectableSource(src);\n        }\n\n        return (T) _bindAndClose(_considerFilter(_parserFactory.createParser(src), false));\n    }\n    \n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(String src) throws IOException, JsonProcessingException {\n        if (_dataFormatReaders != null) {\n            _reportUndetectableSource(src);\n        }\n        \n        return (T) _bindAndClose(_considerFilter(_parserFactory.createParser(src), false));\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(byte[] src) throws IOException, JsonProcessingException {\n        if (_dataFormatReaders != null) {\n            return (T) _detectBindAndClose(src, 0, src.length);\n        }\n        \n        return (T) _bindAndClose(_considerFilter(_parserFactory.createParser(src), false));\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(byte[] src, int offset, int length) throws IOException, JsonProcessingException {\n        if (_dataFormatReaders != null) {\n            return (T) _detectBindAndClose(src, offset, length);\n        }\n\n        return (T) _bindAndClose(_considerFilter(_parserFactory.createParser(src, offset, length),\n                false));\n    }\n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(File src) throws IOException, JsonProcessingException {\n        if (_dataFormatReaders != null) {\n            return (T) _detectBindAndClose(_dataFormatReaders.findFormat(_inputStream(src)), true);\n        }\n\n        return (T) _bindAndClose(_considerFilter(_parserFactory.createParser(src), false));\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(URL src) throws IOException, JsonProcessingException {\n        if (_dataFormatReaders != null) {\n            return (T) _detectBindAndClose(_dataFormatReaders.findFormat(_inputStream(src)), true);\n        }\n\n        return (T) _bindAndClose(_considerFilter(_parserFactory.createParser(src), false));\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(JsonNode src) throws IOException, JsonProcessingException {\n        if (_dataFormatReaders != null) {\n            _reportUndetectableSource(src);\n        }\n        \n        return (T) _bindAndClose(_considerFilter(treeAsTokens(src), false));\n    }\n    \n    \n    public JsonNode readTree(InputStream in) throws IOException, JsonProcessingException {\n        if (_dataFormatReaders != null) {\n            return _detectBindAndCloseAsTree(in);\n        }\n\n        return _bindAndCloseAsTree(_considerFilter(_parserFactory.createParser(in), false));\n    }\n    \n    \n    public JsonNode readTree(Reader r) throws IOException, JsonProcessingException {\n        if (_dataFormatReaders != null) {\n            _reportUndetectableSource(r);\n        }\n        \n        return _bindAndCloseAsTree(_considerFilter(_parserFactory.createParser(r), false));\n    }\n\n    \n    public JsonNode readTree(String json) throws IOException, JsonProcessingException {\n        if (_dataFormatReaders != null) {\n            _reportUndetectableSource(json);\n        }\n\n        return _bindAndCloseAsTree(_considerFilter(_parserFactory.createParser(json), false));\n    }\n\n    \n    \n    \n    public <T> MappingIterator<T> readValues(JsonParser p) throws IOException, JsonProcessingException {\n        DeserializationContext ctxt = createDeserializationContext(p);\n        \n        return _newIterator(p, ctxt, _findRootDeserializer(ctxt), false);\n    }\n    \n    \n    public <T> MappingIterator<T> readValues(InputStream src) throws IOException, JsonProcessingException {\n        if (_dataFormatReaders != null) {\n            return _detectBindAndReadValues(_dataFormatReaders.findFormat(src), false);\n        }\n        \n        return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), true));\n    }\n    \n    \n    @SuppressWarnings(\"resource\")\n    public <T> MappingIterator<T> readValues(Reader src) throws IOException, JsonProcessingException {\n        if (_dataFormatReaders != null) {\n            _reportUndetectableSource(src);\n        }\n        JsonParser p = _considerFilter(_parserFactory.createParser(src), true);\n        _initForMultiRead(p);\n        p.nextToken();\n        DeserializationContext ctxt = createDeserializationContext(p);\n        return _newIterator(p, ctxt, _findRootDeserializer(ctxt), true);\n    }\n    \n    \n    @SuppressWarnings(\"resource\")\n    public <T> MappingIterator<T> readValues(String json) throws IOException, JsonProcessingException {\n        if (_dataFormatReaders != null) {\n            _reportUndetectableSource(json);\n        }\n        JsonParser p = _considerFilter(_parserFactory.createParser(json), true);\n        _initForMultiRead(p);\n        p.nextToken();\n        DeserializationContext ctxt = createDeserializationContext(p);\n        return _newIterator(p, ctxt, _findRootDeserializer(ctxt), true);\n    }\n\n    \n    public <T> MappingIterator<T> readValues(byte[] src, int offset, int length) throws IOException, JsonProcessingException {\n        if (_dataFormatReaders != null) {\n            return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n        }\n        return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src, offset, length),\n                true));\n    }\n\n    \n    public final <T> MappingIterator<T> readValues(byte[] src) throws IOException, JsonProcessingException {\n        return readValues(src, 0, src.length);\n    }\n    \n    \n    public <T> MappingIterator<T> readValues(File src) throws IOException, JsonProcessingException {\n        if (_dataFormatReaders != null) {\n            return _detectBindAndReadValues(\n                    _dataFormatReaders.findFormat(_inputStream(src)), false);\n        }\n        return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), true));\n    }\n\n    \n    public <T> MappingIterator<T> readValues(URL src) throws IOException, JsonProcessingException {\n        if (_dataFormatReaders != null) {\n            return _detectBindAndReadValues(\n                    _dataFormatReaders.findFormat(_inputStream(src)), true);\n        }\n        return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), true));\n    }\n\n    \n\n    @Override\n    public <T> T treeToValue(TreeNode n, Class<T> valueType) throws JsonProcessingException {\n        try {\n            return readValue(treeAsTokens(n), valueType);\n        } catch (JsonProcessingException e) {\n            throw e;\n        } catch (IOException e) { \n            throw new IllegalArgumentException(e.getMessage(), e);\n        }\n    }    \n\n    @Override\n    public void writeValue(JsonGenerator gen, Object value) throws IOException, JsonProcessingException {\n        throw new UnsupportedOperationException(\"Not implemented for ObjectReader\");\n    }\n\n    \n    \n    \n    protected Object _bind(JsonParser p, Object valueToUpdate) throws IOException {\n        \n        Object result;\n        JsonToken t = _initForReading(p);\n        if (t == JsonToken.VALUE_NULL) {\n            if (valueToUpdate == null) {\n                DeserializationContext ctxt = createDeserializationContext(p);\n                result = _findRootDeserializer(ctxt).getNullValue(ctxt);\n            } else {\n                result = valueToUpdate;\n            }\n        } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {\n            result = valueToUpdate;\n        } else { \n            DeserializationContext ctxt = createDeserializationContext(p);\n            JsonDeserializer<Object> deser = _findRootDeserializer(ctxt);\n            if (_unwrapRoot) {\n                result = _unwrapAndDeserialize(p, ctxt, _valueType, deser);\n            } else {\n                if (valueToUpdate == null) {\n                    result = deser.deserialize(p, ctxt);\n                } else {\n                    deser.deserialize(p, ctxt, valueToUpdate);\n                    result = valueToUpdate;\n                }\n            }\n        }\n        \n        p.clearCurrentToken();\n        return result;\n    }\n    \n    \n    protected JsonParser _considerFilter(final JsonParser p, boolean multiValue) {\n        \n        \n        return ((_filter == null) || FilteringParserDelegate.class.isInstance(p))\n                ? p : new FilteringParserDelegate(p, _filter, false, multiValue);\n    }\n    \n    protected Object _bindAndClose(JsonParser p) throws IOException {\n        try {\n            Object result;\n            JsonToken t = _initForReading(p);\n            if (t == JsonToken.VALUE_NULL) {\n                if (_valueToUpdate == null) {\n                    DeserializationContext ctxt = createDeserializationContext(p);\n                    result = _findRootDeserializer(ctxt).getNullValue(ctxt);\n                } else {\n                    result = _valueToUpdate;\n                }\n            } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {\n                result = _valueToUpdate;\n            } else {\n                DeserializationContext ctxt = createDeserializationContext(p);\n                JsonDeserializer<Object> deser = _findRootDeserializer(ctxt);\n                if (_unwrapRoot) {\n                    result = _unwrapAndDeserialize(p, ctxt, _valueType, deser);\n                } else {\n                    if (_valueToUpdate == null) {\n                        result = deser.deserialize(p, ctxt);\n                    } else {\n                        deser.deserialize(p, ctxt, _valueToUpdate);\n                        result = _valueToUpdate;                    \n                    }\n                }\n            }\n            return result;\n        } finally {\n            try {\n                p.close();\n            } catch (IOException ioe) { }\n        }\n    }\n\n    protected JsonNode _bindAndCloseAsTree(JsonParser p) throws IOException {\n        try {\n            return _bindAsTree(p);\n        } finally {\n            try {\n                p.close();\n            } catch (IOException ioe) { }\n        }\n    }\n    \n    protected JsonNode _bindAsTree(JsonParser p) throws IOException {\n        JsonNode result;\n        JsonToken t = _initForReading(p);\n        if (t == JsonToken.VALUE_NULL || t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {\n            result = NullNode.instance;\n        } else {\n            DeserializationContext ctxt = createDeserializationContext(p);\n            JsonDeserializer<Object> deser = _findTreeDeserializer(ctxt);\n            if (_unwrapRoot) {\n                result = (JsonNode) _unwrapAndDeserialize(p, ctxt, JSON_NODE_TYPE, deser);\n            } else {\n                result = (JsonNode) deser.deserialize(p, ctxt);\n            }\n        }\n        \n        p.clearCurrentToken();\n        return result;\n    }\n    \n    \n    protected <T> MappingIterator<T> _bindAndReadValues(JsonParser p) throws IOException {\n        _initForMultiRead(p);\n        p.nextToken();\n        DeserializationContext ctxt = createDeserializationContext(p);\n        return _newIterator(p, ctxt, _findRootDeserializer(ctxt), true);\n    }\n\n    protected Object _unwrapAndDeserialize(JsonParser p, DeserializationContext ctxt, JavaType rootType, JsonDeserializer<Object> deser) throws IOException {\n        PropertyName expRootName = _config.findRootName(rootType);\n        \n        String expSimpleName = expRootName.getSimpleName();\n\n        if (p.getCurrentToken() != JsonToken.START_OBJECT) {\n            throw JsonMappingException.from(p, \"Current token not START_OBJECT (needed to unwrap root name '\"\n                    +expSimpleName+\"'), but \"+p.getCurrentToken());\n        }\n        if (p.nextToken() != JsonToken.FIELD_NAME) {\n            throw JsonMappingException.from(p, \"Current token not FIELD_NAME (to contain expected root name '\"\n                    +expSimpleName+\"'), but \"+p.getCurrentToken());\n        }\n        String actualName = p.getCurrentName();\n        if (!expSimpleName.equals(actualName)) {\n            throw JsonMappingException.from(p, \"Root name '\"+actualName+\"' does not match expected ('\"\n                    +expSimpleName+\"') for type \"+rootType);\n        }\n        \n        p.nextToken();\n        Object result;\n        if (_valueToUpdate == null) {\n            result = deser.deserialize(p, ctxt);\n        } else {\n            deser.deserialize(p, ctxt, _valueToUpdate);\n            result = _valueToUpdate;                    \n        }\n        \n        if (p.nextToken() != JsonToken.END_OBJECT) {\n            throw JsonMappingException.from(p, \"Current token not END_OBJECT (to match wrapper object with root name '\"\n                    +expSimpleName+\"'), but \"+p.getCurrentToken());\n        }\n        return result;\n    }\n\n    \n    \n    @SuppressWarnings(\"resource\")\n    protected Object _detectBindAndClose(byte[] src, int offset, int length) throws IOException {\n        DataFormatReaders.Match match = _dataFormatReaders.findFormat(src, offset, length);\n        if (!match.hasMatch()) {\n            _reportUnkownFormat(_dataFormatReaders, match);\n        }\n        JsonParser p = match.createParserWithMatch();\n        return match.getReader()._bindAndClose(p);\n    }\n\n    @SuppressWarnings(\"resource\")\n    protected Object _detectBindAndClose(DataFormatReaders.Match match, boolean forceClosing) throws IOException {\n        if (!match.hasMatch()) {\n            _reportUnkownFormat(_dataFormatReaders, match);\n        }\n        JsonParser p = match.createParserWithMatch();\n        \n        \n        if (forceClosing) {\n            p.enable(JsonParser.Feature.AUTO_CLOSE_SOURCE);\n        }\n        \n        return match.getReader()._bindAndClose(p);\n    }\n\n    @SuppressWarnings(\"resource\")\n    protected <T> MappingIterator<T> _detectBindAndReadValues(DataFormatReaders.Match match, boolean forceClosing) throws IOException, JsonProcessingException {\n        if (!match.hasMatch()) {\n            _reportUnkownFormat(_dataFormatReaders, match);\n        }\n        JsonParser p = match.createParserWithMatch();\n        \n        \n        if (forceClosing) {\n            p.enable(JsonParser.Feature.AUTO_CLOSE_SOURCE);\n        }\n        \n        return match.getReader()._bindAndReadValues(p);\n    }\n    \n    @SuppressWarnings(\"resource\")\n    protected JsonNode _detectBindAndCloseAsTree(InputStream in) throws IOException {\n        DataFormatReaders.Match match = _dataFormatReaders.findFormat(in);\n        if (!match.hasMatch()) {\n            _reportUnkownFormat(_dataFormatReaders, match);\n        }\n        JsonParser p = match.createParserWithMatch();\n        p.enable(JsonParser.Feature.AUTO_CLOSE_SOURCE);\n        return match.getReader()._bindAndCloseAsTree(p);\n    }\n    \n    \n    protected void _reportUnkownFormat(DataFormatReaders detector, DataFormatReaders.Match match) throws JsonProcessingException {\n        \n        throw new JsonParseException(null, \"Can not detect format from input, does not look like any of detectable formats \"\n                +detector.toString());\n    }\n\n    \n\n    \n    protected void _verifySchemaType(FormatSchema schema) {\n        if (schema != null) {\n            if (!_parserFactory.canUseSchema(schema)) {\n                    throw new IllegalArgumentException(\"Can not use FormatSchema of type \"+schema.getClass().getName()\n                            +\" for format \"+_parserFactory.getFormatName());\n            }\n        }\n    }\n\n    \n    protected DefaultDeserializationContext createDeserializationContext(JsonParser p) {\n        return _context.createInstance(_config, p, _injectableValues);\n    }\n\n    protected void _reportUndetectableSource(Object src) throws JsonProcessingException {\n        \n        throw new JsonParseException(null, \"Can not use source of type \"\n                +src.getClass().getName()+\" with format auto-detection: must be byte- not char-based\");\n    }\n\n    protected InputStream _inputStream(URL src) throws IOException {\n        return src.openStream();\n    }\n\n    protected InputStream _inputStream(File f) throws IOException {\n        return new FileInputStream(f);\n    }\n\n    \n    \n    \n    protected JsonDeserializer<Object> _findRootDeserializer(DeserializationContext ctxt) throws JsonMappingException {\n        if (_rootDeserializer != null) {\n            return _rootDeserializer;\n        }\n\n        \n        JavaType t = _valueType;\n        if (t == null) {\n            throw JsonMappingException.from(ctxt, \"No value type configured for ObjectReader\");\n        }\n        \n        \n        JsonDeserializer<Object> deser = _rootDeserializers.get(t);\n        if (deser != null) {\n            return deser;\n        }\n        \n        deser = ctxt.findRootValueDeserializer(t);\n        if (deser == null) { \n            throw JsonMappingException.from(ctxt, \"Can not find a deserializer for type \"+t);\n        }\n        _rootDeserializers.put(t, deser);\n        return deser;\n    }\n\n    \n    protected JsonDeserializer<Object> _findTreeDeserializer(DeserializationContext ctxt) throws JsonMappingException {\n        JsonDeserializer<Object> deser = _rootDeserializers.get(JSON_NODE_TYPE);\n        if (deser == null) {\n            \n            deser = ctxt.findRootValueDeserializer(JSON_NODE_TYPE);\n            if (deser == null) { \n                throw JsonMappingException.from(ctxt,\n                        \"Can not find a deserializer for type \"+JSON_NODE_TYPE);\n            }\n            _rootDeserializers.put(JSON_NODE_TYPE, deser);\n        }\n        return deser;\n    }\n\n    \n    protected JsonDeserializer<Object> _prefetchRootDeserializer(JavaType valueType) {\n        if (valueType == null || !_config.isEnabled(DeserializationFeature.EAGER_DESERIALIZER_FETCH)) {\n            return null;\n        }\n        \n        JsonDeserializer<Object> deser = _rootDeserializers.get(valueType);\n        if (deser == null) {\n            try {\n                \n                DeserializationContext ctxt = createDeserializationContext(null);\n                deser = ctxt.findRootValueDeserializer(valueType);\n                if (deser != null) {\n                    _rootDeserializers.put(valueType, deser);\n                }\n                return deser;\n            } catch (JsonProcessingException e) {\n                \n            }\n        }\n        return deser;\n    }\n\n    \n    public ObjectReader at(final String value) {\n        return new ObjectReader(this, new JsonPointerBasedFilter(value));\n    }\n\n    \n    public ObjectReader at(final JsonPointer pointer) {\n        return new ObjectReader(this, new JsonPointerBasedFilter(pointer));\n    }\n}\n",
      "buggy_signatures": [
        "protected ObjectReader(ObjectMapper mapper, DeserializationConfig config, JavaType valueType, Object valueToUpdate, FormatSchema schema, InjectableValues injectableValues)",
        "protected ObjectReader(ObjectReader base, DeserializationConfig config, JavaType valueType, JsonDeserializer<Object> rootDeser, Object valueToUpdate, FormatSchema schema, InjectableValues injectableValues, DataFormatReaders dataFormatReaders)",
        "protected ObjectReader(ObjectReader base, DeserializationConfig config)",
        "protected ObjectReader(ObjectReader base, JsonFactory f)",
        "protected ObjectReader(ObjectReader base, TokenFilter filter)",
        "public Version version()",
        "protected ObjectReader _new(ObjectReader base, JsonFactory f)",
        "protected ObjectReader _new(ObjectReader base, DeserializationConfig config)",
        "protected ObjectReader _new(ObjectReader base, DeserializationConfig config, JavaType valueType, JsonDeserializer<Object> rootDeser, Object valueToUpdate, FormatSchema schema, InjectableValues injectableValues, DataFormatReaders dataFormatReaders)",
        "protected <T> MappingIterator<T> _newIterator(JsonParser p, DeserializationContext ctxt, JsonDeserializer<?> deser, boolean parserManaged)",
        "protected JsonToken _initForReading(JsonParser p) throws IOException",
        "protected void _initForMultiRead(JsonParser p) throws IOException",
        "public ObjectReader with(DeserializationFeature feature)",
        "public ObjectReader with(DeserializationFeature first, DeserializationFeature... other)",
        "public ObjectReader withFeatures(DeserializationFeature... features)",
        "public ObjectReader without(DeserializationFeature feature)",
        "public ObjectReader without(DeserializationFeature first, DeserializationFeature... other)",
        "public ObjectReader withoutFeatures(DeserializationFeature... features)",
        "public ObjectReader with(JsonParser.Feature feature)",
        "public ObjectReader withFeatures(JsonParser.Feature... features)",
        "public ObjectReader without(JsonParser.Feature feature)",
        "public ObjectReader withoutFeatures(JsonParser.Feature... features)",
        "public ObjectReader with(FormatFeature feature)",
        "public ObjectReader withFeatures(FormatFeature... features)",
        "public ObjectReader without(FormatFeature feature)",
        "public ObjectReader withoutFeatures(FormatFeature... features)",
        "public ObjectReader with(DeserializationConfig config)",
        "public ObjectReader with(InjectableValues injectableValues)",
        "public ObjectReader with(JsonNodeFactory f)",
        "public ObjectReader with(JsonFactory f)",
        "public ObjectReader withRootName(String rootName)",
        "public ObjectReader withRootName(PropertyName rootName)",
        "public ObjectReader withoutRootName()",
        "public ObjectReader with(FormatSchema schema)",
        "public ObjectReader forType(JavaType valueType)",
        "public ObjectReader forType(Class<?> valueType)",
        "public ObjectReader forType(TypeReference<?> valueTypeRef)",
        "public ObjectReader withType(JavaType valueType)",
        "public ObjectReader withType(Class<?> valueType)",
        "public ObjectReader withType(java.lang.reflect.Type valueType)",
        "public ObjectReader withType(TypeReference<?> valueTypeRef)",
        "public ObjectReader withValueToUpdate(Object value)",
        "public ObjectReader withView(Class<?> activeView)",
        "public ObjectReader with(Locale l)",
        "public ObjectReader with(TimeZone tz)",
        "public ObjectReader withHandler(DeserializationProblemHandler h)",
        "public ObjectReader with(Base64Variant defaultBase64)",
        "public ObjectReader withFormatDetection(ObjectReader... readers)",
        "public ObjectReader withFormatDetection(DataFormatReaders readers)",
        "public ObjectReader with(ContextAttributes attrs)",
        "public ObjectReader withAttributes(Map<?,?> attrs)",
        "public ObjectReader withAttribute(Object key, Object value)",
        "public ObjectReader withoutAttribute(Object key)",
        "protected ObjectReader _with(DeserializationConfig newConfig)",
        "public boolean isEnabled(DeserializationFeature f)",
        "public boolean isEnabled(MapperFeature f)",
        "public boolean isEnabled(JsonParser.Feature f)",
        "public DeserializationConfig getConfig()",
        "public JsonFactory getFactory()",
        "public TypeFactory getTypeFactory()",
        "public ContextAttributes getAttributes()",
        "public InjectableValues getInjectableValues()",
        "public <T> T readValue(JsonParser p) throws IOException",
        "public <T> T readValue(JsonParser p, Class<T> valueType) throws IOException",
        "public <T> T readValue(JsonParser p, TypeReference<?> valueTypeRef) throws IOException",
        "public <T> T readValue(JsonParser p, ResolvedType valueType) throws IOException, JsonProcessingException",
        "public <T> T readValue(JsonParser p, JavaType valueType) throws IOException",
        "public <T> Iterator<T> readValues(JsonParser p, Class<T> valueType) throws IOException",
        "public <T> Iterator<T> readValues(JsonParser p, TypeReference<?> valueTypeRef) throws IOException",
        "public <T> Iterator<T> readValues(JsonParser p, ResolvedType valueType) throws IOException",
        "public <T> Iterator<T> readValues(JsonParser p, JavaType valueType) throws IOException",
        "public JsonNode createArrayNode()",
        "public JsonNode createObjectNode()",
        "public JsonParser treeAsTokens(TreeNode n)",
        "public <T extends TreeNode> T readTree(JsonParser p) throws IOException",
        "public void writeTree(JsonGenerator jgen, TreeNode rootNode)",
        "public <T> T readValue(InputStream src) throws IOException, JsonProcessingException",
        "public <T> T readValue(Reader src) throws IOException, JsonProcessingException",
        "public <T> T readValue(String src) throws IOException, JsonProcessingException",
        "public <T> T readValue(byte[] src) throws IOException, JsonProcessingException",
        "public <T> T readValue(byte[] src, int offset, int length) throws IOException, JsonProcessingException",
        "public <T> T readValue(File src) throws IOException, JsonProcessingException",
        "public <T> T readValue(URL src) throws IOException, JsonProcessingException",
        "public <T> T readValue(JsonNode src) throws IOException, JsonProcessingException",
        "public JsonNode readTree(InputStream in) throws IOException, JsonProcessingException",
        "public JsonNode readTree(Reader r) throws IOException, JsonProcessingException",
        "public JsonNode readTree(String json) throws IOException, JsonProcessingException",
        "public <T> MappingIterator<T> readValues(JsonParser p) throws IOException, JsonProcessingException",
        "public <T> MappingIterator<T> readValues(InputStream src) throws IOException, JsonProcessingException",
        "public <T> MappingIterator<T> readValues(Reader src) throws IOException, JsonProcessingException",
        "public <T> MappingIterator<T> readValues(String json) throws IOException, JsonProcessingException",
        "public <T> MappingIterator<T> readValues(byte[] src, int offset, int length) throws IOException, JsonProcessingException",
        "public final <T> MappingIterator<T> readValues(byte[] src) throws IOException, JsonProcessingException",
        "public <T> MappingIterator<T> readValues(File src) throws IOException, JsonProcessingException",
        "public <T> MappingIterator<T> readValues(URL src) throws IOException, JsonProcessingException",
        "public <T> T treeToValue(TreeNode n, Class<T> valueType) throws JsonProcessingException",
        "public void writeValue(JsonGenerator gen, Object value) throws IOException, JsonProcessingException",
        "protected Object _bind(JsonParser p, Object valueToUpdate) throws IOException",
        "protected JsonParser _considerFilter(final JsonParser p, boolean multiValue)",
        "protected Object _bindAndClose(JsonParser p) throws IOException",
        "protected JsonNode _bindAndCloseAsTree(JsonParser p) throws IOException",
        "protected JsonNode _bindAsTree(JsonParser p) throws IOException",
        "protected <T> MappingIterator<T> _bindAndReadValues(JsonParser p) throws IOException",
        "protected Object _unwrapAndDeserialize(JsonParser p, DeserializationContext ctxt, JavaType rootType, JsonDeserializer<Object> deser) throws IOException",
        "protected Object _detectBindAndClose(byte[] src, int offset, int length) throws IOException",
        "protected Object _detectBindAndClose(DataFormatReaders.Match match, boolean forceClosing) throws IOException",
        "protected <T> MappingIterator<T> _detectBindAndReadValues(DataFormatReaders.Match match, boolean forceClosing) throws IOException, JsonProcessingException",
        "protected JsonNode _detectBindAndCloseAsTree(InputStream in) throws IOException",
        "protected void _reportUnkownFormat(DataFormatReaders detector, DataFormatReaders.Match match) throws JsonProcessingException",
        "protected void _verifySchemaType(FormatSchema schema)",
        "protected DefaultDeserializationContext createDeserializationContext(JsonParser p)",
        "protected void _reportUndetectableSource(Object src) throws JsonProcessingException",
        "protected InputStream _inputStream(URL src) throws IOException",
        "protected InputStream _inputStream(File f) throws IOException",
        "protected JsonDeserializer<Object> _findRootDeserializer(DeserializationContext ctxt) throws JsonMappingException",
        "protected JsonDeserializer<Object> _findTreeDeserializer(DeserializationContext ctxt) throws JsonMappingException",
        "protected JsonDeserializer<Object> _prefetchRootDeserializer(JavaType valueType)",
        "public ObjectReader at(final String value)",
        "public ObjectReader at(final JsonPointer pointer)"
      ],
      "fixed_signatures": [
        "protected ObjectReader(ObjectMapper mapper, DeserializationConfig config, JavaType valueType, Object valueToUpdate, FormatSchema schema, InjectableValues injectableValues)",
        "protected ObjectReader(ObjectReader base, DeserializationConfig config, JavaType valueType, JsonDeserializer<Object> rootDeser, Object valueToUpdate, FormatSchema schema, InjectableValues injectableValues, DataFormatReaders dataFormatReaders)",
        "protected ObjectReader(ObjectReader base, DeserializationConfig config)",
        "protected ObjectReader(ObjectReader base, JsonFactory f)",
        "protected ObjectReader(ObjectReader base, TokenFilter filter)",
        "public Version version()",
        "protected ObjectReader _new(ObjectReader base, JsonFactory f)",
        "protected ObjectReader _new(ObjectReader base, DeserializationConfig config)",
        "protected ObjectReader _new(ObjectReader base, DeserializationConfig config, JavaType valueType, JsonDeserializer<Object> rootDeser, Object valueToUpdate, FormatSchema schema, InjectableValues injectableValues, DataFormatReaders dataFormatReaders)",
        "protected <T> MappingIterator<T> _newIterator(JsonParser p, DeserializationContext ctxt, JsonDeserializer<?> deser, boolean parserManaged)",
        "protected JsonToken _initForReading(JsonParser p) throws IOException",
        "protected void _initForMultiRead(JsonParser p) throws IOException",
        "public ObjectReader with(DeserializationFeature feature)",
        "public ObjectReader with(DeserializationFeature first, DeserializationFeature... other)",
        "public ObjectReader withFeatures(DeserializationFeature... features)",
        "public ObjectReader without(DeserializationFeature feature)",
        "public ObjectReader without(DeserializationFeature first, DeserializationFeature... other)",
        "public ObjectReader withoutFeatures(DeserializationFeature... features)",
        "public ObjectReader with(JsonParser.Feature feature)",
        "public ObjectReader withFeatures(JsonParser.Feature... features)",
        "public ObjectReader without(JsonParser.Feature feature)",
        "public ObjectReader withoutFeatures(JsonParser.Feature... features)",
        "public ObjectReader with(FormatFeature feature)",
        "public ObjectReader withFeatures(FormatFeature... features)",
        "public ObjectReader without(FormatFeature feature)",
        "public ObjectReader withoutFeatures(FormatFeature... features)",
        "public ObjectReader with(DeserializationConfig config)",
        "public ObjectReader with(InjectableValues injectableValues)",
        "public ObjectReader with(JsonNodeFactory f)",
        "public ObjectReader with(JsonFactory f)",
        "public ObjectReader withRootName(String rootName)",
        "public ObjectReader withRootName(PropertyName rootName)",
        "public ObjectReader withoutRootName()",
        "public ObjectReader with(FormatSchema schema)",
        "public ObjectReader forType(JavaType valueType)",
        "public ObjectReader forType(Class<?> valueType)",
        "public ObjectReader forType(TypeReference<?> valueTypeRef)",
        "public ObjectReader withType(JavaType valueType)",
        "public ObjectReader withType(Class<?> valueType)",
        "public ObjectReader withType(java.lang.reflect.Type valueType)",
        "public ObjectReader withType(TypeReference<?> valueTypeRef)",
        "public ObjectReader withValueToUpdate(Object value)",
        "public ObjectReader withView(Class<?> activeView)",
        "public ObjectReader with(Locale l)",
        "public ObjectReader with(TimeZone tz)",
        "public ObjectReader withHandler(DeserializationProblemHandler h)",
        "public ObjectReader with(Base64Variant defaultBase64)",
        "public ObjectReader withFormatDetection(ObjectReader... readers)",
        "public ObjectReader withFormatDetection(DataFormatReaders readers)",
        "public ObjectReader with(ContextAttributes attrs)",
        "public ObjectReader withAttributes(Map<?,?> attrs)",
        "public ObjectReader withAttribute(Object key, Object value)",
        "public ObjectReader withoutAttribute(Object key)",
        "protected ObjectReader _with(DeserializationConfig newConfig)",
        "public boolean isEnabled(DeserializationFeature f)",
        "public boolean isEnabled(MapperFeature f)",
        "public boolean isEnabled(JsonParser.Feature f)",
        "public DeserializationConfig getConfig()",
        "public JsonFactory getFactory()",
        "public TypeFactory getTypeFactory()",
        "public ContextAttributes getAttributes()",
        "public InjectableValues getInjectableValues()",
        "public <T> T readValue(JsonParser p) throws IOException",
        "public <T> T readValue(JsonParser p, Class<T> valueType) throws IOException",
        "public <T> T readValue(JsonParser p, TypeReference<?> valueTypeRef) throws IOException",
        "public <T> T readValue(JsonParser p, ResolvedType valueType) throws IOException, JsonProcessingException",
        "public <T> T readValue(JsonParser p, JavaType valueType) throws IOException",
        "public <T> Iterator<T> readValues(JsonParser p, Class<T> valueType) throws IOException",
        "public <T> Iterator<T> readValues(JsonParser p, TypeReference<?> valueTypeRef) throws IOException",
        "public <T> Iterator<T> readValues(JsonParser p, ResolvedType valueType) throws IOException",
        "public <T> Iterator<T> readValues(JsonParser p, JavaType valueType) throws IOException",
        "public JsonNode createArrayNode()",
        "public JsonNode createObjectNode()",
        "public JsonParser treeAsTokens(TreeNode n)",
        "public <T extends TreeNode> T readTree(JsonParser p) throws IOException",
        "public void writeTree(JsonGenerator jgen, TreeNode rootNode)",
        "public <T> T readValue(InputStream src) throws IOException, JsonProcessingException",
        "public <T> T readValue(Reader src) throws IOException, JsonProcessingException",
        "public <T> T readValue(String src) throws IOException, JsonProcessingException",
        "public <T> T readValue(byte[] src) throws IOException, JsonProcessingException",
        "public <T> T readValue(byte[] src, int offset, int length) throws IOException, JsonProcessingException",
        "public <T> T readValue(File src) throws IOException, JsonProcessingException",
        "public <T> T readValue(URL src) throws IOException, JsonProcessingException",
        "public <T> T readValue(JsonNode src) throws IOException, JsonProcessingException",
        "public JsonNode readTree(InputStream in) throws IOException, JsonProcessingException",
        "public JsonNode readTree(Reader r) throws IOException, JsonProcessingException",
        "public JsonNode readTree(String json) throws IOException, JsonProcessingException",
        "public <T> MappingIterator<T> readValues(JsonParser p) throws IOException, JsonProcessingException",
        "public <T> MappingIterator<T> readValues(InputStream src) throws IOException, JsonProcessingException",
        "public <T> MappingIterator<T> readValues(Reader src) throws IOException, JsonProcessingException",
        "public <T> MappingIterator<T> readValues(String json) throws IOException, JsonProcessingException",
        "public <T> MappingIterator<T> readValues(byte[] src, int offset, int length) throws IOException, JsonProcessingException",
        "public final <T> MappingIterator<T> readValues(byte[] src) throws IOException, JsonProcessingException",
        "public <T> MappingIterator<T> readValues(File src) throws IOException, JsonProcessingException",
        "public <T> MappingIterator<T> readValues(URL src) throws IOException, JsonProcessingException",
        "public <T> T treeToValue(TreeNode n, Class<T> valueType) throws JsonProcessingException",
        "public void writeValue(JsonGenerator gen, Object value) throws IOException, JsonProcessingException",
        "protected Object _bind(JsonParser p, Object valueToUpdate) throws IOException",
        "protected JsonParser _considerFilter(final JsonParser p, boolean multiValue)",
        "protected Object _bindAndClose(JsonParser p) throws IOException",
        "protected JsonNode _bindAndCloseAsTree(JsonParser p) throws IOException",
        "protected JsonNode _bindAsTree(JsonParser p) throws IOException",
        "protected <T> MappingIterator<T> _bindAndReadValues(JsonParser p) throws IOException",
        "protected Object _unwrapAndDeserialize(JsonParser p, DeserializationContext ctxt, JavaType rootType, JsonDeserializer<Object> deser) throws IOException",
        "protected Object _detectBindAndClose(byte[] src, int offset, int length) throws IOException",
        "protected Object _detectBindAndClose(DataFormatReaders.Match match, boolean forceClosing) throws IOException",
        "protected <T> MappingIterator<T> _detectBindAndReadValues(DataFormatReaders.Match match, boolean forceClosing) throws IOException, JsonProcessingException",
        "protected JsonNode _detectBindAndCloseAsTree(InputStream in) throws IOException",
        "protected void _reportUnkownFormat(DataFormatReaders detector, DataFormatReaders.Match match) throws JsonProcessingException",
        "protected void _verifySchemaType(FormatSchema schema)",
        "protected DefaultDeserializationContext createDeserializationContext(JsonParser p)",
        "protected void _reportUndetectableSource(Object src) throws JsonProcessingException",
        "protected InputStream _inputStream(URL src) throws IOException",
        "protected InputStream _inputStream(File f) throws IOException",
        "protected JsonDeserializer<Object> _findRootDeserializer(DeserializationContext ctxt) throws JsonMappingException",
        "protected JsonDeserializer<Object> _findTreeDeserializer(DeserializationContext ctxt) throws JsonMappingException",
        "protected JsonDeserializer<Object> _prefetchRootDeserializer(JavaType valueType)",
        "public ObjectReader at(final String value)",
        "public ObjectReader at(final JsonPointer pointer)"
      ],
      "methods": [
        {
          "buggy_method": "  public <T> MappingIterator<T> readValues(byte[] src, int offset, int length) throws IOException, JsonProcessingException {\n  if (_dataFormatReaders != null) {\n  return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n  }\n  return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n  true));\n  }",
          "fixed_method": "  public <T> MappingIterator<T> readValues(byte[] src, int offset, int length) throws IOException, JsonProcessingException {\n  if (_dataFormatReaders != null) {\n  return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n  }\n  return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src, offset, length),\n  true));\n  }",
          "diff": [
            "@@ -1438,7 +1438,7 @@",
            "         if (_dataFormatReaders != null) {\n",
            "             return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n",
            "         }\n",
            "-        return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n",
            "+        return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src, offset, length),\n",
            "                 true));\n",
            "     }\n",
            " \n"
          ],
          "changed_lines": 2
        }
      ]
    }
  ]
}
