{
  "bug_id": "17",
  "failed_tests": {
    "com.fasterxml.jackson.core.json.RawValueWithSurrogatesTest": [
      {
        "methodName": "testRawWithSurrogatesString",
        "error": "com.fasterxml.jackson.core.JsonGenerationException",
        "message": "Split surrogate on writeRaw() input (last character)",
        "fail_line": "        _testRawWithSurrogatesString(false);",
        "test_source": "  public void testRawWithSurrogatesString() throws Exception {\n  _testRawWithSurrogatesString(false);\n  }",
        "stack": [
          "JsonGenerator._reportError line 1723, UTF8JsonGenerator._outputRawMultiByteChar line 1887, UTF8JsonGenerator._writeSegmentedRaw line 658, UTF8JsonGenerator.writeRaw line 573, UTF8JsonGenerator.writeRaw line 536, GeneratorBase.writeRawValue line 299, RawValueWithSurrogatesTest._testRawWithSurrogatesString line 82, RawValueWithSurrogatesTest.testRawWithSurrogatesString line 54"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "com/fasterxml/jackson/core/json/UTF8JsonGenerator.java",
      "buggy_full_code": "package com.fasterxml.jackson.core.json;\n\nimport java.io.*;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.io.*;\n\npublic class UTF8JsonGenerator extends JsonGeneratorImpl { private final static byte BYTE_u = (byte) 'u'; private final static byte BYTE_0 = (byte) '0'; private final static byte BYTE_LBRACKET = (byte) '['; private final static byte BYTE_RBRACKET = (byte) ']'; private final static byte BYTE_LCURLY = (byte) ' {';\n    private final static byte BYTE_RCURLY = (byte) '}'; private final static byte BYTE_BACKSLASH = (byte) '\\\\'; private final static byte BYTE_COMMA = (byte) ','; private final static byte BYTE_COLON = (byte) ':'; private final static byte BYTE_QUOTE = (byte) '\"'; private final static int MAX_BYTES_TO_BUFFER = 512; private final static byte[] HEX_CHARS = CharTypes.copyHexBytes(); private final static byte[] NULL_BYTES = { 'n', 'u', 'l', 'l' };\n    private final static byte[] TRUE_BYTES = { 't', 'r', 'u', 'e' }; private final static byte[] FALSE_BYTES = { 'f', 'a', 'l', 's', 'e' }; final protected OutputStream _outputStream; protected byte[] _outputBuffer; protected int _outputTail; protected final int _outputEnd; protected final int _outputMaxContiguous; protected char[] _charBuffer; protected final int _charBufferLength; protected byte[] _entityBuffer; protected boolean _bufferRecyclable; public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out) {\n        super(ctxt, features, codec);\n        _outputStream = out;\n        _bufferRecyclable = true;\n        _outputBuffer = ctxt.allocWriteEncodingBuffer();\n        _outputEnd = _outputBuffer.length;\n\n        \n        _outputMaxContiguous = _outputEnd >> 3;\n        _charBuffer = ctxt.allocConcatBuffer();\n        _charBufferLength = _charBuffer.length;\n\n        \n        if (isEnabled(Feature.ESCAPE_NON_ASCII)) {\n            setHighestNonEscapedChar(127);\n        }\n    }\n    \n    public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable) {\n        \n        super(ctxt, features, codec);\n        _outputStream = out;\n        _bufferRecyclable = bufferRecyclable;\n        _outputTail = outputOffset;\n        _outputBuffer = outputBuffer;\n        _outputEnd = _outputBuffer.length;\n        \n        _outputMaxContiguous = (_outputEnd >> 3);\n        _charBuffer = ctxt.allocConcatBuffer();\n        _charBufferLength = _charBuffer.length;\n    }\n\n    \n    \n    @Override\n    public Object getOutputTarget() {\n        return _outputStream;\n    }\n\n    @Override\n    public int getOutputBuffered() {\n        \n        return _outputTail;\n    }\n\n    \n\n    @Override\n    public void writeFieldName(String name) throws IOException {\n        if (_cfgPrettyPrinter != null) {\n            _writePPFieldName(name);\n            return;\n        }\n        final int status = _writeContext.writeFieldName(name);\n        if (status == JsonWriteContext.STATUS_EXPECT_VALUE) {\n            _reportError(\"Can not write a field name, expecting a value\");\n        }\n        if (status == JsonWriteContext.STATUS_OK_AFTER_COMMA) { \n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_COMMA;\n        }\n        \n        if (_cfgUnqNames) {\n            _writeStringSegments(name, false);\n            return;\n        }\n        final int len = name.length();\n        \n        if (len > _charBufferLength) { \n            _writeStringSegments(name, true);\n            return;\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        \n        if (len <= _outputMaxContiguous) {\n            if ((_outputTail + len) > _outputEnd) { \n                _flushBuffer();\n            }\n            _writeStringSegment(name, 0, len);\n        } else {\n            _writeStringSegments(name, 0, len);\n        }\n        \n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n    \n    @Override\n    public void writeFieldName(SerializableString name) throws IOException {\n        if (_cfgPrettyPrinter != null) {\n            _writePPFieldName(name);\n            return;\n        }\n        final int status = _writeContext.writeFieldName(name.getValue());\n        if (status == JsonWriteContext.STATUS_EXPECT_VALUE) {\n            _reportError(\"Can not write a field name, expecting a value\");\n        }\n        if (status == JsonWriteContext.STATUS_OK_AFTER_COMMA) {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_COMMA;\n        }\n        if (_cfgUnqNames) {\n            _writeUnq(name);\n            return;\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        int len = name.appendQuotedUTF8(_outputBuffer, _outputTail);\n        if (len < 0) { \n            _writeBytes(name.asQuotedUTF8());\n        } else {\n            _outputTail += len;\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }    \n\n    private final void _writeUnq(SerializableString name) throws IOException {\n        int len = name.appendQuotedUTF8(_outputBuffer, _outputTail);\n        if (len < 0) {\n            _writeBytes(name.asQuotedUTF8());\n        } else {\n            _outputTail += len;\n        }\n    }\n    \n    \n\n    @Override\n    public final void writeStartArray() throws IOException {\n        _verifyValueWrite(\"start an array\");\n        _writeContext = _writeContext.createChildArrayContext();\n        if (_cfgPrettyPrinter != null) {\n            _cfgPrettyPrinter.writeStartArray(this);\n        } else {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_LBRACKET;\n        }\n    }\n\n    @Override\n    public final void writeEndArray() throws IOException {\n        if (!_writeContext.inArray()) {\n            _reportError(\"Current context not an ARRAY but \"+_writeContext.getTypeDesc());\n        }\n        if (_cfgPrettyPrinter != null) {\n            _cfgPrettyPrinter.writeEndArray(this, _writeContext.getEntryCount());\n        } else {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_RBRACKET;\n        }\n        _writeContext = _writeContext.clearAndGetParent();\n    }\n\n    @Override\n    public final void writeStartObject() throws IOException {\n        _verifyValueWrite(\"start an object\");\n        _writeContext = _writeContext.createChildObjectContext();\n        if (_cfgPrettyPrinter != null) {\n            _cfgPrettyPrinter.writeStartObject(this);\n        } else {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_LCURLY;\n        }\n    }\n\n    @Override\n    public final void writeEndObject() throws IOException {\n        if (!_writeContext.inObject()) {\n            _reportError(\"Current context not an object but \"+_writeContext.getTypeDesc());\n        }\n        if (_cfgPrettyPrinter != null) {\n            _cfgPrettyPrinter.writeEndObject(this, _writeContext.getEntryCount());\n        } else {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_RCURLY;\n        }\n        _writeContext = _writeContext.clearAndGetParent();\n    }\n\n    \n    protected final void _writePPFieldName(String name) throws IOException {\n        int status = _writeContext.writeFieldName(name);\n        if (status == JsonWriteContext.STATUS_EXPECT_VALUE) {\n            _reportError(\"Can not write a field name, expecting a value\");\n        }\n        if ((status == JsonWriteContext.STATUS_OK_AFTER_COMMA)) {\n            _cfgPrettyPrinter.writeObjectEntrySeparator(this);\n        } else {\n            _cfgPrettyPrinter.beforeObjectEntries(this);\n        }\n        if (_cfgUnqNames) {\n            _writeStringSegments(name, false);\n            return;\n        }\n        final int len = name.length();\n        if (len > _charBufferLength) {\n            _writeStringSegments(name, true);\n            return;\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        name.getChars(0, len, _charBuffer, 0);\n        \n        if (len <= _outputMaxContiguous) {\n            if ((_outputTail + len) > _outputEnd) { \n                _flushBuffer();\n            }\n            _writeStringSegment(_charBuffer, 0, len);\n        } else {\n            _writeStringSegments(_charBuffer, 0, len);\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n\n    protected final void _writePPFieldName(SerializableString name) throws IOException {\n        final int status = _writeContext.writeFieldName(name.getValue());\n        if (status == JsonWriteContext.STATUS_EXPECT_VALUE) {\n            _reportError(\"Can not write a field name, expecting a value\");\n        }\n        if (status == JsonWriteContext.STATUS_OK_AFTER_COMMA) {\n            _cfgPrettyPrinter.writeObjectEntrySeparator(this);\n        } else {\n            _cfgPrettyPrinter.beforeObjectEntries(this);\n        }\n\n        final boolean addQuotes = !_cfgUnqNames; \n        if (addQuotes) {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        }\n        _writeBytes(name.asQuotedUTF8());\n        if (addQuotes) {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        }\n    }\n    \n    \n\n    @Override\n    public void writeString(String text) throws IOException {\n        _verifyValueWrite(WRITE_STRING);\n        if (text == null) {\n            _writeNull();\n            return;\n        }\n        \n        final int len = text.length();\n        if (len > _outputMaxContiguous) { \n            _writeStringSegments(text, true);\n            return;\n        }\n        if ((_outputTail + len) >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        _writeStringSegment(text, 0, len); \n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n\n    @Override\n    public void writeString(char[] text, int offset, int len) throws IOException {\n        _verifyValueWrite(WRITE_STRING);\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        \n        if (len <= _outputMaxContiguous) {\n            if ((_outputTail + len) > _outputEnd) { \n                _flushBuffer();\n            }\n            _writeStringSegment(text, offset, len);\n        } else {\n            _writeStringSegments(text, offset, len);\n        }\n        \n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n\n    @Override\n    public final void writeString(SerializableString text) throws IOException {\n        _verifyValueWrite(WRITE_STRING);\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        int len = text.appendQuotedUTF8(_outputBuffer, _outputTail);\n        if (len < 0) {\n            _writeBytes(text.asQuotedUTF8());\n        } else {\n            _outputTail += len;\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n    \n    @Override\n    public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException {\n        _verifyValueWrite(WRITE_STRING);\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        _writeBytes(text, offset, length);\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n\n    @Override\n    public void writeUTF8String(byte[] text, int offset, int len) throws IOException {\n        _verifyValueWrite(WRITE_STRING);\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        \n        if (len <= _outputMaxContiguous) {\n            _writeUTF8Segment(text, offset, len);\n        } else {\n            _writeUTF8Segments(text, offset, len);\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n\n    \n\n    @Override\n    public void writeRaw(String text) throws IOException {\n        writeRaw(text, 0, text.length());\n    }\n\n    @Override\n    public void writeRaw(String text, int offset, int len) throws IOException {\n        final char[] buf = _charBuffer;\n\n        \n\n        \n        \n        \n\n        while (len > 0) {\n            int len2 = Math.min(buf.length, len);\n            text.getChars(offset, offset+len2, buf, 0);\n            writeRaw(buf, 0, len2);\n            \n            \n            offset += len2;\n            len -= len2;\n        }\n    }\n\n    @Override\n    public void writeRaw(SerializableString text) throws IOException {\n        byte[] raw = text.asUnquotedUTF8();\n        if (raw.length > 0) {\n            _writeBytes(raw);\n        }\n    }\n\n    \n    @Override\n    public void writeRawValue(SerializableString text) throws IOException {\n        _verifyValueWrite(WRITE_RAW);\n        byte[] raw = text.asUnquotedUTF8();\n        if (raw.length > 0) {\n            _writeBytes(raw);\n        }\n    }\n\n    \n    @Override\n    public final void writeRaw(char[] cbuf, int offset, int len) throws IOException {\n        \n        {\n            int len3 = len+len+len;\n            if ((_outputTail + len3) > _outputEnd) {\n                \n                if (_outputEnd < len3) { \n                    _writeSegmentedRaw(cbuf, offset, len);\n                    return;\n                }\n                \n                _flushBuffer();\n            }\n        }\n        len += offset; \n\n        \n        main_loop:\n        while (offset < len) {\n            inner_loop:\n            while (true) {\n                int ch = (int) cbuf[offset];\n                if (ch > 0x7F) {\n                    break inner_loop;\n                }\n                _outputBuffer[_outputTail++] = (byte) ch;\n                if (++offset >= len) {\n                    break main_loop;\n                }\n            }\n            char ch = cbuf[offset++];\n            if (ch < 0x800) { \n                _outputBuffer[_outputTail++] = (byte) (0xc0 | (ch >> 6));\n                _outputBuffer[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n            } else {\n                offset = _outputRawMultiByteChar(ch, cbuf, offset, len);\n            }\n        }\n    }\n\n    @Override\n    public void writeRaw(char ch) throws IOException {\n        if ((_outputTail + 3) >= _outputEnd) {\n            _flushBuffer();\n        }\n        final byte[] bbuf = _outputBuffer;\n        if (ch <= 0x7F) {\n            bbuf[_outputTail++] = (byte) ch;\n        } else  if (ch < 0x800) { \n            bbuf[_outputTail++] = (byte) (0xc0 | (ch >> 6));\n            bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n        } else {\n             _outputRawMultiByteChar(ch, null, 0, 0);\n        }\n    }\n\n    \n    private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException {\n        final int end = _outputEnd;\n        final byte[] bbuf = _outputBuffer;\n        final int inputEnd = offset + len;\n        \n        main_loop:\n        while (offset < inputEnd) {\n            inner_loop:\n            while (true) {\n                int ch = (int) cbuf[offset];\n                if (ch >= 0x80) {\n                    break inner_loop;\n                }\n                \n                if (_outputTail >= end) {\n                    _flushBuffer();\n                }\n                bbuf[_outputTail++] = (byte) ch;\n                if (++offset >= inputEnd) {\n                    break main_loop;\n                }\n            }\n            if ((_outputTail + 3) >= _outputEnd) {\n                _flushBuffer();\n            }\n            char ch = cbuf[offset++];\n            if (ch < 0x800) { \n                bbuf[_outputTail++] = (byte) (0xc0 | (ch >> 6));\n                bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n            } else {\n                offset = _outputRawMultiByteChar(ch, cbuf, offset, inputEnd);\n            }\n        }\n    }\n\n    \n\n    \n\n    @Override\n    public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException {\n        _verifyValueWrite(WRITE_BINARY);\n        \n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        _writeBinary(b64variant, data, offset, offset+len);\n        \n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n\n    @Override\n    public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException {\n        _verifyValueWrite(WRITE_BINARY);\n        \n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        byte[] encodingBuffer = _ioContext.allocBase64Buffer();\n        int bytes;\n        try {\n            if (dataLength < 0) { \n                bytes = _writeBinary(b64variant, data, encodingBuffer);\n            } else {\n                int missing = _writeBinary(b64variant, data, encodingBuffer, dataLength);\n                if (missing > 0) {\n                    _reportError(\"Too few bytes available: missing \"+missing+\" bytes (out of \"+dataLength+\")\");\n                }\n                bytes = dataLength;\n            }\n        } finally {\n            _ioContext.releaseBase64Buffer(encodingBuffer);\n        }\n        \n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        return bytes;\n    }\n    \n    \n\n    @Override\n    public void writeNumber(short s) throws IOException {\n        _verifyValueWrite(WRITE_NUMBER);\n        \n        if ((_outputTail + 6) >= _outputEnd) {\n            _flushBuffer();\n        }\n        if (_cfgNumbersAsStrings) {\n            _writeQuotedShort(s);\n            return;\n        }\n        _outputTail = NumberOutput.outputInt(s, _outputBuffer, _outputTail);\n    }\n    \n    private final void _writeQuotedShort(short s) throws IOException {\n        if ((_outputTail + 8) >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        _outputTail = NumberOutput.outputInt(s, _outputBuffer, _outputTail);\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    } \n    \n    @Override\n    public void writeNumber(int i) throws IOException {\n        _verifyValueWrite(WRITE_NUMBER);\n        \n        if ((_outputTail + 11) >= _outputEnd) {\n            _flushBuffer();\n        }\n        if (_cfgNumbersAsStrings) {\n            _writeQuotedInt(i);\n            return;\n        }\n        _outputTail = NumberOutput.outputInt(i, _outputBuffer, _outputTail);\n    }\n\n    private final void _writeQuotedInt(int i) throws IOException {\n        if ((_outputTail + 13) >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        _outputTail = NumberOutput.outputInt(i, _outputBuffer, _outputTail);\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }    \n\n    @Override\n    public void writeNumber(long l) throws IOException {\n        _verifyValueWrite(WRITE_NUMBER);\n        if (_cfgNumbersAsStrings) {\n            _writeQuotedLong(l);\n            return;\n        }\n        if ((_outputTail + 21) >= _outputEnd) {\n            \n            _flushBuffer();\n        }\n        _outputTail = NumberOutput.outputLong(l, _outputBuffer, _outputTail);\n    }\n\n    private final void _writeQuotedLong(long l) throws IOException {\n        if ((_outputTail + 23) >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        _outputTail = NumberOutput.outputLong(l, _outputBuffer, _outputTail);\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n\n    @Override\n    public void writeNumber(BigInteger value) throws IOException {\n        _verifyValueWrite(WRITE_NUMBER);\n        if (value == null) {\n            _writeNull();\n        } else if (_cfgNumbersAsStrings) {\n            _writeQuotedRaw(value.toString());\n        } else {\n            writeRaw(value.toString());\n        }\n    }\n\n    \n    @Override\n    public void writeNumber(double d) throws IOException {\n        if (_cfgNumbersAsStrings ||\n            (((Double.isNaN(d) || Double.isInfinite(d))\n                && Feature.QUOTE_NON_NUMERIC_NUMBERS.enabledIn(_features)))) {\n            writeString(String.valueOf(d));\n            return;\n        }\n        \n        _verifyValueWrite(WRITE_NUMBER);\n        writeRaw(String.valueOf(d));\n    }\n\n    @Override\n    public void writeNumber(float f) throws IOException {\n        if (_cfgNumbersAsStrings ||\n            \n            (((Float.isNaN(f) || Float.isInfinite(f))\n                && Feature.QUOTE_NON_NUMERIC_NUMBERS.enabledIn(_features)))) {\n            writeString(String.valueOf(f));\n            return;\n        }\n        \n        _verifyValueWrite(WRITE_NUMBER);\n        writeRaw(String.valueOf(f));\n    }\n\n    @Override\n    public void writeNumber(BigDecimal value) throws IOException {\n        \n        _verifyValueWrite(WRITE_NUMBER);\n        if (value == null) {\n            _writeNull();\n        } else if (_cfgNumbersAsStrings) {\n            String raw = Feature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_features)\n                    ? value.toPlainString() : value.toString();\n            _writeQuotedRaw(raw);\n        } else if (Feature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_features)) {\n            writeRaw(value.toPlainString());\n        } else {\n            writeRaw(value.toString());\n        }\n    }\n\n    @Override\n    public void writeNumber(String encodedValue) throws IOException {\n        _verifyValueWrite(WRITE_NUMBER);\n        if (_cfgNumbersAsStrings) {\n            _writeQuotedRaw(encodedValue);            \n        } else {\n            writeRaw(encodedValue);\n        }\n    }\n\n    private final void _writeQuotedRaw(String value) throws IOException {\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        writeRaw(value);\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n    \n    @Override\n    public void writeBoolean(boolean state) throws IOException {\n        _verifyValueWrite(WRITE_BOOLEAN);\n        if ((_outputTail + 5) >= _outputEnd) {\n            _flushBuffer();\n        }\n        byte[] keyword = state ? TRUE_BYTES : FALSE_BYTES;\n        int len = keyword.length;\n        System.arraycopy(keyword, 0, _outputBuffer, _outputTail, len);\n        _outputTail += len;\n    }\n\n    @Override\n    public void writeNull() throws IOException {\n        _verifyValueWrite(WRITE_NULL);\n        _writeNull();\n    }\n\n    \n\n    @Override\n    protected final void _verifyValueWrite(String typeMsg) throws IOException {\n        int status = _writeContext.writeValue();\n        if (status == JsonWriteContext.STATUS_EXPECT_NAME) {\n            _reportError(\"Can not \"+typeMsg+\", expecting field name\");\n        }\n        if (_cfgPrettyPrinter == null) {\n            byte b;\n            switch (status) {\n            case JsonWriteContext.STATUS_OK_AFTER_COMMA:\n                b = BYTE_COMMA;\n                break;\n            case JsonWriteContext.STATUS_OK_AFTER_COLON:\n                b = BYTE_COLON;\n                break;\n            case JsonWriteContext.STATUS_OK_AFTER_SPACE: \n                if (_rootValueSeparator != null) {\n                    byte[] raw = _rootValueSeparator.asUnquotedUTF8();\n                    if (raw.length > 0) {\n                        _writeBytes(raw);\n                    }\n                }\n                return;\n            case JsonWriteContext.STATUS_OK_AS_IS:\n            default:\n                return;\n            }\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail] = b;\n            ++_outputTail;\n            return;\n        }\n        \n        _verifyPrettyValueWrite(typeMsg, status);\n    }\n\n    protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException {\n        \n        switch (status) {\n        case JsonWriteContext.STATUS_OK_AFTER_COMMA: \n            _cfgPrettyPrinter.writeArrayValueSeparator(this);\n            break;\n        case JsonWriteContext.STATUS_OK_AFTER_COLON:\n            _cfgPrettyPrinter.writeObjectFieldValueSeparator(this);\n            break;\n        case JsonWriteContext.STATUS_OK_AFTER_SPACE:\n            _cfgPrettyPrinter.writeRootValueSeparator(this);\n            break;\n        case JsonWriteContext.STATUS_OK_AS_IS:\n            \n            if (_writeContext.inArray()) {\n                _cfgPrettyPrinter.beforeArrayValues(this);\n            } else if (_writeContext.inObject()) {\n                _cfgPrettyPrinter.beforeObjectEntries(this);\n            }\n            break;\n        default:\n            _throwInternal();\n            break;\n        }\n    }\n\n    \n\n    @Override\n    public void flush() throws IOException {\n        _flushBuffer();\n        if (_outputStream != null) {\n            if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) {\n                _outputStream.flush();\n            }\n        }\n    }\n\n    @Override\n    public void close() throws IOException {\n        super.close();\n\n        \n        \n        if ((_outputBuffer != null)\n            && isEnabled(Feature.AUTO_CLOSE_JSON_CONTENT)) {\n            while (true) {\n                JsonStreamContext ctxt = getOutputContext();\n                if (ctxt.inArray()) {\n                    writeEndArray();\n                } else if (ctxt.inObject()) {\n                    writeEndObject();\n                } else {\n                    break;\n                }\n            }\n        }\n        _flushBuffer();\n        _outputTail = 0; \n\n        \n        if (_outputStream != null) {\n            if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_TARGET)) {\n                _outputStream.close();\n            } else if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) {\n                \n                _outputStream.flush();\n            }\n        }\n        \n        _releaseBuffers();\n    }\n\n    @Override\n    protected void _releaseBuffers() {\n        byte[] buf = _outputBuffer;\n        if (buf != null && _bufferRecyclable) {\n            _outputBuffer = null;\n            _ioContext.releaseWriteEncodingBuffer(buf);\n        }\n        char[] cbuf = _charBuffer;\n        if (cbuf != null) {\n            _charBuffer = null;\n            _ioContext.releaseConcatBuffer(cbuf);\n        }\n    }\n\n    \n\n    private final void _writeBytes(byte[] bytes) throws IOException {\n        final int len = bytes.length;\n        if ((_outputTail + len) > _outputEnd) {\n            _flushBuffer();\n            \n            if (len > MAX_BYTES_TO_BUFFER) {\n                _outputStream.write(bytes, 0, len);\n                return;\n            }\n        }\n        System.arraycopy(bytes, 0, _outputBuffer, _outputTail, len);\n        _outputTail += len;\n    }\n\n    private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException {\n        if ((_outputTail + len) > _outputEnd) {\n            _flushBuffer();\n            \n            if (len > MAX_BYTES_TO_BUFFER) {\n                _outputStream.write(bytes, offset, len);\n                return;\n            }\n        }\n        System.arraycopy(bytes, offset, _outputBuffer, _outputTail, len);\n        _outputTail += len;\n    }\n\n    \n    \n    \n    private final void _writeStringSegments(String text, boolean addQuotes) throws IOException {\n        if (addQuotes) {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_QUOTE;        \n        }\n\n        int left = text.length();\n        int offset = 0;\n\n        while (left > 0) {\n            int len = Math.min(_outputMaxContiguous, left);\n            if ((_outputTail + len) > _outputEnd) { \n                _flushBuffer();\n            }\n            _writeStringSegment(text, offset, len);\n            offset += len;\n            left -= len;\n        }\n\n        if (addQuotes) {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        }\n    }\n\n    \n    private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException {\n        do {\n            int len = Math.min(_outputMaxContiguous, totalLen);\n            if ((_outputTail + len) > _outputEnd) { \n                _flushBuffer();\n            }\n            _writeStringSegment(cbuf, offset, len);\n            offset += len;\n            totalLen -= len;\n        } while (totalLen > 0);\n    }\n\n    private final void _writeStringSegments(String text, int offset, int totalLen) throws IOException {\n        do {\n            int len = Math.min(_outputMaxContiguous, totalLen);\n            if ((_outputTail + len) > _outputEnd) { \n                _flushBuffer();\n            }\n            _writeStringSegment(text, offset, len);\n            offset += len;\n            totalLen -= len;\n        } while (totalLen > 0);\n    }\n\n    \n\n    \n    private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException {\n        \n        \n        \n        len += offset; \n\n        int outputPtr = _outputTail;\n        final byte[] outputBuffer = _outputBuffer;\n        final int[] escCodes = _outputEscapes;\n\n        while (offset < len) {\n            int ch = cbuf[offset];\n            \n            if (ch > 0x7F || escCodes[ch] != 0) {\n                break;\n            }\n            outputBuffer[outputPtr++] = (byte) ch;\n            ++offset;\n        }\n        _outputTail = outputPtr;\n        if (offset < len) {\n            \n            if (_characterEscapes != null) {\n                _writeCustomStringSegment2(cbuf, offset, len);\n            \n            } else if (_maximumNonEscapedChar == 0) {\n                _writeStringSegment2(cbuf, offset, len);\n            } else {\n                _writeStringSegmentASCII2(cbuf, offset, len);\n            }\n\n        }\n    }\n\n    private final void _writeStringSegment(String text, int offset, int len) throws IOException {\n        \n        \n        len += offset; \n\n        int outputPtr = _outputTail;\n        final byte[] outputBuffer = _outputBuffer;\n        final int[] escCodes = _outputEscapes;\n\n        while (offset < len) {\n            int ch = text.charAt(offset);\n            \n            if (ch > 0x7F || escCodes[ch] != 0) {\n                break;\n            }\n            outputBuffer[outputPtr++] = (byte) ch;\n            ++offset;\n        }\n        _outputTail = outputPtr;\n        if (offset < len) {\n            if (_characterEscapes != null) {\n                _writeCustomStringSegment2(text, offset, len);\n            } else if (_maximumNonEscapedChar == 0) {\n                _writeStringSegment2(text, offset, len);\n            } else {\n                _writeStringSegmentASCII2(text, offset, len);\n            }\n        }\n    }\n\n    \n    private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException {\n        \n        if ((_outputTail +  6 * (end - offset)) > _outputEnd) {\n            _flushBuffer();\n        }\n\n        int outputPtr = _outputTail;\n\n        final byte[] outputBuffer = _outputBuffer;\n        final int[] escCodes = _outputEscapes;\n        \n        while (offset < end) {\n            int ch = cbuf[offset++];\n            if (ch <= 0x7F) {\n                 if (escCodes[ch] == 0) {\n                     outputBuffer[outputPtr++] = (byte) ch;\n                     continue;\n                 }\n                 int escape = escCodes[ch];\n                 if (escape > 0) { \n                     outputBuffer[outputPtr++] = BYTE_BACKSLASH;\n                     outputBuffer[outputPtr++] = (byte) escape;\n                 } else {\n                     \n                     outputPtr = _writeGenericEscape(ch, outputPtr);\n                }\n                continue;\n            }\n            if (ch <= 0x7FF) { \n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f));\n            } else {\n                outputPtr = _outputMultiByteChar(ch, outputPtr);\n            }\n        }\n        _outputTail = outputPtr;\n    }\n\n    private final void _writeStringSegment2(final String text, int offset, final int end) throws IOException {\n        if ((_outputTail +  6 * (end - offset)) > _outputEnd) {\n            _flushBuffer();\n        }\n\n        int outputPtr = _outputTail;\n\n        final byte[] outputBuffer = _outputBuffer;\n        final int[] escCodes = _outputEscapes;\n        \n        while (offset < end) {\n            int ch = text.charAt(offset++);\n            if (ch <= 0x7F) {\n                 if (escCodes[ch] == 0) {\n                     outputBuffer[outputPtr++] = (byte) ch;\n                     continue;\n                 }\n                 int escape = escCodes[ch];\n                 if (escape > 0) { \n                     outputBuffer[outputPtr++] = BYTE_BACKSLASH;\n                     outputBuffer[outputPtr++] = (byte) escape;\n                 } else {\n                     \n                     outputPtr = _writeGenericEscape(ch, outputPtr);\n                }\n                continue;\n            }\n            if (ch <= 0x7FF) { \n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f));\n            } else {\n                outputPtr = _outputMultiByteChar(ch, outputPtr);\n            }\n        }\n        _outputTail = outputPtr;\n    }\n    \n    \n\n    \n    private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException {\n        \n        if ((_outputTail +  6 * (end - offset)) > _outputEnd) {\n            _flushBuffer();\n        }\n    \n        int outputPtr = _outputTail;\n    \n        final byte[] outputBuffer = _outputBuffer;\n        final int[] escCodes = _outputEscapes;\n        final int maxUnescaped = _maximumNonEscapedChar;\n        \n        while (offset < end) {\n            int ch = cbuf[offset++];\n            if (ch <= 0x7F) {\n                 if (escCodes[ch] == 0) {\n                     outputBuffer[outputPtr++] = (byte) ch;\n                     continue;\n                 }\n                 int escape = escCodes[ch];\n                 if (escape > 0) { \n                     outputBuffer[outputPtr++] = BYTE_BACKSLASH;\n                     outputBuffer[outputPtr++] = (byte) escape;\n                 } else {\n                     \n                     outputPtr = _writeGenericEscape(ch, outputPtr);\n                 }\n                 continue;\n            }\n            if (ch > maxUnescaped) { \n                outputPtr = _writeGenericEscape(ch, outputPtr);\n                continue;\n            }\n            if (ch <= 0x7FF) { \n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f));\n            } else {\n                outputPtr = _outputMultiByteChar(ch, outputPtr);\n            }\n        }\n        _outputTail = outputPtr;\n    }\n\n    private final void _writeStringSegmentASCII2(final String text, int offset, final int end) throws IOException {\n        \n        if ((_outputTail +  6 * (end - offset)) > _outputEnd) {\n            _flushBuffer();\n        }\n    \n        int outputPtr = _outputTail;\n    \n        final byte[] outputBuffer = _outputBuffer;\n        final int[] escCodes = _outputEscapes;\n        final int maxUnescaped = _maximumNonEscapedChar;\n        \n        while (offset < end) {\n            int ch = text.charAt(offset++);\n            if (ch <= 0x7F) {\n                 if (escCodes[ch] == 0) {\n                     outputBuffer[outputPtr++] = (byte) ch;\n                     continue;\n                 }\n                 int escape = escCodes[ch];\n                 if (escape > 0) { \n                     outputBuffer[outputPtr++] = BYTE_BACKSLASH;\n                     outputBuffer[outputPtr++] = (byte) escape;\n                 } else {\n                     \n                     outputPtr = _writeGenericEscape(ch, outputPtr);\n                 }\n                 continue;\n            }\n            if (ch > maxUnescaped) { \n                outputPtr = _writeGenericEscape(ch, outputPtr);\n                continue;\n            }\n            if (ch <= 0x7FF) { \n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f));\n            } else {\n                outputPtr = _outputMultiByteChar(ch, outputPtr);\n            }\n        }\n        _outputTail = outputPtr;\n    }\n    \n    \n\n    \n    private final void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException {\n        \n        if ((_outputTail +  6 * (end - offset)) > _outputEnd) {\n            _flushBuffer();\n        }\n        int outputPtr = _outputTail;\n    \n        final byte[] outputBuffer = _outputBuffer;\n        final int[] escCodes = _outputEscapes;\n        \n        final int maxUnescaped = (_maximumNonEscapedChar <= 0) ? 0xFFFF : _maximumNonEscapedChar;\n        final CharacterEscapes customEscapes = _characterEscapes; \n        \n        while (offset < end) {\n            int ch = cbuf[offset++];\n            if (ch <= 0x7F) {\n                 if (escCodes[ch] == 0) {\n                     outputBuffer[outputPtr++] = (byte) ch;\n                     continue;\n                 }\n                 int escape = escCodes[ch];\n                 if (escape > 0) { \n                     outputBuffer[outputPtr++] = BYTE_BACKSLASH;\n                     outputBuffer[outputPtr++] = (byte) escape;\n                 } else if (escape == CharacterEscapes.ESCAPE_CUSTOM) {\n                     SerializableString esc = customEscapes.getEscapeSequence(ch);\n                     if (esc == null) {\n                         _reportError(\"Invalid custom escape definitions; custom escape not found for character code 0x\"\n                                 +Integer.toHexString(ch)+\", although was supposed to have one\");\n                     }\n                     outputPtr = _writeCustomEscape(outputBuffer, outputPtr, esc, end-offset);\n                 } else {\n                     \n                     outputPtr = _writeGenericEscape(ch, outputPtr);\n                 }\n                 continue;\n            }\n            if (ch > maxUnescaped) { \n                outputPtr = _writeGenericEscape(ch, outputPtr);\n                continue;\n            }\n            SerializableString esc = customEscapes.getEscapeSequence(ch);\n            if (esc != null) {\n                outputPtr = _writeCustomEscape(outputBuffer, outputPtr, esc, end-offset);\n                continue;\n            }\n            if (ch <= 0x7FF) { \n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f));\n            } else {\n                outputPtr = _outputMultiByteChar(ch, outputPtr);\n            }\n        }\n        _outputTail = outputPtr;\n    }\n\n    private final void _writeCustomStringSegment2(final String text, int offset, final int end) throws IOException {\n        \n        if ((_outputTail +  6 * (end - offset)) > _outputEnd) {\n            _flushBuffer();\n        }\n        int outputPtr = _outputTail;\n    \n        final byte[] outputBuffer = _outputBuffer;\n        final int[] escCodes = _outputEscapes;\n        \n        final int maxUnescaped = (_maximumNonEscapedChar <= 0) ? 0xFFFF : _maximumNonEscapedChar;\n        final CharacterEscapes customEscapes = _characterEscapes; \n        \n        while (offset < end) {\n            int ch = text.charAt(offset++);\n            if (ch <= 0x7F) {\n                 if (escCodes[ch] == 0) {\n                     outputBuffer[outputPtr++] = (byte) ch;\n                     continue;\n                 }\n                 int escape = escCodes[ch];\n                 if (escape > 0) { \n                     outputBuffer[outputPtr++] = BYTE_BACKSLASH;\n                     outputBuffer[outputPtr++] = (byte) escape;\n                 } else if (escape == CharacterEscapes.ESCAPE_CUSTOM) {\n                     SerializableString esc = customEscapes.getEscapeSequence(ch);\n                     if (esc == null) {\n                         _reportError(\"Invalid custom escape definitions; custom escape not found for character code 0x\"\n                                 +Integer.toHexString(ch)+\", although was supposed to have one\");\n                     }\n                     outputPtr = _writeCustomEscape(outputBuffer, outputPtr, esc, end-offset);\n                 } else {\n                     \n                     outputPtr = _writeGenericEscape(ch, outputPtr);\n                 }\n                 continue;\n            }\n            if (ch > maxUnescaped) { \n                outputPtr = _writeGenericEscape(ch, outputPtr);\n                continue;\n            }\n            SerializableString esc = customEscapes.getEscapeSequence(ch);\n            if (esc != null) {\n                outputPtr = _writeCustomEscape(outputBuffer, outputPtr, esc, end-offset);\n                continue;\n            }\n            if (ch <= 0x7FF) { \n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f));\n            } else {\n                outputPtr = _outputMultiByteChar(ch, outputPtr);\n            }\n        }\n        _outputTail = outputPtr;\n    }\n\n    private final int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException {\n        byte[] raw = esc.asUnquotedUTF8(); \n        int len = raw.length;\n        if (len > 6) { \n            return _handleLongCustomEscape(outputBuffer, outputPtr, _outputEnd, raw, remainingChars);\n        }\n        \n        System.arraycopy(raw, 0, outputBuffer, outputPtr, len);\n        return (outputPtr + len);\n    }\n    \n    private final int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException {\n        int len = raw.length;\n        if ((outputPtr + len) > outputEnd) {\n            _outputTail = outputPtr;\n            _flushBuffer();\n            outputPtr = _outputTail;\n            if (len > outputBuffer.length) { \n                _outputStream.write(raw, 0, len);\n                return outputPtr;\n            }\n            System.arraycopy(raw, 0, outputBuffer, outputPtr, len);\n            outputPtr += len;\n        }\n        \n        if ((outputPtr +  6 * remainingChars) > outputEnd) {\n            _flushBuffer();\n            return _outputTail;\n        }\n        return outputPtr;\n    }\n\n    \n    \n    \n    private final void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException {\n        do {\n            int len = Math.min(_outputMaxContiguous, totalLen);\n            _writeUTF8Segment(utf8, offset, len);\n            offset += len;\n            totalLen -= len;\n        } while (totalLen > 0);\n    }\n    \n    private final void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException {\n        \n        final int[] escCodes = _outputEscapes;\n\n        for (int ptr = offset, end = offset + len; ptr < end; ) {\n            \n            int ch = utf8[ptr++];\n            if ((ch >= 0) && escCodes[ch] != 0) {\n                _writeUTF8Segment2(utf8, offset, len);\n                return;\n            }\n        }\n        \n        \n        if ((_outputTail + len) > _outputEnd) { \n            _flushBuffer(); \n        }\n        System.arraycopy(utf8, offset, _outputBuffer, _outputTail, len);\n        _outputTail += len;\n    }\n\n    private final void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException {\n        int outputPtr = _outputTail;\n\n        \n        if ((outputPtr + (len * 6)) > _outputEnd) {\n            _flushBuffer();\n            outputPtr = _outputTail;\n        }\n        \n        final byte[] outputBuffer = _outputBuffer;\n        final int[] escCodes = _outputEscapes;\n        len += offset; \n        \n        while (offset < len) {\n            byte b = utf8[offset++];\n            int ch = b;\n            if (ch < 0 || escCodes[ch] == 0) {\n                outputBuffer[outputPtr++] = b;\n                continue;\n            }\n            int escape = escCodes[ch];\n            if (escape > 0) { \n                outputBuffer[outputPtr++] = BYTE_BACKSLASH;\n                outputBuffer[outputPtr++] = (byte) escape;\n            } else {\n                \n                outputPtr = _writeGenericEscape(ch, outputPtr);\n            }\n        }\n        _outputTail = outputPtr;\n    }\n    \n    \n    \n    protected final void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException {\n        \n        int safeInputEnd = inputEnd - 3;\n        \n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        \n        while (inputPtr <= safeInputEnd) {\n            if (_outputTail > safeOutputEnd) { \n                _flushBuffer();\n            }\n            \n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                \n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        \n        int inputLeft = inputEnd - inputPtr; \n        if (inputLeft > 0) { \n            if (_outputTail > safeOutputEnd) { \n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }\n\n    \n    protected final int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;       \n        \n        \n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        while (bytesLeft > 2) { \n            if (inputPtr > lastFullOffset) {\n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n                inputPtr = 0;\n                if (inputEnd < 3) { \n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { \n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesLeft -= 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n        \n        \n        if (bytesLeft > 0) {\n            inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n            inputPtr = 0;\n            if (inputEnd > 0) { \n                if (_outputTail > safeOutputEnd) { \n                    _flushBuffer();\n                }\n                int b24 = ((int) readBuffer[inputPtr++]) << 16;\n                int amount;\n                if (inputPtr < inputEnd) {\n                    b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                    amount = 2;\n                } else {\n                    amount = 1;\n                }\n                _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n                bytesLeft -= amount;\n            }\n        }\n        return bytesLeft;\n    }\n\n    \n    protected final int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;\n        int bytesDone = 0;\n        \n        \n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        \n        while (true) {\n            if (inputPtr > lastFullOffset) { \n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, readBuffer.length);\n                inputPtr = 0;\n                if (inputEnd < 3) { \n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { \n                _flushBuffer();\n            }\n            \n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesDone += 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        \n        if (inputPtr < inputEnd) { \n            if (_outputTail > safeOutputEnd) { \n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 16;\n            int amount = 1;\n            if (inputPtr < inputEnd) {\n                b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                amount = 2;\n            }\n            bytesDone += amount;\n            _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n        }\n        return bytesDone;\n    }\n    \n    private final int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException {\n        \n        int i = 0;\n        while (inputPtr < inputEnd) {\n            readBuffer[i++]  = readBuffer[inputPtr++];\n        }\n        inputPtr = 0;\n        inputEnd = i;\n        maxRead = Math.min(maxRead, readBuffer.length);\n        \n        do {\n            int length = maxRead - inputEnd;\n            if (length == 0) {\n                break;\n            }\n            int count = in.read(readBuffer, inputEnd, length);            \n            if (count < 0) {\n                return inputEnd;\n            }\n            inputEnd += count;\n        } while (inputEnd < 3);\n        return inputEnd;\n    }\n    \n    \n    \n    \n    private final int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputEnd) throws IOException {\n        \n        if (ch >= SURR1_FIRST) {\n            if (ch <= SURR2_LAST) { \n                \n                if (inputOffset >= inputEnd || cbuf == null) { \n                    _reportError(\"Split surrogate on writeRaw() input (last character)\");\n                }\n                _outputSurrogates(ch, cbuf[inputOffset]);\n                return inputOffset+1;\n            }\n        }\n        final byte[] bbuf = _outputBuffer;\n        bbuf[_outputTail++] = (byte) (0xe0 | (ch >> 12));\n        bbuf[_outputTail++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n        bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n        return inputOffset;\n    }\n\n    protected final void _outputSurrogates(int surr1, int surr2) throws IOException {\n        int c = _decodeSurrogate(surr1, surr2);\n        if ((_outputTail + 4) > _outputEnd) {\n            _flushBuffer();\n        }\n        final byte[] bbuf = _outputBuffer;\n        bbuf[_outputTail++] = (byte) (0xf0 | (c >> 18));\n        bbuf[_outputTail++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n        bbuf[_outputTail++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n        bbuf[_outputTail++] = (byte) (0x80 | (c & 0x3f));\n    }\n    \n    \n    private final int _outputMultiByteChar(int ch, int outputPtr) throws IOException {\n        byte[] bbuf = _outputBuffer;\n        if (ch >= SURR1_FIRST && ch <= SURR2_LAST) { \n            \n            \n            \n\n                bbuf[outputPtr++] = BYTE_BACKSLASH;\n                bbuf[outputPtr++] = BYTE_u;\n                \n                bbuf[outputPtr++] = HEX_CHARS[(ch >> 12) & 0xF];\n                bbuf[outputPtr++] = HEX_CHARS[(ch >> 8) & 0xF];\n                bbuf[outputPtr++] = HEX_CHARS[(ch >> 4) & 0xF];\n                bbuf[outputPtr++] = HEX_CHARS[ch & 0xF];\n\n        } else {\n            bbuf[outputPtr++] = (byte) (0xe0 | (ch >> 12));\n            bbuf[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n            bbuf[outputPtr++] = (byte) (0x80 | (ch & 0x3f));\n        }\n        return outputPtr;\n    }\n\n    private final void _writeNull() throws IOException {\n        if ((_outputTail + 4) >= _outputEnd) {\n            _flushBuffer();\n        }\n        System.arraycopy(NULL_BYTES, 0, _outputBuffer, _outputTail, 4);\n        _outputTail += 4;\n    }\n        \n    \n    private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException {\n        final byte[] bbuf = _outputBuffer;\n        bbuf[outputPtr++] = BYTE_BACKSLASH;\n        bbuf[outputPtr++] = BYTE_u;\n        if (charToEscape > 0xFF) {\n            int hi = (charToEscape >> 8) & 0xFF;\n            bbuf[outputPtr++] = HEX_CHARS[hi >> 4];\n            bbuf[outputPtr++] = HEX_CHARS[hi & 0xF];\n            charToEscape &= 0xFF;\n        } else {\n            bbuf[outputPtr++] = BYTE_0;\n            bbuf[outputPtr++] = BYTE_0;\n        }\n        \n        bbuf[outputPtr++] = HEX_CHARS[charToEscape >> 4];\n        bbuf[outputPtr++] = HEX_CHARS[charToEscape & 0xF];\n        return outputPtr;\n    }\n\n    protected final void _flushBuffer() throws IOException {\n        int len = _outputTail;\n        if (len > 0) {\n            _outputTail = 0;\n            _outputStream.write(_outputBuffer, 0, len);\n        }\n    }\n}\n",
      "fixed_full_code": "package com.fasterxml.jackson.core.json;\n\nimport java.io.*;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.io.*;\n\npublic class UTF8JsonGenerator extends JsonGeneratorImpl { private final static byte BYTE_u = (byte) 'u'; private final static byte BYTE_0 = (byte) '0'; private final static byte BYTE_LBRACKET = (byte) '['; private final static byte BYTE_RBRACKET = (byte) ']'; private final static byte BYTE_LCURLY = (byte) ' {';\n    private final static byte BYTE_RCURLY = (byte) '}'; private final static byte BYTE_BACKSLASH = (byte) '\\\\'; private final static byte BYTE_COMMA = (byte) ','; private final static byte BYTE_COLON = (byte) ':'; private final static byte BYTE_QUOTE = (byte) '\"'; private final static int MAX_BYTES_TO_BUFFER = 512; private final static byte[] HEX_CHARS = CharTypes.copyHexBytes(); private final static byte[] NULL_BYTES = { 'n', 'u', 'l', 'l' };\n    private final static byte[] TRUE_BYTES = { 't', 'r', 'u', 'e' }; private final static byte[] FALSE_BYTES = { 'f', 'a', 'l', 's', 'e' }; final protected OutputStream _outputStream; protected byte[] _outputBuffer; protected int _outputTail; protected final int _outputEnd; protected final int _outputMaxContiguous; protected char[] _charBuffer; protected final int _charBufferLength; protected byte[] _entityBuffer; protected boolean _bufferRecyclable; public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out) {\n        super(ctxt, features, codec);\n        _outputStream = out;\n        _bufferRecyclable = true;\n        _outputBuffer = ctxt.allocWriteEncodingBuffer();\n        _outputEnd = _outputBuffer.length;\n\n        \n        _outputMaxContiguous = _outputEnd >> 3;\n        _charBuffer = ctxt.allocConcatBuffer();\n        _charBufferLength = _charBuffer.length;\n\n        \n        if (isEnabled(Feature.ESCAPE_NON_ASCII)) {\n            setHighestNonEscapedChar(127);\n        }\n    }\n    \n    public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable) {\n        \n        super(ctxt, features, codec);\n        _outputStream = out;\n        _bufferRecyclable = bufferRecyclable;\n        _outputTail = outputOffset;\n        _outputBuffer = outputBuffer;\n        _outputEnd = _outputBuffer.length;\n        \n        _outputMaxContiguous = (_outputEnd >> 3);\n        _charBuffer = ctxt.allocConcatBuffer();\n        _charBufferLength = _charBuffer.length;\n    }\n\n    \n    \n    @Override\n    public Object getOutputTarget() {\n        return _outputStream;\n    }\n\n    @Override\n    public int getOutputBuffered() {\n        \n        return _outputTail;\n    }\n\n    \n\n    @Override\n    public void writeFieldName(String name) throws IOException {\n        if (_cfgPrettyPrinter != null) {\n            _writePPFieldName(name);\n            return;\n        }\n        final int status = _writeContext.writeFieldName(name);\n        if (status == JsonWriteContext.STATUS_EXPECT_VALUE) {\n            _reportError(\"Can not write a field name, expecting a value\");\n        }\n        if (status == JsonWriteContext.STATUS_OK_AFTER_COMMA) { \n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_COMMA;\n        }\n        \n        if (_cfgUnqNames) {\n            _writeStringSegments(name, false);\n            return;\n        }\n        final int len = name.length();\n        \n        if (len > _charBufferLength) { \n            _writeStringSegments(name, true);\n            return;\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        \n        if (len <= _outputMaxContiguous) {\n            if ((_outputTail + len) > _outputEnd) { \n                _flushBuffer();\n            }\n            _writeStringSegment(name, 0, len);\n        } else {\n            _writeStringSegments(name, 0, len);\n        }\n        \n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n    \n    @Override\n    public void writeFieldName(SerializableString name) throws IOException {\n        if (_cfgPrettyPrinter != null) {\n            _writePPFieldName(name);\n            return;\n        }\n        final int status = _writeContext.writeFieldName(name.getValue());\n        if (status == JsonWriteContext.STATUS_EXPECT_VALUE) {\n            _reportError(\"Can not write a field name, expecting a value\");\n        }\n        if (status == JsonWriteContext.STATUS_OK_AFTER_COMMA) {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_COMMA;\n        }\n        if (_cfgUnqNames) {\n            _writeUnq(name);\n            return;\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        int len = name.appendQuotedUTF8(_outputBuffer, _outputTail);\n        if (len < 0) { \n            _writeBytes(name.asQuotedUTF8());\n        } else {\n            _outputTail += len;\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }    \n\n    private final void _writeUnq(SerializableString name) throws IOException {\n        int len = name.appendQuotedUTF8(_outputBuffer, _outputTail);\n        if (len < 0) {\n            _writeBytes(name.asQuotedUTF8());\n        } else {\n            _outputTail += len;\n        }\n    }\n    \n    \n\n    @Override\n    public final void writeStartArray() throws IOException {\n        _verifyValueWrite(\"start an array\");\n        _writeContext = _writeContext.createChildArrayContext();\n        if (_cfgPrettyPrinter != null) {\n            _cfgPrettyPrinter.writeStartArray(this);\n        } else {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_LBRACKET;\n        }\n    }\n\n    @Override\n    public final void writeEndArray() throws IOException {\n        if (!_writeContext.inArray()) {\n            _reportError(\"Current context not an ARRAY but \"+_writeContext.getTypeDesc());\n        }\n        if (_cfgPrettyPrinter != null) {\n            _cfgPrettyPrinter.writeEndArray(this, _writeContext.getEntryCount());\n        } else {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_RBRACKET;\n        }\n        _writeContext = _writeContext.clearAndGetParent();\n    }\n\n    @Override\n    public final void writeStartObject() throws IOException {\n        _verifyValueWrite(\"start an object\");\n        _writeContext = _writeContext.createChildObjectContext();\n        if (_cfgPrettyPrinter != null) {\n            _cfgPrettyPrinter.writeStartObject(this);\n        } else {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_LCURLY;\n        }\n    }\n\n    @Override\n    public final void writeEndObject() throws IOException {\n        if (!_writeContext.inObject()) {\n            _reportError(\"Current context not an object but \"+_writeContext.getTypeDesc());\n        }\n        if (_cfgPrettyPrinter != null) {\n            _cfgPrettyPrinter.writeEndObject(this, _writeContext.getEntryCount());\n        } else {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_RCURLY;\n        }\n        _writeContext = _writeContext.clearAndGetParent();\n    }\n\n    \n    protected final void _writePPFieldName(String name) throws IOException {\n        int status = _writeContext.writeFieldName(name);\n        if (status == JsonWriteContext.STATUS_EXPECT_VALUE) {\n            _reportError(\"Can not write a field name, expecting a value\");\n        }\n        if ((status == JsonWriteContext.STATUS_OK_AFTER_COMMA)) {\n            _cfgPrettyPrinter.writeObjectEntrySeparator(this);\n        } else {\n            _cfgPrettyPrinter.beforeObjectEntries(this);\n        }\n        if (_cfgUnqNames) {\n            _writeStringSegments(name, false);\n            return;\n        }\n        final int len = name.length();\n        if (len > _charBufferLength) {\n            _writeStringSegments(name, true);\n            return;\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        name.getChars(0, len, _charBuffer, 0);\n        \n        if (len <= _outputMaxContiguous) {\n            if ((_outputTail + len) > _outputEnd) { \n                _flushBuffer();\n            }\n            _writeStringSegment(_charBuffer, 0, len);\n        } else {\n            _writeStringSegments(_charBuffer, 0, len);\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n\n    protected final void _writePPFieldName(SerializableString name) throws IOException {\n        final int status = _writeContext.writeFieldName(name.getValue());\n        if (status == JsonWriteContext.STATUS_EXPECT_VALUE) {\n            _reportError(\"Can not write a field name, expecting a value\");\n        }\n        if (status == JsonWriteContext.STATUS_OK_AFTER_COMMA) {\n            _cfgPrettyPrinter.writeObjectEntrySeparator(this);\n        } else {\n            _cfgPrettyPrinter.beforeObjectEntries(this);\n        }\n\n        final boolean addQuotes = !_cfgUnqNames; \n        if (addQuotes) {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        }\n        _writeBytes(name.asQuotedUTF8());\n        if (addQuotes) {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        }\n    }\n    \n    \n\n    @Override\n    public void writeString(String text) throws IOException {\n        _verifyValueWrite(WRITE_STRING);\n        if (text == null) {\n            _writeNull();\n            return;\n        }\n        \n        final int len = text.length();\n        if (len > _outputMaxContiguous) { \n            _writeStringSegments(text, true);\n            return;\n        }\n        if ((_outputTail + len) >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        _writeStringSegment(text, 0, len); \n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n\n    @Override\n    public void writeString(char[] text, int offset, int len) throws IOException {\n        _verifyValueWrite(WRITE_STRING);\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        \n        if (len <= _outputMaxContiguous) {\n            if ((_outputTail + len) > _outputEnd) { \n                _flushBuffer();\n            }\n            _writeStringSegment(text, offset, len);\n        } else {\n            _writeStringSegments(text, offset, len);\n        }\n        \n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n\n    @Override\n    public final void writeString(SerializableString text) throws IOException {\n        _verifyValueWrite(WRITE_STRING);\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        int len = text.appendQuotedUTF8(_outputBuffer, _outputTail);\n        if (len < 0) {\n            _writeBytes(text.asQuotedUTF8());\n        } else {\n            _outputTail += len;\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n    \n    @Override\n    public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException {\n        _verifyValueWrite(WRITE_STRING);\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        _writeBytes(text, offset, length);\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n\n    @Override\n    public void writeUTF8String(byte[] text, int offset, int len) throws IOException {\n        _verifyValueWrite(WRITE_STRING);\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        \n        if (len <= _outputMaxContiguous) {\n            _writeUTF8Segment(text, offset, len);\n        } else {\n            _writeUTF8Segments(text, offset, len);\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n\n    \n\n    @Override\n    public void writeRaw(String text) throws IOException {\n        writeRaw(text, 0, text.length());\n    }\n\n    @Override\n    public void writeRaw(String text, int offset, int len) throws IOException {\n        final char[] buf = _charBuffer;\n\n        \n        if (len <= buf.length) {\n            text.getChars(offset, offset+len, buf, 0);\n            _writeRawSegment(buf, 0, len);\n            return;\n        }\n\n        \n        \n        \n        final int maxChunk = (_outputEnd >> 2) + (_outputEnd >> 4); \n        final int maxBytes = maxChunk * 3;\n\n        while (len > 0) {\n            int len2 = Math.min(maxChunk, len);\n            text.getChars(offset, offset+len2, buf, 0);\n            if ((_outputTail + maxBytes) > _outputEnd) {\n                _flushBuffer();\n            }\n            \n            \n            if (len > 0) {\n                char ch = buf[len2-1];\n                if ((ch >= SURR1_FIRST) && (ch <= SURR1_LAST)) {\n                    --len2;\n                }\n            }\n            _writeRawSegment(buf, 0, len2);\n            offset += len2;\n            len -= len2;\n        }\n    }\n\n    @Override\n    public void writeRaw(SerializableString text) throws IOException {\n        byte[] raw = text.asUnquotedUTF8();\n        if (raw.length > 0) {\n            _writeBytes(raw);\n        }\n    }\n\n    \n    @Override\n    public void writeRawValue(SerializableString text) throws IOException {\n        _verifyValueWrite(WRITE_RAW);\n        byte[] raw = text.asUnquotedUTF8();\n        if (raw.length > 0) {\n            _writeBytes(raw);\n        }\n    }\n\n    \n    @Override\n    public final void writeRaw(char[] cbuf, int offset, int len) throws IOException {\n        \n        {\n            int len3 = len+len+len;\n            if ((_outputTail + len3) > _outputEnd) {\n                \n                if (_outputEnd < len3) { \n                    _writeSegmentedRaw(cbuf, offset, len);\n                    return;\n                }\n                \n                _flushBuffer();\n            }\n        }\n        len += offset; \n\n        \n        main_loop:\n        while (offset < len) {\n            inner_loop:\n            while (true) {\n                int ch = (int) cbuf[offset];\n                if (ch > 0x7F) {\n                    break inner_loop;\n                }\n                _outputBuffer[_outputTail++] = (byte) ch;\n                if (++offset >= len) {\n                    break main_loop;\n                }\n            }\n            char ch = cbuf[offset++];\n            if (ch < 0x800) { \n                _outputBuffer[_outputTail++] = (byte) (0xc0 | (ch >> 6));\n                _outputBuffer[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n            } else {\n                offset = _outputRawMultiByteChar(ch, cbuf, offset, len);\n            }\n        }\n    }\n\n    @Override\n    public void writeRaw(char ch) throws IOException {\n        if ((_outputTail + 3) >= _outputEnd) {\n            _flushBuffer();\n        }\n        final byte[] bbuf = _outputBuffer;\n        if (ch <= 0x7F) {\n            bbuf[_outputTail++] = (byte) ch;\n        } else  if (ch < 0x800) { \n            bbuf[_outputTail++] = (byte) (0xc0 | (ch >> 6));\n            bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n        } else {\n             _outputRawMultiByteChar(ch, null, 0, 0);\n        }\n    }\n\n    \n    private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException {\n        final int end = _outputEnd;\n        final byte[] bbuf = _outputBuffer;\n        final int inputEnd = offset + len;\n        \n        main_loop:\n        while (offset < inputEnd) {\n            inner_loop:\n            while (true) {\n                int ch = (int) cbuf[offset];\n                if (ch >= 0x80) {\n                    break inner_loop;\n                }\n                \n                if (_outputTail >= end) {\n                    _flushBuffer();\n                }\n                bbuf[_outputTail++] = (byte) ch;\n                if (++offset >= inputEnd) {\n                    break main_loop;\n                }\n            }\n            if ((_outputTail + 3) >= _outputEnd) {\n                _flushBuffer();\n            }\n            char ch = cbuf[offset++];\n            if (ch < 0x800) { \n                bbuf[_outputTail++] = (byte) (0xc0 | (ch >> 6));\n                bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n            } else {\n                offset = _outputRawMultiByteChar(ch, cbuf, offset, inputEnd);\n            }\n        }\n    }\n\n    \n    private void _writeRawSegment(char[] cbuf, int offset, int end) throws IOException {\n        main_loop:\n        while (offset < end) {\n            inner_loop:\n            while (true) {\n                int ch = (int) cbuf[offset];\n                if (ch > 0x7F) {\n                    break inner_loop;\n                }\n                _outputBuffer[_outputTail++] = (byte) ch;\n                if (++offset >= end) {\n                    break main_loop;\n                }\n            }\n            char ch = cbuf[offset++];\n            if (ch < 0x800) { \n                _outputBuffer[_outputTail++] = (byte) (0xc0 | (ch >> 6));\n                _outputBuffer[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n            } else {\n                offset = _outputRawMultiByteChar(ch, cbuf, offset, end);\n            }\n        }\n    }\n\n    \n\n    @Override\n    public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException {\n        _verifyValueWrite(WRITE_BINARY);\n        \n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        _writeBinary(b64variant, data, offset, offset+len);\n        \n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n\n    @Override\n    public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException {\n        _verifyValueWrite(WRITE_BINARY);\n        \n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        byte[] encodingBuffer = _ioContext.allocBase64Buffer();\n        int bytes;\n        try {\n            if (dataLength < 0) { \n                bytes = _writeBinary(b64variant, data, encodingBuffer);\n            } else {\n                int missing = _writeBinary(b64variant, data, encodingBuffer, dataLength);\n                if (missing > 0) {\n                    _reportError(\"Too few bytes available: missing \"+missing+\" bytes (out of \"+dataLength+\")\");\n                }\n                bytes = dataLength;\n            }\n        } finally {\n            _ioContext.releaseBase64Buffer(encodingBuffer);\n        }\n        \n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        return bytes;\n    }\n    \n    \n\n    @Override\n    public void writeNumber(short s) throws IOException {\n        _verifyValueWrite(WRITE_NUMBER);\n        \n        if ((_outputTail + 6) >= _outputEnd) {\n            _flushBuffer();\n        }\n        if (_cfgNumbersAsStrings) {\n            _writeQuotedShort(s);\n            return;\n        }\n        _outputTail = NumberOutput.outputInt(s, _outputBuffer, _outputTail);\n    }\n    \n    private final void _writeQuotedShort(short s) throws IOException {\n        if ((_outputTail + 8) >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        _outputTail = NumberOutput.outputInt(s, _outputBuffer, _outputTail);\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    } \n    \n    @Override\n    public void writeNumber(int i) throws IOException {\n        _verifyValueWrite(WRITE_NUMBER);\n        \n        if ((_outputTail + 11) >= _outputEnd) {\n            _flushBuffer();\n        }\n        if (_cfgNumbersAsStrings) {\n            _writeQuotedInt(i);\n            return;\n        }\n        _outputTail = NumberOutput.outputInt(i, _outputBuffer, _outputTail);\n    }\n\n    private final void _writeQuotedInt(int i) throws IOException {\n        if ((_outputTail + 13) >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        _outputTail = NumberOutput.outputInt(i, _outputBuffer, _outputTail);\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }    \n\n    @Override\n    public void writeNumber(long l) throws IOException {\n        _verifyValueWrite(WRITE_NUMBER);\n        if (_cfgNumbersAsStrings) {\n            _writeQuotedLong(l);\n            return;\n        }\n        if ((_outputTail + 21) >= _outputEnd) {\n            \n            _flushBuffer();\n        }\n        _outputTail = NumberOutput.outputLong(l, _outputBuffer, _outputTail);\n    }\n\n    private final void _writeQuotedLong(long l) throws IOException {\n        if ((_outputTail + 23) >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        _outputTail = NumberOutput.outputLong(l, _outputBuffer, _outputTail);\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n\n    @Override\n    public void writeNumber(BigInteger value) throws IOException {\n        _verifyValueWrite(WRITE_NUMBER);\n        if (value == null) {\n            _writeNull();\n        } else if (_cfgNumbersAsStrings) {\n            _writeQuotedRaw(value.toString());\n        } else {\n            writeRaw(value.toString());\n        }\n    }\n\n    \n    @Override\n    public void writeNumber(double d) throws IOException {\n        if (_cfgNumbersAsStrings ||\n            (((Double.isNaN(d) || Double.isInfinite(d))\n                && Feature.QUOTE_NON_NUMERIC_NUMBERS.enabledIn(_features)))) {\n            writeString(String.valueOf(d));\n            return;\n        }\n        \n        _verifyValueWrite(WRITE_NUMBER);\n        writeRaw(String.valueOf(d));\n    }\n\n    @Override\n    public void writeNumber(float f) throws IOException {\n        if (_cfgNumbersAsStrings ||\n            \n            (((Float.isNaN(f) || Float.isInfinite(f))\n                && Feature.QUOTE_NON_NUMERIC_NUMBERS.enabledIn(_features)))) {\n            writeString(String.valueOf(f));\n            return;\n        }\n        \n        _verifyValueWrite(WRITE_NUMBER);\n        writeRaw(String.valueOf(f));\n    }\n\n    @Override\n    public void writeNumber(BigDecimal value) throws IOException {\n        \n        _verifyValueWrite(WRITE_NUMBER);\n        if (value == null) {\n            _writeNull();\n        } else if (_cfgNumbersAsStrings) {\n            String raw = Feature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_features)\n                    ? value.toPlainString() : value.toString();\n            _writeQuotedRaw(raw);\n        } else if (Feature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_features)) {\n            writeRaw(value.toPlainString());\n        } else {\n            writeRaw(value.toString());\n        }\n    }\n\n    @Override\n    public void writeNumber(String encodedValue) throws IOException {\n        _verifyValueWrite(WRITE_NUMBER);\n        if (_cfgNumbersAsStrings) {\n            _writeQuotedRaw(encodedValue);            \n        } else {\n            writeRaw(encodedValue);\n        }\n    }\n\n    private final void _writeQuotedRaw(String value) throws IOException {\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        writeRaw(value);\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n    \n    @Override\n    public void writeBoolean(boolean state) throws IOException {\n        _verifyValueWrite(WRITE_BOOLEAN);\n        if ((_outputTail + 5) >= _outputEnd) {\n            _flushBuffer();\n        }\n        byte[] keyword = state ? TRUE_BYTES : FALSE_BYTES;\n        int len = keyword.length;\n        System.arraycopy(keyword, 0, _outputBuffer, _outputTail, len);\n        _outputTail += len;\n    }\n\n    @Override\n    public void writeNull() throws IOException {\n        _verifyValueWrite(WRITE_NULL);\n        _writeNull();\n    }\n\n    \n\n    @Override\n    protected final void _verifyValueWrite(String typeMsg) throws IOException {\n        int status = _writeContext.writeValue();\n        if (status == JsonWriteContext.STATUS_EXPECT_NAME) {\n            _reportError(\"Can not \"+typeMsg+\", expecting field name\");\n        }\n        if (_cfgPrettyPrinter == null) {\n            byte b;\n            switch (status) {\n            case JsonWriteContext.STATUS_OK_AFTER_COMMA:\n                b = BYTE_COMMA;\n                break;\n            case JsonWriteContext.STATUS_OK_AFTER_COLON:\n                b = BYTE_COLON;\n                break;\n            case JsonWriteContext.STATUS_OK_AFTER_SPACE: \n                if (_rootValueSeparator != null) {\n                    byte[] raw = _rootValueSeparator.asUnquotedUTF8();\n                    if (raw.length > 0) {\n                        _writeBytes(raw);\n                    }\n                }\n                return;\n            case JsonWriteContext.STATUS_OK_AS_IS:\n            default:\n                return;\n            }\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail] = b;\n            ++_outputTail;\n            return;\n        }\n        \n        _verifyPrettyValueWrite(typeMsg, status);\n    }\n\n    protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException {\n        \n        switch (status) {\n        case JsonWriteContext.STATUS_OK_AFTER_COMMA: \n            _cfgPrettyPrinter.writeArrayValueSeparator(this);\n            break;\n        case JsonWriteContext.STATUS_OK_AFTER_COLON:\n            _cfgPrettyPrinter.writeObjectFieldValueSeparator(this);\n            break;\n        case JsonWriteContext.STATUS_OK_AFTER_SPACE:\n            _cfgPrettyPrinter.writeRootValueSeparator(this);\n            break;\n        case JsonWriteContext.STATUS_OK_AS_IS:\n            \n            if (_writeContext.inArray()) {\n                _cfgPrettyPrinter.beforeArrayValues(this);\n            } else if (_writeContext.inObject()) {\n                _cfgPrettyPrinter.beforeObjectEntries(this);\n            }\n            break;\n        default:\n            _throwInternal();\n            break;\n        }\n    }\n\n    \n\n    @Override\n    public void flush() throws IOException {\n        _flushBuffer();\n        if (_outputStream != null) {\n            if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) {\n                _outputStream.flush();\n            }\n        }\n    }\n\n    @Override\n    public void close() throws IOException {\n        super.close();\n\n        \n        \n        if ((_outputBuffer != null)\n            && isEnabled(Feature.AUTO_CLOSE_JSON_CONTENT)) {\n            while (true) {\n                JsonStreamContext ctxt = getOutputContext();\n                if (ctxt.inArray()) {\n                    writeEndArray();\n                } else if (ctxt.inObject()) {\n                    writeEndObject();\n                } else {\n                    break;\n                }\n            }\n        }\n        _flushBuffer();\n        _outputTail = 0; \n\n        \n        if (_outputStream != null) {\n            if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_TARGET)) {\n                _outputStream.close();\n            } else if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) {\n                \n                _outputStream.flush();\n            }\n        }\n        \n        _releaseBuffers();\n    }\n\n    @Override\n    protected void _releaseBuffers() {\n        byte[] buf = _outputBuffer;\n        if (buf != null && _bufferRecyclable) {\n            _outputBuffer = null;\n            _ioContext.releaseWriteEncodingBuffer(buf);\n        }\n        char[] cbuf = _charBuffer;\n        if (cbuf != null) {\n            _charBuffer = null;\n            _ioContext.releaseConcatBuffer(cbuf);\n        }\n    }\n\n    \n\n    private final void _writeBytes(byte[] bytes) throws IOException {\n        final int len = bytes.length;\n        if ((_outputTail + len) > _outputEnd) {\n            _flushBuffer();\n            \n            if (len > MAX_BYTES_TO_BUFFER) {\n                _outputStream.write(bytes, 0, len);\n                return;\n            }\n        }\n        System.arraycopy(bytes, 0, _outputBuffer, _outputTail, len);\n        _outputTail += len;\n    }\n\n    private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException {\n        if ((_outputTail + len) > _outputEnd) {\n            _flushBuffer();\n            \n            if (len > MAX_BYTES_TO_BUFFER) {\n                _outputStream.write(bytes, offset, len);\n                return;\n            }\n        }\n        System.arraycopy(bytes, offset, _outputBuffer, _outputTail, len);\n        _outputTail += len;\n    }\n\n    \n    \n    \n    private final void _writeStringSegments(String text, boolean addQuotes) throws IOException {\n        if (addQuotes) {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_QUOTE;        \n        }\n\n        int left = text.length();\n        int offset = 0;\n\n        while (left > 0) {\n            int len = Math.min(_outputMaxContiguous, left);\n            if ((_outputTail + len) > _outputEnd) { \n                _flushBuffer();\n            }\n            _writeStringSegment(text, offset, len);\n            offset += len;\n            left -= len;\n        }\n\n        if (addQuotes) {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        }\n    }\n\n    \n    private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException {\n        do {\n            int len = Math.min(_outputMaxContiguous, totalLen);\n            if ((_outputTail + len) > _outputEnd) { \n                _flushBuffer();\n            }\n            _writeStringSegment(cbuf, offset, len);\n            offset += len;\n            totalLen -= len;\n        } while (totalLen > 0);\n    }\n\n    private final void _writeStringSegments(String text, int offset, int totalLen) throws IOException {\n        do {\n            int len = Math.min(_outputMaxContiguous, totalLen);\n            if ((_outputTail + len) > _outputEnd) { \n                _flushBuffer();\n            }\n            _writeStringSegment(text, offset, len);\n            offset += len;\n            totalLen -= len;\n        } while (totalLen > 0);\n    }\n\n    \n\n    \n    private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException {\n        \n        \n        \n        len += offset; \n\n        int outputPtr = _outputTail;\n        final byte[] outputBuffer = _outputBuffer;\n        final int[] escCodes = _outputEscapes;\n\n        while (offset < len) {\n            int ch = cbuf[offset];\n            \n            if (ch > 0x7F || escCodes[ch] != 0) {\n                break;\n            }\n            outputBuffer[outputPtr++] = (byte) ch;\n            ++offset;\n        }\n        _outputTail = outputPtr;\n        if (offset < len) {\n            \n            if (_characterEscapes != null) {\n                _writeCustomStringSegment2(cbuf, offset, len);\n            \n            } else if (_maximumNonEscapedChar == 0) {\n                _writeStringSegment2(cbuf, offset, len);\n            } else {\n                _writeStringSegmentASCII2(cbuf, offset, len);\n            }\n\n        }\n    }\n\n    private final void _writeStringSegment(String text, int offset, int len) throws IOException {\n        \n        \n        len += offset; \n\n        int outputPtr = _outputTail;\n        final byte[] outputBuffer = _outputBuffer;\n        final int[] escCodes = _outputEscapes;\n\n        while (offset < len) {\n            int ch = text.charAt(offset);\n            \n            if (ch > 0x7F || escCodes[ch] != 0) {\n                break;\n            }\n            outputBuffer[outputPtr++] = (byte) ch;\n            ++offset;\n        }\n        _outputTail = outputPtr;\n        if (offset < len) {\n            if (_characterEscapes != null) {\n                _writeCustomStringSegment2(text, offset, len);\n            } else if (_maximumNonEscapedChar == 0) {\n                _writeStringSegment2(text, offset, len);\n            } else {\n                _writeStringSegmentASCII2(text, offset, len);\n            }\n        }\n    }\n\n    \n    private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException {\n        \n        if ((_outputTail +  6 * (end - offset)) > _outputEnd) {\n            _flushBuffer();\n        }\n\n        int outputPtr = _outputTail;\n\n        final byte[] outputBuffer = _outputBuffer;\n        final int[] escCodes = _outputEscapes;\n        \n        while (offset < end) {\n            int ch = cbuf[offset++];\n            if (ch <= 0x7F) {\n                 if (escCodes[ch] == 0) {\n                     outputBuffer[outputPtr++] = (byte) ch;\n                     continue;\n                 }\n                 int escape = escCodes[ch];\n                 if (escape > 0) { \n                     outputBuffer[outputPtr++] = BYTE_BACKSLASH;\n                     outputBuffer[outputPtr++] = (byte) escape;\n                 } else {\n                     \n                     outputPtr = _writeGenericEscape(ch, outputPtr);\n                }\n                continue;\n            }\n            if (ch <= 0x7FF) { \n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f));\n            } else {\n                outputPtr = _outputMultiByteChar(ch, outputPtr);\n            }\n        }\n        _outputTail = outputPtr;\n    }\n\n    private final void _writeStringSegment2(final String text, int offset, final int end) throws IOException {\n        if ((_outputTail +  6 * (end - offset)) > _outputEnd) {\n            _flushBuffer();\n        }\n\n        int outputPtr = _outputTail;\n\n        final byte[] outputBuffer = _outputBuffer;\n        final int[] escCodes = _outputEscapes;\n        \n        while (offset < end) {\n            int ch = text.charAt(offset++);\n            if (ch <= 0x7F) {\n                 if (escCodes[ch] == 0) {\n                     outputBuffer[outputPtr++] = (byte) ch;\n                     continue;\n                 }\n                 int escape = escCodes[ch];\n                 if (escape > 0) { \n                     outputBuffer[outputPtr++] = BYTE_BACKSLASH;\n                     outputBuffer[outputPtr++] = (byte) escape;\n                 } else {\n                     \n                     outputPtr = _writeGenericEscape(ch, outputPtr);\n                }\n                continue;\n            }\n            if (ch <= 0x7FF) { \n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f));\n            } else {\n                outputPtr = _outputMultiByteChar(ch, outputPtr);\n            }\n        }\n        _outputTail = outputPtr;\n    }\n    \n    \n\n    \n    private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException {\n        \n        if ((_outputTail +  6 * (end - offset)) > _outputEnd) {\n            _flushBuffer();\n        }\n    \n        int outputPtr = _outputTail;\n    \n        final byte[] outputBuffer = _outputBuffer;\n        final int[] escCodes = _outputEscapes;\n        final int maxUnescaped = _maximumNonEscapedChar;\n        \n        while (offset < end) {\n            int ch = cbuf[offset++];\n            if (ch <= 0x7F) {\n                 if (escCodes[ch] == 0) {\n                     outputBuffer[outputPtr++] = (byte) ch;\n                     continue;\n                 }\n                 int escape = escCodes[ch];\n                 if (escape > 0) { \n                     outputBuffer[outputPtr++] = BYTE_BACKSLASH;\n                     outputBuffer[outputPtr++] = (byte) escape;\n                 } else {\n                     \n                     outputPtr = _writeGenericEscape(ch, outputPtr);\n                 }\n                 continue;\n            }\n            if (ch > maxUnescaped) { \n                outputPtr = _writeGenericEscape(ch, outputPtr);\n                continue;\n            }\n            if (ch <= 0x7FF) { \n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f));\n            } else {\n                outputPtr = _outputMultiByteChar(ch, outputPtr);\n            }\n        }\n        _outputTail = outputPtr;\n    }\n\n    private final void _writeStringSegmentASCII2(final String text, int offset, final int end) throws IOException {\n        \n        if ((_outputTail +  6 * (end - offset)) > _outputEnd) {\n            _flushBuffer();\n        }\n    \n        int outputPtr = _outputTail;\n    \n        final byte[] outputBuffer = _outputBuffer;\n        final int[] escCodes = _outputEscapes;\n        final int maxUnescaped = _maximumNonEscapedChar;\n        \n        while (offset < end) {\n            int ch = text.charAt(offset++);\n            if (ch <= 0x7F) {\n                 if (escCodes[ch] == 0) {\n                     outputBuffer[outputPtr++] = (byte) ch;\n                     continue;\n                 }\n                 int escape = escCodes[ch];\n                 if (escape > 0) { \n                     outputBuffer[outputPtr++] = BYTE_BACKSLASH;\n                     outputBuffer[outputPtr++] = (byte) escape;\n                 } else {\n                     \n                     outputPtr = _writeGenericEscape(ch, outputPtr);\n                 }\n                 continue;\n            }\n            if (ch > maxUnescaped) { \n                outputPtr = _writeGenericEscape(ch, outputPtr);\n                continue;\n            }\n            if (ch <= 0x7FF) { \n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f));\n            } else {\n                outputPtr = _outputMultiByteChar(ch, outputPtr);\n            }\n        }\n        _outputTail = outputPtr;\n    }\n    \n    \n\n    \n    private final void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException {\n        \n        if ((_outputTail +  6 * (end - offset)) > _outputEnd) {\n            _flushBuffer();\n        }\n        int outputPtr = _outputTail;\n    \n        final byte[] outputBuffer = _outputBuffer;\n        final int[] escCodes = _outputEscapes;\n        \n        final int maxUnescaped = (_maximumNonEscapedChar <= 0) ? 0xFFFF : _maximumNonEscapedChar;\n        final CharacterEscapes customEscapes = _characterEscapes; \n        \n        while (offset < end) {\n            int ch = cbuf[offset++];\n            if (ch <= 0x7F) {\n                 if (escCodes[ch] == 0) {\n                     outputBuffer[outputPtr++] = (byte) ch;\n                     continue;\n                 }\n                 int escape = escCodes[ch];\n                 if (escape > 0) { \n                     outputBuffer[outputPtr++] = BYTE_BACKSLASH;\n                     outputBuffer[outputPtr++] = (byte) escape;\n                 } else if (escape == CharacterEscapes.ESCAPE_CUSTOM) {\n                     SerializableString esc = customEscapes.getEscapeSequence(ch);\n                     if (esc == null) {\n                         _reportError(\"Invalid custom escape definitions; custom escape not found for character code 0x\"\n                                 +Integer.toHexString(ch)+\", although was supposed to have one\");\n                     }\n                     outputPtr = _writeCustomEscape(outputBuffer, outputPtr, esc, end-offset);\n                 } else {\n                     \n                     outputPtr = _writeGenericEscape(ch, outputPtr);\n                 }\n                 continue;\n            }\n            if (ch > maxUnescaped) { \n                outputPtr = _writeGenericEscape(ch, outputPtr);\n                continue;\n            }\n            SerializableString esc = customEscapes.getEscapeSequence(ch);\n            if (esc != null) {\n                outputPtr = _writeCustomEscape(outputBuffer, outputPtr, esc, end-offset);\n                continue;\n            }\n            if (ch <= 0x7FF) { \n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f));\n            } else {\n                outputPtr = _outputMultiByteChar(ch, outputPtr);\n            }\n        }\n        _outputTail = outputPtr;\n    }\n\n    private final void _writeCustomStringSegment2(final String text, int offset, final int end) throws IOException {\n        \n        if ((_outputTail +  6 * (end - offset)) > _outputEnd) {\n            _flushBuffer();\n        }\n        int outputPtr = _outputTail;\n    \n        final byte[] outputBuffer = _outputBuffer;\n        final int[] escCodes = _outputEscapes;\n        \n        final int maxUnescaped = (_maximumNonEscapedChar <= 0) ? 0xFFFF : _maximumNonEscapedChar;\n        final CharacterEscapes customEscapes = _characterEscapes; \n        \n        while (offset < end) {\n            int ch = text.charAt(offset++);\n            if (ch <= 0x7F) {\n                 if (escCodes[ch] == 0) {\n                     outputBuffer[outputPtr++] = (byte) ch;\n                     continue;\n                 }\n                 int escape = escCodes[ch];\n                 if (escape > 0) { \n                     outputBuffer[outputPtr++] = BYTE_BACKSLASH;\n                     outputBuffer[outputPtr++] = (byte) escape;\n                 } else if (escape == CharacterEscapes.ESCAPE_CUSTOM) {\n                     SerializableString esc = customEscapes.getEscapeSequence(ch);\n                     if (esc == null) {\n                         _reportError(\"Invalid custom escape definitions; custom escape not found for character code 0x\"\n                                 +Integer.toHexString(ch)+\", although was supposed to have one\");\n                     }\n                     outputPtr = _writeCustomEscape(outputBuffer, outputPtr, esc, end-offset);\n                 } else {\n                     \n                     outputPtr = _writeGenericEscape(ch, outputPtr);\n                 }\n                 continue;\n            }\n            if (ch > maxUnescaped) { \n                outputPtr = _writeGenericEscape(ch, outputPtr);\n                continue;\n            }\n            SerializableString esc = customEscapes.getEscapeSequence(ch);\n            if (esc != null) {\n                outputPtr = _writeCustomEscape(outputBuffer, outputPtr, esc, end-offset);\n                continue;\n            }\n            if (ch <= 0x7FF) { \n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f));\n            } else {\n                outputPtr = _outputMultiByteChar(ch, outputPtr);\n            }\n        }\n        _outputTail = outputPtr;\n    }\n\n    private final int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException {\n        byte[] raw = esc.asUnquotedUTF8(); \n        int len = raw.length;\n        if (len > 6) { \n            return _handleLongCustomEscape(outputBuffer, outputPtr, _outputEnd, raw, remainingChars);\n        }\n        \n        System.arraycopy(raw, 0, outputBuffer, outputPtr, len);\n        return (outputPtr + len);\n    }\n    \n    private final int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException {\n        int len = raw.length;\n        if ((outputPtr + len) > outputEnd) {\n            _outputTail = outputPtr;\n            _flushBuffer();\n            outputPtr = _outputTail;\n            if (len > outputBuffer.length) { \n                _outputStream.write(raw, 0, len);\n                return outputPtr;\n            }\n            System.arraycopy(raw, 0, outputBuffer, outputPtr, len);\n            outputPtr += len;\n        }\n        \n        if ((outputPtr +  6 * remainingChars) > outputEnd) {\n            _flushBuffer();\n            return _outputTail;\n        }\n        return outputPtr;\n    }\n\n    \n    \n    \n    private final void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException {\n        do {\n            int len = Math.min(_outputMaxContiguous, totalLen);\n            _writeUTF8Segment(utf8, offset, len);\n            offset += len;\n            totalLen -= len;\n        } while (totalLen > 0);\n    }\n    \n    private final void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException {\n        \n        final int[] escCodes = _outputEscapes;\n\n        for (int ptr = offset, end = offset + len; ptr < end; ) {\n            \n            int ch = utf8[ptr++];\n            if ((ch >= 0) && escCodes[ch] != 0) {\n                _writeUTF8Segment2(utf8, offset, len);\n                return;\n            }\n        }\n        \n        \n        if ((_outputTail + len) > _outputEnd) { \n            _flushBuffer(); \n        }\n        System.arraycopy(utf8, offset, _outputBuffer, _outputTail, len);\n        _outputTail += len;\n    }\n\n    private final void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException {\n        int outputPtr = _outputTail;\n\n        \n        if ((outputPtr + (len * 6)) > _outputEnd) {\n            _flushBuffer();\n            outputPtr = _outputTail;\n        }\n        \n        final byte[] outputBuffer = _outputBuffer;\n        final int[] escCodes = _outputEscapes;\n        len += offset; \n        \n        while (offset < len) {\n            byte b = utf8[offset++];\n            int ch = b;\n            if (ch < 0 || escCodes[ch] == 0) {\n                outputBuffer[outputPtr++] = b;\n                continue;\n            }\n            int escape = escCodes[ch];\n            if (escape > 0) { \n                outputBuffer[outputPtr++] = BYTE_BACKSLASH;\n                outputBuffer[outputPtr++] = (byte) escape;\n            } else {\n                \n                outputPtr = _writeGenericEscape(ch, outputPtr);\n            }\n        }\n        _outputTail = outputPtr;\n    }\n    \n    \n    \n    protected final void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException {\n        \n        int safeInputEnd = inputEnd - 3;\n        \n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        \n        while (inputPtr <= safeInputEnd) {\n            if (_outputTail > safeOutputEnd) { \n                _flushBuffer();\n            }\n            \n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                \n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        \n        int inputLeft = inputEnd - inputPtr; \n        if (inputLeft > 0) { \n            if (_outputTail > safeOutputEnd) { \n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }\n\n    \n    protected final int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;       \n        \n        \n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        while (bytesLeft > 2) { \n            if (inputPtr > lastFullOffset) {\n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n                inputPtr = 0;\n                if (inputEnd < 3) { \n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { \n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesLeft -= 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n        \n        \n        if (bytesLeft > 0) {\n            inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n            inputPtr = 0;\n            if (inputEnd > 0) { \n                if (_outputTail > safeOutputEnd) { \n                    _flushBuffer();\n                }\n                int b24 = ((int) readBuffer[inputPtr++]) << 16;\n                int amount;\n                if (inputPtr < inputEnd) {\n                    b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                    amount = 2;\n                } else {\n                    amount = 1;\n                }\n                _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n                bytesLeft -= amount;\n            }\n        }\n        return bytesLeft;\n    }\n\n    \n    protected final int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;\n        int bytesDone = 0;\n        \n        \n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        \n        while (true) {\n            if (inputPtr > lastFullOffset) { \n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, readBuffer.length);\n                inputPtr = 0;\n                if (inputEnd < 3) { \n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { \n                _flushBuffer();\n            }\n            \n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesDone += 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        \n        if (inputPtr < inputEnd) { \n            if (_outputTail > safeOutputEnd) { \n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 16;\n            int amount = 1;\n            if (inputPtr < inputEnd) {\n                b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                amount = 2;\n            }\n            bytesDone += amount;\n            _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n        }\n        return bytesDone;\n    }\n    \n    private final int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException {\n        \n        int i = 0;\n        while (inputPtr < inputEnd) {\n            readBuffer[i++]  = readBuffer[inputPtr++];\n        }\n        inputPtr = 0;\n        inputEnd = i;\n        maxRead = Math.min(maxRead, readBuffer.length);\n        \n        do {\n            int length = maxRead - inputEnd;\n            if (length == 0) {\n                break;\n            }\n            int count = in.read(readBuffer, inputEnd, length);            \n            if (count < 0) {\n                return inputEnd;\n            }\n            inputEnd += count;\n        } while (inputEnd < 3);\n        return inputEnd;\n    }\n    \n    \n    \n    \n    private final int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputEnd) throws IOException {\n        \n        if (ch >= SURR1_FIRST) {\n            if (ch <= SURR2_LAST) { \n                \n                if (inputOffset >= inputEnd || cbuf == null) { \n                    _reportError(String.format(\n\"Split surrogate on writeRaw() input (last character): first character 0x%4x\", ch));\n                }\n                _outputSurrogates(ch, cbuf[inputOffset]);\n                return inputOffset+1;\n            }\n        }\n        final byte[] bbuf = _outputBuffer;\n        bbuf[_outputTail++] = (byte) (0xe0 | (ch >> 12));\n        bbuf[_outputTail++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n        bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n        return inputOffset;\n    }\n\n    protected final void _outputSurrogates(int surr1, int surr2) throws IOException {\n        int c = _decodeSurrogate(surr1, surr2);\n        if ((_outputTail + 4) > _outputEnd) {\n            _flushBuffer();\n        }\n        final byte[] bbuf = _outputBuffer;\n        bbuf[_outputTail++] = (byte) (0xf0 | (c >> 18));\n        bbuf[_outputTail++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n        bbuf[_outputTail++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n        bbuf[_outputTail++] = (byte) (0x80 | (c & 0x3f));\n    }\n    \n    \n    private final int _outputMultiByteChar(int ch, int outputPtr) throws IOException {\n        byte[] bbuf = _outputBuffer;\n        if (ch >= SURR1_FIRST && ch <= SURR2_LAST) { \n            \n            \n            \n\n                bbuf[outputPtr++] = BYTE_BACKSLASH;\n                bbuf[outputPtr++] = BYTE_u;\n                \n                bbuf[outputPtr++] = HEX_CHARS[(ch >> 12) & 0xF];\n                bbuf[outputPtr++] = HEX_CHARS[(ch >> 8) & 0xF];\n                bbuf[outputPtr++] = HEX_CHARS[(ch >> 4) & 0xF];\n                bbuf[outputPtr++] = HEX_CHARS[ch & 0xF];\n\n        } else {\n            bbuf[outputPtr++] = (byte) (0xe0 | (ch >> 12));\n            bbuf[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n            bbuf[outputPtr++] = (byte) (0x80 | (ch & 0x3f));\n        }\n        return outputPtr;\n    }\n\n    private final void _writeNull() throws IOException {\n        if ((_outputTail + 4) >= _outputEnd) {\n            _flushBuffer();\n        }\n        System.arraycopy(NULL_BYTES, 0, _outputBuffer, _outputTail, 4);\n        _outputTail += 4;\n    }\n        \n    \n    private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException {\n        final byte[] bbuf = _outputBuffer;\n        bbuf[outputPtr++] = BYTE_BACKSLASH;\n        bbuf[outputPtr++] = BYTE_u;\n        if (charToEscape > 0xFF) {\n            int hi = (charToEscape >> 8) & 0xFF;\n            bbuf[outputPtr++] = HEX_CHARS[hi >> 4];\n            bbuf[outputPtr++] = HEX_CHARS[hi & 0xF];\n            charToEscape &= 0xFF;\n        } else {\n            bbuf[outputPtr++] = BYTE_0;\n            bbuf[outputPtr++] = BYTE_0;\n        }\n        \n        bbuf[outputPtr++] = HEX_CHARS[charToEscape >> 4];\n        bbuf[outputPtr++] = HEX_CHARS[charToEscape & 0xF];\n        return outputPtr;\n    }\n\n    protected final void _flushBuffer() throws IOException {\n        int len = _outputTail;\n        if (len > 0) {\n            _outputTail = 0;\n            _outputStream.write(_outputBuffer, 0, len);\n        }\n    }\n}\n",
      "buggy_signatures": [
        "public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable)",
        "public Object getOutputTarget()",
        "public int getOutputBuffered()",
        "public void writeFieldName(String name) throws IOException",
        "public void writeFieldName(SerializableString name) throws IOException",
        "private final void _writeUnq(SerializableString name) throws IOException",
        "public final void writeStartArray() throws IOException",
        "public final void writeEndArray() throws IOException",
        "public final void writeStartObject() throws IOException",
        "public final void writeEndObject() throws IOException",
        "protected final void _writePPFieldName(String name) throws IOException",
        "protected final void _writePPFieldName(SerializableString name) throws IOException",
        "public void writeString(String text) throws IOException",
        "public void writeString(char[] text, int offset, int len) throws IOException",
        "public final void writeString(SerializableString text) throws IOException",
        "public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException",
        "public void writeUTF8String(byte[] text, int offset, int len) throws IOException",
        "public void writeRaw(String text) throws IOException",
        "public void writeRaw(String text, int offset, int len) throws IOException",
        "public void writeRaw(SerializableString text) throws IOException",
        "public void writeRawValue(SerializableString text) throws IOException",
        "public final void writeRaw(char[] cbuf, int offset, int len) throws IOException",
        "public void writeRaw(char ch) throws IOException",
        "private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException",
        "public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException",
        "public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException",
        "public void writeNumber(short s) throws IOException",
        "private final void _writeQuotedShort(short s) throws IOException",
        "public void writeNumber(int i) throws IOException",
        "private final void _writeQuotedInt(int i) throws IOException",
        "public void writeNumber(long l) throws IOException",
        "private final void _writeQuotedLong(long l) throws IOException",
        "public void writeNumber(BigInteger value) throws IOException",
        "public void writeNumber(double d) throws IOException",
        "public void writeNumber(float f) throws IOException",
        "public void writeNumber(BigDecimal value) throws IOException",
        "public void writeNumber(String encodedValue) throws IOException",
        "private final void _writeQuotedRaw(String value) throws IOException",
        "public void writeBoolean(boolean state) throws IOException",
        "public void writeNull() throws IOException",
        "protected final void _verifyValueWrite(String typeMsg) throws IOException",
        "protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException",
        "public void flush() throws IOException",
        "public void close() throws IOException",
        "protected void _releaseBuffers()",
        "private final void _writeBytes(byte[] bytes) throws IOException",
        "private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException",
        "private final void _writeStringSegments(String text, boolean addQuotes) throws IOException",
        "private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException",
        "private final void _writeStringSegments(String text, int offset, int totalLen) throws IOException",
        "private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException",
        "private final void _writeStringSegment(String text, int offset, int len) throws IOException",
        "private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException",
        "private final void _writeStringSegment2(final String text, int offset, final int end) throws IOException",
        "private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException",
        "private final void _writeStringSegmentASCII2(final String text, int offset, final int end) throws IOException",
        "private final void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException",
        "private final void _writeCustomStringSegment2(final String text, int offset, final int end) throws IOException",
        "private final int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException",
        "private final int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException",
        "private final void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException",
        "private final void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException",
        "private final void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException",
        "protected final void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException",
        "protected final int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException",
        "protected final int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException",
        "private final int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException",
        "private final int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputEnd) throws IOException",
        "protected final void _outputSurrogates(int surr1, int surr2) throws IOException",
        "private final int _outputMultiByteChar(int ch, int outputPtr) throws IOException",
        "private final void _writeNull() throws IOException",
        "private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException",
        "protected final void _flushBuffer() throws IOException"
      ],
      "fixed_signatures": [
        "public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable)",
        "public Object getOutputTarget()",
        "public int getOutputBuffered()",
        "public void writeFieldName(String name) throws IOException",
        "public void writeFieldName(SerializableString name) throws IOException",
        "private final void _writeUnq(SerializableString name) throws IOException",
        "public final void writeStartArray() throws IOException",
        "public final void writeEndArray() throws IOException",
        "public final void writeStartObject() throws IOException",
        "public final void writeEndObject() throws IOException",
        "protected final void _writePPFieldName(String name) throws IOException",
        "protected final void _writePPFieldName(SerializableString name) throws IOException",
        "public void writeString(String text) throws IOException",
        "public void writeString(char[] text, int offset, int len) throws IOException",
        "public final void writeString(SerializableString text) throws IOException",
        "public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException",
        "public void writeUTF8String(byte[] text, int offset, int len) throws IOException",
        "public void writeRaw(String text) throws IOException",
        "public void writeRaw(String text, int offset, int len) throws IOException",
        "public void writeRaw(SerializableString text) throws IOException",
        "public void writeRawValue(SerializableString text) throws IOException",
        "public final void writeRaw(char[] cbuf, int offset, int len) throws IOException",
        "public void writeRaw(char ch) throws IOException",
        "private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException",
        "private void _writeRawSegment(char[] cbuf, int offset, int end) throws IOException",
        "public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException",
        "public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException",
        "public void writeNumber(short s) throws IOException",
        "private final void _writeQuotedShort(short s) throws IOException",
        "public void writeNumber(int i) throws IOException",
        "private final void _writeQuotedInt(int i) throws IOException",
        "public void writeNumber(long l) throws IOException",
        "private final void _writeQuotedLong(long l) throws IOException",
        "public void writeNumber(BigInteger value) throws IOException",
        "public void writeNumber(double d) throws IOException",
        "public void writeNumber(float f) throws IOException",
        "public void writeNumber(BigDecimal value) throws IOException",
        "public void writeNumber(String encodedValue) throws IOException",
        "private final void _writeQuotedRaw(String value) throws IOException",
        "public void writeBoolean(boolean state) throws IOException",
        "public void writeNull() throws IOException",
        "protected final void _verifyValueWrite(String typeMsg) throws IOException",
        "protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException",
        "public void flush() throws IOException",
        "public void close() throws IOException",
        "protected void _releaseBuffers()",
        "private final void _writeBytes(byte[] bytes) throws IOException",
        "private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException",
        "private final void _writeStringSegments(String text, boolean addQuotes) throws IOException",
        "private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException",
        "private final void _writeStringSegments(String text, int offset, int totalLen) throws IOException",
        "private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException",
        "private final void _writeStringSegment(String text, int offset, int len) throws IOException",
        "private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException",
        "private final void _writeStringSegment2(final String text, int offset, final int end) throws IOException",
        "private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException",
        "private final void _writeStringSegmentASCII2(final String text, int offset, final int end) throws IOException",
        "private final void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException",
        "private final void _writeCustomStringSegment2(final String text, int offset, final int end) throws IOException",
        "private final int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException",
        "private final int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException",
        "private final void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException",
        "private final void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException",
        "private final void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException",
        "protected final void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException",
        "protected final int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException",
        "protected final int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException",
        "private final int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException",
        "private final int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputEnd) throws IOException",
        "protected final void _outputSurrogates(int surr1, int surr2) throws IOException",
        "private final int _outputMultiByteChar(int ch, int outputPtr) throws IOException",
        "private final void _writeNull() throws IOException",
        "private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException",
        "protected final void _flushBuffer() throws IOException"
      ],
      "methods": [
        {
          "buggy_method": "  public void writeRaw(String text, int offset, int len) throws IOException {\n  final char[] buf = _charBuffer;\n\n  \n\n  \n  \n  \n\n  while (len > 0) {\n  int len2 = Math.min(buf.length, len);\n  text.getChars(offset, offset+len2, buf, 0);\n  writeRaw(buf, 0, len2);\n  \n  \n  offset += len2;\n  len -= len2;\n  }\n  }",
          "fixed_method": "  public void writeRaw(String text, int offset, int len) throws IOException {\n  final char[] buf = _charBuffer;\n\n  \n  if (len <= buf.length) {\n  text.getChars(offset, offset+len, buf, 0);\n  _writeRawSegment(buf, 0, len);\n  return;\n  }\n\n  \n  \n  \n  final int maxChunk = (_outputEnd >> 2) + (_outputEnd >> 4); \n  final int maxBytes = maxChunk * 3;\n\n  while (len > 0) {\n  int len2 = Math.min(maxChunk, len);\n  text.getChars(offset, offset+len2, buf, 0);\n  if ((_outputTail + maxBytes) > _outputEnd) {\n  _flushBuffer();\n  }\n  \n  \n  if (len > 0) {\n  char ch = buf[len2-1];\n  if ((ch >= SURR1_FIRST) && (ch <= SURR1_LAST)) {\n  --len2;\n  }\n  }\n  _writeRawSegment(buf, 0, len2);\n  offset += len2;\n  len -= len2;\n  }\n  }",
          "diff": [
            "@@ -525,17 +525,33 @@",
            "         final char[] buf = _charBuffer;\n",
            " \n",
            "         // minor optimization: see if we can just get and copy\n",
            "+        if (len <= buf.length) {\n",
            "+            text.getChars(offset, offset+len, buf, 0);\n",
            "+            _writeRawSegment(buf, 0, len);\n",
            "+            return;\n",
            "+        }\n",
            " \n",
            "         // If not, need segmented approach. For speed, let's also use input buffer\n",
            "         // size that is guaranteed to fit in output buffer; each char can expand to\n",
            "         // at most 3 bytes, so at most 1/3 of buffer size.\n",
            "+        final int maxChunk = (_outputEnd >> 2) + (_outputEnd >> 4); // == (1/4 + 1/16) == 5/16\n",
            "+        final int maxBytes = maxChunk * 3;\n",
            " \n",
            "         while (len > 0) {\n",
            "-            int len2 = Math.min(buf.length, len);\n",
            "+            int len2 = Math.min(maxChunk, len);\n",
            "             text.getChars(offset, offset+len2, buf, 0);\n",
            "-            writeRaw(buf, 0, len2);\n",
            "+            if ((_outputTail + maxBytes) > _outputEnd) {\n",
            "+                _flushBuffer();\n",
            "+            }\n",
            "             // If this is NOT the last segment and if the last character looks like\n",
            "             // split surrogate second half, drop it\n",
            "+            if (len > 0) {\n",
            "+                char ch = buf[len2-1];\n",
            "+                if ((ch >= SURR1_FIRST) && (ch <= SURR1_LAST)) {\n",
            "+                    --len2;\n",
            "+                }\n",
            "+            }\n",
            "+            _writeRawSegment(buf, 0, len2);\n",
            "             offset += len2;\n",
            "             len -= len2;\n",
            "         }\n"
          ],
          "changed_lines": 20
        },
        {
          "buggy_method": "  private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException {\n  final int end = _outputEnd;\n  final byte[] bbuf = _outputBuffer;\n  final int inputEnd = offset + len;\n  \n  main_loop:\n  while (offset < inputEnd) {\n  inner_loop:\n  while (true) {\n  int ch = (int) cbuf[offset];\n  if (ch >= 0x80) {\n  break inner_loop;\n  }\n  \n  if (_outputTail >= end) {\n  _flushBuffer();\n  }\n  bbuf[_outputTail++] = (byte) ch;\n  if (++offset >= inputEnd) {\n  break main_loop;\n  }\n  }\n  if ((_outputTail + 3) >= _outputEnd) {\n  _flushBuffer();\n  }\n  char ch = cbuf[offset++];\n  if (ch < 0x800) { \n  bbuf[_outputTail++] = (byte) (0xc0 | (ch >> 6));\n  bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n  } else {\n  offset = _outputRawMultiByteChar(ch, cbuf, offset, inputEnd);\n  }\n  }\n  }",
          "fixed_method": "  private void _writeRawSegment(char[] cbuf, int offset, int end) throws IOException {\n  main_loop:\n  while (offset < end) {\n  inner_loop:\n  while (true) {\n  int ch = (int) cbuf[offset];\n  if (ch > 0x7F) {\n  break inner_loop;\n  }\n  _outputBuffer[_outputTail++] = (byte) ch;\n  if (++offset >= end) {\n  break main_loop;\n  }\n  }\n  char ch = cbuf[offset++];\n  if (ch < 0x800) { \n  _outputBuffer[_outputTail++] = (byte) (0xc0 | (ch >> 6));\n  _outputBuffer[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n  } else {\n  offset = _outputRawMultiByteChar(ch, cbuf, offset, end);\n  }\n  }\n  }",
          "diff": [
            "@@ -669,6 +685,30 @@",
            "      *\n",
            "      * @since 2.8.2\n",
            "      */\n",
            "+    private void _writeRawSegment(char[] cbuf, int offset, int end) throws IOException\n",
            "+    {\n",
            "+        main_loop:\n",
            "+        while (offset < end) {\n",
            "+            inner_loop:\n",
            "+            while (true) {\n",
            "+                int ch = (int) cbuf[offset];\n",
            "+                if (ch > 0x7F) {\n",
            "+                    break inner_loop;\n",
            "+                }\n",
            "+                _outputBuffer[_outputTail++] = (byte) ch;\n",
            "+                if (++offset >= end) {\n",
            "+                    break main_loop;\n",
            "+                }\n",
            "+            }\n",
            "+            char ch = cbuf[offset++];\n",
            "+            if (ch < 0x800) { // 2-byte?\n",
            "+                _outputBuffer[_outputTail++] = (byte) (0xc0 | (ch >> 6));\n",
            "+                _outputBuffer[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n",
            "+            } else {\n",
            "+                offset = _outputRawMultiByteChar(ch, cbuf, offset, end);\n",
            "+            }\n",
            "+        }\n",
            "+    }\n",
            " \n",
            "     /*\n",
            "     /**********************************************************\n"
          ],
          "changed_lines": 24
        },
        {
          "buggy_method": "  private final int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputEnd) throws IOException {\n  \n  if (ch >= SURR1_FIRST) {\n  if (ch <= SURR2_LAST) { \n  \n  if (inputOffset >= inputEnd || cbuf == null) { \n  _reportError(\"Split surrogate on writeRaw() input (last character)\");\n  }\n  _outputSurrogates(ch, cbuf[inputOffset]);\n  return inputOffset+1;\n  }\n  }\n  final byte[] bbuf = _outputBuffer;\n  bbuf[_outputTail++] = (byte) (0xe0 | (ch >> 12));\n  bbuf[_outputTail++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n  bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n  return inputOffset;\n  }",
          "fixed_method": "  private final int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputEnd) throws IOException {\n  \n  if (ch >= SURR1_FIRST) {\n  if (ch <= SURR2_LAST) { \n  \n  if (inputOffset >= inputEnd || cbuf == null) { \n  _reportError(String.format(\n\"Split surrogate on writeRaw() input (last character): first character 0x%4x\", ch));\n  }\n  _outputSurrogates(ch, cbuf[inputOffset]);\n  return inputOffset+1;\n  }\n  }\n  final byte[] bbuf = _outputBuffer;\n  bbuf[_outputTail++] = (byte) (0xe0 | (ch >> 12));\n  bbuf[_outputTail++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n  bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n  return inputOffset;\n  }",
          "diff": [
            "@@ -1884,7 +1924,8 @@",
            "             if (ch <= SURR2_LAST) { // yes, outside of BMP\n",
            "                 // Do we have second part?\n",
            "                 if (inputOffset >= inputEnd || cbuf == null) { // nope... have to note down\n",
            "-                    _reportError(\"Split surrogate on writeRaw() input (last character)\");\n",
            "+                    _reportError(String.format(\n",
            "+\"Split surrogate on writeRaw() input (last character): first character 0x%4x\", ch));\n",
            "                 }\n",
            "                 _outputSurrogates(ch, cbuf[inputOffset]);\n",
            "                 return inputOffset+1;\n"
          ],
          "changed_lines": 3
        }
      ]
    }
  ]
}
