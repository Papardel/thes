{
  "bug_id": "110",
  "failed_tests": {
    "com.fasterxml.jackson.databind.deser.jdk.UtilCollectionsTypesTest": [
      {
        "methodName": "testUnmodifiableListFromLinkedList",
        "error": "com.fasterxml.jackson.databind.exc.InvalidDefinitionException",
        "message": "Cannot construct instance of `java.util.Collections$UnmodifiableList` (no Creators, like default construct, exist): no default no-arguments constructor found",
        "fail_line": "       Collection<?> act = _writeReadCollection(Collections.unmodifiableList(input));",
        "test_source": "  public void testUnmodifiableListFromLinkedList() throws Exception {\n  final List<String> input = new LinkedList<>();\n  input.add(\"first\");\n  input.add(\"second\");\n\n  // Can't use simple \"_verifyCollection\" as type may change; instead use\n  // bit more flexible check:\n  Collection<?> act = _writeReadCollection(Collections.unmodifiableList(input));\n  assertEquals(input, act);\n\n  // and this check may be bit fragile (may need to revisit), but is good enough for now:\n  assertEquals(Collections.unmodifiableList(new ArrayList<>(input)).getClass(), act.getClass());\n  }",
        "stack": [
          "InvalidDefinitionException.from line 67, DeserializationContext.reportBadDefinition line 1452, DeserializationContext.handleMissingInstantiator line 1028, ValueInstantiator.createUsingDefault line 189, StdValueInstantiator.createUsingDefault line 267, CollectionDeserializer.createDefaultInstance line 255, CollectionDeserializer.deserialize line 245, CollectionDeserializer.deserialize line 27, AsArrayTypeDeserializer._deserialize line 116, AsArrayTypeDeserializer.deserializeTypedFromArray line 53, CollectionDeserializer.deserializeWithType line 314, TypeWrappedDeserializer.deserialize line 68, ObjectMapper._readMapAndClose line 4013, ObjectMapper.readValue line 3004, UtilCollectionsTypesTest._writeReadCollection line 122, UtilCollectionsTypesTest.testUnmodifiableListFromLinkedList line 71"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "com/fasterxml/jackson/databind/deser/impl/JavaUtilCollectionsDeserializers.java",
      "buggy_full_code": "package com.fasterxml.jackson.databind.deser.impl;\n\nimport java.util.*;\n\nimport com.fasterxml.jackson.databind.DeserializationContext;\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.JsonDeserializer;\nimport com.fasterxml.jackson.databind.JsonMappingException;\nimport com.fasterxml.jackson.databind.deser.std.StdDelegatingDeserializer;\nimport com.fasterxml.jackson.databind.type.TypeFactory;\nimport com.fasterxml.jackson.databind.util.Converter;\n\n\npublic abstract class JavaUtilCollectionsDeserializers { private final static int TYPE_SINGLETON_SET = 1; private final static int TYPE_SINGLETON_LIST = 2; private final static int TYPE_SINGLETON_MAP = 3; private final static int TYPE_UNMODIFIABLE_SET = 4; private final static int TYPE_UNMODIFIABLE_LIST = 5; private final static int TYPE_UNMODIFIABLE_MAP = 6; public final static int TYPE_AS_LIST = 7; private final static Class<?> CLASS_AS_ARRAYS_LIST = Arrays.asList(null, null).getClass(); private final static Class<?> CLASS_SINGLETON_SET; private final static Class<?> CLASS_SINGLETON_LIST; private final static Class<?> CLASS_SINGLETON_MAP; private final static Class<?> CLASS_UNMODIFIABLE_SET; private final static Class<?> CLASS_UNMODIFIABLE_LIST; private final static Class<?> CLASS_UNMODIFIABLE_MAP; static {\n        Set<?> set = Collections.singleton(Boolean.TRUE);\n        CLASS_SINGLETON_SET = set.getClass();\n        CLASS_UNMODIFIABLE_SET = Collections.unmodifiableSet(set).getClass();\n\n        List<?> list = Collections.singletonList(Boolean.TRUE);\n        CLASS_SINGLETON_LIST = list.getClass();\n        CLASS_UNMODIFIABLE_LIST = Collections.unmodifiableList(list).getClass();\n        \n        \n        Map<?,?> map = Collections.singletonMap(\"a\", \"b\");\n        CLASS_SINGLETON_MAP = map.getClass();\n        CLASS_UNMODIFIABLE_MAP = Collections.unmodifiableMap(map).getClass();\n    }\n\n    public static JsonDeserializer<?> findForCollection(DeserializationContext ctxt, JavaType type) throws JsonMappingException {\n        JavaUtilCollectionsConverter conv;\n\n        \n        if (type.hasRawClass(CLASS_AS_ARRAYS_LIST)) {\n            conv = converter(TYPE_AS_LIST, type, List.class);\n        } else if (type.hasRawClass(CLASS_SINGLETON_LIST)) {\n            conv = converter(TYPE_SINGLETON_LIST, type, List.class);\n        } else if (type.hasRawClass(CLASS_SINGLETON_SET)) {\n            conv = converter(TYPE_SINGLETON_SET, type, Set.class);\n        \n        } else if (type.hasRawClass(CLASS_UNMODIFIABLE_LIST)) {\n            conv = converter(TYPE_UNMODIFIABLE_LIST, type, List.class);\n        } else if (type.hasRawClass(CLASS_UNMODIFIABLE_SET)) {\n            conv = converter(TYPE_UNMODIFIABLE_SET, type, Set.class);\n        } else {\n            return null;\n        }\n        return new StdDelegatingDeserializer<Object>(conv);\n    }\n\n    public static JsonDeserializer<?> findForMap(DeserializationContext ctxt, JavaType type) throws JsonMappingException {\n        JavaUtilCollectionsConverter conv;\n\n        \n        if (type.hasRawClass(CLASS_SINGLETON_MAP)) {\n            conv = converter(TYPE_SINGLETON_MAP, type, Map.class);\n        } else if (type.hasRawClass(CLASS_UNMODIFIABLE_MAP)) {\n            conv = converter(TYPE_UNMODIFIABLE_MAP, type, Map.class);\n        } else {\n            return null;\n        }\n        return new StdDelegatingDeserializer<Object>(conv);\n    }\n    \n    static JavaUtilCollectionsConverter converter(int kind, JavaType concreteType, Class<?> rawSuper) {\n        return new JavaUtilCollectionsConverter(kind, concreteType.findSuperType(rawSuper));\n    }\n\n    \n    private static class JavaUtilCollectionsConverter implements Converter<Object,Object> { private final JavaType _inputType; private final int _kind; private JavaUtilCollectionsConverter(int kind, JavaType inputType) {\n            _inputType = inputType;\n            _kind = kind;\n        }\n        \n        @Override\n        public Object convert(Object value) {\n            if (value == null) { \n                return null;\n            }\n            \n            switch (_kind) {\n            case TYPE_SINGLETON_SET:\n                {\n                    Set<?> set = (Set<?>) value;\n                    _checkSingleton(set.size());\n                    return Collections.singleton(set.iterator().next());\n                }\n            case TYPE_SINGLETON_LIST:\n                {\n                    List<?> list = (List<?>) value;\n                    _checkSingleton(list.size());\n                    return Collections.singletonList(list.get(0));\n                }\n            case TYPE_SINGLETON_MAP:\n                {\n                    Map<?,?> map = (Map<?,?>) value;\n                    _checkSingleton(map.size());\n                    Map.Entry<?,?> entry = map.entrySet().iterator().next();\n                    return Collections.singletonMap(entry.getKey(), entry.getValue());\n                }\n\n            case TYPE_UNMODIFIABLE_SET:\n                return Collections.unmodifiableSet((Set<?>) value);\n            case TYPE_UNMODIFIABLE_LIST:\n                return Collections.unmodifiableList((List<?>) value);\n            case TYPE_UNMODIFIABLE_MAP:\n                return Collections.unmodifiableMap((Map<?,?>) value);\n\n            case TYPE_AS_LIST:\n            default:\n                \n                return value;\n            }\n        }\n\n        @Override\n        public JavaType getInputType(TypeFactory typeFactory) {\n            return _inputType;\n        }\n\n        @Override\n        public JavaType getOutputType(TypeFactory typeFactory) {\n            \n            return _inputType;\n        }\n\n        private void _checkSingleton(int size) {\n            if (size != 1) {\n                \n                throw new IllegalArgumentException(\"Can not deserialize Singleton container from \"+size+\" entries\");\n            }\n        }\n    }\n    \n}\n",
      "fixed_full_code": "package com.fasterxml.jackson.databind.deser.impl;\n\nimport java.util.*;\n\nimport com.fasterxml.jackson.databind.DeserializationContext;\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.JsonDeserializer;\nimport com.fasterxml.jackson.databind.JsonMappingException;\nimport com.fasterxml.jackson.databind.deser.std.StdDelegatingDeserializer;\nimport com.fasterxml.jackson.databind.type.TypeFactory;\nimport com.fasterxml.jackson.databind.util.Converter;\n\n\npublic abstract class JavaUtilCollectionsDeserializers { private final static int TYPE_SINGLETON_SET = 1; private final static int TYPE_SINGLETON_LIST = 2; private final static int TYPE_SINGLETON_MAP = 3; private final static int TYPE_UNMODIFIABLE_SET = 4; private final static int TYPE_UNMODIFIABLE_LIST = 5; private final static int TYPE_UNMODIFIABLE_MAP = 6; public final static int TYPE_AS_LIST = 7; private final static Class<?> CLASS_AS_ARRAYS_LIST = Arrays.asList(null, null).getClass(); private final static Class<?> CLASS_SINGLETON_SET; private final static Class<?> CLASS_SINGLETON_LIST; private final static Class<?> CLASS_SINGLETON_MAP; private final static Class<?> CLASS_UNMODIFIABLE_SET; private final static Class<?> CLASS_UNMODIFIABLE_LIST; private final static Class<?> CLASS_UNMODIFIABLE_LIST_ALIAS; private final static Class<?> CLASS_UNMODIFIABLE_MAP; static {\n        Set<?> set = Collections.singleton(Boolean.TRUE);\n        CLASS_SINGLETON_SET = set.getClass();\n        CLASS_UNMODIFIABLE_SET = Collections.unmodifiableSet(set).getClass();\n\n        List<?> list = Collections.singletonList(Boolean.TRUE);\n        CLASS_SINGLETON_LIST = list.getClass();\n        CLASS_UNMODIFIABLE_LIST = Collections.unmodifiableList(list).getClass();\n        \n        CLASS_UNMODIFIABLE_LIST_ALIAS = Collections.unmodifiableList(new LinkedList<Object>()).getClass();\n        \n        Map<?,?> map = Collections.singletonMap(\"a\", \"b\");\n        CLASS_SINGLETON_MAP = map.getClass();\n        CLASS_UNMODIFIABLE_MAP = Collections.unmodifiableMap(map).getClass();\n    }\n\n    public static JsonDeserializer<?> findForCollection(DeserializationContext ctxt, JavaType type) throws JsonMappingException {\n        JavaUtilCollectionsConverter conv;\n\n        \n        if (type.hasRawClass(CLASS_AS_ARRAYS_LIST)) {\n            conv = converter(TYPE_AS_LIST, type, List.class);\n        } else if (type.hasRawClass(CLASS_SINGLETON_LIST)) {\n            conv = converter(TYPE_SINGLETON_LIST, type, List.class);\n        } else if (type.hasRawClass(CLASS_SINGLETON_SET)) {\n            conv = converter(TYPE_SINGLETON_SET, type, Set.class);\n        \n        } else if (type.hasRawClass(CLASS_UNMODIFIABLE_LIST) || type.hasRawClass(CLASS_UNMODIFIABLE_LIST_ALIAS)) {\n            conv = converter(TYPE_UNMODIFIABLE_LIST, type, List.class);\n        } else if (type.hasRawClass(CLASS_UNMODIFIABLE_SET)) {\n            conv = converter(TYPE_UNMODIFIABLE_SET, type, Set.class);\n        } else {\n            return null;\n        }\n        return new StdDelegatingDeserializer<Object>(conv);\n    }\n\n    public static JsonDeserializer<?> findForMap(DeserializationContext ctxt, JavaType type) throws JsonMappingException {\n        JavaUtilCollectionsConverter conv;\n\n        \n        if (type.hasRawClass(CLASS_SINGLETON_MAP)) {\n            conv = converter(TYPE_SINGLETON_MAP, type, Map.class);\n        } else if (type.hasRawClass(CLASS_UNMODIFIABLE_MAP)) {\n            conv = converter(TYPE_UNMODIFIABLE_MAP, type, Map.class);\n        } else {\n            return null;\n        }\n        return new StdDelegatingDeserializer<Object>(conv);\n    }\n    \n    static JavaUtilCollectionsConverter converter(int kind, JavaType concreteType, Class<?> rawSuper) {\n        return new JavaUtilCollectionsConverter(kind, concreteType.findSuperType(rawSuper));\n    }\n\n    \n    private static class JavaUtilCollectionsConverter implements Converter<Object,Object> { private final JavaType _inputType; private final int _kind; private JavaUtilCollectionsConverter(int kind, JavaType inputType) {\n            _inputType = inputType;\n            _kind = kind;\n        }\n        \n        @Override\n        public Object convert(Object value) {\n            if (value == null) { \n                return null;\n            }\n            \n            switch (_kind) {\n            case TYPE_SINGLETON_SET:\n                {\n                    Set<?> set = (Set<?>) value;\n                    _checkSingleton(set.size());\n                    return Collections.singleton(set.iterator().next());\n                }\n            case TYPE_SINGLETON_LIST:\n                {\n                    List<?> list = (List<?>) value;\n                    _checkSingleton(list.size());\n                    return Collections.singletonList(list.get(0));\n                }\n            case TYPE_SINGLETON_MAP:\n                {\n                    Map<?,?> map = (Map<?,?>) value;\n                    _checkSingleton(map.size());\n                    Map.Entry<?,?> entry = map.entrySet().iterator().next();\n                    return Collections.singletonMap(entry.getKey(), entry.getValue());\n                }\n\n            case TYPE_UNMODIFIABLE_SET:\n                return Collections.unmodifiableSet((Set<?>) value);\n            case TYPE_UNMODIFIABLE_LIST:\n                return Collections.unmodifiableList((List<?>) value);\n            case TYPE_UNMODIFIABLE_MAP:\n                return Collections.unmodifiableMap((Map<?,?>) value);\n\n            case TYPE_AS_LIST:\n            default:\n                \n                return value;\n            }\n        }\n\n        @Override\n        public JavaType getInputType(TypeFactory typeFactory) {\n            return _inputType;\n        }\n\n        @Override\n        public JavaType getOutputType(TypeFactory typeFactory) {\n            \n            return _inputType;\n        }\n\n        private void _checkSingleton(int size) {\n            if (size != 1) {\n                \n                throw new IllegalArgumentException(\"Can not deserialize Singleton container from \"+size+\" entries\");\n            }\n        }\n    }\n    \n}\n",
      "buggy_signatures": [
        "public static JsonDeserializer<?> findForCollection(DeserializationContext ctxt, JavaType type) throws JsonMappingException",
        "public static JsonDeserializer<?> findForMap(DeserializationContext ctxt, JavaType type) throws JsonMappingException",
        "static JavaUtilCollectionsConverter converter(int kind, JavaType concreteType, Class<?> rawSuper)",
        "private static class JavaUtilCollectionsConverter implements Converter<Object,Object> { private final JavaType _inputType; private final int _kind; private JavaUtilCollectionsConverter(int kind, JavaType inputType)",
        "public Object convert(Object value)",
        "public JavaType getInputType(TypeFactory typeFactory)",
        "public JavaType getOutputType(TypeFactory typeFactory)",
        "private void _checkSingleton(int size)"
      ],
      "fixed_signatures": [
        "public static JsonDeserializer<?> findForCollection(DeserializationContext ctxt, JavaType type) throws JsonMappingException",
        "public static JsonDeserializer<?> findForMap(DeserializationContext ctxt, JavaType type) throws JsonMappingException",
        "static JavaUtilCollectionsConverter converter(int kind, JavaType concreteType, Class<?> rawSuper)",
        "private static class JavaUtilCollectionsConverter implements Converter<Object,Object> { private final JavaType _inputType; private final int _kind; private JavaUtilCollectionsConverter(int kind, JavaType inputType)",
        "public Object convert(Object value)",
        "public JavaType getInputType(TypeFactory typeFactory)",
        "public JavaType getOutputType(TypeFactory typeFactory)",
        "private void _checkSingleton(int size)"
      ],
      "methods": [
        {
          "buggy_method": "  private final static Class<?> CLASS_AS_ARRAYS_LIST = Arrays.asList(null, null).getClass(); private final static Class<?> CLASS_SINGLETON_SET; private final static Class<?> CLASS_SINGLETON_LIST; private final static Class<?> CLASS_SINGLETON_MAP; private final static Class<?> CLASS_UNMODIFIABLE_SET; private final static Class<?> CLASS_UNMODIFIABLE_LIST; private final static Class<?> CLASS_UNMODIFIABLE_MAP; static {\n  Set<?> set = Collections.singleton(Boolean.TRUE);\n  CLASS_SINGLETON_SET = set.getClass();\n  CLASS_UNMODIFIABLE_SET = Collections.unmodifiableSet(set).getClass();\n\n  List<?> list = Collections.singletonList(Boolean.TRUE);\n  CLASS_SINGLETON_LIST = list.getClass();\n  CLASS_UNMODIFIABLE_LIST = Collections.unmodifiableList(list).getClass();\n  \n  \n  Map<?,?> map = Collections.singletonMap(\"a\", \"b\");\n  CLASS_SINGLETON_MAP = map.getClass();\n  CLASS_UNMODIFIABLE_MAP = Collections.unmodifiableMap(map).getClass();\n  }",
          "fixed_method": "  private final static Class<?> CLASS_AS_ARRAYS_LIST = Arrays.asList(null, null).getClass(); private final static Class<?> CLASS_SINGLETON_SET; private final static Class<?> CLASS_SINGLETON_LIST; private final static Class<?> CLASS_SINGLETON_MAP; private final static Class<?> CLASS_UNMODIFIABLE_SET; private final static Class<?> CLASS_UNMODIFIABLE_LIST; private final static Class<?> CLASS_UNMODIFIABLE_LIST_ALIAS; private final static Class<?> CLASS_UNMODIFIABLE_MAP; static {\n  Set<?> set = Collections.singleton(Boolean.TRUE);\n  CLASS_SINGLETON_SET = set.getClass();\n  CLASS_UNMODIFIABLE_SET = Collections.unmodifiableSet(set).getClass();\n\n  List<?> list = Collections.singletonList(Boolean.TRUE);\n  CLASS_SINGLETON_LIST = list.getClass();\n  CLASS_UNMODIFIABLE_LIST = Collections.unmodifiableList(list).getClass();\n  \n  CLASS_UNMODIFIABLE_LIST_ALIAS = Collections.unmodifiableList(new LinkedList<Object>()).getClass();\n  \n  Map<?,?> map = Collections.singletonMap(\"a\", \"b\");\n  CLASS_SINGLETON_MAP = map.getClass();\n  CLASS_UNMODIFIABLE_MAP = Collections.unmodifiableMap(map).getClass();\n  }",
          "diff": [
            "@@ -44,6 +44,7 @@",
            "     /* 02-Mar-2019, tatu: for [databind#2265], need to consider possible alternate type...\n",
            "      *    which we essentially coerce into the other one\n",
            "      */\n",
            "+    private final static Class<?> CLASS_UNMODIFIABLE_LIST_ALIAS;\n",
            "     private final static Class<?> CLASS_UNMODIFIABLE_MAP;\n",
            " \n",
            "     static {\n",
            "@@ -55,6 +56,7 @@",
            "         CLASS_SINGLETON_LIST = list.getClass();\n",
            "         CLASS_UNMODIFIABLE_LIST = Collections.unmodifiableList(list).getClass();\n",
            "         // for [databind#2265]\n",
            "+        CLASS_UNMODIFIABLE_LIST_ALIAS = Collections.unmodifiableList(new LinkedList<Object>()).getClass();\n",
            "         \n",
            "         Map<?,?> map = Collections.singletonMap(\"a\", \"b\");\n",
            "         CLASS_SINGLETON_MAP = map.getClass();\n"
          ],
          "changed_lines": 2
        },
        {
          "buggy_method": "  public static JsonDeserializer<?> findForCollection(DeserializationContext ctxt, JavaType type) throws JsonMappingException {\n  JavaUtilCollectionsConverter conv;\n\n  \n  if (type.hasRawClass(CLASS_AS_ARRAYS_LIST)) {\n  conv = converter(TYPE_AS_LIST, type, List.class);\n  } else if (type.hasRawClass(CLASS_SINGLETON_LIST)) {\n  conv = converter(TYPE_SINGLETON_LIST, type, List.class);\n  } else if (type.hasRawClass(CLASS_SINGLETON_SET)) {\n  conv = converter(TYPE_SINGLETON_SET, type, Set.class);\n  \n  } else if (type.hasRawClass(CLASS_UNMODIFIABLE_LIST)) {\n  conv = converter(TYPE_UNMODIFIABLE_LIST, type, List.class);\n  } else if (type.hasRawClass(CLASS_UNMODIFIABLE_SET)) {\n  conv = converter(TYPE_UNMODIFIABLE_SET, type, Set.class);\n  } else {\n  return null;\n  }\n  return new StdDelegatingDeserializer<Object>(conv);\n  }",
          "fixed_method": "  public static JsonDeserializer<?> findForCollection(DeserializationContext ctxt, JavaType type) throws JsonMappingException {\n  JavaUtilCollectionsConverter conv;\n\n  \n  if (type.hasRawClass(CLASS_AS_ARRAYS_LIST)) {\n  conv = converter(TYPE_AS_LIST, type, List.class);\n  } else if (type.hasRawClass(CLASS_SINGLETON_LIST)) {\n  conv = converter(TYPE_SINGLETON_LIST, type, List.class);\n  } else if (type.hasRawClass(CLASS_SINGLETON_SET)) {\n  conv = converter(TYPE_SINGLETON_SET, type, Set.class);\n  \n  } else if (type.hasRawClass(CLASS_UNMODIFIABLE_LIST) || type.hasRawClass(CLASS_UNMODIFIABLE_LIST_ALIAS)) {\n  conv = converter(TYPE_UNMODIFIABLE_LIST, type, List.class);\n  } else if (type.hasRawClass(CLASS_UNMODIFIABLE_SET)) {\n  conv = converter(TYPE_UNMODIFIABLE_SET, type, Set.class);\n  } else {\n  return null;\n  }\n  return new StdDelegatingDeserializer<Object>(conv);\n  }",
          "diff": [
            "@@ -75,7 +77,7 @@",
            "         } else if (type.hasRawClass(CLASS_SINGLETON_SET)) {\n",
            "             conv = converter(TYPE_SINGLETON_SET, type, Set.class);\n",
            "         // [databind#2265]: we may have another impl type for unmodifiable Lists, check both\n",
            "-        } else if (type.hasRawClass(CLASS_UNMODIFIABLE_LIST)) {\n",
            "+        } else if (type.hasRawClass(CLASS_UNMODIFIABLE_LIST) || type.hasRawClass(CLASS_UNMODIFIABLE_LIST_ALIAS)) {\n",
            "             conv = converter(TYPE_UNMODIFIABLE_LIST, type, List.class);\n",
            "         } else if (type.hasRawClass(CLASS_UNMODIFIABLE_SET)) {\n",
            "             conv = converter(TYPE_UNMODIFIABLE_SET, type, Set.class);\n"
          ],
          "changed_lines": 2
        }
      ]
    }
  ]
}
