{
  "bug_id": "96",
  "failed_tests": {
    "org.apache.commons.math.complex.ComplexTest": [
      {
        "methodName": "testMath221",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<org.apache.commons.math.complex.Complex@98b00000> but was:<org.apache.commons.math.complex.Complex@18b00000>",
        "fail_line": "        assertEquals(new Complex(0,-1), new Complex(0,1).multiply(new Complex(-1,0)));",
        "test_source": "  public void testMath221() {\n  assertEquals(new Complex(0,-1), new Complex(0,1).multiply(new Complex(-1,0)));\n  }",
        "stack": [
          "ComplexTest.testMath221 line 696"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/math/complex/Complex.java",
      "buggy_full_code": "\n\npackage org.apache.commons.math.complex;\n\nimport java.io.Serializable;\nimport org.apache.commons.math.util.MathUtils;\n\n\npublic class Complex implements Serializable { private static final long serialVersionUID = -6530173849413811929L; public static final Complex I = new Complex(0.0, 1.0); public static final Complex NaN = new Complex(Double.NaN, Double.NaN); public static final Complex INF = new Complex(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY); public static final Complex ONE = new Complex(1.0, 0.0); public static final Complex ZERO = new Complex(0.0, 0.0); private final double imaginary; private final double real; public Complex(double real, double imaginary) {\n        super();\n        this.real = real;\n        this.imaginary = imaginary;\n    }\n\n    \n    public double abs() {\n        if (isNaN()) {\n            return Double.NaN;\n        }\n        \n        if (isInfinite()) {\n            return Double.POSITIVE_INFINITY;\n        }\n        \n        if (Math.abs(real) < Math.abs(imaginary)) {\n            if (imaginary == 0.0) {\n                return Math.abs(real);\n            }\n            double q = real / imaginary;\n            return (Math.abs(imaginary) * Math.sqrt(1 + q*q));\n        } else {\n            if (real == 0.0) {\n                return Math.abs(imaginary);\n            }\n            double q = imaginary / real;\n            return (Math.abs(real) * Math.sqrt(1 + q*q));\n        }\n    }\n    \n    \n    public Complex add(Complex rhs) {   \n        return createComplex(real + rhs.getReal(),\n            imaginary + rhs.getImaginary());\n    }\n    \n    \n    public Complex conjugate() {\n        if (isNaN()) {\n            return NaN;\n        }   \n        return createComplex(real, -imaginary);\n    }\n    \n    \n    public Complex divide(Complex rhs) {\n        if (isNaN() || rhs.isNaN()) {\n            return NaN;\n        }\n\n        double c = rhs.getReal();\n        double d = rhs.getImaginary();\n        if (c == 0.0 && d == 0.0) {\n            return NaN;\n        }\n        \n        if (rhs.isInfinite() && !isInfinite()) {\n            return ZERO;\n        }\n\n        if (Math.abs(c) < Math.abs(d)) {\n            if (d == 0.0) {\n                return createComplex(real/c, imaginary/c);\n            }\n            double q = c / d;\n            double denominator = c * q + d;\n            return createComplex((real * q + imaginary) / denominator,\n                (imaginary * q - real) / denominator);\n        } else {\n            if (c == 0.0) {\n                return createComplex(imaginary/d, -real/c);\n            }\n            double q = d / c;\n            double denominator = d * q + c;\n            return createComplex((imaginary * q + real) / denominator,\n                (imaginary - real * q) / denominator);\n        }\n    }\n    \n    \n    public boolean equals(Object other) {\n        boolean ret;\n        \n        if (this == other) { \n            ret = true;\n        } else if (other == null) {\n            ret = false;\n        } else  {\n            try {\n                Complex rhs = (Complex)other;\n                if (rhs.isNaN()) {\n                    ret = this.isNaN();\n                } else {\n                    ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); \n                }\n            } catch (ClassCastException ex) {\n                \n                ret = false;\n            }\n        }\n      \n        return ret;\n    }\n    \n    \n    public int hashCode() {\n        if (isNaN()) {\n            return 7;\n        }\n        return 37 * (17 * MathUtils.hash(imaginary) + \n            MathUtils.hash(real));\n    }\n\n    \n    public double getImaginary() {\n        return imaginary;\n    }\n\n    \n    public double getReal() {\n        return real;\n    }\n    \n    \n    public boolean isNaN() {\n        return Double.isNaN(real) || Double.isNaN(imaginary);        \n    }\n    \n    \n    public boolean isInfinite() {\n        return !isNaN() && \n        (Double.isInfinite(real) || Double.isInfinite(imaginary));        \n    }\n    \n    \n    public Complex multiply(Complex rhs) {\n        if (isNaN() || rhs.isNaN()) {\n            return NaN;\n        }\n        if (Double.isInfinite(real) || Double.isInfinite(imaginary) ||\n            Double.isInfinite(rhs.real)|| Double.isInfinite(rhs.imaginary)) {\n            \n            return INF;\n        }\n        return createComplex(real * rhs.real - imaginary * rhs.imaginary,\n                real * rhs.imaginary + imaginary * rhs.real);\n    }\n    \n    \n    public Complex negate() {\n        if (isNaN()) {\n            return NaN;\n        }\n        \n        return createComplex(-real, -imaginary);\n    }\n    \n    \n    public Complex subtract(Complex rhs) {\n        if (isNaN() || rhs.isNaN()) {\n            return NaN;\n        }\n        \n        return createComplex(real - rhs.getReal(),\n            imaginary - rhs.getImaginary());\n    }\n    \n    \n    public Complex acos() {\n        if (isNaN()) {\n            return Complex.NaN;\n        }\n\n        return this.add(this.sqrt1z().multiply(Complex.I)).log()\n              .multiply(Complex.I.negate());\n    }\n    \n    \n    public Complex asin() {\n        if (isNaN()) {\n            return Complex.NaN;\n        }\n\n        return sqrt1z().add(this.multiply(Complex.I)).log()\n              .multiply(Complex.I.negate());\n    }\n    \n    \n    public Complex atan() {\n        if (isNaN()) {\n            return Complex.NaN;\n        }\n        \n        return this.add(Complex.I).divide(Complex.I.subtract(this)).log()\n            .multiply(Complex.I.divide(createComplex(2.0, 0.0)));\n    }\n    \n    \n    public Complex cos() {\n        if (isNaN()) {\n            return Complex.NaN;\n        }\n        \n        return createComplex(Math.cos(real) * MathUtils.cosh(imaginary),\n            -Math.sin(real) * MathUtils.sinh(imaginary));\n    }\n    \n    \n    public Complex cosh() {\n        if (isNaN()) {\n            return Complex.NaN;\n        }\n        \n        return createComplex(MathUtils.cosh(real) * Math.cos(imaginary),\n            MathUtils.sinh(real) * Math.sin(imaginary));\n    }\n    \n    \n    public Complex exp() {\n        if (isNaN()) {\n            return Complex.NaN;\n        }\n        \n        double expReal = Math.exp(real);\n        return createComplex(expReal *  Math.cos(imaginary), expReal * Math.sin(imaginary));\n    }\n    \n    \n    public Complex log() {\n        if (isNaN()) {\n            return Complex.NaN;\n        }\n\n        return createComplex(Math.log(abs()),\n            Math.atan2(imaginary, real));        \n    }\n    \n    \n    public Complex pow(Complex x) {\n        if (x == null) {\n            throw new NullPointerException();\n        }\n        return this.log().multiply(x).exp();\n    }\n    \n    \n    public Complex sin() {\n        if (isNaN()) {\n            return Complex.NaN;\n        }\n        \n        return createComplex(Math.sin(real) * MathUtils.cosh(imaginary),\n            Math.cos(real) * MathUtils.sinh(imaginary));\n    }\n    \n    \n    public Complex sinh() {\n        if (isNaN()) {\n            return Complex.NaN;\n        }\n        \n        return createComplex(MathUtils.sinh(real) * Math.cos(imaginary),\n            MathUtils.cosh(real) * Math.sin(imaginary));\n    }\n    \n    \n    public Complex sqrt() {\n        if (isNaN()) {\n            return Complex.NaN;\n        }\n        \n        if (real == 0.0 && imaginary == 0.0) {\n            return createComplex(0.0, 0.0);\n        }\n        \n        double t = Math.sqrt((Math.abs(real) + abs()) / 2.0);\n        if (real >= 0.0) {\n            return createComplex(t, imaginary / (2.0 * t));\n        } else {\n            return createComplex(Math.abs(imaginary) / (2.0 * t),\n                MathUtils.indicator(imaginary) * t);\n        }\n    }\n    \n    \n    public Complex sqrt1z() {\n        return createComplex(1.0, 0.0).subtract(this.multiply(this)).sqrt();\n    }\n    \n    \n    public Complex tan() {\n        if (isNaN()) {\n            return Complex.NaN;\n        }\n        \n        double real2 = 2.0 * real;\n        double imaginary2 = 2.0 * imaginary;\n        double d = Math.cos(real2) + MathUtils.cosh(imaginary2);\n        \n        return createComplex(Math.sin(real2) / d, MathUtils.sinh(imaginary2) / d);\n    }\n    \n    \n    public Complex tanh() {\n        if (isNaN()) {\n            return Complex.NaN;\n        }\n        \n        double real2 = 2.0 * real;\n        double imaginary2 = 2.0 * imaginary;\n        double d = MathUtils.cosh(real2) + Math.cos(imaginary2);\n        \n        return createComplex(MathUtils.sinh(real2) / d, Math.sin(imaginary2) / d);\n    }\n\n    \n    protected Complex createComplex(double real, double imaginary) {\n        return new Complex(real, imaginary);\n    }\n}\n",
      "fixed_full_code": "\n\npackage org.apache.commons.math.complex;\n\nimport java.io.Serializable;\nimport org.apache.commons.math.util.MathUtils;\n\n\npublic class Complex implements Serializable { private static final long serialVersionUID = -6530173849413811929L; public static final Complex I = new Complex(0.0, 1.0); public static final Complex NaN = new Complex(Double.NaN, Double.NaN); public static final Complex INF = new Complex(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY); public static final Complex ONE = new Complex(1.0, 0.0); public static final Complex ZERO = new Complex(0.0, 0.0); private final double imaginary; private final double real; public Complex(double real, double imaginary) {\n        super();\n        this.real = real;\n        this.imaginary = imaginary;\n    }\n\n    \n    public double abs() {\n        if (isNaN()) {\n            return Double.NaN;\n        }\n        \n        if (isInfinite()) {\n            return Double.POSITIVE_INFINITY;\n        }\n        \n        if (Math.abs(real) < Math.abs(imaginary)) {\n            if (imaginary == 0.0) {\n                return Math.abs(real);\n            }\n            double q = real / imaginary;\n            return (Math.abs(imaginary) * Math.sqrt(1 + q*q));\n        } else {\n            if (real == 0.0) {\n                return Math.abs(imaginary);\n            }\n            double q = imaginary / real;\n            return (Math.abs(real) * Math.sqrt(1 + q*q));\n        }\n    }\n    \n    \n    public Complex add(Complex rhs) {   \n        return createComplex(real + rhs.getReal(),\n            imaginary + rhs.getImaginary());\n    }\n    \n    \n    public Complex conjugate() {\n        if (isNaN()) {\n            return NaN;\n        }   \n        return createComplex(real, -imaginary);\n    }\n    \n    \n    public Complex divide(Complex rhs) {\n        if (isNaN() || rhs.isNaN()) {\n            return NaN;\n        }\n\n        double c = rhs.getReal();\n        double d = rhs.getImaginary();\n        if (c == 0.0 && d == 0.0) {\n            return NaN;\n        }\n        \n        if (rhs.isInfinite() && !isInfinite()) {\n            return ZERO;\n        }\n\n        if (Math.abs(c) < Math.abs(d)) {\n            if (d == 0.0) {\n                return createComplex(real/c, imaginary/c);\n            }\n            double q = c / d;\n            double denominator = c * q + d;\n            return createComplex((real * q + imaginary) / denominator,\n                (imaginary * q - real) / denominator);\n        } else {\n            if (c == 0.0) {\n                return createComplex(imaginary/d, -real/c);\n            }\n            double q = d / c;\n            double denominator = d * q + c;\n            return createComplex((imaginary * q + real) / denominator,\n                (imaginary - real * q) / denominator);\n        }\n    }\n    \n    \n    public boolean equals(Object other) {\n        boolean ret;\n        \n        if (this == other) { \n            ret = true;\n        } else if (other == null) {\n            ret = false;\n        } else  {\n            try {\n                Complex rhs = (Complex)other;\n                if (rhs.isNaN()) {\n                    ret = this.isNaN();\n                } else {\n                    ret = (real == rhs.real) && (imaginary == rhs.imaginary); \n                }\n            } catch (ClassCastException ex) {\n                \n                ret = false;\n            }\n        }\n      \n        return ret;\n    }\n    \n    \n    public int hashCode() {\n        if (isNaN()) {\n            return 7;\n        }\n        return 37 * (17 * MathUtils.hash(imaginary) + \n            MathUtils.hash(real));\n    }\n\n    \n    public double getImaginary() {\n        return imaginary;\n    }\n\n    \n    public double getReal() {\n        return real;\n    }\n    \n    \n    public boolean isNaN() {\n        return Double.isNaN(real) || Double.isNaN(imaginary);        \n    }\n    \n    \n    public boolean isInfinite() {\n        return !isNaN() && \n        (Double.isInfinite(real) || Double.isInfinite(imaginary));        \n    }\n    \n    \n    public Complex multiply(Complex rhs) {\n        if (isNaN() || rhs.isNaN()) {\n            return NaN;\n        }\n        if (Double.isInfinite(real) || Double.isInfinite(imaginary) ||\n            Double.isInfinite(rhs.real)|| Double.isInfinite(rhs.imaginary)) {\n            \n            return INF;\n        }\n        return createComplex(real * rhs.real - imaginary * rhs.imaginary,\n                real * rhs.imaginary + imaginary * rhs.real);\n    }\n    \n    \n    public Complex negate() {\n        if (isNaN()) {\n            return NaN;\n        }\n        \n        return createComplex(-real, -imaginary);\n    }\n    \n    \n    public Complex subtract(Complex rhs) {\n        if (isNaN() || rhs.isNaN()) {\n            return NaN;\n        }\n        \n        return createComplex(real - rhs.getReal(),\n            imaginary - rhs.getImaginary());\n    }\n    \n    \n    public Complex acos() {\n        if (isNaN()) {\n            return Complex.NaN;\n        }\n\n        return this.add(this.sqrt1z().multiply(Complex.I)).log()\n              .multiply(Complex.I.negate());\n    }\n    \n    \n    public Complex asin() {\n        if (isNaN()) {\n            return Complex.NaN;\n        }\n\n        return sqrt1z().add(this.multiply(Complex.I)).log()\n              .multiply(Complex.I.negate());\n    }\n    \n    \n    public Complex atan() {\n        if (isNaN()) {\n            return Complex.NaN;\n        }\n        \n        return this.add(Complex.I).divide(Complex.I.subtract(this)).log()\n            .multiply(Complex.I.divide(createComplex(2.0, 0.0)));\n    }\n    \n    \n    public Complex cos() {\n        if (isNaN()) {\n            return Complex.NaN;\n        }\n        \n        return createComplex(Math.cos(real) * MathUtils.cosh(imaginary),\n            -Math.sin(real) * MathUtils.sinh(imaginary));\n    }\n    \n    \n    public Complex cosh() {\n        if (isNaN()) {\n            return Complex.NaN;\n        }\n        \n        return createComplex(MathUtils.cosh(real) * Math.cos(imaginary),\n            MathUtils.sinh(real) * Math.sin(imaginary));\n    }\n    \n    \n    public Complex exp() {\n        if (isNaN()) {\n            return Complex.NaN;\n        }\n        \n        double expReal = Math.exp(real);\n        return createComplex(expReal *  Math.cos(imaginary), expReal * Math.sin(imaginary));\n    }\n    \n    \n    public Complex log() {\n        if (isNaN()) {\n            return Complex.NaN;\n        }\n\n        return createComplex(Math.log(abs()),\n            Math.atan2(imaginary, real));        \n    }\n    \n    \n    public Complex pow(Complex x) {\n        if (x == null) {\n            throw new NullPointerException();\n        }\n        return this.log().multiply(x).exp();\n    }\n    \n    \n    public Complex sin() {\n        if (isNaN()) {\n            return Complex.NaN;\n        }\n        \n        return createComplex(Math.sin(real) * MathUtils.cosh(imaginary),\n            Math.cos(real) * MathUtils.sinh(imaginary));\n    }\n    \n    \n    public Complex sinh() {\n        if (isNaN()) {\n            return Complex.NaN;\n        }\n        \n        return createComplex(MathUtils.sinh(real) * Math.cos(imaginary),\n            MathUtils.cosh(real) * Math.sin(imaginary));\n    }\n    \n    \n    public Complex sqrt() {\n        if (isNaN()) {\n            return Complex.NaN;\n        }\n        \n        if (real == 0.0 && imaginary == 0.0) {\n            return createComplex(0.0, 0.0);\n        }\n        \n        double t = Math.sqrt((Math.abs(real) + abs()) / 2.0);\n        if (real >= 0.0) {\n            return createComplex(t, imaginary / (2.0 * t));\n        } else {\n            return createComplex(Math.abs(imaginary) / (2.0 * t),\n                MathUtils.indicator(imaginary) * t);\n        }\n    }\n    \n    \n    public Complex sqrt1z() {\n        return createComplex(1.0, 0.0).subtract(this.multiply(this)).sqrt();\n    }\n    \n    \n    public Complex tan() {\n        if (isNaN()) {\n            return Complex.NaN;\n        }\n        \n        double real2 = 2.0 * real;\n        double imaginary2 = 2.0 * imaginary;\n        double d = Math.cos(real2) + MathUtils.cosh(imaginary2);\n        \n        return createComplex(Math.sin(real2) / d, MathUtils.sinh(imaginary2) / d);\n    }\n    \n    \n    public Complex tanh() {\n        if (isNaN()) {\n            return Complex.NaN;\n        }\n        \n        double real2 = 2.0 * real;\n        double imaginary2 = 2.0 * imaginary;\n        double d = MathUtils.cosh(real2) + Math.cos(imaginary2);\n        \n        return createComplex(MathUtils.sinh(real2) / d, Math.sin(imaginary2) / d);\n    }\n\n    \n    protected Complex createComplex(double real, double imaginary) {\n        return new Complex(real, imaginary);\n    }\n}\n",
      "buggy_signatures": [
        "public double abs()",
        "public Complex add(Complex rhs)",
        "public Complex conjugate()",
        "public Complex divide(Complex rhs)",
        "public boolean equals(Object other)",
        "public int hashCode()",
        "public double getImaginary()",
        "public double getReal()",
        "public boolean isNaN()",
        "public boolean isInfinite()",
        "public Complex multiply(Complex rhs)",
        "public Complex negate()",
        "public Complex subtract(Complex rhs)",
        "public Complex acos()",
        "public Complex asin()",
        "public Complex atan()",
        "public Complex cos()",
        "public Complex cosh()",
        "public Complex exp()",
        "public Complex log()",
        "public Complex pow(Complex x)",
        "public Complex sin()",
        "public Complex sinh()",
        "public Complex sqrt()",
        "public Complex sqrt1z()",
        "public Complex tan()",
        "public Complex tanh()",
        "protected Complex createComplex(double real, double imaginary)"
      ],
      "fixed_signatures": [
        "public double abs()",
        "public Complex add(Complex rhs)",
        "public Complex conjugate()",
        "public Complex divide(Complex rhs)",
        "public boolean equals(Object other)",
        "public int hashCode()",
        "public double getImaginary()",
        "public double getReal()",
        "public boolean isNaN()",
        "public boolean isInfinite()",
        "public Complex multiply(Complex rhs)",
        "public Complex negate()",
        "public Complex subtract(Complex rhs)",
        "public Complex acos()",
        "public Complex asin()",
        "public Complex atan()",
        "public Complex cos()",
        "public Complex cosh()",
        "public Complex exp()",
        "public Complex log()",
        "public Complex pow(Complex x)",
        "public Complex sin()",
        "public Complex sinh()",
        "public Complex sqrt()",
        "public Complex sqrt1z()",
        "public Complex tan()",
        "public Complex tanh()",
        "protected Complex createComplex(double real, double imaginary)"
      ],
      "methods": [
        {
          "buggy_method": "  public boolean equals(Object other) {\n  boolean ret;\n  \n  if (this == other) { \n  ret = true;\n  } else if (other == null) {\n  ret = false;\n  } else  {\n  try {\n  Complex rhs = (Complex)other;\n  if (rhs.isNaN()) {\n  ret = this.isNaN();\n  } else {\n  ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); \n  }\n  } catch (ClassCastException ex) {\n  \n  ret = false;\n  }\n  }\n  \n  return ret;\n  }",
          "fixed_method": "  public boolean equals(Object other) {\n  boolean ret;\n  \n  if (this == other) { \n  ret = true;\n  } else if (other == null) {\n  ret = false;\n  } else  {\n  try {\n  Complex rhs = (Complex)other;\n  if (rhs.isNaN()) {\n  ret = this.isNaN();\n  } else {\n  ret = (real == rhs.real) && (imaginary == rhs.imaginary); \n  }\n  } catch (ClassCastException ex) {\n  \n  ret = false;\n  }\n  }\n  \n  return ret;\n  }",
          "diff": [
            "@@ -255,7 +255,7 @@",
            "                 if (rhs.isNaN()) {\n",
            "                     ret = this.isNaN();\n",
            "                 } else {\n",
            "-                    ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); \n",
            "+                    ret = (real == rhs.real) && (imaginary == rhs.imaginary); \n",
            "                 }\n",
            "             } catch (ClassCastException ex) {\n",
            "                 // ignore exception\n"
          ],
          "changed_lines": 2
        }
      ]
    }
  ]
}
