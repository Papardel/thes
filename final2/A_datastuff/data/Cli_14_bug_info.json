{
  "bug_id": "14",
  "failed_tests": {
    "org.apache.commons.cli2.bug.BugCLI144Test": [
      {
        "methodName": "testFileValidator",
        "error": "java.lang.ClassCastException",
        "message": "class java.io.File cannot be cast to class java.lang.String (java.io.File and java.lang.String are in module java.base of loader 'bootstrap')",
        "fail_line": "                .parseAndHelp(new String[] { \"--file-name\", fileName });",
        "test_source": "\tpublic void testFileValidator() {\n\t\tfinal DefaultOptionBuilder obuilder = new DefaultOptionBuilder();\n  final ArgumentBuilder abuilder = new ArgumentBuilder();\n  final GroupBuilder gbuilder = new GroupBuilder();\n  DefaultOption fileNameOption = obuilder.withShortName(\"f\")\n  .withLongName(\"file-name\").withRequired(true).withDescription(\n  \"name of an existing file\").withArgument(\n  abuilder.withName(\"file-name\").withValidator(\n  FileValidator.getExistingFileInstance())\n  .create()).create();\n  Group options = gbuilder.withName(\"options\").withOption(fileNameOption)\n  .create();\n  Parser parser = new Parser();\n  parser.setHelpTrigger(\"--help\");\n  parser.setGroup(options);\n\n  final String fileName = \"src/test/org/apache/commons/cli2/bug/BugCLI144Test.java\";\n  CommandLine cl = parser\n  .parseAndHelp(new String[] { \"--file-name\", fileName });\n  assertNotNull(cl);\n  assertEquals(\"Wrong file\", new File(fileName), cl.getValue(fileNameOption));\n\t}",
        "stack": [
          "FileValidator.validate line 123, ArgumentImpl.validate line 251, ParentImpl.validate line 124, DefaultOption.validate line 176, GroupImpl.validate line 262, Parser.parse line 104, Parser.parseAndHelp line 124, BugCLI144Test.testFileValidator line 62"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/cli2/option/GroupImpl.java",
      "buggy_full_code": "\npackage org.apache.commons.cli2.option;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\n\nimport org.apache.commons.cli2.Argument;\nimport org.apache.commons.cli2.DisplaySetting;\nimport org.apache.commons.cli2.Group;\nimport org.apache.commons.cli2.HelpLine;\nimport org.apache.commons.cli2.Option;\nimport org.apache.commons.cli2.OptionException;\nimport org.apache.commons.cli2.WriteableCommandLine;\nimport org.apache.commons.cli2.resource.ResourceConstants;\n\n\npublic class GroupImpl extends OptionImpl implements Group { private final String name; private final String description; private final List options; private final int minimum; private final int maximum; private final List anonymous; private final SortedMap optionMap; private final Set prefixes; public GroupImpl(final List options, final String name, final String description, final int minimum, final int maximum) {\n        super(0, false);\n\n        this.name = name;\n        this.description = description;\n        this.minimum = minimum;\n        this.maximum = maximum;\n\n        \n        \n        this.options = Collections.unmodifiableList(options);\n\n        \n        final List newAnonymous = new ArrayList();\n\n        \n        final SortedMap newOptionMap = new TreeMap(ReverseStringComparator.getInstance());\n\n        \n        final Set newPrefixes = new HashSet();\n\n        \n        for (final Iterator i = options.iterator(); i.hasNext();) {\n            final Option option = (Option) i.next();\n\n            if (option instanceof Argument) {\n                i.remove();\n                newAnonymous.add(option);\n            } else {\n                final Set triggers = option.getTriggers();\n\n                for (Iterator j = triggers.iterator(); j.hasNext();) {\n                    newOptionMap.put(j.next(), option);\n                }\n\n                \n                newPrefixes.addAll(option.getPrefixes());\n            }\n        }\n\n        this.anonymous = Collections.unmodifiableList(newAnonymous);\n        this.optionMap = Collections.unmodifiableSortedMap(newOptionMap);\n        this.prefixes = Collections.unmodifiableSet(newPrefixes);\n    }\n\n    public boolean canProcess(final WriteableCommandLine commandLine, final String arg) {\n        if (arg == null) {\n            return false;\n        }\n\n        \n        if (optionMap.containsKey(arg)) {\n            return true;\n        }\n\n        \n        final Map tailMap = optionMap.tailMap(arg);\n\n        \n        for (final Iterator iter = tailMap.values().iterator(); iter.hasNext();) {\n            final Option option = (Option) iter.next();\n\n            if (option.canProcess(commandLine, arg)) {\n                return true;\n            }\n        }\n\n        if (commandLine.looksLikeOption(arg)) {\n            return false;\n        }\n\n        \n        if (anonymous.size() > 0) {\n            return true;\n        }\n\n        return false;\n    }\n\n    public Set getPrefixes() {\n        return prefixes;\n    }\n\n    public Set getTriggers() {\n        return optionMap.keySet();\n    }\n\n    public void process(final WriteableCommandLine commandLine, final ListIterator arguments) throws OptionException {\n        String previous = null;\n\n        \n        while (arguments.hasNext()) {\n            \n            final String arg = (String) arguments.next();\n\n            \n            if (arg == previous) {\n                \n                arguments.previous();\n\n                break;\n            }\n\n            \n            previous = arg;\n\n            final Option opt = (Option) optionMap.get(arg);\n\n            \n            if (opt != null) {\n                arguments.previous();\n                opt.process(commandLine, arguments);\n            }\n            \n            else {\n                \n                \n                if (commandLine.looksLikeOption(arg)) {\n                    \n                    final Collection values = optionMap.tailMap(arg).values();\n\n                    boolean foundMemberOption = false;\n\n                    for (Iterator i = values.iterator(); i.hasNext() && !foundMemberOption;) {\n                        final Option option = (Option) i.next();\n\n                        if (option.canProcess(commandLine, arg)) {\n                            foundMemberOption = true;\n                            arguments.previous();\n                            option.process(commandLine, arguments);\n                        }\n                    }\n\n                    \n                    if (!foundMemberOption) {\n                        arguments.previous();\n\n                        return;\n                    }\n                } \n\n                \n                else {\n                    \n                    arguments.previous();\n\n                    \n                    \n                    if (anonymous.isEmpty()) {\n                        break;\n                    }\n\n                    \n                    \n                    for (final Iterator i = anonymous.iterator(); i.hasNext();) {\n                        final Argument argument = (Argument) i.next();\n\n                        if (argument.canProcess(commandLine, arguments)) {\n                            argument.process(commandLine, arguments);\n                        }\n                    }\n                } \n            } \n        } \n    }\n\n    public void validate(final WriteableCommandLine commandLine) throws OptionException {\n        \n        int present = 0;\n\n        \n        Option unexpected = null;\n\n        for (final Iterator i = options.iterator(); i.hasNext();) {\n            final Option option = (Option) i.next();\n\n            \n            boolean validate = option.isRequired() || option instanceof Group;\n            if (validate) {\n                option.validate(commandLine);\n            }\n\n            \n            if (commandLine.hasOption(option)) {\n                if (++present > maximum) {\n                    unexpected = option;\n\n                    break;\n                }\n\n                option.validate(commandLine);\n            }\n        }\n\n        \n        if (unexpected != null) {\n            throw new OptionException(this, ResourceConstants.UNEXPECTED_TOKEN,\n                                      unexpected.getPreferredName());\n        }\n\n        \n        if (present < minimum) {\n            throw new OptionException(this, ResourceConstants.MISSING_OPTION);\n        }\n\n        \n        for (final Iterator i = anonymous.iterator(); i.hasNext();) {\n            final Option option = (Option) i.next();\n            option.validate(commandLine);\n        }\n    }\n\n    public String getPreferredName() {\n        return name;\n    }\n\n    public String getDescription() {\n        return description;\n    }\n\n    public void appendUsage(final StringBuffer buffer, final Set helpSettings, final Comparator comp) {\n        appendUsage(buffer, helpSettings, comp, \"|\");\n    }\n\n    public void appendUsage(final StringBuffer buffer, final Set helpSettings, final Comparator comp, final String separator) {\n        final Set helpSettingsCopy = new HashSet(helpSettings);\n\n        final boolean optional =\n            (minimum == 0) && helpSettingsCopy.contains(DisplaySetting.DISPLAY_OPTIONAL);\n\n        final boolean expanded =\n            (name == null) || helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_EXPANDED);\n\n        final boolean named =\n            !expanded ||\n            ((name != null) && helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_NAME));\n\n        final boolean arguments = helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_ARGUMENT);\n\n        final boolean outer = helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_OUTER);\n\n        helpSettingsCopy.remove(DisplaySetting.DISPLAY_GROUP_OUTER);\n\n        final boolean both = named && expanded;\n\n        if (optional) {\n            buffer.append('[');\n        }\n\n        if (named) {\n            buffer.append(name);\n        }\n\n        if (both) {\n            buffer.append(\" (\");\n        }\n\n        if (expanded) {\n            final Set childSettings;\n\n            if (!helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_EXPANDED)) {\n                childSettings = DisplaySetting.NONE;\n            } else {\n                childSettings = new HashSet(helpSettingsCopy);\n                childSettings.remove(DisplaySetting.DISPLAY_OPTIONAL);\n            }\n\n            \n            final List list;\n\n            if (comp == null) {\n                \n                list = options;\n            } else {\n                \n                list = new ArrayList(options);\n                Collections.sort(list, comp);\n            }\n\n            \n            for (final Iterator i = list.iterator(); i.hasNext();) {\n                final Option option = (Option) i.next();\n\n                \n                option.appendUsage(buffer, childSettings, comp);\n\n                \n                if (i.hasNext()) {\n                    buffer.append(separator);\n                }\n            }\n        }\n\n        if (both) {\n            buffer.append(')');\n        }\n\n        if (optional && outer) {\n            buffer.append(']');\n        }\n\n        if (arguments) {\n            for (final Iterator i = anonymous.iterator(); i.hasNext();) {\n                buffer.append(' ');\n\n                final Option option = (Option) i.next();\n                option.appendUsage(buffer, helpSettingsCopy, comp);\n            }\n        }\n\n        if (optional && !outer) {\n            buffer.append(']');\n        }\n    }\n\n    public List helpLines(final int depth, final Set helpSettings, final Comparator comp) {\n        final List helpLines = new ArrayList();\n\n        if (helpSettings.contains(DisplaySetting.DISPLAY_GROUP_NAME)) {\n            final HelpLine helpLine = new HelpLineImpl(this, depth);\n            helpLines.add(helpLine);\n        }\n\n        if (helpSettings.contains(DisplaySetting.DISPLAY_GROUP_EXPANDED)) {\n            \n            final List list;\n\n            if (comp == null) {\n                \n                list = options;\n            } else {\n                \n                list = new ArrayList(options);\n                Collections.sort(list, comp);\n            }\n\n            \n            for (final Iterator i = list.iterator(); i.hasNext();) {\n                final Option option = (Option) i.next();\n                helpLines.addAll(option.helpLines(depth + 1, helpSettings, comp));\n            }\n        }\n\n        if (helpSettings.contains(DisplaySetting.DISPLAY_GROUP_ARGUMENT)) {\n            for (final Iterator i = anonymous.iterator(); i.hasNext();) {\n                final Option option = (Option) i.next();\n                helpLines.addAll(option.helpLines(depth + 1, helpSettings, comp));\n            }\n        }\n\n        return helpLines;\n    }\n\n    \n    public List getOptions() {\n        return options;\n    }\n\n    \n    public List getAnonymous() {\n        return anonymous;\n    }\n\n    public Option findOption(final String trigger) {\n        final Iterator i = getOptions().iterator();\n\n        while (i.hasNext()) {\n            final Option option = (Option) i.next();\n            final Option found = option.findOption(trigger);\n\n            if (found != null) {\n                return found;\n            }\n        }\n\n        return null;\n    }\n\n    public int getMinimum() {\n        return minimum;\n    }\n\n    public int getMaximum() {\n        return maximum;\n    }\n\n    public boolean isRequired() {\n        return getMinimum() > 0;\n    }\n\n    public void defaults(final WriteableCommandLine commandLine) {\n        super.defaults(commandLine);\n\n        for (final Iterator i = options.iterator(); i.hasNext();) {\n            final Option option = (Option) i.next();\n            option.defaults(commandLine);\n        }\n\n        for (final Iterator i = anonymous.iterator(); i.hasNext();) {\n            final Option option = (Option) i.next();\n            option.defaults(commandLine);\n        }\n    }\n}\n\n\nclass ReverseStringComparator implements Comparator {\n    private static final Comparator instance = new ReverseStringComparator(); private ReverseStringComparator() {\n        \n    }\n\n    \n    public static final Comparator getInstance() {\n        return instance;\n    }\n\n    public int compare(final Object o1, final Object o2) {\n        final String s1 = (String) o1;\n        final String s2 = (String) o2;\n\n        return -s1.compareTo(s2);\n    }\n}\n",
      "fixed_full_code": "\npackage org.apache.commons.cli2.option;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\n\nimport org.apache.commons.cli2.Argument;\nimport org.apache.commons.cli2.DisplaySetting;\nimport org.apache.commons.cli2.Group;\nimport org.apache.commons.cli2.HelpLine;\nimport org.apache.commons.cli2.Option;\nimport org.apache.commons.cli2.OptionException;\nimport org.apache.commons.cli2.WriteableCommandLine;\nimport org.apache.commons.cli2.resource.ResourceConstants;\n\n\npublic class GroupImpl extends OptionImpl implements Group { private final String name; private final String description; private final List options; private final int minimum; private final int maximum; private final List anonymous; private final SortedMap optionMap; private final Set prefixes; public GroupImpl(final List options, final String name, final String description, final int minimum, final int maximum) {\n        super(0, false);\n\n        this.name = name;\n        this.description = description;\n        this.minimum = minimum;\n        this.maximum = maximum;\n\n        \n        \n        this.options = Collections.unmodifiableList(options);\n\n        \n        final List newAnonymous = new ArrayList();\n\n        \n        final SortedMap newOptionMap = new TreeMap(ReverseStringComparator.getInstance());\n\n        \n        final Set newPrefixes = new HashSet();\n\n        \n        for (final Iterator i = options.iterator(); i.hasNext();) {\n            final Option option = (Option) i.next();\n\n            if (option instanceof Argument) {\n                i.remove();\n                newAnonymous.add(option);\n            } else {\n                final Set triggers = option.getTriggers();\n\n                for (Iterator j = triggers.iterator(); j.hasNext();) {\n                    newOptionMap.put(j.next(), option);\n                }\n\n                \n                newPrefixes.addAll(option.getPrefixes());\n            }\n        }\n\n        this.anonymous = Collections.unmodifiableList(newAnonymous);\n        this.optionMap = Collections.unmodifiableSortedMap(newOptionMap);\n        this.prefixes = Collections.unmodifiableSet(newPrefixes);\n    }\n\n    public boolean canProcess(final WriteableCommandLine commandLine, final String arg) {\n        if (arg == null) {\n            return false;\n        }\n\n        \n        if (optionMap.containsKey(arg)) {\n            return true;\n        }\n\n        \n        final Map tailMap = optionMap.tailMap(arg);\n\n        \n        for (final Iterator iter = tailMap.values().iterator(); iter.hasNext();) {\n            final Option option = (Option) iter.next();\n\n            if (option.canProcess(commandLine, arg)) {\n                return true;\n            }\n        }\n\n        if (commandLine.looksLikeOption(arg)) {\n            return false;\n        }\n\n        \n        if (anonymous.size() > 0) {\n            return true;\n        }\n\n        return false;\n    }\n\n    public Set getPrefixes() {\n        return prefixes;\n    }\n\n    public Set getTriggers() {\n        return optionMap.keySet();\n    }\n\n    public void process(final WriteableCommandLine commandLine, final ListIterator arguments) throws OptionException {\n        String previous = null;\n\n        \n        while (arguments.hasNext()) {\n            \n            final String arg = (String) arguments.next();\n\n            \n            if (arg == previous) {\n                \n                arguments.previous();\n\n                break;\n            }\n\n            \n            previous = arg;\n\n            final Option opt = (Option) optionMap.get(arg);\n\n            \n            if (opt != null) {\n                arguments.previous();\n                opt.process(commandLine, arguments);\n            }\n            \n            else {\n                \n                \n                if (commandLine.looksLikeOption(arg)) {\n                    \n                    final Collection values = optionMap.tailMap(arg).values();\n\n                    boolean foundMemberOption = false;\n\n                    for (Iterator i = values.iterator(); i.hasNext() && !foundMemberOption;) {\n                        final Option option = (Option) i.next();\n\n                        if (option.canProcess(commandLine, arg)) {\n                            foundMemberOption = true;\n                            arguments.previous();\n                            option.process(commandLine, arguments);\n                        }\n                    }\n\n                    \n                    if (!foundMemberOption) {\n                        arguments.previous();\n\n                        return;\n                    }\n                } \n\n                \n                else {\n                    \n                    arguments.previous();\n\n                    \n                    \n                    if (anonymous.isEmpty()) {\n                        break;\n                    }\n\n                    \n                    \n                    for (final Iterator i = anonymous.iterator(); i.hasNext();) {\n                        final Argument argument = (Argument) i.next();\n\n                        if (argument.canProcess(commandLine, arguments)) {\n                            argument.process(commandLine, arguments);\n                        }\n                    }\n                } \n            } \n        } \n    }\n\n    public void validate(final WriteableCommandLine commandLine) throws OptionException {\n        \n        int present = 0;\n\n        \n        Option unexpected = null;\n\n        for (final Iterator i = options.iterator(); i.hasNext();) {\n            final Option option = (Option) i.next();\n\n            \n            boolean validate = option.isRequired() || option instanceof Group;\n\n            \n            if (commandLine.hasOption(option)) {\n                if (++present > maximum) {\n                    unexpected = option;\n\n                    break;\n                }\n                validate = true;\n            }\n\n            if (validate) {\n                option.validate(commandLine);\n            }\n        }\n\n        \n        if (unexpected != null) {\n            throw new OptionException(this, ResourceConstants.UNEXPECTED_TOKEN,\n                                      unexpected.getPreferredName());\n        }\n\n        \n        if (present < minimum) {\n            throw new OptionException(this, ResourceConstants.MISSING_OPTION);\n        }\n\n        \n        for (final Iterator i = anonymous.iterator(); i.hasNext();) {\n            final Option option = (Option) i.next();\n            option.validate(commandLine);\n        }\n    }\n\n    public String getPreferredName() {\n        return name;\n    }\n\n    public String getDescription() {\n        return description;\n    }\n\n    public void appendUsage(final StringBuffer buffer, final Set helpSettings, final Comparator comp) {\n        appendUsage(buffer, helpSettings, comp, \"|\");\n    }\n\n    public void appendUsage(final StringBuffer buffer, final Set helpSettings, final Comparator comp, final String separator) {\n        final Set helpSettingsCopy = new HashSet(helpSettings);\n\n        final boolean optional =\n            (minimum == 0) && helpSettingsCopy.contains(DisplaySetting.DISPLAY_OPTIONAL);\n\n        final boolean expanded =\n            (name == null) || helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_EXPANDED);\n\n        final boolean named =\n            !expanded ||\n            ((name != null) && helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_NAME));\n\n        final boolean arguments = helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_ARGUMENT);\n\n        final boolean outer = helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_OUTER);\n\n        helpSettingsCopy.remove(DisplaySetting.DISPLAY_GROUP_OUTER);\n\n        final boolean both = named && expanded;\n\n        if (optional) {\n            buffer.append('[');\n        }\n\n        if (named) {\n            buffer.append(name);\n        }\n\n        if (both) {\n            buffer.append(\" (\");\n        }\n\n        if (expanded) {\n            final Set childSettings;\n\n            if (!helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_EXPANDED)) {\n                childSettings = DisplaySetting.NONE;\n            } else {\n                childSettings = new HashSet(helpSettingsCopy);\n                childSettings.remove(DisplaySetting.DISPLAY_OPTIONAL);\n            }\n\n            \n            final List list;\n\n            if (comp == null) {\n                \n                list = options;\n            } else {\n                \n                list = new ArrayList(options);\n                Collections.sort(list, comp);\n            }\n\n            \n            for (final Iterator i = list.iterator(); i.hasNext();) {\n                final Option option = (Option) i.next();\n\n                \n                option.appendUsage(buffer, childSettings, comp);\n\n                \n                if (i.hasNext()) {\n                    buffer.append(separator);\n                }\n            }\n        }\n\n        if (both) {\n            buffer.append(')');\n        }\n\n        if (optional && outer) {\n            buffer.append(']');\n        }\n\n        if (arguments) {\n            for (final Iterator i = anonymous.iterator(); i.hasNext();) {\n                buffer.append(' ');\n\n                final Option option = (Option) i.next();\n                option.appendUsage(buffer, helpSettingsCopy, comp);\n            }\n        }\n\n        if (optional && !outer) {\n            buffer.append(']');\n        }\n    }\n\n    public List helpLines(final int depth, final Set helpSettings, final Comparator comp) {\n        final List helpLines = new ArrayList();\n\n        if (helpSettings.contains(DisplaySetting.DISPLAY_GROUP_NAME)) {\n            final HelpLine helpLine = new HelpLineImpl(this, depth);\n            helpLines.add(helpLine);\n        }\n\n        if (helpSettings.contains(DisplaySetting.DISPLAY_GROUP_EXPANDED)) {\n            \n            final List list;\n\n            if (comp == null) {\n                \n                list = options;\n            } else {\n                \n                list = new ArrayList(options);\n                Collections.sort(list, comp);\n            }\n\n            \n            for (final Iterator i = list.iterator(); i.hasNext();) {\n                final Option option = (Option) i.next();\n                helpLines.addAll(option.helpLines(depth + 1, helpSettings, comp));\n            }\n        }\n\n        if (helpSettings.contains(DisplaySetting.DISPLAY_GROUP_ARGUMENT)) {\n            for (final Iterator i = anonymous.iterator(); i.hasNext();) {\n                final Option option = (Option) i.next();\n                helpLines.addAll(option.helpLines(depth + 1, helpSettings, comp));\n            }\n        }\n\n        return helpLines;\n    }\n\n    \n    public List getOptions() {\n        return options;\n    }\n\n    \n    public List getAnonymous() {\n        return anonymous;\n    }\n\n    public Option findOption(final String trigger) {\n        final Iterator i = getOptions().iterator();\n\n        while (i.hasNext()) {\n            final Option option = (Option) i.next();\n            final Option found = option.findOption(trigger);\n\n            if (found != null) {\n                return found;\n            }\n        }\n\n        return null;\n    }\n\n    public int getMinimum() {\n        return minimum;\n    }\n\n    public int getMaximum() {\n        return maximum;\n    }\n\n    public boolean isRequired() {\n        return getMinimum() > 0;\n    }\n\n    public void defaults(final WriteableCommandLine commandLine) {\n        super.defaults(commandLine);\n\n        for (final Iterator i = options.iterator(); i.hasNext();) {\n            final Option option = (Option) i.next();\n            option.defaults(commandLine);\n        }\n\n        for (final Iterator i = anonymous.iterator(); i.hasNext();) {\n            final Option option = (Option) i.next();\n            option.defaults(commandLine);\n        }\n    }\n}\n\n\nclass ReverseStringComparator implements Comparator {\n    private static final Comparator instance = new ReverseStringComparator(); private ReverseStringComparator() {\n        \n    }\n\n    \n    public static final Comparator getInstance() {\n        return instance;\n    }\n\n    public int compare(final Object o1, final Object o2) {\n        final String s1 = (String) o1;\n        final String s2 = (String) o2;\n\n        return -s1.compareTo(s2);\n    }\n}\n",
      "buggy_signatures": [
        "public class GroupImpl extends OptionImpl implements Group { private final String name; private final String description; private final List options; private final int minimum; private final int maximum; private final List anonymous; private final SortedMap optionMap; private final Set prefixes; public GroupImpl(final List options, final String name, final String description, final int minimum, final int maximum)",
        "public boolean canProcess(final WriteableCommandLine commandLine, final String arg)",
        "public Set getPrefixes()",
        "public Set getTriggers()",
        "public void process(final WriteableCommandLine commandLine, final ListIterator arguments) throws OptionException",
        "public void validate(final WriteableCommandLine commandLine) throws OptionException",
        "public String getPreferredName()",
        "public String getDescription()",
        "public void appendUsage(final StringBuffer buffer, final Set helpSettings, final Comparator comp)",
        "public void appendUsage(final StringBuffer buffer, final Set helpSettings, final Comparator comp, final String separator)",
        "public List helpLines(final int depth, final Set helpSettings, final Comparator comp)",
        "public List getOptions()",
        "public List getAnonymous()",
        "public Option findOption(final String trigger)",
        "public int getMinimum()",
        "public int getMaximum()",
        "public boolean isRequired()",
        "public void defaults(final WriteableCommandLine commandLine)",
        "public static final Comparator getInstance()",
        "public int compare(final Object o1, final Object o2)"
      ],
      "fixed_signatures": [
        "public class GroupImpl extends OptionImpl implements Group { private final String name; private final String description; private final List options; private final int minimum; private final int maximum; private final List anonymous; private final SortedMap optionMap; private final Set prefixes; public GroupImpl(final List options, final String name, final String description, final int minimum, final int maximum)",
        "public boolean canProcess(final WriteableCommandLine commandLine, final String arg)",
        "public Set getPrefixes()",
        "public Set getTriggers()",
        "public void process(final WriteableCommandLine commandLine, final ListIterator arguments) throws OptionException",
        "public void validate(final WriteableCommandLine commandLine) throws OptionException",
        "public String getPreferredName()",
        "public String getDescription()",
        "public void appendUsage(final StringBuffer buffer, final Set helpSettings, final Comparator comp)",
        "public void appendUsage(final StringBuffer buffer, final Set helpSettings, final Comparator comp, final String separator)",
        "public List helpLines(final int depth, final Set helpSettings, final Comparator comp)",
        "public List getOptions()",
        "public List getAnonymous()",
        "public Option findOption(final String trigger)",
        "public int getMinimum()",
        "public int getMaximum()",
        "public boolean isRequired()",
        "public void defaults(final WriteableCommandLine commandLine)",
        "public static final Comparator getInstance()",
        "public int compare(final Object o1, final Object o2)"
      ],
      "methods": [
        {
          "buggy_method": "  public void validate(final WriteableCommandLine commandLine) throws OptionException {\n  \n  int present = 0;\n\n  \n  Option unexpected = null;\n\n  for (final Iterator i = options.iterator(); i.hasNext();) {\n  final Option option = (Option) i.next();\n\n  \n  boolean validate = option.isRequired() || option instanceof Group;\n  if (validate) {\n  option.validate(commandLine);\n  }\n\n  \n  if (commandLine.hasOption(option)) {\n  if (++present > maximum) {\n  unexpected = option;\n\n  break;\n  }\n\n  option.validate(commandLine);\n  }\n  }\n\n  \n  if (unexpected != null) {\n  throw new OptionException(this, ResourceConstants.UNEXPECTED_TOKEN,\n  unexpected.getPreferredName());\n  }\n\n  \n  if (present < minimum) {\n  throw new OptionException(this, ResourceConstants.MISSING_OPTION);\n  }\n\n  \n  for (final Iterator i = anonymous.iterator(); i.hasNext();) {\n  final Option option = (Option) i.next();\n  option.validate(commandLine);\n  }\n  }",
          "fixed_method": "  public void validate(final WriteableCommandLine commandLine) throws OptionException {\n  \n  int present = 0;\n\n  \n  Option unexpected = null;\n\n  for (final Iterator i = options.iterator(); i.hasNext();) {\n  final Option option = (Option) i.next();\n\n  \n  boolean validate = option.isRequired() || option instanceof Group;\n\n  \n  if (commandLine.hasOption(option)) {\n  if (++present > maximum) {\n  unexpected = option;\n\n  break;\n  }\n  validate = true;\n  }\n\n  if (validate) {\n  option.validate(commandLine);\n  }\n  }\n\n  \n  if (unexpected != null) {\n  throw new OptionException(this, ResourceConstants.UNEXPECTED_TOKEN,\n  unexpected.getPreferredName());\n  }\n\n  \n  if (present < minimum) {\n  throw new OptionException(this, ResourceConstants.MISSING_OPTION);\n  }\n\n  \n  for (final Iterator i = anonymous.iterator(); i.hasNext();) {\n  final Option option = (Option) i.next();\n  option.validate(commandLine);\n  }\n  }",
          "diff": [
            "@@ -247,9 +247,6 @@",
            " \n",
            "             // needs validation?\n",
            "             boolean validate = option.isRequired() || option instanceof Group;\n",
            "-            if (validate) {\n",
            "-                option.validate(commandLine);\n",
            "-            }\n",
            " \n",
            "             // if the child option is present then validate it\n",
            "             if (commandLine.hasOption(option)) {\n",
            "@@ -258,7 +255,10 @@",
            " \n",
            "                     break;\n",
            "                 }\n",
            "-\n",
            "+                validate = true;\n",
            "+            }\n",
            "+\n",
            "+            if (validate) {\n",
            "                 option.validate(commandLine);\n",
            "             }\n",
            "         }\n"
          ],
          "changed_lines": 8
        }
      ]
    }
  ]
}
