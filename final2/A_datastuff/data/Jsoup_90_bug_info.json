{
  "bug_id": "90",
  "failed_tests": {
    "org.jsoup.helper.HttpConnectionTest": [
      {
        "methodName": "handlesHeaderEncodingOnRequest",
        "error": "java.lang.ArrayIndexOutOfBoundsException",
        "message": "Index 1 out of bounds for length 1",
        "fail_line": "        req.addHeader(\"xxx\", \"Ã©\");",
        "test_source": "",
        "stack": [
          "HttpConnection$Base.looksLikeUtf8 line 427, HttpConnection$Base.fixHeaderEncoding line 389, HttpConnection$Base.addHeader line 375, HttpConnection$Request.addHeader line 534, HttpConnectionTest.handlesHeaderEncodingOnRequest line 256, MultiLocaleRule$1.evaluate line 22"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/jsoup/helper/HttpConnection.java",
      "buggy_full_code": "package org.jsoup.helper;\n\nimport org.jsoup.Connection;\nimport org.jsoup.HttpStatusException;\nimport org.jsoup.UncheckedIOException;\nimport org.jsoup.UnsupportedMimeTypeException;\nimport org.jsoup.internal.ConstrainableInputStream;\nimport org.jsoup.internal.StringUtil;\nimport org.jsoup.nodes.Document;\nimport org.jsoup.parser.Parser;\nimport org.jsoup.parser.TokenQueue;\n\nimport javax.net.ssl.HttpsURLConnection;\nimport javax.net.ssl.SSLSocketFactory;\nimport java.io.BufferedInputStream;\nimport java.io.BufferedWriter;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.UnsupportedEncodingException;\nimport java.net.HttpURLConnection;\nimport java.net.InetSocketAddress;\nimport java.net.MalformedURLException;\nimport java.net.Proxy;\nimport java.net.URI;\nimport java.net.URL;\nimport java.net.URLEncoder;\nimport java.nio.Buffer;\nimport java.nio.ByteBuffer;\nimport java.nio.charset.Charset;\nimport java.nio.charset.IllegalCharsetNameException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.regex.Pattern;\nimport java.util.zip.GZIPInputStream;\nimport java.util.zip.Inflater;\nimport java.util.zip.InflaterInputStream;\n\nimport static org.jsoup.Connection.Method.HEAD; import static org.jsoup.internal.Normalizer.lowerCase; public class HttpConnection implements Connection { public static final String CONTENT_ENCODING = \"Content-Encoding\"; public static final String DEFAULT_UA = \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.143 Safari/537.36\"; private static final String USER_AGENT = \"User-Agent\"; public static final String CONTENT_TYPE = \"Content-Type\"; public static final String MULTIPART_FORM_DATA = \"multipart/form-data\"; public static final String FORM_URL_ENCODED = \"application/x-www-form-urlencoded\"; private static final int HTTP_TEMP_REDIR = 307; private static final String DefaultUploadType = \"application/octet-stream\"; public static Connection connect(String url) {\n        Connection con = new HttpConnection();\n        con.url(url);\n        return con;\n    }\n\n    public static Connection connect(URL url) {\n        Connection con = new HttpConnection();\n        con.url(url);\n        return con;\n    }\n\n    public HttpConnection() {\n        req = new Request();\n        res = new Response();\n    }\n\n    \n\tprivate static String encodeUrl(String url) {\n        try {\n            URL u = new URL(url);\n            return encodeUrl(u).toExternalForm();\n        } catch (Exception e) {\n            return url;\n        }\n\t}\n\n    static URL encodeUrl(URL u) {\n        try {\n            \n            String urlS = u.toExternalForm(); \n            urlS = urlS.replaceAll(\" \", \"%20\");\n            final URI uri = new URI(urlS);\n            return new URL(uri.toASCIIString());\n        } catch (Exception e) {\n            return u;\n        }\n    }\n\n    private static String encodeMimeName(String val) {\n        if (val == null)\n            return null;\n        return val.replaceAll(\"\\\"\", \"%22\");\n    }\n\n    private Connection.Request req; private Connection.Response res; public Connection url(URL url) {\n        req.url(url);\n        return this;\n    }\n\n    public Connection url(String url) {\n        Validate.notEmpty(url, \"Must supply a valid URL\");\n        try {\n            req.url(new URL(encodeUrl(url)));\n        } catch (MalformedURLException e) {\n            throw new IllegalArgumentException(\"Malformed URL: \" + url, e);\n        }\n        return this;\n    }\n\n    public Connection proxy(Proxy proxy) {\n        req.proxy(proxy);\n        return this;\n    }\n\n    public Connection proxy(String host, int port) {\n        req.proxy(host, port);\n        return this;\n    }\n\n    public Connection userAgent(String userAgent) {\n        Validate.notNull(userAgent, \"User agent must not be null\");\n        req.header(USER_AGENT, userAgent);\n        return this;\n    }\n\n    public Connection timeout(int millis) {\n        req.timeout(millis);\n        return this;\n    }\n\n    public Connection maxBodySize(int bytes) {\n        req.maxBodySize(bytes);\n        return this;\n    }\n\n    public Connection followRedirects(boolean followRedirects) {\n        req.followRedirects(followRedirects);\n        return this;\n    }\n\n    public Connection referrer(String referrer) {\n        Validate.notNull(referrer, \"Referrer must not be null\");\n        req.header(\"Referer\", referrer);\n        return this;\n    }\n\n    public Connection method(Method method) {\n        req.method(method);\n        return this;\n    }\n\n    public Connection ignoreHttpErrors(boolean ignoreHttpErrors) {\n\t\treq.ignoreHttpErrors(ignoreHttpErrors);\n\t\treturn this;\n\t}\n\n    public Connection ignoreContentType(boolean ignoreContentType) {\n        req.ignoreContentType(ignoreContentType);\n        return this;\n    }\n\n\n    public Connection data(String key, String value) {\n        req.data(KeyVal.create(key, value));\n        return this;\n    }\n\n    public Connection sslSocketFactory(SSLSocketFactory sslSocketFactory) {\n\t    req.sslSocketFactory(sslSocketFactory);\n\t    return this;\n    }\n\n    public Connection data(String key, String filename, InputStream inputStream) {\n        req.data(KeyVal.create(key, filename, inputStream));\n        return this;\n    }\n\n    @Override\n    public Connection data(String key, String filename, InputStream inputStream, String contentType) {\n        req.data(KeyVal.create(key, filename, inputStream).contentType(contentType));\n        return this;\n    }\n\n    public Connection data(Map<String, String> data) {\n        Validate.notNull(data, \"Data map must not be null\");\n        for (Map.Entry<String, String> entry : data.entrySet()) {\n            req.data(KeyVal.create(entry.getKey(), entry.getValue()));\n        }\n        return this;\n    }\n\n    public Connection data(String... keyvals) {\n        Validate.notNull(keyvals, \"Data key value pairs must not be null\");\n        Validate.isTrue(keyvals.length %2 == 0, \"Must supply an even number of key value pairs\");\n        for (int i = 0; i < keyvals.length; i += 2) {\n            String key = keyvals[i];\n            String value = keyvals[i+1];\n            Validate.notEmpty(key, \"Data key must not be empty\");\n            Validate.notNull(value, \"Data value must not be null\");\n            req.data(KeyVal.create(key, value));\n        }\n        return this;\n    }\n\n    public Connection data(Collection<Connection.KeyVal> data) {\n        Validate.notNull(data, \"Data collection must not be null\");\n        for (Connection.KeyVal entry: data) {\n            req.data(entry);\n        }\n        return this;\n    }\n\n    public Connection.KeyVal data(String key) {\n        Validate.notEmpty(key, \"Data key must not be empty\");\n        for (Connection.KeyVal keyVal : request().data()) {\n            if (keyVal.key().equals(key))\n                return keyVal;\n        }\n        return null;\n    }\n\n    public Connection requestBody(String body) {\n        req.requestBody(body);\n        return this;\n    }\n\n    public Connection header(String name, String value) {\n        req.header(name, value);\n        return this;\n    }\n\n    public Connection headers(Map<String,String> headers) {\n        Validate.notNull(headers, \"Header map must not be null\");\n        for (Map.Entry<String,String> entry : headers.entrySet()) {\n            req.header(entry.getKey(),entry.getValue());\n        }\n        return this;\n    }\n\n    public Connection cookie(String name, String value) {\n        req.cookie(name, value);\n        return this;\n    }\n\n    public Connection cookies(Map<String, String> cookies) {\n        Validate.notNull(cookies, \"Cookie map must not be null\");\n        for (Map.Entry<String, String> entry : cookies.entrySet()) {\n            req.cookie(entry.getKey(), entry.getValue());\n        }\n        return this;\n    }\n\n    public Connection parser(Parser parser) {\n        req.parser(parser);\n        return this;\n    }\n\n    public Document get() throws IOException {\n        req.method(Method.GET);\n        execute();\n        return res.parse();\n    }\n\n    public Document post() throws IOException {\n        req.method(Method.POST);\n        execute();\n        return res.parse();\n    }\n\n    public Connection.Response execute() throws IOException {\n        res = Response.execute(req);\n        return res;\n    }\n\n    public Connection.Request request() {\n        return req;\n    }\n\n    public Connection request(Connection.Request request) {\n        req = request;\n        return this;\n    }\n\n    public Connection.Response response() {\n        return res;\n    }\n\n    public Connection response(Connection.Response response) {\n        res = response;\n        return this;\n    }\n\n    public Connection postDataCharset(String charset) {\n        req.postDataCharset(charset);\n        return this;\n    }\n\n    @SuppressWarnings({\"unchecked\"})\n    private static abstract class Base<T extends Connection.Base> implements Connection.Base<T> { URL url; Method method; Map<String, List<String>> headers; Map<String, String> cookies; private Base() {\n            headers = new LinkedHashMap<>();\n            cookies = new LinkedHashMap<>();\n        }\n\n        public URL url() {\n            return url;\n        }\n\n        public T url(URL url) {\n            Validate.notNull(url, \"URL must not be null\");\n            this.url = url;\n            return (T) this;\n        }\n\n        public Method method() {\n            return method;\n        }\n\n        public T method(Method method) {\n            Validate.notNull(method, \"Method must not be null\");\n            this.method = method;\n            return (T) this;\n        }\n\n        public String header(String name) {\n            Validate.notNull(name, \"Header name must not be null\");\n            List<String> vals = getHeadersCaseInsensitive(name);\n            if (vals.size() > 0) {\n                \n                return StringUtil.join(vals, \", \");\n            }\n\n            return null;\n        }\n\n        @Override\n        public T addHeader(String name, String value) {\n            Validate.notEmpty(name);\n            value = value == null ? \"\" : value;\n\n            List<String> values = headers(name);\n            if (values.isEmpty()) {\n                values = new ArrayList<>();\n                headers.put(name, values);\n            }\n            values.add(fixHeaderEncoding(value));\n\n            return (T) this;\n        }\n\n        @Override\n        public List<String> headers(String name) {\n            Validate.notEmpty(name);\n            return getHeadersCaseInsensitive(name);\n        }\n\n        private static String fixHeaderEncoding(String val) {\n            try {\n                byte[] bytes = val.getBytes(\"ISO-8859-1\");\n                if (!looksLikeUtf8(bytes))\n                    return val;\n                return new String(bytes, \"UTF-8\");\n            } catch (UnsupportedEncodingException e) {\n                \n                return val;\n            }\n        }\n\n        private static boolean looksLikeUtf8(byte[] input) {\n            int i = 0;\n            \n            if (input.length >= 3 && (input[0] & 0xFF) == 0xEF\n                && (input[1] & 0xFF) == 0xBB & (input[2] & 0xFF) == 0xBF) {\n                i = 3;\n            }\n\n            int end;\n            for (int j = input.length; i < j; ++i) {\n                int o = input[i];\n                if ((o & 0x80) == 0) {\n                    continue; \n                }\n\n                \n                if ((o & 0xE0) == 0xC0) {\n                    end = i + 1;\n                } else if ((o & 0xF0) == 0xE0) {\n                    end = i + 2;\n                } else if ((o & 0xF8) == 0xF0) {\n                    end = i + 3;\n                } else {\n                    return false;\n                }\n\n\n                while (i < end) {\n                    i++;\n                    o = input[i];\n                    if ((o & 0xC0) != 0x80) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }\n\n        public T header(String name, String value) {\n            Validate.notEmpty(name, \"Header name must not be empty\");\n            removeHeader(name); \n            addHeader(name, value);\n            return (T) this;\n        }\n\n        public boolean hasHeader(String name) {\n            Validate.notEmpty(name, \"Header name must not be empty\");\n            return getHeadersCaseInsensitive(name).size() != 0;\n        }\n\n        \n        public boolean hasHeaderWithValue(String name, String value) {\n            Validate.notEmpty(name);\n            Validate.notEmpty(value);\n            List<String> values = headers(name);\n            for (String candidate : values) {\n                if (value.equalsIgnoreCase(candidate))\n                    return true;\n            }\n            return false;\n        }\n\n        public T removeHeader(String name) {\n            Validate.notEmpty(name, \"Header name must not be empty\");\n            Map.Entry<String, List<String>> entry = scanHeaders(name); \n            if (entry != null)\n                headers.remove(entry.getKey()); \n            return (T) this;\n        }\n\n        public Map<String, String> headers() {\n            LinkedHashMap<String, String> map = new LinkedHashMap<>(headers.size());\n            for (Map.Entry<String, List<String>> entry : headers.entrySet()) {\n                String header = entry.getKey();\n                List<String> values = entry.getValue();\n                if (values.size() > 0)\n                    map.put(header, values.get(0));\n            }\n            return map;\n        }\n\n        @Override\n        public Map<String, List<String>> multiHeaders() {\n            return headers;\n        }\n\n        private List<String> getHeadersCaseInsensitive(String name) {\n            Validate.notNull(name);\n\n            for (Map.Entry<String, List<String>> entry : headers.entrySet()) {\n                if (name.equalsIgnoreCase(entry.getKey()))\n                    return entry.getValue();\n            }\n\n            return Collections.emptyList();\n        }\n\n        private Map.Entry<String, List<String>> scanHeaders(String name) {\n            String lc = lowerCase(name);\n            for (Map.Entry<String, List<String>> entry : headers.entrySet()) {\n                if (lowerCase(entry.getKey()).equals(lc))\n                    return entry;\n            }\n            return null;\n        }\n\n        public String cookie(String name) {\n            Validate.notEmpty(name, \"Cookie name must not be empty\");\n            return cookies.get(name);\n        }\n\n        public T cookie(String name, String value) {\n            Validate.notEmpty(name, \"Cookie name must not be empty\");\n            Validate.notNull(value, \"Cookie value must not be null\");\n            cookies.put(name, value);\n            return (T) this;\n        }\n\n        public boolean hasCookie(String name) {\n            Validate.notEmpty(name, \"Cookie name must not be empty\");\n            return cookies.containsKey(name);\n        }\n\n        public T removeCookie(String name) {\n            Validate.notEmpty(name, \"Cookie name must not be empty\");\n            cookies.remove(name);\n            return (T) this;\n        }\n\n        public Map<String, String> cookies() {\n            return cookies;\n        }\n    }\n\n    public static class Request extends HttpConnection.Base<Connection.Request> implements Connection.Request { private Proxy proxy; private int timeoutMilliseconds; private int maxBodySizeBytes; private boolean followRedirects; private Collection<Connection.KeyVal> data; private String body = null; private boolean ignoreHttpErrors = false; private boolean ignoreContentType = false; private Parser parser; private boolean parserDefined = false; private String postDataCharset = DataUtil.defaultCharset; private SSLSocketFactory sslSocketFactory; Request() {\n            timeoutMilliseconds = 30000; \n            maxBodySizeBytes = 1024 * 1024; \n            followRedirects = true;\n            data = new ArrayList<>();\n            method = Method.GET;\n            addHeader(\"Accept-Encoding\", \"gzip\");\n            addHeader(USER_AGENT, DEFAULT_UA);\n            parser = Parser.htmlParser();\n        }\n\n        public Proxy proxy() {\n            return proxy;\n        }\n\n        public Request proxy(Proxy proxy) {\n            this.proxy = proxy;\n            return this;\n        }\n\n        public Request proxy(String host, int port) {\n            this.proxy = new Proxy(Proxy.Type.HTTP, InetSocketAddress.createUnresolved(host, port));\n            return this;\n        }\n\n        public int timeout() {\n            return timeoutMilliseconds;\n        }\n\n        public Request timeout(int millis) {\n            Validate.isTrue(millis >= 0, \"Timeout milliseconds must be 0 (infinite) or greater\");\n            timeoutMilliseconds = millis;\n            return this;\n        }\n\n        public int maxBodySize() {\n            return maxBodySizeBytes;\n        }\n\n        public Connection.Request maxBodySize(int bytes) {\n            Validate.isTrue(bytes >= 0, \"maxSize must be 0 (unlimited) or larger\");\n            maxBodySizeBytes = bytes;\n            return this;\n        }\n\n        public boolean followRedirects() {\n            return followRedirects;\n        }\n\n        public Connection.Request followRedirects(boolean followRedirects) {\n            this.followRedirects = followRedirects;\n            return this;\n        }\n\n        public boolean ignoreHttpErrors() {\n            return ignoreHttpErrors;\n        }\n\n        public SSLSocketFactory sslSocketFactory() {\n            return sslSocketFactory;\n        }\n\n        public void sslSocketFactory(SSLSocketFactory sslSocketFactory) {\n            this.sslSocketFactory = sslSocketFactory;\n        }\n\n        public Connection.Request ignoreHttpErrors(boolean ignoreHttpErrors) {\n            this.ignoreHttpErrors = ignoreHttpErrors;\n            return this;\n        }\n\n        public boolean ignoreContentType() {\n            return ignoreContentType;\n        }\n\n        public Connection.Request ignoreContentType(boolean ignoreContentType) {\n            this.ignoreContentType = ignoreContentType;\n            return this;\n        }\n\n        public Request data(Connection.KeyVal keyval) {\n            Validate.notNull(keyval, \"Key val must not be null\");\n            data.add(keyval);\n            return this;\n        }\n\n        public Collection<Connection.KeyVal> data() {\n            return data;\n        }\n\n        public Connection.Request requestBody(String body) {\n            this.body = body;\n            return this;\n        }\n\n        public String requestBody() {\n            return body;\n        }\n\n        public Request parser(Parser parser) {\n            this.parser = parser;\n            parserDefined = true;\n            return this;\n        }\n\n        public Parser parser() {\n            return parser;\n        }\n\n        public Connection.Request postDataCharset(String charset) {\n            Validate.notNull(charset, \"Charset must not be null\");\n            if (!Charset.isSupported(charset)) throw new IllegalCharsetNameException(charset);\n            this.postDataCharset = charset;\n            return this;\n        }\n\n        public String postDataCharset() {\n            return postDataCharset;\n        }\n    }\n\n    public static class Response extends HttpConnection.Base<Connection.Response> implements Connection.Response { private static final int MAX_REDIRECTS = 20; private static final String LOCATION = \"Location\"; private int statusCode; private String statusMessage; private ByteBuffer byteData; private InputStream bodyStream; private HttpURLConnection conn; private String charset; private String contentType; private boolean executed = false; private boolean inputStreamRead = false; private int numRedirects = 0; private Connection.Request req; private static final Pattern xmlContentTypeRxp = Pattern.compile(\"(application|text)/\\\\w*\\\\+?xml.*\"); Response() {\n            super();\n        }\n\n        private Response(Response previousResponse) throws IOException {\n            super();\n            if (previousResponse != null) {\n                numRedirects = previousResponse.numRedirects + 1;\n                if (numRedirects >= MAX_REDIRECTS)\n                    throw new IOException(String.format(\"Too many redirects occurred trying to load URL %s\", previousResponse.url()));\n            }\n        }\n\n        static Response execute(Connection.Request req) throws IOException {\n            return execute(req, null);\n        }\n\n        static Response execute(Connection.Request req, Response previousResponse) throws IOException {\n            Validate.notNull(req, \"Request must not be null\");\n            Validate.notNull(req.url(), \"URL must be specified to connect\");\n            String protocol = req.url().getProtocol();\n            if (!protocol.equals(\"http\") && !protocol.equals(\"https\"))\n                throw new MalformedURLException(\"Only http & https protocols supported\");\n            final boolean methodHasBody = req.method().hasBody();\n            final boolean hasRequestBody = req.requestBody() != null;\n            if (!methodHasBody)\n                Validate.isFalse(hasRequestBody, \"Cannot set a request body for HTTP method \" + req.method());\n\n            \n            String mimeBoundary = null;\n            if (req.data().size() > 0 && (!methodHasBody || hasRequestBody))\n                serialiseRequestUrl(req);\n            else if (methodHasBody)\n                mimeBoundary = setOutputContentType(req);\n\n            long startTime = System.nanoTime();\n            HttpURLConnection conn = createConnection(req);\n            Response res;\n            try {\n                conn.connect();\n                if (conn.getDoOutput())\n                    writePost(req, conn.getOutputStream(), mimeBoundary);\n\n                int status = conn.getResponseCode();\n                res = new Response(previousResponse);\n                res.setupFromConnection(conn, previousResponse);\n                res.req = req;\n\n                \n                if (res.hasHeader(LOCATION) && req.followRedirects()) {\n                    if (status != HTTP_TEMP_REDIR) {\n                        req.method(Method.GET); \n                        req.data().clear();\n                        req.requestBody(null);\n                        req.removeHeader(CONTENT_TYPE);\n                    }\n\n                    String location = res.header(LOCATION);\n                    if (location.startsWith(\"http:/\") && location.charAt(6) != '/') \n                        location = location.substring(6);\n                    URL redir = StringUtil.resolve(req.url(), location);\n                    req.url(encodeUrl(redir));\n\n                    for (Map.Entry<String, String> cookie : res.cookies.entrySet()) { \n                        req.cookie(cookie.getKey(), cookie.getValue());\n                    }\n                    return execute(req, res);\n                }\n                if ((status < 200 || status >= 400) && !req.ignoreHttpErrors())\n                        throw new HttpStatusException(\"HTTP error fetching URL\", status, req.url().toString());\n\n                \n                String contentType = res.contentType();\n                if (contentType != null\n                        && !req.ignoreContentType()\n                        && !contentType.startsWith(\"text/\")\n                        && !xmlContentTypeRxp.matcher(contentType).matches()\n                        )\n                    throw new UnsupportedMimeTypeException(\"Unhandled content type. Must be text\n        private void safeClose() {\n            if (conn != null) {\n                conn.disconnect();\n                conn = null;\n            }\n            if (bodyStream != null) {\n                try {\n                    bodyStream.close();\n                } catch (IOException e) {\n                    \n                } finally {\n                    bodyStream = null;\n                }\n            }\n        }\n\n        \n        private void setupFromConnection(HttpURLConnection conn, HttpConnection.Response previousResponse) throws IOException {\n            this.conn = conn;\n            method = Method.valueOf(conn.getRequestMethod());\n            url = conn.getURL();\n            statusCode = conn.getResponseCode();\n            statusMessage = conn.getResponseMessage();\n            contentType = conn.getContentType();\n\n            Map<String, List<String>> resHeaders = createHeaderMap(conn);\n            processResponseHeaders(resHeaders);\n\n            \n            if (previousResponse != null) {\n                for (Map.Entry<String, String> prevCookie : previousResponse.cookies().entrySet()) {\n                    if (!hasCookie(prevCookie.getKey()))\n                        cookie(prevCookie.getKey(), prevCookie.getValue());\n                }\n                previousResponse.safeClose();\n            }\n        }\n\n        private static LinkedHashMap<String, List<String>> createHeaderMap(HttpURLConnection conn) {\n            \n            final LinkedHashMap<String, List<String>> headers = new LinkedHashMap<>();\n            int i = 0;\n            while (true) {\n                final String key = conn.getHeaderFieldKey(i);\n                final String val = conn.getHeaderField(i);\n                if (key == null && val == null)\n                    break;\n                i++;\n                if (key == null || val == null)\n                    continue; \n\n                if (headers.containsKey(key))\n                    headers.get(key).add(val);\n                else {\n                    final ArrayList<String> vals = new ArrayList<>();\n                    vals.add(val);\n                    headers.put(key, vals);\n                }\n            }\n            return headers;\n        }\n\n        void processResponseHeaders(Map<String, List<String>> resHeaders) {\n            for (Map.Entry<String, List<String>> entry : resHeaders.entrySet()) {\n                String name = entry.getKey();\n                if (name == null)\n                    continue; \n\n                List<String> values = entry.getValue();\n                if (name.equalsIgnoreCase(\"Set-Cookie\")) {\n                    for (String value : values) {\n                        if (value == null)\n                            continue;\n                        TokenQueue cd = new TokenQueue(value);\n                        String cookieName = cd.chompTo(\"=\").trim();\n                        String cookieVal = cd.consumeTo(\";\").trim();\n                        \n                        \n                        if (cookieName.length() > 0)\n                            cookie(cookieName, cookieVal);\n                    }\n                }\n                for (String value : values) {\n                    addHeader(name, value);\n                }\n            }\n        }\n\n        private static String setOutputContentType(final Connection.Request req) {\n            String bound = null;\n            if (req.hasHeader(CONTENT_TYPE)) {\n                \n                \n\n                \n                if(req.header(CONTENT_TYPE).contains(MULTIPART_FORM_DATA) &&\n                        !req.header(CONTENT_TYPE).contains(\"boundary\")) {\n                    bound = DataUtil.mimeBoundary();\n                    req.header(CONTENT_TYPE, MULTIPART_FORM_DATA + \"; boundary=\" + bound);\n                }\n\n            }\n            else if (needsMultipart(req)) {\n                bound = DataUtil.mimeBoundary();\n                req.header(CONTENT_TYPE, MULTIPART_FORM_DATA + \"; boundary=\" + bound);\n            } else {\n                req.header(CONTENT_TYPE, FORM_URL_ENCODED + \"; charset=\" + req.postDataCharset());\n            }\n            return bound;\n        }\n\n        private static void writePost(final Connection.Request req, final OutputStream outputStream, final String bound) throws IOException {\n            final Collection<Connection.KeyVal> data = req.data();\n            final BufferedWriter w = new BufferedWriter(new OutputStreamWriter(outputStream, req.postDataCharset()));\n\n            if (bound != null) {\n                \n                for (Connection.KeyVal keyVal : data) {\n                    w.write(\"--\");\n                    w.write(bound);\n                    w.write(\"\\r\\n\");\n                    w.write(\"Content-Disposition: form-data; name=\\\"\");\n                    w.write(encodeMimeName(keyVal.key())); \n                    w.write(\"\\\"\");\n                    if (keyVal.hasInputStream()) {\n                        w.write(\"; filename=\\\"\");\n                        w.write(encodeMimeName(keyVal.value()));\n                        w.write(\"\\\"\\r\\nContent-Type: \");\n                        w.write(keyVal.contentType() != null ? keyVal.contentType() : DefaultUploadType);\n                        w.write(\"\\r\\n\\r\\n\");\n                        w.flush(); \n                        DataUtil.crossStreams(keyVal.inputStream(), outputStream);\n                        outputStream.flush();\n                    } else {\n                        w.write(\"\\r\\n\\r\\n\");\n                        w.write(keyVal.value());\n                    }\n                    w.write(\"\\r\\n\");\n                }\n                w.write(\"--\");\n                w.write(bound);\n                w.write(\"--\");\n            } else if (req.requestBody() != null) {\n                \n                w.write(req.requestBody());\n            }\n            else {\n                \n                boolean first = true;\n                for (Connection.KeyVal keyVal : data) {\n                    if (!first)\n                        w.append('&');\n                    else\n                        first = false;\n\n                    w.write(URLEncoder.encode(keyVal.key(), req.postDataCharset()));\n                    w.write('=');\n                    w.write(URLEncoder.encode(keyVal.value(), req.postDataCharset()));\n                }\n            }\n            w.close();\n        }\n\n        private static String getRequestCookieString(Connection.Request req) {\n            StringBuilder sb = StringUtil.borrowBuilder();\n            boolean first = true;\n            for (Map.Entry<String, String> cookie : req.cookies().entrySet()) {\n                if (!first)\n                    sb.append(\"; \");\n                else\n                    first = false;\n                sb.append(cookie.getKey()).append('=').append(cookie.getValue());\n                \n            }\n            return StringUtil.releaseBuilder(sb);\n        }\n\n        \n        private static void serialiseRequestUrl(Connection.Request req) throws IOException {\n            URL in = req.url();\n            StringBuilder url = StringUtil.borrowBuilder();\n            boolean first = true;\n            \n            url\n                .append(in.getProtocol())\n                .append(\":\n                .append(in.getAuthority()) \n                .append(in.getPath())\n                .append(\"?\");\n            if (in.getQuery() != null) {\n                url.append(in.getQuery());\n                first = false;\n            }\n            for (Connection.KeyVal keyVal : req.data()) {\n                Validate.isFalse(keyVal.hasInputStream(), \"InputStream data not supported in URL query string.\");\n                if (!first)\n                    url.append('&');\n                else\n                    first = false;\n                url\n                    .append(URLEncoder.encode(keyVal.key(), DataUtil.defaultCharset))\n                    .append('=')\n                    .append(URLEncoder.encode(keyVal.value(), DataUtil.defaultCharset));\n            }\n            req.url(new URL(StringUtil.releaseBuilder(url)));\n            req.data().clear(); \n        }\n    }\n\n    private static boolean needsMultipart(Connection.Request req) {\n        \n        for (Connection.KeyVal keyVal : req.data()) {\n            if (keyVal.hasInputStream())\n                return true;\n        }\n        return false;\n    }\n\n    public static class KeyVal implements Connection.KeyVal { private String key; private String value; private InputStream stream; private String contentType; public static KeyVal create(String key, String value) {\n            return new KeyVal().key(key).value(value);\n        }\n\n        public static KeyVal create(String key, String filename, InputStream stream) {\n            return new KeyVal().key(key).value(filename).inputStream(stream);\n        }\n\n        private KeyVal() {}\n\n        public KeyVal key(String key) {\n            Validate.notEmpty(key, \"Data key must not be empty\");\n            this.key = key;\n            return this;\n        }\n\n        public String key() {\n            return key;\n        }\n\n        public KeyVal value(String value) {\n            Validate.notNull(value, \"Data value must not be null\");\n            this.value = value;\n            return this;\n        }\n\n        public String value() {\n            return value;\n        }\n\n        public KeyVal inputStream(InputStream inputStream) {\n            Validate.notNull(value, \"Data input stream must not be null\");\n            this.stream = inputStream;\n            return this;\n        }\n\n        public InputStream inputStream() {\n            return stream;\n        }\n\n        public boolean hasInputStream() {\n            return stream != null;\n        }\n\n        @Override\n        public Connection.KeyVal contentType(String contentType) {\n            Validate.notEmpty(contentType);\n            this.contentType = contentType;\n            return this;\n        }\n\n        @Override\n        public String contentType() {\n            return contentType;\n        }\n\n        @Override\n        public String toString() {\n            return key + \"=\" + value;\n        }\n    }\n}\n",
      "fixed_full_code": "package org.jsoup.helper;\n\nimport org.jsoup.Connection;\nimport org.jsoup.HttpStatusException;\nimport org.jsoup.UncheckedIOException;\nimport org.jsoup.UnsupportedMimeTypeException;\nimport org.jsoup.internal.ConstrainableInputStream;\nimport org.jsoup.internal.StringUtil;\nimport org.jsoup.nodes.Document;\nimport org.jsoup.parser.Parser;\nimport org.jsoup.parser.TokenQueue;\n\nimport javax.net.ssl.HttpsURLConnection;\nimport javax.net.ssl.SSLSocketFactory;\nimport java.io.BufferedInputStream;\nimport java.io.BufferedWriter;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.UnsupportedEncodingException;\nimport java.net.HttpURLConnection;\nimport java.net.InetSocketAddress;\nimport java.net.MalformedURLException;\nimport java.net.Proxy;\nimport java.net.URI;\nimport java.net.URL;\nimport java.net.URLEncoder;\nimport java.nio.Buffer;\nimport java.nio.ByteBuffer;\nimport java.nio.charset.Charset;\nimport java.nio.charset.IllegalCharsetNameException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.regex.Pattern;\nimport java.util.zip.GZIPInputStream;\nimport java.util.zip.Inflater;\nimport java.util.zip.InflaterInputStream;\n\nimport static org.jsoup.Connection.Method.HEAD; import static org.jsoup.internal.Normalizer.lowerCase; public class HttpConnection implements Connection { public static final String CONTENT_ENCODING = \"Content-Encoding\"; public static final String DEFAULT_UA = \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.143 Safari/537.36\"; private static final String USER_AGENT = \"User-Agent\"; public static final String CONTENT_TYPE = \"Content-Type\"; public static final String MULTIPART_FORM_DATA = \"multipart/form-data\"; public static final String FORM_URL_ENCODED = \"application/x-www-form-urlencoded\"; private static final int HTTP_TEMP_REDIR = 307; private static final String DefaultUploadType = \"application/octet-stream\"; public static Connection connect(String url) {\n        Connection con = new HttpConnection();\n        con.url(url);\n        return con;\n    }\n\n    public static Connection connect(URL url) {\n        Connection con = new HttpConnection();\n        con.url(url);\n        return con;\n    }\n\n    public HttpConnection() {\n        req = new Request();\n        res = new Response();\n    }\n\n    \n\tprivate static String encodeUrl(String url) {\n        try {\n            URL u = new URL(url);\n            return encodeUrl(u).toExternalForm();\n        } catch (Exception e) {\n            return url;\n        }\n\t}\n\n    static URL encodeUrl(URL u) {\n        try {\n            \n            String urlS = u.toExternalForm(); \n            urlS = urlS.replaceAll(\" \", \"%20\");\n            final URI uri = new URI(urlS);\n            return new URL(uri.toASCIIString());\n        } catch (Exception e) {\n            return u;\n        }\n    }\n\n    private static String encodeMimeName(String val) {\n        if (val == null)\n            return null;\n        return val.replaceAll(\"\\\"\", \"%22\");\n    }\n\n    private Connection.Request req; private Connection.Response res; public Connection url(URL url) {\n        req.url(url);\n        return this;\n    }\n\n    public Connection url(String url) {\n        Validate.notEmpty(url, \"Must supply a valid URL\");\n        try {\n            req.url(new URL(encodeUrl(url)));\n        } catch (MalformedURLException e) {\n            throw new IllegalArgumentException(\"Malformed URL: \" + url, e);\n        }\n        return this;\n    }\n\n    public Connection proxy(Proxy proxy) {\n        req.proxy(proxy);\n        return this;\n    }\n\n    public Connection proxy(String host, int port) {\n        req.proxy(host, port);\n        return this;\n    }\n\n    public Connection userAgent(String userAgent) {\n        Validate.notNull(userAgent, \"User agent must not be null\");\n        req.header(USER_AGENT, userAgent);\n        return this;\n    }\n\n    public Connection timeout(int millis) {\n        req.timeout(millis);\n        return this;\n    }\n\n    public Connection maxBodySize(int bytes) {\n        req.maxBodySize(bytes);\n        return this;\n    }\n\n    public Connection followRedirects(boolean followRedirects) {\n        req.followRedirects(followRedirects);\n        return this;\n    }\n\n    public Connection referrer(String referrer) {\n        Validate.notNull(referrer, \"Referrer must not be null\");\n        req.header(\"Referer\", referrer);\n        return this;\n    }\n\n    public Connection method(Method method) {\n        req.method(method);\n        return this;\n    }\n\n    public Connection ignoreHttpErrors(boolean ignoreHttpErrors) {\n\t\treq.ignoreHttpErrors(ignoreHttpErrors);\n\t\treturn this;\n\t}\n\n    public Connection ignoreContentType(boolean ignoreContentType) {\n        req.ignoreContentType(ignoreContentType);\n        return this;\n    }\n\n\n    public Connection data(String key, String value) {\n        req.data(KeyVal.create(key, value));\n        return this;\n    }\n\n    public Connection sslSocketFactory(SSLSocketFactory sslSocketFactory) {\n\t    req.sslSocketFactory(sslSocketFactory);\n\t    return this;\n    }\n\n    public Connection data(String key, String filename, InputStream inputStream) {\n        req.data(KeyVal.create(key, filename, inputStream));\n        return this;\n    }\n\n    @Override\n    public Connection data(String key, String filename, InputStream inputStream, String contentType) {\n        req.data(KeyVal.create(key, filename, inputStream).contentType(contentType));\n        return this;\n    }\n\n    public Connection data(Map<String, String> data) {\n        Validate.notNull(data, \"Data map must not be null\");\n        for (Map.Entry<String, String> entry : data.entrySet()) {\n            req.data(KeyVal.create(entry.getKey(), entry.getValue()));\n        }\n        return this;\n    }\n\n    public Connection data(String... keyvals) {\n        Validate.notNull(keyvals, \"Data key value pairs must not be null\");\n        Validate.isTrue(keyvals.length %2 == 0, \"Must supply an even number of key value pairs\");\n        for (int i = 0; i < keyvals.length; i += 2) {\n            String key = keyvals[i];\n            String value = keyvals[i+1];\n            Validate.notEmpty(key, \"Data key must not be empty\");\n            Validate.notNull(value, \"Data value must not be null\");\n            req.data(KeyVal.create(key, value));\n        }\n        return this;\n    }\n\n    public Connection data(Collection<Connection.KeyVal> data) {\n        Validate.notNull(data, \"Data collection must not be null\");\n        for (Connection.KeyVal entry: data) {\n            req.data(entry);\n        }\n        return this;\n    }\n\n    public Connection.KeyVal data(String key) {\n        Validate.notEmpty(key, \"Data key must not be empty\");\n        for (Connection.KeyVal keyVal : request().data()) {\n            if (keyVal.key().equals(key))\n                return keyVal;\n        }\n        return null;\n    }\n\n    public Connection requestBody(String body) {\n        req.requestBody(body);\n        return this;\n    }\n\n    public Connection header(String name, String value) {\n        req.header(name, value);\n        return this;\n    }\n\n    public Connection headers(Map<String,String> headers) {\n        Validate.notNull(headers, \"Header map must not be null\");\n        for (Map.Entry<String,String> entry : headers.entrySet()) {\n            req.header(entry.getKey(),entry.getValue());\n        }\n        return this;\n    }\n\n    public Connection cookie(String name, String value) {\n        req.cookie(name, value);\n        return this;\n    }\n\n    public Connection cookies(Map<String, String> cookies) {\n        Validate.notNull(cookies, \"Cookie map must not be null\");\n        for (Map.Entry<String, String> entry : cookies.entrySet()) {\n            req.cookie(entry.getKey(), entry.getValue());\n        }\n        return this;\n    }\n\n    public Connection parser(Parser parser) {\n        req.parser(parser);\n        return this;\n    }\n\n    public Document get() throws IOException {\n        req.method(Method.GET);\n        execute();\n        return res.parse();\n    }\n\n    public Document post() throws IOException {\n        req.method(Method.POST);\n        execute();\n        return res.parse();\n    }\n\n    public Connection.Response execute() throws IOException {\n        res = Response.execute(req);\n        return res;\n    }\n\n    public Connection.Request request() {\n        return req;\n    }\n\n    public Connection request(Connection.Request request) {\n        req = request;\n        return this;\n    }\n\n    public Connection.Response response() {\n        return res;\n    }\n\n    public Connection response(Connection.Response response) {\n        res = response;\n        return this;\n    }\n\n    public Connection postDataCharset(String charset) {\n        req.postDataCharset(charset);\n        return this;\n    }\n\n    @SuppressWarnings({\"unchecked\"})\n    private static abstract class Base<T extends Connection.Base> implements Connection.Base<T> { URL url; Method method; Map<String, List<String>> headers; Map<String, String> cookies; private Base() {\n            headers = new LinkedHashMap<>();\n            cookies = new LinkedHashMap<>();\n        }\n\n        public URL url() {\n            return url;\n        }\n\n        public T url(URL url) {\n            Validate.notNull(url, \"URL must not be null\");\n            this.url = url;\n            return (T) this;\n        }\n\n        public Method method() {\n            return method;\n        }\n\n        public T method(Method method) {\n            Validate.notNull(method, \"Method must not be null\");\n            this.method = method;\n            return (T) this;\n        }\n\n        public String header(String name) {\n            Validate.notNull(name, \"Header name must not be null\");\n            List<String> vals = getHeadersCaseInsensitive(name);\n            if (vals.size() > 0) {\n                \n                return StringUtil.join(vals, \", \");\n            }\n\n            return null;\n        }\n\n        @Override\n        public T addHeader(String name, String value) {\n            Validate.notEmpty(name);\n            value = value == null ? \"\" : value;\n\n            List<String> values = headers(name);\n            if (values.isEmpty()) {\n                values = new ArrayList<>();\n                headers.put(name, values);\n            }\n            values.add(fixHeaderEncoding(value));\n\n            return (T) this;\n        }\n\n        @Override\n        public List<String> headers(String name) {\n            Validate.notEmpty(name);\n            return getHeadersCaseInsensitive(name);\n        }\n\n        private static String fixHeaderEncoding(String val) {\n            try {\n                byte[] bytes = val.getBytes(\"ISO-8859-1\");\n                if (!looksLikeUtf8(bytes))\n                    return val;\n                return new String(bytes, \"UTF-8\");\n            } catch (UnsupportedEncodingException e) {\n                \n                return val;\n            }\n        }\n\n        private static boolean looksLikeUtf8(byte[] input) {\n            int i = 0;\n            \n            if (input.length >= 3 && (input[0] & 0xFF) == 0xEF\n                && (input[1] & 0xFF) == 0xBB & (input[2] & 0xFF) == 0xBF) {\n                i = 3;\n            }\n\n            int end;\n            for (int j = input.length; i < j; ++i) {\n                int o = input[i];\n                if ((o & 0x80) == 0) {\n                    continue; \n                }\n\n                \n                if ((o & 0xE0) == 0xC0) {\n                    end = i + 1;\n                } else if ((o & 0xF0) == 0xE0) {\n                    end = i + 2;\n                } else if ((o & 0xF8) == 0xF0) {\n                    end = i + 3;\n                } else {\n                    return false;\n                }\n\n                if (end >= input.length)\n                    return false;\n\n                while (i < end) {\n                    i++;\n                    o = input[i];\n                    if ((o & 0xC0) != 0x80) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }\n\n        public T header(String name, String value) {\n            Validate.notEmpty(name, \"Header name must not be empty\");\n            removeHeader(name); \n            addHeader(name, value);\n            return (T) this;\n        }\n\n        public boolean hasHeader(String name) {\n            Validate.notEmpty(name, \"Header name must not be empty\");\n            return getHeadersCaseInsensitive(name).size() != 0;\n        }\n\n        \n        public boolean hasHeaderWithValue(String name, String value) {\n            Validate.notEmpty(name);\n            Validate.notEmpty(value);\n            List<String> values = headers(name);\n            for (String candidate : values) {\n                if (value.equalsIgnoreCase(candidate))\n                    return true;\n            }\n            return false;\n        }\n\n        public T removeHeader(String name) {\n            Validate.notEmpty(name, \"Header name must not be empty\");\n            Map.Entry<String, List<String>> entry = scanHeaders(name); \n            if (entry != null)\n                headers.remove(entry.getKey()); \n            return (T) this;\n        }\n\n        public Map<String, String> headers() {\n            LinkedHashMap<String, String> map = new LinkedHashMap<>(headers.size());\n            for (Map.Entry<String, List<String>> entry : headers.entrySet()) {\n                String header = entry.getKey();\n                List<String> values = entry.getValue();\n                if (values.size() > 0)\n                    map.put(header, values.get(0));\n            }\n            return map;\n        }\n\n        @Override\n        public Map<String, List<String>> multiHeaders() {\n            return headers;\n        }\n\n        private List<String> getHeadersCaseInsensitive(String name) {\n            Validate.notNull(name);\n\n            for (Map.Entry<String, List<String>> entry : headers.entrySet()) {\n                if (name.equalsIgnoreCase(entry.getKey()))\n                    return entry.getValue();\n            }\n\n            return Collections.emptyList();\n        }\n\n        private Map.Entry<String, List<String>> scanHeaders(String name) {\n            String lc = lowerCase(name);\n            for (Map.Entry<String, List<String>> entry : headers.entrySet()) {\n                if (lowerCase(entry.getKey()).equals(lc))\n                    return entry;\n            }\n            return null;\n        }\n\n        public String cookie(String name) {\n            Validate.notEmpty(name, \"Cookie name must not be empty\");\n            return cookies.get(name);\n        }\n\n        public T cookie(String name, String value) {\n            Validate.notEmpty(name, \"Cookie name must not be empty\");\n            Validate.notNull(value, \"Cookie value must not be null\");\n            cookies.put(name, value);\n            return (T) this;\n        }\n\n        public boolean hasCookie(String name) {\n            Validate.notEmpty(name, \"Cookie name must not be empty\");\n            return cookies.containsKey(name);\n        }\n\n        public T removeCookie(String name) {\n            Validate.notEmpty(name, \"Cookie name must not be empty\");\n            cookies.remove(name);\n            return (T) this;\n        }\n\n        public Map<String, String> cookies() {\n            return cookies;\n        }\n    }\n\n    public static class Request extends HttpConnection.Base<Connection.Request> implements Connection.Request { private Proxy proxy; private int timeoutMilliseconds; private int maxBodySizeBytes; private boolean followRedirects; private Collection<Connection.KeyVal> data; private String body = null; private boolean ignoreHttpErrors = false; private boolean ignoreContentType = false; private Parser parser; private boolean parserDefined = false; private String postDataCharset = DataUtil.defaultCharset; private SSLSocketFactory sslSocketFactory; Request() {\n            timeoutMilliseconds = 30000; \n            maxBodySizeBytes = 1024 * 1024; \n            followRedirects = true;\n            data = new ArrayList<>();\n            method = Method.GET;\n            addHeader(\"Accept-Encoding\", \"gzip\");\n            addHeader(USER_AGENT, DEFAULT_UA);\n            parser = Parser.htmlParser();\n        }\n\n        public Proxy proxy() {\n            return proxy;\n        }\n\n        public Request proxy(Proxy proxy) {\n            this.proxy = proxy;\n            return this;\n        }\n\n        public Request proxy(String host, int port) {\n            this.proxy = new Proxy(Proxy.Type.HTTP, InetSocketAddress.createUnresolved(host, port));\n            return this;\n        }\n\n        public int timeout() {\n            return timeoutMilliseconds;\n        }\n\n        public Request timeout(int millis) {\n            Validate.isTrue(millis >= 0, \"Timeout milliseconds must be 0 (infinite) or greater\");\n            timeoutMilliseconds = millis;\n            return this;\n        }\n\n        public int maxBodySize() {\n            return maxBodySizeBytes;\n        }\n\n        public Connection.Request maxBodySize(int bytes) {\n            Validate.isTrue(bytes >= 0, \"maxSize must be 0 (unlimited) or larger\");\n            maxBodySizeBytes = bytes;\n            return this;\n        }\n\n        public boolean followRedirects() {\n            return followRedirects;\n        }\n\n        public Connection.Request followRedirects(boolean followRedirects) {\n            this.followRedirects = followRedirects;\n            return this;\n        }\n\n        public boolean ignoreHttpErrors() {\n            return ignoreHttpErrors;\n        }\n\n        public SSLSocketFactory sslSocketFactory() {\n            return sslSocketFactory;\n        }\n\n        public void sslSocketFactory(SSLSocketFactory sslSocketFactory) {\n            this.sslSocketFactory = sslSocketFactory;\n        }\n\n        public Connection.Request ignoreHttpErrors(boolean ignoreHttpErrors) {\n            this.ignoreHttpErrors = ignoreHttpErrors;\n            return this;\n        }\n\n        public boolean ignoreContentType() {\n            return ignoreContentType;\n        }\n\n        public Connection.Request ignoreContentType(boolean ignoreContentType) {\n            this.ignoreContentType = ignoreContentType;\n            return this;\n        }\n\n        public Request data(Connection.KeyVal keyval) {\n            Validate.notNull(keyval, \"Key val must not be null\");\n            data.add(keyval);\n            return this;\n        }\n\n        public Collection<Connection.KeyVal> data() {\n            return data;\n        }\n\n        public Connection.Request requestBody(String body) {\n            this.body = body;\n            return this;\n        }\n\n        public String requestBody() {\n            return body;\n        }\n\n        public Request parser(Parser parser) {\n            this.parser = parser;\n            parserDefined = true;\n            return this;\n        }\n\n        public Parser parser() {\n            return parser;\n        }\n\n        public Connection.Request postDataCharset(String charset) {\n            Validate.notNull(charset, \"Charset must not be null\");\n            if (!Charset.isSupported(charset)) throw new IllegalCharsetNameException(charset);\n            this.postDataCharset = charset;\n            return this;\n        }\n\n        public String postDataCharset() {\n            return postDataCharset;\n        }\n    }\n\n    public static class Response extends HttpConnection.Base<Connection.Response> implements Connection.Response { private static final int MAX_REDIRECTS = 20; private static final String LOCATION = \"Location\"; private int statusCode; private String statusMessage; private ByteBuffer byteData; private InputStream bodyStream; private HttpURLConnection conn; private String charset; private String contentType; private boolean executed = false; private boolean inputStreamRead = false; private int numRedirects = 0; private Connection.Request req; private static final Pattern xmlContentTypeRxp = Pattern.compile(\"(application|text)/\\\\w*\\\\+?xml.*\"); Response() {\n            super();\n        }\n\n        private Response(Response previousResponse) throws IOException {\n            super();\n            if (previousResponse != null) {\n                numRedirects = previousResponse.numRedirects + 1;\n                if (numRedirects >= MAX_REDIRECTS)\n                    throw new IOException(String.format(\"Too many redirects occurred trying to load URL %s\", previousResponse.url()));\n            }\n        }\n\n        static Response execute(Connection.Request req) throws IOException {\n            return execute(req, null);\n        }\n\n        static Response execute(Connection.Request req, Response previousResponse) throws IOException {\n            Validate.notNull(req, \"Request must not be null\");\n            Validate.notNull(req.url(), \"URL must be specified to connect\");\n            String protocol = req.url().getProtocol();\n            if (!protocol.equals(\"http\") && !protocol.equals(\"https\"))\n                throw new MalformedURLException(\"Only http & https protocols supported\");\n            final boolean methodHasBody = req.method().hasBody();\n            final boolean hasRequestBody = req.requestBody() != null;\n            if (!methodHasBody)\n                Validate.isFalse(hasRequestBody, \"Cannot set a request body for HTTP method \" + req.method());\n\n            \n            String mimeBoundary = null;\n            if (req.data().size() > 0 && (!methodHasBody || hasRequestBody))\n                serialiseRequestUrl(req);\n            else if (methodHasBody)\n                mimeBoundary = setOutputContentType(req);\n\n            long startTime = System.nanoTime();\n            HttpURLConnection conn = createConnection(req);\n            Response res;\n            try {\n                conn.connect();\n                if (conn.getDoOutput())\n                    writePost(req, conn.getOutputStream(), mimeBoundary);\n\n                int status = conn.getResponseCode();\n                res = new Response(previousResponse);\n                res.setupFromConnection(conn, previousResponse);\n                res.req = req;\n\n                \n                if (res.hasHeader(LOCATION) && req.followRedirects()) {\n                    if (status != HTTP_TEMP_REDIR) {\n                        req.method(Method.GET); \n                        req.data().clear();\n                        req.requestBody(null);\n                        req.removeHeader(CONTENT_TYPE);\n                    }\n\n                    String location = res.header(LOCATION);\n                    if (location.startsWith(\"http:/\") && location.charAt(6) != '/') \n                        location = location.substring(6);\n                    URL redir = StringUtil.resolve(req.url(), location);\n                    req.url(encodeUrl(redir));\n\n                    for (Map.Entry<String, String> cookie : res.cookies.entrySet()) { \n                        req.cookie(cookie.getKey(), cookie.getValue());\n                    }\n                    return execute(req, res);\n                }\n                if ((status < 200 || status >= 400) && !req.ignoreHttpErrors())\n                        throw new HttpStatusException(\"HTTP error fetching URL\", status, req.url().toString());\n\n                \n                String contentType = res.contentType();\n                if (contentType != null\n                        && !req.ignoreContentType()\n                        && !contentType.startsWith(\"text/\")\n                        && !xmlContentTypeRxp.matcher(contentType).matches()\n                        )\n                    throw new UnsupportedMimeTypeException(\"Unhandled content type. Must be text\n        private void safeClose() {\n            if (conn != null) {\n                conn.disconnect();\n                conn = null;\n            }\n            if (bodyStream != null) {\n                try {\n                    bodyStream.close();\n                } catch (IOException e) {\n                    \n                } finally {\n                    bodyStream = null;\n                }\n            }\n        }\n\n        \n        private void setupFromConnection(HttpURLConnection conn, HttpConnection.Response previousResponse) throws IOException {\n            this.conn = conn;\n            method = Method.valueOf(conn.getRequestMethod());\n            url = conn.getURL();\n            statusCode = conn.getResponseCode();\n            statusMessage = conn.getResponseMessage();\n            contentType = conn.getContentType();\n\n            Map<String, List<String>> resHeaders = createHeaderMap(conn);\n            processResponseHeaders(resHeaders);\n\n            \n            if (previousResponse != null) {\n                for (Map.Entry<String, String> prevCookie : previousResponse.cookies().entrySet()) {\n                    if (!hasCookie(prevCookie.getKey()))\n                        cookie(prevCookie.getKey(), prevCookie.getValue());\n                }\n                previousResponse.safeClose();\n            }\n        }\n\n        private static LinkedHashMap<String, List<String>> createHeaderMap(HttpURLConnection conn) {\n            \n            final LinkedHashMap<String, List<String>> headers = new LinkedHashMap<>();\n            int i = 0;\n            while (true) {\n                final String key = conn.getHeaderFieldKey(i);\n                final String val = conn.getHeaderField(i);\n                if (key == null && val == null)\n                    break;\n                i++;\n                if (key == null || val == null)\n                    continue; \n\n                if (headers.containsKey(key))\n                    headers.get(key).add(val);\n                else {\n                    final ArrayList<String> vals = new ArrayList<>();\n                    vals.add(val);\n                    headers.put(key, vals);\n                }\n            }\n            return headers;\n        }\n\n        void processResponseHeaders(Map<String, List<String>> resHeaders) {\n            for (Map.Entry<String, List<String>> entry : resHeaders.entrySet()) {\n                String name = entry.getKey();\n                if (name == null)\n                    continue; \n\n                List<String> values = entry.getValue();\n                if (name.equalsIgnoreCase(\"Set-Cookie\")) {\n                    for (String value : values) {\n                        if (value == null)\n                            continue;\n                        TokenQueue cd = new TokenQueue(value);\n                        String cookieName = cd.chompTo(\"=\").trim();\n                        String cookieVal = cd.consumeTo(\";\").trim();\n                        \n                        \n                        if (cookieName.length() > 0)\n                            cookie(cookieName, cookieVal);\n                    }\n                }\n                for (String value : values) {\n                    addHeader(name, value);\n                }\n            }\n        }\n\n        private static String setOutputContentType(final Connection.Request req) {\n            String bound = null;\n            if (req.hasHeader(CONTENT_TYPE)) {\n                \n                \n\n                \n                if(req.header(CONTENT_TYPE).contains(MULTIPART_FORM_DATA) &&\n                        !req.header(CONTENT_TYPE).contains(\"boundary\")) {\n                    bound = DataUtil.mimeBoundary();\n                    req.header(CONTENT_TYPE, MULTIPART_FORM_DATA + \"; boundary=\" + bound);\n                }\n\n            }\n            else if (needsMultipart(req)) {\n                bound = DataUtil.mimeBoundary();\n                req.header(CONTENT_TYPE, MULTIPART_FORM_DATA + \"; boundary=\" + bound);\n            } else {\n                req.header(CONTENT_TYPE, FORM_URL_ENCODED + \"; charset=\" + req.postDataCharset());\n            }\n            return bound;\n        }\n\n        private static void writePost(final Connection.Request req, final OutputStream outputStream, final String bound) throws IOException {\n            final Collection<Connection.KeyVal> data = req.data();\n            final BufferedWriter w = new BufferedWriter(new OutputStreamWriter(outputStream, req.postDataCharset()));\n\n            if (bound != null) {\n                \n                for (Connection.KeyVal keyVal : data) {\n                    w.write(\"--\");\n                    w.write(bound);\n                    w.write(\"\\r\\n\");\n                    w.write(\"Content-Disposition: form-data; name=\\\"\");\n                    w.write(encodeMimeName(keyVal.key())); \n                    w.write(\"\\\"\");\n                    if (keyVal.hasInputStream()) {\n                        w.write(\"; filename=\\\"\");\n                        w.write(encodeMimeName(keyVal.value()));\n                        w.write(\"\\\"\\r\\nContent-Type: \");\n                        w.write(keyVal.contentType() != null ? keyVal.contentType() : DefaultUploadType);\n                        w.write(\"\\r\\n\\r\\n\");\n                        w.flush(); \n                        DataUtil.crossStreams(keyVal.inputStream(), outputStream);\n                        outputStream.flush();\n                    } else {\n                        w.write(\"\\r\\n\\r\\n\");\n                        w.write(keyVal.value());\n                    }\n                    w.write(\"\\r\\n\");\n                }\n                w.write(\"--\");\n                w.write(bound);\n                w.write(\"--\");\n            } else if (req.requestBody() != null) {\n                \n                w.write(req.requestBody());\n            }\n            else {\n                \n                boolean first = true;\n                for (Connection.KeyVal keyVal : data) {\n                    if (!first)\n                        w.append('&');\n                    else\n                        first = false;\n\n                    w.write(URLEncoder.encode(keyVal.key(), req.postDataCharset()));\n                    w.write('=');\n                    w.write(URLEncoder.encode(keyVal.value(), req.postDataCharset()));\n                }\n            }\n            w.close();\n        }\n\n        private static String getRequestCookieString(Connection.Request req) {\n            StringBuilder sb = StringUtil.borrowBuilder();\n            boolean first = true;\n            for (Map.Entry<String, String> cookie : req.cookies().entrySet()) {\n                if (!first)\n                    sb.append(\"; \");\n                else\n                    first = false;\n                sb.append(cookie.getKey()).append('=').append(cookie.getValue());\n                \n            }\n            return StringUtil.releaseBuilder(sb);\n        }\n\n        \n        private static void serialiseRequestUrl(Connection.Request req) throws IOException {\n            URL in = req.url();\n            StringBuilder url = StringUtil.borrowBuilder();\n            boolean first = true;\n            \n            url\n                .append(in.getProtocol())\n                .append(\":\n                .append(in.getAuthority()) \n                .append(in.getPath())\n                .append(\"?\");\n            if (in.getQuery() != null) {\n                url.append(in.getQuery());\n                first = false;\n            }\n            for (Connection.KeyVal keyVal : req.data()) {\n                Validate.isFalse(keyVal.hasInputStream(), \"InputStream data not supported in URL query string.\");\n                if (!first)\n                    url.append('&');\n                else\n                    first = false;\n                url\n                    .append(URLEncoder.encode(keyVal.key(), DataUtil.defaultCharset))\n                    .append('=')\n                    .append(URLEncoder.encode(keyVal.value(), DataUtil.defaultCharset));\n            }\n            req.url(new URL(StringUtil.releaseBuilder(url)));\n            req.data().clear(); \n        }\n    }\n\n    private static boolean needsMultipart(Connection.Request req) {\n        \n        for (Connection.KeyVal keyVal : req.data()) {\n            if (keyVal.hasInputStream())\n                return true;\n        }\n        return false;\n    }\n\n    public static class KeyVal implements Connection.KeyVal { private String key; private String value; private InputStream stream; private String contentType; public static KeyVal create(String key, String value) {\n            return new KeyVal().key(key).value(value);\n        }\n\n        public static KeyVal create(String key, String filename, InputStream stream) {\n            return new KeyVal().key(key).value(filename).inputStream(stream);\n        }\n\n        private KeyVal() {}\n\n        public KeyVal key(String key) {\n            Validate.notEmpty(key, \"Data key must not be empty\");\n            this.key = key;\n            return this;\n        }\n\n        public String key() {\n            return key;\n        }\n\n        public KeyVal value(String value) {\n            Validate.notNull(value, \"Data value must not be null\");\n            this.value = value;\n            return this;\n        }\n\n        public String value() {\n            return value;\n        }\n\n        public KeyVal inputStream(InputStream inputStream) {\n            Validate.notNull(value, \"Data input stream must not be null\");\n            this.stream = inputStream;\n            return this;\n        }\n\n        public InputStream inputStream() {\n            return stream;\n        }\n\n        public boolean hasInputStream() {\n            return stream != null;\n        }\n\n        @Override\n        public Connection.KeyVal contentType(String contentType) {\n            Validate.notEmpty(contentType);\n            this.contentType = contentType;\n            return this;\n        }\n\n        @Override\n        public String contentType() {\n            return contentType;\n        }\n\n        @Override\n        public String toString() {\n            return key + \"=\" + value;\n        }\n    }\n}\n",
      "buggy_signatures": [
        "public static Connection connect(URL url)",
        "public HttpConnection()",
        "private static String encodeUrl(String url)",
        "static URL encodeUrl(URL u)",
        "private static String encodeMimeName(String val)",
        "private Connection.Request req; private Connection.Response res; public Connection url(URL url)",
        "public Connection url(String url)",
        "public Connection proxy(Proxy proxy)",
        "public Connection proxy(String host, int port)",
        "public Connection userAgent(String userAgent)",
        "public Connection timeout(int millis)",
        "public Connection maxBodySize(int bytes)",
        "public Connection followRedirects(boolean followRedirects)",
        "public Connection referrer(String referrer)",
        "public Connection method(Method method)",
        "public Connection ignoreHttpErrors(boolean ignoreHttpErrors)",
        "public Connection ignoreContentType(boolean ignoreContentType)",
        "public Connection data(String key, String value)",
        "public Connection sslSocketFactory(SSLSocketFactory sslSocketFactory)",
        "public Connection data(String key, String filename, InputStream inputStream)",
        "public Connection data(String key, String filename, InputStream inputStream, String contentType)",
        "public Connection data(Map<String, String> data)",
        "public Connection data(String... keyvals)",
        "public Connection data(Collection<Connection.KeyVal> data)",
        "public Connection.KeyVal data(String key)",
        "public Connection requestBody(String body)",
        "public Connection header(String name, String value)",
        "public Connection headers(Map<String,String> headers)",
        "public Connection cookie(String name, String value)",
        "public Connection cookies(Map<String, String> cookies)",
        "public Connection parser(Parser parser)",
        "public Document get() throws IOException",
        "public Document post() throws IOException",
        "public Connection.Response execute() throws IOException",
        "public Connection.Request request()",
        "public Connection request(Connection.Request request)",
        "public Connection.Response response()",
        "public Connection response(Connection.Response response)",
        "public Connection postDataCharset(String charset)",
        "private static abstract class Base<T extends Connection.Base> implements Connection.Base<T> { URL url; Method method; Map<String, List<String>> headers; Map<String, String> cookies; private Base()",
        "public URL url()",
        "public T url(URL url)",
        "public Method method()",
        "public T method(Method method)",
        "public String header(String name)",
        "public T addHeader(String name, String value)",
        "public List<String> headers(String name)",
        "private static String fixHeaderEncoding(String val)",
        "private static boolean looksLikeUtf8(byte[] input)",
        "public T header(String name, String value)",
        "public boolean hasHeader(String name)",
        "public boolean hasHeaderWithValue(String name, String value)",
        "public T removeHeader(String name)",
        "public Map<String, String> headers()",
        "public Map<String, List<String>> multiHeaders()",
        "private List<String> getHeadersCaseInsensitive(String name)",
        "private Map.Entry<String, List<String>> scanHeaders(String name)",
        "public String cookie(String name)",
        "public T cookie(String name, String value)",
        "public boolean hasCookie(String name)",
        "public T removeCookie(String name)",
        "public Map<String, String> cookies()",
        "public Proxy proxy()",
        "public Request proxy(Proxy proxy)",
        "public Request proxy(String host, int port)",
        "public int timeout()",
        "public Request timeout(int millis)",
        "public int maxBodySize()",
        "public Connection.Request maxBodySize(int bytes)",
        "public boolean followRedirects()",
        "public Connection.Request followRedirects(boolean followRedirects)",
        "public boolean ignoreHttpErrors()",
        "public SSLSocketFactory sslSocketFactory()",
        "public void sslSocketFactory(SSLSocketFactory sslSocketFactory)",
        "public Connection.Request ignoreHttpErrors(boolean ignoreHttpErrors)",
        "public boolean ignoreContentType()",
        "public Connection.Request ignoreContentType(boolean ignoreContentType)",
        "public Request data(Connection.KeyVal keyval)",
        "public Collection<Connection.KeyVal> data()",
        "public Connection.Request requestBody(String body)",
        "public String requestBody()",
        "public Request parser(Parser parser)",
        "public Parser parser()",
        "public Connection.Request postDataCharset(String charset)",
        "public String postDataCharset()",
        "private Response(Response previousResponse) throws IOException",
        "static Response execute(Connection.Request req) throws IOException",
        "static Response execute(Connection.Request req, Response previousResponse) throws IOException",
        "private void safeClose()",
        "private void setupFromConnection(HttpURLConnection conn, HttpConnection.Response previousResponse) throws IOException",
        "private static LinkedHashMap<String, List<String>> createHeaderMap(HttpURLConnection conn)",
        "private static String setOutputContentType(final Connection.Request req)",
        "private static void writePost(final Connection.Request req, final OutputStream outputStream, final String bound) throws IOException",
        "private static String getRequestCookieString(Connection.Request req)",
        "private static void serialiseRequestUrl(Connection.Request req) throws IOException",
        "private static boolean needsMultipart(Connection.Request req)",
        "public static class KeyVal implements Connection.KeyVal { private String key; private String value; private InputStream stream; private String contentType; public static KeyVal create(String key, String value)",
        "public static KeyVal create(String key, String filename, InputStream stream)",
        "private KeyVal()",
        "public KeyVal key(String key)",
        "public String key()",
        "public KeyVal value(String value)",
        "public String value()",
        "public KeyVal inputStream(InputStream inputStream)",
        "public InputStream inputStream()",
        "public boolean hasInputStream()",
        "public Connection.KeyVal contentType(String contentType)",
        "public String contentType()",
        "public String toString()"
      ],
      "fixed_signatures": [
        "public static Connection connect(URL url)",
        "public HttpConnection()",
        "private static String encodeUrl(String url)",
        "static URL encodeUrl(URL u)",
        "private static String encodeMimeName(String val)",
        "private Connection.Request req; private Connection.Response res; public Connection url(URL url)",
        "public Connection url(String url)",
        "public Connection proxy(Proxy proxy)",
        "public Connection proxy(String host, int port)",
        "public Connection userAgent(String userAgent)",
        "public Connection timeout(int millis)",
        "public Connection maxBodySize(int bytes)",
        "public Connection followRedirects(boolean followRedirects)",
        "public Connection referrer(String referrer)",
        "public Connection method(Method method)",
        "public Connection ignoreHttpErrors(boolean ignoreHttpErrors)",
        "public Connection ignoreContentType(boolean ignoreContentType)",
        "public Connection data(String key, String value)",
        "public Connection sslSocketFactory(SSLSocketFactory sslSocketFactory)",
        "public Connection data(String key, String filename, InputStream inputStream)",
        "public Connection data(String key, String filename, InputStream inputStream, String contentType)",
        "public Connection data(Map<String, String> data)",
        "public Connection data(String... keyvals)",
        "public Connection data(Collection<Connection.KeyVal> data)",
        "public Connection.KeyVal data(String key)",
        "public Connection requestBody(String body)",
        "public Connection header(String name, String value)",
        "public Connection headers(Map<String,String> headers)",
        "public Connection cookie(String name, String value)",
        "public Connection cookies(Map<String, String> cookies)",
        "public Connection parser(Parser parser)",
        "public Document get() throws IOException",
        "public Document post() throws IOException",
        "public Connection.Response execute() throws IOException",
        "public Connection.Request request()",
        "public Connection request(Connection.Request request)",
        "public Connection.Response response()",
        "public Connection response(Connection.Response response)",
        "public Connection postDataCharset(String charset)",
        "private static abstract class Base<T extends Connection.Base> implements Connection.Base<T> { URL url; Method method; Map<String, List<String>> headers; Map<String, String> cookies; private Base()",
        "public URL url()",
        "public T url(URL url)",
        "public Method method()",
        "public T method(Method method)",
        "public String header(String name)",
        "public T addHeader(String name, String value)",
        "public List<String> headers(String name)",
        "private static String fixHeaderEncoding(String val)",
        "private static boolean looksLikeUtf8(byte[] input)",
        "public T header(String name, String value)",
        "public boolean hasHeader(String name)",
        "public boolean hasHeaderWithValue(String name, String value)",
        "public T removeHeader(String name)",
        "public Map<String, String> headers()",
        "public Map<String, List<String>> multiHeaders()",
        "private List<String> getHeadersCaseInsensitive(String name)",
        "private Map.Entry<String, List<String>> scanHeaders(String name)",
        "public String cookie(String name)",
        "public T cookie(String name, String value)",
        "public boolean hasCookie(String name)",
        "public T removeCookie(String name)",
        "public Map<String, String> cookies()",
        "public Proxy proxy()",
        "public Request proxy(Proxy proxy)",
        "public Request proxy(String host, int port)",
        "public int timeout()",
        "public Request timeout(int millis)",
        "public int maxBodySize()",
        "public Connection.Request maxBodySize(int bytes)",
        "public boolean followRedirects()",
        "public Connection.Request followRedirects(boolean followRedirects)",
        "public boolean ignoreHttpErrors()",
        "public SSLSocketFactory sslSocketFactory()",
        "public void sslSocketFactory(SSLSocketFactory sslSocketFactory)",
        "public Connection.Request ignoreHttpErrors(boolean ignoreHttpErrors)",
        "public boolean ignoreContentType()",
        "public Connection.Request ignoreContentType(boolean ignoreContentType)",
        "public Request data(Connection.KeyVal keyval)",
        "public Collection<Connection.KeyVal> data()",
        "public Connection.Request requestBody(String body)",
        "public String requestBody()",
        "public Request parser(Parser parser)",
        "public Parser parser()",
        "public Connection.Request postDataCharset(String charset)",
        "public String postDataCharset()",
        "private Response(Response previousResponse) throws IOException",
        "static Response execute(Connection.Request req) throws IOException",
        "static Response execute(Connection.Request req, Response previousResponse) throws IOException",
        "private void safeClose()",
        "private void setupFromConnection(HttpURLConnection conn, HttpConnection.Response previousResponse) throws IOException",
        "private static LinkedHashMap<String, List<String>> createHeaderMap(HttpURLConnection conn)",
        "private static String setOutputContentType(final Connection.Request req)",
        "private static void writePost(final Connection.Request req, final OutputStream outputStream, final String bound) throws IOException",
        "private static String getRequestCookieString(Connection.Request req)",
        "private static void serialiseRequestUrl(Connection.Request req) throws IOException",
        "private static boolean needsMultipart(Connection.Request req)",
        "public static class KeyVal implements Connection.KeyVal { private String key; private String value; private InputStream stream; private String contentType; public static KeyVal create(String key, String value)",
        "public static KeyVal create(String key, String filename, InputStream stream)",
        "private KeyVal()",
        "public KeyVal key(String key)",
        "public String key()",
        "public KeyVal value(String value)",
        "public String value()",
        "public KeyVal inputStream(InputStream inputStream)",
        "public InputStream inputStream()",
        "public boolean hasInputStream()",
        "public Connection.KeyVal contentType(String contentType)",
        "public String contentType()",
        "public String toString()"
      ],
      "methods": [
        {
          "buggy_method": "  private static boolean looksLikeUtf8(byte[] input) {\n  int i = 0;\n  \n  if (input.length >= 3 && (input[0] & 0xFF) == 0xEF\n  && (input[1] & 0xFF) == 0xBB & (input[2] & 0xFF) == 0xBF) {\n  i = 3;\n  }\n\n  int end;\n  for (int j = input.length; i < j; ++i) {\n  int o = input[i];\n  if ((o & 0x80) == 0) {\n  continue; \n  }\n\n  \n  if ((o & 0xE0) == 0xC0) {\n  end = i + 1;\n  } else if ((o & 0xF0) == 0xE0) {\n  end = i + 2;\n  } else if ((o & 0xF8) == 0xF0) {\n  end = i + 3;\n  } else {\n  return false;\n  }\n\n\n  while (i < end) {\n  i++;\n  o = input[i];\n  if ((o & 0xC0) != 0x80) {\n  return false;\n  }\n  }\n  }\n  return true;\n  }",
          "fixed_method": "  private static boolean looksLikeUtf8(byte[] input) {\n  int i = 0;\n  \n  if (input.length >= 3 && (input[0] & 0xFF) == 0xEF\n  && (input[1] & 0xFF) == 0xBB & (input[2] & 0xFF) == 0xBF) {\n  i = 3;\n  }\n\n  int end;\n  for (int j = input.length; i < j; ++i) {\n  int o = input[i];\n  if ((o & 0x80) == 0) {\n  continue; \n  }\n\n  \n  if ((o & 0xE0) == 0xC0) {\n  end = i + 1;\n  } else if ((o & 0xF0) == 0xE0) {\n  end = i + 2;\n  } else if ((o & 0xF8) == 0xF0) {\n  end = i + 3;\n  } else {\n  return false;\n  }\n\n  if (end >= input.length)\n  return false;\n\n  while (i < end) {\n  i++;\n  o = input[i];\n  if ((o & 0xC0) != 0x80) {\n  return false;\n  }\n  }\n  }\n  return true;\n  }",
          "diff": [
            "@@ -421,6 +421,8 @@",
            "                     return false;\n",
            "                 }\n",
            " \n",
            "+                if (end >= input.length)\n",
            "+                    return false;\n",
            " \n",
            "                 while (i < end) {\n",
            "                     i++;\n"
          ],
          "changed_lines": 2
        }
      ]
    }
  ]
}
