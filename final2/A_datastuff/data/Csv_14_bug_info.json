{
  "bug_id": "14",
  "failed_tests": {
    "org.apache.commons.csv.CSVPrinterTest": [
      {
        "methodName": "testEscapeNull1",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<[\\]> but was:<[\"\\\"]>",
        "fail_line": "        assertEquals(\"\\\\\", sw.toString());",
        "test_source": "  public void testEscapeNull1() throws IOException {\n  StringWriter sw = new StringWriter();\n  try (final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withEscape(null))) {\n  printer.print(\"\\\\\");\n  }\n  assertEquals(\"\\\\\", sw.toString());\n  }",
        "stack": [
          "CSVPrinterTest.testEscapeNull1 line 346"
        ]
      },
      {
        "methodName": "testEscapeNull4",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<[\\\\]> but was:<[\"\\\\\"]>",
        "fail_line": "        assertEquals(\"\\\\\\\\\", sw.toString());",
        "test_source": "  public void testEscapeNull4() throws IOException {\n  StringWriter sw = new StringWriter();\n  try (final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withEscape(null))) {\n  printer.print(\"\\\\\\\\\");\n  }\n  assertEquals(\"\\\\\\\\\", sw.toString());\n  }",
        "stack": [
          "CSVPrinterTest.testEscapeNull4 line 373"
        ]
      },
      {
        "methodName": "testEscapeNull5",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<[\\\\]> but was:<[\"\\\\\"]>",
        "fail_line": "        assertEquals(\"\\\\\\\\\", sw.toString());",
        "test_source": "  public void testEscapeNull5() throws IOException {\n  StringWriter sw = new StringWriter();\n  try (final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withEscape(null))) {\n  printer.print(\"\\\\\\\\\");\n  }\n  assertEquals(\"\\\\\\\\\", sw.toString());\n  }",
        "stack": [
          "CSVPrinterTest.testEscapeNull5 line 382"
        ]
      },
      {
        "methodName": "testEscapeBackslash1",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<[\\]> but was:<['\\']>",
        "fail_line": "        assertEquals(\"\\\\\", sw.toString());",
        "test_source": "  public void testEscapeBackslash1() throws IOException {\n  StringWriter sw = new StringWriter();\n  try (final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(QUOTE_CH))) {\n  printer.print(\"\\\\\");\n  }\n  assertEquals(\"\\\\\", sw.toString());\n  }",
        "stack": [
          "CSVPrinterTest.testEscapeBackslash1 line 301"
        ]
      },
      {
        "methodName": "testEscapeBackslash4",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<[\\\\]> but was:<['\\\\']>",
        "fail_line": "        assertEquals(\"\\\\\\\\\", sw.toString());",
        "test_source": "  public void testEscapeBackslash4() throws IOException {\n  StringWriter sw = new StringWriter();\n  try (final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(QUOTE_CH))) {\n  printer.print(\"\\\\\\\\\");\n  }\n  assertEquals(\"\\\\\\\\\", sw.toString());\n  }",
        "stack": [
          "CSVPrinterTest.testEscapeBackslash4 line 328"
        ]
      },
      {
        "methodName": "testEscapeBackslash5",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<[\\\\]> but was:<['\\\\']>",
        "fail_line": "        assertEquals(\"\\\\\\\\\", sw.toString());",
        "test_source": "  public void testEscapeBackslash5() throws IOException {\n  StringWriter sw = new StringWriter();\n  try (final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(QUOTE_CH))) {\n  printer.print(\"\\\\\\\\\");\n  }\n  assertEquals(\"\\\\\\\\\", sw.toString());\n  }",
        "stack": [
          "CSVPrinterTest.testEscapeBackslash5 line 337"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/csv/CSVFormat.java",
      "buggy_full_code": "\n\npackage org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Constants.BACKSLASH; import static org.apache.commons.csv.Constants.COMMA; import static org.apache.commons.csv.Constants.COMMENT; import static org.apache.commons.csv.Constants.CR; import static org.apache.commons.csv.Constants.CRLF; import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR; import static org.apache.commons.csv.Constants.LF; import static org.apache.commons.csv.Constants.PIPE; import static org.apache.commons.csv.Constants.SP; import static org.apache.commons.csv.Constants.TAB; import java.io.File; import java.io.FileOutputStream; import java.io.IOException; import java.io.OutputStreamWriter; import java.io.Reader; import java.io.Serializable; import java.io.StringWriter; import java.nio.charset.Charset; import java.nio.file.Path; import java.sql.ResultSet; import java.sql.ResultSetMetaData; import java.sql.SQLException; import java.util.Arrays; import java.util.HashSet; import java.util.Set; public final class CSVFormat implements Serializable { public enum Predefined { Default(CSVFormat.DEFAULT), Excel(CSVFormat.EXCEL), InformixUnload(CSVFormat.INFORMIX_UNLOAD), InformixUnloadCsv(CSVFormat.INFORMIX_UNLOAD_CSV), MySQL(CSVFormat.MYSQL), RFC4180(CSVFormat.RFC4180), TDF(CSVFormat.TDF); private final CSVFormat format; Predefined(final CSVFormat format) {\n            this.format = format;\n        }\n\n        \n        public CSVFormat getFormat() {\n            return format;\n        }\n    }\n\n    \n    public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT.withDelimiter(PIPE).withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR).withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT.withDelimiter(COMMA).withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(\"\\\\N\"); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); private static final long serialVersionUID = 1L; public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); private static boolean isLineBreak(final char c) {\n        return c == LF || c == CR;\n    }\n\n    \n    private static boolean isLineBreak(final Character c) {\n        return c != null && isLineBreak(c.charValue());\n    }\n\n    \n    public static CSVFormat newFormat(final char delimiter) {\n        return new CSVFormat(delimiter, null, null, null, null, false, false, null, null, null, null, false, false,\n                false, false, false);\n    }\n\n    \n    public static CSVFormat valueOf(final String format) {\n        return CSVFormat.Predefined.valueOf(format).getFormat();\n    }\n\n    private final boolean allowMissingColumnNames; private final Character commentMarker; private final char delimiter; private final Character escapeCharacter; private final String[] header; private final String[] headerComments; private final boolean ignoreEmptyLines; private final boolean ignoreHeaderCase; private final boolean ignoreSurroundingSpaces; private final String nullString; private final Character quoteCharacter; private final QuoteMode quoteMode; private final String recordSeparator; private final boolean skipHeaderRecord; private final boolean trailingDelimiter; private final boolean trim; private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter) {\n        this.delimiter = delimiter;\n        this.quoteCharacter = quoteChar;\n        this.quoteMode = quoteMode;\n        this.commentMarker = commentStart;\n        this.escapeCharacter = escape;\n        this.ignoreSurroundingSpaces = ignoreSurroundingSpaces;\n        this.allowMissingColumnNames = allowMissingColumnNames;\n        this.ignoreEmptyLines = ignoreEmptyLines;\n        this.recordSeparator = recordSeparator;\n        this.nullString = nullString;\n        this.headerComments = toStringArray(headerComments);\n        this.header = header == null ? null : header.clone();\n        this.skipHeaderRecord = skipHeaderRecord;\n        this.ignoreHeaderCase = ignoreHeaderCase;\n        this.trailingDelimiter = trailingDelimiter;\n        this.trim = trim;\n        validate();\n    }\n\n    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (getClass() != obj.getClass()) {\n            return false;\n        }\n\n        final CSVFormat other = (CSVFormat) obj;\n        if (delimiter != other.delimiter) {\n            return false;\n        }\n        if (quoteMode != other.quoteMode) {\n            return false;\n        }\n        if (quoteCharacter == null) {\n            if (other.quoteCharacter != null) {\n                return false;\n            }\n        } else if (!quoteCharacter.equals(other.quoteCharacter)) {\n            return false;\n        }\n        if (commentMarker == null) {\n            if (other.commentMarker != null) {\n                return false;\n            }\n        } else if (!commentMarker.equals(other.commentMarker)) {\n            return false;\n        }\n        if (escapeCharacter == null) {\n            if (other.escapeCharacter != null) {\n                return false;\n            }\n        } else if (!escapeCharacter.equals(other.escapeCharacter)) {\n            return false;\n        }\n        if (nullString == null) {\n            if (other.nullString != null) {\n                return false;\n            }\n        } else if (!nullString.equals(other.nullString)) {\n            return false;\n        }\n        if (!Arrays.equals(header, other.header)) {\n            return false;\n        }\n        if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {\n            return false;\n        }\n        if (ignoreEmptyLines != other.ignoreEmptyLines) {\n            return false;\n        }\n        if (skipHeaderRecord != other.skipHeaderRecord) {\n            return false;\n        }\n        if (recordSeparator == null) {\n            if (other.recordSeparator != null) {\n                return false;\n            }\n        } else if (!recordSeparator.equals(other.recordSeparator)) {\n            return false;\n        }\n        return true;\n    }\n\n    \n    public String format(final Object... values) {\n        final StringWriter out = new StringWriter();\n        try (final CSVPrinter csvPrinter = new CSVPrinter(out, this)) {\n            csvPrinter.printRecord(values);\n            return out.toString().trim();\n        } catch (final IOException e) {\n            \n            throw new IllegalStateException(e);\n        }\n    }\n\n    \n    public boolean getAllowMissingColumnNames() {\n        return allowMissingColumnNames;\n    }\n\n    \n    public Character getCommentMarker() {\n        return commentMarker;\n    }\n\n    \n    public char getDelimiter() {\n        return delimiter;\n    }\n\n    \n    public Character getEscapeCharacter() {\n        return escapeCharacter;\n    }\n\n    \n    public String[] getHeader() {\n        return header != null ? header.clone() : null;\n    }\n\n    \n    public String[] getHeaderComments() {\n        return headerComments != null ? headerComments.clone() : null;\n    }\n\n    \n    public boolean getIgnoreEmptyLines() {\n        return ignoreEmptyLines;\n    }\n\n    \n    public boolean getIgnoreHeaderCase() {\n        return ignoreHeaderCase;\n    }\n\n    \n    public boolean getIgnoreSurroundingSpaces() {\n        return ignoreSurroundingSpaces;\n    }\n\n    \n    public String getNullString() {\n        return nullString;\n    }\n\n    \n    public Character getQuoteCharacter() {\n        return quoteCharacter;\n    }\n\n    \n    public QuoteMode getQuoteMode() {\n        return quoteMode;\n    }\n\n    \n    public String getRecordSeparator() {\n        return recordSeparator;\n    }\n\n    \n    public boolean getSkipHeaderRecord() {\n        return skipHeaderRecord;\n    }\n\n    \n    public boolean getTrailingDelimiter() {\n        return trailingDelimiter;\n    }\n\n    \n    public boolean getTrim() {\n        return trim;\n    }\n\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n\n        result = prime * result + delimiter;\n        result = prime * result + ((quoteMode == null) ? 0 : quoteMode.hashCode());\n        result = prime * result + ((quoteCharacter == null) ? 0 : quoteCharacter.hashCode());\n        result = prime * result + ((commentMarker == null) ? 0 : commentMarker.hashCode());\n        result = prime * result + ((escapeCharacter == null) ? 0 : escapeCharacter.hashCode());\n        result = prime * result + ((nullString == null) ? 0 : nullString.hashCode());\n        result = prime * result + (ignoreSurroundingSpaces ? 1231 : 1237);\n        result = prime * result + (ignoreHeaderCase ? 1231 : 1237);\n        result = prime * result + (ignoreEmptyLines ? 1231 : 1237);\n        result = prime * result + (skipHeaderRecord ? 1231 : 1237);\n        result = prime * result + ((recordSeparator == null) ? 0 : recordSeparator.hashCode());\n        result = prime * result + Arrays.hashCode(header);\n        return result;\n    }\n\n    \n    public boolean isCommentMarkerSet() {\n        return commentMarker != null;\n    }\n\n    \n    public boolean isEscapeCharacterSet() {\n        return escapeCharacter != null;\n    }\n\n    \n    public boolean isNullStringSet() {\n        return nullString != null;\n    }\n\n    \n    public boolean isQuoteCharacterSet() {\n        return quoteCharacter != null;\n    }\n\n    \n    public CSVParser parse(final Reader in) throws IOException {\n        return new CSVParser(in, this);\n    }\n\n    \n    public CSVPrinter print(final Appendable out) throws IOException {\n        return new CSVPrinter(out, this);\n    }\n\n    \n    @SuppressWarnings(\"resource\")\n    public CSVPrinter print(final File out, Charset charset) throws IOException {\n        \n        return new CSVPrinter(new OutputStreamWriter(new FileOutputStream(out), charset), this);\n    }\n\n    \n    public CSVPrinter print(final Path out, Charset charset) throws IOException {\n        return print(out.toFile(), charset);\n    }\n\n    \n    public void print(final Object value, final Appendable out, final boolean newRecord) throws IOException {\n        \n        \n        CharSequence charSequence;\n        if (value == null) {\n            charSequence = nullString == null ? Constants.EMPTY : nullString;\n        } else {\n            charSequence = value instanceof CharSequence ? (CharSequence) value : value.toString();\n        }\n        charSequence = getTrim() ? trim(charSequence) : charSequence;\n        this.print(value, charSequence, 0, charSequence.length(), out, newRecord);\n    }\n\n    private void print(final Object object, final CharSequence value, final int offset, final int len, final Appendable out, final boolean newRecord) throws IOException {\n        if (!newRecord) {\n            out.append(getDelimiter());\n        }\n        if (object == null) {\n            out.append(value);\n        } else if (isQuoteCharacterSet()) {\n            \n            printAndQuote(object, value, offset, len, out, newRecord);\n        } else if (isEscapeCharacterSet()) {\n            printAndEscape(value, offset, len, out);\n        } else {\n            out.append(value, offset, offset + len);\n        }\n    }\n\n    \n    private void printAndEscape(final CharSequence value, final int offset, final int len, final Appendable out) throws IOException {\n        int start = offset;\n        int pos = offset;\n        final int end = offset + len;\n\n        final char delim = getDelimiter();\n        final char escape = getEscapeCharacter().charValue();\n\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == CR || c == LF || c == delim || c == escape) {\n                \n                if (pos > start) {\n                    out.append(value, start, pos);\n                }\n                if (c == LF) {\n                    c = 'n';\n                } else if (c == CR) {\n                    c = 'r';\n                }\n\n                out.append(escape);\n                out.append(c);\n\n                start = pos + 1; \n            }\n\n            pos++;\n        }\n\n        \n        if (pos > start) {\n            out.append(value, start, pos);\n        }\n    }\n\n    \n    \n    private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len, final Appendable out, final boolean newRecord) throws IOException {\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        final int end = offset + len;\n\n        final char delimChar = getDelimiter();\n        final char quoteChar = getQuoteCharacter().charValue();\n\n        QuoteMode quoteModePolicy = getQuoteMode();\n        if (quoteModePolicy == null) {\n            quoteModePolicy = QuoteMode.MINIMAL;\n        }\n        switch (quoteModePolicy) {\n        case ALL:\n            quote = true;\n            break;\n        case NON_NUMERIC:\n            quote = !(object instanceof Number);\n            break;\n        case NONE:\n            \n            printAndEscape(value, offset, len, out);\n            return;\n        case MINIMAL:\n            if (len <= 0) {\n                \n                \n                \n                \n                if (newRecord) {\n                    quote = true;\n                }\n            } else {\n                char c = value.charAt(pos);\n\n                \n                if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {\n                    quote = true;\n                } else if (c <= COMMENT) {\n                    \n                    \n                    \n                    quote = true;\n                } else {\n                    while (pos < end) {\n                        c = value.charAt(pos);\n                        if (c == LF || c == CR || c == quoteChar || c == delimChar) {\n                            quote = true;\n                            break;\n                        }\n                        pos++;\n                    }\n\n                    if (!quote) {\n                        pos = end - 1;\n                        c = value.charAt(pos);\n                        \n                        \n                        if (c <= SP) {\n                            quote = true;\n                        }\n                    }\n                }\n            }\n\n            if (!quote) {\n                \n                out.append(value, start, end);\n                return;\n            }\n            break;\n        default:\n            throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy);\n        }\n\n        if (!quote) {\n            \n            out.append(value, start, end);\n            return;\n        }\n\n        \n        out.append(quoteChar);\n\n        \n        \n        while (pos < end) {\n            final char c = value.charAt(pos);\n            if (c == quoteChar) {\n                \n\n                \n                out.append(value, start, pos + 1);\n                \n                \n                start = pos;\n            }\n            pos++;\n        }\n\n        \n        out.append(value, start, pos);\n        out.append(quoteChar);\n    }\n\n    \n    public void println(final Appendable out) throws IOException {\n        if (getTrailingDelimiter()) {\n            out.append(getDelimiter());\n        }\n        if (recordSeparator != null) {\n            out.append(recordSeparator);\n        }\n    }\n\n    \n    public void printRecord(final Appendable out, final Object... values) throws IOException {\n        for (int i = 0; i < values.length; i++) {\n            print(values[i], out, i == 0);\n        }\n        println(out);\n    }\n\n    @Override\n    public String toString() {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"Delimiter=<\").append(delimiter).append('>');\n        if (isEscapeCharacterSet()) {\n            sb.append(' ');\n            sb.append(\"Escape=<\").append(escapeCharacter).append('>');\n        }\n        if (isQuoteCharacterSet()) {\n            sb.append(' ');\n            sb.append(\"QuoteChar=<\").append(quoteCharacter).append('>');\n        }\n        if (isCommentMarkerSet()) {\n            sb.append(' ');\n            sb.append(\"CommentStart=<\").append(commentMarker).append('>');\n        }\n        if (isNullStringSet()) {\n            sb.append(' ');\n            sb.append(\"NullString=<\").append(nullString).append('>');\n        }\n        if (recordSeparator != null) {\n            sb.append(' ');\n            sb.append(\"RecordSeparator=<\").append(recordSeparator).append('>');\n        }\n        if (getIgnoreEmptyLines()) {\n            sb.append(\" EmptyLines:ignored\");\n        }\n        if (getIgnoreSurroundingSpaces()) {\n            sb.append(\" SurroundingSpaces:ignored\");\n        }\n        if (getIgnoreHeaderCase()) {\n            sb.append(\" IgnoreHeaderCase:ignored\");\n        }\n        sb.append(\" SkipHeaderRecord:\").append(skipHeaderRecord);\n        if (headerComments != null) {\n            sb.append(' ');\n            sb.append(\"HeaderComments:\").append(Arrays.toString(headerComments));\n        }\n        if (header != null) {\n            sb.append(' ');\n            sb.append(\"Header:\").append(Arrays.toString(header));\n        }\n        return sb.toString();\n    }\n\n    private String[] toStringArray(final Object[] values) {\n        if (values == null) {\n            return null;\n        }\n        final String[] strings = new String[values.length];\n        for (int i = 0; i < values.length; i++) {\n            final Object value = values[i];\n            strings[i] = value == null ? null : value.toString();\n        }\n        return strings;\n    }\n\n    private CharSequence trim(final CharSequence charSequence) {\n        if (charSequence instanceof String) {\n            return ((String) charSequence).trim();\n        }\n        final int count = charSequence.length();\n        int len = count;\n        int pos = 0;\n\n        while (pos < len && charSequence.charAt(pos) <= SP) {\n            pos++;\n        }\n        while (pos < len && charSequence.charAt(len - 1) <= SP) {\n            len--;\n        }\n        return pos > 0 || len < count ? charSequence.subSequence(pos, len) : charSequence;\n    }\n\n    \n    private void validate() throws IllegalArgumentException {\n        if (isLineBreak(delimiter)) {\n            throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n        }\n\n        if (quoteCharacter != null && delimiter == quoteCharacter.charValue()) {\n            throw new IllegalArgumentException(\n                    \"The quoteChar character and the delimiter cannot be the same ('\" + quoteCharacter + \"')\");\n        }\n\n        if (escapeCharacter != null && delimiter == escapeCharacter.charValue()) {\n            throw new IllegalArgumentException(\n                    \"The escape character and the delimiter cannot be the same ('\" + escapeCharacter + \"')\");\n        }\n\n        if (commentMarker != null && delimiter == commentMarker.charValue()) {\n            throw new IllegalArgumentException(\n                    \"The comment start character and the delimiter cannot be the same ('\" + commentMarker + \"')\");\n        }\n\n        if (quoteCharacter != null && quoteCharacter.equals(commentMarker)) {\n            throw new IllegalArgumentException(\n                    \"The comment start character and the quoteChar cannot be the same ('\" + commentMarker + \"')\");\n        }\n\n        if (escapeCharacter != null && escapeCharacter.equals(commentMarker)) {\n            throw new IllegalArgumentException(\n                    \"The comment start and the escape character cannot be the same ('\" + commentMarker + \"')\");\n        }\n\n        if (escapeCharacter == null && quoteMode == QuoteMode.NONE) {\n            throw new IllegalArgumentException(\"No quotes mode set but no escape character is set\");\n        }\n\n        \n        if (header != null) {\n            final Set<String> dupCheck = new HashSet<>();\n            for (final String hdr : header) {\n                if (!dupCheck.add(hdr)) {\n                    throw new IllegalArgumentException(\n                            \"The header contains a duplicate entry: '\" + hdr + \"' in \" + Arrays.toString(header));\n                }\n            }\n        }\n    }\n\n    \n    public CSVFormat withAllowMissingColumnNames() {\n        return this.withAllowMissingColumnNames(true);\n    }\n\n    \n    public CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n    }\n\n    \n    public CSVFormat withCommentMarker(final char commentMarker) {\n        return withCommentMarker(Character.valueOf(commentMarker));\n    }\n\n    \n    public CSVFormat withCommentMarker(final Character commentMarker) {\n        if (isLineBreak(commentMarker)) {\n            throw new IllegalArgumentException(\"The comment start marker character cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n    }\n\n    \n    public CSVFormat withDelimiter(final char delimiter) {\n        if (isLineBreak(delimiter)) {\n            throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n    }\n\n    \n    public CSVFormat withEscape(final char escape) {\n        return withEscape(Character.valueOf(escape));\n    }\n\n    \n    public CSVFormat withEscape(final Character escape) {\n        if (isLineBreak(escape)) {\n            throw new IllegalArgumentException(\"The escape character cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escape, ignoreSurroundingSpaces,\n                ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord,\n                allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n    }\n\n    \n    public CSVFormat withFirstRecordAsHeader() {\n        return withHeader().withSkipHeaderRecord();\n    }\n\n    \n    public CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum) {\n        String[] header = null;\n        if (headerEnum != null) {\n            final Enum<?>[] enumValues = headerEnum.getEnumConstants();\n            header = new String[enumValues.length];\n            for (int i = 0; i < enumValues.length; i++) {\n                header[i] = enumValues[i].name();\n            }\n        }\n        return withHeader(header);\n    }\n\n    \n    public CSVFormat withHeader(final ResultSet resultSet) throws SQLException {\n        return withHeader(resultSet != null ? resultSet.getMetaData() : null);\n    }\n\n    \n    public CSVFormat withHeader(final ResultSetMetaData metaData) throws SQLException {\n        String[] labels = null;\n        if (metaData != null) {\n            final int columnCount = metaData.getColumnCount();\n            labels = new String[columnCount];\n            for (int i = 0; i < columnCount; i++) {\n                labels[i] = metaData.getColumnLabel(i + 1);\n            }\n        }\n        return withHeader(labels);\n    }\n\n    \n    public CSVFormat withHeader(final String... header) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n    }\n\n    \n    public CSVFormat withHeaderComments(final Object... headerComments) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n    }\n\n    \n    public CSVFormat withIgnoreEmptyLines() {\n        return this.withIgnoreEmptyLines(true);\n    }\n\n    \n    public CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n    }\n\n    \n    public CSVFormat withIgnoreHeaderCase() {\n        return this.withIgnoreHeaderCase(true);\n    }\n\n    \n    public CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n    }\n\n    \n    public CSVFormat withIgnoreSurroundingSpaces() {\n        return this.withIgnoreSurroundingSpaces(true);\n    }\n\n    \n    public CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n    }\n\n    \n    public CSVFormat withNullString(final String nullString) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n    }\n\n    \n    public CSVFormat withQuote(final char quoteChar) {\n        return withQuote(Character.valueOf(quoteChar));\n    }\n\n    \n    public CSVFormat withQuote(final Character quoteChar) {\n        if (isLineBreak(quoteChar)) {\n            throw new IllegalArgumentException(\"The quoteChar cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteChar, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces,\n                ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord,\n                allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n    }\n\n    \n    public CSVFormat withQuoteMode(final QuoteMode quoteModePolicy) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteModePolicy, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n    }\n\n    \n    public CSVFormat withRecordSeparator(final char recordSeparator) {\n        return withRecordSeparator(String.valueOf(recordSeparator));\n    }\n\n    \n    public CSVFormat withRecordSeparator(final String recordSeparator) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n    }\n\n    \n    public CSVFormat withSkipHeaderRecord() {\n        return this.withSkipHeaderRecord(true);\n    }\n\n    \n    public CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n    }\n\n    \n    public CSVFormat withTrailingDelimiter() {\n        return withTrailingDelimiter(true);\n    }\n\n    \n    public CSVFormat withTrailingDelimiter(final boolean trailingDelimiter) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n    }\n\n    \n    public CSVFormat withTrim() {\n        return withTrim(true);\n    }\n\n    \n    public CSVFormat withTrim(final boolean trim) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n    }\n}\n",
      "fixed_full_code": "\n\npackage org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Constants.BACKSLASH; import static org.apache.commons.csv.Constants.COMMA; import static org.apache.commons.csv.Constants.COMMENT; import static org.apache.commons.csv.Constants.CR; import static org.apache.commons.csv.Constants.CRLF; import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR; import static org.apache.commons.csv.Constants.LF; import static org.apache.commons.csv.Constants.PIPE; import static org.apache.commons.csv.Constants.SP; import static org.apache.commons.csv.Constants.TAB; import java.io.File; import java.io.FileOutputStream; import java.io.IOException; import java.io.OutputStreamWriter; import java.io.Reader; import java.io.Serializable; import java.io.StringWriter; import java.nio.charset.Charset; import java.nio.file.Path; import java.sql.ResultSet; import java.sql.ResultSetMetaData; import java.sql.SQLException; import java.util.Arrays; import java.util.HashSet; import java.util.Set; public final class CSVFormat implements Serializable { public enum Predefined { Default(CSVFormat.DEFAULT), Excel(CSVFormat.EXCEL), InformixUnload(CSVFormat.INFORMIX_UNLOAD), InformixUnloadCsv(CSVFormat.INFORMIX_UNLOAD_CSV), MySQL(CSVFormat.MYSQL), RFC4180(CSVFormat.RFC4180), TDF(CSVFormat.TDF); private final CSVFormat format; Predefined(final CSVFormat format) {\n            this.format = format;\n        }\n\n        \n        public CSVFormat getFormat() {\n            return format;\n        }\n    }\n\n    \n    public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT.withDelimiter(PIPE).withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR).withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT.withDelimiter(COMMA).withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(\"\\\\N\"); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); private static final long serialVersionUID = 1L; public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); private static boolean isLineBreak(final char c) {\n        return c == LF || c == CR;\n    }\n\n    \n    private static boolean isLineBreak(final Character c) {\n        return c != null && isLineBreak(c.charValue());\n    }\n\n    \n    public static CSVFormat newFormat(final char delimiter) {\n        return new CSVFormat(delimiter, null, null, null, null, false, false, null, null, null, null, false, false,\n                false, false, false);\n    }\n\n    \n    public static CSVFormat valueOf(final String format) {\n        return CSVFormat.Predefined.valueOf(format).getFormat();\n    }\n\n    private final boolean allowMissingColumnNames; private final Character commentMarker; private final char delimiter; private final Character escapeCharacter; private final String[] header; private final String[] headerComments; private final boolean ignoreEmptyLines; private final boolean ignoreHeaderCase; private final boolean ignoreSurroundingSpaces; private final String nullString; private final Character quoteCharacter; private final QuoteMode quoteMode; private final String recordSeparator; private final boolean skipHeaderRecord; private final boolean trailingDelimiter; private final boolean trim; private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter) {\n        this.delimiter = delimiter;\n        this.quoteCharacter = quoteChar;\n        this.quoteMode = quoteMode;\n        this.commentMarker = commentStart;\n        this.escapeCharacter = escape;\n        this.ignoreSurroundingSpaces = ignoreSurroundingSpaces;\n        this.allowMissingColumnNames = allowMissingColumnNames;\n        this.ignoreEmptyLines = ignoreEmptyLines;\n        this.recordSeparator = recordSeparator;\n        this.nullString = nullString;\n        this.headerComments = toStringArray(headerComments);\n        this.header = header == null ? null : header.clone();\n        this.skipHeaderRecord = skipHeaderRecord;\n        this.ignoreHeaderCase = ignoreHeaderCase;\n        this.trailingDelimiter = trailingDelimiter;\n        this.trim = trim;\n        validate();\n    }\n\n    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (getClass() != obj.getClass()) {\n            return false;\n        }\n\n        final CSVFormat other = (CSVFormat) obj;\n        if (delimiter != other.delimiter) {\n            return false;\n        }\n        if (quoteMode != other.quoteMode) {\n            return false;\n        }\n        if (quoteCharacter == null) {\n            if (other.quoteCharacter != null) {\n                return false;\n            }\n        } else if (!quoteCharacter.equals(other.quoteCharacter)) {\n            return false;\n        }\n        if (commentMarker == null) {\n            if (other.commentMarker != null) {\n                return false;\n            }\n        } else if (!commentMarker.equals(other.commentMarker)) {\n            return false;\n        }\n        if (escapeCharacter == null) {\n            if (other.escapeCharacter != null) {\n                return false;\n            }\n        } else if (!escapeCharacter.equals(other.escapeCharacter)) {\n            return false;\n        }\n        if (nullString == null) {\n            if (other.nullString != null) {\n                return false;\n            }\n        } else if (!nullString.equals(other.nullString)) {\n            return false;\n        }\n        if (!Arrays.equals(header, other.header)) {\n            return false;\n        }\n        if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {\n            return false;\n        }\n        if (ignoreEmptyLines != other.ignoreEmptyLines) {\n            return false;\n        }\n        if (skipHeaderRecord != other.skipHeaderRecord) {\n            return false;\n        }\n        if (recordSeparator == null) {\n            if (other.recordSeparator != null) {\n                return false;\n            }\n        } else if (!recordSeparator.equals(other.recordSeparator)) {\n            return false;\n        }\n        return true;\n    }\n\n    \n    public String format(final Object... values) {\n        final StringWriter out = new StringWriter();\n        try (final CSVPrinter csvPrinter = new CSVPrinter(out, this)) {\n            csvPrinter.printRecord(values);\n            return out.toString().trim();\n        } catch (final IOException e) {\n            \n            throw new IllegalStateException(e);\n        }\n    }\n\n    \n    public boolean getAllowMissingColumnNames() {\n        return allowMissingColumnNames;\n    }\n\n    \n    public Character getCommentMarker() {\n        return commentMarker;\n    }\n\n    \n    public char getDelimiter() {\n        return delimiter;\n    }\n\n    \n    public Character getEscapeCharacter() {\n        return escapeCharacter;\n    }\n\n    \n    public String[] getHeader() {\n        return header != null ? header.clone() : null;\n    }\n\n    \n    public String[] getHeaderComments() {\n        return headerComments != null ? headerComments.clone() : null;\n    }\n\n    \n    public boolean getIgnoreEmptyLines() {\n        return ignoreEmptyLines;\n    }\n\n    \n    public boolean getIgnoreHeaderCase() {\n        return ignoreHeaderCase;\n    }\n\n    \n    public boolean getIgnoreSurroundingSpaces() {\n        return ignoreSurroundingSpaces;\n    }\n\n    \n    public String getNullString() {\n        return nullString;\n    }\n\n    \n    public Character getQuoteCharacter() {\n        return quoteCharacter;\n    }\n\n    \n    public QuoteMode getQuoteMode() {\n        return quoteMode;\n    }\n\n    \n    public String getRecordSeparator() {\n        return recordSeparator;\n    }\n\n    \n    public boolean getSkipHeaderRecord() {\n        return skipHeaderRecord;\n    }\n\n    \n    public boolean getTrailingDelimiter() {\n        return trailingDelimiter;\n    }\n\n    \n    public boolean getTrim() {\n        return trim;\n    }\n\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n\n        result = prime * result + delimiter;\n        result = prime * result + ((quoteMode == null) ? 0 : quoteMode.hashCode());\n        result = prime * result + ((quoteCharacter == null) ? 0 : quoteCharacter.hashCode());\n        result = prime * result + ((commentMarker == null) ? 0 : commentMarker.hashCode());\n        result = prime * result + ((escapeCharacter == null) ? 0 : escapeCharacter.hashCode());\n        result = prime * result + ((nullString == null) ? 0 : nullString.hashCode());\n        result = prime * result + (ignoreSurroundingSpaces ? 1231 : 1237);\n        result = prime * result + (ignoreHeaderCase ? 1231 : 1237);\n        result = prime * result + (ignoreEmptyLines ? 1231 : 1237);\n        result = prime * result + (skipHeaderRecord ? 1231 : 1237);\n        result = prime * result + ((recordSeparator == null) ? 0 : recordSeparator.hashCode());\n        result = prime * result + Arrays.hashCode(header);\n        return result;\n    }\n\n    \n    public boolean isCommentMarkerSet() {\n        return commentMarker != null;\n    }\n\n    \n    public boolean isEscapeCharacterSet() {\n        return escapeCharacter != null;\n    }\n\n    \n    public boolean isNullStringSet() {\n        return nullString != null;\n    }\n\n    \n    public boolean isQuoteCharacterSet() {\n        return quoteCharacter != null;\n    }\n\n    \n    public CSVParser parse(final Reader in) throws IOException {\n        return new CSVParser(in, this);\n    }\n\n    \n    public CSVPrinter print(final Appendable out) throws IOException {\n        return new CSVPrinter(out, this);\n    }\n\n    \n    @SuppressWarnings(\"resource\")\n    public CSVPrinter print(final File out, Charset charset) throws IOException {\n        \n        return new CSVPrinter(new OutputStreamWriter(new FileOutputStream(out), charset), this);\n    }\n\n    \n    public CSVPrinter print(final Path out, Charset charset) throws IOException {\n        return print(out.toFile(), charset);\n    }\n\n    \n    public void print(final Object value, final Appendable out, final boolean newRecord) throws IOException {\n        \n        \n        CharSequence charSequence;\n        if (value == null) {\n            charSequence = nullString == null ? Constants.EMPTY : nullString;\n        } else {\n            charSequence = value instanceof CharSequence ? (CharSequence) value : value.toString();\n        }\n        charSequence = getTrim() ? trim(charSequence) : charSequence;\n        this.print(value, charSequence, 0, charSequence.length(), out, newRecord);\n    }\n\n    private void print(final Object object, final CharSequence value, final int offset, final int len, final Appendable out, final boolean newRecord) throws IOException {\n        if (!newRecord) {\n            out.append(getDelimiter());\n        }\n        if (object == null) {\n            out.append(value);\n        } else if (isQuoteCharacterSet()) {\n            \n            printAndQuote(object, value, offset, len, out, newRecord);\n        } else if (isEscapeCharacterSet()) {\n            printAndEscape(value, offset, len, out);\n        } else {\n            out.append(value, offset, offset + len);\n        }\n    }\n\n    \n    private void printAndEscape(final CharSequence value, final int offset, final int len, final Appendable out) throws IOException {\n        int start = offset;\n        int pos = offset;\n        final int end = offset + len;\n\n        final char delim = getDelimiter();\n        final char escape = getEscapeCharacter().charValue();\n\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == CR || c == LF || c == delim || c == escape) {\n                \n                if (pos > start) {\n                    out.append(value, start, pos);\n                }\n                if (c == LF) {\n                    c = 'n';\n                } else if (c == CR) {\n                    c = 'r';\n                }\n\n                out.append(escape);\n                out.append(c);\n\n                start = pos + 1; \n            }\n\n            pos++;\n        }\n\n        \n        if (pos > start) {\n            out.append(value, start, pos);\n        }\n    }\n\n    \n    \n    private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len, final Appendable out, final boolean newRecord) throws IOException {\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        final int end = offset + len;\n\n        final char delimChar = getDelimiter();\n        final char quoteChar = getQuoteCharacter().charValue();\n\n        QuoteMode quoteModePolicy = getQuoteMode();\n        if (quoteModePolicy == null) {\n            quoteModePolicy = QuoteMode.MINIMAL;\n        }\n        switch (quoteModePolicy) {\n        case ALL:\n            quote = true;\n            break;\n        case NON_NUMERIC:\n            quote = !(object instanceof Number);\n            break;\n        case NONE:\n            \n            printAndEscape(value, offset, len, out);\n            return;\n        case MINIMAL:\n            if (len <= 0) {\n                \n                \n                \n                \n                if (newRecord) {\n                    quote = true;\n                }\n            } else {\n                char c = value.charAt(pos);\n\n                \n                if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {\n                    quote = true;\n                } else if (c <= COMMENT) {\n                    \n                    \n                    \n                    quote = true;\n                } else {\n                    while (pos < end) {\n                        c = value.charAt(pos);\n                        if (c == LF || c == CR || c == quoteChar || c == delimChar) {\n                            quote = true;\n                            break;\n                        }\n                        pos++;\n                    }\n\n                    if (!quote) {\n                        pos = end - 1;\n                        c = value.charAt(pos);\n                        \n                        \n                        if (c <= SP) {\n                            quote = true;\n                        }\n                    }\n                }\n            }\n\n            if (!quote) {\n                \n                out.append(value, start, end);\n                return;\n            }\n            break;\n        default:\n            throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy);\n        }\n\n        if (!quote) {\n            \n            out.append(value, start, end);\n            return;\n        }\n\n        \n        out.append(quoteChar);\n\n        \n        \n        while (pos < end) {\n            final char c = value.charAt(pos);\n            if (c == quoteChar) {\n                \n\n                \n                out.append(value, start, pos + 1);\n                \n                \n                start = pos;\n            }\n            pos++;\n        }\n\n        \n        out.append(value, start, pos);\n        out.append(quoteChar);\n    }\n\n    \n    public void println(final Appendable out) throws IOException {\n        if (getTrailingDelimiter()) {\n            out.append(getDelimiter());\n        }\n        if (recordSeparator != null) {\n            out.append(recordSeparator);\n        }\n    }\n\n    \n    public void printRecord(final Appendable out, final Object... values) throws IOException {\n        for (int i = 0; i < values.length; i++) {\n            print(values[i], out, i == 0);\n        }\n        println(out);\n    }\n\n    @Override\n    public String toString() {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"Delimiter=<\").append(delimiter).append('>');\n        if (isEscapeCharacterSet()) {\n            sb.append(' ');\n            sb.append(\"Escape=<\").append(escapeCharacter).append('>');\n        }\n        if (isQuoteCharacterSet()) {\n            sb.append(' ');\n            sb.append(\"QuoteChar=<\").append(quoteCharacter).append('>');\n        }\n        if (isCommentMarkerSet()) {\n            sb.append(' ');\n            sb.append(\"CommentStart=<\").append(commentMarker).append('>');\n        }\n        if (isNullStringSet()) {\n            sb.append(' ');\n            sb.append(\"NullString=<\").append(nullString).append('>');\n        }\n        if (recordSeparator != null) {\n            sb.append(' ');\n            sb.append(\"RecordSeparator=<\").append(recordSeparator).append('>');\n        }\n        if (getIgnoreEmptyLines()) {\n            sb.append(\" EmptyLines:ignored\");\n        }\n        if (getIgnoreSurroundingSpaces()) {\n            sb.append(\" SurroundingSpaces:ignored\");\n        }\n        if (getIgnoreHeaderCase()) {\n            sb.append(\" IgnoreHeaderCase:ignored\");\n        }\n        sb.append(\" SkipHeaderRecord:\").append(skipHeaderRecord);\n        if (headerComments != null) {\n            sb.append(' ');\n            sb.append(\"HeaderComments:\").append(Arrays.toString(headerComments));\n        }\n        if (header != null) {\n            sb.append(' ');\n            sb.append(\"Header:\").append(Arrays.toString(header));\n        }\n        return sb.toString();\n    }\n\n    private String[] toStringArray(final Object[] values) {\n        if (values == null) {\n            return null;\n        }\n        final String[] strings = new String[values.length];\n        for (int i = 0; i < values.length; i++) {\n            final Object value = values[i];\n            strings[i] = value == null ? null : value.toString();\n        }\n        return strings;\n    }\n\n    private CharSequence trim(final CharSequence charSequence) {\n        if (charSequence instanceof String) {\n            return ((String) charSequence).trim();\n        }\n        final int count = charSequence.length();\n        int len = count;\n        int pos = 0;\n\n        while (pos < len && charSequence.charAt(pos) <= SP) {\n            pos++;\n        }\n        while (pos < len && charSequence.charAt(len - 1) <= SP) {\n            len--;\n        }\n        return pos > 0 || len < count ? charSequence.subSequence(pos, len) : charSequence;\n    }\n\n    \n    private void validate() throws IllegalArgumentException {\n        if (isLineBreak(delimiter)) {\n            throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n        }\n\n        if (quoteCharacter != null && delimiter == quoteCharacter.charValue()) {\n            throw new IllegalArgumentException(\n                    \"The quoteChar character and the delimiter cannot be the same ('\" + quoteCharacter + \"')\");\n        }\n\n        if (escapeCharacter != null && delimiter == escapeCharacter.charValue()) {\n            throw new IllegalArgumentException(\n                    \"The escape character and the delimiter cannot be the same ('\" + escapeCharacter + \"')\");\n        }\n\n        if (commentMarker != null && delimiter == commentMarker.charValue()) {\n            throw new IllegalArgumentException(\n                    \"The comment start character and the delimiter cannot be the same ('\" + commentMarker + \"')\");\n        }\n\n        if (quoteCharacter != null && quoteCharacter.equals(commentMarker)) {\n            throw new IllegalArgumentException(\n                    \"The comment start character and the quoteChar cannot be the same ('\" + commentMarker + \"')\");\n        }\n\n        if (escapeCharacter != null && escapeCharacter.equals(commentMarker)) {\n            throw new IllegalArgumentException(\n                    \"The comment start and the escape character cannot be the same ('\" + commentMarker + \"')\");\n        }\n\n        if (escapeCharacter == null && quoteMode == QuoteMode.NONE) {\n            throw new IllegalArgumentException(\"No quotes mode set but no escape character is set\");\n        }\n\n        \n        if (header != null) {\n            final Set<String> dupCheck = new HashSet<>();\n            for (final String hdr : header) {\n                if (!dupCheck.add(hdr)) {\n                    throw new IllegalArgumentException(\n                            \"The header contains a duplicate entry: '\" + hdr + \"' in \" + Arrays.toString(header));\n                }\n            }\n        }\n    }\n\n    \n    public CSVFormat withAllowMissingColumnNames() {\n        return this.withAllowMissingColumnNames(true);\n    }\n\n    \n    public CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n    }\n\n    \n    public CSVFormat withCommentMarker(final char commentMarker) {\n        return withCommentMarker(Character.valueOf(commentMarker));\n    }\n\n    \n    public CSVFormat withCommentMarker(final Character commentMarker) {\n        if (isLineBreak(commentMarker)) {\n            throw new IllegalArgumentException(\"The comment start marker character cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n    }\n\n    \n    public CSVFormat withDelimiter(final char delimiter) {\n        if (isLineBreak(delimiter)) {\n            throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n    }\n\n    \n    public CSVFormat withEscape(final char escape) {\n        return withEscape(Character.valueOf(escape));\n    }\n\n    \n    public CSVFormat withEscape(final Character escape) {\n        if (isLineBreak(escape)) {\n            throw new IllegalArgumentException(\"The escape character cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escape, ignoreSurroundingSpaces,\n                ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord,\n                allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n    }\n\n    \n    public CSVFormat withFirstRecordAsHeader() {\n        return withHeader().withSkipHeaderRecord();\n    }\n\n    \n    public CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum) {\n        String[] header = null;\n        if (headerEnum != null) {\n            final Enum<?>[] enumValues = headerEnum.getEnumConstants();\n            header = new String[enumValues.length];\n            for (int i = 0; i < enumValues.length; i++) {\n                header[i] = enumValues[i].name();\n            }\n        }\n        return withHeader(header);\n    }\n\n    \n    public CSVFormat withHeader(final ResultSet resultSet) throws SQLException {\n        return withHeader(resultSet != null ? resultSet.getMetaData() : null);\n    }\n\n    \n    public CSVFormat withHeader(final ResultSetMetaData metaData) throws SQLException {\n        String[] labels = null;\n        if (metaData != null) {\n            final int columnCount = metaData.getColumnCount();\n            labels = new String[columnCount];\n            for (int i = 0; i < columnCount; i++) {\n                labels[i] = metaData.getColumnLabel(i + 1);\n            }\n        }\n        return withHeader(labels);\n    }\n\n    \n    public CSVFormat withHeader(final String... header) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n    }\n\n    \n    public CSVFormat withHeaderComments(final Object... headerComments) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n    }\n\n    \n    public CSVFormat withIgnoreEmptyLines() {\n        return this.withIgnoreEmptyLines(true);\n    }\n\n    \n    public CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n    }\n\n    \n    public CSVFormat withIgnoreHeaderCase() {\n        return this.withIgnoreHeaderCase(true);\n    }\n\n    \n    public CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n    }\n\n    \n    public CSVFormat withIgnoreSurroundingSpaces() {\n        return this.withIgnoreSurroundingSpaces(true);\n    }\n\n    \n    public CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n    }\n\n    \n    public CSVFormat withNullString(final String nullString) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n    }\n\n    \n    public CSVFormat withQuote(final char quoteChar) {\n        return withQuote(Character.valueOf(quoteChar));\n    }\n\n    \n    public CSVFormat withQuote(final Character quoteChar) {\n        if (isLineBreak(quoteChar)) {\n            throw new IllegalArgumentException(\"The quoteChar cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteChar, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces,\n                ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord,\n                allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n    }\n\n    \n    public CSVFormat withQuoteMode(final QuoteMode quoteModePolicy) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteModePolicy, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n    }\n\n    \n    public CSVFormat withRecordSeparator(final char recordSeparator) {\n        return withRecordSeparator(String.valueOf(recordSeparator));\n    }\n\n    \n    public CSVFormat withRecordSeparator(final String recordSeparator) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n    }\n\n    \n    public CSVFormat withSkipHeaderRecord() {\n        return this.withSkipHeaderRecord(true);\n    }\n\n    \n    public CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n    }\n\n    \n    public CSVFormat withTrailingDelimiter() {\n        return withTrailingDelimiter(true);\n    }\n\n    \n    public CSVFormat withTrailingDelimiter(final boolean trailingDelimiter) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n    }\n\n    \n    public CSVFormat withTrim() {\n        return withTrim(true);\n    }\n\n    \n    public CSVFormat withTrim(final boolean trim) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n    }\n}\n",
      "buggy_signatures": [
        "static org.apache.commons.csv.Constants.BACKSLASH; import static org.apache.commons.csv.Constants.COMMA; import static org.apache.commons.csv.Constants.COMMENT; import static org.apache.commons.csv.Constants.CR; import static org.apache.commons.csv.Constants.CRLF; import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR; import static org.apache.commons.csv.Constants.LF; import static org.apache.commons.csv.Constants.PIPE; import static org.apache.commons.csv.Constants.SP; import static org.apache.commons.csv.Constants.TAB; import java.io.File; import java.io.FileOutputStream; import java.io.IOException; import java.io.OutputStreamWriter; import java.io.Reader; import java.io.Serializable; import java.io.StringWriter; import java.nio.charset.Charset; import java.nio.file.Path; import java.sql.ResultSet; import java.sql.ResultSetMetaData; import java.sql.SQLException; import java.util.Arrays; import java.util.HashSet; import java.util.Set; public final class CSVFormat implements Serializable { public enum Predefined { Default(CSVFormat.DEFAULT), Excel(CSVFormat.EXCEL), InformixUnload(CSVFormat.INFORMIX_UNLOAD), InformixUnloadCsv(CSVFormat.INFORMIX_UNLOAD_CSV), MySQL(CSVFormat.MYSQL), RFC4180(CSVFormat.RFC4180), TDF(CSVFormat.TDF); private final CSVFormat format; Predefined(final CSVFormat format)",
        "public CSVFormat getFormat()",
        "private static boolean isLineBreak(final Character c)",
        "public static CSVFormat newFormat(final char delimiter)",
        "public static CSVFormat valueOf(final String format)",
        "private final boolean allowMissingColumnNames; private final Character commentMarker; private final char delimiter; private final Character escapeCharacter; private final String[] header; private final String[] headerComments; private final boolean ignoreEmptyLines; private final boolean ignoreHeaderCase; private final boolean ignoreSurroundingSpaces; private final String nullString; private final Character quoteCharacter; private final QuoteMode quoteMode; private final String recordSeparator; private final boolean skipHeaderRecord; private final boolean trailingDelimiter; private final boolean trim; private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter)",
        "public boolean equals(final Object obj)",
        "public String format(final Object... values)",
        "public boolean getAllowMissingColumnNames()",
        "public Character getCommentMarker()",
        "public char getDelimiter()",
        "public Character getEscapeCharacter()",
        "public String[] getHeader()",
        "public String[] getHeaderComments()",
        "public boolean getIgnoreEmptyLines()",
        "public boolean getIgnoreHeaderCase()",
        "public boolean getIgnoreSurroundingSpaces()",
        "public String getNullString()",
        "public Character getQuoteCharacter()",
        "public QuoteMode getQuoteMode()",
        "public String getRecordSeparator()",
        "public boolean getSkipHeaderRecord()",
        "public boolean getTrailingDelimiter()",
        "public boolean getTrim()",
        "public int hashCode()",
        "public boolean isCommentMarkerSet()",
        "public boolean isEscapeCharacterSet()",
        "public boolean isNullStringSet()",
        "public boolean isQuoteCharacterSet()",
        "public CSVParser parse(final Reader in) throws IOException",
        "public CSVPrinter print(final Appendable out) throws IOException",
        "public CSVPrinter print(final File out, Charset charset) throws IOException",
        "public CSVPrinter print(final Path out, Charset charset) throws IOException",
        "public void print(final Object value, final Appendable out, final boolean newRecord) throws IOException",
        "private void print(final Object object, final CharSequence value, final int offset, final int len, final Appendable out, final boolean newRecord) throws IOException",
        "private void printAndEscape(final CharSequence value, final int offset, final int len, final Appendable out) throws IOException",
        "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len, final Appendable out, final boolean newRecord) throws IOException",
        "public void println(final Appendable out) throws IOException",
        "public void printRecord(final Appendable out, final Object... values) throws IOException",
        "public String toString()",
        "private String[] toStringArray(final Object[] values)",
        "private CharSequence trim(final CharSequence charSequence)",
        "private void validate() throws IllegalArgumentException",
        "public CSVFormat withAllowMissingColumnNames()",
        "public CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames)",
        "public CSVFormat withCommentMarker(final char commentMarker)",
        "public CSVFormat withCommentMarker(final Character commentMarker)",
        "public CSVFormat withDelimiter(final char delimiter)",
        "public CSVFormat withEscape(final char escape)",
        "public CSVFormat withEscape(final Character escape)",
        "public CSVFormat withFirstRecordAsHeader()",
        "public CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum)",
        "public CSVFormat withHeader(final ResultSet resultSet) throws SQLException",
        "public CSVFormat withHeader(final ResultSetMetaData metaData) throws SQLException",
        "public CSVFormat withHeader(final String... header)",
        "public CSVFormat withHeaderComments(final Object... headerComments)",
        "public CSVFormat withIgnoreEmptyLines()",
        "public CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines)",
        "public CSVFormat withIgnoreHeaderCase()",
        "public CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase)",
        "public CSVFormat withIgnoreSurroundingSpaces()",
        "public CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces)",
        "public CSVFormat withNullString(final String nullString)",
        "public CSVFormat withQuote(final char quoteChar)",
        "public CSVFormat withQuote(final Character quoteChar)",
        "public CSVFormat withQuoteMode(final QuoteMode quoteModePolicy)",
        "public CSVFormat withRecordSeparator(final char recordSeparator)",
        "public CSVFormat withRecordSeparator(final String recordSeparator)",
        "public CSVFormat withSkipHeaderRecord()",
        "public CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord)",
        "public CSVFormat withTrailingDelimiter()",
        "public CSVFormat withTrailingDelimiter(final boolean trailingDelimiter)",
        "public CSVFormat withTrim()",
        "public CSVFormat withTrim(final boolean trim)"
      ],
      "fixed_signatures": [
        "static org.apache.commons.csv.Constants.BACKSLASH; import static org.apache.commons.csv.Constants.COMMA; import static org.apache.commons.csv.Constants.COMMENT; import static org.apache.commons.csv.Constants.CR; import static org.apache.commons.csv.Constants.CRLF; import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR; import static org.apache.commons.csv.Constants.LF; import static org.apache.commons.csv.Constants.PIPE; import static org.apache.commons.csv.Constants.SP; import static org.apache.commons.csv.Constants.TAB; import java.io.File; import java.io.FileOutputStream; import java.io.IOException; import java.io.OutputStreamWriter; import java.io.Reader; import java.io.Serializable; import java.io.StringWriter; import java.nio.charset.Charset; import java.nio.file.Path; import java.sql.ResultSet; import java.sql.ResultSetMetaData; import java.sql.SQLException; import java.util.Arrays; import java.util.HashSet; import java.util.Set; public final class CSVFormat implements Serializable { public enum Predefined { Default(CSVFormat.DEFAULT), Excel(CSVFormat.EXCEL), InformixUnload(CSVFormat.INFORMIX_UNLOAD), InformixUnloadCsv(CSVFormat.INFORMIX_UNLOAD_CSV), MySQL(CSVFormat.MYSQL), RFC4180(CSVFormat.RFC4180), TDF(CSVFormat.TDF); private final CSVFormat format; Predefined(final CSVFormat format)",
        "public CSVFormat getFormat()",
        "private static boolean isLineBreak(final Character c)",
        "public static CSVFormat newFormat(final char delimiter)",
        "public static CSVFormat valueOf(final String format)",
        "private final boolean allowMissingColumnNames; private final Character commentMarker; private final char delimiter; private final Character escapeCharacter; private final String[] header; private final String[] headerComments; private final boolean ignoreEmptyLines; private final boolean ignoreHeaderCase; private final boolean ignoreSurroundingSpaces; private final String nullString; private final Character quoteCharacter; private final QuoteMode quoteMode; private final String recordSeparator; private final boolean skipHeaderRecord; private final boolean trailingDelimiter; private final boolean trim; private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter)",
        "public boolean equals(final Object obj)",
        "public String format(final Object... values)",
        "public boolean getAllowMissingColumnNames()",
        "public Character getCommentMarker()",
        "public char getDelimiter()",
        "public Character getEscapeCharacter()",
        "public String[] getHeader()",
        "public String[] getHeaderComments()",
        "public boolean getIgnoreEmptyLines()",
        "public boolean getIgnoreHeaderCase()",
        "public boolean getIgnoreSurroundingSpaces()",
        "public String getNullString()",
        "public Character getQuoteCharacter()",
        "public QuoteMode getQuoteMode()",
        "public String getRecordSeparator()",
        "public boolean getSkipHeaderRecord()",
        "public boolean getTrailingDelimiter()",
        "public boolean getTrim()",
        "public int hashCode()",
        "public boolean isCommentMarkerSet()",
        "public boolean isEscapeCharacterSet()",
        "public boolean isNullStringSet()",
        "public boolean isQuoteCharacterSet()",
        "public CSVParser parse(final Reader in) throws IOException",
        "public CSVPrinter print(final Appendable out) throws IOException",
        "public CSVPrinter print(final File out, Charset charset) throws IOException",
        "public CSVPrinter print(final Path out, Charset charset) throws IOException",
        "public void print(final Object value, final Appendable out, final boolean newRecord) throws IOException",
        "private void print(final Object object, final CharSequence value, final int offset, final int len, final Appendable out, final boolean newRecord) throws IOException",
        "private void printAndEscape(final CharSequence value, final int offset, final int len, final Appendable out) throws IOException",
        "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len, final Appendable out, final boolean newRecord) throws IOException",
        "public void println(final Appendable out) throws IOException",
        "public void printRecord(final Appendable out, final Object... values) throws IOException",
        "public String toString()",
        "private String[] toStringArray(final Object[] values)",
        "private CharSequence trim(final CharSequence charSequence)",
        "private void validate() throws IllegalArgumentException",
        "public CSVFormat withAllowMissingColumnNames()",
        "public CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames)",
        "public CSVFormat withCommentMarker(final char commentMarker)",
        "public CSVFormat withCommentMarker(final Character commentMarker)",
        "public CSVFormat withDelimiter(final char delimiter)",
        "public CSVFormat withEscape(final char escape)",
        "public CSVFormat withEscape(final Character escape)",
        "public CSVFormat withFirstRecordAsHeader()",
        "public CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum)",
        "public CSVFormat withHeader(final ResultSet resultSet) throws SQLException",
        "public CSVFormat withHeader(final ResultSetMetaData metaData) throws SQLException",
        "public CSVFormat withHeader(final String... header)",
        "public CSVFormat withHeaderComments(final Object... headerComments)",
        "public CSVFormat withIgnoreEmptyLines()",
        "public CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines)",
        "public CSVFormat withIgnoreHeaderCase()",
        "public CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase)",
        "public CSVFormat withIgnoreSurroundingSpaces()",
        "public CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces)",
        "public CSVFormat withNullString(final String nullString)",
        "public CSVFormat withQuote(final char quoteChar)",
        "public CSVFormat withQuote(final Character quoteChar)",
        "public CSVFormat withQuoteMode(final QuoteMode quoteModePolicy)",
        "public CSVFormat withRecordSeparator(final char recordSeparator)",
        "public CSVFormat withRecordSeparator(final String recordSeparator)",
        "public CSVFormat withSkipHeaderRecord()",
        "public CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord)",
        "public CSVFormat withTrailingDelimiter()",
        "public CSVFormat withTrailingDelimiter(final boolean trailingDelimiter)",
        "public CSVFormat withTrim()",
        "public CSVFormat withTrim(final boolean trim)"
      ],
      "methods": [
        {
          "buggy_method": "  private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len, final Appendable out, final boolean newRecord) throws IOException {\n  boolean quote = false;\n  int start = offset;\n  int pos = offset;\n  final int end = offset + len;\n\n  final char delimChar = getDelimiter();\n  final char quoteChar = getQuoteCharacter().charValue();\n\n  QuoteMode quoteModePolicy = getQuoteMode();\n  if (quoteModePolicy == null) {\n  quoteModePolicy = QuoteMode.MINIMAL;\n  }\n  switch (quoteModePolicy) {\n  case ALL:\n  quote = true;\n  break;\n  case NON_NUMERIC:\n  quote = !(object instanceof Number);\n  break;\n  case NONE:\n  \n  printAndEscape(value, offset, len, out);\n  return;\n  case MINIMAL:\n  if (len <= 0) {\n  \n  \n  \n  \n  if (newRecord) {\n  quote = true;\n  }\n  } else {\n  char c = value.charAt(pos);\n\n  \n  if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {\n  quote = true;\n  } else if (c <= COMMENT) {\n  \n  \n  \n  quote = true;\n  } else {\n  while (pos < end) {\n  c = value.charAt(pos);\n  if (c == LF || c == CR || c == quoteChar || c == delimChar) {\n  quote = true;\n  break;\n  }\n  pos++;\n  }\n\n  if (!quote) {\n  pos = end - 1;\n  c = value.charAt(pos);\n  \n  \n  if (c <= SP) {\n  quote = true;\n  }\n  }\n  }\n  }\n\n  if (!quote) {\n  \n  out.append(value, start, end);\n  return;\n  }\n  break;\n  default:\n  throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy);\n  }\n\n  if (!quote) {\n  \n  out.append(value, start, end);\n  return;\n  }\n\n  \n  out.append(quoteChar);\n\n  \n  \n  while (pos < end) {\n  final char c = value.charAt(pos);\n  if (c == quoteChar) {\n  \n\n  \n  out.append(value, start, pos + 1);\n  \n  \n  start = pos;\n  }\n  pos++;\n  }\n\n  \n  out.append(value, start, pos);\n  out.append(quoteChar);\n  }",
          "fixed_method": "  private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len, final Appendable out, final boolean newRecord) throws IOException {\n  boolean quote = false;\n  int start = offset;\n  int pos = offset;\n  final int end = offset + len;\n\n  final char delimChar = getDelimiter();\n  final char quoteChar = getQuoteCharacter().charValue();\n\n  QuoteMode quoteModePolicy = getQuoteMode();\n  if (quoteModePolicy == null) {\n  quoteModePolicy = QuoteMode.MINIMAL;\n  }\n  switch (quoteModePolicy) {\n  case ALL:\n  quote = true;\n  break;\n  case NON_NUMERIC:\n  quote = !(object instanceof Number);\n  break;\n  case NONE:\n  \n  printAndEscape(value, offset, len, out);\n  return;\n  case MINIMAL:\n  if (len <= 0) {\n  \n  \n  \n  \n  if (newRecord) {\n  quote = true;\n  }\n  } else {\n  char c = value.charAt(pos);\n\n  \n  if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {\n  quote = true;\n  } else if (c <= COMMENT) {\n  \n  \n  \n  quote = true;\n  } else {\n  while (pos < end) {\n  c = value.charAt(pos);\n  if (c == LF || c == CR || c == quoteChar || c == delimChar) {\n  quote = true;\n  break;\n  }\n  pos++;\n  }\n\n  if (!quote) {\n  pos = end - 1;\n  c = value.charAt(pos);\n  \n  \n  if (c <= SP) {\n  quote = true;\n  }\n  }\n  }\n  }\n\n  if (!quote) {\n  \n  out.append(value, start, end);\n  return;\n  }\n  break;\n  default:\n  throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy);\n  }\n\n  if (!quote) {\n  \n  out.append(value, start, end);\n  return;\n  }\n\n  \n  out.append(quoteChar);\n\n  \n  \n  while (pos < end) {\n  final char c = value.charAt(pos);\n  if (c == quoteChar) {\n  \n\n  \n  out.append(value, start, pos + 1);\n  \n  \n  start = pos;\n  }\n  pos++;\n  }\n\n  \n  out.append(value, start, pos);\n  out.append(quoteChar);\n  }",
          "diff": [
            "@@ -1036,7 +1036,7 @@",
            "                 char c = value.charAt(pos);\n",
            " \n",
            "                 // RFC4180 (https://tools.ietf.org/html/rfc4180) TEXTDATA =  %x20-21 / %x23-2B / %x2D-7E\n",
            "-                if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {\n",
            "+                if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {\n",
            "                     quote = true;\n",
            "                 } else if (c <= COMMENT) {\n",
            "                     // Some other chars at the start of a value caused the parser to fail, so for now\n"
          ],
          "changed_lines": 2
        }
      ]
    }
  ]
}
