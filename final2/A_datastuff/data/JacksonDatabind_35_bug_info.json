{
  "bug_id": "35",
  "failed_tests": {
    "com.fasterxml.jackson.databind.jsontype.WrapperObjectWithObjectIdTest": [
      {
        "methodName": "testSimple",
        "error": "com.fasterxml.jackson.databind.JsonMappingException",
        "message": "Unexpected token (FIELD_NAME), expected START_OBJECT: need JSON Object to contain As.WRAPPER_OBJECT type information for class com.fasterxml.jackson.databind.jsontype.WrapperObjectWithObjectIdTest$Computer",
        "fail_line": "        Company result = mapper.readValue(json, Company.class);",
        "test_source": "  public void testSimple() throws Exception {\n  Company comp = new Company();\n  comp.addComputer(new DesktopComputer(\"computer-1\", \"Bangkok\"));\n  comp.addComputer(new DesktopComputer(\"computer-2\", \"Pattaya\"));\n  comp.addComputer(new LaptopComputer(\"computer-3\", \"Apple\"));\n\n  final ObjectMapper mapper = new ObjectMapper();\n\n  String json = mapper.writerWithDefaultPrettyPrinter()\n  .writeValueAsString(comp);\n\n  System.out.println(\"JSON: \"+json);\n\n  Company result = mapper.readValue(json, Company.class);\n  assertNotNull(result);\n  assertNotNull(result.computers);\n  assertEquals(3, result.computers.size());\n  }",
        "stack": [
          "JsonMappingException.from line 148, DeserializationContext.wrongTokenException line 927, AsWrapperTypeDeserializer._deserialize line 90, AsWrapperTypeDeserializer.deserializeTypedFromObject line 49, BeanDeserializerBase.deserializeWithType line 966, CollectionDeserializer.deserialize line 247, CollectionDeserializer.deserialize line 217, CollectionDeserializer.deserialize line 25, SettableBeanProperty.deserialize line 523, FieldProperty.deserializeAndSet line 101, BeanPropertyMap.findDeserializeAndSet line 285, BeanDeserializer.vanillaDeserialize line 248, BeanDeserializer.deserialize line 136, ObjectMapper._readMapAndClose line 3564, ObjectMapper.readValue line 2580, WrapperObjectWithObjectIdTest.testSimple line 83"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeDeserializer.java",
      "buggy_full_code": "package com.fasterxml.jackson.databind.jsontype.impl;\n\nimport java.io.IOException;\n\nimport com.fasterxml.jackson.annotation.JsonTypeInfo.As;\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.util.JsonParserSequence;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\nimport com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\nimport com.fasterxml.jackson.databind.util.TokenBuffer;\n\n\npublic class AsWrapperTypeDeserializer extends TypeDeserializerBase implements java.io.Serializable { private static final long serialVersionUID = 5345570420394408290L; public AsWrapperTypeDeserializer(JavaType bt, TypeIdResolver idRes, String typePropertyName, boolean typeIdVisible, Class<?> defaultImpl) {\n        super(bt, idRes, typePropertyName, typeIdVisible, defaultImpl);\n    }\n\n    protected AsWrapperTypeDeserializer(AsWrapperTypeDeserializer src, BeanProperty property) {\n        super(src, property);\n    }\n    \n    @Override\n    public TypeDeserializer forProperty(BeanProperty prop) {\n        return (prop == _property) ? this : new AsWrapperTypeDeserializer(this, prop);\n    }\n    \n    @Override\n    public As getTypeInclusion() { return As.WRAPPER_OBJECT; }\n\n    \n    @Override\n    public Object deserializeTypedFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException {\n        return _deserialize(jp, ctxt);\n    }    \n\n    @Override\n    public Object deserializeTypedFromArray(JsonParser jp, DeserializationContext ctxt) throws IOException {\n        return _deserialize(jp, ctxt);\n    }\n\n    @Override\n    public Object deserializeTypedFromScalar(JsonParser jp, DeserializationContext ctxt) throws IOException {\n        return _deserialize(jp, ctxt);\n    }\n\n    @Override\n    public Object deserializeTypedFromAny(JsonParser jp, DeserializationContext ctxt) throws IOException {\n        return _deserialize(jp, ctxt);\n    }\n    \n    \n\n    \n    @SuppressWarnings(\"resource\")\n    private final Object _deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n        \n        if (p.canReadTypeId()) {\n            Object typeId = p.getTypeId();\n            if (typeId != null) {\n                return _deserializeWithNativeTypeId(p, ctxt, typeId);\n            }\n        }\n        \n        if (p.getCurrentToken() != JsonToken.START_OBJECT) {\n            throw ctxt.wrongTokenException(p, JsonToken.START_OBJECT,\n                    \"need JSON Object to contain As.WRAPPER_OBJECT type information for class \"+baseTypeName());\n        }\n            \n            if (p.nextToken() != JsonToken.FIELD_NAME) {\n                throw ctxt.wrongTokenException(p, JsonToken.FIELD_NAME,\n                        \"need JSON String that contains type id (for subtype of \"+baseTypeName()+\")\");\n            }\n        final String typeId = p.getText();\n        JsonDeserializer<Object> deser = _findDeserializer(ctxt, typeId);\n        p.nextToken();\n\n        \n        if (_typeIdVisible && p.getCurrentToken() == JsonToken.START_OBJECT) {\n            \n            TokenBuffer tb = new TokenBuffer(null, false);\n            tb.writeStartObject(); \n            tb.writeFieldName(_typePropertyName);\n            tb.writeString(typeId);\n            p = JsonParserSequence.createFlattened(tb.asParser(p), p);\n            p.nextToken();\n        }\n        \n        Object value = deser.deserialize(p, ctxt);\n        \n        if (p.nextToken() != JsonToken.END_OBJECT) {\n            throw ctxt.wrongTokenException(p, JsonToken.END_OBJECT,\n                    \"expected closing END_OBJECT after type information and deserialized value\");\n        }\n        return value;\n    }\n}\n",
      "fixed_full_code": "package com.fasterxml.jackson.databind.jsontype.impl;\n\nimport java.io.IOException;\n\nimport com.fasterxml.jackson.annotation.JsonTypeInfo.As;\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.util.JsonParserSequence;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\nimport com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\nimport com.fasterxml.jackson.databind.util.TokenBuffer;\n\n\npublic class AsWrapperTypeDeserializer extends TypeDeserializerBase implements java.io.Serializable { private static final long serialVersionUID = 5345570420394408290L; public AsWrapperTypeDeserializer(JavaType bt, TypeIdResolver idRes, String typePropertyName, boolean typeIdVisible, Class<?> defaultImpl) {\n        super(bt, idRes, typePropertyName, typeIdVisible, defaultImpl);\n    }\n\n    protected AsWrapperTypeDeserializer(AsWrapperTypeDeserializer src, BeanProperty property) {\n        super(src, property);\n    }\n    \n    @Override\n    public TypeDeserializer forProperty(BeanProperty prop) {\n        return (prop == _property) ? this : new AsWrapperTypeDeserializer(this, prop);\n    }\n    \n    @Override\n    public As getTypeInclusion() { return As.WRAPPER_OBJECT; }\n\n    \n    @Override\n    public Object deserializeTypedFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException {\n        return _deserialize(jp, ctxt);\n    }    \n\n    @Override\n    public Object deserializeTypedFromArray(JsonParser jp, DeserializationContext ctxt) throws IOException {\n        return _deserialize(jp, ctxt);\n    }\n\n    @Override\n    public Object deserializeTypedFromScalar(JsonParser jp, DeserializationContext ctxt) throws IOException {\n        return _deserialize(jp, ctxt);\n    }\n\n    @Override\n    public Object deserializeTypedFromAny(JsonParser jp, DeserializationContext ctxt) throws IOException {\n        return _deserialize(jp, ctxt);\n    }\n    \n    \n\n    \n    @SuppressWarnings(\"resource\")\n    private final Object _deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n        \n        if (p.canReadTypeId()) {\n            Object typeId = p.getTypeId();\n            if (typeId != null) {\n                return _deserializeWithNativeTypeId(p, ctxt, typeId);\n            }\n        }\n        \n        JsonToken t = p.getCurrentToken();\n        if (t == JsonToken.START_OBJECT) {\n            \n            if (p.nextToken() != JsonToken.FIELD_NAME) {\n                throw ctxt.wrongTokenException(p, JsonToken.FIELD_NAME,\n                        \"need JSON String that contains type id (for subtype of \"+baseTypeName()+\")\");\n            }\n        } else if (t != JsonToken.FIELD_NAME) {\n            throw ctxt.wrongTokenException(p, JsonToken.START_OBJECT,\n                    \"need JSON Object to contain As.WRAPPER_OBJECT type information for class \"+baseTypeName());\n        }\n        final String typeId = p.getText();\n        JsonDeserializer<Object> deser = _findDeserializer(ctxt, typeId);\n        p.nextToken();\n\n        \n        if (_typeIdVisible && p.getCurrentToken() == JsonToken.START_OBJECT) {\n            \n            TokenBuffer tb = new TokenBuffer(null, false);\n            tb.writeStartObject(); \n            tb.writeFieldName(_typePropertyName);\n            tb.writeString(typeId);\n            p = JsonParserSequence.createFlattened(tb.asParser(p), p);\n            p.nextToken();\n        }\n        \n        Object value = deser.deserialize(p, ctxt);\n        \n        if (p.nextToken() != JsonToken.END_OBJECT) {\n            throw ctxt.wrongTokenException(p, JsonToken.END_OBJECT,\n                    \"expected closing END_OBJECT after type information and deserialized value\");\n        }\n        return value;\n    }\n}\n",
      "buggy_signatures": [
        "protected AsWrapperTypeDeserializer(AsWrapperTypeDeserializer src, BeanProperty property)",
        "public TypeDeserializer forProperty(BeanProperty prop)",
        "public As getTypeInclusion()",
        "public Object deserializeTypedFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException",
        "public Object deserializeTypedFromArray(JsonParser jp, DeserializationContext ctxt) throws IOException",
        "public Object deserializeTypedFromScalar(JsonParser jp, DeserializationContext ctxt) throws IOException",
        "public Object deserializeTypedFromAny(JsonParser jp, DeserializationContext ctxt) throws IOException",
        "private final Object _deserialize(JsonParser p, DeserializationContext ctxt) throws IOException"
      ],
      "fixed_signatures": [
        "protected AsWrapperTypeDeserializer(AsWrapperTypeDeserializer src, BeanProperty property)",
        "public TypeDeserializer forProperty(BeanProperty prop)",
        "public As getTypeInclusion()",
        "public Object deserializeTypedFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException",
        "public Object deserializeTypedFromArray(JsonParser jp, DeserializationContext ctxt) throws IOException",
        "public Object deserializeTypedFromScalar(JsonParser jp, DeserializationContext ctxt) throws IOException",
        "public Object deserializeTypedFromAny(JsonParser jp, DeserializationContext ctxt) throws IOException",
        "private final Object _deserialize(JsonParser p, DeserializationContext ctxt) throws IOException"
      ],
      "methods": [
        {
          "buggy_method": "  private final Object _deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n  \n  if (p.canReadTypeId()) {\n  Object typeId = p.getTypeId();\n  if (typeId != null) {\n  return _deserializeWithNativeTypeId(p, ctxt, typeId);\n  }\n  }\n  \n  if (p.getCurrentToken() != JsonToken.START_OBJECT) {\n  throw ctxt.wrongTokenException(p, JsonToken.START_OBJECT,\n  \"need JSON Object to contain As.WRAPPER_OBJECT type information for class \"+baseTypeName());\n  }\n  \n  if (p.nextToken() != JsonToken.FIELD_NAME) {\n  throw ctxt.wrongTokenException(p, JsonToken.FIELD_NAME,\n  \"need JSON String that contains type id (for subtype of \"+baseTypeName()+\")\");\n  }\n  final String typeId = p.getText();\n  JsonDeserializer<Object> deser = _findDeserializer(ctxt, typeId);\n  p.nextToken();\n\n  \n  if (_typeIdVisible && p.getCurrentToken() == JsonToken.START_OBJECT) {\n  \n  TokenBuffer tb = new TokenBuffer(null, false);\n  tb.writeStartObject(); \n  tb.writeFieldName(_typePropertyName);\n  tb.writeString(typeId);\n  p = JsonParserSequence.createFlattened(tb.asParser(p), p);\n  p.nextToken();\n  }\n  \n  Object value = deser.deserialize(p, ctxt);\n  \n  if (p.nextToken() != JsonToken.END_OBJECT) {\n  throw ctxt.wrongTokenException(p, JsonToken.END_OBJECT,\n  \"expected closing END_OBJECT after type information and deserialized value\");\n  }\n  return value;\n  }",
          "fixed_method": "  private final Object _deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n  \n  if (p.canReadTypeId()) {\n  Object typeId = p.getTypeId();\n  if (typeId != null) {\n  return _deserializeWithNativeTypeId(p, ctxt, typeId);\n  }\n  }\n  \n  JsonToken t = p.getCurrentToken();\n  if (t == JsonToken.START_OBJECT) {\n  \n  if (p.nextToken() != JsonToken.FIELD_NAME) {\n  throw ctxt.wrongTokenException(p, JsonToken.FIELD_NAME,\n  \"need JSON String that contains type id (for subtype of \"+baseTypeName()+\")\");\n  }\n  } else if (t != JsonToken.FIELD_NAME) {\n  throw ctxt.wrongTokenException(p, JsonToken.START_OBJECT,\n  \"need JSON Object to contain As.WRAPPER_OBJECT type information for class \"+baseTypeName());\n  }\n  final String typeId = p.getText();\n  JsonDeserializer<Object> deser = _findDeserializer(ctxt, typeId);\n  p.nextToken();\n\n  \n  if (_typeIdVisible && p.getCurrentToken() == JsonToken.START_OBJECT) {\n  \n  TokenBuffer tb = new TokenBuffer(null, false);\n  tb.writeStartObject(); \n  tb.writeFieldName(_typePropertyName);\n  tb.writeString(typeId);\n  p = JsonParserSequence.createFlattened(tb.asParser(p), p);\n  p.nextToken();\n  }\n  \n  Object value = deser.deserialize(p, ctxt);\n  \n  if (p.nextToken() != JsonToken.END_OBJECT) {\n  throw ctxt.wrongTokenException(p, JsonToken.END_OBJECT,\n  \"expected closing END_OBJECT after type information and deserialized value\");\n  }\n  return value;\n  }",
          "diff": [
            "@@ -86,15 +86,17 @@",
            "             }\n",
            "         }\n",
            "         // first, sanity checks\n",
            "-        if (p.getCurrentToken() != JsonToken.START_OBJECT) {\n",
            "-            throw ctxt.wrongTokenException(p, JsonToken.START_OBJECT,\n",
            "-                    \"need JSON Object to contain As.WRAPPER_OBJECT type information for class \"+baseTypeName());\n",
            "-        }\n",
            "+        JsonToken t = p.getCurrentToken();\n",
            "+        if (t == JsonToken.START_OBJECT) {\n",
            "             // should always get field name, but just in case...\n",
            "             if (p.nextToken() != JsonToken.FIELD_NAME) {\n",
            "                 throw ctxt.wrongTokenException(p, JsonToken.FIELD_NAME,\n",
            "                         \"need JSON String that contains type id (for subtype of \"+baseTypeName()+\")\");\n",
            "             }\n",
            "+        } else if (t != JsonToken.FIELD_NAME) {\n",
            "+            throw ctxt.wrongTokenException(p, JsonToken.START_OBJECT,\n",
            "+                    \"need JSON Object to contain As.WRAPPER_OBJECT type information for class \"+baseTypeName());\n",
            "+        }\n",
            "         final String typeId = p.getText();\n",
            "         JsonDeserializer<Object> deser = _findDeserializer(ctxt, typeId);\n",
            "         p.nextToken();\n"
          ],
          "changed_lines": 10
        }
      ]
    }
  ]
}
