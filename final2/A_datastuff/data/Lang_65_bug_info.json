{
  "bug_id": "65",
  "failed_tests": {
    "org.apache.commons.lang.time.DateUtilsTest": [
      {
        "methodName": "testTruncateLang59",
        "error": "junit.framework.AssertionFailedError",
        "message": "Truncate Calendar.SECOND expected:<Sun Oct 31 01:02:03 MDT 2004> but was:<Sun Oct 31 01:02:03 MST 2004>",
        "fail_line": "        assertEquals(\"Truncate Calendar.SECOND\",",
        "test_source": "  public void testTruncateLang59() throws Exception {\n\n  // Set TimeZone to Mountain Time\n  TimeZone MST_MDT = TimeZone.getTimeZone(\"MST7MDT\");\n  TimeZone.setDefault(MST_MDT);\n  DateFormat format = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.SSS z\");\n  format.setTimeZone(MST_MDT);\n\n  Date oct31_01MDT = new Date(1099206000000L); \n\n  Date oct31MDT  = new Date(oct31_01MDT.getTime()  - 3600000L); // - 1 hour\n  Date oct31_01_02MDT  = new Date(oct31_01MDT.getTime()  + 120000L);  // + 2 minutes\n  Date oct31_01_02_03MDT  = new Date(oct31_01_02MDT.getTime()  + 3000L);  // + 3 seconds\n  Date oct31_01_02_03_04MDT = new Date(oct31_01_02_03MDT.getTime() + 4L);  // + 4 milliseconds\n\n  assertEquals(\"Check 00:00:00.000\", \"2004-10-31 00:00:00.000 MDT\", format.format(oct31MDT));\n  assertEquals(\"Check 01:00:00.000\", \"2004-10-31 01:00:00.000 MDT\", format.format(oct31_01MDT));\n  assertEquals(\"Check 01:02:00.000\", \"2004-10-31 01:02:00.000 MDT\", format.format(oct31_01_02MDT));\n  assertEquals(\"Check 01:02:03.000\", \"2004-10-31 01:02:03.000 MDT\", format.format(oct31_01_02_03MDT));\n  assertEquals(\"Check 01:02:03.004\", \"2004-10-31 01:02:03.004 MDT\", format.format(oct31_01_02_03_04MDT));\n\n  // ------- Demonstrate Problem -------\n  Calendar gval = Calendar.getInstance();\n  gval.setTime(new Date(oct31_01MDT.getTime()));\n  gval.set(Calendar.MINUTE, gval.get(Calendar.MINUTE)); // set minutes to the same value\n  assertEquals(\"Demonstrate Problem\", gval.getTime().getTime(), oct31_01MDT.getTime() + 3600000L);\n\n  // ---------- Test Truncate ----------\n  assertEquals(\"Truncate Calendar.MILLISECOND\",\n  oct31_01_02_03_04MDT, DateUtils.truncate(oct31_01_02_03_04MDT, Calendar.MILLISECOND));\n\n  assertEquals(\"Truncate Calendar.SECOND\",\n  oct31_01_02_03MDT, DateUtils.truncate(oct31_01_02_03_04MDT, Calendar.SECOND));\n\n  assertEquals(\"Truncate Calendar.MINUTE\",\n  oct31_01_02MDT, DateUtils.truncate(oct31_01_02_03_04MDT, Calendar.MINUTE));\n\n  assertEquals(\"Truncate Calendar.HOUR_OF_DAY\",\n  oct31_01MDT, DateUtils.truncate(oct31_01_02_03_04MDT, Calendar.HOUR_OF_DAY));\n\n  assertEquals(\"Truncate Calendar.HOUR\",\n  oct31_01MDT, DateUtils.truncate(oct31_01_02_03_04MDT, Calendar.HOUR));\n\n  assertEquals(\"Truncate Calendar.DATE\",\n  oct31MDT, DateUtils.truncate(oct31_01_02_03_04MDT, Calendar.DATE));\n\n\n  // ---------- Test Round (down) ----------\n  assertEquals(\"Round Calendar.MILLISECOND\",\n  oct31_01_02_03_04MDT, DateUtils.round(oct31_01_02_03_04MDT, Calendar.MILLISECOND));\n\n  assertEquals(\"Round Calendar.SECOND\",\n  oct31_01_02_03MDT, DateUtils.round(oct31_01_02_03_04MDT, Calendar.SECOND));\n\n  assertEquals(\"Round Calendar.MINUTE\",\n  oct31_01_02MDT, DateUtils.round(oct31_01_02_03_04MDT, Calendar.MINUTE));\n\n  assertEquals(\"Round Calendar.HOUR_OF_DAY\",\n  oct31_01MDT, DateUtils.round(oct31_01_02_03_04MDT, Calendar.HOUR_OF_DAY));\n\n  assertEquals(\"Round Calendar.HOUR\",\n  oct31_01MDT, DateUtils.round(oct31_01_02_03_04MDT, Calendar.HOUR));\n\n  assertEquals(\"Round Calendar.DATE\",\n  oct31MDT, DateUtils.round(oct31_01_02_03_04MDT, Calendar.DATE));\n\n  // restore default time zone\n  TimeZone.setDefault(defaultZone);\n  }",
        "stack": [
          "DateUtilsTest.testTruncateLang59 line 925"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/lang/time/DateUtils.java",
      "buggy_full_code": "\npackage org.apache.commons.lang.time;\n\nimport java.text.ParseException;\nimport java.text.ParsePosition;\nimport java.text.SimpleDateFormat;\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\nimport java.util.TimeZone;\n\n\npublic class DateUtils { public static final TimeZone UTC_TIME_ZONE = TimeZone.getTimeZone(\"GMT\"); public static final long MILLIS_PER_SECOND = 1000; public static final long MILLIS_PER_MINUTE = 60 * MILLIS_PER_SECOND; public static final long MILLIS_PER_HOUR = 60 * MILLIS_PER_MINUTE; public static final long MILLIS_PER_DAY = 24 * MILLIS_PER_HOUR; public final static int SEMI_MONTH = 1001; private static final int[][] fields = {\n            {Calendar.MILLISECOND},\n            {Calendar.SECOND},\n            {Calendar.MINUTE},\n            {Calendar.HOUR_OF_DAY, Calendar.HOUR},\n            {Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM \n                \n            },\n            {Calendar.MONTH, DateUtils.SEMI_MONTH},\n            {Calendar.YEAR},\n            {Calendar.ERA}};\n\n    \n    public final static int RANGE_WEEK_SUNDAY = 1; public final static int RANGE_WEEK_MONDAY = 2; public final static int RANGE_WEEK_RELATIVE = 3; public final static int RANGE_WEEK_CENTER = 4; public final static int RANGE_MONTH_SUNDAY = 5; public final static int RANGE_MONTH_MONDAY = 6; public DateUtils() {\n        super();\n    }\n\n    \n    \n    public static boolean isSameDay(Date date1, Date date2) {\n        if (date1 == null || date2 == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        Calendar cal1 = Calendar.getInstance();\n        cal1.setTime(date1);\n        Calendar cal2 = Calendar.getInstance();\n        cal2.setTime(date2);\n        return isSameDay(cal1, cal2);\n    }\n\n    \n    public static boolean isSameDay(Calendar cal1, Calendar cal2) {\n        if (cal1 == null || cal2 == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        return (cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR));\n    }\n\n    \n    \n    public static boolean isSameInstant(Date date1, Date date2) {\n        if (date1 == null || date2 == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        return date1.getTime() == date2.getTime();\n    }\n\n    \n    public static boolean isSameInstant(Calendar cal1, Calendar cal2) {\n        if (cal1 == null || cal2 == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        return cal1.getTime().getTime() == cal2.getTime().getTime();\n    }\n\n    \n    \n    public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {\n        if (cal1 == null || cal2 == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());\n    }\n\n    \n    \n    public static Date parseDate(String str, String[] parsePatterns) throws ParseException {\n        if (str == null || parsePatterns == null) {\n            throw new IllegalArgumentException(\"Date and Patterns must not be null\");\n        }\n        \n        SimpleDateFormat parser = null;\n        ParsePosition pos = new ParsePosition(0);\n        for (int i = 0; i < parsePatterns.length; i++) {\n            if (i == 0) {\n                parser = new SimpleDateFormat(parsePatterns[0]);\n            } else {\n                parser.applyPattern(parsePatterns[i]);\n            }\n            pos.setIndex(0);\n            Date date = parser.parse(str, pos);\n            if (date != null && pos.getIndex() == str.length()) {\n                return date;\n            }\n        }\n        throw new ParseException(\"Unable to parse the date: \" + str, -1);\n    }\n\n    \n    \n    public static Date addYears(Date date, int amount) {\n        return add(date, Calendar.YEAR, amount);\n    }\n\n    \n    \n    public static Date addMonths(Date date, int amount) {\n        return add(date, Calendar.MONTH, amount);\n    }\n\n    \n    \n    public static Date addWeeks(Date date, int amount) {\n        return add(date, Calendar.WEEK_OF_YEAR, amount);\n    }\n\n    \n    \n    public static Date addDays(Date date, int amount) {\n        return add(date, Calendar.DAY_OF_MONTH, amount);\n    }\n\n    \n    \n    public static Date addHours(Date date, int amount) {\n        return add(date, Calendar.HOUR_OF_DAY, amount);\n    }\n\n    \n    \n    public static Date addMinutes(Date date, int amount) {\n        return add(date, Calendar.MINUTE, amount);\n    }\n\n    \n    \n    public static Date addSeconds(Date date, int amount) {\n        return add(date, Calendar.SECOND, amount);\n    }\n\n    \n    \n    public static Date addMilliseconds(Date date, int amount) {\n        return add(date, Calendar.MILLISECOND, amount);\n    }\n\n    \n    \n    public static Date add(Date date, int calendarField, int amount) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        Calendar c = Calendar.getInstance();\n        c.setTime(date);\n        c.add(calendarField, amount);\n        return c.getTime();\n    }\n\n    \n    \n    public static Date round(Date date, int field) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        Calendar gval = Calendar.getInstance();\n        gval.setTime(date);\n        modify(gval, field, true);\n        return gval.getTime();\n    }\n\n    \n    public static Calendar round(Calendar date, int field) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        Calendar rounded = (Calendar) date.clone();\n        modify(rounded, field, true);\n        return rounded;\n    }\n\n    \n    public static Date round(Object date, int field) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        if (date instanceof Date) {\n            return round((Date) date, field);\n        } else if (date instanceof Calendar) {\n            return round((Calendar) date, field).getTime();\n        } else {\n            throw new ClassCastException(\"Could not round \" + date);\n        }\n    }\n\n    \n    \n    public static Date truncate(Date date, int field) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        Calendar gval = Calendar.getInstance();\n        gval.setTime(date);\n        modify(gval, field, false);\n        return gval.getTime();\n    }\n\n    \n    public static Calendar truncate(Calendar date, int field) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        Calendar truncated = (Calendar) date.clone();\n        modify(truncated, field, false);\n        return truncated;\n    }\n\n    \n    public static Date truncate(Object date, int field) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        if (date instanceof Date) {\n            return truncate((Date) date, field);\n        } else if (date instanceof Calendar) {\n            return truncate((Calendar) date, field).getTime();\n        } else {\n            throw new ClassCastException(\"Could not truncate \" + date);\n        }\n    }\n\n    \n    \n    private static void modify(Calendar val, int field, boolean round) {\n        if (val.get(Calendar.YEAR) > 280000000) {\n            throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n        }\n        \n\n        \n        \n        \n        \n        \n\n\n        \n\n        \n\n        \n\n        \n        \n\n        boolean roundUp = false;\n        for (int i = 0; i < fields.length; i++) {\n            for (int j = 0; j < fields[i].length; j++) {\n                if (fields[i][j] == field) {\n                    \n                    if (round && roundUp) {\n                        if (field == DateUtils.SEMI_MONTH) {\n                            \n                            \n                            \n                            if (val.get(Calendar.DATE) == 1) {\n                                val.add(Calendar.DATE, 15);\n                            } else {\n                                val.add(Calendar.DATE, -15);\n                                val.add(Calendar.MONTH, 1);\n                            }\n                        } else {\n                            \n                            \n                            val.add(fields[i][0], 1);\n                        }\n                    }\n                    return;\n                }\n            }\n            \n            int offset = 0;\n            boolean offsetSet = false;\n            \n            switch (field) {\n                case DateUtils.SEMI_MONTH:\n                    if (fields[i][0] == Calendar.DATE) {\n                        \n                        \n                        \n                        offset = val.get(Calendar.DATE) - 1;\n                        \n                        \n                        if (offset >= 15) {\n                            offset -= 15;\n                        }\n                        \n                        roundUp = offset > 7;\n                        offsetSet = true;\n                    }\n                    break;\n                case Calendar.AM_PM:\n                    if (fields[i][0] == Calendar.HOUR_OF_DAY) {\n                        \n                        \n                        offset = val.get(Calendar.HOUR_OF_DAY);\n                        if (offset >= 12) {\n                            offset -= 12;\n                        }\n                        roundUp = offset > 6;\n                        offsetSet = true;\n                    }\n                    break;\n            }\n            if (!offsetSet) {\n                int min = val.getActualMinimum(fields[i][0]);\n                int max = val.getActualMaximum(fields[i][0]);\n                \n                offset = val.get(fields[i][0]) - min;\n                \n                roundUp = offset > ((max - min) / 2);\n            }\n            \n                val.set(fields[i][0], val.get(fields[i][0]) - offset);\n        }\n        throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n\n    }\n\n    \n    \n    public static Iterator iterator(Date focus, int rangeStyle) {\n        if (focus == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        Calendar gval = Calendar.getInstance();\n        gval.setTime(focus);\n        return iterator(gval, rangeStyle);\n    }\n\n    \n    public static Iterator iterator(Calendar focus, int rangeStyle) {\n        if (focus == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        Calendar start = null;\n        Calendar end = null;\n        int startCutoff = Calendar.SUNDAY;\n        int endCutoff = Calendar.SATURDAY;\n        switch (rangeStyle) {\n            case RANGE_MONTH_SUNDAY:\n            case RANGE_MONTH_MONDAY:\n                \n                start = truncate(focus, Calendar.MONTH);\n                \n                end = (Calendar) start.clone();\n                end.add(Calendar.MONTH, 1);\n                end.add(Calendar.DATE, -1);\n                \n                if (rangeStyle == RANGE_MONTH_MONDAY) {\n                    startCutoff = Calendar.MONDAY;\n                    endCutoff = Calendar.SUNDAY;\n                }\n                break;\n            case RANGE_WEEK_SUNDAY:\n            case RANGE_WEEK_MONDAY:\n            case RANGE_WEEK_RELATIVE:\n            case RANGE_WEEK_CENTER:\n                \n                start = truncate(focus, Calendar.DATE);\n                end = truncate(focus, Calendar.DATE);\n                switch (rangeStyle) {\n                    case RANGE_WEEK_SUNDAY:\n                        \n                        break;\n                    case RANGE_WEEK_MONDAY:\n                        startCutoff = Calendar.MONDAY;\n                        endCutoff = Calendar.SUNDAY;\n                        break;\n                    case RANGE_WEEK_RELATIVE:\n                        startCutoff = focus.get(Calendar.DAY_OF_WEEK);\n                        endCutoff = startCutoff - 1;\n                        break;\n                    case RANGE_WEEK_CENTER:\n                        startCutoff = focus.get(Calendar.DAY_OF_WEEK) - 3;\n                        endCutoff = focus.get(Calendar.DAY_OF_WEEK) + 3;\n                        break;\n                }\n                break;\n            default:\n                throw new IllegalArgumentException(\"The range style \" + rangeStyle + \" is not valid.\");\n        }\n        if (startCutoff < Calendar.SUNDAY) {\n            startCutoff += 7;\n        }\n        if (startCutoff > Calendar.SATURDAY) {\n            startCutoff -= 7;\n        }\n        if (endCutoff < Calendar.SUNDAY) {\n            endCutoff += 7;\n        }\n        if (endCutoff > Calendar.SATURDAY) {\n            endCutoff -= 7;\n        }\n        while (start.get(Calendar.DAY_OF_WEEK) != startCutoff) {\n            start.add(Calendar.DATE, -1);\n        }\n        while (end.get(Calendar.DAY_OF_WEEK) != endCutoff) {\n            end.add(Calendar.DATE, 1);\n        }\n        return new DateIterator(start, end);\n    }\n\n    \n    public static Iterator iterator(Object focus, int rangeStyle) {\n        if (focus == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        if (focus instanceof Date) {\n            return iterator((Date) focus, rangeStyle);\n        } else if (focus instanceof Calendar) {\n            return iterator((Calendar) focus, rangeStyle);\n        } else {\n            throw new ClassCastException(\"Could not iterate based on \" + focus);\n        }\n    }\n\n    \n    static class DateIterator implements Iterator { private final Calendar endFinal; private final Calendar spot; DateIterator(Calendar startFinal, Calendar endFinal) {\n            super();\n            this.endFinal = endFinal;\n            spot = startFinal;\n            spot.add(Calendar.DATE, -1);\n        }\n\n        \n        public boolean hasNext() {\n            return spot.before(endFinal);\n        }\n\n        \n        public Object next() {\n            if (spot.equals(endFinal)) {\n                throw new NoSuchElementException();\n            }\n            spot.add(Calendar.DATE, 1);\n            return spot.clone();\n        }\n\n        \n        public void remove() {\n            throw new UnsupportedOperationException();\n        }\n    }\n    \n    \n    \n    \n    \n    \n    public static final int MILLIS_IN_SECOND = 1000;\n    \n    public static final int MILLIS_IN_MINUTE = 60 * 1000;\n    \n    public static final int MILLIS_IN_HOUR = 60 * 60 * 1000;\n    \n    public static final int MILLIS_IN_DAY = 24 * 60 * 60 * 1000;\n    \n}\n",
      "fixed_full_code": "\npackage org.apache.commons.lang.time;\n\nimport java.text.ParseException;\nimport java.text.ParsePosition;\nimport java.text.SimpleDateFormat;\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\nimport java.util.TimeZone;\n\n\npublic class DateUtils { public static final TimeZone UTC_TIME_ZONE = TimeZone.getTimeZone(\"GMT\"); public static final long MILLIS_PER_SECOND = 1000; public static final long MILLIS_PER_MINUTE = 60 * MILLIS_PER_SECOND; public static final long MILLIS_PER_HOUR = 60 * MILLIS_PER_MINUTE; public static final long MILLIS_PER_DAY = 24 * MILLIS_PER_HOUR; public final static int SEMI_MONTH = 1001; private static final int[][] fields = {\n            {Calendar.MILLISECOND},\n            {Calendar.SECOND},\n            {Calendar.MINUTE},\n            {Calendar.HOUR_OF_DAY, Calendar.HOUR},\n            {Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM \n                \n            },\n            {Calendar.MONTH, DateUtils.SEMI_MONTH},\n            {Calendar.YEAR},\n            {Calendar.ERA}};\n\n    \n    public final static int RANGE_WEEK_SUNDAY = 1; public final static int RANGE_WEEK_MONDAY = 2; public final static int RANGE_WEEK_RELATIVE = 3; public final static int RANGE_WEEK_CENTER = 4; public final static int RANGE_MONTH_SUNDAY = 5; public final static int RANGE_MONTH_MONDAY = 6; public DateUtils() {\n        super();\n    }\n\n    \n    \n    public static boolean isSameDay(Date date1, Date date2) {\n        if (date1 == null || date2 == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        Calendar cal1 = Calendar.getInstance();\n        cal1.setTime(date1);\n        Calendar cal2 = Calendar.getInstance();\n        cal2.setTime(date2);\n        return isSameDay(cal1, cal2);\n    }\n\n    \n    public static boolean isSameDay(Calendar cal1, Calendar cal2) {\n        if (cal1 == null || cal2 == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        return (cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR));\n    }\n\n    \n    \n    public static boolean isSameInstant(Date date1, Date date2) {\n        if (date1 == null || date2 == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        return date1.getTime() == date2.getTime();\n    }\n\n    \n    public static boolean isSameInstant(Calendar cal1, Calendar cal2) {\n        if (cal1 == null || cal2 == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        return cal1.getTime().getTime() == cal2.getTime().getTime();\n    }\n\n    \n    \n    public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {\n        if (cal1 == null || cal2 == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());\n    }\n\n    \n    \n    public static Date parseDate(String str, String[] parsePatterns) throws ParseException {\n        if (str == null || parsePatterns == null) {\n            throw new IllegalArgumentException(\"Date and Patterns must not be null\");\n        }\n        \n        SimpleDateFormat parser = null;\n        ParsePosition pos = new ParsePosition(0);\n        for (int i = 0; i < parsePatterns.length; i++) {\n            if (i == 0) {\n                parser = new SimpleDateFormat(parsePatterns[0]);\n            } else {\n                parser.applyPattern(parsePatterns[i]);\n            }\n            pos.setIndex(0);\n            Date date = parser.parse(str, pos);\n            if (date != null && pos.getIndex() == str.length()) {\n                return date;\n            }\n        }\n        throw new ParseException(\"Unable to parse the date: \" + str, -1);\n    }\n\n    \n    \n    public static Date addYears(Date date, int amount) {\n        return add(date, Calendar.YEAR, amount);\n    }\n\n    \n    \n    public static Date addMonths(Date date, int amount) {\n        return add(date, Calendar.MONTH, amount);\n    }\n\n    \n    \n    public static Date addWeeks(Date date, int amount) {\n        return add(date, Calendar.WEEK_OF_YEAR, amount);\n    }\n\n    \n    \n    public static Date addDays(Date date, int amount) {\n        return add(date, Calendar.DAY_OF_MONTH, amount);\n    }\n\n    \n    \n    public static Date addHours(Date date, int amount) {\n        return add(date, Calendar.HOUR_OF_DAY, amount);\n    }\n\n    \n    \n    public static Date addMinutes(Date date, int amount) {\n        return add(date, Calendar.MINUTE, amount);\n    }\n\n    \n    \n    public static Date addSeconds(Date date, int amount) {\n        return add(date, Calendar.SECOND, amount);\n    }\n\n    \n    \n    public static Date addMilliseconds(Date date, int amount) {\n        return add(date, Calendar.MILLISECOND, amount);\n    }\n\n    \n    \n    public static Date add(Date date, int calendarField, int amount) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        Calendar c = Calendar.getInstance();\n        c.setTime(date);\n        c.add(calendarField, amount);\n        return c.getTime();\n    }\n\n    \n    \n    public static Date round(Date date, int field) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        Calendar gval = Calendar.getInstance();\n        gval.setTime(date);\n        modify(gval, field, true);\n        return gval.getTime();\n    }\n\n    \n    public static Calendar round(Calendar date, int field) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        Calendar rounded = (Calendar) date.clone();\n        modify(rounded, field, true);\n        return rounded;\n    }\n\n    \n    public static Date round(Object date, int field) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        if (date instanceof Date) {\n            return round((Date) date, field);\n        } else if (date instanceof Calendar) {\n            return round((Calendar) date, field).getTime();\n        } else {\n            throw new ClassCastException(\"Could not round \" + date);\n        }\n    }\n\n    \n    \n    public static Date truncate(Date date, int field) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        Calendar gval = Calendar.getInstance();\n        gval.setTime(date);\n        modify(gval, field, false);\n        return gval.getTime();\n    }\n\n    \n    public static Calendar truncate(Calendar date, int field) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        Calendar truncated = (Calendar) date.clone();\n        modify(truncated, field, false);\n        return truncated;\n    }\n\n    \n    public static Date truncate(Object date, int field) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        if (date instanceof Date) {\n            return truncate((Date) date, field);\n        } else if (date instanceof Calendar) {\n            return truncate((Calendar) date, field).getTime();\n        } else {\n            throw new ClassCastException(\"Could not truncate \" + date);\n        }\n    }\n\n    \n    \n    private static void modify(Calendar val, int field, boolean round) {\n        if (val.get(Calendar.YEAR) > 280000000) {\n            throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n        }\n        \n        if (field == Calendar.MILLISECOND) {\n            return;\n        }\n\n        \n        \n        \n        \n        \n\n        Date date = val.getTime();\n        long time = date.getTime();\n        boolean done = false;\n\n        \n        int millisecs = val.get(Calendar.MILLISECOND);\n        if (!round || millisecs < 500) {\n            time = time - millisecs;\n            if (field == Calendar.SECOND) {\n                done = true;\n            }\n        }\n\n        \n        int seconds = val.get(Calendar.SECOND);\n        if (!done && (!round || seconds < 30)) {\n            time = time - (seconds * 1000L);\n            if (field == Calendar.MINUTE) {\n                done = true;\n            }\n        }\n\n        \n        int minutes = val.get(Calendar.MINUTE);\n        if (!done && (!round || minutes < 30)) {\n            time = time - (minutes * 60000L);\n        }\n\n        \n        if (date.getTime() != time) {\n            date.setTime(time);\n            val.setTime(date);\n        }\n        \n\n        boolean roundUp = false;\n        for (int i = 0; i < fields.length; i++) {\n            for (int j = 0; j < fields[i].length; j++) {\n                if (fields[i][j] == field) {\n                    \n                    if (round && roundUp) {\n                        if (field == DateUtils.SEMI_MONTH) {\n                            \n                            \n                            \n                            if (val.get(Calendar.DATE) == 1) {\n                                val.add(Calendar.DATE, 15);\n                            } else {\n                                val.add(Calendar.DATE, -15);\n                                val.add(Calendar.MONTH, 1);\n                            }\n                        } else {\n                            \n                            \n                            val.add(fields[i][0], 1);\n                        }\n                    }\n                    return;\n                }\n            }\n            \n            int offset = 0;\n            boolean offsetSet = false;\n            \n            switch (field) {\n                case DateUtils.SEMI_MONTH:\n                    if (fields[i][0] == Calendar.DATE) {\n                        \n                        \n                        \n                        offset = val.get(Calendar.DATE) - 1;\n                        \n                        \n                        if (offset >= 15) {\n                            offset -= 15;\n                        }\n                        \n                        roundUp = offset > 7;\n                        offsetSet = true;\n                    }\n                    break;\n                case Calendar.AM_PM:\n                    if (fields[i][0] == Calendar.HOUR_OF_DAY) {\n                        \n                        \n                        offset = val.get(Calendar.HOUR_OF_DAY);\n                        if (offset >= 12) {\n                            offset -= 12;\n                        }\n                        roundUp = offset > 6;\n                        offsetSet = true;\n                    }\n                    break;\n            }\n            if (!offsetSet) {\n                int min = val.getActualMinimum(fields[i][0]);\n                int max = val.getActualMaximum(fields[i][0]);\n                \n                offset = val.get(fields[i][0]) - min;\n                \n                roundUp = offset > ((max - min) / 2);\n            }\n            \n            if (offset != 0) {\n                val.set(fields[i][0], val.get(fields[i][0]) - offset);\n            }\n        }\n        throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n\n    }\n\n    \n    \n    public static Iterator iterator(Date focus, int rangeStyle) {\n        if (focus == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        Calendar gval = Calendar.getInstance();\n        gval.setTime(focus);\n        return iterator(gval, rangeStyle);\n    }\n\n    \n    public static Iterator iterator(Calendar focus, int rangeStyle) {\n        if (focus == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        Calendar start = null;\n        Calendar end = null;\n        int startCutoff = Calendar.SUNDAY;\n        int endCutoff = Calendar.SATURDAY;\n        switch (rangeStyle) {\n            case RANGE_MONTH_SUNDAY:\n            case RANGE_MONTH_MONDAY:\n                \n                start = truncate(focus, Calendar.MONTH);\n                \n                end = (Calendar) start.clone();\n                end.add(Calendar.MONTH, 1);\n                end.add(Calendar.DATE, -1);\n                \n                if (rangeStyle == RANGE_MONTH_MONDAY) {\n                    startCutoff = Calendar.MONDAY;\n                    endCutoff = Calendar.SUNDAY;\n                }\n                break;\n            case RANGE_WEEK_SUNDAY:\n            case RANGE_WEEK_MONDAY:\n            case RANGE_WEEK_RELATIVE:\n            case RANGE_WEEK_CENTER:\n                \n                start = truncate(focus, Calendar.DATE);\n                end = truncate(focus, Calendar.DATE);\n                switch (rangeStyle) {\n                    case RANGE_WEEK_SUNDAY:\n                        \n                        break;\n                    case RANGE_WEEK_MONDAY:\n                        startCutoff = Calendar.MONDAY;\n                        endCutoff = Calendar.SUNDAY;\n                        break;\n                    case RANGE_WEEK_RELATIVE:\n                        startCutoff = focus.get(Calendar.DAY_OF_WEEK);\n                        endCutoff = startCutoff - 1;\n                        break;\n                    case RANGE_WEEK_CENTER:\n                        startCutoff = focus.get(Calendar.DAY_OF_WEEK) - 3;\n                        endCutoff = focus.get(Calendar.DAY_OF_WEEK) + 3;\n                        break;\n                }\n                break;\n            default:\n                throw new IllegalArgumentException(\"The range style \" + rangeStyle + \" is not valid.\");\n        }\n        if (startCutoff < Calendar.SUNDAY) {\n            startCutoff += 7;\n        }\n        if (startCutoff > Calendar.SATURDAY) {\n            startCutoff -= 7;\n        }\n        if (endCutoff < Calendar.SUNDAY) {\n            endCutoff += 7;\n        }\n        if (endCutoff > Calendar.SATURDAY) {\n            endCutoff -= 7;\n        }\n        while (start.get(Calendar.DAY_OF_WEEK) != startCutoff) {\n            start.add(Calendar.DATE, -1);\n        }\n        while (end.get(Calendar.DAY_OF_WEEK) != endCutoff) {\n            end.add(Calendar.DATE, 1);\n        }\n        return new DateIterator(start, end);\n    }\n\n    \n    public static Iterator iterator(Object focus, int rangeStyle) {\n        if (focus == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        if (focus instanceof Date) {\n            return iterator((Date) focus, rangeStyle);\n        } else if (focus instanceof Calendar) {\n            return iterator((Calendar) focus, rangeStyle);\n        } else {\n            throw new ClassCastException(\"Could not iterate based on \" + focus);\n        }\n    }\n\n    \n    static class DateIterator implements Iterator { private final Calendar endFinal; private final Calendar spot; DateIterator(Calendar startFinal, Calendar endFinal) {\n            super();\n            this.endFinal = endFinal;\n            spot = startFinal;\n            spot.add(Calendar.DATE, -1);\n        }\n\n        \n        public boolean hasNext() {\n            return spot.before(endFinal);\n        }\n\n        \n        public Object next() {\n            if (spot.equals(endFinal)) {\n                throw new NoSuchElementException();\n            }\n            spot.add(Calendar.DATE, 1);\n            return spot.clone();\n        }\n\n        \n        public void remove() {\n            throw new UnsupportedOperationException();\n        }\n    }\n    \n    \n    \n    \n    \n    \n    public static final int MILLIS_IN_SECOND = 1000;\n    \n    public static final int MILLIS_IN_MINUTE = 60 * 1000;\n    \n    public static final int MILLIS_IN_HOUR = 60 * 60 * 1000;\n    \n    public static final int MILLIS_IN_DAY = 24 * 60 * 60 * 1000;\n    \n}\n",
      "buggy_signatures": [
        "public static boolean isSameDay(Date date1, Date date2)",
        "public static boolean isSameDay(Calendar cal1, Calendar cal2)",
        "public static boolean isSameInstant(Date date1, Date date2)",
        "public static boolean isSameInstant(Calendar cal1, Calendar cal2)",
        "public static boolean isSameLocalTime(Calendar cal1, Calendar cal2)",
        "public static Date parseDate(String str, String[] parsePatterns) throws ParseException",
        "public static Date addYears(Date date, int amount)",
        "public static Date addMonths(Date date, int amount)",
        "public static Date addWeeks(Date date, int amount)",
        "public static Date addDays(Date date, int amount)",
        "public static Date addHours(Date date, int amount)",
        "public static Date addMinutes(Date date, int amount)",
        "public static Date addSeconds(Date date, int amount)",
        "public static Date addMilliseconds(Date date, int amount)",
        "public static Date add(Date date, int calendarField, int amount)",
        "public static Date round(Date date, int field)",
        "public static Calendar round(Calendar date, int field)",
        "public static Date round(Object date, int field)",
        "public static Date truncate(Date date, int field)",
        "public static Calendar truncate(Calendar date, int field)",
        "public static Date truncate(Object date, int field)",
        "private static void modify(Calendar val, int field, boolean round)",
        "public static Iterator iterator(Date focus, int rangeStyle)",
        "public static Iterator iterator(Calendar focus, int rangeStyle)",
        "public static Iterator iterator(Object focus, int rangeStyle)",
        "static class DateIterator implements Iterator { private final Calendar endFinal; private final Calendar spot; DateIterator(Calendar startFinal, Calendar endFinal)",
        "public boolean hasNext()",
        "public Object next()",
        "public void remove()"
      ],
      "fixed_signatures": [
        "public static boolean isSameDay(Date date1, Date date2)",
        "public static boolean isSameDay(Calendar cal1, Calendar cal2)",
        "public static boolean isSameInstant(Date date1, Date date2)",
        "public static boolean isSameInstant(Calendar cal1, Calendar cal2)",
        "public static boolean isSameLocalTime(Calendar cal1, Calendar cal2)",
        "public static Date parseDate(String str, String[] parsePatterns) throws ParseException",
        "public static Date addYears(Date date, int amount)",
        "public static Date addMonths(Date date, int amount)",
        "public static Date addWeeks(Date date, int amount)",
        "public static Date addDays(Date date, int amount)",
        "public static Date addHours(Date date, int amount)",
        "public static Date addMinutes(Date date, int amount)",
        "public static Date addSeconds(Date date, int amount)",
        "public static Date addMilliseconds(Date date, int amount)",
        "public static Date add(Date date, int calendarField, int amount)",
        "public static Date round(Date date, int field)",
        "public static Calendar round(Calendar date, int field)",
        "public static Date round(Object date, int field)",
        "public static Date truncate(Date date, int field)",
        "public static Calendar truncate(Calendar date, int field)",
        "public static Date truncate(Object date, int field)",
        "private static void modify(Calendar val, int field, boolean round)",
        "public static Iterator iterator(Date focus, int rangeStyle)",
        "public static Iterator iterator(Calendar focus, int rangeStyle)",
        "public static Iterator iterator(Object focus, int rangeStyle)",
        "static class DateIterator implements Iterator { private final Calendar endFinal; private final Calendar spot; DateIterator(Calendar startFinal, Calendar endFinal)",
        "public boolean hasNext()",
        "public Object next()",
        "public void remove()"
      ],
      "methods": [
        {
          "buggy_method": "  private static void modify(Calendar val, int field, boolean round) {\n  if (val.get(Calendar.YEAR) > 280000000) {\n  throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n  }\n  \n\n  \n  \n  \n  \n  \n\n\n  \n\n  \n\n  \n\n  \n  \n\n  boolean roundUp = false;\n  for (int i = 0; i < fields.length; i++) {\n  for (int j = 0; j < fields[i].length; j++) {\n  if (fields[i][j] == field) {\n  \n  if (round && roundUp) {\n  if (field == DateUtils.SEMI_MONTH) {\n  \n  \n  \n  if (val.get(Calendar.DATE) == 1) {\n  val.add(Calendar.DATE, 15);\n  } else {\n  val.add(Calendar.DATE, -15);\n  val.add(Calendar.MONTH, 1);\n  }\n  } else {\n  \n  \n  val.add(fields[i][0], 1);\n  }\n  }\n  return;\n  }\n  }\n  \n  int offset = 0;\n  boolean offsetSet = false;\n  \n  switch (field) {\n  case DateUtils.SEMI_MONTH:\n  if (fields[i][0] == Calendar.DATE) {\n  \n  \n  \n  offset = val.get(Calendar.DATE) - 1;\n  \n  \n  if (offset >= 15) {\n  offset -= 15;\n  }\n  \n  roundUp = offset > 7;\n  offsetSet = true;\n  }\n  break;\n  case Calendar.AM_PM:\n  if (fields[i][0] == Calendar.HOUR_OF_DAY) {\n  \n  \n  offset = val.get(Calendar.HOUR_OF_DAY);\n  if (offset >= 12) {\n  offset -= 12;\n  }\n  roundUp = offset > 6;\n  offsetSet = true;\n  }\n  break;\n  }\n  if (!offsetSet) {\n  int min = val.getActualMinimum(fields[i][0]);\n  int max = val.getActualMaximum(fields[i][0]);\n  \n  offset = val.get(fields[i][0]) - min;\n  \n  roundUp = offset > ((max - min) / 2);\n  }\n  \n  val.set(fields[i][0], val.get(fields[i][0]) - offset);\n  }\n  throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n\n  }",
          "fixed_method": "  private static void modify(Calendar val, int field, boolean round) {\n  if (val.get(Calendar.YEAR) > 280000000) {\n  throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n  }\n  \n  if (field == Calendar.MILLISECOND) {\n  return;\n  }\n\n  \n  \n  \n  \n  \n\n  Date date = val.getTime();\n  long time = date.getTime();\n  boolean done = false;\n\n  \n  int millisecs = val.get(Calendar.MILLISECOND);\n  if (!round || millisecs < 500) {\n  time = time - millisecs;\n  if (field == Calendar.SECOND) {\n  done = true;\n  }\n  }\n\n  \n  int seconds = val.get(Calendar.SECOND);\n  if (!done && (!round || seconds < 30)) {\n  time = time - (seconds * 1000L);\n  if (field == Calendar.MINUTE) {\n  done = true;\n  }\n  }\n\n  \n  int minutes = val.get(Calendar.MINUTE);\n  if (!done && (!round || minutes < 30)) {\n  time = time - (minutes * 60000L);\n  }\n\n  \n  if (date.getTime() != time) {\n  date.setTime(time);\n  val.setTime(date);\n  }\n  \n\n  boolean roundUp = false;\n  for (int i = 0; i < fields.length; i++) {\n  for (int j = 0; j < fields[i].length; j++) {\n  if (fields[i][j] == field) {\n  \n  if (round && roundUp) {\n  if (field == DateUtils.SEMI_MONTH) {\n  \n  \n  \n  if (val.get(Calendar.DATE) == 1) {\n  val.add(Calendar.DATE, 15);\n  } else {\n  val.add(Calendar.DATE, -15);\n  val.add(Calendar.MONTH, 1);\n  }\n  } else {\n  \n  \n  val.add(fields[i][0], 1);\n  }\n  }\n  return;\n  }\n  }\n  \n  int offset = 0;\n  boolean offsetSet = false;\n  \n  switch (field) {\n  case DateUtils.SEMI_MONTH:\n  if (fields[i][0] == Calendar.DATE) {\n  \n  \n  \n  offset = val.get(Calendar.DATE) - 1;\n  \n  \n  if (offset >= 15) {\n  offset -= 15;\n  }\n  \n  roundUp = offset > 7;\n  offsetSet = true;\n  }\n  break;\n  case Calendar.AM_PM:\n  if (fields[i][0] == Calendar.HOUR_OF_DAY) {\n  \n  \n  offset = val.get(Calendar.HOUR_OF_DAY);\n  if (offset >= 12) {\n  offset -= 12;\n  }\n  roundUp = offset > 6;\n  offsetSet = true;\n  }\n  break;\n  }\n  if (!offsetSet) {\n  int min = val.getActualMinimum(fields[i][0]);\n  int max = val.getActualMaximum(fields[i][0]);\n  \n  offset = val.get(fields[i][0]) - min;\n  \n  roundUp = offset > ((max - min) / 2);\n  }\n  \n  if (offset != 0) {\n  val.set(fields[i][0], val.get(fields[i][0]) - offset);\n  }\n  }\n  throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n\n  }",
          "diff": [
            "@@ -621,6 +621,9 @@",
            "             throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n",
            "         }\n",
            "         \n",
            "+        if (field == Calendar.MILLISECOND) {\n",
            "+            return;\n",
            "+        }\n",
            " \n",
            "         // ----------------- Fix for LANG-59 ---------------------- START ---------------\n",
            "         // see http://issues.apache.org/jira/browse/LANG-59\n",
            "@@ -628,14 +631,39 @@",
            "         // Manually truncate milliseconds, seconds and minutes, rather than using\n",
            "         // Calendar methods.\n",
            " \n",
            "+        Date date = val.getTime();\n",
            "+        long time = date.getTime();\n",
            "+        boolean done = false;\n",
            " \n",
            "         // truncate milliseconds\n",
            "+        int millisecs = val.get(Calendar.MILLISECOND);\n",
            "+        if (!round || millisecs < 500) {\n",
            "+            time = time - millisecs;\n",
            "+            if (field == Calendar.SECOND) {\n",
            "+                done = true;\n",
            "+            }\n",
            "+        }\n",
            " \n",
            "         // truncate seconds\n",
            "+        int seconds = val.get(Calendar.SECOND);\n",
            "+        if (!done && (!round || seconds < 30)) {\n",
            "+            time = time - (seconds * 1000L);\n",
            "+            if (field == Calendar.MINUTE) {\n",
            "+                done = true;\n",
            "+            }\n",
            "+        }\n",
            " \n",
            "         // truncate minutes\n",
            "+        int minutes = val.get(Calendar.MINUTE);\n",
            "+        if (!done && (!round || minutes < 30)) {\n",
            "+            time = time - (minutes * 60000L);\n",
            "+        }\n",
            " \n",
            "         // reset time\n",
            "+        if (date.getTime() != time) {\n",
            "+            date.setTime(time);\n",
            "+            val.setTime(date);\n",
            "+        }\n",
            "         // ----------------- Fix for LANG-59 ----------------------- END ----------------\n",
            " \n",
            "         boolean roundUp = false;\n",
            "@@ -706,7 +734,9 @@",
            "                 roundUp = offset > ((max - min) / 2);\n",
            "             }\n",
            "             //We need to remove this field\n",
            "+            if (offset != 0) {\n",
            "                 val.set(fields[i][0], val.get(fields[i][0]) - offset);\n",
            "+            }\n",
            "         }\n",
            "         throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n",
            " \n"
          ],
          "changed_lines": 30
        }
      ]
    }
  ]
}
