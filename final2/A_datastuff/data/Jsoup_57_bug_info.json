{
  "bug_id": "57",
  "failed_tests": {
    "org.jsoup.nodes.ElementTest": [
      {
        "methodName": "testChainedRemoveAttributes",
        "error": "java.util.ConcurrentModificationException",
        "message": "",
        "fail_line": "            .removeAttr(\"one\")",
        "test_source": "  public void testChainedRemoveAttributes() {\n  String html = \"<a one two three four>Text</a>\";\n  Document doc = Jsoup.parse(html);\n  Element a = doc.select(\"a\").first();\n  a\n  .removeAttr(\"zero\")\n  .removeAttr(\"one\")\n  .removeAttr(\"two\")\n  .removeAttr(\"three\")\n  .removeAttr(\"four\")\n  .removeAttr(\"five\");\n  assertEquals(\"<a>Text</a>\", a.outerHtml());\n  }",
        "stack": [
          "Attributes.removeIgnoreCase line 123, Node.removeAttr line 128, ElementTest.testChainedRemoveAttributes line 968"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/jsoup/nodes/Attributes.java",
      "buggy_full_code": "package org.jsoup.nodes;\n\nimport org.jsoup.SerializationException;\nimport org.jsoup.helper.Validate;\n\nimport java.io.IOException;\nimport java.util.AbstractMap;\nimport java.util.AbstractSet;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\n\npublic class Attributes implements Iterable<Attribute>, Cloneable { protected static final String dataPrefix = \"data-\"; private LinkedHashMap<String, Attribute> attributes = null; public String get(String key) {\n        Validate.notEmpty(key);\n\n        if (attributes == null)\n            return \"\";\n\n        Attribute attr = attributes.get(key);\n        return attr != null ? attr.getValue() : \"\";\n    }\n\n    \n    public String getIgnoreCase(String key) {\n        Validate.notEmpty(key);\n        if (attributes == null)\n            return \"\";\n\n        for (String attrKey : attributes.keySet()) {\n            if (attrKey.equalsIgnoreCase(key))\n                return attributes.get(attrKey).getValue();\n        }\n        return \"\";\n    }\n\n    \n    public void put(String key, String value) {\n        Attribute attr = new Attribute(key, value);\n        put(attr);\n    }\n\n    \n    public void put(String key, boolean value) {\n        if (value)\n            put(new BooleanAttribute(key));\n        else\n            remove(key);\n    }\n\n    \n    public void put(Attribute attribute) {\n        Validate.notNull(attribute);\n        if (attributes == null)\n             attributes = new LinkedHashMap<String, Attribute>(2);\n        attributes.put(attribute.getKey(), attribute);\n    }\n\n    \n    public void remove(String key) {\n        Validate.notEmpty(key);\n        if (attributes == null)\n            return;\n        attributes.remove(key);\n    }\n\n    \n    public void removeIgnoreCase(String key) {\n        Validate.notEmpty(key);\n        if (attributes == null)\n            return;\n        for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {\n            String attrKey = it.next();\n            if (attrKey.equalsIgnoreCase(key))\n                attributes.remove(attrKey);\n        }\n    }\n\n    \n    public boolean hasKey(String key) {\n        return attributes != null && attributes.containsKey(key);\n    }\n\n    \n    public boolean hasKeyIgnoreCase(String key) {\n        if (attributes == null)\n            return false;\n        for (String attrKey : attributes.keySet()) {\n            if (attrKey.equalsIgnoreCase(key))\n                return true;\n        }\n        return false;\n    }\n\n    \n    public int size() {\n        if (attributes == null)\n            return 0;\n        return attributes.size();\n    }\n\n    \n    public void addAll(Attributes incoming) {\n        if (incoming.size() == 0)\n            return;\n        if (attributes == null)\n            attributes = new LinkedHashMap<String, Attribute>(incoming.size());\n        attributes.putAll(incoming.attributes);\n    }\n\n    public Iterator<Attribute> iterator() {\n        if (attributes == null || attributes.isEmpty()) {\n            return Collections.<Attribute>emptyList().iterator();\n        }\n\n        return attributes.values().iterator();\n    }\n\n    \n    public List<Attribute> asList() {\n        if (attributes == null)\n            return Collections.emptyList();\n\n        List<Attribute> list = new ArrayList<Attribute>(attributes.size());\n        for (Map.Entry<String, Attribute> entry : attributes.entrySet()) {\n            list.add(entry.getValue());\n        }\n        return Collections.unmodifiableList(list);\n    }\n\n    \n    public Map<String, String> dataset() {\n        return new Dataset();\n    }\n\n    \n    public String html() {\n        StringBuilder accum = new StringBuilder();\n        try {\n            html(accum, (new Document(\"\")).outputSettings()); \n        } catch (IOException e) { \n            throw new SerializationException(e);\n        }\n        return accum.toString();\n    }\n\n    void html(Appendable accum, Document.OutputSettings out) throws IOException {\n        if (attributes == null)\n            return;\n\n        for (Map.Entry<String, Attribute> entry : attributes.entrySet()) {\n            Attribute attribute = entry.getValue();\n            accum.append(\" \");\n            attribute.html(accum, out);\n        }\n    }\n\n    @Override\n    public String toString() {\n        return html();\n    }\n\n    \n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (!(o instanceof Attributes)) return false;\n\n        Attributes that = (Attributes) o;\n\n        return !(attributes != null ? !attributes.equals(that.attributes) : that.attributes != null);\n    }\n\n    \n    @Override\n    public int hashCode() {\n        return attributes != null ? attributes.hashCode() : 0;\n    }\n\n    @Override\n    public Attributes clone() {\n        if (attributes == null)\n            return new Attributes();\n\n        Attributes clone;\n        try {\n            clone = (Attributes) super.clone();\n        } catch (CloneNotSupportedException e) {\n            throw new RuntimeException(e);\n        }\n        clone.attributes = new LinkedHashMap<String, Attribute>(attributes.size());\n        for (Attribute attribute: this)\n            clone.attributes.put(attribute.getKey(), attribute.clone());\n        return clone;\n    }\n\n    private class Dataset extends AbstractMap<String, String> { private Dataset() {\n            if (attributes == null)\n                attributes = new LinkedHashMap<String, Attribute>(2);\n        }\n\n        @Override\n        public Set<Entry<String, String>> entrySet() {\n            return new EntrySet();\n        }\n\n        @Override\n        public String put(String key, String value) {\n            String dataKey = dataKey(key);\n            String oldValue = hasKey(dataKey) ? attributes.get(dataKey).getValue() : null;\n            Attribute attr = new Attribute(dataKey, value);\n            attributes.put(dataKey, attr);\n            return oldValue;\n        }\n\n        private class EntrySet extends AbstractSet<Map.Entry<String, String>> { @Override public Iterator<Map.Entry<String, String>> iterator() {\n                return new DatasetIterator();\n            }\n\n           @Override\n            public int size() {\n                int count = 0;\n                Iterator iter = new DatasetIterator();\n                while (iter.hasNext())\n                    count++;\n                return count;\n            }\n        }\n\n        private class DatasetIterator implements Iterator<Map.Entry<String, String>> { private Iterator<Attribute> attrIter = attributes.values().iterator(); private Attribute attr; public boolean hasNext() {\n                while (attrIter.hasNext()) {\n                    attr = attrIter.next();\n                    if (attr.isDataAttribute()) return true;\n                }\n                return false;\n            }\n\n            public Entry<String, String> next() {\n                return new Attribute(attr.getKey().substring(dataPrefix.length()), attr.getValue());\n            }\n\n            public void remove() {\n                attributes.remove(attr.getKey());\n            }\n        }\n    }\n\n    private static String dataKey(String key) {\n        return dataPrefix + key;\n    }\n}\n",
      "fixed_full_code": "package org.jsoup.nodes;\n\nimport org.jsoup.SerializationException;\nimport org.jsoup.helper.Validate;\n\nimport java.io.IOException;\nimport java.util.AbstractMap;\nimport java.util.AbstractSet;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\n\npublic class Attributes implements Iterable<Attribute>, Cloneable { protected static final String dataPrefix = \"data-\"; private LinkedHashMap<String, Attribute> attributes = null; public String get(String key) {\n        Validate.notEmpty(key);\n\n        if (attributes == null)\n            return \"\";\n\n        Attribute attr = attributes.get(key);\n        return attr != null ? attr.getValue() : \"\";\n    }\n\n    \n    public String getIgnoreCase(String key) {\n        Validate.notEmpty(key);\n        if (attributes == null)\n            return \"\";\n\n        for (String attrKey : attributes.keySet()) {\n            if (attrKey.equalsIgnoreCase(key))\n                return attributes.get(attrKey).getValue();\n        }\n        return \"\";\n    }\n\n    \n    public void put(String key, String value) {\n        Attribute attr = new Attribute(key, value);\n        put(attr);\n    }\n\n    \n    public void put(String key, boolean value) {\n        if (value)\n            put(new BooleanAttribute(key));\n        else\n            remove(key);\n    }\n\n    \n    public void put(Attribute attribute) {\n        Validate.notNull(attribute);\n        if (attributes == null)\n             attributes = new LinkedHashMap<String, Attribute>(2);\n        attributes.put(attribute.getKey(), attribute);\n    }\n\n    \n    public void remove(String key) {\n        Validate.notEmpty(key);\n        if (attributes == null)\n            return;\n        attributes.remove(key);\n    }\n\n    \n    public void removeIgnoreCase(String key) {\n        Validate.notEmpty(key);\n        if (attributes == null)\n            return;\n        for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {\n            String attrKey = it.next();\n            if (attrKey.equalsIgnoreCase(key))\n                it.remove();\n        }\n    }\n\n    \n    public boolean hasKey(String key) {\n        return attributes != null && attributes.containsKey(key);\n    }\n\n    \n    public boolean hasKeyIgnoreCase(String key) {\n        if (attributes == null)\n            return false;\n        for (String attrKey : attributes.keySet()) {\n            if (attrKey.equalsIgnoreCase(key))\n                return true;\n        }\n        return false;\n    }\n\n    \n    public int size() {\n        if (attributes == null)\n            return 0;\n        return attributes.size();\n    }\n\n    \n    public void addAll(Attributes incoming) {\n        if (incoming.size() == 0)\n            return;\n        if (attributes == null)\n            attributes = new LinkedHashMap<String, Attribute>(incoming.size());\n        attributes.putAll(incoming.attributes);\n    }\n\n    public Iterator<Attribute> iterator() {\n        if (attributes == null || attributes.isEmpty()) {\n            return Collections.<Attribute>emptyList().iterator();\n        }\n\n        return attributes.values().iterator();\n    }\n\n    \n    public List<Attribute> asList() {\n        if (attributes == null)\n            return Collections.emptyList();\n\n        List<Attribute> list = new ArrayList<Attribute>(attributes.size());\n        for (Map.Entry<String, Attribute> entry : attributes.entrySet()) {\n            list.add(entry.getValue());\n        }\n        return Collections.unmodifiableList(list);\n    }\n\n    \n    public Map<String, String> dataset() {\n        return new Dataset();\n    }\n\n    \n    public String html() {\n        StringBuilder accum = new StringBuilder();\n        try {\n            html(accum, (new Document(\"\")).outputSettings()); \n        } catch (IOException e) { \n            throw new SerializationException(e);\n        }\n        return accum.toString();\n    }\n\n    void html(Appendable accum, Document.OutputSettings out) throws IOException {\n        if (attributes == null)\n            return;\n\n        for (Map.Entry<String, Attribute> entry : attributes.entrySet()) {\n            Attribute attribute = entry.getValue();\n            accum.append(\" \");\n            attribute.html(accum, out);\n        }\n    }\n\n    @Override\n    public String toString() {\n        return html();\n    }\n\n    \n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (!(o instanceof Attributes)) return false;\n\n        Attributes that = (Attributes) o;\n\n        return !(attributes != null ? !attributes.equals(that.attributes) : that.attributes != null);\n    }\n\n    \n    @Override\n    public int hashCode() {\n        return attributes != null ? attributes.hashCode() : 0;\n    }\n\n    @Override\n    public Attributes clone() {\n        if (attributes == null)\n            return new Attributes();\n\n        Attributes clone;\n        try {\n            clone = (Attributes) super.clone();\n        } catch (CloneNotSupportedException e) {\n            throw new RuntimeException(e);\n        }\n        clone.attributes = new LinkedHashMap<String, Attribute>(attributes.size());\n        for (Attribute attribute: this)\n            clone.attributes.put(attribute.getKey(), attribute.clone());\n        return clone;\n    }\n\n    private class Dataset extends AbstractMap<String, String> { private Dataset() {\n            if (attributes == null)\n                attributes = new LinkedHashMap<String, Attribute>(2);\n        }\n\n        @Override\n        public Set<Entry<String, String>> entrySet() {\n            return new EntrySet();\n        }\n\n        @Override\n        public String put(String key, String value) {\n            String dataKey = dataKey(key);\n            String oldValue = hasKey(dataKey) ? attributes.get(dataKey).getValue() : null;\n            Attribute attr = new Attribute(dataKey, value);\n            attributes.put(dataKey, attr);\n            return oldValue;\n        }\n\n        private class EntrySet extends AbstractSet<Map.Entry<String, String>> { @Override public Iterator<Map.Entry<String, String>> iterator() {\n                return new DatasetIterator();\n            }\n\n           @Override\n            public int size() {\n                int count = 0;\n                Iterator iter = new DatasetIterator();\n                while (iter.hasNext())\n                    count++;\n                return count;\n            }\n        }\n\n        private class DatasetIterator implements Iterator<Map.Entry<String, String>> { private Iterator<Attribute> attrIter = attributes.values().iterator(); private Attribute attr; public boolean hasNext() {\n                while (attrIter.hasNext()) {\n                    attr = attrIter.next();\n                    if (attr.isDataAttribute()) return true;\n                }\n                return false;\n            }\n\n            public Entry<String, String> next() {\n                return new Attribute(attr.getKey().substring(dataPrefix.length()), attr.getValue());\n            }\n\n            public void remove() {\n                attributes.remove(attr.getKey());\n            }\n        }\n    }\n\n    private static String dataKey(String key) {\n        return dataPrefix + key;\n    }\n}\n",
      "buggy_signatures": [
        "public String getIgnoreCase(String key)",
        "public void put(String key, String value)",
        "public void put(String key, boolean value)",
        "public void put(Attribute attribute)",
        "public void remove(String key)",
        "public void removeIgnoreCase(String key)",
        "public boolean hasKey(String key)",
        "public boolean hasKeyIgnoreCase(String key)",
        "public int size()",
        "public void addAll(Attributes incoming)",
        "public Iterator<Attribute> iterator()",
        "public List<Attribute> asList()",
        "public Map<String, String> dataset()",
        "public String html()",
        "public String toString()",
        "public boolean equals(Object o)",
        "public int hashCode()",
        "public Attributes clone()",
        "private class Dataset extends AbstractMap<String, String> { private Dataset()",
        "public Set<Entry<String, String>> entrySet()",
        "public String put(String key, String value)",
        "private class EntrySet extends AbstractSet<Map.Entry<String, String>> { @Override public Iterator<Map.Entry<String, String>> iterator()",
        "public int size()",
        "public Entry<String, String> next()",
        "public void remove()",
        "private static String dataKey(String key)"
      ],
      "fixed_signatures": [
        "public String getIgnoreCase(String key)",
        "public void put(String key, String value)",
        "public void put(String key, boolean value)",
        "public void put(Attribute attribute)",
        "public void remove(String key)",
        "public void removeIgnoreCase(String key)",
        "public boolean hasKey(String key)",
        "public boolean hasKeyIgnoreCase(String key)",
        "public int size()",
        "public void addAll(Attributes incoming)",
        "public Iterator<Attribute> iterator()",
        "public List<Attribute> asList()",
        "public Map<String, String> dataset()",
        "public String html()",
        "public String toString()",
        "public boolean equals(Object o)",
        "public int hashCode()",
        "public Attributes clone()",
        "private class Dataset extends AbstractMap<String, String> { private Dataset()",
        "public Set<Entry<String, String>> entrySet()",
        "public String put(String key, String value)",
        "private class EntrySet extends AbstractSet<Map.Entry<String, String>> { @Override public Iterator<Map.Entry<String, String>> iterator()",
        "public int size()",
        "public Entry<String, String> next()",
        "public void remove()",
        "private static String dataKey(String key)"
      ],
      "methods": [
        {
          "buggy_method": "  public void removeIgnoreCase(String key) {\n  Validate.notEmpty(key);\n  if (attributes == null)\n  return;\n  for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {\n  String attrKey = it.next();\n  if (attrKey.equalsIgnoreCase(key))\n  attributes.remove(attrKey);\n  }\n  }",
          "fixed_method": "  public void removeIgnoreCase(String key) {\n  Validate.notEmpty(key);\n  if (attributes == null)\n  return;\n  for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {\n  String attrKey = it.next();\n  if (attrKey.equalsIgnoreCase(key))\n  it.remove();\n  }\n  }",
          "diff": [
            "@@ -122,7 +122,7 @@",
            "         for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {\n",
            "             String attrKey = it.next();\n",
            "             if (attrKey.equalsIgnoreCase(key))\n",
            "-                attributes.remove(attrKey);\n",
            "+                it.remove();\n",
            "         }\n",
            "     }\n",
            " \n"
          ],
          "changed_lines": 2
        }
      ]
    }
  ]
}
