{
  "bug_id": "92",
  "failed_tests": {
    "org.jsoup.parser.HtmlParserTest": [
      {
        "methodName": "retainsAttributesOfDifferentCaseIfSensitive",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<<p One=\"[One\" one=\"Three\" two=\"Four]\" Two=\"Six\">Text</p>> but was:<<p One=\"[Two\" one=\"Three\" two=\"Five]\" Two=\"Six\">Text</p>>",
        "fail_line": "        assertEquals(\"<p One=\\\"One\\\" one=\\\"Three\\\" two=\\\"Four\\\" Two=\\\"Six\\\">Text</p>\", doc.selectFirst(\"p\").outerHtml());",
        "test_source": "",
        "stack": [
          "HtmlParserTest.retainsAttributesOfDifferentCaseIfSensitive line 74"
        ]
      },
      {
        "methodName": "dropsDuplicateAttributes",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<<p one=\"[One\" two=\"two]\">Text</p>> but was:<<p one=\"[Four\" one=\"Two\" two=\"two\" one=\"Three\" two=\"Five]\">Text</p>>",
        "fail_line": "        assertEquals(\"<p one=\\\"One\\\" two=\\\"two\\\">Text</p>\", p.outerHtml()); // normalized names due to lower casing",
        "test_source": "",
        "stack": [
          "HtmlParserTest.dropsDuplicateAttributes line 64"
        ]
      }
    ],
    "org.jsoup.parser.XmlTreeBuilderTest": [
      {
        "methodName": "dropsDuplicateAttributes",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<<p One=\"[One\" ONE=\"Two\" one=\"Three\" two=\"Six]\" Two=\"Eight\">Text</...> but was:<<p One=\"[Four\" ONE=\"Five\" one=\"Three\" two=\"Seven]\" Two=\"Eight\">Text</...>",
        "fail_line": "        assertEquals(\"<p One=\\\"One\\\" ONE=\\\"Two\\\" one=\\\"Three\\\" two=\\\"Six\\\" Two=\\\"Eight\\\">Text</p>\", doc.selectFirst(\"p\").outerHtml());",
        "test_source": "",
        "stack": [
          "XmlTreeBuilderTest.dropsDuplicateAttributes line 255"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/jsoup/nodes/Attributes.java",
      "buggy_full_code": "package org.jsoup.nodes;\n\nimport org.jsoup.SerializationException;\nimport org.jsoup.helper.Validate;\nimport org.jsoup.internal.StringUtil;\n\nimport java.io.IOException;\nimport java.util.AbstractMap;\nimport java.util.AbstractSet;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport static org.jsoup.internal.Normalizer.lowerCase; public class Attributes implements Iterable<Attribute>, Cloneable { protected static final String dataPrefix = \"data-\"; private static final int InitialCapacity = 4; private static final int GrowthFactor = 2; private static final String[] Empty = {}; static final int NotFound = -1; private static final String EmptyString = \"\"; private int size = 0; String[] keys = Empty; String[] vals = Empty; private void checkCapacity(int minNewSize) {\n        Validate.isTrue(minNewSize >= size);\n        int curSize = keys.length;\n        if (curSize >= minNewSize)\n            return;\n\n        int newSize = curSize >= InitialCapacity ? size * GrowthFactor : InitialCapacity;\n        if (minNewSize > newSize)\n            newSize = minNewSize;\n\n        keys = copyOf(keys, newSize);\n        vals = copyOf(vals, newSize);\n    }\n\n    \n    private static String[] copyOf(String[] orig, int size) {\n        final String[] copy = new String[size];\n        System.arraycopy(orig, 0, copy, 0,\n                Math.min(orig.length, size));\n        return copy;\n    }\n\n    int indexOfKey(String key) {\n        Validate.notNull(key);\n        for (int i = 0; i < size; i++) {\n            if (key.equals(keys[i]))\n                return i;\n        }\n        return NotFound;\n    }\n\n    private int indexOfKeyIgnoreCase(String key) {\n        Validate.notNull(key);\n        for (int i = 0; i < size; i++) {\n            if (key.equalsIgnoreCase(keys[i]))\n                return i;\n        }\n        return NotFound;\n    }\n\n    \n    static String checkNotNull(String val) {\n        return val == null ? EmptyString : val;\n    }\n\n    \n    public String get(String key) {\n        int i = indexOfKey(key);\n        return i == NotFound ? EmptyString : checkNotNull(vals[i]);\n    }\n\n    \n    public String getIgnoreCase(String key) {\n        int i = indexOfKeyIgnoreCase(key);\n        return i == NotFound ? EmptyString : checkNotNull(vals[i]);\n    }\n\n    \n    private void add(String key, String value) {\n        checkCapacity(size + 1);\n        keys[size] = key;\n        vals[size] = value;\n        size++;\n    }\n\n    \n    public Attributes put(String key, String value) {\n        int i = indexOfKey(key);\n        if (i != NotFound)\n            vals[i] = value;\n        else\n            add(key, value);\n        return this;\n    }\n\n    void putIgnoreCase(String key, String value) {\n        int i = indexOfKeyIgnoreCase(key);\n        if (i != NotFound) {\n            vals[i] = value;\n            if (!keys[i].equals(key)) \n                keys[i] = key;\n        }\n        else\n            add(key, value);\n    }\n\n    \n    public Attributes put(String key, boolean value) {\n        if (value)\n            putIgnoreCase(key, null);\n        else\n            remove(key);\n        return this;\n    }\n\n    \n    public Attributes put(Attribute attribute) {\n        Validate.notNull(attribute);\n        put(attribute.getKey(), attribute.getValue());\n        attribute.parent = this;\n        return this;\n    }\n\n    \n    private void remove(int index) {\n        Validate.isFalse(index >= size);\n        int shifted = size - index - 1;\n        if (shifted > 0) {\n            System.arraycopy(keys, index + 1, keys, index, shifted);\n            System.arraycopy(vals, index + 1, vals, index, shifted);\n        }\n        size--;\n        keys[size] = null; \n        vals[size] = null;\n    }\n\n    \n    public void remove(String key) {\n        int i = indexOfKey(key);\n        if (i != NotFound)\n            remove(i);\n    }\n\n    \n    public void removeIgnoreCase(String key) {\n        int i = indexOfKeyIgnoreCase(key);\n        if (i != NotFound)\n            remove(i);\n    }\n\n    \n    public boolean hasKey(String key) {\n        return indexOfKey(key) != NotFound;\n    }\n\n    \n    public boolean hasKeyIgnoreCase(String key) {\n        return indexOfKeyIgnoreCase(key) != NotFound;\n    }\n\n    \n    public int size() {\n        return size;\n    }\n\n    \n\n    \n    public void addAll(Attributes incoming) {\n        if (incoming.size() == 0)\n            return;\n        checkCapacity(size + incoming.size);\n\n        for (Attribute attr : incoming) {\n            \n            put(attr);\n        }\n\n    }\n\n    public Iterator<Attribute> iterator() {\n        return new Iterator<Attribute>() {\n            int i = 0;\n\n            @Override\n            public boolean hasNext() {\n                return i < size;\n            }\n\n            @Override\n            public Attribute next() {\n                final Attribute attr = new Attribute(keys[i], vals[i], Attributes.this);\n                i++;\n                return attr;\n            }\n\n            @Override\n            public void remove() {\n                Attributes.this.remove(--i); \n            }\n        };\n    }\n\n    \n    public List<Attribute> asList() {\n        ArrayList<Attribute> list = new ArrayList<>(size);\n        for (int i = 0; i < size; i++) {\n            Attribute attr = vals[i] == null ?\n                new BooleanAttribute(keys[i]) : \n                new Attribute(keys[i], vals[i], Attributes.this);\n            list.add(attr);\n        }\n        return Collections.unmodifiableList(list);\n    }\n\n    \n    public Map<String, String> dataset() {\n        return new Dataset(this);\n    }\n\n    \n    public String html() {\n        StringBuilder sb = StringUtil.borrowBuilder();\n        try {\n            html(sb, (new Document(\"\")).outputSettings()); \n        } catch (IOException e) { \n            throw new SerializationException(e);\n        }\n        return StringUtil.releaseBuilder(sb);\n    }\n\n    final void html(final Appendable accum, final Document.OutputSettings out) throws IOException {\n        final int sz = size;\n        for (int i = 0; i < sz; i++) {\n            \n            final String key = keys[i];\n            final String val = vals[i];\n            accum.append(' ').append(key);\n\n            \n            if (!Attribute.shouldCollapseAttribute(key, val, out)) {\n                accum.append(\"=\\\"\");\n                Entities.escape(accum, val == null ? EmptyString : val, out, true, false, false);\n                accum.append('\"');\n            }\n        }\n    }\n\n    @Override\n    public String toString() {\n        return html();\n    }\n\n    \n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        Attributes that = (Attributes) o;\n\n        if (size != that.size) return false;\n        if (!Arrays.equals(keys, that.keys)) return false;\n        return Arrays.equals(vals, that.vals);\n    }\n\n    \n    @Override\n    public int hashCode() {\n        int result = size;\n        result = 31 * result + Arrays.hashCode(keys);\n        result = 31 * result + Arrays.hashCode(vals);\n        return result;\n    }\n\n    @Override\n    public Attributes clone() {\n        Attributes clone;\n        try {\n            clone = (Attributes) super.clone();\n        } catch (CloneNotSupportedException e) {\n            throw new RuntimeException(e);\n        }\n        clone.size = size;\n        keys = copyOf(keys, size);\n        vals = copyOf(vals, size);\n        return clone;\n    }\n\n    \n    public void normalize() {\n        for (int i = 0; i < size; i++) {\n            keys[i] = lowerCase(keys[i]);\n        }\n    }\n\n    \n\n    private static class Dataset extends AbstractMap<String, String> { private final Attributes attributes; private Dataset(Attributes attributes) {\n            this.attributes = attributes;\n        }\n\n        @Override\n        public Set<Entry<String, String>> entrySet() {\n            return new EntrySet();\n        }\n\n        @Override\n        public String put(String key, String value) {\n            String dataKey = dataKey(key);\n            String oldValue = attributes.hasKey(dataKey) ? attributes.get(dataKey) : null;\n            attributes.put(dataKey, value);\n            return oldValue;\n        }\n\n        private class EntrySet extends AbstractSet<Map.Entry<String, String>> { @Override public Iterator<Map.Entry<String, String>> iterator() {\n                return new DatasetIterator();\n            }\n\n            @Override\n            public int size() {\n                int count = 0;\n                Iterator iter = new DatasetIterator();\n                while (iter.hasNext())\n                    count++;\n                return count;\n            }\n        }\n\n        private class DatasetIterator implements Iterator<Map.Entry<String, String>> { private Iterator<Attribute> attrIter = attributes.iterator(); private Attribute attr; public boolean hasNext() {\n                while (attrIter.hasNext()) {\n                    attr = attrIter.next();\n                    if (attr.isDataAttribute()) return true;\n                }\n                return false;\n            }\n\n            public Entry<String, String> next() {\n                return new Attribute(attr.getKey().substring(dataPrefix.length()), attr.getValue());\n            }\n\n            public void remove() {\n                attributes.remove(attr.getKey());\n            }\n        }\n    }\n\n    private static String dataKey(String key) {\n        return dataPrefix + key;\n    }\n}\n",
      "fixed_full_code": "package org.jsoup.nodes;\n\nimport org.jsoup.SerializationException;\nimport org.jsoup.helper.Validate;\nimport org.jsoup.internal.StringUtil;\nimport org.jsoup.parser.ParseSettings;\n\nimport java.io.IOException;\nimport java.util.AbstractMap;\nimport java.util.AbstractSet;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport static org.jsoup.internal.Normalizer.lowerCase; public class Attributes implements Iterable<Attribute>, Cloneable { protected static final String dataPrefix = \"data-\"; private static final int InitialCapacity = 4; private static final int GrowthFactor = 2; private static final String[] Empty = {}; static final int NotFound = -1; private static final String EmptyString = \"\"; private int size = 0; String[] keys = Empty; String[] vals = Empty; private void checkCapacity(int minNewSize) {\n        Validate.isTrue(minNewSize >= size);\n        int curSize = keys.length;\n        if (curSize >= minNewSize)\n            return;\n\n        int newSize = curSize >= InitialCapacity ? size * GrowthFactor : InitialCapacity;\n        if (minNewSize > newSize)\n            newSize = minNewSize;\n\n        keys = copyOf(keys, newSize);\n        vals = copyOf(vals, newSize);\n    }\n\n    \n    private static String[] copyOf(String[] orig, int size) {\n        final String[] copy = new String[size];\n        System.arraycopy(orig, 0, copy, 0,\n                Math.min(orig.length, size));\n        return copy;\n    }\n\n    int indexOfKey(String key) {\n        Validate.notNull(key);\n        for (int i = 0; i < size; i++) {\n            if (key.equals(keys[i]))\n                return i;\n        }\n        return NotFound;\n    }\n\n    private int indexOfKeyIgnoreCase(String key) {\n        Validate.notNull(key);\n        for (int i = 0; i < size; i++) {\n            if (key.equalsIgnoreCase(keys[i]))\n                return i;\n        }\n        return NotFound;\n    }\n\n    \n    static String checkNotNull(String val) {\n        return val == null ? EmptyString : val;\n    }\n\n    \n    public String get(String key) {\n        int i = indexOfKey(key);\n        return i == NotFound ? EmptyString : checkNotNull(vals[i]);\n    }\n\n    \n    public String getIgnoreCase(String key) {\n        int i = indexOfKeyIgnoreCase(key);\n        return i == NotFound ? EmptyString : checkNotNull(vals[i]);\n    }\n\n    \n    public Attributes add(String key, String value) {\n        checkCapacity(size + 1);\n        keys[size] = key;\n        vals[size] = value;\n        size++;\n        return this;\n    }\n\n    \n    public Attributes put(String key, String value) {\n        int i = indexOfKey(key);\n        if (i != NotFound)\n            vals[i] = value;\n        else\n            add(key, value);\n        return this;\n    }\n\n    void putIgnoreCase(String key, String value) {\n        int i = indexOfKeyIgnoreCase(key);\n        if (i != NotFound) {\n            vals[i] = value;\n            if (!keys[i].equals(key)) \n                keys[i] = key;\n        }\n        else\n            add(key, value);\n    }\n\n    \n    public Attributes put(String key, boolean value) {\n        if (value)\n            putIgnoreCase(key, null);\n        else\n            remove(key);\n        return this;\n    }\n\n    \n    public Attributes put(Attribute attribute) {\n        Validate.notNull(attribute);\n        put(attribute.getKey(), attribute.getValue());\n        attribute.parent = this;\n        return this;\n    }\n\n    \n    private void remove(int index) {\n        Validate.isFalse(index >= size);\n        int shifted = size - index - 1;\n        if (shifted > 0) {\n            System.arraycopy(keys, index + 1, keys, index, shifted);\n            System.arraycopy(vals, index + 1, vals, index, shifted);\n        }\n        size--;\n        keys[size] = null; \n        vals[size] = null;\n    }\n\n    \n    public void remove(String key) {\n        int i = indexOfKey(key);\n        if (i != NotFound)\n            remove(i);\n    }\n\n    \n    public void removeIgnoreCase(String key) {\n        int i = indexOfKeyIgnoreCase(key);\n        if (i != NotFound)\n            remove(i);\n    }\n\n    \n    public boolean hasKey(String key) {\n        return indexOfKey(key) != NotFound;\n    }\n\n    \n    public boolean hasKeyIgnoreCase(String key) {\n        return indexOfKeyIgnoreCase(key) != NotFound;\n    }\n\n    \n    public int size() {\n        return size;\n    }\n\n    \n    public boolean isEmpty() {\n        return size == 0;\n    }\n\n    \n    public void addAll(Attributes incoming) {\n        if (incoming.size() == 0)\n            return;\n        checkCapacity(size + incoming.size);\n\n        for (Attribute attr : incoming) {\n            \n            put(attr);\n        }\n\n    }\n\n    public Iterator<Attribute> iterator() {\n        return new Iterator<Attribute>() {\n            int i = 0;\n\n            @Override\n            public boolean hasNext() {\n                return i < size;\n            }\n\n            @Override\n            public Attribute next() {\n                final Attribute attr = new Attribute(keys[i], vals[i], Attributes.this);\n                i++;\n                return attr;\n            }\n\n            @Override\n            public void remove() {\n                Attributes.this.remove(--i); \n            }\n        };\n    }\n\n    \n    public List<Attribute> asList() {\n        ArrayList<Attribute> list = new ArrayList<>(size);\n        for (int i = 0; i < size; i++) {\n            Attribute attr = vals[i] == null ?\n                new BooleanAttribute(keys[i]) : \n                new Attribute(keys[i], vals[i], Attributes.this);\n            list.add(attr);\n        }\n        return Collections.unmodifiableList(list);\n    }\n\n    \n    public Map<String, String> dataset() {\n        return new Dataset(this);\n    }\n\n    \n    public String html() {\n        StringBuilder sb = StringUtil.borrowBuilder();\n        try {\n            html(sb, (new Document(\"\")).outputSettings()); \n        } catch (IOException e) { \n            throw new SerializationException(e);\n        }\n        return StringUtil.releaseBuilder(sb);\n    }\n\n    final void html(final Appendable accum, final Document.OutputSettings out) throws IOException {\n        final int sz = size;\n        for (int i = 0; i < sz; i++) {\n            \n            final String key = keys[i];\n            final String val = vals[i];\n            accum.append(' ').append(key);\n\n            \n            if (!Attribute.shouldCollapseAttribute(key, val, out)) {\n                accum.append(\"=\\\"\");\n                Entities.escape(accum, val == null ? EmptyString : val, out, true, false, false);\n                accum.append('\"');\n            }\n        }\n    }\n\n    @Override\n    public String toString() {\n        return html();\n    }\n\n    \n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        Attributes that = (Attributes) o;\n\n        if (size != that.size) return false;\n        if (!Arrays.equals(keys, that.keys)) return false;\n        return Arrays.equals(vals, that.vals);\n    }\n\n    \n    @Override\n    public int hashCode() {\n        int result = size;\n        result = 31 * result + Arrays.hashCode(keys);\n        result = 31 * result + Arrays.hashCode(vals);\n        return result;\n    }\n\n    @Override\n    public Attributes clone() {\n        Attributes clone;\n        try {\n            clone = (Attributes) super.clone();\n        } catch (CloneNotSupportedException e) {\n            throw new RuntimeException(e);\n        }\n        clone.size = size;\n        keys = copyOf(keys, size);\n        vals = copyOf(vals, size);\n        return clone;\n    }\n\n    \n    public void normalize() {\n        for (int i = 0; i < size; i++) {\n            keys[i] = lowerCase(keys[i]);\n        }\n    }\n\n    \n    public int deduplicate(ParseSettings settings) {\n        if (isEmpty())\n            return 0;\n        boolean preserve = settings.preserveAttributeCase();\n        int dupes = 0;\n        OUTER: for (int i = 0; i < keys.length; i++) {\n            for (int j = i + 1; j < keys.length; j++) {\n                if (keys[j] == null)\n                    continue OUTER; \n                if ((preserve && keys[i].equals(keys[j])) || (!preserve && keys[i].equalsIgnoreCase(keys[j]))) {\n                    dupes++;\n                    remove(j);\n                    j--;\n                }\n            }\n        }\n        return dupes;\n    }\n\n    private static class Dataset extends AbstractMap<String, String> { private final Attributes attributes; private Dataset(Attributes attributes) {\n            this.attributes = attributes;\n        }\n\n        @Override\n        public Set<Entry<String, String>> entrySet() {\n            return new EntrySet();\n        }\n\n        @Override\n        public String put(String key, String value) {\n            String dataKey = dataKey(key);\n            String oldValue = attributes.hasKey(dataKey) ? attributes.get(dataKey) : null;\n            attributes.put(dataKey, value);\n            return oldValue;\n        }\n\n        private class EntrySet extends AbstractSet<Map.Entry<String, String>> { @Override public Iterator<Map.Entry<String, String>> iterator() {\n                return new DatasetIterator();\n            }\n\n            @Override\n            public int size() {\n                int count = 0;\n                Iterator iter = new DatasetIterator();\n                while (iter.hasNext())\n                    count++;\n                return count;\n            }\n        }\n\n        private class DatasetIterator implements Iterator<Map.Entry<String, String>> { private Iterator<Attribute> attrIter = attributes.iterator(); private Attribute attr; public boolean hasNext() {\n                while (attrIter.hasNext()) {\n                    attr = attrIter.next();\n                    if (attr.isDataAttribute()) return true;\n                }\n                return false;\n            }\n\n            public Entry<String, String> next() {\n                return new Attribute(attr.getKey().substring(dataPrefix.length()), attr.getValue());\n            }\n\n            public void remove() {\n                attributes.remove(attr.getKey());\n            }\n        }\n    }\n\n    private static String dataKey(String key) {\n        return dataPrefix + key;\n    }\n}\n",
      "buggy_signatures": [
        "private static String[] copyOf(String[] orig, int size)",
        "private int indexOfKeyIgnoreCase(String key)",
        "static String checkNotNull(String val)",
        "public String get(String key)",
        "public String getIgnoreCase(String key)",
        "private void add(String key, String value)",
        "public Attributes put(String key, String value)",
        "public Attributes put(String key, boolean value)",
        "public Attributes put(Attribute attribute)",
        "private void remove(int index)",
        "public void remove(String key)",
        "public void removeIgnoreCase(String key)",
        "public boolean hasKey(String key)",
        "public boolean hasKeyIgnoreCase(String key)",
        "public int size()",
        "public void addAll(Attributes incoming)",
        "public Iterator<Attribute> iterator()",
        "public boolean hasNext()",
        "public Attribute next()",
        "public void remove()",
        "public List<Attribute> asList()",
        "public Map<String, String> dataset()",
        "public String html()",
        "public String toString()",
        "public boolean equals(Object o)",
        "public int hashCode()",
        "public Attributes clone()",
        "public void normalize()",
        "private static class Dataset extends AbstractMap<String, String> { private final Attributes attributes; private Dataset(Attributes attributes)",
        "public Set<Entry<String, String>> entrySet()",
        "public String put(String key, String value)",
        "private class EntrySet extends AbstractSet<Map.Entry<String, String>> { @Override public Iterator<Map.Entry<String, String>> iterator()",
        "public int size()",
        "public Entry<String, String> next()",
        "public void remove()",
        "private static String dataKey(String key)"
      ],
      "fixed_signatures": [
        "private static String[] copyOf(String[] orig, int size)",
        "private int indexOfKeyIgnoreCase(String key)",
        "static String checkNotNull(String val)",
        "public String get(String key)",
        "public String getIgnoreCase(String key)",
        "public Attributes add(String key, String value)",
        "public Attributes put(String key, String value)",
        "public Attributes put(String key, boolean value)",
        "public Attributes put(Attribute attribute)",
        "private void remove(int index)",
        "public void remove(String key)",
        "public void removeIgnoreCase(String key)",
        "public boolean hasKey(String key)",
        "public boolean hasKeyIgnoreCase(String key)",
        "public int size()",
        "public boolean isEmpty()",
        "public void addAll(Attributes incoming)",
        "public Iterator<Attribute> iterator()",
        "public boolean hasNext()",
        "public Attribute next()",
        "public void remove()",
        "public List<Attribute> asList()",
        "public Map<String, String> dataset()",
        "public String html()",
        "public String toString()",
        "public boolean equals(Object o)",
        "public int hashCode()",
        "public Attributes clone()",
        "public void normalize()",
        "public int deduplicate(ParseSettings settings)",
        "private static class Dataset extends AbstractMap<String, String> { private final Attributes attributes; private Dataset(Attributes attributes)",
        "public Set<Entry<String, String>> entrySet()",
        "public String put(String key, String value)",
        "private class EntrySet extends AbstractSet<Map.Entry<String, String>> { @Override public Iterator<Map.Entry<String, String>> iterator()",
        "public int size()",
        "public Entry<String, String> next()",
        "public void remove()",
        "private static String dataKey(String key)"
      ],
      "methods": [
        {
          "buggy_method": "",
          "fixed_method": "",
          "diff": [
            "@@ -3,6 +3,7 @@",
            " import org.jsoup.SerializationException;\n",
            " import org.jsoup.helper.Validate;\n",
            " import org.jsoup.internal.StringUtil;\n",
            "+import org.jsoup.parser.ParseSettings;\n",
            " \n",
            " import java.io.IOException;\n",
            " import java.util.AbstractMap;\n"
          ],
          "changed_lines": 1
        },
        {
          "buggy_method": "  private void add(String key, String value) {\n  checkCapacity(size + 1);\n  keys[size] = key;\n  vals[size] = value;\n  size++;\n  }",
          "fixed_method": "  public Attributes add(String key, String value) {\n  checkCapacity(size + 1);\n  keys[size] = key;\n  vals[size] = value;\n  size++;\n  return this;\n  }",
          "diff": [
            "@@ -115,11 +116,12 @@",
            "      * Adds a new attribute. Will produce duplicates if the key already exists.\n",
            "      * @see Attributes#put(String, String)\n",
            "      */\n",
            "-    private void add(String key, String value) {\n",
            "+    public Attributes add(String key, String value) {\n",
            "         checkCapacity(size + 1);\n",
            "         keys[size] = key;\n",
            "         vals[size] = value;\n",
            "         size++;\n",
            "+        return this;\n",
            "     }\n",
            " \n",
            "     /**\n"
          ],
          "changed_lines": 3
        },
        {
          "buggy_method": "  public int size() {\n  return size;\n  }",
          "fixed_method": "  public boolean isEmpty() {\n  return size == 0;\n  }",
          "diff": [
            "@@ -236,6 +238,9 @@",
            "     /**\n",
            "      * Test if this Attributes list is empty (size==0).\n",
            "      */\n",
            "+    public boolean isEmpty() {\n",
            "+        return size == 0;\n",
            "+    }\n",
            " \n",
            "     /**\n",
            "      Add all the attributes from the incoming set to this set.\n"
          ],
          "changed_lines": 3
        },
        {
          "buggy_method": "  public void normalize() {\n  for (int i = 0; i < size; i++) {\n  keys[i] = lowerCase(keys[i]);\n  }\n  }",
          "fixed_method": "  public int deduplicate(ParseSettings settings) {\n  if (isEmpty())\n  return 0;\n  boolean preserve = settings.preserveAttributeCase();\n  int dupes = 0;\n  OUTER: for (int i = 0; i < keys.length; i++) {\n  for (int j = i + 1; j < keys.length; j++) {\n  if (keys[j] == null)\n  continue OUTER; \n  if ((preserve && keys[i].equals(keys[j])) || (!preserve && keys[i].equalsIgnoreCase(keys[j]))) {\n  dupes++;\n  remove(j);\n  j--;\n  }\n  }\n  }\n  return dupes;\n  }",
          "diff": [
            "@@ -394,6 +399,24 @@",
            "      * @param settings case sensitivity\n",
            "      * @return number of removed dupes\n",
            "      */\n",
            "+    public int deduplicate(ParseSettings settings) {\n",
            "+        if (isEmpty())\n",
            "+            return 0;\n",
            "+        boolean preserve = settings.preserveAttributeCase();\n",
            "+        int dupes = 0;\n",
            "+        OUTER: for (int i = 0; i < keys.length; i++) {\n",
            "+            for (int j = i + 1; j < keys.length; j++) {\n",
            "+                if (keys[j] == null)\n",
            "+                    continue OUTER; // keys.length doesn't shrink when removing, so re-test\n",
            "+                if ((preserve && keys[i].equals(keys[j])) || (!preserve && keys[i].equalsIgnoreCase(keys[j]))) {\n",
            "+                    dupes++;\n",
            "+                    remove(j);\n",
            "+                    j--;\n",
            "+                }\n",
            "+            }\n",
            "+        }\n",
            "+        return dupes;\n",
            "+    }\n",
            " \n",
            "     private static class Dataset extends AbstractMap<String, String> {\n",
            "         private final Attributes attributes;\n"
          ],
          "changed_lines": 18
        }
      ]
    },
    {
      "name": "org/jsoup/parser/HtmlTreeBuilder.java",
      "buggy_full_code": "package org.jsoup.parser;\n\nimport org.jsoup.helper.Validate;\nimport org.jsoup.internal.StringUtil;\nimport org.jsoup.nodes.CDataNode;\nimport org.jsoup.nodes.Comment;\nimport org.jsoup.nodes.DataNode;\nimport org.jsoup.nodes.Document;\nimport org.jsoup.nodes.Element;\nimport org.jsoup.nodes.FormElement;\nimport org.jsoup.nodes.Node;\nimport org.jsoup.nodes.TextNode;\nimport org.jsoup.select.Elements;\n\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static org.jsoup.internal.StringUtil.inSorted; public class HtmlTreeBuilder extends TreeBuilder { static final String[] TagsSearchInScope = new String[]{\"applet\", \"caption\", \"html\", \"marquee\", \"object\", \"table\", \"td\", \"th\"}; static final String[] TagSearchList = new String[]{\"ol\", \"ul\"}; static final String[] TagSearchButton = new String[]{\"button\"}; static final String[] TagSearchTableScope = new String[]{\"html\", \"table\"}; static final String[] TagSearchSelectScope = new String[]{\"optgroup\", \"option\"}; static final String[] TagSearchEndTags = new String[]{\"dd\", \"dt\", \"li\", \"optgroup\", \"option\", \"p\", \"rp\", \"rt\"}; static final String[] TagSearchSpecial = new String[]{\"address\", \"applet\", \"area\", \"article\", \"aside\", \"base\", \"basefont\", \"bgsound\", \"blockquote\", \"body\", \"br\", \"button\", \"caption\", \"center\", \"col\", \"colgroup\", \"command\", \"dd\", \"details\", \"dir\", \"div\", \"dl\", \"dt\", \"embed\", \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"form\", \"frame\", \"frameset\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"head\", \"header\", \"hgroup\", \"hr\", \"html\", \"iframe\", \"img\", \"input\", \"isindex\", \"li\", \"link\", \"listing\", \"marquee\", \"menu\", \"meta\", \"nav\", \"noembed\", \"noframes\", \"noscript\", \"object\", \"ol\", \"p\", \"param\", \"plaintext\", \"pre\", \"script\", \"section\", \"select\", \"style\", \"summary\", \"table\", \"tbody\", \"td\", \"textarea\", \"tfoot\", \"th\", \"thead\", \"title\", \"tr\", \"ul\", \"wbr\", \"xmp\"}; public static final int MaxScopeSearchDepth = 100; private HtmlTreeBuilderState state; private HtmlTreeBuilderState originalState; private boolean baseUriSetFromDoc; private Element headElement; private FormElement formElement; private Element contextElement; private ArrayList<Element> formattingElements; private List<String> pendingTableCharacters; private Token.EndTag emptyEnd; private boolean framesetOk; private boolean fosterInserts; private boolean fragmentParsing; ParseSettings defaultSettings() {\n        return ParseSettings.htmlDefault;\n    }\n\n    @Override\n    protected void initialiseParse(Reader input, String baseUri, Parser parser) {\n        super.initialiseParse(input, baseUri, parser);\n\n        \n        state = HtmlTreeBuilderState.Initial;\n        originalState = null;\n        baseUriSetFromDoc = false;\n        headElement = null;\n        formElement = null;\n        contextElement = null;\n        formattingElements = new ArrayList<>();\n        pendingTableCharacters = new ArrayList<>();\n        emptyEnd = new Token.EndTag();\n        framesetOk = true;\n        fosterInserts = false;\n        fragmentParsing = false;\n    }\n\n    List<Node> parseFragment(String inputFragment, Element context, String baseUri, Parser parser) {\n        \n        state = HtmlTreeBuilderState.Initial;\n        initialiseParse(new StringReader(inputFragment), baseUri, parser);\n        contextElement = context;\n        fragmentParsing = true;\n        Element root = null;\n\n        if (context != null) {\n            if (context.ownerDocument() != null) \n                doc.quirksMode(context.ownerDocument().quirksMode());\n\n            \n            String contextTag = context.tagName();\n            if (StringUtil.in(contextTag, \"title\", \"textarea\"))\n                tokeniser.transition(TokeniserState.Rcdata);\n            else if (StringUtil.in(contextTag, \"iframe\", \"noembed\", \"noframes\", \"style\", \"xmp\"))\n                tokeniser.transition(TokeniserState.Rawtext);\n            else if (contextTag.equals(\"script\"))\n                tokeniser.transition(TokeniserState.ScriptData);\n            else if (contextTag.equals((\"noscript\")))\n                tokeniser.transition(TokeniserState.Data); \n            else if (contextTag.equals(\"plaintext\"))\n                tokeniser.transition(TokeniserState.Data);\n            else\n                tokeniser.transition(TokeniserState.Data); \n\n            root = new Element(Tag.valueOf(\"html\", settings), baseUri);\n            doc.appendChild(root);\n            stack.add(root);\n            resetInsertionMode();\n\n            \n            \n            Elements contextChain = context.parents();\n            contextChain.add(0, context);\n            for (Element parent: contextChain) {\n                if (parent instanceof FormElement) {\n                    formElement = (FormElement) parent;\n                    break;\n                }\n            }\n        }\n\n        runParser();\n        if (context != null)\n            return root.childNodes();\n        else\n            return doc.childNodes();\n    }\n\n    @Override\n    protected boolean process(Token token) {\n        currentToken = token;\n        return this.state.process(token, this);\n    }\n\n    boolean process(Token token, HtmlTreeBuilderState state) {\n        currentToken = token;\n        return state.process(token, this);\n    }\n\n    void transition(HtmlTreeBuilderState state) {\n        this.state = state;\n    }\n\n    HtmlTreeBuilderState state() {\n        return state;\n    }\n\n    void markInsertionMode() {\n        originalState = state;\n    }\n\n    HtmlTreeBuilderState originalState() {\n        return originalState;\n    }\n\n    void framesetOk(boolean framesetOk) {\n        this.framesetOk = framesetOk;\n    }\n\n    boolean framesetOk() {\n        return framesetOk;\n    }\n\n    Document getDocument() {\n        return doc;\n    }\n\n    String getBaseUri() {\n        return baseUri;\n    }\n\n    void maybeSetBaseUri(Element base) {\n        if (baseUriSetFromDoc) \n            return;\n\n        String href = base.absUrl(\"href\");\n        if (href.length() != 0) { \n            baseUri = href;\n            baseUriSetFromDoc = true;\n            doc.setBaseUri(href); \n        }\n    }\n\n    boolean isFragmentParsing() {\n        return fragmentParsing;\n    }\n\n    void error(HtmlTreeBuilderState state) {\n        if (parser.getErrors().canAddError())\n            parser.getErrors().add(new ParseError(reader.pos(), \"Unexpected token [%s] when in state [%s]\", currentToken.tokenType(), state));\n    }\n\n    Element insert(final Token.StartTag startTag) {\n        \n\n        \n        \n        if (startTag.isSelfClosing()) {\n            Element el = insertEmpty(startTag);\n            stack.add(el);\n            tokeniser.transition(TokeniserState.Data); \n            tokeniser.emit(emptyEnd.reset().name(el.tagName()));  \n            return el;\n        }\n\n        Element el = new Element(Tag.valueOf(startTag.name(), settings), baseUri, settings.normalizeAttributes(startTag.attributes));\n        insert(el);\n        return el;\n    }\n\n    Element insertStartTag(String startTagName) {\n        Element el = new Element(Tag.valueOf(startTagName, settings), baseUri);\n        insert(el);\n        return el;\n    }\n\n    void insert(Element el) {\n        insertNode(el);\n        stack.add(el);\n    }\n\n    Element insertEmpty(Token.StartTag startTag) {\n        Tag tag = Tag.valueOf(startTag.name(), settings);\n        Element el = new Element(tag, baseUri, startTag.attributes);\n        insertNode(el);\n        if (startTag.isSelfClosing()) {\n            if (tag.isKnownTag()) {\n                if (!tag.isEmpty())\n                    tokeniser.error(\"Tag cannot be self closing; not a void tag\");\n            }\n            else \n                tag.setSelfClosing();\n        }\n        return el;\n    }\n\n    FormElement insertForm(Token.StartTag startTag, boolean onStack) {\n        Tag tag = Tag.valueOf(startTag.name(), settings);\n        FormElement el = new FormElement(tag, baseUri, startTag.attributes);\n        setFormElement(el);\n        insertNode(el);\n        if (onStack)\n            stack.add(el);\n        return el;\n    }\n\n    void insert(Token.Comment commentToken) {\n        Comment comment = new Comment(commentToken.getData());\n        insertNode(comment);\n    }\n\n    void insert(Token.Character characterToken) {\n        final Node node;\n        final Element el = currentElement();\n        final String tagName = el.tagName();\n        final String data = characterToken.getData();\n\n        if (characterToken.isCData())\n            node = new CDataNode(data);\n        else if (tagName.equals(\"script\") || tagName.equals(\"style\"))\n            node = new DataNode(data);\n        else\n            node = new TextNode(data);\n        el.appendChild(node); \n    }\n\n    private void insertNode(Node node) {\n        \n        if (stack.isEmpty())\n            doc.appendChild(node);\n        else if (isFosterInserts())\n            insertInFosterParent(node);\n        else\n            currentElement().appendChild(node);\n\n        \n        if (node instanceof Element && ((Element) node).tag().isFormListed()) {\n            if (formElement != null)\n                formElement.addElement((Element) node);\n        }\n    }\n\n    Element pop() {\n        int size = stack.size();\n        return stack.remove(size-1);\n    }\n\n    void push(Element element) {\n        stack.add(element);\n    }\n\n    ArrayList<Element> getStack() {\n        return stack;\n    }\n\n    boolean onStack(Element el) {\n        return isElementInQueue(stack, el);\n    }\n\n    private boolean isElementInQueue(ArrayList<Element> queue, Element element) {\n        for (int pos = queue.size() -1; pos >= 0; pos--) {\n            Element next = queue.get(pos);\n            if (next == element) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    Element getFromStack(String elName) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next.normalName().equals(elName)) {\n                return next;\n            }\n        }\n        return null;\n    }\n\n    boolean removeFromStack(Element el) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next == el) {\n                stack.remove(pos);\n                return true;\n            }\n        }\n        return false;\n    }\n\n    void popStackToClose(String elName) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            stack.remove(pos);\n            if (next.normalName().equals(elName))\n                break;\n        }\n    }\n\n    \n    void popStackToClose(String... elNames) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            stack.remove(pos);\n            if (inSorted(next.normalName(), elNames))\n                break;\n        }\n    }\n\n    void popStackToBefore(String elName) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next.normalName().equals(elName)) {\n                break;\n            } else {\n                stack.remove(pos);\n            }\n        }\n    }\n\n    void clearStackToTableContext() {\n        clearStackToContext(\"table\");\n    }\n\n    void clearStackToTableBodyContext() {\n        clearStackToContext(\"tbody\", \"tfoot\", \"thead\", \"template\");\n    }\n\n    void clearStackToTableRowContext() {\n        clearStackToContext(\"tr\", \"template\");\n    }\n\n    private void clearStackToContext(String... nodeNames) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (StringUtil.in(next.normalName(), nodeNames) || next.normalName().equals(\"html\"))\n                break;\n            else\n                stack.remove(pos);\n        }\n    }\n\n    Element aboveOnStack(Element el) {\n        assert onStack(el);\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next == el) {\n                return stack.get(pos-1);\n            }\n        }\n        return null;\n    }\n\n    void insertOnStackAfter(Element after, Element in) {\n        int i = stack.lastIndexOf(after);\n        Validate.isTrue(i != -1);\n        stack.add(i+1, in);\n    }\n\n    void replaceOnStack(Element out, Element in) {\n        replaceInQueue(stack, out, in);\n    }\n\n    private void replaceInQueue(ArrayList<Element> queue, Element out, Element in) {\n        int i = queue.lastIndexOf(out);\n        Validate.isTrue(i != -1);\n        queue.set(i, in);\n    }\n\n    void resetInsertionMode() {\n        boolean last = false;\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element node = stack.get(pos);\n            if (pos == 0) {\n                last = true;\n                node = contextElement;\n            }\n            String name = node.normalName();\n            if (\"select\".equals(name)) {\n                transition(HtmlTreeBuilderState.InSelect);\n                break; \n            } else if ((\"td\".equals(name) || \"th\".equals(name) && !last)) {\n                transition(HtmlTreeBuilderState.InCell);\n                break;\n            } else if (\"tr\".equals(name)) {\n                transition(HtmlTreeBuilderState.InRow);\n                break;\n            } else if (\"tbody\".equals(name) || \"thead\".equals(name) || \"tfoot\".equals(name)) {\n                transition(HtmlTreeBuilderState.InTableBody);\n                break;\n            } else if (\"caption\".equals(name)) {\n                transition(HtmlTreeBuilderState.InCaption);\n                break;\n            } else if (\"colgroup\".equals(name)) {\n                transition(HtmlTreeBuilderState.InColumnGroup);\n                break; \n            } else if (\"table\".equals(name)) {\n                transition(HtmlTreeBuilderState.InTable);\n                break;\n            } else if (\"head\".equals(name)) {\n                transition(HtmlTreeBuilderState.InBody);\n                break; \n            } else if (\"body\".equals(name)) {\n                transition(HtmlTreeBuilderState.InBody);\n                break;\n            } else if (\"frameset\".equals(name)) {\n                transition(HtmlTreeBuilderState.InFrameset);\n                break; \n            } else if (\"html\".equals(name)) {\n                transition(HtmlTreeBuilderState.BeforeHead);\n                break; \n            } else if (last) {\n                transition(HtmlTreeBuilderState.InBody);\n                break; \n            }\n        }\n    }\n\n    \n    private String[] specificScopeTarget = {null}; private boolean inSpecificScope(String targetName, String[] baseTypes, String[] extraTypes) {\n        specificScopeTarget[0] = targetName;\n        return inSpecificScope(specificScopeTarget, baseTypes, extraTypes);\n    }\n\n    private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {\n        \n        final int bottom = stack.size() -1;\n        final int top = bottom > MaxScopeSearchDepth ? bottom - MaxScopeSearchDepth : 0;\n        \n\n        for (int pos = bottom; pos >= top; pos--) {\n            final String elName = stack.get(pos).normalName();\n            if (inSorted(elName, targetNames))\n                return true;\n            if (inSorted(elName, baseTypes))\n                return false;\n            if (extraTypes != null && inSorted(elName, extraTypes))\n                return false;\n        }\n        \n        return false;\n    }\n\n    boolean inScope(String[] targetNames) {\n        return inSpecificScope(targetNames, TagsSearchInScope, null);\n    }\n\n    boolean inScope(String targetName) {\n        return inScope(targetName, null);\n    }\n\n    boolean inScope(String targetName, String[] extras) {\n        return inSpecificScope(targetName, TagsSearchInScope, extras);\n        \n        \n    }\n\n    boolean inListItemScope(String targetName) {\n        return inScope(targetName, TagSearchList);\n    }\n\n    boolean inButtonScope(String targetName) {\n        return inScope(targetName, TagSearchButton);\n    }\n\n    boolean inTableScope(String targetName) {\n        return inSpecificScope(targetName, TagSearchTableScope, null);\n    }\n\n    boolean inSelectScope(String targetName) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element el = stack.get(pos);\n            String elName = el.normalName();\n            if (elName.equals(targetName))\n                return true;\n            if (!inSorted(elName, TagSearchSelectScope)) \n                return false;\n        }\n        Validate.fail(\"Should not be reachable\");\n        return false;\n    }\n\n    void setHeadElement(Element headElement) {\n        this.headElement = headElement;\n    }\n\n    Element getHeadElement() {\n        return headElement;\n    }\n\n    boolean isFosterInserts() {\n        return fosterInserts;\n    }\n\n    void setFosterInserts(boolean fosterInserts) {\n        this.fosterInserts = fosterInserts;\n    }\n\n    FormElement getFormElement() {\n        return formElement;\n    }\n\n    void setFormElement(FormElement formElement) {\n        this.formElement = formElement;\n    }\n\n    void newPendingTableCharacters() {\n        pendingTableCharacters = new ArrayList<>();\n    }\n\n    List<String> getPendingTableCharacters() {\n        return pendingTableCharacters;\n    }\n\n    \n    void generateImpliedEndTags(String excludeTag) {\n        while ((excludeTag != null && !currentElement().normalName().equals(excludeTag)) &&\n                inSorted(currentElement().normalName(), TagSearchEndTags))\n            pop();\n    }\n\n    void generateImpliedEndTags() {\n        generateImpliedEndTags(null);\n    }\n\n    boolean isSpecial(Element el) {\n        \n        \n        String name = el.normalName();\n        return inSorted(name, TagSearchSpecial);\n    }\n\n    Element lastFormattingElement() {\n        return formattingElements.size() > 0 ? formattingElements.get(formattingElements.size()-1) : null;\n    }\n\n    Element removeLastFormattingElement() {\n        int size = formattingElements.size();\n        if (size > 0)\n            return formattingElements.remove(size-1);\n        else\n            return null;\n    }\n\n    \n    void pushActiveFormattingElements(Element in) {\n        int numSeen = 0;\n        for (int pos = formattingElements.size() -1; pos >= 0; pos--) {\n            Element el = formattingElements.get(pos);\n            if (el == null) \n                break;\n\n            if (isSameFormattingElement(in, el))\n                numSeen++;\n\n            if (numSeen == 3) {\n                formattingElements.remove(pos);\n                break;\n            }\n        }\n        formattingElements.add(in);\n    }\n\n    private boolean isSameFormattingElement(Element a, Element b) {\n        \n        return a.normalName().equals(b.normalName()) &&\n                \n                a.attributes().equals(b.attributes());\n        \n    }\n\n    void reconstructFormattingElements() {\n        Element last = lastFormattingElement();\n        if (last == null || onStack(last))\n            return;\n\n        Element entry = last;\n        int size = formattingElements.size();\n        int pos = size - 1;\n        boolean skip = false;\n        while (true) {\n            if (pos == 0) { \n                skip = true;\n                break;\n            }\n            entry = formattingElements.get(--pos); \n            if (entry == null || onStack(entry)) \n                break; \n        }\n        while(true) {\n            if (!skip) \n                entry = formattingElements.get(++pos);\n            Validate.notNull(entry); \n\n            \n            skip = false; \n            Element newEl = insertStartTag(entry.normalName()); \n            \n            newEl.attributes().addAll(entry.attributes());\n\n            \n            formattingElements.set(pos, newEl);\n\n            \n            if (pos == size-1) \n                break;\n        }\n    }\n\n    void clearFormattingElementsToLastMarker() {\n        while (!formattingElements.isEmpty()) {\n            Element el = removeLastFormattingElement();\n            if (el == null)\n                break;\n        }\n    }\n\n    void removeFromActiveFormattingElements(Element el) {\n        for (int pos = formattingElements.size() -1; pos >= 0; pos--) {\n            Element next = formattingElements.get(pos);\n            if (next == el) {\n                formattingElements.remove(pos);\n                break;\n            }\n        }\n    }\n\n    boolean isInActiveFormattingElements(Element el) {\n        return isElementInQueue(formattingElements, el);\n    }\n\n    Element getActiveFormattingElement(String nodeName) {\n        for (int pos = formattingElements.size() -1; pos >= 0; pos--) {\n            Element next = formattingElements.get(pos);\n            if (next == null) \n                break;\n            else if (next.normalName().equals(nodeName))\n                return next;\n        }\n        return null;\n    }\n\n    void replaceActiveFormattingElement(Element out, Element in) {\n        replaceInQueue(formattingElements, out, in);\n    }\n\n    void insertMarkerToFormattingElements() {\n        formattingElements.add(null);\n    }\n\n    void insertInFosterParent(Node in) {\n        Element fosterParent;\n        Element lastTable = getFromStack(\"table\");\n        boolean isLastTableParent = false;\n        if (lastTable != null) {\n            if (lastTable.parent() != null) {\n                fosterParent = lastTable.parent();\n                isLastTableParent = true;\n            } else\n                fosterParent = aboveOnStack(lastTable);\n        } else { \n            fosterParent = stack.get(0);\n        }\n\n        if (isLastTableParent) {\n            Validate.notNull(lastTable); \n            lastTable.before(in);\n        }\n        else\n            fosterParent.appendChild(in);\n    }\n\n    @Override\n    public String toString() {\n        return \"TreeBuilder{\" +\n                \"currentToken=\" + currentToken +\n                \", state=\" + state +\n                \", currentElement=\" + currentElement() +\n                '}';\n    }\n}\n",
      "fixed_full_code": "package org.jsoup.parser;\n\nimport org.jsoup.helper.Validate;\nimport org.jsoup.internal.StringUtil;\nimport org.jsoup.nodes.CDataNode;\nimport org.jsoup.nodes.Comment;\nimport org.jsoup.nodes.DataNode;\nimport org.jsoup.nodes.Document;\nimport org.jsoup.nodes.Element;\nimport org.jsoup.nodes.FormElement;\nimport org.jsoup.nodes.Node;\nimport org.jsoup.nodes.TextNode;\nimport org.jsoup.select.Elements;\n\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static org.jsoup.internal.StringUtil.inSorted; public class HtmlTreeBuilder extends TreeBuilder { static final String[] TagsSearchInScope = new String[]{\"applet\", \"caption\", \"html\", \"marquee\", \"object\", \"table\", \"td\", \"th\"}; static final String[] TagSearchList = new String[]{\"ol\", \"ul\"}; static final String[] TagSearchButton = new String[]{\"button\"}; static final String[] TagSearchTableScope = new String[]{\"html\", \"table\"}; static final String[] TagSearchSelectScope = new String[]{\"optgroup\", \"option\"}; static final String[] TagSearchEndTags = new String[]{\"dd\", \"dt\", \"li\", \"optgroup\", \"option\", \"p\", \"rp\", \"rt\"}; static final String[] TagSearchSpecial = new String[]{\"address\", \"applet\", \"area\", \"article\", \"aside\", \"base\", \"basefont\", \"bgsound\", \"blockquote\", \"body\", \"br\", \"button\", \"caption\", \"center\", \"col\", \"colgroup\", \"command\", \"dd\", \"details\", \"dir\", \"div\", \"dl\", \"dt\", \"embed\", \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"form\", \"frame\", \"frameset\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"head\", \"header\", \"hgroup\", \"hr\", \"html\", \"iframe\", \"img\", \"input\", \"isindex\", \"li\", \"link\", \"listing\", \"marquee\", \"menu\", \"meta\", \"nav\", \"noembed\", \"noframes\", \"noscript\", \"object\", \"ol\", \"p\", \"param\", \"plaintext\", \"pre\", \"script\", \"section\", \"select\", \"style\", \"summary\", \"table\", \"tbody\", \"td\", \"textarea\", \"tfoot\", \"th\", \"thead\", \"title\", \"tr\", \"ul\", \"wbr\", \"xmp\"}; public static final int MaxScopeSearchDepth = 100; private HtmlTreeBuilderState state; private HtmlTreeBuilderState originalState; private boolean baseUriSetFromDoc; private Element headElement; private FormElement formElement; private Element contextElement; private ArrayList<Element> formattingElements; private List<String> pendingTableCharacters; private Token.EndTag emptyEnd; private boolean framesetOk; private boolean fosterInserts; private boolean fragmentParsing; ParseSettings defaultSettings() {\n        return ParseSettings.htmlDefault;\n    }\n\n    @Override\n    protected void initialiseParse(Reader input, String baseUri, Parser parser) {\n        super.initialiseParse(input, baseUri, parser);\n\n        \n        state = HtmlTreeBuilderState.Initial;\n        originalState = null;\n        baseUriSetFromDoc = false;\n        headElement = null;\n        formElement = null;\n        contextElement = null;\n        formattingElements = new ArrayList<>();\n        pendingTableCharacters = new ArrayList<>();\n        emptyEnd = new Token.EndTag();\n        framesetOk = true;\n        fosterInserts = false;\n        fragmentParsing = false;\n    }\n\n    List<Node> parseFragment(String inputFragment, Element context, String baseUri, Parser parser) {\n        \n        state = HtmlTreeBuilderState.Initial;\n        initialiseParse(new StringReader(inputFragment), baseUri, parser);\n        contextElement = context;\n        fragmentParsing = true;\n        Element root = null;\n\n        if (context != null) {\n            if (context.ownerDocument() != null) \n                doc.quirksMode(context.ownerDocument().quirksMode());\n\n            \n            String contextTag = context.tagName();\n            if (StringUtil.in(contextTag, \"title\", \"textarea\"))\n                tokeniser.transition(TokeniserState.Rcdata);\n            else if (StringUtil.in(contextTag, \"iframe\", \"noembed\", \"noframes\", \"style\", \"xmp\"))\n                tokeniser.transition(TokeniserState.Rawtext);\n            else if (contextTag.equals(\"script\"))\n                tokeniser.transition(TokeniserState.ScriptData);\n            else if (contextTag.equals((\"noscript\")))\n                tokeniser.transition(TokeniserState.Data); \n            else if (contextTag.equals(\"plaintext\"))\n                tokeniser.transition(TokeniserState.Data);\n            else\n                tokeniser.transition(TokeniserState.Data); \n\n            root = new Element(Tag.valueOf(\"html\", settings), baseUri);\n            doc.appendChild(root);\n            stack.add(root);\n            resetInsertionMode();\n\n            \n            \n            Elements contextChain = context.parents();\n            contextChain.add(0, context);\n            for (Element parent: contextChain) {\n                if (parent instanceof FormElement) {\n                    formElement = (FormElement) parent;\n                    break;\n                }\n            }\n        }\n\n        runParser();\n        if (context != null)\n            return root.childNodes();\n        else\n            return doc.childNodes();\n    }\n\n    @Override\n    protected boolean process(Token token) {\n        currentToken = token;\n        return this.state.process(token, this);\n    }\n\n    boolean process(Token token, HtmlTreeBuilderState state) {\n        currentToken = token;\n        return state.process(token, this);\n    }\n\n    void transition(HtmlTreeBuilderState state) {\n        this.state = state;\n    }\n\n    HtmlTreeBuilderState state() {\n        return state;\n    }\n\n    void markInsertionMode() {\n        originalState = state;\n    }\n\n    HtmlTreeBuilderState originalState() {\n        return originalState;\n    }\n\n    void framesetOk(boolean framesetOk) {\n        this.framesetOk = framesetOk;\n    }\n\n    boolean framesetOk() {\n        return framesetOk;\n    }\n\n    Document getDocument() {\n        return doc;\n    }\n\n    String getBaseUri() {\n        return baseUri;\n    }\n\n    void maybeSetBaseUri(Element base) {\n        if (baseUriSetFromDoc) \n            return;\n\n        String href = base.absUrl(\"href\");\n        if (href.length() != 0) { \n            baseUri = href;\n            baseUriSetFromDoc = true;\n            doc.setBaseUri(href); \n        }\n    }\n\n    boolean isFragmentParsing() {\n        return fragmentParsing;\n    }\n\n    void error(HtmlTreeBuilderState state) {\n        if (parser.getErrors().canAddError())\n            parser.getErrors().add(new ParseError(reader.pos(), \"Unexpected token [%s] when in state [%s]\", currentToken.tokenType(), state));\n    }\n\n    Element insert(final Token.StartTag startTag) {\n        \n        if (!startTag.attributes.isEmpty()) {\n            int dupes = startTag.attributes.deduplicate(settings);\n            if (dupes > 0) {\n                error(\"Duplicate attribute\");\n            }\n        }\n\n        \n        \n        if (startTag.isSelfClosing()) {\n            Element el = insertEmpty(startTag);\n            stack.add(el);\n            tokeniser.transition(TokeniserState.Data); \n            tokeniser.emit(emptyEnd.reset().name(el.tagName()));  \n            return el;\n        }\n\n        Element el = new Element(Tag.valueOf(startTag.name(), settings), baseUri, settings.normalizeAttributes(startTag.attributes));\n        insert(el);\n        return el;\n    }\n\n    Element insertStartTag(String startTagName) {\n        Element el = new Element(Tag.valueOf(startTagName, settings), baseUri);\n        insert(el);\n        return el;\n    }\n\n    void insert(Element el) {\n        insertNode(el);\n        stack.add(el);\n    }\n\n    Element insertEmpty(Token.StartTag startTag) {\n        Tag tag = Tag.valueOf(startTag.name(), settings);\n        Element el = new Element(tag, baseUri, startTag.attributes);\n        insertNode(el);\n        if (startTag.isSelfClosing()) {\n            if (tag.isKnownTag()) {\n                if (!tag.isEmpty())\n                    tokeniser.error(\"Tag cannot be self closing; not a void tag\");\n            }\n            else \n                tag.setSelfClosing();\n        }\n        return el;\n    }\n\n    FormElement insertForm(Token.StartTag startTag, boolean onStack) {\n        Tag tag = Tag.valueOf(startTag.name(), settings);\n        FormElement el = new FormElement(tag, baseUri, startTag.attributes);\n        setFormElement(el);\n        insertNode(el);\n        if (onStack)\n            stack.add(el);\n        return el;\n    }\n\n    void insert(Token.Comment commentToken) {\n        Comment comment = new Comment(commentToken.getData());\n        insertNode(comment);\n    }\n\n    void insert(Token.Character characterToken) {\n        final Node node;\n        final Element el = currentElement();\n        final String tagName = el.tagName();\n        final String data = characterToken.getData();\n\n        if (characterToken.isCData())\n            node = new CDataNode(data);\n        else if (tagName.equals(\"script\") || tagName.equals(\"style\"))\n            node = new DataNode(data);\n        else\n            node = new TextNode(data);\n        el.appendChild(node); \n    }\n\n    private void insertNode(Node node) {\n        \n        if (stack.isEmpty())\n            doc.appendChild(node);\n        else if (isFosterInserts())\n            insertInFosterParent(node);\n        else\n            currentElement().appendChild(node);\n\n        \n        if (node instanceof Element && ((Element) node).tag().isFormListed()) {\n            if (formElement != null)\n                formElement.addElement((Element) node);\n        }\n    }\n\n    Element pop() {\n        int size = stack.size();\n        return stack.remove(size-1);\n    }\n\n    void push(Element element) {\n        stack.add(element);\n    }\n\n    ArrayList<Element> getStack() {\n        return stack;\n    }\n\n    boolean onStack(Element el) {\n        return isElementInQueue(stack, el);\n    }\n\n    private boolean isElementInQueue(ArrayList<Element> queue, Element element) {\n        for (int pos = queue.size() -1; pos >= 0; pos--) {\n            Element next = queue.get(pos);\n            if (next == element) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    Element getFromStack(String elName) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next.normalName().equals(elName)) {\n                return next;\n            }\n        }\n        return null;\n    }\n\n    boolean removeFromStack(Element el) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next == el) {\n                stack.remove(pos);\n                return true;\n            }\n        }\n        return false;\n    }\n\n    void popStackToClose(String elName) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            stack.remove(pos);\n            if (next.normalName().equals(elName))\n                break;\n        }\n    }\n\n    \n    void popStackToClose(String... elNames) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            stack.remove(pos);\n            if (inSorted(next.normalName(), elNames))\n                break;\n        }\n    }\n\n    void popStackToBefore(String elName) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next.normalName().equals(elName)) {\n                break;\n            } else {\n                stack.remove(pos);\n            }\n        }\n    }\n\n    void clearStackToTableContext() {\n        clearStackToContext(\"table\");\n    }\n\n    void clearStackToTableBodyContext() {\n        clearStackToContext(\"tbody\", \"tfoot\", \"thead\", \"template\");\n    }\n\n    void clearStackToTableRowContext() {\n        clearStackToContext(\"tr\", \"template\");\n    }\n\n    private void clearStackToContext(String... nodeNames) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (StringUtil.in(next.normalName(), nodeNames) || next.normalName().equals(\"html\"))\n                break;\n            else\n                stack.remove(pos);\n        }\n    }\n\n    Element aboveOnStack(Element el) {\n        assert onStack(el);\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next == el) {\n                return stack.get(pos-1);\n            }\n        }\n        return null;\n    }\n\n    void insertOnStackAfter(Element after, Element in) {\n        int i = stack.lastIndexOf(after);\n        Validate.isTrue(i != -1);\n        stack.add(i+1, in);\n    }\n\n    void replaceOnStack(Element out, Element in) {\n        replaceInQueue(stack, out, in);\n    }\n\n    private void replaceInQueue(ArrayList<Element> queue, Element out, Element in) {\n        int i = queue.lastIndexOf(out);\n        Validate.isTrue(i != -1);\n        queue.set(i, in);\n    }\n\n    void resetInsertionMode() {\n        boolean last = false;\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element node = stack.get(pos);\n            if (pos == 0) {\n                last = true;\n                node = contextElement;\n            }\n            String name = node.normalName();\n            if (\"select\".equals(name)) {\n                transition(HtmlTreeBuilderState.InSelect);\n                break; \n            } else if ((\"td\".equals(name) || \"th\".equals(name) && !last)) {\n                transition(HtmlTreeBuilderState.InCell);\n                break;\n            } else if (\"tr\".equals(name)) {\n                transition(HtmlTreeBuilderState.InRow);\n                break;\n            } else if (\"tbody\".equals(name) || \"thead\".equals(name) || \"tfoot\".equals(name)) {\n                transition(HtmlTreeBuilderState.InTableBody);\n                break;\n            } else if (\"caption\".equals(name)) {\n                transition(HtmlTreeBuilderState.InCaption);\n                break;\n            } else if (\"colgroup\".equals(name)) {\n                transition(HtmlTreeBuilderState.InColumnGroup);\n                break; \n            } else if (\"table\".equals(name)) {\n                transition(HtmlTreeBuilderState.InTable);\n                break;\n            } else if (\"head\".equals(name)) {\n                transition(HtmlTreeBuilderState.InBody);\n                break; \n            } else if (\"body\".equals(name)) {\n                transition(HtmlTreeBuilderState.InBody);\n                break;\n            } else if (\"frameset\".equals(name)) {\n                transition(HtmlTreeBuilderState.InFrameset);\n                break; \n            } else if (\"html\".equals(name)) {\n                transition(HtmlTreeBuilderState.BeforeHead);\n                break; \n            } else if (last) {\n                transition(HtmlTreeBuilderState.InBody);\n                break; \n            }\n        }\n    }\n\n    \n    private String[] specificScopeTarget = {null}; private boolean inSpecificScope(String targetName, String[] baseTypes, String[] extraTypes) {\n        specificScopeTarget[0] = targetName;\n        return inSpecificScope(specificScopeTarget, baseTypes, extraTypes);\n    }\n\n    private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {\n        \n        final int bottom = stack.size() -1;\n        final int top = bottom > MaxScopeSearchDepth ? bottom - MaxScopeSearchDepth : 0;\n        \n\n        for (int pos = bottom; pos >= top; pos--) {\n            final String elName = stack.get(pos).normalName();\n            if (inSorted(elName, targetNames))\n                return true;\n            if (inSorted(elName, baseTypes))\n                return false;\n            if (extraTypes != null && inSorted(elName, extraTypes))\n                return false;\n        }\n        \n        return false;\n    }\n\n    boolean inScope(String[] targetNames) {\n        return inSpecificScope(targetNames, TagsSearchInScope, null);\n    }\n\n    boolean inScope(String targetName) {\n        return inScope(targetName, null);\n    }\n\n    boolean inScope(String targetName, String[] extras) {\n        return inSpecificScope(targetName, TagsSearchInScope, extras);\n        \n        \n    }\n\n    boolean inListItemScope(String targetName) {\n        return inScope(targetName, TagSearchList);\n    }\n\n    boolean inButtonScope(String targetName) {\n        return inScope(targetName, TagSearchButton);\n    }\n\n    boolean inTableScope(String targetName) {\n        return inSpecificScope(targetName, TagSearchTableScope, null);\n    }\n\n    boolean inSelectScope(String targetName) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element el = stack.get(pos);\n            String elName = el.normalName();\n            if (elName.equals(targetName))\n                return true;\n            if (!inSorted(elName, TagSearchSelectScope)) \n                return false;\n        }\n        Validate.fail(\"Should not be reachable\");\n        return false;\n    }\n\n    void setHeadElement(Element headElement) {\n        this.headElement = headElement;\n    }\n\n    Element getHeadElement() {\n        return headElement;\n    }\n\n    boolean isFosterInserts() {\n        return fosterInserts;\n    }\n\n    void setFosterInserts(boolean fosterInserts) {\n        this.fosterInserts = fosterInserts;\n    }\n\n    FormElement getFormElement() {\n        return formElement;\n    }\n\n    void setFormElement(FormElement formElement) {\n        this.formElement = formElement;\n    }\n\n    void newPendingTableCharacters() {\n        pendingTableCharacters = new ArrayList<>();\n    }\n\n    List<String> getPendingTableCharacters() {\n        return pendingTableCharacters;\n    }\n\n    \n    void generateImpliedEndTags(String excludeTag) {\n        while ((excludeTag != null && !currentElement().normalName().equals(excludeTag)) &&\n                inSorted(currentElement().normalName(), TagSearchEndTags))\n            pop();\n    }\n\n    void generateImpliedEndTags() {\n        generateImpliedEndTags(null);\n    }\n\n    boolean isSpecial(Element el) {\n        \n        \n        String name = el.normalName();\n        return inSorted(name, TagSearchSpecial);\n    }\n\n    Element lastFormattingElement() {\n        return formattingElements.size() > 0 ? formattingElements.get(formattingElements.size()-1) : null;\n    }\n\n    Element removeLastFormattingElement() {\n        int size = formattingElements.size();\n        if (size > 0)\n            return formattingElements.remove(size-1);\n        else\n            return null;\n    }\n\n    \n    void pushActiveFormattingElements(Element in) {\n        int numSeen = 0;\n        for (int pos = formattingElements.size() -1; pos >= 0; pos--) {\n            Element el = formattingElements.get(pos);\n            if (el == null) \n                break;\n\n            if (isSameFormattingElement(in, el))\n                numSeen++;\n\n            if (numSeen == 3) {\n                formattingElements.remove(pos);\n                break;\n            }\n        }\n        formattingElements.add(in);\n    }\n\n    private boolean isSameFormattingElement(Element a, Element b) {\n        \n        return a.normalName().equals(b.normalName()) &&\n                \n                a.attributes().equals(b.attributes());\n        \n    }\n\n    void reconstructFormattingElements() {\n        Element last = lastFormattingElement();\n        if (last == null || onStack(last))\n            return;\n\n        Element entry = last;\n        int size = formattingElements.size();\n        int pos = size - 1;\n        boolean skip = false;\n        while (true) {\n            if (pos == 0) { \n                skip = true;\n                break;\n            }\n            entry = formattingElements.get(--pos); \n            if (entry == null || onStack(entry)) \n                break; \n        }\n        while(true) {\n            if (!skip) \n                entry = formattingElements.get(++pos);\n            Validate.notNull(entry); \n\n            \n            skip = false; \n            Element newEl = insertStartTag(entry.normalName()); \n            \n            newEl.attributes().addAll(entry.attributes());\n\n            \n            formattingElements.set(pos, newEl);\n\n            \n            if (pos == size-1) \n                break;\n        }\n    }\n\n    void clearFormattingElementsToLastMarker() {\n        while (!formattingElements.isEmpty()) {\n            Element el = removeLastFormattingElement();\n            if (el == null)\n                break;\n        }\n    }\n\n    void removeFromActiveFormattingElements(Element el) {\n        for (int pos = formattingElements.size() -1; pos >= 0; pos--) {\n            Element next = formattingElements.get(pos);\n            if (next == el) {\n                formattingElements.remove(pos);\n                break;\n            }\n        }\n    }\n\n    boolean isInActiveFormattingElements(Element el) {\n        return isElementInQueue(formattingElements, el);\n    }\n\n    Element getActiveFormattingElement(String nodeName) {\n        for (int pos = formattingElements.size() -1; pos >= 0; pos--) {\n            Element next = formattingElements.get(pos);\n            if (next == null) \n                break;\n            else if (next.normalName().equals(nodeName))\n                return next;\n        }\n        return null;\n    }\n\n    void replaceActiveFormattingElement(Element out, Element in) {\n        replaceInQueue(formattingElements, out, in);\n    }\n\n    void insertMarkerToFormattingElements() {\n        formattingElements.add(null);\n    }\n\n    void insertInFosterParent(Node in) {\n        Element fosterParent;\n        Element lastTable = getFromStack(\"table\");\n        boolean isLastTableParent = false;\n        if (lastTable != null) {\n            if (lastTable.parent() != null) {\n                fosterParent = lastTable.parent();\n                isLastTableParent = true;\n            } else\n                fosterParent = aboveOnStack(lastTable);\n        } else { \n            fosterParent = stack.get(0);\n        }\n\n        if (isLastTableParent) {\n            Validate.notNull(lastTable); \n            lastTable.before(in);\n        }\n        else\n            fosterParent.appendChild(in);\n    }\n\n    @Override\n    public String toString() {\n        return \"TreeBuilder{\" +\n                \"currentToken=\" + currentToken +\n                \", state=\" + state +\n                \", currentElement=\" + currentElement() +\n                '}';\n    }\n}\n",
      "buggy_signatures": [
        "protected void initialiseParse(Reader input, String baseUri, Parser parser)",
        "protected boolean process(Token token)",
        "private void insertNode(Node node)",
        "private boolean isElementInQueue(ArrayList<Element> queue, Element element)",
        "private void clearStackToContext(String... nodeNames)",
        "private void replaceInQueue(ArrayList<Element> queue, Element out, Element in)",
        "private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes)",
        "private boolean isSameFormattingElement(Element a, Element b)",
        "public String toString()"
      ],
      "fixed_signatures": [
        "protected void initialiseParse(Reader input, String baseUri, Parser parser)",
        "protected boolean process(Token token)",
        "private void insertNode(Node node)",
        "private boolean isElementInQueue(ArrayList<Element> queue, Element element)",
        "private void clearStackToContext(String... nodeNames)",
        "private void replaceInQueue(ArrayList<Element> queue, Element out, Element in)",
        "private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes)",
        "private boolean isSameFormattingElement(Element a, Element b)",
        "public String toString()"
      ],
      "methods": [
        {
          "buggy_method": "  protected boolean process(Token token) {\n  currentToken = token;\n  return this.state.process(token, this);\n  }",
          "fixed_method": "  protected boolean process(Token token) {\n  currentToken = token;\n  return this.state.process(token, this);\n  }",
          "diff": [
            "@@ -196,6 +196,12 @@",
            " \n",
            "     Element insert(final Token.StartTag startTag) {\n",
            "         // cleanup duplicate attributes:\n",
            "+        if (!startTag.attributes.isEmpty()) {\n",
            "+            int dupes = startTag.attributes.deduplicate(settings);\n",
            "+            if (dupes > 0) {\n",
            "+                error(\"Duplicate attribute\");\n",
            "+            }\n",
            "+        }\n",
            " \n",
            "         // handle empty unknown tags\n",
            "         // when the spec expects an empty tag, will directly hit insertEmpty, so won't generate this fake end tag.\n"
          ],
          "changed_lines": 6
        }
      ]
    },
    {
      "name": "org/jsoup/parser/ParseSettings.java",
      "buggy_full_code": "package org.jsoup.parser;\n\nimport org.jsoup.nodes.Attributes;\n\nimport static org.jsoup.internal.Normalizer.lowerCase; public class ParseSettings { public static final ParseSettings htmlDefault; public static final ParseSettings preserveCase; static { htmlDefault = new ParseSettings(false, false); preserveCase = new ParseSettings(true, true); } private final boolean preserveTagCase; private final boolean preserveAttributeCase; public boolean preserveTagCase() {\n        return preserveTagCase;\n    }\n\n    \n\n    \n    public ParseSettings(boolean tag, boolean attribute) {\n        preserveTagCase = tag;\n        preserveAttributeCase = attribute;\n    }\n\n    \n    public String normalizeTag(String name) {\n        name = name.trim();\n        if (!preserveTagCase)\n            name = lowerCase(name);\n        return name;\n    }\n\n    \n    public String normalizeAttribute(String name) {\n        name = name.trim();\n        if (!preserveAttributeCase)\n            name = lowerCase(name);\n        return name;\n    }\n\n    Attributes normalizeAttributes(Attributes attributes) {\n        if (!preserveAttributeCase) {\n            attributes.normalize();\n        }\n        return attributes;\n    }\n}\n",
      "fixed_full_code": "package org.jsoup.parser;\n\nimport org.jsoup.nodes.Attributes;\n\nimport static org.jsoup.internal.Normalizer.lowerCase; public class ParseSettings { public static final ParseSettings htmlDefault; public static final ParseSettings preserveCase; static { htmlDefault = new ParseSettings(false, false); preserveCase = new ParseSettings(true, true); } private final boolean preserveTagCase; private final boolean preserveAttributeCase; public boolean preserveTagCase() {\n        return preserveTagCase;\n    }\n\n    \n    public boolean preserveAttributeCase() {\n        return preserveAttributeCase;\n    }\n\n    \n    public ParseSettings(boolean tag, boolean attribute) {\n        preserveTagCase = tag;\n        preserveAttributeCase = attribute;\n    }\n\n    \n    public String normalizeTag(String name) {\n        name = name.trim();\n        if (!preserveTagCase)\n            name = lowerCase(name);\n        return name;\n    }\n\n    \n    public String normalizeAttribute(String name) {\n        name = name.trim();\n        if (!preserveAttributeCase)\n            name = lowerCase(name);\n        return name;\n    }\n\n    Attributes normalizeAttributes(Attributes attributes) {\n        if (!preserveAttributeCase) {\n            attributes.normalize();\n        }\n        return attributes;\n    }\n}\n",
      "buggy_signatures": [
        "public ParseSettings(boolean tag, boolean attribute)",
        "public String normalizeTag(String name)",
        "public String normalizeAttribute(String name)"
      ],
      "fixed_signatures": [
        "public boolean preserveAttributeCase()",
        "public ParseSettings(boolean tag, boolean attribute)",
        "public String normalizeTag(String name)",
        "public String normalizeAttribute(String name)"
      ],
      "methods": [
        {
          "buggy_method": "  public boolean preserveTagCase() {\n  return preserveTagCase;\n  }",
          "fixed_method": "  public boolean preserveAttributeCase() {\n  return preserveAttributeCase;\n  }",
          "diff": [
            "@@ -35,6 +35,9 @@",
            "     /**\n",
            "      * Returns true if preserving attribute case.\n",
            "      */\n",
            "+    public boolean preserveAttributeCase() {\n",
            "+        return preserveAttributeCase;\n",
            "+    }\n",
            " \n",
            "     /**\n",
            "      * Define parse settings.\n"
          ],
          "changed_lines": 3
        }
      ]
    },
    {
      "name": "org/jsoup/parser/Token.java",
      "buggy_full_code": "package org.jsoup.parser;\n\nimport org.jsoup.helper.Validate;\nimport org.jsoup.nodes.Attributes;\n\nimport static org.jsoup.internal.Normalizer.lowerCase; abstract class Token { TokenType type; private Token() {\n    }\n    \n    String tokenType() {\n        return this.getClass().getSimpleName();\n    }\n\n    \n    abstract Token reset(); static void reset(StringBuilder sb) {\n        if (sb != null) {\n            sb.delete(0, sb.length());\n        }\n    }\n\n    static final class Doctype extends Token { final StringBuilder name = new StringBuilder(); String pubSysKey = null; final StringBuilder publicIdentifier = new StringBuilder(); final StringBuilder systemIdentifier = new StringBuilder(); boolean forceQuirks = false; Doctype() {\n            type = TokenType.Doctype;\n        }\n\n        @Override\n        Token reset() {\n            reset(name);\n            pubSysKey = null;\n            reset(publicIdentifier);\n            reset(systemIdentifier);\n            forceQuirks = false;\n            return this;\n        }\n\n        String getName() {\n            return name.toString();\n        }\n\n        String getPubSysKey() {\n            return pubSysKey;\n        }\n\n        String getPublicIdentifier() {\n            return publicIdentifier.toString();\n        }\n\n        public String getSystemIdentifier() {\n            return systemIdentifier.toString();\n        }\n\n        public boolean isForceQuirks() {\n            return forceQuirks;\n        }\n    }\n\n    static abstract class Tag extends Token { protected String tagName; protected String normalName; private String pendingAttributeName; private StringBuilder pendingAttributeValue = new StringBuilder(); private String pendingAttributeValueS; private boolean hasEmptyAttributeValue = false; private boolean hasPendingAttributeValue = false; boolean selfClosing = false; Attributes attributes; @Override Tag reset() {\n            tagName = null;\n            normalName = null;\n            pendingAttributeName = null;\n            reset(pendingAttributeValue);\n            pendingAttributeValueS = null;\n            hasEmptyAttributeValue = false;\n            hasPendingAttributeValue = false;\n            selfClosing = false;\n            attributes = null;\n            return this;\n        }\n\n        final void newAttribute() {\n            if (attributes == null)\n                attributes = new Attributes();\n\n            if (pendingAttributeName != null) {\n                \n                pendingAttributeName = pendingAttributeName.trim();\n                if (pendingAttributeName.length() > 0) {\n                    String value;\n                    if (hasPendingAttributeValue)\n                        value = pendingAttributeValue.length() > 0 ? pendingAttributeValue.toString() : pendingAttributeValueS;\n                    else if (hasEmptyAttributeValue)\n                        value = \"\";\n                    else\n                        value = null;\n                    \n                    attributes.put(pendingAttributeName, value);\n                }\n            }\n            pendingAttributeName = null;\n            hasEmptyAttributeValue = false;\n            hasPendingAttributeValue = false;\n            reset(pendingAttributeValue);\n            pendingAttributeValueS = null;\n        }\n\n        final void finaliseTag() {\n            \n            if (pendingAttributeName != null) {\n                newAttribute();\n            }\n        }\n\n        \n        final String name() { \n            Validate.isFalse(tagName == null || tagName.length() == 0);\n            return tagName;\n        }\n\n        \n        final String normalName() { \n            return normalName;\n        }\n\n        final Tag name(String name) {\n            tagName = name;\n            normalName = lowerCase(name);\n            return this;\n        }\n\n        final boolean isSelfClosing() {\n            return selfClosing;\n        }\n\n        @SuppressWarnings({\"TypeMayBeWeakened\"})\n        final Attributes getAttributes() {\n            return attributes;\n        }\n\n        \n        final void appendTagName(String append) {\n            tagName = tagName == null ? append : tagName.concat(append);\n            normalName = lowerCase(tagName);\n        }\n\n        final void appendTagName(char append) {\n            appendTagName(String.valueOf(append));\n        }\n\n        final void appendAttributeName(String append) {\n            pendingAttributeName = pendingAttributeName == null ? append : pendingAttributeName.concat(append);\n        }\n\n        final void appendAttributeName(char append) {\n            appendAttributeName(String.valueOf(append));\n        }\n\n        final void appendAttributeValue(String append) {\n            ensureAttributeValue();\n            if (pendingAttributeValue.length() == 0) {\n                pendingAttributeValueS = append;\n            } else {\n                pendingAttributeValue.append(append);\n            }\n        }\n\n        final void appendAttributeValue(char append) {\n            ensureAttributeValue();\n            pendingAttributeValue.append(append);\n        }\n\n        final void appendAttributeValue(char[] append) {\n            ensureAttributeValue();\n            pendingAttributeValue.append(append);\n        }\n\n        final void appendAttributeValue(int[] appendCodepoints) {\n            ensureAttributeValue();\n            for (int codepoint : appendCodepoints) {\n                pendingAttributeValue.appendCodePoint(codepoint);\n            }\n        }\n        \n        final void setEmptyAttributeValue() {\n            hasEmptyAttributeValue = true;\n        }\n\n        private void ensureAttributeValue() {\n            hasPendingAttributeValue = true;\n            \n            if (pendingAttributeValueS != null) {\n                pendingAttributeValue.append(pendingAttributeValueS);\n                pendingAttributeValueS = null;\n            }\n        }\n    }\n\n    final static class StartTag extends Tag { StartTag() {\n            super();\n            attributes = new Attributes();\n            type = TokenType.StartTag;\n        }\n\n        @Override\n        Tag reset() {\n            super.reset();\n            attributes = new Attributes();\n            \n            return this;\n        }\n\n        StartTag nameAttr(String name, Attributes attributes) {\n            this.tagName = name;\n            this.attributes = attributes;\n            normalName = lowerCase(tagName);\n            return this;\n        }\n\n        @Override\n        public String toString() {\n            if (attributes != null && attributes.size() > 0)\n                return \"<\" + name() + \" \" + attributes.toString() + \">\";\n            else\n                return \"<\" + name() + \">\";\n        }\n    }\n\n    final static class EndTag extends Tag{ EndTag() {\n            super();\n            type = TokenType.EndTag;\n        }\n\n        @Override\n        public String toString() {\n            return \"</\" + name() + \">\";\n        }\n    }\n\n    final static class Comment extends Token { final StringBuilder data = new StringBuilder(); boolean bogus = false; @Override Token reset() {\n            reset(data);\n            bogus = false;\n            return this;\n        }\n\n        Comment() {\n            type = TokenType.Comment;\n        }\n\n        String getData() {\n            return data.toString();\n        }\n\n        @Override\n        public String toString() {\n            return \"<!--\" + getData() + \"-->\";\n        }\n    }\n\n    static class Character extends Token { private String data; Character() {\n            super();\n            type = TokenType.Character;\n        }\n\n        @Override\n        Token reset() {\n            data = null;\n            return this;\n        }\n\n        Character data(String data) {\n            this.data = data;\n            return this;\n        }\n\n        String getData() {\n            return data;\n        }\n\n        @Override\n        public String toString() {\n            return getData();\n        }\n    }\n\n    final static class CData extends Character { CData(String data) {\n            super();\n            this.data(data);\n        }\n\n        @Override\n        public String toString() {\n            return \"<![CDATA[\" + getData() + \"]]>\";\n        }\n\n    }\n\n    final static class EOF extends Token { EOF() {\n            type = Token.TokenType.EOF;\n        }\n\n        @Override\n        Token reset() {\n            return this;\n        }\n    }\n\n    final boolean isDoctype() {\n        return type == TokenType.Doctype;\n    }\n\n    final Doctype asDoctype() {\n        return (Doctype) this;\n    }\n\n    final boolean isStartTag() {\n        return type == TokenType.StartTag;\n    }\n\n    final StartTag asStartTag() {\n        return (StartTag) this;\n    }\n\n    final boolean isEndTag() {\n        return type == TokenType.EndTag;\n    }\n\n    final EndTag asEndTag() {\n        return (EndTag) this;\n    }\n\n    final boolean isComment() {\n        return type == TokenType.Comment;\n    }\n\n    final Comment asComment() {\n        return (Comment) this;\n    }\n\n    final boolean isCharacter() {\n        return type == TokenType.Character;\n    }\n\n    final boolean isCData() {\n        return this instanceof CData;\n    }\n\n    final Character asCharacter() {\n        return (Character) this;\n    }\n\n    final boolean isEOF() {\n        return type == TokenType.EOF;\n    }\n\n    public enum TokenType {\n        Doctype,\n        StartTag,\n        EndTag,\n        Comment,\n        Character, \n        EOF\n    }\n}\n",
      "fixed_full_code": "package org.jsoup.parser;\n\nimport org.jsoup.helper.Validate;\nimport org.jsoup.nodes.Attributes;\n\nimport static org.jsoup.internal.Normalizer.lowerCase; abstract class Token { TokenType type; private Token() {\n    }\n    \n    String tokenType() {\n        return this.getClass().getSimpleName();\n    }\n\n    \n    abstract Token reset(); static void reset(StringBuilder sb) {\n        if (sb != null) {\n            sb.delete(0, sb.length());\n        }\n    }\n\n    static final class Doctype extends Token { final StringBuilder name = new StringBuilder(); String pubSysKey = null; final StringBuilder publicIdentifier = new StringBuilder(); final StringBuilder systemIdentifier = new StringBuilder(); boolean forceQuirks = false; Doctype() {\n            type = TokenType.Doctype;\n        }\n\n        @Override\n        Token reset() {\n            reset(name);\n            pubSysKey = null;\n            reset(publicIdentifier);\n            reset(systemIdentifier);\n            forceQuirks = false;\n            return this;\n        }\n\n        String getName() {\n            return name.toString();\n        }\n\n        String getPubSysKey() {\n            return pubSysKey;\n        }\n\n        String getPublicIdentifier() {\n            return publicIdentifier.toString();\n        }\n\n        public String getSystemIdentifier() {\n            return systemIdentifier.toString();\n        }\n\n        public boolean isForceQuirks() {\n            return forceQuirks;\n        }\n    }\n\n    static abstract class Tag extends Token { protected String tagName; protected String normalName; private String pendingAttributeName; private StringBuilder pendingAttributeValue = new StringBuilder(); private String pendingAttributeValueS; private boolean hasEmptyAttributeValue = false; private boolean hasPendingAttributeValue = false; boolean selfClosing = false; Attributes attributes; @Override Tag reset() {\n            tagName = null;\n            normalName = null;\n            pendingAttributeName = null;\n            reset(pendingAttributeValue);\n            pendingAttributeValueS = null;\n            hasEmptyAttributeValue = false;\n            hasPendingAttributeValue = false;\n            selfClosing = false;\n            attributes = null;\n            return this;\n        }\n\n        final void newAttribute() {\n            if (attributes == null)\n                attributes = new Attributes();\n\n            if (pendingAttributeName != null) {\n                \n                pendingAttributeName = pendingAttributeName.trim();\n                if (pendingAttributeName.length() > 0) {\n                    String value;\n                    if (hasPendingAttributeValue)\n                        value = pendingAttributeValue.length() > 0 ? pendingAttributeValue.toString() : pendingAttributeValueS;\n                    else if (hasEmptyAttributeValue)\n                        value = \"\";\n                    else\n                        value = null;\n                    \n                    attributes.add(pendingAttributeName, value);\n                }\n            }\n            pendingAttributeName = null;\n            hasEmptyAttributeValue = false;\n            hasPendingAttributeValue = false;\n            reset(pendingAttributeValue);\n            pendingAttributeValueS = null;\n        }\n\n        final void finaliseTag() {\n            \n            if (pendingAttributeName != null) {\n                newAttribute();\n            }\n        }\n\n        \n        final String name() { \n            Validate.isFalse(tagName == null || tagName.length() == 0);\n            return tagName;\n        }\n\n        \n        final String normalName() { \n            return normalName;\n        }\n\n        final Tag name(String name) {\n            tagName = name;\n            normalName = lowerCase(name);\n            return this;\n        }\n\n        final boolean isSelfClosing() {\n            return selfClosing;\n        }\n\n        @SuppressWarnings({\"TypeMayBeWeakened\"})\n        final Attributes getAttributes() {\n            return attributes;\n        }\n\n        \n        final void appendTagName(String append) {\n            tagName = tagName == null ? append : tagName.concat(append);\n            normalName = lowerCase(tagName);\n        }\n\n        final void appendTagName(char append) {\n            appendTagName(String.valueOf(append));\n        }\n\n        final void appendAttributeName(String append) {\n            pendingAttributeName = pendingAttributeName == null ? append : pendingAttributeName.concat(append);\n        }\n\n        final void appendAttributeName(char append) {\n            appendAttributeName(String.valueOf(append));\n        }\n\n        final void appendAttributeValue(String append) {\n            ensureAttributeValue();\n            if (pendingAttributeValue.length() == 0) {\n                pendingAttributeValueS = append;\n            } else {\n                pendingAttributeValue.append(append);\n            }\n        }\n\n        final void appendAttributeValue(char append) {\n            ensureAttributeValue();\n            pendingAttributeValue.append(append);\n        }\n\n        final void appendAttributeValue(char[] append) {\n            ensureAttributeValue();\n            pendingAttributeValue.append(append);\n        }\n\n        final void appendAttributeValue(int[] appendCodepoints) {\n            ensureAttributeValue();\n            for (int codepoint : appendCodepoints) {\n                pendingAttributeValue.appendCodePoint(codepoint);\n            }\n        }\n        \n        final void setEmptyAttributeValue() {\n            hasEmptyAttributeValue = true;\n        }\n\n        private void ensureAttributeValue() {\n            hasPendingAttributeValue = true;\n            \n            if (pendingAttributeValueS != null) {\n                pendingAttributeValue.append(pendingAttributeValueS);\n                pendingAttributeValueS = null;\n            }\n        }\n    }\n\n    final static class StartTag extends Tag { StartTag() {\n            super();\n            attributes = new Attributes();\n            type = TokenType.StartTag;\n        }\n\n        @Override\n        Tag reset() {\n            super.reset();\n            attributes = new Attributes();\n            \n            return this;\n        }\n\n        StartTag nameAttr(String name, Attributes attributes) {\n            this.tagName = name;\n            this.attributes = attributes;\n            normalName = lowerCase(tagName);\n            return this;\n        }\n\n        @Override\n        public String toString() {\n            if (attributes != null && attributes.size() > 0)\n                return \"<\" + name() + \" \" + attributes.toString() + \">\";\n            else\n                return \"<\" + name() + \">\";\n        }\n    }\n\n    final static class EndTag extends Tag{ EndTag() {\n            super();\n            type = TokenType.EndTag;\n        }\n\n        @Override\n        public String toString() {\n            return \"</\" + name() + \">\";\n        }\n    }\n\n    final static class Comment extends Token { final StringBuilder data = new StringBuilder(); boolean bogus = false; @Override Token reset() {\n            reset(data);\n            bogus = false;\n            return this;\n        }\n\n        Comment() {\n            type = TokenType.Comment;\n        }\n\n        String getData() {\n            return data.toString();\n        }\n\n        @Override\n        public String toString() {\n            return \"<!--\" + getData() + \"-->\";\n        }\n    }\n\n    static class Character extends Token { private String data; Character() {\n            super();\n            type = TokenType.Character;\n        }\n\n        @Override\n        Token reset() {\n            data = null;\n            return this;\n        }\n\n        Character data(String data) {\n            this.data = data;\n            return this;\n        }\n\n        String getData() {\n            return data;\n        }\n\n        @Override\n        public String toString() {\n            return getData();\n        }\n    }\n\n    final static class CData extends Character { CData(String data) {\n            super();\n            this.data(data);\n        }\n\n        @Override\n        public String toString() {\n            return \"<![CDATA[\" + getData() + \"]]>\";\n        }\n\n    }\n\n    final static class EOF extends Token { EOF() {\n            type = Token.TokenType.EOF;\n        }\n\n        @Override\n        Token reset() {\n            return this;\n        }\n    }\n\n    final boolean isDoctype() {\n        return type == TokenType.Doctype;\n    }\n\n    final Doctype asDoctype() {\n        return (Doctype) this;\n    }\n\n    final boolean isStartTag() {\n        return type == TokenType.StartTag;\n    }\n\n    final StartTag asStartTag() {\n        return (StartTag) this;\n    }\n\n    final boolean isEndTag() {\n        return type == TokenType.EndTag;\n    }\n\n    final EndTag asEndTag() {\n        return (EndTag) this;\n    }\n\n    final boolean isComment() {\n        return type == TokenType.Comment;\n    }\n\n    final Comment asComment() {\n        return (Comment) this;\n    }\n\n    final boolean isCharacter() {\n        return type == TokenType.Character;\n    }\n\n    final boolean isCData() {\n        return this instanceof CData;\n    }\n\n    final Character asCharacter() {\n        return (Character) this;\n    }\n\n    final boolean isEOF() {\n        return type == TokenType.EOF;\n    }\n\n    public enum TokenType {\n        Doctype,\n        StartTag,\n        EndTag,\n        Comment,\n        Character, \n        EOF\n    }\n}\n",
      "buggy_signatures": [
        "static org.jsoup.internal.Normalizer.lowerCase; abstract class Token { TokenType type; private Token()",
        "abstract Token reset(); static void reset(StringBuilder sb)",
        "public String getSystemIdentifier()",
        "public boolean isForceQuirks()",
        "private void ensureAttributeValue()",
        "static class StartTag extends Tag { StartTag()",
        "public String toString()",
        "static class EndTag extends Tag{ EndTag()",
        "public String toString()",
        "public String toString()",
        "static class Character extends Token { private String data; Character()",
        "public String toString()",
        "static class CData extends Character { CData(String data)",
        "public String toString()",
        "static class EOF extends Token { EOF()"
      ],
      "fixed_signatures": [
        "static org.jsoup.internal.Normalizer.lowerCase; abstract class Token { TokenType type; private Token()",
        "abstract Token reset(); static void reset(StringBuilder sb)",
        "public String getSystemIdentifier()",
        "public boolean isForceQuirks()",
        "private void ensureAttributeValue()",
        "static class StartTag extends Tag { StartTag()",
        "public String toString()",
        "static class EndTag extends Tag{ EndTag()",
        "public String toString()",
        "public String toString()",
        "static class Character extends Token { private String data; Character()",
        "public String toString()",
        "static class CData extends Character { CData(String data)",
        "public String toString()",
        "static class EOF extends Token { EOF()"
      ],
      "methods": [
        {
          "buggy_method": "  private StringBuilder pendingAttributeValue = new StringBuilder(); private String pendingAttributeValueS; private boolean hasEmptyAttributeValue = false; private boolean hasPendingAttributeValue = false; boolean selfClosing = false; Attributes attributes; @Override Tag reset() {\n  tagName = null;\n  normalName = null;\n  pendingAttributeName = null;\n  reset(pendingAttributeValue);\n  pendingAttributeValueS = null;\n  hasEmptyAttributeValue = false;\n  hasPendingAttributeValue = false;\n  selfClosing = false;\n  attributes = null;\n  return this;\n  }",
          "fixed_method": "  private StringBuilder pendingAttributeValue = new StringBuilder(); private String pendingAttributeValueS; private boolean hasEmptyAttributeValue = false; private boolean hasPendingAttributeValue = false; boolean selfClosing = false; Attributes attributes; @Override Tag reset() {\n  tagName = null;\n  normalName = null;\n  pendingAttributeName = null;\n  reset(pendingAttributeValue);\n  pendingAttributeValueS = null;\n  hasEmptyAttributeValue = false;\n  hasPendingAttributeValue = false;\n  selfClosing = false;\n  attributes = null;\n  return this;\n  }",
          "diff": [
            "@@ -113,7 +113,7 @@",
            "                     else\n",
            "                         value = null;\n",
            "                     // note that we add, not put. So that the first is kept, and rest are deduped, once in a context where case sensitivity is known (the appropriate tree builder).\n",
            "-                    attributes.put(pendingAttributeName, value);\n",
            "+                    attributes.add(pendingAttributeName, value);\n",
            "                 }\n",
            "             }\n",
            "             pendingAttributeName = null;\n"
          ],
          "changed_lines": 2
        }
      ]
    },
    {
      "name": "org/jsoup/parser/XmlTreeBuilder.java",
      "buggy_full_code": "package org.jsoup.parser;\n\nimport org.jsoup.helper.Validate;\nimport org.jsoup.nodes.CDataNode;\nimport org.jsoup.nodes.Comment;\nimport org.jsoup.nodes.Document;\nimport org.jsoup.nodes.DocumentType;\nimport org.jsoup.nodes.Element;\nimport org.jsoup.nodes.Node;\nimport org.jsoup.nodes.TextNode;\nimport org.jsoup.nodes.XmlDeclaration;\n\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.util.List;\n\n\npublic class XmlTreeBuilder extends TreeBuilder { ParseSettings defaultSettings() {\n        return ParseSettings.preserveCase;\n    }\n\n    @Override\n    protected void initialiseParse(Reader input, String baseUri, Parser parser) {\n        super.initialiseParse(input, baseUri, parser);\n        stack.add(doc); \n        doc.outputSettings().syntax(Document.OutputSettings.Syntax.xml);\n    }\n\n    Document parse(Reader input, String baseUri) {\n        return parse(input, baseUri, new Parser(this));\n    }\n\n    Document parse(String input, String baseUri) {\n        return parse(new StringReader(input), baseUri, new Parser(this));\n    }\n\n    @Override\n    protected boolean process(Token token) {\n        \n        switch (token.type) {\n            case StartTag:\n                insert(token.asStartTag());\n                break;\n            case EndTag:\n                popStackToClose(token.asEndTag());\n                break;\n            case Comment:\n                insert(token.asComment());\n                break;\n            case Character:\n                insert(token.asCharacter());\n                break;\n            case Doctype:\n                insert(token.asDoctype());\n                break;\n            case EOF: \n                break;\n            default:\n                Validate.fail(\"Unexpected token type: \" + token.type);\n        }\n        return true;\n    }\n\n    private void insertNode(Node node) {\n        currentElement().appendChild(node);\n    }\n\n    Element insert(Token.StartTag startTag) {\n        Tag tag = Tag.valueOf(startTag.name(), settings);\n        \n\n        Element el = new Element(tag, baseUri, settings.normalizeAttributes(startTag.attributes));\n        insertNode(el);\n        if (startTag.isSelfClosing()) {\n            if (!tag.isKnownTag()) \n                tag.setSelfClosing();\n        } else {\n            stack.add(el);\n        }\n        return el;\n    }\n\n    void insert(Token.Comment commentToken) {\n        Comment comment = new Comment(commentToken.getData());\n        Node insert = comment;\n        if (commentToken.bogus && comment.isXmlDeclaration()) {\n            \n            \n            XmlDeclaration decl = comment.asXmlDeclaration(); \n            if (decl != null)\n                insert = decl;\n        }\n        insertNode(insert);\n    }\n\n    void insert(Token.Character token) {\n        final String data = token.getData();\n        insertNode(token.isCData() ? new CDataNode(data) : new TextNode(data));\n    }\n\n    void insert(Token.Doctype d) {\n        DocumentType doctypeNode = new DocumentType(settings.normalizeTag(d.getName()), d.getPublicIdentifier(), d.getSystemIdentifier());\n        doctypeNode.setPubSysKey(d.getPubSysKey());\n        insertNode(doctypeNode);\n    }\n\n    \n    private void popStackToClose(Token.EndTag endTag) {\n        String elName = settings.normalizeTag(endTag.tagName);\n        Element firstFound = null;\n\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next.nodeName().equals(elName)) {\n                firstFound = next;\n                break;\n            }\n        }\n        if (firstFound == null)\n            return; \n\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            stack.remove(pos);\n            if (next == firstFound)\n                break;\n        }\n    }\n\n\n    List<Node> parseFragment(String inputFragment, String baseUri, Parser parser) {\n        initialiseParse(new StringReader(inputFragment), baseUri, parser);\n        runParser();\n        return doc.childNodes();\n    }\n\n    List<Node> parseFragment(String inputFragment, Element context, String baseUri, Parser parser) {\n        return parseFragment(inputFragment, baseUri, parser);\n    }\n}\n",
      "fixed_full_code": "package org.jsoup.parser;\n\nimport org.jsoup.helper.Validate;\nimport org.jsoup.nodes.CDataNode;\nimport org.jsoup.nodes.Comment;\nimport org.jsoup.nodes.Document;\nimport org.jsoup.nodes.DocumentType;\nimport org.jsoup.nodes.Element;\nimport org.jsoup.nodes.Node;\nimport org.jsoup.nodes.TextNode;\nimport org.jsoup.nodes.XmlDeclaration;\n\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.util.List;\n\n\npublic class XmlTreeBuilder extends TreeBuilder { ParseSettings defaultSettings() {\n        return ParseSettings.preserveCase;\n    }\n\n    @Override\n    protected void initialiseParse(Reader input, String baseUri, Parser parser) {\n        super.initialiseParse(input, baseUri, parser);\n        stack.add(doc); \n        doc.outputSettings().syntax(Document.OutputSettings.Syntax.xml);\n    }\n\n    Document parse(Reader input, String baseUri) {\n        return parse(input, baseUri, new Parser(this));\n    }\n\n    Document parse(String input, String baseUri) {\n        return parse(new StringReader(input), baseUri, new Parser(this));\n    }\n\n    @Override\n    protected boolean process(Token token) {\n        \n        switch (token.type) {\n            case StartTag:\n                insert(token.asStartTag());\n                break;\n            case EndTag:\n                popStackToClose(token.asEndTag());\n                break;\n            case Comment:\n                insert(token.asComment());\n                break;\n            case Character:\n                insert(token.asCharacter());\n                break;\n            case Doctype:\n                insert(token.asDoctype());\n                break;\n            case EOF: \n                break;\n            default:\n                Validate.fail(\"Unexpected token type: \" + token.type);\n        }\n        return true;\n    }\n\n    private void insertNode(Node node) {\n        currentElement().appendChild(node);\n    }\n\n    Element insert(Token.StartTag startTag) {\n        Tag tag = Tag.valueOf(startTag.name(), settings);\n        \n        startTag.attributes.deduplicate(settings);\n\n        Element el = new Element(tag, baseUri, settings.normalizeAttributes(startTag.attributes));\n        insertNode(el);\n        if (startTag.isSelfClosing()) {\n            if (!tag.isKnownTag()) \n                tag.setSelfClosing();\n        } else {\n            stack.add(el);\n        }\n        return el;\n    }\n\n    void insert(Token.Comment commentToken) {\n        Comment comment = new Comment(commentToken.getData());\n        Node insert = comment;\n        if (commentToken.bogus && comment.isXmlDeclaration()) {\n            \n            \n            XmlDeclaration decl = comment.asXmlDeclaration(); \n            if (decl != null)\n                insert = decl;\n        }\n        insertNode(insert);\n    }\n\n    void insert(Token.Character token) {\n        final String data = token.getData();\n        insertNode(token.isCData() ? new CDataNode(data) : new TextNode(data));\n    }\n\n    void insert(Token.Doctype d) {\n        DocumentType doctypeNode = new DocumentType(settings.normalizeTag(d.getName()), d.getPublicIdentifier(), d.getSystemIdentifier());\n        doctypeNode.setPubSysKey(d.getPubSysKey());\n        insertNode(doctypeNode);\n    }\n\n    \n    private void popStackToClose(Token.EndTag endTag) {\n        String elName = settings.normalizeTag(endTag.tagName);\n        Element firstFound = null;\n\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next.nodeName().equals(elName)) {\n                firstFound = next;\n                break;\n            }\n        }\n        if (firstFound == null)\n            return; \n\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            stack.remove(pos);\n            if (next == firstFound)\n                break;\n        }\n    }\n\n\n    List<Node> parseFragment(String inputFragment, String baseUri, Parser parser) {\n        initialiseParse(new StringReader(inputFragment), baseUri, parser);\n        runParser();\n        return doc.childNodes();\n    }\n\n    List<Node> parseFragment(String inputFragment, Element context, String baseUri, Parser parser) {\n        return parseFragment(inputFragment, baseUri, parser);\n    }\n}\n",
      "buggy_signatures": [
        "public class XmlTreeBuilder extends TreeBuilder { ParseSettings defaultSettings()",
        "protected void initialiseParse(Reader input, String baseUri, Parser parser)",
        "protected boolean process(Token token)",
        "private void insertNode(Node node)",
        "private void popStackToClose(Token.EndTag endTag)"
      ],
      "fixed_signatures": [
        "public class XmlTreeBuilder extends TreeBuilder { ParseSettings defaultSettings()",
        "protected void initialiseParse(Reader input, String baseUri, Parser parser)",
        "protected boolean process(Token token)",
        "private void insertNode(Node node)",
        "private void popStackToClose(Token.EndTag endTag)"
      ],
      "methods": [
        {
          "buggy_method": "  private void insertNode(Node node) {\n  currentElement().appendChild(node);\n  }",
          "fixed_method": "  private void insertNode(Node node) {\n  currentElement().appendChild(node);\n  }",
          "diff": [
            "@@ -75,6 +75,7 @@",
            "     Element insert(Token.StartTag startTag) {\n",
            "         Tag tag = Tag.valueOf(startTag.name(), settings);\n",
            "         // todo: wonder if for xml parsing, should treat all tags as unknown? because it's not html.\n",
            "+        startTag.attributes.deduplicate(settings);\n",
            " \n",
            "         Element el = new Element(tag, baseUri, settings.normalizeAttributes(startTag.attributes));\n",
            "         insertNode(el);\n"
          ],
          "changed_lines": 1
        }
      ]
    }
  ]
}
