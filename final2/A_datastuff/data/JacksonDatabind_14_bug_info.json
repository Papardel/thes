{
  "bug_id": "14",
  "failed_tests": {
    "com.fasterxml.jackson.databind.convert.TestUpdateValue": [
      {
        "methodName": "testIssue744",
        "error": "com.fasterxml.jackson.databind.exc.UnrecognizedPropertyException",
        "message": "Unrecognized field \"i\" (class com.fasterxml.jackson.databind.convert.TestUpdateValue$DataB), not marked as ignorable (2 known properties: \"da\", \"k\"])",
        "fail_line": "        mapper.readerForUpdating(dbUpdViaNode).readValue(jsonBNode);",
        "test_source": "  public void testIssue744() throws IOException {\n  ObjectMapper mapper = new ObjectMapper();\n  SimpleModule module = new SimpleModule();\n  module.addDeserializer(DataA.class, new DataADeserializer());\n  mapper.registerModule(module);\n\n  DataB db = new DataB();\n  db.da.i = 11;\n  db.k = 13;\n  String jsonBString = mapper.writeValueAsString(db);\n  JsonNode jsonBNode = mapper.valueToTree(db);\n\n  // create parent\n  DataB dbNewViaString = mapper.readValue(jsonBString, DataB.class);\n  assertEquals(5, dbNewViaString.da.i);\n  assertEquals(13, dbNewViaString.k);\n\n  DataB dbNewViaNode = mapper.treeToValue(jsonBNode, DataB.class);\n  assertEquals(5, dbNewViaNode.da.i);\n  assertEquals(13, dbNewViaNode.k);\n\n  // update parent\n  DataB dbUpdViaString = new DataB();\n  DataB dbUpdViaNode = new DataB();\n\n  assertEquals(1, dbUpdViaString.da.i);\n  assertEquals(3, dbUpdViaString.k);\n  mapper.readerForUpdating(dbUpdViaString).readValue(jsonBString);\n  assertEquals(5, dbUpdViaString.da.i);\n  assertEquals(13, dbUpdViaString.k);\n\n  assertEquals(1, dbUpdViaNode.da.i);\n  assertEquals(3, dbUpdViaNode.k);\n  \n  mapper.readerForUpdating(dbUpdViaNode).readValue(jsonBNode);\n  assertEquals(5, dbUpdViaNode.da.i);\n  assertEquals(13, dbUpdViaNode.k);\n  }",
        "stack": [
          "UnrecognizedPropertyException.from line 52, DeserializationContext.reportUnknownProperty line 817, StdDeserializer.handleUnknownProperty line 958, BeanDeserializerBase.handleUnknownProperty line 1324, BeanDeserializerBase.handleUnknownVanilla line 1302, BeanDeserializer.vanillaDeserialize line 249, BeanDeserializer.deserialize line 136, ObjectReader._bindAsTree line 1480, ObjectReader.readTree line 1022, JsonParser.readValueAsTree line 1465, TestUpdateValue$DataADeserializer.deserialize line 76, TestUpdateValue$DataADeserializer.deserialize line 63, SettableBeanProperty.deserialize line 523, FieldProperty.deserializeAndSet line 101, BeanPropertyMap.findDeserializeAndSet line 285, BeanDeserializer.deserialize line 220, ObjectReader._bindAndClose line 1445, ObjectReader.readValue line 1156, TestUpdateValue.testIssue744 line 222"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "com/fasterxml/jackson/databind/ObjectReader.java",
      "buggy_full_code": "package com.fasterxml.jackson.databind;\n\nimport java.io.*;\nimport java.net.URL;\nimport java.util.Iterator;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.TimeZone;\nimport java.util.concurrent.ConcurrentHashMap;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.type.ResolvedType;\nimport com.fasterxml.jackson.core.type.TypeReference;\nimport com.fasterxml.jackson.databind.cfg.ContextAttributes;\nimport com.fasterxml.jackson.databind.deser.DataFormatReaders;\nimport com.fasterxml.jackson.databind.deser.DefaultDeserializationContext;\nimport com.fasterxml.jackson.databind.deser.DeserializationProblemHandler;\nimport com.fasterxml.jackson.databind.node.JsonNodeFactory;\nimport com.fasterxml.jackson.databind.node.NullNode;\nimport com.fasterxml.jackson.databind.node.TreeTraversingParser;\nimport com.fasterxml.jackson.databind.type.SimpleType;\nimport com.fasterxml.jackson.databind.type.TypeFactory;\nimport com.fasterxml.jackson.databind.util.RootNameLookup;\n\n\npublic class ObjectReader extends ObjectCodec implements Versioned, java.io.Serializable { private static final long serialVersionUID = 1L; private final static JavaType JSON_NODE_TYPE = SimpleType.constructUnsafe(JsonNode.class); protected final DeserializationConfig _config; protected final DefaultDeserializationContext _context; protected final JsonFactory _parserFactory; protected final boolean _unwrapRoot; protected final JavaType _valueType; protected final JsonDeserializer<Object> _rootDeserializer; protected final Object _valueToUpdate; protected final FormatSchema _schema; protected final InjectableValues _injectableValues; protected final DataFormatReaders _dataFormatReaders; final protected ConcurrentHashMap<JavaType, JsonDeserializer<Object>> _rootDeserializers; protected final RootNameLookup _rootNames; protected ObjectReader(ObjectMapper mapper, DeserializationConfig config) {\n        this(mapper, config, null, null, null, null);\n    }\n\n    \n    protected ObjectReader(ObjectMapper mapper, DeserializationConfig config, JavaType valueType, Object valueToUpdate, FormatSchema schema, InjectableValues injectableValues) {\n        _config = config;\n        _context = mapper._deserializationContext;\n        _rootDeserializers = mapper._rootDeserializers;\n        _parserFactory = mapper._jsonFactory;\n        _rootNames = mapper._rootNames;\n        _valueType = valueType;\n        _valueToUpdate = valueToUpdate;\n        if (valueToUpdate != null && valueType.isArrayType()) {\n            throw new IllegalArgumentException(\"Can not update an array value\");\n        }\n        _schema = schema;\n        _injectableValues = injectableValues;\n        _unwrapRoot = config.useRootWrapping();\n\n        _rootDeserializer = _prefetchRootDeserializer(config, valueType);\n        _dataFormatReaders = null;        \n    }\n    \n    \n    protected ObjectReader(ObjectReader base, DeserializationConfig config, JavaType valueType, JsonDeserializer<Object> rootDeser, Object valueToUpdate, FormatSchema schema, InjectableValues injectableValues, DataFormatReaders dataFormatReaders) {\n        _config = config;\n        _context = base._context;\n\n        _rootDeserializers = base._rootDeserializers;\n        _parserFactory = base._parserFactory;\n        _rootNames = base._rootNames;\n\n        _valueType = valueType;\n        _rootDeserializer = rootDeser;\n        _valueToUpdate = valueToUpdate;\n        if (valueToUpdate != null && valueType.isArrayType()) {\n            throw new IllegalArgumentException(\"Can not update an array value\");\n        }\n        _schema = schema;\n        _injectableValues = injectableValues;\n        _unwrapRoot = config.useRootWrapping();\n        _dataFormatReaders = dataFormatReaders;\n    }\n\n    \n    protected ObjectReader(ObjectReader base, DeserializationConfig config) {\n        _config = config;\n        _context = base._context;\n\n        _rootDeserializers = base._rootDeserializers;\n        _parserFactory = base._parserFactory;\n        _rootNames = base._rootNames;\n\n        _valueType = base._valueType;\n        _rootDeserializer = base._rootDeserializer;\n        _valueToUpdate = base._valueToUpdate;\n        _schema = base._schema;\n        _injectableValues = base._injectableValues;\n        _unwrapRoot = config.useRootWrapping();\n        _dataFormatReaders = base._dataFormatReaders;\n    }\n    \n    protected ObjectReader(ObjectReader base, JsonFactory f) {\n        \n        _config = base._config\n            .with(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY, f.requiresPropertyOrdering());\n        _context = base._context;\n\n        _rootDeserializers = base._rootDeserializers;\n        _parserFactory = f;\n        _rootNames = base._rootNames;\n\n        _valueType = base._valueType;\n        _rootDeserializer = base._rootDeserializer;\n        _valueToUpdate = base._valueToUpdate;\n        _schema = base._schema;\n        _injectableValues = base._injectableValues;\n        _unwrapRoot = base._unwrapRoot;\n        _dataFormatReaders = base._dataFormatReaders;\n    }\n    \n    \n    @Override\n    public Version version() {\n        return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION;\n    }\n\n    \n\n    \n    protected ObjectReader _new(ObjectReader base, JsonFactory f) {\n        return new ObjectReader(base, f);\n    }\n\n    \n    protected ObjectReader _new(ObjectReader base, DeserializationConfig config) {\n        return new ObjectReader(base, config);\n    }\n\n    \n    protected ObjectReader _new(ObjectReader base, DeserializationConfig config, JavaType valueType, JsonDeserializer<Object> rootDeser, Object valueToUpdate, FormatSchema schema, InjectableValues injectableValues, DataFormatReaders dataFormatReaders) {\n        return new ObjectReader(base, config, valueType, rootDeser,  valueToUpdate,\n                 schema,  injectableValues, dataFormatReaders);\n    }\n\n    \n    protected <T> MappingIterator<T> _newIterator(JavaType valueType, JsonParser parser, DeserializationContext ctxt, JsonDeserializer<?> deser, boolean parserManaged, Object valueToUpdate) {\n            return new MappingIterator<T>(valueType, parser, ctxt,\n                    deser, parserManaged, valueToUpdate);\n    }\n\n    \n\n    \n    protected JsonToken _initForReading(JsonParser p) throws IOException {\n        if (_schema != null) {\n            p.setSchema(_schema);\n        }\n        _config.initialize(p); \n\n        \n        JsonToken t = p.getCurrentToken();\n        if (t == null) { \n            t = p.nextToken();\n            if (t == null) {\n                \n                throw JsonMappingException.from(p, \"No content to map due to end-of-input\");\n            }\n        }\n        return t;\n    }\n\n    \n    protected void _initForMultiRead(JsonParser p) throws IOException {\n        if (_schema != null) {\n            p.setSchema(_schema);\n        }\n        _config.initialize(p); \n    }\n\n    \n\n    \n    public ObjectReader with(DeserializationFeature feature) {\n        return _with(_config.with(feature));\n    }\n\n    \n    public ObjectReader with(DeserializationFeature first, DeserializationFeature... other) {\n        return _with(_config.with(first, other));\n    }    \n\n    \n    public ObjectReader withFeatures(DeserializationFeature... features) {\n        return _with(_config.withFeatures(features));\n    }    \n\n    \n    public ObjectReader without(DeserializationFeature feature) {\n        return _with(_config.without(feature)); \n    }\n\n    \n    public ObjectReader without(DeserializationFeature first, DeserializationFeature... other) {\n        return _with(_config.without(first, other));\n    }    \n\n    \n    public ObjectReader withoutFeatures(DeserializationFeature... features) {\n        return _with(_config.withoutFeatures(features));\n    }    \n\n    \n\n    \n    public ObjectReader with(JsonParser.Feature feature) {\n        return _with(_config.with(feature));\n    }\n\n    \n    public ObjectReader withFeatures(JsonParser.Feature... features) {\n        return _with(_config.withFeatures(features));\n    }    \n\n    \n    public ObjectReader without(JsonParser.Feature feature) {\n        return _with(_config.without(feature)); \n    }\n\n    \n    public ObjectReader withoutFeatures(JsonParser.Feature... features) {\n        return _with(_config.withoutFeatures(features));\n    }\n\n    \n\n    public ObjectReader with(DeserializationConfig config) {\n        return _with(config);\n    }    \n\n    \n    public ObjectReader with(InjectableValues injectableValues) {\n        if (_injectableValues == injectableValues) {\n            return this;\n        }\n        return _new(this, _config,\n                _valueType, _rootDeserializer, _valueToUpdate,\n                _schema, injectableValues, _dataFormatReaders);\n    }\n\n    \n    public ObjectReader with(JsonNodeFactory f) {\n        return _with(_config.with(f));\n    }\n\n    \n    public ObjectReader with(JsonFactory f) {\n        if (f == _parserFactory) {\n            return this;\n        }\n        ObjectReader r = _new(this, f);\n        \n        if (f.getCodec() == null) {\n            f.setCodec(r);\n        }\n        return r;\n    }\n    \n    \n    public ObjectReader withRootName(String rootName) {\n        return _with(_config.withRootName(rootName));\n    }\n\n    \n    public ObjectReader with(FormatSchema schema) {\n        if (_schema == schema) {\n            return this;\n        }\n        _verifySchemaType(schema);\n        return _new(this, _config, _valueType, _rootDeserializer, _valueToUpdate,\n                schema, _injectableValues, _dataFormatReaders);\n    }\n\n    \n    public ObjectReader forType(JavaType valueType) {\n        if (valueType != null && valueType.equals(_valueType)) {\n            return this;\n        }\n        JsonDeserializer<Object> rootDeser = _prefetchRootDeserializer(_config, valueType);\n        \n        DataFormatReaders det = _dataFormatReaders;\n        if (det != null) {\n            det = det.withType(valueType);\n        }\n        return _new(this, _config, valueType, rootDeser,\n                _valueToUpdate, _schema, _injectableValues, det);\n    }    \n\n    \n    public ObjectReader forType(Class<?> valueType) {\n        return forType(_config.constructType(valueType));\n    }    \n\n    \n    public ObjectReader forType(TypeReference<?> valueTypeRef) {\n        return forType(_config.getTypeFactory().constructType(valueTypeRef.getType()));\n    }    \n\n    \n    @Deprecated\n    public ObjectReader withType(JavaType valueType) {\n        return forType(valueType);\n    }\n\n    \n    @Deprecated\n    public ObjectReader withType(Class<?> valueType) {\n        return forType(_config.constructType(valueType));\n    }    \n\n    \n    @Deprecated\n    public ObjectReader withType(java.lang.reflect.Type valueType) {\n        return forType(_config.getTypeFactory().constructType(valueType));\n    }\n\n    \n    @Deprecated\n    public ObjectReader withType(TypeReference<?> valueTypeRef) {\n        return forType(_config.getTypeFactory().constructType(valueTypeRef.getType()));\n    }    \n\n    \n    public ObjectReader withValueToUpdate(Object value) {\n        if (value == _valueToUpdate) return this;\n        if (value == null) {\n            throw new IllegalArgumentException(\"cat not update null value\");\n        }\n        JavaType t;\n        \n        \n        if (_valueType == null) {\n            t = _config.constructType(value.getClass());\n        } else {\n            t = _valueType;\n        }\n        return _new(this, _config, t, _rootDeserializer, value,\n                _schema, _injectableValues, _dataFormatReaders);\n    }\n\n    \n    public ObjectReader withView(Class<?> activeView) {\n        return _with(_config.withView(activeView));\n    }\n\n    public ObjectReader with(Locale l) {\n        return _with(_config.with(l));\n    }\n\n    public ObjectReader with(TimeZone tz) {\n        return _with(_config.with(tz));\n    }\n\n    public ObjectReader withHandler(DeserializationProblemHandler h) {\n        return _with(_config.withHandler(h));\n    }\n\n    public ObjectReader with(Base64Variant defaultBase64) {\n        return _with(_config.with(defaultBase64));\n    }\n\n    \n    public ObjectReader withFormatDetection(ObjectReader... readers) {\n        return withFormatDetection(new DataFormatReaders(readers));\n    }\n\n    \n    public ObjectReader withFormatDetection(DataFormatReaders readers) {\n        return _new(this, _config, _valueType, _rootDeserializer, _valueToUpdate,\n                _schema, _injectableValues, readers);\n    }\n\n    \n    public ObjectReader with(ContextAttributes attrs) {\n        return _with(_config.with(attrs));\n    }\n\n    \n    public ObjectReader withAttributes(Map<Object,Object> attrs) {\n        return _with(_config.withAttributes(attrs));\n    }\n\n    \n    public ObjectReader withAttribute(Object key, Object value) {\n        return _with( _config.withAttribute(key, value));\n    }\n\n    \n    public ObjectReader withoutAttribute(Object key) {\n        return _with(_config.withoutAttribute(key));\n    }\n\n    \n    \n    protected ObjectReader _with(DeserializationConfig newConfig) {\n        if (newConfig == _config) {\n            return this;\n        }\n        ObjectReader r = _new(this, newConfig);\n        if (_dataFormatReaders != null) {\n            r  = r.withFormatDetection(_dataFormatReaders.with(newConfig));\n        }\n        return r;\n    }\n    \n    \n    \n    public boolean isEnabled(DeserializationFeature f) {\n        return _config.isEnabled(f);\n    }\n\n    public boolean isEnabled(MapperFeature f) {\n        return _config.isEnabled(f);\n    }\n\n    public boolean isEnabled(JsonParser.Feature f) {\n        return _parserFactory.isEnabled(f);\n    }\n\n    \n    public DeserializationConfig getConfig() {\n        return _config;\n    }\n    \n    \n    @Override\n    public JsonFactory getFactory() {\n        return _parserFactory;\n    }\n    \n    \n    @Deprecated\n    @Override\n    public JsonFactory getJsonFactory() {\n        return _parserFactory;\n    }\n\n    public TypeFactory getTypeFactory() {\n        return _config.getTypeFactory();\n    }\n\n    \n    public ContextAttributes getAttributes() {\n        return _config.getAttributes();\n    }\n    \n    \n\n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(JsonParser jp) throws IOException, JsonProcessingException {\n        return (T) _bind(jp, _valueToUpdate);\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public <T> T readValue(JsonParser jp, Class<T> valueType) throws IOException, JsonProcessingException {\n        return (T) withType(valueType).readValue(jp);\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public <T> T readValue(JsonParser jp, TypeReference<?> valueTypeRef) throws IOException, JsonProcessingException {\n        return (T) withType(valueTypeRef).readValue(jp);\n    }\n\n    \n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(JsonParser jp, ResolvedType valueType) throws IOException, JsonProcessingException {\n        return (T) withType((JavaType)valueType).readValue(jp);\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(JsonParser jp, JavaType valueType) throws IOException, JsonProcessingException {\n        return (T) withType(valueType).readValue(jp);\n    }\n\n    \n    @Override\n    public <T> Iterator<T> readValues(JsonParser jp, Class<T> valueType) throws IOException, JsonProcessingException {\n        return withType(valueType).readValues(jp);\n    }\n\n    \n    @Override\n    public <T> Iterator<T> readValues(JsonParser jp, TypeReference<?> valueTypeRef) throws IOException, JsonProcessingException {\n        return withType(valueTypeRef).readValues(jp);\n    }\n    \n    \n    @Override\n    public <T> Iterator<T> readValues(JsonParser jp, ResolvedType valueType) throws IOException, JsonProcessingException {\n        return readValues(jp, (JavaType) valueType);\n    }\n\n    \n    public <T> Iterator<T> readValues(JsonParser jp, JavaType valueType) throws IOException, JsonProcessingException {\n        return withType(valueType).readValues(jp);\n    }\n\n    \n\n    @Override\n    public JsonNode createArrayNode() {\n        return _config.getNodeFactory().arrayNode();\n    }\n\n    @Override\n    public JsonNode createObjectNode() {\n        return _config.getNodeFactory().objectNode();\n    }\n\n    @Override\n    public JsonParser treeAsTokens(TreeNode n) {\n        return new TreeTraversingParser((JsonNode) n, this);\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public <T extends TreeNode> T readTree(JsonParser jp) throws IOException, JsonProcessingException {\n        return (T) _bindAsTree(jp);\n    }\n     \n    @Override\n    public void writeTree(JsonGenerator jgen, TreeNode rootNode) {\n        throw new UnsupportedOperationException();\n    }\n    \n    \n    \n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(InputStream src) throws IOException, JsonProcessingException {\n        if (_dataFormatReaders != null) {\n            return (T) _detectBindAndClose(_dataFormatReaders.findFormat(src), false);\n        }\n        return (T) _bindAndClose(_parserFactory.createParser(src), _valueToUpdate);\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(Reader src) throws IOException, JsonProcessingException {\n        if (_dataFormatReaders != null) {\n            _reportUndetectableSource(src);\n        }\n        return (T) _bindAndClose(_parserFactory.createParser(src), _valueToUpdate);\n    }\n    \n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(String src) throws IOException, JsonProcessingException {\n        if (_dataFormatReaders != null) {\n            _reportUndetectableSource(src);\n        }\n        return (T) _bindAndClose(_parserFactory.createParser(src), _valueToUpdate);\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(byte[] src) throws IOException, JsonProcessingException {\n        if (_dataFormatReaders != null) {\n            return (T) _detectBindAndClose(src, 0, src.length);\n        }\n        return (T) _bindAndClose(_parserFactory.createParser(src), _valueToUpdate);\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(byte[] src, int offset, int length) throws IOException, JsonProcessingException {\n        if (_dataFormatReaders != null) {\n            return (T) _detectBindAndClose(src, offset, length);\n        }\n        return (T) _bindAndClose(_parserFactory.createParser(src, offset, length), _valueToUpdate);\n    }\n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(File src) throws IOException, JsonProcessingException {\n        if (_dataFormatReaders != null) {\n            return (T) _detectBindAndClose(_dataFormatReaders.findFormat(_inputStream(src)), true);\n        }\n        return (T) _bindAndClose(_parserFactory.createParser(src), _valueToUpdate);\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(URL src) throws IOException, JsonProcessingException {\n        if (_dataFormatReaders != null) {\n            return (T) _detectBindAndClose(_dataFormatReaders.findFormat(_inputStream(src)), true);\n        }\n        return (T) _bindAndClose(_parserFactory.createParser(src), _valueToUpdate);\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(JsonNode src) throws IOException, JsonProcessingException {\n        if (_dataFormatReaders != null) {\n            _reportUndetectableSource(src);\n        }\n        return (T) _bindAndClose(treeAsTokens(src), _valueToUpdate);\n    }\n    \n    \n    public JsonNode readTree(InputStream in) throws IOException, JsonProcessingException {\n        if (_dataFormatReaders != null) {\n            return _detectBindAndCloseAsTree(in);\n        }\n        return _bindAndCloseAsTree(_parserFactory.createParser(in));\n    }\n    \n    \n    public JsonNode readTree(Reader r) throws IOException, JsonProcessingException {\n        if (_dataFormatReaders != null) {\n            _reportUndetectableSource(r);\n        }\n        return _bindAndCloseAsTree(_parserFactory.createParser(r));\n    }\n\n    \n    public JsonNode readTree(String json) throws IOException, JsonProcessingException {\n        if (_dataFormatReaders != null) {\n            _reportUndetectableSource(json);\n        }\n        return _bindAndCloseAsTree(_parserFactory.createParser(json));\n    }\n\n    \n    \n    \n    public <T> MappingIterator<T> readValues(JsonParser jp) throws IOException, JsonProcessingException {\n        DeserializationContext ctxt = createDeserializationContext(jp, _config);\n        \n        return _newIterator(_valueType, jp, ctxt,\n                _findRootDeserializer(ctxt, _valueType),\n                false, _valueToUpdate);\n    }\n    \n    \n    public <T> MappingIterator<T> readValues(InputStream src) throws IOException, JsonProcessingException {\n        if (_dataFormatReaders != null) {\n            return _detectBindAndReadValues(_dataFormatReaders.findFormat(src), false);\n        }\n        return _bindAndReadValues(_parserFactory.createParser(src), _valueToUpdate);\n    }\n    \n    \n    @SuppressWarnings(\"resource\")\n    public <T> MappingIterator<T> readValues(Reader src) throws IOException, JsonProcessingException {\n        if (_dataFormatReaders != null) {\n            _reportUndetectableSource(src);\n        }\n        JsonParser p = _parserFactory.createParser(src);\n        _initForMultiRead(p);\n        p.nextToken();\n        DeserializationContext ctxt = createDeserializationContext(p, _config);\n        return _newIterator(_valueType, p, ctxt,\n                _findRootDeserializer(ctxt, _valueType), true, _valueToUpdate);\n    }\n    \n    \n    @SuppressWarnings(\"resource\")\n    public <T> MappingIterator<T> readValues(String json) throws IOException, JsonProcessingException {\n        if (_dataFormatReaders != null) {\n            _reportUndetectableSource(json);\n        }\n        JsonParser p = _parserFactory.createParser(json);\n        _initForMultiRead(p);\n        p.nextToken();\n        DeserializationContext ctxt = createDeserializationContext(p, _config);\n        return _newIterator(_valueType, p, ctxt,\n                _findRootDeserializer(ctxt, _valueType), true, _valueToUpdate);\n    }\n\n    \n    public <T> MappingIterator<T> readValues(byte[] src, int offset, int length) throws IOException, JsonProcessingException {\n        if (_dataFormatReaders != null) {\n            return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n        }\n        return _bindAndReadValues(_parserFactory.createParser(src), _valueToUpdate);\n    }\n\n    \n    public final <T> MappingIterator<T> readValues(byte[] src) throws IOException, JsonProcessingException {\n        return readValues(src, 0, src.length);\n    }\n    \n    \n    public <T> MappingIterator<T> readValues(File src) throws IOException, JsonProcessingException {\n        if (_dataFormatReaders != null) {\n            return _detectBindAndReadValues(\n                    _dataFormatReaders.findFormat(_inputStream(src)), false);\n        }\n        return _bindAndReadValues(_parserFactory.createParser(src), _valueToUpdate);\n    }\n\n    \n    public <T> MappingIterator<T> readValues(URL src) throws IOException, JsonProcessingException {\n        if (_dataFormatReaders != null) {\n            return _detectBindAndReadValues(\n                    _dataFormatReaders.findFormat(_inputStream(src)), true);\n        }\n        return _bindAndReadValues(_parserFactory.createParser(src), _valueToUpdate);\n    }\n\n    \n\n    @Override\n    public <T> T treeToValue(TreeNode n, Class<T> valueType) throws JsonProcessingException {\n        try {\n            return readValue(treeAsTokens(n), valueType);\n        } catch (JsonProcessingException e) {\n            throw e;\n        } catch (IOException e) { \n            throw new IllegalArgumentException(e.getMessage(), e);\n        }\n    }    \n    \n    @Override\n    public void writeValue(JsonGenerator jgen, Object value) throws IOException, JsonProcessingException {\n        throw new UnsupportedOperationException(\"Not implemented for ObjectReader\");\n    }\n\n    \n    \n    \n    protected Object _bind(JsonParser jp, Object valueToUpdate) throws IOException {\n        \n        Object result;\n        JsonToken t = _initForReading(jp);\n        if (t == JsonToken.VALUE_NULL) {\n            if (valueToUpdate == null) {\n                DeserializationContext ctxt = createDeserializationContext(jp, _config);\n                result = _findRootDeserializer(ctxt, _valueType).getNullValue();\n            } else {\n                result = valueToUpdate;\n            }\n        } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {\n            result = valueToUpdate;\n        } else { \n            DeserializationContext ctxt = createDeserializationContext(jp, _config);\n            JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, _valueType);\n            if (_unwrapRoot) {\n                result = _unwrapAndDeserialize(jp, ctxt, _valueType, deser);\n            } else {\n                if (valueToUpdate == null) {\n                    result = deser.deserialize(jp, ctxt);\n                } else {\n                    deser.deserialize(jp, ctxt, valueToUpdate);\n                    result = valueToUpdate;\n                }\n            }\n        }\n        \n        jp.clearCurrentToken();\n        return result;\n    }\n    \n    protected Object _bindAndClose(JsonParser jp, Object valueToUpdate) throws IOException {\n        try {\n            Object result;\n            JsonToken t = _initForReading(jp);\n            if (t == JsonToken.VALUE_NULL) {\n                if (valueToUpdate == null) {\n                    DeserializationContext ctxt = createDeserializationContext(jp, _config);\n                    result = _findRootDeserializer(ctxt, _valueType).getNullValue();\n                } else {\n                    result = valueToUpdate;\n                }\n            } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {\n                result = valueToUpdate;\n            } else {\n                DeserializationContext ctxt = createDeserializationContext(jp, _config);\n                JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, _valueType);\n                if (_unwrapRoot) {\n                    result = _unwrapAndDeserialize(jp, ctxt, _valueType, deser);\n                } else {\n                    if (valueToUpdate == null) {\n                        result = deser.deserialize(jp, ctxt);\n                    } else {\n                        deser.deserialize(jp, ctxt, valueToUpdate);\n                        result = valueToUpdate;                    \n                    }\n                }\n            }\n            return result;\n        } finally {\n            try {\n                jp.close();\n            } catch (IOException ioe) { }\n        }\n    }\n\n    protected JsonNode _bindAndCloseAsTree(JsonParser jp) throws IOException {\n        try {\n            return _bindAsTree(jp);\n        } finally {\n            try {\n                jp.close();\n            } catch (IOException ioe) { }\n        }\n    }\n    \n    protected JsonNode _bindAsTree(JsonParser jp) throws IOException {\n        JsonNode result;\n        JsonToken t = _initForReading(jp);\n        if (t == JsonToken.VALUE_NULL || t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {\n            result = NullNode.instance;\n        } else {\n            DeserializationContext ctxt = createDeserializationContext(jp, _config);\n            JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, JSON_NODE_TYPE);\n            if (_unwrapRoot) {\n                result = (JsonNode) _unwrapAndDeserialize(jp, ctxt, JSON_NODE_TYPE, deser);\n            } else {\n                result = (JsonNode) deser.deserialize(jp, ctxt);\n            }\n        }\n        \n        jp.clearCurrentToken();\n        return result;\n    }\n    \n    \n    protected <T> MappingIterator<T> _bindAndReadValues(JsonParser p, Object valueToUpdate) throws IOException {\n        _initForMultiRead(p);\n        p.nextToken();\n        DeserializationContext ctxt = createDeserializationContext(p, _config);\n        return _newIterator(_valueType, p, ctxt, \n                _findRootDeserializer(ctxt, _valueType), true, _valueToUpdate);\n    }\n\n    protected Object _unwrapAndDeserialize(JsonParser jp, DeserializationContext ctxt, JavaType rootType, JsonDeserializer<Object> deser) throws IOException {\n        String expName = _config.getRootName();\n        if (expName == null) {\n            PropertyName pname = _rootNames.findRootName(rootType, _config);\n            expName = pname.getSimpleName();\n        }\n        if (jp.getCurrentToken() != JsonToken.START_OBJECT) {\n            throw JsonMappingException.from(jp, \"Current token not START_OBJECT (needed to unwrap root name '\"\n                    +expName+\"'), but \"+jp.getCurrentToken());\n        }\n        if (jp.nextToken() != JsonToken.FIELD_NAME) {\n            throw JsonMappingException.from(jp, \"Current token not FIELD_NAME (to contain expected root name '\"\n                    +expName+\"'), but \"+jp.getCurrentToken());\n        }\n        String actualName = jp.getCurrentName();\n        if (!expName.equals(actualName)) {\n            throw JsonMappingException.from(jp, \"Root name '\"+actualName+\"' does not match expected ('\"\n                    +expName+\"') for type \"+rootType);\n        }\n        \n        jp.nextToken();\n        Object result;\n        if (_valueToUpdate == null) {\n            result = deser.deserialize(jp, ctxt);\n        } else {\n            deser.deserialize(jp, ctxt, _valueToUpdate);\n            result = _valueToUpdate;                    \n        }\n        \n        if (jp.nextToken() != JsonToken.END_OBJECT) {\n            throw JsonMappingException.from(jp, \"Current token not END_OBJECT (to match wrapper object with root name '\"\n                    +expName+\"'), but \"+jp.getCurrentToken());\n        }\n        return result;\n    }\n\n    \n    \n    \n    protected JsonDeserializer<Object> _findRootDeserializer(DeserializationContext ctxt, JavaType valueType) throws JsonMappingException {\n        if (_rootDeserializer != null) {\n            return _rootDeserializer;\n        }\n\n        \n        if (valueType == null) {\n            throw new JsonMappingException(\"No value type configured for ObjectReader\");\n        }\n        \n        \n        JsonDeserializer<Object> deser = _rootDeserializers.get(valueType);\n        if (deser != null) {\n            return deser;\n        }\n        \n        deser = ctxt.findRootValueDeserializer(valueType);\n        if (deser == null) { \n            throw new JsonMappingException(\"Can not find a deserializer for type \"+valueType);\n        }\n        _rootDeserializers.put(valueType, deser);\n        return deser;\n    }\n\n    \n            \n\n    \n    protected JsonDeserializer<Object> _prefetchRootDeserializer(DeserializationConfig config, JavaType valueType) {\n        if (valueType == null || !_config.isEnabled(DeserializationFeature.EAGER_DESERIALIZER_FETCH)) {\n            return null;\n        }\n        \n        JsonDeserializer<Object> deser = _rootDeserializers.get(valueType);\n        if (deser == null) {\n            try {\n                \n                DeserializationContext ctxt = createDeserializationContext(null, _config);\n                deser = ctxt.findRootValueDeserializer(valueType);\n                if (deser != null) {\n                    _rootDeserializers.put(valueType, deser);\n                }\n                return deser;\n                \n            } catch (JsonProcessingException e) {\n                \n            }\n        }\n        return deser;\n    }\n\n    \n    \n    @SuppressWarnings(\"resource\")\n    protected Object _detectBindAndClose(byte[] src, int offset, int length) throws IOException {\n        DataFormatReaders.Match match = _dataFormatReaders.findFormat(src, offset, length);\n        if (!match.hasMatch()) {\n            _reportUnkownFormat(_dataFormatReaders, match);\n        }\n        JsonParser jp = match.createParserWithMatch();\n        return match.getReader()._bindAndClose(jp, _valueToUpdate);\n    }\n\n    @SuppressWarnings(\"resource\")\n    protected Object _detectBindAndClose(DataFormatReaders.Match match, boolean forceClosing) throws IOException {\n        if (!match.hasMatch()) {\n            _reportUnkownFormat(_dataFormatReaders, match);\n        }\n        JsonParser p = match.createParserWithMatch();\n        \n        \n        if (forceClosing) {\n            p.enable(JsonParser.Feature.AUTO_CLOSE_SOURCE);\n        }\n        \n        return match.getReader()._bindAndClose(p, _valueToUpdate);\n    }\n\n    @SuppressWarnings(\"resource\")\n    protected <T> MappingIterator<T> _detectBindAndReadValues(DataFormatReaders.Match match, boolean forceClosing) throws IOException, JsonProcessingException {\n        if (!match.hasMatch()) {\n            _reportUnkownFormat(_dataFormatReaders, match);\n        }\n        JsonParser p = match.createParserWithMatch();\n        \n        \n        if (forceClosing) {\n            p.enable(JsonParser.Feature.AUTO_CLOSE_SOURCE);\n        }\n        \n        return match.getReader()._bindAndReadValues(p, _valueToUpdate);\n    }\n    \n    @SuppressWarnings(\"resource\")\n    protected JsonNode _detectBindAndCloseAsTree(InputStream in) throws IOException {\n        DataFormatReaders.Match match = _dataFormatReaders.findFormat(in);\n        if (!match.hasMatch()) {\n            _reportUnkownFormat(_dataFormatReaders, match);\n        }\n        JsonParser p = match.createParserWithMatch();\n        p.enable(JsonParser.Feature.AUTO_CLOSE_SOURCE);\n        return match.getReader()._bindAndCloseAsTree(p);\n    }\n    \n    \n    protected void _reportUnkownFormat(DataFormatReaders detector, DataFormatReaders.Match match) throws JsonProcessingException {\n        throw new JsonParseException(\"Can not detect format from input, does not look like any of detectable formats \"\n                +detector.toString(),\n                JsonLocation.NA);\n    }\n    \n    \n\n    \n    protected void _verifySchemaType(FormatSchema schema) {\n        if (schema != null) {\n            if (!_parserFactory.canUseSchema(schema)) {\n                    throw new IllegalArgumentException(\"Can not use FormatSchema of type \"+schema.getClass().getName()\n                            +\" for format \"+_parserFactory.getFormatName());\n            }\n        }\n    }\n\n    \n    protected DefaultDeserializationContext createDeserializationContext(JsonParser jp, DeserializationConfig cfg) {\n        \n        return _context.createInstance(cfg, jp, _injectableValues);\n    }\n\n    protected void _reportUndetectableSource(Object src) throws JsonProcessingException {\n        throw new JsonParseException(\"Can not use source of type \"\n                +src.getClass().getName()+\" with format auto-detection: must be byte- not char-based\",\n                JsonLocation.NA);\n    }\n\n    protected InputStream _inputStream(URL src) throws IOException {\n        return src.openStream();\n    }\n\n    protected InputStream _inputStream(File f) throws IOException {\n        return new FileInputStream(f);\n    }\n}\n",
      "fixed_full_code": "package com.fasterxml.jackson.databind;\n\nimport java.io.*;\nimport java.net.URL;\nimport java.util.Iterator;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.TimeZone;\nimport java.util.concurrent.ConcurrentHashMap;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.type.ResolvedType;\nimport com.fasterxml.jackson.core.type.TypeReference;\nimport com.fasterxml.jackson.databind.cfg.ContextAttributes;\nimport com.fasterxml.jackson.databind.deser.DataFormatReaders;\nimport com.fasterxml.jackson.databind.deser.DefaultDeserializationContext;\nimport com.fasterxml.jackson.databind.deser.DeserializationProblemHandler;\nimport com.fasterxml.jackson.databind.node.JsonNodeFactory;\nimport com.fasterxml.jackson.databind.node.NullNode;\nimport com.fasterxml.jackson.databind.node.TreeTraversingParser;\nimport com.fasterxml.jackson.databind.type.SimpleType;\nimport com.fasterxml.jackson.databind.type.TypeFactory;\nimport com.fasterxml.jackson.databind.util.RootNameLookup;\n\n\npublic class ObjectReader extends ObjectCodec implements Versioned, java.io.Serializable { private static final long serialVersionUID = 1L; private final static JavaType JSON_NODE_TYPE = SimpleType.constructUnsafe(JsonNode.class); protected final DeserializationConfig _config; protected final DefaultDeserializationContext _context; protected final JsonFactory _parserFactory; protected final boolean _unwrapRoot; protected final JavaType _valueType; protected final JsonDeserializer<Object> _rootDeserializer; protected final Object _valueToUpdate; protected final FormatSchema _schema; protected final InjectableValues _injectableValues; protected final DataFormatReaders _dataFormatReaders; final protected ConcurrentHashMap<JavaType, JsonDeserializer<Object>> _rootDeserializers; protected final RootNameLookup _rootNames; protected ObjectReader(ObjectMapper mapper, DeserializationConfig config) {\n        this(mapper, config, null, null, null, null);\n    }\n\n    \n    protected ObjectReader(ObjectMapper mapper, DeserializationConfig config, JavaType valueType, Object valueToUpdate, FormatSchema schema, InjectableValues injectableValues) {\n        _config = config;\n        _context = mapper._deserializationContext;\n        _rootDeserializers = mapper._rootDeserializers;\n        _parserFactory = mapper._jsonFactory;\n        _rootNames = mapper._rootNames;\n        _valueType = valueType;\n        _valueToUpdate = valueToUpdate;\n        if (valueToUpdate != null && valueType.isArrayType()) {\n            throw new IllegalArgumentException(\"Can not update an array value\");\n        }\n        _schema = schema;\n        _injectableValues = injectableValues;\n        _unwrapRoot = config.useRootWrapping();\n\n        _rootDeserializer = _prefetchRootDeserializer(config, valueType);\n        _dataFormatReaders = null;        \n    }\n    \n    \n    protected ObjectReader(ObjectReader base, DeserializationConfig config, JavaType valueType, JsonDeserializer<Object> rootDeser, Object valueToUpdate, FormatSchema schema, InjectableValues injectableValues, DataFormatReaders dataFormatReaders) {\n        _config = config;\n        _context = base._context;\n\n        _rootDeserializers = base._rootDeserializers;\n        _parserFactory = base._parserFactory;\n        _rootNames = base._rootNames;\n\n        _valueType = valueType;\n        _rootDeserializer = rootDeser;\n        _valueToUpdate = valueToUpdate;\n        if (valueToUpdate != null && valueType.isArrayType()) {\n            throw new IllegalArgumentException(\"Can not update an array value\");\n        }\n        _schema = schema;\n        _injectableValues = injectableValues;\n        _unwrapRoot = config.useRootWrapping();\n        _dataFormatReaders = dataFormatReaders;\n    }\n\n    \n    protected ObjectReader(ObjectReader base, DeserializationConfig config) {\n        _config = config;\n        _context = base._context;\n\n        _rootDeserializers = base._rootDeserializers;\n        _parserFactory = base._parserFactory;\n        _rootNames = base._rootNames;\n\n        _valueType = base._valueType;\n        _rootDeserializer = base._rootDeserializer;\n        _valueToUpdate = base._valueToUpdate;\n        _schema = base._schema;\n        _injectableValues = base._injectableValues;\n        _unwrapRoot = config.useRootWrapping();\n        _dataFormatReaders = base._dataFormatReaders;\n    }\n    \n    protected ObjectReader(ObjectReader base, JsonFactory f) {\n        \n        _config = base._config\n            .with(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY, f.requiresPropertyOrdering());\n        _context = base._context;\n\n        _rootDeserializers = base._rootDeserializers;\n        _parserFactory = f;\n        _rootNames = base._rootNames;\n\n        _valueType = base._valueType;\n        _rootDeserializer = base._rootDeserializer;\n        _valueToUpdate = base._valueToUpdate;\n        _schema = base._schema;\n        _injectableValues = base._injectableValues;\n        _unwrapRoot = base._unwrapRoot;\n        _dataFormatReaders = base._dataFormatReaders;\n    }\n    \n    \n    @Override\n    public Version version() {\n        return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION;\n    }\n\n    \n\n    \n    protected ObjectReader _new(ObjectReader base, JsonFactory f) {\n        return new ObjectReader(base, f);\n    }\n\n    \n    protected ObjectReader _new(ObjectReader base, DeserializationConfig config) {\n        return new ObjectReader(base, config);\n    }\n\n    \n    protected ObjectReader _new(ObjectReader base, DeserializationConfig config, JavaType valueType, JsonDeserializer<Object> rootDeser, Object valueToUpdate, FormatSchema schema, InjectableValues injectableValues, DataFormatReaders dataFormatReaders) {\n        return new ObjectReader(base, config, valueType, rootDeser,  valueToUpdate,\n                 schema,  injectableValues, dataFormatReaders);\n    }\n\n    \n    protected <T> MappingIterator<T> _newIterator(JavaType valueType, JsonParser parser, DeserializationContext ctxt, JsonDeserializer<?> deser, boolean parserManaged, Object valueToUpdate) {\n            return new MappingIterator<T>(valueType, parser, ctxt,\n                    deser, parserManaged, valueToUpdate);\n    }\n\n    \n\n    \n    protected JsonToken _initForReading(JsonParser p) throws IOException {\n        if (_schema != null) {\n            p.setSchema(_schema);\n        }\n        _config.initialize(p); \n\n        \n        JsonToken t = p.getCurrentToken();\n        if (t == null) { \n            t = p.nextToken();\n            if (t == null) {\n                \n                throw JsonMappingException.from(p, \"No content to map due to end-of-input\");\n            }\n        }\n        return t;\n    }\n\n    \n    protected void _initForMultiRead(JsonParser p) throws IOException {\n        if (_schema != null) {\n            p.setSchema(_schema);\n        }\n        _config.initialize(p); \n    }\n\n    \n\n    \n    public ObjectReader with(DeserializationFeature feature) {\n        return _with(_config.with(feature));\n    }\n\n    \n    public ObjectReader with(DeserializationFeature first, DeserializationFeature... other) {\n        return _with(_config.with(first, other));\n    }    \n\n    \n    public ObjectReader withFeatures(DeserializationFeature... features) {\n        return _with(_config.withFeatures(features));\n    }    \n\n    \n    public ObjectReader without(DeserializationFeature feature) {\n        return _with(_config.without(feature)); \n    }\n\n    \n    public ObjectReader without(DeserializationFeature first, DeserializationFeature... other) {\n        return _with(_config.without(first, other));\n    }    \n\n    \n    public ObjectReader withoutFeatures(DeserializationFeature... features) {\n        return _with(_config.withoutFeatures(features));\n    }    \n\n    \n\n    \n    public ObjectReader with(JsonParser.Feature feature) {\n        return _with(_config.with(feature));\n    }\n\n    \n    public ObjectReader withFeatures(JsonParser.Feature... features) {\n        return _with(_config.withFeatures(features));\n    }    \n\n    \n    public ObjectReader without(JsonParser.Feature feature) {\n        return _with(_config.without(feature)); \n    }\n\n    \n    public ObjectReader withoutFeatures(JsonParser.Feature... features) {\n        return _with(_config.withoutFeatures(features));\n    }\n\n    \n\n    public ObjectReader with(DeserializationConfig config) {\n        return _with(config);\n    }    \n\n    \n    public ObjectReader with(InjectableValues injectableValues) {\n        if (_injectableValues == injectableValues) {\n            return this;\n        }\n        return _new(this, _config,\n                _valueType, _rootDeserializer, _valueToUpdate,\n                _schema, injectableValues, _dataFormatReaders);\n    }\n\n    \n    public ObjectReader with(JsonNodeFactory f) {\n        return _with(_config.with(f));\n    }\n\n    \n    public ObjectReader with(JsonFactory f) {\n        if (f == _parserFactory) {\n            return this;\n        }\n        ObjectReader r = _new(this, f);\n        \n        if (f.getCodec() == null) {\n            f.setCodec(r);\n        }\n        return r;\n    }\n    \n    \n    public ObjectReader withRootName(String rootName) {\n        return _with(_config.withRootName(rootName));\n    }\n\n    \n    public ObjectReader with(FormatSchema schema) {\n        if (_schema == schema) {\n            return this;\n        }\n        _verifySchemaType(schema);\n        return _new(this, _config, _valueType, _rootDeserializer, _valueToUpdate,\n                schema, _injectableValues, _dataFormatReaders);\n    }\n\n    \n    public ObjectReader forType(JavaType valueType) {\n        if (valueType != null && valueType.equals(_valueType)) {\n            return this;\n        }\n        JsonDeserializer<Object> rootDeser = _prefetchRootDeserializer(_config, valueType);\n        \n        DataFormatReaders det = _dataFormatReaders;\n        if (det != null) {\n            det = det.withType(valueType);\n        }\n        return _new(this, _config, valueType, rootDeser,\n                _valueToUpdate, _schema, _injectableValues, det);\n    }    \n\n    \n    public ObjectReader forType(Class<?> valueType) {\n        return forType(_config.constructType(valueType));\n    }    \n\n    \n    public ObjectReader forType(TypeReference<?> valueTypeRef) {\n        return forType(_config.getTypeFactory().constructType(valueTypeRef.getType()));\n    }    \n\n    \n    @Deprecated\n    public ObjectReader withType(JavaType valueType) {\n        return forType(valueType);\n    }\n\n    \n    @Deprecated\n    public ObjectReader withType(Class<?> valueType) {\n        return forType(_config.constructType(valueType));\n    }    \n\n    \n    @Deprecated\n    public ObjectReader withType(java.lang.reflect.Type valueType) {\n        return forType(_config.getTypeFactory().constructType(valueType));\n    }\n\n    \n    @Deprecated\n    public ObjectReader withType(TypeReference<?> valueTypeRef) {\n        return forType(_config.getTypeFactory().constructType(valueTypeRef.getType()));\n    }    \n\n    \n    public ObjectReader withValueToUpdate(Object value) {\n        if (value == _valueToUpdate) return this;\n        if (value == null) {\n            throw new IllegalArgumentException(\"cat not update null value\");\n        }\n        JavaType t;\n        \n        \n        if (_valueType == null) {\n            t = _config.constructType(value.getClass());\n        } else {\n            t = _valueType;\n        }\n        return _new(this, _config, t, _rootDeserializer, value,\n                _schema, _injectableValues, _dataFormatReaders);\n    }\n\n    \n    public ObjectReader withView(Class<?> activeView) {\n        return _with(_config.withView(activeView));\n    }\n\n    public ObjectReader with(Locale l) {\n        return _with(_config.with(l));\n    }\n\n    public ObjectReader with(TimeZone tz) {\n        return _with(_config.with(tz));\n    }\n\n    public ObjectReader withHandler(DeserializationProblemHandler h) {\n        return _with(_config.withHandler(h));\n    }\n\n    public ObjectReader with(Base64Variant defaultBase64) {\n        return _with(_config.with(defaultBase64));\n    }\n\n    \n    public ObjectReader withFormatDetection(ObjectReader... readers) {\n        return withFormatDetection(new DataFormatReaders(readers));\n    }\n\n    \n    public ObjectReader withFormatDetection(DataFormatReaders readers) {\n        return _new(this, _config, _valueType, _rootDeserializer, _valueToUpdate,\n                _schema, _injectableValues, readers);\n    }\n\n    \n    public ObjectReader with(ContextAttributes attrs) {\n        return _with(_config.with(attrs));\n    }\n\n    \n    public ObjectReader withAttributes(Map<Object,Object> attrs) {\n        return _with(_config.withAttributes(attrs));\n    }\n\n    \n    public ObjectReader withAttribute(Object key, Object value) {\n        return _with( _config.withAttribute(key, value));\n    }\n\n    \n    public ObjectReader withoutAttribute(Object key) {\n        return _with(_config.withoutAttribute(key));\n    }\n\n    \n    \n    protected ObjectReader _with(DeserializationConfig newConfig) {\n        if (newConfig == _config) {\n            return this;\n        }\n        ObjectReader r = _new(this, newConfig);\n        if (_dataFormatReaders != null) {\n            r  = r.withFormatDetection(_dataFormatReaders.with(newConfig));\n        }\n        return r;\n    }\n    \n    \n    \n    public boolean isEnabled(DeserializationFeature f) {\n        return _config.isEnabled(f);\n    }\n\n    public boolean isEnabled(MapperFeature f) {\n        return _config.isEnabled(f);\n    }\n\n    public boolean isEnabled(JsonParser.Feature f) {\n        return _parserFactory.isEnabled(f);\n    }\n\n    \n    public DeserializationConfig getConfig() {\n        return _config;\n    }\n    \n    \n    @Override\n    public JsonFactory getFactory() {\n        return _parserFactory;\n    }\n    \n    \n    @Deprecated\n    @Override\n    public JsonFactory getJsonFactory() {\n        return _parserFactory;\n    }\n\n    public TypeFactory getTypeFactory() {\n        return _config.getTypeFactory();\n    }\n\n    \n    public ContextAttributes getAttributes() {\n        return _config.getAttributes();\n    }\n    \n    \n\n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(JsonParser jp) throws IOException, JsonProcessingException {\n        return (T) _bind(jp, _valueToUpdate);\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public <T> T readValue(JsonParser jp, Class<T> valueType) throws IOException, JsonProcessingException {\n        return (T) withType(valueType).readValue(jp);\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public <T> T readValue(JsonParser jp, TypeReference<?> valueTypeRef) throws IOException, JsonProcessingException {\n        return (T) withType(valueTypeRef).readValue(jp);\n    }\n\n    \n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(JsonParser jp, ResolvedType valueType) throws IOException, JsonProcessingException {\n        return (T) withType((JavaType)valueType).readValue(jp);\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(JsonParser jp, JavaType valueType) throws IOException, JsonProcessingException {\n        return (T) withType(valueType).readValue(jp);\n    }\n\n    \n    @Override\n    public <T> Iterator<T> readValues(JsonParser jp, Class<T> valueType) throws IOException, JsonProcessingException {\n        return withType(valueType).readValues(jp);\n    }\n\n    \n    @Override\n    public <T> Iterator<T> readValues(JsonParser jp, TypeReference<?> valueTypeRef) throws IOException, JsonProcessingException {\n        return withType(valueTypeRef).readValues(jp);\n    }\n    \n    \n    @Override\n    public <T> Iterator<T> readValues(JsonParser jp, ResolvedType valueType) throws IOException, JsonProcessingException {\n        return readValues(jp, (JavaType) valueType);\n    }\n\n    \n    public <T> Iterator<T> readValues(JsonParser jp, JavaType valueType) throws IOException, JsonProcessingException {\n        return withType(valueType).readValues(jp);\n    }\n\n    \n\n    @Override\n    public JsonNode createArrayNode() {\n        return _config.getNodeFactory().arrayNode();\n    }\n\n    @Override\n    public JsonNode createObjectNode() {\n        return _config.getNodeFactory().objectNode();\n    }\n\n    @Override\n    public JsonParser treeAsTokens(TreeNode n) {\n        return new TreeTraversingParser((JsonNode) n, this);\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public <T extends TreeNode> T readTree(JsonParser jp) throws IOException, JsonProcessingException {\n        return (T) _bindAsTree(jp);\n    }\n     \n    @Override\n    public void writeTree(JsonGenerator jgen, TreeNode rootNode) {\n        throw new UnsupportedOperationException();\n    }\n    \n    \n    \n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(InputStream src) throws IOException, JsonProcessingException {\n        if (_dataFormatReaders != null) {\n            return (T) _detectBindAndClose(_dataFormatReaders.findFormat(src), false);\n        }\n        return (T) _bindAndClose(_parserFactory.createParser(src), _valueToUpdate);\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(Reader src) throws IOException, JsonProcessingException {\n        if (_dataFormatReaders != null) {\n            _reportUndetectableSource(src);\n        }\n        return (T) _bindAndClose(_parserFactory.createParser(src), _valueToUpdate);\n    }\n    \n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(String src) throws IOException, JsonProcessingException {\n        if (_dataFormatReaders != null) {\n            _reportUndetectableSource(src);\n        }\n        return (T) _bindAndClose(_parserFactory.createParser(src), _valueToUpdate);\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(byte[] src) throws IOException, JsonProcessingException {\n        if (_dataFormatReaders != null) {\n            return (T) _detectBindAndClose(src, 0, src.length);\n        }\n        return (T) _bindAndClose(_parserFactory.createParser(src), _valueToUpdate);\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(byte[] src, int offset, int length) throws IOException, JsonProcessingException {\n        if (_dataFormatReaders != null) {\n            return (T) _detectBindAndClose(src, offset, length);\n        }\n        return (T) _bindAndClose(_parserFactory.createParser(src, offset, length), _valueToUpdate);\n    }\n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(File src) throws IOException, JsonProcessingException {\n        if (_dataFormatReaders != null) {\n            return (T) _detectBindAndClose(_dataFormatReaders.findFormat(_inputStream(src)), true);\n        }\n        return (T) _bindAndClose(_parserFactory.createParser(src), _valueToUpdate);\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(URL src) throws IOException, JsonProcessingException {\n        if (_dataFormatReaders != null) {\n            return (T) _detectBindAndClose(_dataFormatReaders.findFormat(_inputStream(src)), true);\n        }\n        return (T) _bindAndClose(_parserFactory.createParser(src), _valueToUpdate);\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(JsonNode src) throws IOException, JsonProcessingException {\n        if (_dataFormatReaders != null) {\n            _reportUndetectableSource(src);\n        }\n        return (T) _bindAndClose(treeAsTokens(src), _valueToUpdate);\n    }\n    \n    \n    public JsonNode readTree(InputStream in) throws IOException, JsonProcessingException {\n        if (_dataFormatReaders != null) {\n            return _detectBindAndCloseAsTree(in);\n        }\n        return _bindAndCloseAsTree(_parserFactory.createParser(in));\n    }\n    \n    \n    public JsonNode readTree(Reader r) throws IOException, JsonProcessingException {\n        if (_dataFormatReaders != null) {\n            _reportUndetectableSource(r);\n        }\n        return _bindAndCloseAsTree(_parserFactory.createParser(r));\n    }\n\n    \n    public JsonNode readTree(String json) throws IOException, JsonProcessingException {\n        if (_dataFormatReaders != null) {\n            _reportUndetectableSource(json);\n        }\n        return _bindAndCloseAsTree(_parserFactory.createParser(json));\n    }\n\n    \n    \n    \n    public <T> MappingIterator<T> readValues(JsonParser jp) throws IOException, JsonProcessingException {\n        DeserializationContext ctxt = createDeserializationContext(jp, _config);\n        \n        return _newIterator(_valueType, jp, ctxt,\n                _findRootDeserializer(ctxt, _valueType),\n                false, _valueToUpdate);\n    }\n    \n    \n    public <T> MappingIterator<T> readValues(InputStream src) throws IOException, JsonProcessingException {\n        if (_dataFormatReaders != null) {\n            return _detectBindAndReadValues(_dataFormatReaders.findFormat(src), false);\n        }\n        return _bindAndReadValues(_parserFactory.createParser(src), _valueToUpdate);\n    }\n    \n    \n    @SuppressWarnings(\"resource\")\n    public <T> MappingIterator<T> readValues(Reader src) throws IOException, JsonProcessingException {\n        if (_dataFormatReaders != null) {\n            _reportUndetectableSource(src);\n        }\n        JsonParser p = _parserFactory.createParser(src);\n        _initForMultiRead(p);\n        p.nextToken();\n        DeserializationContext ctxt = createDeserializationContext(p, _config);\n        return _newIterator(_valueType, p, ctxt,\n                _findRootDeserializer(ctxt, _valueType), true, _valueToUpdate);\n    }\n    \n    \n    @SuppressWarnings(\"resource\")\n    public <T> MappingIterator<T> readValues(String json) throws IOException, JsonProcessingException {\n        if (_dataFormatReaders != null) {\n            _reportUndetectableSource(json);\n        }\n        JsonParser p = _parserFactory.createParser(json);\n        _initForMultiRead(p);\n        p.nextToken();\n        DeserializationContext ctxt = createDeserializationContext(p, _config);\n        return _newIterator(_valueType, p, ctxt,\n                _findRootDeserializer(ctxt, _valueType), true, _valueToUpdate);\n    }\n\n    \n    public <T> MappingIterator<T> readValues(byte[] src, int offset, int length) throws IOException, JsonProcessingException {\n        if (_dataFormatReaders != null) {\n            return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n        }\n        return _bindAndReadValues(_parserFactory.createParser(src), _valueToUpdate);\n    }\n\n    \n    public final <T> MappingIterator<T> readValues(byte[] src) throws IOException, JsonProcessingException {\n        return readValues(src, 0, src.length);\n    }\n    \n    \n    public <T> MappingIterator<T> readValues(File src) throws IOException, JsonProcessingException {\n        if (_dataFormatReaders != null) {\n            return _detectBindAndReadValues(\n                    _dataFormatReaders.findFormat(_inputStream(src)), false);\n        }\n        return _bindAndReadValues(_parserFactory.createParser(src), _valueToUpdate);\n    }\n\n    \n    public <T> MappingIterator<T> readValues(URL src) throws IOException, JsonProcessingException {\n        if (_dataFormatReaders != null) {\n            return _detectBindAndReadValues(\n                    _dataFormatReaders.findFormat(_inputStream(src)), true);\n        }\n        return _bindAndReadValues(_parserFactory.createParser(src), _valueToUpdate);\n    }\n\n    \n\n    @Override\n    public <T> T treeToValue(TreeNode n, Class<T> valueType) throws JsonProcessingException {\n        try {\n            return readValue(treeAsTokens(n), valueType);\n        } catch (JsonProcessingException e) {\n            throw e;\n        } catch (IOException e) { \n            throw new IllegalArgumentException(e.getMessage(), e);\n        }\n    }    \n    \n    @Override\n    public void writeValue(JsonGenerator jgen, Object value) throws IOException, JsonProcessingException {\n        throw new UnsupportedOperationException(\"Not implemented for ObjectReader\");\n    }\n\n    \n    \n    \n    protected Object _bind(JsonParser jp, Object valueToUpdate) throws IOException {\n        \n        Object result;\n        JsonToken t = _initForReading(jp);\n        if (t == JsonToken.VALUE_NULL) {\n            if (valueToUpdate == null) {\n                DeserializationContext ctxt = createDeserializationContext(jp, _config);\n                result = _findRootDeserializer(ctxt, _valueType).getNullValue();\n            } else {\n                result = valueToUpdate;\n            }\n        } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {\n            result = valueToUpdate;\n        } else { \n            DeserializationContext ctxt = createDeserializationContext(jp, _config);\n            JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, _valueType);\n            if (_unwrapRoot) {\n                result = _unwrapAndDeserialize(jp, ctxt, _valueType, deser);\n            } else {\n                if (valueToUpdate == null) {\n                    result = deser.deserialize(jp, ctxt);\n                } else {\n                    deser.deserialize(jp, ctxt, valueToUpdate);\n                    result = valueToUpdate;\n                }\n            }\n        }\n        \n        jp.clearCurrentToken();\n        return result;\n    }\n    \n    protected Object _bindAndClose(JsonParser jp, Object valueToUpdate) throws IOException {\n        try {\n            Object result;\n            JsonToken t = _initForReading(jp);\n            if (t == JsonToken.VALUE_NULL) {\n                if (valueToUpdate == null) {\n                    DeserializationContext ctxt = createDeserializationContext(jp, _config);\n                    result = _findRootDeserializer(ctxt, _valueType).getNullValue();\n                } else {\n                    result = valueToUpdate;\n                }\n            } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {\n                result = valueToUpdate;\n            } else {\n                DeserializationContext ctxt = createDeserializationContext(jp, _config);\n                JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, _valueType);\n                if (_unwrapRoot) {\n                    result = _unwrapAndDeserialize(jp, ctxt, _valueType, deser);\n                } else {\n                    if (valueToUpdate == null) {\n                        result = deser.deserialize(jp, ctxt);\n                    } else {\n                        deser.deserialize(jp, ctxt, valueToUpdate);\n                        result = valueToUpdate;                    \n                    }\n                }\n            }\n            return result;\n        } finally {\n            try {\n                jp.close();\n            } catch (IOException ioe) { }\n        }\n    }\n\n    protected JsonNode _bindAndCloseAsTree(JsonParser jp) throws IOException {\n        try {\n            return _bindAsTree(jp);\n        } finally {\n            try {\n                jp.close();\n            } catch (IOException ioe) { }\n        }\n    }\n    \n    protected JsonNode _bindAsTree(JsonParser jp) throws IOException {\n        JsonNode result;\n        JsonToken t = _initForReading(jp);\n        if (t == JsonToken.VALUE_NULL || t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {\n            result = NullNode.instance;\n        } else {\n            DeserializationContext ctxt = createDeserializationContext(jp, _config);\n            JsonDeserializer<Object> deser = _findTreeDeserializer(ctxt);\n            if (_unwrapRoot) {\n                result = (JsonNode) _unwrapAndDeserialize(jp, ctxt, JSON_NODE_TYPE, deser);\n            } else {\n                result = (JsonNode) deser.deserialize(jp, ctxt);\n            }\n        }\n        \n        jp.clearCurrentToken();\n        return result;\n    }\n    \n    \n    protected <T> MappingIterator<T> _bindAndReadValues(JsonParser p, Object valueToUpdate) throws IOException {\n        _initForMultiRead(p);\n        p.nextToken();\n        DeserializationContext ctxt = createDeserializationContext(p, _config);\n        return _newIterator(_valueType, p, ctxt, \n                _findRootDeserializer(ctxt, _valueType), true, _valueToUpdate);\n    }\n\n    protected Object _unwrapAndDeserialize(JsonParser jp, DeserializationContext ctxt, JavaType rootType, JsonDeserializer<Object> deser) throws IOException {\n        String expName = _config.getRootName();\n        if (expName == null) {\n            PropertyName pname = _rootNames.findRootName(rootType, _config);\n            expName = pname.getSimpleName();\n        }\n        if (jp.getCurrentToken() != JsonToken.START_OBJECT) {\n            throw JsonMappingException.from(jp, \"Current token not START_OBJECT (needed to unwrap root name '\"\n                    +expName+\"'), but \"+jp.getCurrentToken());\n        }\n        if (jp.nextToken() != JsonToken.FIELD_NAME) {\n            throw JsonMappingException.from(jp, \"Current token not FIELD_NAME (to contain expected root name '\"\n                    +expName+\"'), but \"+jp.getCurrentToken());\n        }\n        String actualName = jp.getCurrentName();\n        if (!expName.equals(actualName)) {\n            throw JsonMappingException.from(jp, \"Root name '\"+actualName+\"' does not match expected ('\"\n                    +expName+\"') for type \"+rootType);\n        }\n        \n        jp.nextToken();\n        Object result;\n        if (_valueToUpdate == null) {\n            result = deser.deserialize(jp, ctxt);\n        } else {\n            deser.deserialize(jp, ctxt, _valueToUpdate);\n            result = _valueToUpdate;                    \n        }\n        \n        if (jp.nextToken() != JsonToken.END_OBJECT) {\n            throw JsonMappingException.from(jp, \"Current token not END_OBJECT (to match wrapper object with root name '\"\n                    +expName+\"'), but \"+jp.getCurrentToken());\n        }\n        return result;\n    }\n\n    \n    \n    \n    protected JsonDeserializer<Object> _findRootDeserializer(DeserializationContext ctxt, JavaType valueType) throws JsonMappingException {\n        if (_rootDeserializer != null) {\n            return _rootDeserializer;\n        }\n\n        \n        if (valueType == null) {\n            throw new JsonMappingException(\"No value type configured for ObjectReader\");\n        }\n        \n        \n        JsonDeserializer<Object> deser = _rootDeserializers.get(valueType);\n        if (deser != null) {\n            return deser;\n        }\n        \n        deser = ctxt.findRootValueDeserializer(valueType);\n        if (deser == null) { \n            throw new JsonMappingException(\"Can not find a deserializer for type \"+valueType);\n        }\n        _rootDeserializers.put(valueType, deser);\n        return deser;\n    }\n\n    \n    protected JsonDeserializer<Object> _findTreeDeserializer(DeserializationContext ctxt) throws JsonMappingException {\n        JsonDeserializer<Object> deser = _rootDeserializers.get(JSON_NODE_TYPE);\n        if (deser == null) {\n            \n            deser = ctxt.findRootValueDeserializer(JSON_NODE_TYPE);\n            if (deser == null) { \n                throw new JsonMappingException(\"Can not find a deserializer for type \"+JSON_NODE_TYPE);\n            }\n            _rootDeserializers.put(JSON_NODE_TYPE, deser);\n        }\n        return deser;\n    }\n\n    \n    protected JsonDeserializer<Object> _prefetchRootDeserializer(DeserializationConfig config, JavaType valueType) {\n        if (valueType == null || !_config.isEnabled(DeserializationFeature.EAGER_DESERIALIZER_FETCH)) {\n            return null;\n        }\n        \n        JsonDeserializer<Object> deser = _rootDeserializers.get(valueType);\n        if (deser == null) {\n            try {\n                \n                DeserializationContext ctxt = createDeserializationContext(null, _config);\n                deser = ctxt.findRootValueDeserializer(valueType);\n                if (deser != null) {\n                    _rootDeserializers.put(valueType, deser);\n                }\n                return deser;\n                \n            } catch (JsonProcessingException e) {\n                \n            }\n        }\n        return deser;\n    }\n\n    \n    \n    @SuppressWarnings(\"resource\")\n    protected Object _detectBindAndClose(byte[] src, int offset, int length) throws IOException {\n        DataFormatReaders.Match match = _dataFormatReaders.findFormat(src, offset, length);\n        if (!match.hasMatch()) {\n            _reportUnkownFormat(_dataFormatReaders, match);\n        }\n        JsonParser jp = match.createParserWithMatch();\n        return match.getReader()._bindAndClose(jp, _valueToUpdate);\n    }\n\n    @SuppressWarnings(\"resource\")\n    protected Object _detectBindAndClose(DataFormatReaders.Match match, boolean forceClosing) throws IOException {\n        if (!match.hasMatch()) {\n            _reportUnkownFormat(_dataFormatReaders, match);\n        }\n        JsonParser p = match.createParserWithMatch();\n        \n        \n        if (forceClosing) {\n            p.enable(JsonParser.Feature.AUTO_CLOSE_SOURCE);\n        }\n        \n        return match.getReader()._bindAndClose(p, _valueToUpdate);\n    }\n\n    @SuppressWarnings(\"resource\")\n    protected <T> MappingIterator<T> _detectBindAndReadValues(DataFormatReaders.Match match, boolean forceClosing) throws IOException, JsonProcessingException {\n        if (!match.hasMatch()) {\n            _reportUnkownFormat(_dataFormatReaders, match);\n        }\n        JsonParser p = match.createParserWithMatch();\n        \n        \n        if (forceClosing) {\n            p.enable(JsonParser.Feature.AUTO_CLOSE_SOURCE);\n        }\n        \n        return match.getReader()._bindAndReadValues(p, _valueToUpdate);\n    }\n    \n    @SuppressWarnings(\"resource\")\n    protected JsonNode _detectBindAndCloseAsTree(InputStream in) throws IOException {\n        DataFormatReaders.Match match = _dataFormatReaders.findFormat(in);\n        if (!match.hasMatch()) {\n            _reportUnkownFormat(_dataFormatReaders, match);\n        }\n        JsonParser p = match.createParserWithMatch();\n        p.enable(JsonParser.Feature.AUTO_CLOSE_SOURCE);\n        return match.getReader()._bindAndCloseAsTree(p);\n    }\n    \n    \n    protected void _reportUnkownFormat(DataFormatReaders detector, DataFormatReaders.Match match) throws JsonProcessingException {\n        throw new JsonParseException(\"Can not detect format from input, does not look like any of detectable formats \"\n                +detector.toString(),\n                JsonLocation.NA);\n    }\n    \n    \n\n    \n    protected void _verifySchemaType(FormatSchema schema) {\n        if (schema != null) {\n            if (!_parserFactory.canUseSchema(schema)) {\n                    throw new IllegalArgumentException(\"Can not use FormatSchema of type \"+schema.getClass().getName()\n                            +\" for format \"+_parserFactory.getFormatName());\n            }\n        }\n    }\n\n    \n    protected DefaultDeserializationContext createDeserializationContext(JsonParser jp, DeserializationConfig cfg) {\n        \n        return _context.createInstance(cfg, jp, _injectableValues);\n    }\n\n    protected void _reportUndetectableSource(Object src) throws JsonProcessingException {\n        throw new JsonParseException(\"Can not use source of type \"\n                +src.getClass().getName()+\" with format auto-detection: must be byte- not char-based\",\n                JsonLocation.NA);\n    }\n\n    protected InputStream _inputStream(URL src) throws IOException {\n        return src.openStream();\n    }\n\n    protected InputStream _inputStream(File f) throws IOException {\n        return new FileInputStream(f);\n    }\n}\n",
      "buggy_signatures": [
        "protected ObjectReader(ObjectMapper mapper, DeserializationConfig config, JavaType valueType, Object valueToUpdate, FormatSchema schema, InjectableValues injectableValues)",
        "protected ObjectReader(ObjectReader base, DeserializationConfig config, JavaType valueType, JsonDeserializer<Object> rootDeser, Object valueToUpdate, FormatSchema schema, InjectableValues injectableValues, DataFormatReaders dataFormatReaders)",
        "protected ObjectReader(ObjectReader base, DeserializationConfig config)",
        "protected ObjectReader(ObjectReader base, JsonFactory f)",
        "public Version version()",
        "protected ObjectReader _new(ObjectReader base, JsonFactory f)",
        "protected ObjectReader _new(ObjectReader base, DeserializationConfig config)",
        "protected ObjectReader _new(ObjectReader base, DeserializationConfig config, JavaType valueType, JsonDeserializer<Object> rootDeser, Object valueToUpdate, FormatSchema schema, InjectableValues injectableValues, DataFormatReaders dataFormatReaders)",
        "protected <T> MappingIterator<T> _newIterator(JavaType valueType, JsonParser parser, DeserializationContext ctxt, JsonDeserializer<?> deser, boolean parserManaged, Object valueToUpdate)",
        "protected JsonToken _initForReading(JsonParser p) throws IOException",
        "protected void _initForMultiRead(JsonParser p) throws IOException",
        "public ObjectReader with(DeserializationFeature feature)",
        "public ObjectReader with(DeserializationFeature first, DeserializationFeature... other)",
        "public ObjectReader withFeatures(DeserializationFeature... features)",
        "public ObjectReader without(DeserializationFeature feature)",
        "public ObjectReader without(DeserializationFeature first, DeserializationFeature... other)",
        "public ObjectReader withoutFeatures(DeserializationFeature... features)",
        "public ObjectReader with(JsonParser.Feature feature)",
        "public ObjectReader withFeatures(JsonParser.Feature... features)",
        "public ObjectReader without(JsonParser.Feature feature)",
        "public ObjectReader withoutFeatures(JsonParser.Feature... features)",
        "public ObjectReader with(DeserializationConfig config)",
        "public ObjectReader with(InjectableValues injectableValues)",
        "public ObjectReader with(JsonNodeFactory f)",
        "public ObjectReader with(JsonFactory f)",
        "public ObjectReader withRootName(String rootName)",
        "public ObjectReader with(FormatSchema schema)",
        "public ObjectReader forType(JavaType valueType)",
        "public ObjectReader forType(Class<?> valueType)",
        "public ObjectReader forType(TypeReference<?> valueTypeRef)",
        "public ObjectReader withType(JavaType valueType)",
        "public ObjectReader withType(Class<?> valueType)",
        "public ObjectReader withType(java.lang.reflect.Type valueType)",
        "public ObjectReader withType(TypeReference<?> valueTypeRef)",
        "public ObjectReader withValueToUpdate(Object value)",
        "public ObjectReader withView(Class<?> activeView)",
        "public ObjectReader with(Locale l)",
        "public ObjectReader with(TimeZone tz)",
        "public ObjectReader withHandler(DeserializationProblemHandler h)",
        "public ObjectReader with(Base64Variant defaultBase64)",
        "public ObjectReader withFormatDetection(ObjectReader... readers)",
        "public ObjectReader withFormatDetection(DataFormatReaders readers)",
        "public ObjectReader with(ContextAttributes attrs)",
        "public ObjectReader withAttributes(Map<Object,Object> attrs)",
        "public ObjectReader withAttribute(Object key, Object value)",
        "public ObjectReader withoutAttribute(Object key)",
        "protected ObjectReader _with(DeserializationConfig newConfig)",
        "public boolean isEnabled(DeserializationFeature f)",
        "public boolean isEnabled(MapperFeature f)",
        "public boolean isEnabled(JsonParser.Feature f)",
        "public DeserializationConfig getConfig()",
        "public JsonFactory getFactory()",
        "public JsonFactory getJsonFactory()",
        "public TypeFactory getTypeFactory()",
        "public ContextAttributes getAttributes()",
        "public <T> T readValue(JsonParser jp) throws IOException, JsonProcessingException",
        "public <T> T readValue(JsonParser jp, Class<T> valueType) throws IOException, JsonProcessingException",
        "public <T> T readValue(JsonParser jp, TypeReference<?> valueTypeRef) throws IOException, JsonProcessingException",
        "public <T> T readValue(JsonParser jp, ResolvedType valueType) throws IOException, JsonProcessingException",
        "public <T> T readValue(JsonParser jp, JavaType valueType) throws IOException, JsonProcessingException",
        "public <T> Iterator<T> readValues(JsonParser jp, Class<T> valueType) throws IOException, JsonProcessingException",
        "public <T> Iterator<T> readValues(JsonParser jp, TypeReference<?> valueTypeRef) throws IOException, JsonProcessingException",
        "public <T> Iterator<T> readValues(JsonParser jp, ResolvedType valueType) throws IOException, JsonProcessingException",
        "public <T> Iterator<T> readValues(JsonParser jp, JavaType valueType) throws IOException, JsonProcessingException",
        "public JsonNode createArrayNode()",
        "public JsonNode createObjectNode()",
        "public JsonParser treeAsTokens(TreeNode n)",
        "public <T extends TreeNode> T readTree(JsonParser jp) throws IOException, JsonProcessingException",
        "public void writeTree(JsonGenerator jgen, TreeNode rootNode)",
        "public <T> T readValue(InputStream src) throws IOException, JsonProcessingException",
        "public <T> T readValue(Reader src) throws IOException, JsonProcessingException",
        "public <T> T readValue(String src) throws IOException, JsonProcessingException",
        "public <T> T readValue(byte[] src) throws IOException, JsonProcessingException",
        "public <T> T readValue(byte[] src, int offset, int length) throws IOException, JsonProcessingException",
        "public <T> T readValue(File src) throws IOException, JsonProcessingException",
        "public <T> T readValue(URL src) throws IOException, JsonProcessingException",
        "public <T> T readValue(JsonNode src) throws IOException, JsonProcessingException",
        "public JsonNode readTree(InputStream in) throws IOException, JsonProcessingException",
        "public JsonNode readTree(Reader r) throws IOException, JsonProcessingException",
        "public JsonNode readTree(String json) throws IOException, JsonProcessingException",
        "public <T> MappingIterator<T> readValues(JsonParser jp) throws IOException, JsonProcessingException",
        "public <T> MappingIterator<T> readValues(InputStream src) throws IOException, JsonProcessingException",
        "public <T> MappingIterator<T> readValues(Reader src) throws IOException, JsonProcessingException",
        "public <T> MappingIterator<T> readValues(String json) throws IOException, JsonProcessingException",
        "public <T> MappingIterator<T> readValues(byte[] src, int offset, int length) throws IOException, JsonProcessingException",
        "public final <T> MappingIterator<T> readValues(byte[] src) throws IOException, JsonProcessingException",
        "public <T> MappingIterator<T> readValues(File src) throws IOException, JsonProcessingException",
        "public <T> MappingIterator<T> readValues(URL src) throws IOException, JsonProcessingException",
        "public <T> T treeToValue(TreeNode n, Class<T> valueType) throws JsonProcessingException",
        "public void writeValue(JsonGenerator jgen, Object value) throws IOException, JsonProcessingException",
        "protected Object _bind(JsonParser jp, Object valueToUpdate) throws IOException",
        "protected Object _bindAndClose(JsonParser jp, Object valueToUpdate) throws IOException",
        "protected JsonNode _bindAndCloseAsTree(JsonParser jp) throws IOException",
        "protected JsonNode _bindAsTree(JsonParser jp) throws IOException",
        "protected <T> MappingIterator<T> _bindAndReadValues(JsonParser p, Object valueToUpdate) throws IOException",
        "protected Object _unwrapAndDeserialize(JsonParser jp, DeserializationContext ctxt, JavaType rootType, JsonDeserializer<Object> deser) throws IOException",
        "protected JsonDeserializer<Object> _findRootDeserializer(DeserializationContext ctxt, JavaType valueType) throws JsonMappingException",
        "protected JsonDeserializer<Object> _prefetchRootDeserializer(DeserializationConfig config, JavaType valueType)",
        "protected Object _detectBindAndClose(byte[] src, int offset, int length) throws IOException",
        "protected Object _detectBindAndClose(DataFormatReaders.Match match, boolean forceClosing) throws IOException",
        "protected <T> MappingIterator<T> _detectBindAndReadValues(DataFormatReaders.Match match, boolean forceClosing) throws IOException, JsonProcessingException",
        "protected JsonNode _detectBindAndCloseAsTree(InputStream in) throws IOException",
        "protected void _reportUnkownFormat(DataFormatReaders detector, DataFormatReaders.Match match) throws JsonProcessingException",
        "protected void _verifySchemaType(FormatSchema schema)",
        "protected DefaultDeserializationContext createDeserializationContext(JsonParser jp, DeserializationConfig cfg)",
        "protected void _reportUndetectableSource(Object src) throws JsonProcessingException",
        "protected InputStream _inputStream(URL src) throws IOException",
        "protected InputStream _inputStream(File f) throws IOException"
      ],
      "fixed_signatures": [
        "protected ObjectReader(ObjectMapper mapper, DeserializationConfig config, JavaType valueType, Object valueToUpdate, FormatSchema schema, InjectableValues injectableValues)",
        "protected ObjectReader(ObjectReader base, DeserializationConfig config, JavaType valueType, JsonDeserializer<Object> rootDeser, Object valueToUpdate, FormatSchema schema, InjectableValues injectableValues, DataFormatReaders dataFormatReaders)",
        "protected ObjectReader(ObjectReader base, DeserializationConfig config)",
        "protected ObjectReader(ObjectReader base, JsonFactory f)",
        "public Version version()",
        "protected ObjectReader _new(ObjectReader base, JsonFactory f)",
        "protected ObjectReader _new(ObjectReader base, DeserializationConfig config)",
        "protected ObjectReader _new(ObjectReader base, DeserializationConfig config, JavaType valueType, JsonDeserializer<Object> rootDeser, Object valueToUpdate, FormatSchema schema, InjectableValues injectableValues, DataFormatReaders dataFormatReaders)",
        "protected <T> MappingIterator<T> _newIterator(JavaType valueType, JsonParser parser, DeserializationContext ctxt, JsonDeserializer<?> deser, boolean parserManaged, Object valueToUpdate)",
        "protected JsonToken _initForReading(JsonParser p) throws IOException",
        "protected void _initForMultiRead(JsonParser p) throws IOException",
        "public ObjectReader with(DeserializationFeature feature)",
        "public ObjectReader with(DeserializationFeature first, DeserializationFeature... other)",
        "public ObjectReader withFeatures(DeserializationFeature... features)",
        "public ObjectReader without(DeserializationFeature feature)",
        "public ObjectReader without(DeserializationFeature first, DeserializationFeature... other)",
        "public ObjectReader withoutFeatures(DeserializationFeature... features)",
        "public ObjectReader with(JsonParser.Feature feature)",
        "public ObjectReader withFeatures(JsonParser.Feature... features)",
        "public ObjectReader without(JsonParser.Feature feature)",
        "public ObjectReader withoutFeatures(JsonParser.Feature... features)",
        "public ObjectReader with(DeserializationConfig config)",
        "public ObjectReader with(InjectableValues injectableValues)",
        "public ObjectReader with(JsonNodeFactory f)",
        "public ObjectReader with(JsonFactory f)",
        "public ObjectReader withRootName(String rootName)",
        "public ObjectReader with(FormatSchema schema)",
        "public ObjectReader forType(JavaType valueType)",
        "public ObjectReader forType(Class<?> valueType)",
        "public ObjectReader forType(TypeReference<?> valueTypeRef)",
        "public ObjectReader withType(JavaType valueType)",
        "public ObjectReader withType(Class<?> valueType)",
        "public ObjectReader withType(java.lang.reflect.Type valueType)",
        "public ObjectReader withType(TypeReference<?> valueTypeRef)",
        "public ObjectReader withValueToUpdate(Object value)",
        "public ObjectReader withView(Class<?> activeView)",
        "public ObjectReader with(Locale l)",
        "public ObjectReader with(TimeZone tz)",
        "public ObjectReader withHandler(DeserializationProblemHandler h)",
        "public ObjectReader with(Base64Variant defaultBase64)",
        "public ObjectReader withFormatDetection(ObjectReader... readers)",
        "public ObjectReader withFormatDetection(DataFormatReaders readers)",
        "public ObjectReader with(ContextAttributes attrs)",
        "public ObjectReader withAttributes(Map<Object,Object> attrs)",
        "public ObjectReader withAttribute(Object key, Object value)",
        "public ObjectReader withoutAttribute(Object key)",
        "protected ObjectReader _with(DeserializationConfig newConfig)",
        "public boolean isEnabled(DeserializationFeature f)",
        "public boolean isEnabled(MapperFeature f)",
        "public boolean isEnabled(JsonParser.Feature f)",
        "public DeserializationConfig getConfig()",
        "public JsonFactory getFactory()",
        "public JsonFactory getJsonFactory()",
        "public TypeFactory getTypeFactory()",
        "public ContextAttributes getAttributes()",
        "public <T> T readValue(JsonParser jp) throws IOException, JsonProcessingException",
        "public <T> T readValue(JsonParser jp, Class<T> valueType) throws IOException, JsonProcessingException",
        "public <T> T readValue(JsonParser jp, TypeReference<?> valueTypeRef) throws IOException, JsonProcessingException",
        "public <T> T readValue(JsonParser jp, ResolvedType valueType) throws IOException, JsonProcessingException",
        "public <T> T readValue(JsonParser jp, JavaType valueType) throws IOException, JsonProcessingException",
        "public <T> Iterator<T> readValues(JsonParser jp, Class<T> valueType) throws IOException, JsonProcessingException",
        "public <T> Iterator<T> readValues(JsonParser jp, TypeReference<?> valueTypeRef) throws IOException, JsonProcessingException",
        "public <T> Iterator<T> readValues(JsonParser jp, ResolvedType valueType) throws IOException, JsonProcessingException",
        "public <T> Iterator<T> readValues(JsonParser jp, JavaType valueType) throws IOException, JsonProcessingException",
        "public JsonNode createArrayNode()",
        "public JsonNode createObjectNode()",
        "public JsonParser treeAsTokens(TreeNode n)",
        "public <T extends TreeNode> T readTree(JsonParser jp) throws IOException, JsonProcessingException",
        "public void writeTree(JsonGenerator jgen, TreeNode rootNode)",
        "public <T> T readValue(InputStream src) throws IOException, JsonProcessingException",
        "public <T> T readValue(Reader src) throws IOException, JsonProcessingException",
        "public <T> T readValue(String src) throws IOException, JsonProcessingException",
        "public <T> T readValue(byte[] src) throws IOException, JsonProcessingException",
        "public <T> T readValue(byte[] src, int offset, int length) throws IOException, JsonProcessingException",
        "public <T> T readValue(File src) throws IOException, JsonProcessingException",
        "public <T> T readValue(URL src) throws IOException, JsonProcessingException",
        "public <T> T readValue(JsonNode src) throws IOException, JsonProcessingException",
        "public JsonNode readTree(InputStream in) throws IOException, JsonProcessingException",
        "public JsonNode readTree(Reader r) throws IOException, JsonProcessingException",
        "public JsonNode readTree(String json) throws IOException, JsonProcessingException",
        "public <T> MappingIterator<T> readValues(JsonParser jp) throws IOException, JsonProcessingException",
        "public <T> MappingIterator<T> readValues(InputStream src) throws IOException, JsonProcessingException",
        "public <T> MappingIterator<T> readValues(Reader src) throws IOException, JsonProcessingException",
        "public <T> MappingIterator<T> readValues(String json) throws IOException, JsonProcessingException",
        "public <T> MappingIterator<T> readValues(byte[] src, int offset, int length) throws IOException, JsonProcessingException",
        "public final <T> MappingIterator<T> readValues(byte[] src) throws IOException, JsonProcessingException",
        "public <T> MappingIterator<T> readValues(File src) throws IOException, JsonProcessingException",
        "public <T> MappingIterator<T> readValues(URL src) throws IOException, JsonProcessingException",
        "public <T> T treeToValue(TreeNode n, Class<T> valueType) throws JsonProcessingException",
        "public void writeValue(JsonGenerator jgen, Object value) throws IOException, JsonProcessingException",
        "protected Object _bind(JsonParser jp, Object valueToUpdate) throws IOException",
        "protected Object _bindAndClose(JsonParser jp, Object valueToUpdate) throws IOException",
        "protected JsonNode _bindAndCloseAsTree(JsonParser jp) throws IOException",
        "protected JsonNode _bindAsTree(JsonParser jp) throws IOException",
        "protected <T> MappingIterator<T> _bindAndReadValues(JsonParser p, Object valueToUpdate) throws IOException",
        "protected Object _unwrapAndDeserialize(JsonParser jp, DeserializationContext ctxt, JavaType rootType, JsonDeserializer<Object> deser) throws IOException",
        "protected JsonDeserializer<Object> _findRootDeserializer(DeserializationContext ctxt, JavaType valueType) throws JsonMappingException",
        "protected JsonDeserializer<Object> _findTreeDeserializer(DeserializationContext ctxt) throws JsonMappingException",
        "protected JsonDeserializer<Object> _prefetchRootDeserializer(DeserializationConfig config, JavaType valueType)",
        "protected Object _detectBindAndClose(byte[] src, int offset, int length) throws IOException",
        "protected Object _detectBindAndClose(DataFormatReaders.Match match, boolean forceClosing) throws IOException",
        "protected <T> MappingIterator<T> _detectBindAndReadValues(DataFormatReaders.Match match, boolean forceClosing) throws IOException, JsonProcessingException",
        "protected JsonNode _detectBindAndCloseAsTree(InputStream in) throws IOException",
        "protected void _reportUnkownFormat(DataFormatReaders detector, DataFormatReaders.Match match) throws JsonProcessingException",
        "protected void _verifySchemaType(FormatSchema schema)",
        "protected DefaultDeserializationContext createDeserializationContext(JsonParser jp, DeserializationConfig cfg)",
        "protected void _reportUndetectableSource(Object src) throws JsonProcessingException",
        "protected InputStream _inputStream(URL src) throws IOException",
        "protected InputStream _inputStream(File f) throws IOException"
      ],
      "methods": [
        {
          "buggy_method": "  protected JsonNode _bindAsTree(JsonParser jp) throws IOException {\n  JsonNode result;\n  JsonToken t = _initForReading(jp);\n  if (t == JsonToken.VALUE_NULL || t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {\n  result = NullNode.instance;\n  } else {\n  DeserializationContext ctxt = createDeserializationContext(jp, _config);\n  JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, JSON_NODE_TYPE);\n  if (_unwrapRoot) {\n  result = (JsonNode) _unwrapAndDeserialize(jp, ctxt, JSON_NODE_TYPE, deser);\n  } else {\n  result = (JsonNode) deser.deserialize(jp, ctxt);\n  }\n  }\n  \n  jp.clearCurrentToken();\n  return result;\n  }",
          "fixed_method": "  protected JsonNode _bindAsTree(JsonParser jp) throws IOException {\n  JsonNode result;\n  JsonToken t = _initForReading(jp);\n  if (t == JsonToken.VALUE_NULL || t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {\n  result = NullNode.instance;\n  } else {\n  DeserializationContext ctxt = createDeserializationContext(jp, _config);\n  JsonDeserializer<Object> deser = _findTreeDeserializer(ctxt);\n  if (_unwrapRoot) {\n  result = (JsonNode) _unwrapAndDeserialize(jp, ctxt, JSON_NODE_TYPE, deser);\n  } else {\n  result = (JsonNode) deser.deserialize(jp, ctxt);\n  }\n  }\n  \n  jp.clearCurrentToken();\n  return result;\n  }",
          "diff": [
            "@@ -1473,7 +1473,7 @@",
            "             result = NullNode.instance;\n",
            "         } else {\n",
            "             DeserializationContext ctxt = createDeserializationContext(jp, _config);\n",
            "-            JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, JSON_NODE_TYPE);\n",
            "+            JsonDeserializer<Object> deser = _findTreeDeserializer(ctxt);\n",
            "             if (_unwrapRoot) {\n",
            "                 result = (JsonNode) _unwrapAndDeserialize(jp, ctxt, JSON_NODE_TYPE, deser);\n",
            "             } else {\n"
          ],
          "changed_lines": 2
        },
        {
          "buggy_method": "  protected JsonDeserializer<Object> _findRootDeserializer(DeserializationContext ctxt, JavaType valueType) throws JsonMappingException {\n  if (_rootDeserializer != null) {\n  return _rootDeserializer;\n  }\n\n  \n  if (valueType == null) {\n  throw new JsonMappingException(\"No value type configured for ObjectReader\");\n  }\n  \n  \n  JsonDeserializer<Object> deser = _rootDeserializers.get(valueType);\n  if (deser != null) {\n  return deser;\n  }\n  \n  deser = ctxt.findRootValueDeserializer(valueType);\n  if (deser == null) { \n  throw new JsonMappingException(\"Can not find a deserializer for type \"+valueType);\n  }\n  _rootDeserializers.put(valueType, deser);\n  return deser;\n  }",
          "fixed_method": "  protected JsonDeserializer<Object> _findTreeDeserializer(DeserializationContext ctxt) throws JsonMappingException {\n  JsonDeserializer<Object> deser = _rootDeserializers.get(JSON_NODE_TYPE);\n  if (deser == null) {\n  \n  deser = ctxt.findRootValueDeserializer(JSON_NODE_TYPE);\n  if (deser == null) { \n  throw new JsonMappingException(\"Can not find a deserializer for type \"+JSON_NODE_TYPE);\n  }\n  _rootDeserializers.put(JSON_NODE_TYPE, deser);\n  }\n  return deser;\n  }",
          "diff": [
            "@@ -1574,7 +1574,20 @@",
            "     /**\n",
            "      * @since 2.6\n",
            "      */\n",
            "+    protected JsonDeserializer<Object> _findTreeDeserializer(DeserializationContext ctxt)\n",
            "+        throws JsonMappingException\n",
            "+    {\n",
            "+        JsonDeserializer<Object> deser = _rootDeserializers.get(JSON_NODE_TYPE);\n",
            "+        if (deser == null) {\n",
            "             // Nope: need to ask provider to resolve it\n",
            "+            deser = ctxt.findRootValueDeserializer(JSON_NODE_TYPE);\n",
            "+            if (deser == null) { // can this happen?\n",
            "+                throw new JsonMappingException(\"Can not find a deserializer for type \"+JSON_NODE_TYPE);\n",
            "+            }\n",
            "+            _rootDeserializers.put(JSON_NODE_TYPE, deser);\n",
            "+        }\n",
            "+        return deser;\n",
            "+    }\n",
            " \n",
            "     /**\n",
            "      * Method called to locate deserializer ahead of time, if permitted\n"
          ],
          "changed_lines": 13
        }
      ]
    }
  ]
}
