{
  "bug_id": "80",
  "failed_tests": {
    "com.fasterxml.jackson.databind.jsontype.TestTypeNames": [
      {
        "methodName": "testBaseTypeId1616",
        "error": "java.lang.NullPointerException",
        "message": "",
        "fail_line": "        Collection<NamedType> subtypes = new StdSubtypeResolver().collectAndResolveSubtypesByTypeId(",
        "test_source": "  public void testBaseTypeId1616() throws Exception {\n  ObjectMapper mapper = new ObjectMapper();\n  Collection<NamedType> subtypes = new StdSubtypeResolver().collectAndResolveSubtypesByTypeId(\n  mapper.getDeserializationConfig(),\n  // note: `null` is fine here as `AnnotatedMember`:\n  null,\n  mapper.constructType(Base1616.class));\n  assertEquals(2, subtypes.size());\n  Set<String> ok = new HashSet<>(Arrays.asList(\"A\", \"B\"));\n  for (NamedType type : subtypes) {\n  String id = type.getName();\n  if (!ok.contains(id)) {\n  fail(\"Unexpected id '\"+id+\"' (mapping to: \"+type.getType()+\"), should be one of: \"+ok);\n  }\n  }\n  }",
        "stack": [
          "AnnotationIntrospector._findAnnotation line 1336, JacksonAnnotationIntrospector.findSubtypes line 556, StdSubtypeResolver.collectAndResolveSubtypesByTypeId line 145, TestTypeNames.testBaseTypeId1616 line 47"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java",
      "buggy_full_code": "package com.fasterxml.jackson.databind.jsontype.impl;\n\nimport java.lang.reflect.Modifier;\nimport java.util.*;\n\nimport com.fasterxml.jackson.databind.AnnotationIntrospector;\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.cfg.MapperConfig;\nimport com.fasterxml.jackson.databind.introspect.*;\nimport com.fasterxml.jackson.databind.jsontype.NamedType;\nimport com.fasterxml.jackson.databind.jsontype.SubtypeResolver;\n\n\npublic class StdSubtypeResolver extends SubtypeResolver implements java.io.Serializable { private static final long serialVersionUID = 1L; protected LinkedHashSet<NamedType> _registeredSubtypes; public StdSubtypeResolver() { }\n\n    \n\n    @Override    \n    public void registerSubtypes(NamedType... types) {\n        if (_registeredSubtypes == null) {\n            _registeredSubtypes = new LinkedHashSet<NamedType>();\n        }\n        for (NamedType type : types) {\n            _registeredSubtypes.add(type);\n        }\n    }\n\n    @Override\n    public void registerSubtypes(Class<?>... classes) {\n        NamedType[] types = new NamedType[classes.length];\n        for (int i = 0, len = classes.length; i < len; ++i) {\n            types[i] = new NamedType(classes[i]);\n        }\n        registerSubtypes(types);\n    }\n\n    \n\n    @Override\n    public Collection<NamedType> collectAndResolveSubtypesByClass(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n        final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n        \n        Class<?> rawBase = (baseType == null) ? property.getRawType() : baseType.getRawClass();\n        \n        HashMap<NamedType, NamedType> collected = new HashMap<NamedType, NamedType>();\n        \n        if (_registeredSubtypes != null) {\n            for (NamedType subtype : _registeredSubtypes) {\n                \n                if (rawBase.isAssignableFrom(subtype.getType())) { \n                    AnnotatedClass curr = AnnotatedClassResolver.resolveWithoutSuperTypes(config,\n                            subtype.getType());\n                    _collectAndResolve(curr, subtype, config, ai, collected);\n                }\n            }\n        }\n        \n        \n            Collection<NamedType> st = ai.findSubtypes(property);\n            if (st != null) {\n                for (NamedType nt : st) {\n                    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config,\n                            nt.getType());\n                    _collectAndResolve(ac, nt, config, ai, collected);\n                }            \n        }\n\n        NamedType rootType = new NamedType(rawBase, null);\n        AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n            \n        \n        _collectAndResolve(ac, rootType, config, ai, collected);\n\n        return new ArrayList<NamedType>(collected.values());\n    }\n\n    @Override\n    public Collection<NamedType> collectAndResolveSubtypesByClass(MapperConfig<?> config, AnnotatedClass type) {\n        final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n        HashMap<NamedType, NamedType> subtypes = new HashMap<NamedType, NamedType>();\n        \n        if (_registeredSubtypes != null) {\n            Class<?> rawBase = type.getRawType();\n            for (NamedType subtype : _registeredSubtypes) {\n                \n                if (rawBase.isAssignableFrom(subtype.getType())) { \n                    AnnotatedClass curr = AnnotatedClassResolver.resolveWithoutSuperTypes(config,\n                            subtype.getType());\n                    _collectAndResolve(curr, subtype, config, ai, subtypes);\n                }\n            }\n        }\n        \n        NamedType rootType = new NamedType(type.getRawType(), null);\n        _collectAndResolve(type, rootType, config, ai, subtypes);\n        return new ArrayList<NamedType>(subtypes.values());\n    }\n\n    \n\n    @Override\n    public Collection<NamedType> collectAndResolveSubtypesByTypeId(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n        final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n        Class<?> rawBase = baseType.getRawClass();\n\n        \n        Set<Class<?>> typesHandled = new HashSet<Class<?>>();\n        Map<String,NamedType> byName = new LinkedHashMap<String,NamedType>();\n\n        \n        NamedType rootType = new NamedType(rawBase, null);\n        AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config,\n                rawBase);\n        _collectAndResolveByTypeId(ac, rootType, config, typesHandled, byName);\n        \n        \n            Collection<NamedType> st = ai.findSubtypes(property);\n            if (st != null) {\n                for (NamedType nt : st) {\n                    ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n                    _collectAndResolveByTypeId(ac, nt, config, typesHandled, byName);\n                }            \n        }\n        \n        if (_registeredSubtypes != null) {\n            for (NamedType subtype : _registeredSubtypes) {\n                \n                if (rawBase.isAssignableFrom(subtype.getType())) { \n                    AnnotatedClass curr = AnnotatedClassResolver.resolveWithoutSuperTypes(config,\n                            subtype.getType());\n                    _collectAndResolveByTypeId(curr, subtype, config, typesHandled, byName);\n                }\n            }\n        }\n        return _combineNamedAndUnnamed(rawBase, typesHandled, byName);\n    }\n\n    @Override\n    public Collection<NamedType> collectAndResolveSubtypesByTypeId(MapperConfig<?> config, AnnotatedClass baseType) {\n        final Class<?> rawBase = baseType.getRawType();\n        Set<Class<?>> typesHandled = new HashSet<Class<?>>();\n        Map<String,NamedType> byName = new LinkedHashMap<String,NamedType>();\n\n        NamedType rootType = new NamedType(rawBase, null);\n        _collectAndResolveByTypeId(baseType, rootType, config, typesHandled, byName);\n        \n        if (_registeredSubtypes != null) {\n            for (NamedType subtype : _registeredSubtypes) {\n                \n                if (rawBase.isAssignableFrom(subtype.getType())) { \n                    AnnotatedClass curr = AnnotatedClassResolver.resolveWithoutSuperTypes(config,\n                            subtype.getType());\n                    _collectAndResolveByTypeId(curr, subtype, config, typesHandled, byName);\n                }\n            }\n        }\n        return _combineNamedAndUnnamed(rawBase, typesHandled, byName);\n    }\n\n    \n\n    \n    protected void _collectAndResolve(AnnotatedClass annotatedType, NamedType namedType, MapperConfig<?> config, AnnotationIntrospector ai, HashMap<NamedType, NamedType> collectedSubtypes) {\n        if (!namedType.hasName()) {\n            String name = ai.findTypeName(annotatedType);\n            if (name != null) {\n                namedType = new NamedType(namedType.getType(), name);\n            }\n        }\n\n        \n        if (collectedSubtypes.containsKey(namedType)) {\n            \n            if (namedType.hasName()) {\n                NamedType prev = collectedSubtypes.get(namedType);\n                if (!prev.hasName()) {\n                    collectedSubtypes.put(namedType, namedType);\n                }\n            }\n            return;\n        }\n        \n        collectedSubtypes.put(namedType, namedType);\n        Collection<NamedType> st = ai.findSubtypes(annotatedType);\n        if (st != null && !st.isEmpty()) {\n            for (NamedType subtype : st) {\n                AnnotatedClass subtypeClass = AnnotatedClassResolver.resolveWithoutSuperTypes(config,\n                        subtype.getType());\n                _collectAndResolve(subtypeClass, subtype, config, ai, collectedSubtypes);\n            }\n        }\n    }\n\n    \n    protected void _collectAndResolveByTypeId(AnnotatedClass annotatedType, NamedType namedType, MapperConfig<?> config, Set<Class<?>> typesHandled, Map<String,NamedType> byName) {\n        final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n        if (!namedType.hasName()) {\n            String name = ai.findTypeName(annotatedType);\n            if (name != null) {\n                namedType = new NamedType(namedType.getType(), name);\n            }\n        }\n        if (namedType.hasName()) {\n            byName.put(namedType.getName(), namedType);\n        }\n\n        \n        if (typesHandled.add(namedType.getType())) {\n            Collection<NamedType> st = ai.findSubtypes(annotatedType);\n            if (st != null && !st.isEmpty()) {\n                for (NamedType subtype : st) {\n                    AnnotatedClass subtypeClass = AnnotatedClassResolver.resolveWithoutSuperTypes(config,\n                            subtype.getType());\n                    _collectAndResolveByTypeId(subtypeClass, subtype, config, typesHandled, byName);\n                }\n            }\n        }\n    }\n\n    \n    protected Collection<NamedType> _combineNamedAndUnnamed(Class<?> rawBase, Set<Class<?>> typesHandled, Map<String,NamedType> byName) {\n        ArrayList<NamedType> result = new ArrayList<NamedType>(byName.values());\n\n        \n        \n        \n        for (NamedType t : byName.values()) {\n            typesHandled.remove(t.getType());\n        }\n        for (Class<?> cls : typesHandled) {\n            \n            \n            if ((cls == rawBase) && Modifier.isAbstract(cls.getModifiers())) {\n                continue;\n            }\n            result.add(new NamedType(cls));\n        }\n        return result;\n    }\n}\n",
      "fixed_full_code": "package com.fasterxml.jackson.databind.jsontype.impl;\n\nimport java.lang.reflect.Modifier;\nimport java.util.*;\n\nimport com.fasterxml.jackson.databind.AnnotationIntrospector;\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.cfg.MapperConfig;\nimport com.fasterxml.jackson.databind.introspect.*;\nimport com.fasterxml.jackson.databind.jsontype.NamedType;\nimport com.fasterxml.jackson.databind.jsontype.SubtypeResolver;\n\n\npublic class StdSubtypeResolver extends SubtypeResolver implements java.io.Serializable { private static final long serialVersionUID = 1L; protected LinkedHashSet<NamedType> _registeredSubtypes; public StdSubtypeResolver() { }\n\n    \n\n    @Override    \n    public void registerSubtypes(NamedType... types) {\n        if (_registeredSubtypes == null) {\n            _registeredSubtypes = new LinkedHashSet<NamedType>();\n        }\n        for (NamedType type : types) {\n            _registeredSubtypes.add(type);\n        }\n    }\n\n    @Override\n    public void registerSubtypes(Class<?>... classes) {\n        NamedType[] types = new NamedType[classes.length];\n        for (int i = 0, len = classes.length; i < len; ++i) {\n            types[i] = new NamedType(classes[i]);\n        }\n        registerSubtypes(types);\n    }\n\n    \n\n    @Override\n    public Collection<NamedType> collectAndResolveSubtypesByClass(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n        final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n        \n        Class<?> rawBase = (baseType == null) ? property.getRawType() : baseType.getRawClass();\n        \n        HashMap<NamedType, NamedType> collected = new HashMap<NamedType, NamedType>();\n        \n        if (_registeredSubtypes != null) {\n            for (NamedType subtype : _registeredSubtypes) {\n                \n                if (rawBase.isAssignableFrom(subtype.getType())) { \n                    AnnotatedClass curr = AnnotatedClassResolver.resolveWithoutSuperTypes(config,\n                            subtype.getType());\n                    _collectAndResolve(curr, subtype, config, ai, collected);\n                }\n            }\n        }\n        \n        \n        if (property != null) {\n            Collection<NamedType> st = ai.findSubtypes(property);\n            if (st != null) {\n                for (NamedType nt : st) {\n                    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config,\n                            nt.getType());\n                    _collectAndResolve(ac, nt, config, ai, collected);\n                }            \n            }\n        }\n\n        NamedType rootType = new NamedType(rawBase, null);\n        AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n            \n        \n        _collectAndResolve(ac, rootType, config, ai, collected);\n\n        return new ArrayList<NamedType>(collected.values());\n    }\n\n    @Override\n    public Collection<NamedType> collectAndResolveSubtypesByClass(MapperConfig<?> config, AnnotatedClass type) {\n        final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n        HashMap<NamedType, NamedType> subtypes = new HashMap<NamedType, NamedType>();\n        \n        if (_registeredSubtypes != null) {\n            Class<?> rawBase = type.getRawType();\n            for (NamedType subtype : _registeredSubtypes) {\n                \n                if (rawBase.isAssignableFrom(subtype.getType())) { \n                    AnnotatedClass curr = AnnotatedClassResolver.resolveWithoutSuperTypes(config,\n                            subtype.getType());\n                    _collectAndResolve(curr, subtype, config, ai, subtypes);\n                }\n            }\n        }\n        \n        NamedType rootType = new NamedType(type.getRawType(), null);\n        _collectAndResolve(type, rootType, config, ai, subtypes);\n        return new ArrayList<NamedType>(subtypes.values());\n    }\n\n    \n\n    @Override\n    public Collection<NamedType> collectAndResolveSubtypesByTypeId(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n        final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n        Class<?> rawBase = baseType.getRawClass();\n\n        \n        Set<Class<?>> typesHandled = new HashSet<Class<?>>();\n        Map<String,NamedType> byName = new LinkedHashMap<String,NamedType>();\n\n        \n        NamedType rootType = new NamedType(rawBase, null);\n        AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config,\n                rawBase);\n        _collectAndResolveByTypeId(ac, rootType, config, typesHandled, byName);\n        \n        \n        if (property != null) {\n            Collection<NamedType> st = ai.findSubtypes(property);\n            if (st != null) {\n                for (NamedType nt : st) {\n                    ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n                    _collectAndResolveByTypeId(ac, nt, config, typesHandled, byName);\n                }            \n            }\n        }\n        \n        if (_registeredSubtypes != null) {\n            for (NamedType subtype : _registeredSubtypes) {\n                \n                if (rawBase.isAssignableFrom(subtype.getType())) { \n                    AnnotatedClass curr = AnnotatedClassResolver.resolveWithoutSuperTypes(config,\n                            subtype.getType());\n                    _collectAndResolveByTypeId(curr, subtype, config, typesHandled, byName);\n                }\n            }\n        }\n        return _combineNamedAndUnnamed(rawBase, typesHandled, byName);\n    }\n\n    @Override\n    public Collection<NamedType> collectAndResolveSubtypesByTypeId(MapperConfig<?> config, AnnotatedClass baseType) {\n        final Class<?> rawBase = baseType.getRawType();\n        Set<Class<?>> typesHandled = new HashSet<Class<?>>();\n        Map<String,NamedType> byName = new LinkedHashMap<String,NamedType>();\n\n        NamedType rootType = new NamedType(rawBase, null);\n        _collectAndResolveByTypeId(baseType, rootType, config, typesHandled, byName);\n        \n        if (_registeredSubtypes != null) {\n            for (NamedType subtype : _registeredSubtypes) {\n                \n                if (rawBase.isAssignableFrom(subtype.getType())) { \n                    AnnotatedClass curr = AnnotatedClassResolver.resolveWithoutSuperTypes(config,\n                            subtype.getType());\n                    _collectAndResolveByTypeId(curr, subtype, config, typesHandled, byName);\n                }\n            }\n        }\n        return _combineNamedAndUnnamed(rawBase, typesHandled, byName);\n    }\n\n    \n\n    \n    protected void _collectAndResolve(AnnotatedClass annotatedType, NamedType namedType, MapperConfig<?> config, AnnotationIntrospector ai, HashMap<NamedType, NamedType> collectedSubtypes) {\n        if (!namedType.hasName()) {\n            String name = ai.findTypeName(annotatedType);\n            if (name != null) {\n                namedType = new NamedType(namedType.getType(), name);\n            }\n        }\n\n        \n        if (collectedSubtypes.containsKey(namedType)) {\n            \n            if (namedType.hasName()) {\n                NamedType prev = collectedSubtypes.get(namedType);\n                if (!prev.hasName()) {\n                    collectedSubtypes.put(namedType, namedType);\n                }\n            }\n            return;\n        }\n        \n        collectedSubtypes.put(namedType, namedType);\n        Collection<NamedType> st = ai.findSubtypes(annotatedType);\n        if (st != null && !st.isEmpty()) {\n            for (NamedType subtype : st) {\n                AnnotatedClass subtypeClass = AnnotatedClassResolver.resolveWithoutSuperTypes(config,\n                        subtype.getType());\n                _collectAndResolve(subtypeClass, subtype, config, ai, collectedSubtypes);\n            }\n        }\n    }\n\n    \n    protected void _collectAndResolveByTypeId(AnnotatedClass annotatedType, NamedType namedType, MapperConfig<?> config, Set<Class<?>> typesHandled, Map<String,NamedType> byName) {\n        final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n        if (!namedType.hasName()) {\n            String name = ai.findTypeName(annotatedType);\n            if (name != null) {\n                namedType = new NamedType(namedType.getType(), name);\n            }\n        }\n        if (namedType.hasName()) {\n            byName.put(namedType.getName(), namedType);\n        }\n\n        \n        if (typesHandled.add(namedType.getType())) {\n            Collection<NamedType> st = ai.findSubtypes(annotatedType);\n            if (st != null && !st.isEmpty()) {\n                for (NamedType subtype : st) {\n                    AnnotatedClass subtypeClass = AnnotatedClassResolver.resolveWithoutSuperTypes(config,\n                            subtype.getType());\n                    _collectAndResolveByTypeId(subtypeClass, subtype, config, typesHandled, byName);\n                }\n            }\n        }\n    }\n\n    \n    protected Collection<NamedType> _combineNamedAndUnnamed(Class<?> rawBase, Set<Class<?>> typesHandled, Map<String,NamedType> byName) {\n        ArrayList<NamedType> result = new ArrayList<NamedType>(byName.values());\n\n        \n        \n        \n        for (NamedType t : byName.values()) {\n            typesHandled.remove(t.getType());\n        }\n        for (Class<?> cls : typesHandled) {\n            \n            \n            if ((cls == rawBase) && Modifier.isAbstract(cls.getModifiers())) {\n                continue;\n            }\n            result.add(new NamedType(cls));\n        }\n        return result;\n    }\n}\n",
      "buggy_signatures": [
        "public void registerSubtypes(NamedType... types)",
        "public void registerSubtypes(Class<?>... classes)",
        "public Collection<NamedType> collectAndResolveSubtypesByClass(MapperConfig<?> config, AnnotatedMember property, JavaType baseType)",
        "public Collection<NamedType> collectAndResolveSubtypesByClass(MapperConfig<?> config, AnnotatedClass type)",
        "public Collection<NamedType> collectAndResolveSubtypesByTypeId(MapperConfig<?> config, AnnotatedMember property, JavaType baseType)",
        "public Collection<NamedType> collectAndResolveSubtypesByTypeId(MapperConfig<?> config, AnnotatedClass baseType)",
        "protected void _collectAndResolve(AnnotatedClass annotatedType, NamedType namedType, MapperConfig<?> config, AnnotationIntrospector ai, HashMap<NamedType, NamedType> collectedSubtypes)",
        "protected void _collectAndResolveByTypeId(AnnotatedClass annotatedType, NamedType namedType, MapperConfig<?> config, Set<Class<?>> typesHandled, Map<String,NamedType> byName)",
        "protected Collection<NamedType> _combineNamedAndUnnamed(Class<?> rawBase, Set<Class<?>> typesHandled, Map<String,NamedType> byName)"
      ],
      "fixed_signatures": [
        "public void registerSubtypes(NamedType... types)",
        "public void registerSubtypes(Class<?>... classes)",
        "public Collection<NamedType> collectAndResolveSubtypesByClass(MapperConfig<?> config, AnnotatedMember property, JavaType baseType)",
        "public Collection<NamedType> collectAndResolveSubtypesByClass(MapperConfig<?> config, AnnotatedClass type)",
        "public Collection<NamedType> collectAndResolveSubtypesByTypeId(MapperConfig<?> config, AnnotatedMember property, JavaType baseType)",
        "public Collection<NamedType> collectAndResolveSubtypesByTypeId(MapperConfig<?> config, AnnotatedClass baseType)",
        "protected void _collectAndResolve(AnnotatedClass annotatedType, NamedType namedType, MapperConfig<?> config, AnnotationIntrospector ai, HashMap<NamedType, NamedType> collectedSubtypes)",
        "protected void _collectAndResolveByTypeId(AnnotatedClass annotatedType, NamedType namedType, MapperConfig<?> config, Set<Class<?>> typesHandled, Map<String,NamedType> byName)",
        "protected Collection<NamedType> _combineNamedAndUnnamed(Class<?> rawBase, Set<Class<?>> typesHandled, Map<String,NamedType> byName)"
      ],
      "methods": [
        {
          "buggy_method": "  public Collection<NamedType> collectAndResolveSubtypesByClass(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n  final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n  \n  Class<?> rawBase = (baseType == null) ? property.getRawType() : baseType.getRawClass();\n  \n  HashMap<NamedType, NamedType> collected = new HashMap<NamedType, NamedType>();\n  \n  if (_registeredSubtypes != null) {\n  for (NamedType subtype : _registeredSubtypes) {\n  \n  if (rawBase.isAssignableFrom(subtype.getType())) { \n  AnnotatedClass curr = AnnotatedClassResolver.resolveWithoutSuperTypes(config,\n  subtype.getType());\n  _collectAndResolve(curr, subtype, config, ai, collected);\n  }\n  }\n  }\n  \n  \n  Collection<NamedType> st = ai.findSubtypes(property);\n  if (st != null) {\n  for (NamedType nt : st) {\n  AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config,\n  nt.getType());\n  _collectAndResolve(ac, nt, config, ai, collected);\n  }  \n  }\n\n  NamedType rootType = new NamedType(rawBase, null);\n  AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n  \n  \n  _collectAndResolve(ac, rootType, config, ai, collected);\n\n  return new ArrayList<NamedType>(collected.values());\n  }",
          "fixed_method": "  public Collection<NamedType> collectAndResolveSubtypesByClass(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n  final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n  \n  Class<?> rawBase = (baseType == null) ? property.getRawType() : baseType.getRawClass();\n  \n  HashMap<NamedType, NamedType> collected = new HashMap<NamedType, NamedType>();\n  \n  if (_registeredSubtypes != null) {\n  for (NamedType subtype : _registeredSubtypes) {\n  \n  if (rawBase.isAssignableFrom(subtype.getType())) { \n  AnnotatedClass curr = AnnotatedClassResolver.resolveWithoutSuperTypes(config,\n  subtype.getType());\n  _collectAndResolve(curr, subtype, config, ai, collected);\n  }\n  }\n  }\n  \n  \n  if (property != null) {\n  Collection<NamedType> st = ai.findSubtypes(property);\n  if (st != null) {\n  for (NamedType nt : st) {\n  AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config,\n  nt.getType());\n  _collectAndResolve(ac, nt, config, ai, collected);\n  }  \n  }\n  }\n\n  NamedType rootType = new NamedType(rawBase, null);\n  AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n  \n  \n  _collectAndResolve(ac, rootType, config, ai, collected);\n\n  return new ArrayList<NamedType>(collected.values());\n  }",
          "diff": [
            "@@ -76,6 +76,7 @@",
            "         }\n",
            "         \n",
            "         // then annotated types for property itself\n",
            "+        if (property != null) {\n",
            "             Collection<NamedType> st = ai.findSubtypes(property);\n",
            "             if (st != null) {\n",
            "                 for (NamedType nt : st) {\n",
            "@@ -83,6 +84,7 @@",
            "                             nt.getType());\n",
            "                     _collectAndResolve(ac, nt, config, ai, collected);\n",
            "                 }            \n",
            "+            }\n",
            "         }\n",
            " \n",
            "         NamedType rootType = new NamedType(rawBase, null);\n"
          ],
          "changed_lines": 2
        },
        {
          "buggy_method": "  public Collection<NamedType> collectAndResolveSubtypesByTypeId(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n  final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n  Class<?> rawBase = baseType.getRawClass();\n\n  \n  Set<Class<?>> typesHandled = new HashSet<Class<?>>();\n  Map<String,NamedType> byName = new LinkedHashMap<String,NamedType>();\n\n  \n  NamedType rootType = new NamedType(rawBase, null);\n  AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config,\n  rawBase);\n  _collectAndResolveByTypeId(ac, rootType, config, typesHandled, byName);\n  \n  \n  Collection<NamedType> st = ai.findSubtypes(property);\n  if (st != null) {\n  for (NamedType nt : st) {\n  ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n  _collectAndResolveByTypeId(ac, nt, config, typesHandled, byName);\n  }  \n  }\n  \n  if (_registeredSubtypes != null) {\n  for (NamedType subtype : _registeredSubtypes) {\n  \n  if (rawBase.isAssignableFrom(subtype.getType())) { \n  AnnotatedClass curr = AnnotatedClassResolver.resolveWithoutSuperTypes(config,\n  subtype.getType());\n  _collectAndResolveByTypeId(curr, subtype, config, typesHandled, byName);\n  }\n  }\n  }\n  return _combineNamedAndUnnamed(rawBase, typesHandled, byName);\n  }",
          "fixed_method": "  public Collection<NamedType> collectAndResolveSubtypesByTypeId(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n  final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n  Class<?> rawBase = baseType.getRawClass();\n\n  \n  Set<Class<?>> typesHandled = new HashSet<Class<?>>();\n  Map<String,NamedType> byName = new LinkedHashMap<String,NamedType>();\n\n  \n  NamedType rootType = new NamedType(rawBase, null);\n  AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config,\n  rawBase);\n  _collectAndResolveByTypeId(ac, rootType, config, typesHandled, byName);\n  \n  \n  if (property != null) {\n  Collection<NamedType> st = ai.findSubtypes(property);\n  if (st != null) {\n  for (NamedType nt : st) {\n  ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n  _collectAndResolveByTypeId(ac, nt, config, typesHandled, byName);\n  }  \n  }\n  }\n  \n  if (_registeredSubtypes != null) {\n  for (NamedType subtype : _registeredSubtypes) {\n  \n  if (rawBase.isAssignableFrom(subtype.getType())) { \n  AnnotatedClass curr = AnnotatedClassResolver.resolveWithoutSuperTypes(config,\n  subtype.getType());\n  _collectAndResolveByTypeId(curr, subtype, config, typesHandled, byName);\n  }\n  }\n  }\n  return _combineNamedAndUnnamed(rawBase, typesHandled, byName);\n  }",
          "diff": [
            "@@ -142,12 +144,14 @@",
            "         _collectAndResolveByTypeId(ac, rootType, config, typesHandled, byName);\n",
            "         \n",
            "         // then with definitions from property\n",
            "+        if (property != null) {\n",
            "             Collection<NamedType> st = ai.findSubtypes(property);\n",
            "             if (st != null) {\n",
            "                 for (NamedType nt : st) {\n",
            "                     ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n",
            "                     _collectAndResolveByTypeId(ac, nt, config, typesHandled, byName);\n",
            "                 }            \n",
            "+            }\n",
            "         }\n",
            "         // and finally explicit type registrations (highest precedence)\n",
            "         if (_registeredSubtypes != null) {\n"
          ],
          "changed_lines": 2
        }
      ]
    }
  ]
}
