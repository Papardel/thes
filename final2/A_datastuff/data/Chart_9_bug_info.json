{
  "bug_id": "9",
  "failed_tests": {
    "org.jfree.data.time.junit.TimeSeriesTests": [
      {
        "methodName": "testBug1864222",
        "error": "java.lang.IllegalArgumentException",
        "message": "Requires start <= end.",
        "fail_line": "            s.createCopy(new Day(1, 12, 2005), new Day(18, 1, 2006));",
        "test_source": "  public void testBug1864222() {\n  TimeSeries s = new TimeSeries(\"S\");\n  s.add(new Day(19, 8, 2005), 1);\n  s.add(new Day(31, 1, 2006), 1);\n  boolean pass = true;\n  try {\n  s.createCopy(new Day(1, 12, 2005), new Day(18, 1, 2006));\n  }\n  catch (CloneNotSupportedException e) {\n  pass = false;\n  }\n  assertTrue(pass);\n  }",
        "stack": [
          "TimeSeries.createCopy line 883, TimeSeries.createCopy line 953, TimeSeriesTests.testBug1864222 line 829"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/jfree/data/time/TimeSeries.java",
      "buggy_full_code": "\n\npackage org.jfree.data.time;\n\nimport java.io.Serializable;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.TimeZone;\n\nimport org.jfree.chart.util.ObjectUtilities;\nimport org.jfree.data.general.Series;\nimport org.jfree.data.general.SeriesChangeEvent;\nimport org.jfree.data.general.SeriesException;\n\n\npublic class TimeSeries extends Series implements Cloneable, Serializable { private static final long serialVersionUID = -5032960206869675528L; protected static final String DEFAULT_DOMAIN_DESCRIPTION = \"Time\"; protected static final String DEFAULT_RANGE_DESCRIPTION = \"Value\"; private String domain; private String range; protected Class timePeriodClass; protected List data; private int maximumItemCount; private long maximumItemAge; public TimeSeries(Comparable name) {\n        this(name, DEFAULT_DOMAIN_DESCRIPTION, DEFAULT_RANGE_DESCRIPTION,\n                Day.class);\n    }\n\n    \n    public TimeSeries(Comparable name, Class timePeriodClass) {\n        this(name, DEFAULT_DOMAIN_DESCRIPTION, DEFAULT_RANGE_DESCRIPTION,\n                timePeriodClass);\n    }\n\n    \n    public TimeSeries(Comparable name, String domain, String range, Class timePeriodClass) {\n        super(name);\n        this.domain = domain;\n        this.range = range;\n        this.timePeriodClass = timePeriodClass;\n        this.data = new java.util.ArrayList();\n        this.maximumItemCount = Integer.MAX_VALUE;\n        this.maximumItemAge = Long.MAX_VALUE;\n    }\n\n    \n    public String getDomainDescription() {\n        return this.domain;\n    }\n\n    \n    public void setDomainDescription(String description) {\n        String old = this.domain;\n        this.domain = description;\n        firePropertyChange(\"Domain\", old, description);\n    }\n\n    \n    public String getRangeDescription() {\n        return this.range;\n    }\n\n    \n    public void setRangeDescription(String description) {\n        String old = this.range;\n        this.range = description;\n        firePropertyChange(\"Range\", old, description);\n    }\n\n    \n    public int getItemCount() {\n        return this.data.size();\n    }\n\n    \n    public List getItems() {\n        return Collections.unmodifiableList(this.data);\n    }\n\n    \n    public int getMaximumItemCount() {\n        return this.maximumItemCount;\n    }\n\n    \n    public void setMaximumItemCount(int maximum) {\n        if (maximum < 0) {\n            throw new IllegalArgumentException(\"Negative 'maximum' argument.\");\n        }\n        this.maximumItemCount = maximum;\n        int count = this.data.size();\n        if (count > maximum) {\n            delete(0, count - maximum - 1);\n        }\n    }\n\n    \n    public long getMaximumItemAge() {\n        return this.maximumItemAge;\n    }\n\n    \n    public void setMaximumItemAge(long periods) {\n        if (periods < 0) {\n            throw new IllegalArgumentException(\"Negative 'periods' argument.\");\n        }\n        this.maximumItemAge = periods;\n        removeAgedItems(true);  \n    }\n\n    \n    public Class getTimePeriodClass() {\n        return this.timePeriodClass;\n    }\n\n    \n    public TimeSeriesDataItem getDataItem(int index) {\n        return (TimeSeriesDataItem) this.data.get(index);\n    }\n\n    \n    public TimeSeriesDataItem getDataItem(RegularTimePeriod period) {\n        int index = getIndex(period);\n        if (index >= 0) {\n            return (TimeSeriesDataItem) this.data.get(index);\n        }\n        else {\n            return null;\n        }\n    }\n\n    \n    public RegularTimePeriod getTimePeriod(int index) {\n        return getDataItem(index).getPeriod();\n    }\n\n    \n    public RegularTimePeriod getNextTimePeriod() {\n        RegularTimePeriod last = getTimePeriod(getItemCount() - 1);\n        return last.next();\n    }\n\n    \n    public Collection getTimePeriods() {\n        Collection result = new java.util.ArrayList();\n        for (int i = 0; i < getItemCount(); i++) {\n            result.add(getTimePeriod(i));\n        }\n        return result;\n    }\n\n    \n    public Collection getTimePeriodsUniqueToOtherSeries(TimeSeries series) {\n\n        Collection result = new java.util.ArrayList();\n        for (int i = 0; i < series.getItemCount(); i++) {\n            RegularTimePeriod period = series.getTimePeriod(i);\n            int index = getIndex(period);\n            if (index < 0) {\n                result.add(period);\n            }\n        }\n        return result;\n\n    }\n\n    \n    public int getIndex(RegularTimePeriod period) {\n        if (period == null) {\n            throw new IllegalArgumentException(\"Null 'period' argument.\");\n        }\n        TimeSeriesDataItem dummy = new TimeSeriesDataItem(\n              period, Integer.MIN_VALUE);\n        return Collections.binarySearch(this.data, dummy);\n    }\n\n    \n    public Number getValue(int index) {\n        return getDataItem(index).getValue();\n    }\n\n    \n    public Number getValue(RegularTimePeriod period) {\n\n        int index = getIndex(period);\n        if (index >= 0) {\n            return getValue(index);\n        }\n        else {\n            return null;\n        }\n\n    }\n\n    \n    public void add(TimeSeriesDataItem item) {\n        add(item, true);\n    }\n\n    \n    public void add(TimeSeriesDataItem item, boolean notify) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (!item.getPeriod().getClass().equals(this.timePeriodClass)) {\n            StringBuffer b = new StringBuffer();\n            b.append(\"You are trying to add data where the time period class \");\n            b.append(\"is \");\n            b.append(item.getPeriod().getClass().getName());\n            b.append(\", but the TimeSeries is expecting an instance of \");\n            b.append(this.timePeriodClass.getName());\n            b.append(\".\");\n            throw new SeriesException(b.toString());\n        }\n\n        \n        boolean added = false;\n        int count = getItemCount();\n        if (count == 0) {\n            this.data.add(item);\n            added = true;\n        }\n        else {\n            RegularTimePeriod last = getTimePeriod(getItemCount() - 1);\n            if (item.getPeriod().compareTo(last) > 0) {\n                this.data.add(item);\n                added = true;\n            }\n            else {\n                int index = Collections.binarySearch(this.data, item);\n                if (index < 0) {\n                    this.data.add(-index - 1, item);\n                    added = true;\n                }\n                else {\n                    StringBuffer b = new StringBuffer();\n                    b.append(\"You are attempting to add an observation for \");\n                    b.append(\"the time period \");\n                    b.append(item.getPeriod().toString());\n                    b.append(\" but the series already contains an observation\");\n                    b.append(\" for that time period. Duplicates are not \");\n                    b.append(\"permitted.  Try using the addOrUpdate() method.\");\n                    throw new SeriesException(b.toString());\n                }\n            }\n        }\n        if (added) {\n            \n            if (getItemCount() > this.maximumItemCount) {\n                this.data.remove(0);\n            }\n\n            removeAgedItems(false);  \n                                     \n                                     \n            if (notify) {\n                fireSeriesChanged();\n            }\n        }\n\n    }\n\n    \n    public void add(RegularTimePeriod period, double value) {\n        \n        add(period, value, true);\n    }\n\n    \n    public void add(RegularTimePeriod period, double value, boolean notify) {\n        \n        TimeSeriesDataItem item = new TimeSeriesDataItem(period, value);\n        add(item, notify);\n    }\n\n    \n    public void add(RegularTimePeriod period, Number value) {\n        \n        add(period, value, true);\n    }\n\n    \n    public void add(RegularTimePeriod period, Number value, boolean notify) {\n        \n        TimeSeriesDataItem item = new TimeSeriesDataItem(period, value);\n        add(item, notify);\n    }\n\n    \n    public void update(RegularTimePeriod period, Number value) {\n        TimeSeriesDataItem temp = new TimeSeriesDataItem(period, value);\n        int index = Collections.binarySearch(this.data, temp);\n        if (index >= 0) {\n            TimeSeriesDataItem pair = (TimeSeriesDataItem) this.data.get(index);\n            pair.setValue(value);\n            fireSeriesChanged();\n        }\n        else {\n            throw new SeriesException(\n                \"TimeSeries.update(TimePeriod, Number):  period does not exist.\"\n            );\n        }\n\n    }\n\n    \n    public void update(int index, Number value) {\n        TimeSeriesDataItem item = getDataItem(index);\n        item.setValue(value);\n        fireSeriesChanged();\n    }\n\n    \n    public TimeSeries addAndOrUpdate(TimeSeries series) {\n        TimeSeries overwritten = new TimeSeries(\"Overwritten values from: \"\n                + getKey(), series.getTimePeriodClass());\n        for (int i = 0; i < series.getItemCount(); i++) {\n            TimeSeriesDataItem item = series.getDataItem(i);\n            TimeSeriesDataItem oldItem = addOrUpdate(item.getPeriod(),\n                    item.getValue());\n            if (oldItem != null) {\n                overwritten.add(oldItem);\n            }\n        }\n        return overwritten;\n    }\n\n    \n    public TimeSeriesDataItem addOrUpdate(RegularTimePeriod period, double value) {\n        return addOrUpdate(period, new Double(value));\n    }\n\n    \n    public TimeSeriesDataItem addOrUpdate(RegularTimePeriod period, Number value) {\n\n        if (period == null) {\n            throw new IllegalArgumentException(\"Null 'period' argument.\");\n        }\n        TimeSeriesDataItem overwritten = null;\n\n        TimeSeriesDataItem key = new TimeSeriesDataItem(period, value);\n        int index = Collections.binarySearch(this.data, key);\n        if (index >= 0) {\n            TimeSeriesDataItem existing\n                = (TimeSeriesDataItem) this.data.get(index);\n            overwritten = (TimeSeriesDataItem) existing.clone();\n            existing.setValue(value);\n            removeAgedItems(false);  \n                                     \n                                     \n            fireSeriesChanged();\n        }\n        else {\n            this.data.add(-index - 1, new TimeSeriesDataItem(period, value));\n\n            \n            if (getItemCount() > this.maximumItemCount) {\n                this.data.remove(0);\n            }\n\n            removeAgedItems(false);  \n                                     \n                                     \n            fireSeriesChanged();\n        }\n        return overwritten;\n\n    }\n\n    \n    public void removeAgedItems(boolean notify) {\n        \n        \n        if (getItemCount() > 1) {\n            long latest = getTimePeriod(getItemCount() - 1).getSerialIndex();\n            boolean removed = false;\n            while ((latest - getTimePeriod(0).getSerialIndex())\n                    > this.maximumItemAge) {\n                this.data.remove(0);\n                removed = true;\n            }\n            if (removed && notify) {\n                fireSeriesChanged();\n            }\n        }\n    }\n\n    \n    public void removeAgedItems(long latest, boolean notify) {\n\n        \n        long index = Long.MAX_VALUE;\n        try {\n            Method m = RegularTimePeriod.class.getDeclaredMethod(\n                    \"createInstance\", new Class[] {Class.class, Date.class,\n                    TimeZone.class});\n            RegularTimePeriod newest = (RegularTimePeriod) m.invoke(\n                    this.timePeriodClass, new Object[] {this.timePeriodClass,\n                            new Date(latest), TimeZone.getDefault()});\n            index = newest.getSerialIndex();\n        }\n        catch (NoSuchMethodException e) {\n            e.printStackTrace();\n        }\n        catch (IllegalAccessException e) {\n            e.printStackTrace();\n        }\n        catch (InvocationTargetException e) {\n            e.printStackTrace();\n        }\n\n        \n        \n        boolean removed = false;\n        while (getItemCount() > 0 && (index\n                - getTimePeriod(0).getSerialIndex()) > this.maximumItemAge) {\n            this.data.remove(0);\n            removed = true;\n        }\n        if (removed && notify) {\n            fireSeriesChanged();\n        }\n    }\n\n    \n    public void clear() {\n        if (this.data.size() > 0) {\n            this.data.clear();\n            fireSeriesChanged();\n        }\n    }\n\n    \n    public void delete(RegularTimePeriod period) {\n        int index = getIndex(period);\n        if (index >= 0) {\n            this.data.remove(index);\n            fireSeriesChanged();\n        }\n    }\n\n    \n    public void delete(int start, int end) {\n        if (end < start) {\n            throw new IllegalArgumentException(\"Requires start <= end.\");\n        }\n        for (int i = 0; i <= (end - start); i++) {\n            this.data.remove(start);\n        }\n        fireSeriesChanged();\n    }\n\n    \n    public Object clone() throws CloneNotSupportedException {\n        TimeSeries clone = (TimeSeries) super.clone();\n        clone.data = (List) ObjectUtilities.deepClone(this.data);\n        return clone;\n    }\n\n    \n    public TimeSeries createCopy(int start, int end) throws CloneNotSupportedException {\n\n        if (start < 0) {\n            throw new IllegalArgumentException(\"Requires start >= 0.\");\n        }\n        if (end < start) {\n            throw new IllegalArgumentException(\"Requires start <= end.\");\n        }\n        TimeSeries copy = (TimeSeries) super.clone();\n\n        copy.data = new java.util.ArrayList();\n        if (this.data.size() > 0) {\n            for (int index = start; index <= end; index++) {\n                TimeSeriesDataItem item\n                    = (TimeSeriesDataItem) this.data.get(index);\n                TimeSeriesDataItem clone = (TimeSeriesDataItem) item.clone();\n                try {\n                    copy.add(clone);\n                }\n                catch (SeriesException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return copy;\n    }\n\n    \n    public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end) throws CloneNotSupportedException {\n\n        if (start == null) {\n            throw new IllegalArgumentException(\"Null 'start' argument.\");\n        }\n        if (end == null) {\n            throw new IllegalArgumentException(\"Null 'end' argument.\");\n        }\n        if (start.compareTo(end) > 0) {\n            throw new IllegalArgumentException(\n                    \"Requires start on or before end.\");\n        }\n        boolean emptyRange = false;\n        int startIndex = getIndex(start);\n        if (startIndex < 0) {\n            startIndex = -(startIndex + 1);\n            if (startIndex == this.data.size()) {\n                emptyRange = true;  \n            }\n        }\n        int endIndex = getIndex(end);\n        if (endIndex < 0) {             \n            endIndex = -(endIndex + 1); \n            endIndex = endIndex - 1;    \n        }\n        if (endIndex < 0) {\n            emptyRange = true;\n        }\n        if (emptyRange) {\n            TimeSeries copy = (TimeSeries) super.clone();\n            copy.data = new java.util.ArrayList();\n            return copy;\n        }\n        else {\n            return createCopy(startIndex, endIndex);\n        }\n\n    }\n\n    \n    public boolean equals(Object object) {\n        if (object == this) {\n            return true;\n        }\n        if (!(object instanceof TimeSeries) || !super.equals(object)) {\n            return false;\n        }\n        TimeSeries s = (TimeSeries) object;\n        if (!ObjectUtilities.equal(getDomainDescription(),\n                s.getDomainDescription())) {\n            return false;\n        }\n\n        if (!ObjectUtilities.equal(getRangeDescription(),\n                s.getRangeDescription())) {\n            return false;\n        }\n\n        if (!getClass().equals(s.getClass())) {\n            return false;\n        }\n\n        if (getMaximumItemAge() != s.getMaximumItemAge()) {\n            return false;\n        }\n\n        if (getMaximumItemCount() != s.getMaximumItemCount()) {\n            return false;\n        }\n\n        int count = getItemCount();\n        if (count != s.getItemCount()) {\n            return false;\n        }\n        for (int i = 0; i < count; i++) {\n            if (!getDataItem(i).equals(s.getDataItem(i))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public int hashCode() {\n        int result = super.hashCode();\n        result = 29 * result + (this.domain != null ? this.domain.hashCode()\n                : 0);\n        result = 29 * result + (this.range != null ? this.range.hashCode() : 0);\n        result = 29 * result + (this.timePeriodClass != null\n                ? this.timePeriodClass.hashCode() : 0);\n        \n        \n        int count = getItemCount();\n        if (count > 0) {\n            TimeSeriesDataItem item = getDataItem(0);\n            result = 29 * result + item.hashCode();\n        }\n        if (count > 1) {\n            TimeSeriesDataItem item = getDataItem(count - 1);\n            result = 29 * result + item.hashCode();\n        }\n        if (count > 2) {\n            TimeSeriesDataItem item = getDataItem(count / 2);\n            result = 29 * result + item.hashCode();\n        }\n        result = 29 * result + this.maximumItemCount;\n        result = 29 * result + (int) this.maximumItemAge;\n        return result;\n    }\n\n}\n",
      "fixed_full_code": "\n\npackage org.jfree.data.time;\n\nimport java.io.Serializable;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.TimeZone;\n\nimport org.jfree.chart.util.ObjectUtilities;\nimport org.jfree.data.general.Series;\nimport org.jfree.data.general.SeriesChangeEvent;\nimport org.jfree.data.general.SeriesException;\n\n\npublic class TimeSeries extends Series implements Cloneable, Serializable { private static final long serialVersionUID = -5032960206869675528L; protected static final String DEFAULT_DOMAIN_DESCRIPTION = \"Time\"; protected static final String DEFAULT_RANGE_DESCRIPTION = \"Value\"; private String domain; private String range; protected Class timePeriodClass; protected List data; private int maximumItemCount; private long maximumItemAge; public TimeSeries(Comparable name) {\n        this(name, DEFAULT_DOMAIN_DESCRIPTION, DEFAULT_RANGE_DESCRIPTION,\n                Day.class);\n    }\n\n    \n    public TimeSeries(Comparable name, Class timePeriodClass) {\n        this(name, DEFAULT_DOMAIN_DESCRIPTION, DEFAULT_RANGE_DESCRIPTION,\n                timePeriodClass);\n    }\n\n    \n    public TimeSeries(Comparable name, String domain, String range, Class timePeriodClass) {\n        super(name);\n        this.domain = domain;\n        this.range = range;\n        this.timePeriodClass = timePeriodClass;\n        this.data = new java.util.ArrayList();\n        this.maximumItemCount = Integer.MAX_VALUE;\n        this.maximumItemAge = Long.MAX_VALUE;\n    }\n\n    \n    public String getDomainDescription() {\n        return this.domain;\n    }\n\n    \n    public void setDomainDescription(String description) {\n        String old = this.domain;\n        this.domain = description;\n        firePropertyChange(\"Domain\", old, description);\n    }\n\n    \n    public String getRangeDescription() {\n        return this.range;\n    }\n\n    \n    public void setRangeDescription(String description) {\n        String old = this.range;\n        this.range = description;\n        firePropertyChange(\"Range\", old, description);\n    }\n\n    \n    public int getItemCount() {\n        return this.data.size();\n    }\n\n    \n    public List getItems() {\n        return Collections.unmodifiableList(this.data);\n    }\n\n    \n    public int getMaximumItemCount() {\n        return this.maximumItemCount;\n    }\n\n    \n    public void setMaximumItemCount(int maximum) {\n        if (maximum < 0) {\n            throw new IllegalArgumentException(\"Negative 'maximum' argument.\");\n        }\n        this.maximumItemCount = maximum;\n        int count = this.data.size();\n        if (count > maximum) {\n            delete(0, count - maximum - 1);\n        }\n    }\n\n    \n    public long getMaximumItemAge() {\n        return this.maximumItemAge;\n    }\n\n    \n    public void setMaximumItemAge(long periods) {\n        if (periods < 0) {\n            throw new IllegalArgumentException(\"Negative 'periods' argument.\");\n        }\n        this.maximumItemAge = periods;\n        removeAgedItems(true);  \n    }\n\n    \n    public Class getTimePeriodClass() {\n        return this.timePeriodClass;\n    }\n\n    \n    public TimeSeriesDataItem getDataItem(int index) {\n        return (TimeSeriesDataItem) this.data.get(index);\n    }\n\n    \n    public TimeSeriesDataItem getDataItem(RegularTimePeriod period) {\n        int index = getIndex(period);\n        if (index >= 0) {\n            return (TimeSeriesDataItem) this.data.get(index);\n        }\n        else {\n            return null;\n        }\n    }\n\n    \n    public RegularTimePeriod getTimePeriod(int index) {\n        return getDataItem(index).getPeriod();\n    }\n\n    \n    public RegularTimePeriod getNextTimePeriod() {\n        RegularTimePeriod last = getTimePeriod(getItemCount() - 1);\n        return last.next();\n    }\n\n    \n    public Collection getTimePeriods() {\n        Collection result = new java.util.ArrayList();\n        for (int i = 0; i < getItemCount(); i++) {\n            result.add(getTimePeriod(i));\n        }\n        return result;\n    }\n\n    \n    public Collection getTimePeriodsUniqueToOtherSeries(TimeSeries series) {\n\n        Collection result = new java.util.ArrayList();\n        for (int i = 0; i < series.getItemCount(); i++) {\n            RegularTimePeriod period = series.getTimePeriod(i);\n            int index = getIndex(period);\n            if (index < 0) {\n                result.add(period);\n            }\n        }\n        return result;\n\n    }\n\n    \n    public int getIndex(RegularTimePeriod period) {\n        if (period == null) {\n            throw new IllegalArgumentException(\"Null 'period' argument.\");\n        }\n        TimeSeriesDataItem dummy = new TimeSeriesDataItem(\n              period, Integer.MIN_VALUE);\n        return Collections.binarySearch(this.data, dummy);\n    }\n\n    \n    public Number getValue(int index) {\n        return getDataItem(index).getValue();\n    }\n\n    \n    public Number getValue(RegularTimePeriod period) {\n\n        int index = getIndex(period);\n        if (index >= 0) {\n            return getValue(index);\n        }\n        else {\n            return null;\n        }\n\n    }\n\n    \n    public void add(TimeSeriesDataItem item) {\n        add(item, true);\n    }\n\n    \n    public void add(TimeSeriesDataItem item, boolean notify) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (!item.getPeriod().getClass().equals(this.timePeriodClass)) {\n            StringBuffer b = new StringBuffer();\n            b.append(\"You are trying to add data where the time period class \");\n            b.append(\"is \");\n            b.append(item.getPeriod().getClass().getName());\n            b.append(\", but the TimeSeries is expecting an instance of \");\n            b.append(this.timePeriodClass.getName());\n            b.append(\".\");\n            throw new SeriesException(b.toString());\n        }\n\n        \n        boolean added = false;\n        int count = getItemCount();\n        if (count == 0) {\n            this.data.add(item);\n            added = true;\n        }\n        else {\n            RegularTimePeriod last = getTimePeriod(getItemCount() - 1);\n            if (item.getPeriod().compareTo(last) > 0) {\n                this.data.add(item);\n                added = true;\n            }\n            else {\n                int index = Collections.binarySearch(this.data, item);\n                if (index < 0) {\n                    this.data.add(-index - 1, item);\n                    added = true;\n                }\n                else {\n                    StringBuffer b = new StringBuffer();\n                    b.append(\"You are attempting to add an observation for \");\n                    b.append(\"the time period \");\n                    b.append(item.getPeriod().toString());\n                    b.append(\" but the series already contains an observation\");\n                    b.append(\" for that time period. Duplicates are not \");\n                    b.append(\"permitted.  Try using the addOrUpdate() method.\");\n                    throw new SeriesException(b.toString());\n                }\n            }\n        }\n        if (added) {\n            \n            if (getItemCount() > this.maximumItemCount) {\n                this.data.remove(0);\n            }\n\n            removeAgedItems(false);  \n                                     \n                                     \n            if (notify) {\n                fireSeriesChanged();\n            }\n        }\n\n    }\n\n    \n    public void add(RegularTimePeriod period, double value) {\n        \n        add(period, value, true);\n    }\n\n    \n    public void add(RegularTimePeriod period, double value, boolean notify) {\n        \n        TimeSeriesDataItem item = new TimeSeriesDataItem(period, value);\n        add(item, notify);\n    }\n\n    \n    public void add(RegularTimePeriod period, Number value) {\n        \n        add(period, value, true);\n    }\n\n    \n    public void add(RegularTimePeriod period, Number value, boolean notify) {\n        \n        TimeSeriesDataItem item = new TimeSeriesDataItem(period, value);\n        add(item, notify);\n    }\n\n    \n    public void update(RegularTimePeriod period, Number value) {\n        TimeSeriesDataItem temp = new TimeSeriesDataItem(period, value);\n        int index = Collections.binarySearch(this.data, temp);\n        if (index >= 0) {\n            TimeSeriesDataItem pair = (TimeSeriesDataItem) this.data.get(index);\n            pair.setValue(value);\n            fireSeriesChanged();\n        }\n        else {\n            throw new SeriesException(\n                \"TimeSeries.update(TimePeriod, Number):  period does not exist.\"\n            );\n        }\n\n    }\n\n    \n    public void update(int index, Number value) {\n        TimeSeriesDataItem item = getDataItem(index);\n        item.setValue(value);\n        fireSeriesChanged();\n    }\n\n    \n    public TimeSeries addAndOrUpdate(TimeSeries series) {\n        TimeSeries overwritten = new TimeSeries(\"Overwritten values from: \"\n                + getKey(), series.getTimePeriodClass());\n        for (int i = 0; i < series.getItemCount(); i++) {\n            TimeSeriesDataItem item = series.getDataItem(i);\n            TimeSeriesDataItem oldItem = addOrUpdate(item.getPeriod(),\n                    item.getValue());\n            if (oldItem != null) {\n                overwritten.add(oldItem);\n            }\n        }\n        return overwritten;\n    }\n\n    \n    public TimeSeriesDataItem addOrUpdate(RegularTimePeriod period, double value) {\n        return addOrUpdate(period, new Double(value));\n    }\n\n    \n    public TimeSeriesDataItem addOrUpdate(RegularTimePeriod period, Number value) {\n\n        if (period == null) {\n            throw new IllegalArgumentException(\"Null 'period' argument.\");\n        }\n        TimeSeriesDataItem overwritten = null;\n\n        TimeSeriesDataItem key = new TimeSeriesDataItem(period, value);\n        int index = Collections.binarySearch(this.data, key);\n        if (index >= 0) {\n            TimeSeriesDataItem existing\n                = (TimeSeriesDataItem) this.data.get(index);\n            overwritten = (TimeSeriesDataItem) existing.clone();\n            existing.setValue(value);\n            removeAgedItems(false);  \n                                     \n                                     \n            fireSeriesChanged();\n        }\n        else {\n            this.data.add(-index - 1, new TimeSeriesDataItem(period, value));\n\n            \n            if (getItemCount() > this.maximumItemCount) {\n                this.data.remove(0);\n            }\n\n            removeAgedItems(false);  \n                                     \n                                     \n            fireSeriesChanged();\n        }\n        return overwritten;\n\n    }\n\n    \n    public void removeAgedItems(boolean notify) {\n        \n        \n        if (getItemCount() > 1) {\n            long latest = getTimePeriod(getItemCount() - 1).getSerialIndex();\n            boolean removed = false;\n            while ((latest - getTimePeriod(0).getSerialIndex())\n                    > this.maximumItemAge) {\n                this.data.remove(0);\n                removed = true;\n            }\n            if (removed && notify) {\n                fireSeriesChanged();\n            }\n        }\n    }\n\n    \n    public void removeAgedItems(long latest, boolean notify) {\n\n        \n        long index = Long.MAX_VALUE;\n        try {\n            Method m = RegularTimePeriod.class.getDeclaredMethod(\n                    \"createInstance\", new Class[] {Class.class, Date.class,\n                    TimeZone.class});\n            RegularTimePeriod newest = (RegularTimePeriod) m.invoke(\n                    this.timePeriodClass, new Object[] {this.timePeriodClass,\n                            new Date(latest), TimeZone.getDefault()});\n            index = newest.getSerialIndex();\n        }\n        catch (NoSuchMethodException e) {\n            e.printStackTrace();\n        }\n        catch (IllegalAccessException e) {\n            e.printStackTrace();\n        }\n        catch (InvocationTargetException e) {\n            e.printStackTrace();\n        }\n\n        \n        \n        boolean removed = false;\n        while (getItemCount() > 0 && (index\n                - getTimePeriod(0).getSerialIndex()) > this.maximumItemAge) {\n            this.data.remove(0);\n            removed = true;\n        }\n        if (removed && notify) {\n            fireSeriesChanged();\n        }\n    }\n\n    \n    public void clear() {\n        if (this.data.size() > 0) {\n            this.data.clear();\n            fireSeriesChanged();\n        }\n    }\n\n    \n    public void delete(RegularTimePeriod period) {\n        int index = getIndex(period);\n        if (index >= 0) {\n            this.data.remove(index);\n            fireSeriesChanged();\n        }\n    }\n\n    \n    public void delete(int start, int end) {\n        if (end < start) {\n            throw new IllegalArgumentException(\"Requires start <= end.\");\n        }\n        for (int i = 0; i <= (end - start); i++) {\n            this.data.remove(start);\n        }\n        fireSeriesChanged();\n    }\n\n    \n    public Object clone() throws CloneNotSupportedException {\n        TimeSeries clone = (TimeSeries) super.clone();\n        clone.data = (List) ObjectUtilities.deepClone(this.data);\n        return clone;\n    }\n\n    \n    public TimeSeries createCopy(int start, int end) throws CloneNotSupportedException {\n\n        if (start < 0) {\n            throw new IllegalArgumentException(\"Requires start >= 0.\");\n        }\n        if (end < start) {\n            throw new IllegalArgumentException(\"Requires start <= end.\");\n        }\n        TimeSeries copy = (TimeSeries) super.clone();\n\n        copy.data = new java.util.ArrayList();\n        if (this.data.size() > 0) {\n            for (int index = start; index <= end; index++) {\n                TimeSeriesDataItem item\n                    = (TimeSeriesDataItem) this.data.get(index);\n                TimeSeriesDataItem clone = (TimeSeriesDataItem) item.clone();\n                try {\n                    copy.add(clone);\n                }\n                catch (SeriesException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return copy;\n    }\n\n    \n    public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end) throws CloneNotSupportedException {\n\n        if (start == null) {\n            throw new IllegalArgumentException(\"Null 'start' argument.\");\n        }\n        if (end == null) {\n            throw new IllegalArgumentException(\"Null 'end' argument.\");\n        }\n        if (start.compareTo(end) > 0) {\n            throw new IllegalArgumentException(\n                    \"Requires start on or before end.\");\n        }\n        boolean emptyRange = false;\n        int startIndex = getIndex(start);\n        if (startIndex < 0) {\n            startIndex = -(startIndex + 1);\n            if (startIndex == this.data.size()) {\n                emptyRange = true;  \n            }\n        }\n        int endIndex = getIndex(end);\n        if (endIndex < 0) {             \n            endIndex = -(endIndex + 1); \n            endIndex = endIndex - 1;    \n        }\n        if ((endIndex < 0)  || (endIndex < startIndex)) {\n            emptyRange = true;\n        }\n        if (emptyRange) {\n            TimeSeries copy = (TimeSeries) super.clone();\n            copy.data = new java.util.ArrayList();\n            return copy;\n        }\n        else {\n            return createCopy(startIndex, endIndex);\n        }\n\n    }\n\n    \n    public boolean equals(Object object) {\n        if (object == this) {\n            return true;\n        }\n        if (!(object instanceof TimeSeries) || !super.equals(object)) {\n            return false;\n        }\n        TimeSeries s = (TimeSeries) object;\n        if (!ObjectUtilities.equal(getDomainDescription(),\n                s.getDomainDescription())) {\n            return false;\n        }\n\n        if (!ObjectUtilities.equal(getRangeDescription(),\n                s.getRangeDescription())) {\n            return false;\n        }\n\n        if (!getClass().equals(s.getClass())) {\n            return false;\n        }\n\n        if (getMaximumItemAge() != s.getMaximumItemAge()) {\n            return false;\n        }\n\n        if (getMaximumItemCount() != s.getMaximumItemCount()) {\n            return false;\n        }\n\n        int count = getItemCount();\n        if (count != s.getItemCount()) {\n            return false;\n        }\n        for (int i = 0; i < count; i++) {\n            if (!getDataItem(i).equals(s.getDataItem(i))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public int hashCode() {\n        int result = super.hashCode();\n        result = 29 * result + (this.domain != null ? this.domain.hashCode()\n                : 0);\n        result = 29 * result + (this.range != null ? this.range.hashCode() : 0);\n        result = 29 * result + (this.timePeriodClass != null\n                ? this.timePeriodClass.hashCode() : 0);\n        \n        \n        int count = getItemCount();\n        if (count > 0) {\n            TimeSeriesDataItem item = getDataItem(0);\n            result = 29 * result + item.hashCode();\n        }\n        if (count > 1) {\n            TimeSeriesDataItem item = getDataItem(count - 1);\n            result = 29 * result + item.hashCode();\n        }\n        if (count > 2) {\n            TimeSeriesDataItem item = getDataItem(count / 2);\n            result = 29 * result + item.hashCode();\n        }\n        result = 29 * result + this.maximumItemCount;\n        result = 29 * result + (int) this.maximumItemAge;\n        return result;\n    }\n\n}\n",
      "buggy_signatures": [
        "public TimeSeries(Comparable name, Class timePeriodClass)",
        "public TimeSeries(Comparable name, String domain, String range, Class timePeriodClass)",
        "public String getDomainDescription()",
        "public void setDomainDescription(String description)",
        "public String getRangeDescription()",
        "public void setRangeDescription(String description)",
        "public int getItemCount()",
        "public List getItems()",
        "public int getMaximumItemCount()",
        "public void setMaximumItemCount(int maximum)",
        "public long getMaximumItemAge()",
        "public void setMaximumItemAge(long periods)",
        "public Class getTimePeriodClass()",
        "public TimeSeriesDataItem getDataItem(int index)",
        "public TimeSeriesDataItem getDataItem(RegularTimePeriod period)",
        "public RegularTimePeriod getTimePeriod(int index)",
        "public RegularTimePeriod getNextTimePeriod()",
        "public Collection getTimePeriods()",
        "public Collection getTimePeriodsUniqueToOtherSeries(TimeSeries series)",
        "public int getIndex(RegularTimePeriod period)",
        "public Number getValue(int index)",
        "public Number getValue(RegularTimePeriod period)",
        "public void add(TimeSeriesDataItem item)",
        "public void add(TimeSeriesDataItem item, boolean notify)",
        "public void add(RegularTimePeriod period, double value)",
        "public void add(RegularTimePeriod period, double value, boolean notify)",
        "public void add(RegularTimePeriod period, Number value)",
        "public void add(RegularTimePeriod period, Number value, boolean notify)",
        "public void update(RegularTimePeriod period, Number value)",
        "public void update(int index, Number value)",
        "public TimeSeries addAndOrUpdate(TimeSeries series)",
        "public TimeSeriesDataItem addOrUpdate(RegularTimePeriod period, double value)",
        "public TimeSeriesDataItem addOrUpdate(RegularTimePeriod period, Number value)",
        "public void removeAgedItems(boolean notify)",
        "public void removeAgedItems(long latest, boolean notify)",
        "public void clear()",
        "public void delete(RegularTimePeriod period)",
        "public void delete(int start, int end)",
        "public Object clone() throws CloneNotSupportedException",
        "public TimeSeries createCopy(int start, int end) throws CloneNotSupportedException",
        "public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end) throws CloneNotSupportedException",
        "public boolean equals(Object object)",
        "public int hashCode()"
      ],
      "fixed_signatures": [
        "public TimeSeries(Comparable name, Class timePeriodClass)",
        "public TimeSeries(Comparable name, String domain, String range, Class timePeriodClass)",
        "public String getDomainDescription()",
        "public void setDomainDescription(String description)",
        "public String getRangeDescription()",
        "public void setRangeDescription(String description)",
        "public int getItemCount()",
        "public List getItems()",
        "public int getMaximumItemCount()",
        "public void setMaximumItemCount(int maximum)",
        "public long getMaximumItemAge()",
        "public void setMaximumItemAge(long periods)",
        "public Class getTimePeriodClass()",
        "public TimeSeriesDataItem getDataItem(int index)",
        "public TimeSeriesDataItem getDataItem(RegularTimePeriod period)",
        "public RegularTimePeriod getTimePeriod(int index)",
        "public RegularTimePeriod getNextTimePeriod()",
        "public Collection getTimePeriods()",
        "public Collection getTimePeriodsUniqueToOtherSeries(TimeSeries series)",
        "public int getIndex(RegularTimePeriod period)",
        "public Number getValue(int index)",
        "public Number getValue(RegularTimePeriod period)",
        "public void add(TimeSeriesDataItem item)",
        "public void add(TimeSeriesDataItem item, boolean notify)",
        "public void add(RegularTimePeriod period, double value)",
        "public void add(RegularTimePeriod period, double value, boolean notify)",
        "public void add(RegularTimePeriod period, Number value)",
        "public void add(RegularTimePeriod period, Number value, boolean notify)",
        "public void update(RegularTimePeriod period, Number value)",
        "public void update(int index, Number value)",
        "public TimeSeries addAndOrUpdate(TimeSeries series)",
        "public TimeSeriesDataItem addOrUpdate(RegularTimePeriod period, double value)",
        "public TimeSeriesDataItem addOrUpdate(RegularTimePeriod period, Number value)",
        "public void removeAgedItems(boolean notify)",
        "public void removeAgedItems(long latest, boolean notify)",
        "public void clear()",
        "public void delete(RegularTimePeriod period)",
        "public void delete(int start, int end)",
        "public Object clone() throws CloneNotSupportedException",
        "public TimeSeries createCopy(int start, int end) throws CloneNotSupportedException",
        "public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end) throws CloneNotSupportedException",
        "public boolean equals(Object object)",
        "public int hashCode()"
      ],
      "methods": [
        {
          "buggy_method": "  public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end) throws CloneNotSupportedException {\n\n  if (start == null) {\n  throw new IllegalArgumentException(\"Null 'start' argument.\");\n  }\n  if (end == null) {\n  throw new IllegalArgumentException(\"Null 'end' argument.\");\n  }\n  if (start.compareTo(end) > 0) {\n  throw new IllegalArgumentException(\n  \"Requires start on or before end.\");\n  }\n  boolean emptyRange = false;\n  int startIndex = getIndex(start);\n  if (startIndex < 0) {\n  startIndex = -(startIndex + 1);\n  if (startIndex == this.data.size()) {\n  emptyRange = true;  \n  }\n  }\n  int endIndex = getIndex(end);\n  if (endIndex < 0) {  \n  endIndex = -(endIndex + 1); \n  endIndex = endIndex - 1;  \n  }\n  if (endIndex < 0) {\n  emptyRange = true;\n  }\n  if (emptyRange) {\n  TimeSeries copy = (TimeSeries) super.clone();\n  copy.data = new java.util.ArrayList();\n  return copy;\n  }\n  else {\n  return createCopy(startIndex, endIndex);\n  }\n\n  }",
          "fixed_method": "  public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end) throws CloneNotSupportedException {\n\n  if (start == null) {\n  throw new IllegalArgumentException(\"Null 'start' argument.\");\n  }\n  if (end == null) {\n  throw new IllegalArgumentException(\"Null 'end' argument.\");\n  }\n  if (start.compareTo(end) > 0) {\n  throw new IllegalArgumentException(\n  \"Requires start on or before end.\");\n  }\n  boolean emptyRange = false;\n  int startIndex = getIndex(start);\n  if (startIndex < 0) {\n  startIndex = -(startIndex + 1);\n  if (startIndex == this.data.size()) {\n  emptyRange = true;  \n  }\n  }\n  int endIndex = getIndex(end);\n  if (endIndex < 0) {  \n  endIndex = -(endIndex + 1); \n  endIndex = endIndex - 1;  \n  }\n  if ((endIndex < 0)  || (endIndex < startIndex)) {\n  emptyRange = true;\n  }\n  if (emptyRange) {\n  TimeSeries copy = (TimeSeries) super.clone();\n  copy.data = new java.util.ArrayList();\n  return copy;\n  }\n  else {\n  return createCopy(startIndex, endIndex);\n  }\n\n  }",
          "diff": [
            "@@ -941,7 +941,7 @@",
            "             endIndex = -(endIndex + 1); // this is first item AFTER end period\n",
            "             endIndex = endIndex - 1;    // so this is last item BEFORE end\n",
            "         }\n",
            "-        if (endIndex < 0) {\n",
            "+        if ((endIndex < 0)  || (endIndex < startIndex)) {\n",
            "             emptyRange = true;\n",
            "         }\n",
            "         if (emptyRange) {\n"
          ],
          "changed_lines": 2
        }
      ]
    }
  ]
}
