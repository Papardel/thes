{
  "bug_id": "14",
  "failed_tests": {
    "org.apache.commons.jxpath.ri.compiler.CoreFunctionTest": [
      {
        "methodName": "testCoreFunctions",
        "error": "junit.framework.AssertionFailedError",
        "message": "Evaluating <round('NaN')> expected:<NaN> but was:<0.0>",
        "fail_line": "        assertXPathValue(context, \"round('NaN')\", new Double(Double.NaN));",
        "test_source": "  public void testCoreFunctions() {\n  assertXPathValue(context, \"string(2)\", \"2\");\n  assertXPathValue(context, \"string($nan)\", \"NaN\");\n  assertXPathValue(context, \"string(-$nan)\", \"NaN\");\n  assertXPathValue(context, \"string(-2 div 0)\", \"-Infinity\");\n  assertXPathValue(context, \"string(2 div 0)\", \"Infinity\");\n  assertXPathValue(context, \"concat('a', 'b', 'c')\", \"abc\");\n  assertXPathValue(context, \"starts-with('abc', 'ab')\", Boolean.TRUE);\n  assertXPathValue(context, \"starts-with('xabc', 'ab')\", Boolean.FALSE);\n  assertXPathValue(context, \"contains('xabc', 'ab')\", Boolean.TRUE);\n  assertXPathValue(context, \"contains('xabc', 'ba')\", Boolean.FALSE);\n  assertXPathValue(\n  context,\n  \"substring-before('1999/04/01', '/')\",\n  \"1999\");\n  assertXPathValue(\n  context,\n  \"substring-after('1999/04/01', '/')\",\n  \"04/01\");\n  assertXPathValue(context, \"substring('12345', 2, 3)\", \"234\");\n  assertXPathValue(context, \"substring('12345', 2)\", \"2345\");\n  assertXPathValue(context, \"substring('12345', 1.5, 2.6)\", \"234\");\n  assertXPathValue(context, \"substring('12345', 0, 3)\", \"12\");\n  assertXPathValue(context, \"substring('12345', 0 div 0, 3)\", \"\");\n  assertXPathValue(context, \"substring('12345', 1, 0 div 0)\", \"\");\n  assertXPathValue(context, \"substring('12345', -42, 1 div 0)\", \"12345\");\n  assertXPathValue(context, \"substring('12345', -1 div 0, 1 div 0)\", \"\");\n  assertXPathValue(context, \"substring('12345', 6, 6)\", \"\");\n  assertXPathValue(context, \"substring('12345', 7, 8)\", \"\");\n  assertXPathValue(context, \"substring('12345', 7)\", \"\");\n  assertXPathValue(context, \"string-length('12345')\", new Double(5));\n  assertXPathValue(context, \"normalize-space(' abc  def  ')\", \"abc def\");\n  assertXPathValue(context, \"normalize-space('abc def')\", \"abc def\");\n  assertXPathValue(context, \"normalize-space('  ')\", \"\");\n  assertXPathValue(context, \"translate('--aaa--', 'abc-', 'ABC')\", \"AAA\");\n  assertXPathValue(context, \"boolean(1)\", Boolean.TRUE);\n  assertXPathValue(context, \"boolean(0)\", Boolean.FALSE);\n  assertXPathValue(context, \"boolean('x')\", Boolean.TRUE);\n  assertXPathValue(context, \"boolean('')\", Boolean.FALSE);\n  assertXPathValue(context, \"boolean(/list)\", Boolean.TRUE);\n  assertXPathValue(context, \"boolean(/list[position() < 1])\", Boolean.FALSE);\n\n  assertXPathValue(context, \"true()\", Boolean.TRUE);\n  assertXPathValue(context, \"false()\", Boolean.FALSE);\n  assertXPathValue(context, \"not(false())\", Boolean.TRUE);\n  assertXPathValue(context, \"not(true())\", Boolean.FALSE);\n  assertXPathValue(context, \"null()\", null);  \n  assertXPathValue(context, \"number('1')\", new Double(1));\n  assertXPathValue(context, \"number($bool_true)\", new Double(1));\n  assertXPathValue(context, \"number($bool_false)\", new Double(0));\n  assertXPathValue(context, \"floor(1.5)\", new Double(1));\n  assertXPathValue(context, \"floor(-1.5)\", new Double(-2));\n  assertXPathValue(context, \"ceiling(1.5)\", new Double(2));\n  assertXPathValue(context, \"ceiling(-1.5)\", new Double(-1));\n  assertXPathValue(context, \"round(1.5)\", new Double(2));\n  assertXPathValue(context, \"round(-1.5)\", new Double(-1));\n\n  assertXPathValue(context, \"floor('NaN')\", new Double(Double.NaN));\n  assertXPathValue(context, \"floor(-2 div 0)\", new Double(Double.NEGATIVE_INFINITY));\n  assertXPathValue(context, \"floor(2 div 0)\", new Double(Double.POSITIVE_INFINITY));\n  assertXPathValue(context, \"ceiling('NaN')\", new Double(Double.NaN));\n  assertXPathValue(context, \"ceiling(-2 div 0)\", new Double(Double.NEGATIVE_INFINITY));\n  assertXPathValue(context, \"ceiling(2 div 0)\", new Double(Double.POSITIVE_INFINITY));\n  assertXPathValue(context, \"round('NaN')\", new Double(Double.NaN));\n  assertXPathValue(context, \"round(-2 div 0)\", new Double(Double.NEGATIVE_INFINITY));\n  assertXPathValue(context, \"round(2 div 0)\", new Double(Double.POSITIVE_INFINITY));\n  }",
        "stack": [
          "JXPathTestCase.assertXPathValue line 55, CoreFunctionTest.testCoreFunctions line 126"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/jxpath/ri/compiler/CoreFunction.java",
      "buggy_full_code": "\npackage org.apache.commons.jxpath.ri.compiler;\n\nimport java.text.DecimalFormat;\nimport java.text.DecimalFormatSymbols;\nimport java.text.NumberFormat;\nimport java.util.Collection;\nimport java.util.Locale;\n\nimport org.apache.commons.jxpath.BasicNodeSet;\nimport org.apache.commons.jxpath.JXPathContext;\nimport org.apache.commons.jxpath.JXPathException;\nimport org.apache.commons.jxpath.JXPathInvalidSyntaxException;\nimport org.apache.commons.jxpath.NodeSet;\nimport org.apache.commons.jxpath.ri.Compiler;\nimport org.apache.commons.jxpath.ri.EvalContext;\nimport org.apache.commons.jxpath.ri.InfoSetUtil;\nimport org.apache.commons.jxpath.ri.axes.NodeSetContext;\nimport org.apache.commons.jxpath.ri.model.NodePointer;\n\n\npublic class CoreFunction extends Operation { private static final Double ZERO = new Double(0); private int functionCode; public CoreFunction(int functionCode, Expression args[]) {\n        super(args);\n        this.functionCode = functionCode;\n    }\n\n    public int getFunctionCode() {\n        return functionCode;\n    }\n    \n    protected String getFunctionName() {\n        switch (functionCode) {\n            case Compiler.FUNCTION_LAST :\n                return \"last\";\n            case Compiler.FUNCTION_POSITION :\n                return \"position\";\n            case Compiler.FUNCTION_COUNT :\n                return \"count\";\n            case Compiler.FUNCTION_ID :\n                return \"id\";\n            case Compiler.FUNCTION_LOCAL_NAME :\n                return \"local-name\";\n            case Compiler.FUNCTION_NAMESPACE_URI :\n                return \"namespace-uri\";\n            case Compiler.FUNCTION_NAME :\n                return \"name\";\n            case Compiler.FUNCTION_STRING :\n                return \"string\";\n            case Compiler.FUNCTION_CONCAT :\n                return \"concat\";\n            case Compiler.FUNCTION_STARTS_WITH :\n                return \"starts-with\";\n            case Compiler.FUNCTION_CONTAINS :\n                return \"contains\";\n            case Compiler.FUNCTION_SUBSTRING_BEFORE :\n                return \"substring-before\";\n            case Compiler.FUNCTION_SUBSTRING_AFTER :\n                return \"substring-after\";\n            case Compiler.FUNCTION_SUBSTRING :\n                return \"substring\";\n            case Compiler.FUNCTION_STRING_LENGTH :\n                return \"string-length\";\n            case Compiler.FUNCTION_NORMALIZE_SPACE :\n                return \"normalize-space\";\n            case Compiler.FUNCTION_TRANSLATE :\n                return \"translate\";\n            case Compiler.FUNCTION_BOOLEAN :\n                return \"boolean\";\n            case Compiler.FUNCTION_NOT :\n                return \"not\";\n            case Compiler.FUNCTION_TRUE :\n                return \"true\";\n            case Compiler.FUNCTION_FALSE :\n                return \"false\";\n            case Compiler.FUNCTION_LANG :\n                return \"lang\";\n            case Compiler.FUNCTION_NUMBER :\n                return \"number\";\n            case Compiler.FUNCTION_SUM :\n                return \"sum\";\n            case Compiler.FUNCTION_FLOOR :\n                return \"floor\";\n            case Compiler.FUNCTION_CEILING :\n                return \"ceiling\";\n            case Compiler.FUNCTION_ROUND :\n                return \"round\";\n            case Compiler.FUNCTION_KEY :\n                return \"key\";\n            case Compiler.FUNCTION_FORMAT_NUMBER:\n                return \"format-number\";\n        }\n        return \"unknownFunction\" + functionCode + \"()\";\n    }\n\n    public Expression getArg1() {\n        return args[0];\n    }\n\n    public Expression getArg2() {\n        return args[1];\n    }\n\n    public Expression getArg3() {\n        return args[2];\n    }\n\n    public int getArgumentCount() {\n        if (args == null) {\n            return 0;\n        }\n        return args.length;\n    }\n\n    \n    public boolean computeContextDependent() {\n        if (super.computeContextDependent()) {\n            return true;\n        }\n\n        switch(functionCode) {\n            case Compiler.FUNCTION_LAST:\n            case Compiler.FUNCTION_POSITION:\n                return true;\n\n            case Compiler.FUNCTION_BOOLEAN:\n            case Compiler.FUNCTION_LOCAL_NAME:\n            case Compiler.FUNCTION_NAME:\n            case Compiler.FUNCTION_NAMESPACE_URI:\n            case Compiler.FUNCTION_STRING:\n            case Compiler.FUNCTION_LANG:\n            case Compiler.FUNCTION_NUMBER:\n                return args == null || args.length == 0;\n\n            case Compiler.FUNCTION_COUNT:\n            case Compiler.FUNCTION_ID:\n            case Compiler.FUNCTION_CONCAT:\n            case Compiler.FUNCTION_STARTS_WITH:\n            case Compiler.FUNCTION_CONTAINS:\n            case Compiler.FUNCTION_SUBSTRING_BEFORE:\n            case Compiler.FUNCTION_SUBSTRING_AFTER:\n            case Compiler.FUNCTION_SUBSTRING:\n            case Compiler.FUNCTION_STRING_LENGTH:\n            case Compiler.FUNCTION_NORMALIZE_SPACE:\n            case Compiler.FUNCTION_TRANSLATE:\n            case Compiler.FUNCTION_NOT:\n            case Compiler.FUNCTION_TRUE:\n            case Compiler.FUNCTION_FALSE:\n            case Compiler.FUNCTION_SUM:\n            case Compiler.FUNCTION_FLOOR:\n            case Compiler.FUNCTION_CEILING:\n            case Compiler.FUNCTION_ROUND:\n                return false;\n                \n            case Compiler.FUNCTION_FORMAT_NUMBER:\n                return args != null && args.length == 2;                             \n        }\n\n        return false;\n    }\n\n    public String toString() {\n        StringBuffer buffer = new StringBuffer();\n        buffer.append(getFunctionName());\n        buffer.append('(');\n        Expression args[] = getArguments();\n        if (args != null) {\n            for (int i = 0; i < args.length; i++) {\n                if (i > 0) {\n                    buffer.append(\", \");\n                }\n                buffer.append(args[i]);\n            }\n        }\n        buffer.append(')');\n        return buffer.toString();\n    }\n\n    public Object compute(EvalContext context) {\n        return computeValue(context);\n    }\n\n    \n    public Object computeValue(EvalContext context) {\n        switch (functionCode) {\n            case Compiler.FUNCTION_LAST :\n                return functionLast(context);\n            case Compiler.FUNCTION_POSITION :\n                return functionPosition(context);\n            case Compiler.FUNCTION_COUNT :\n                return functionCount(context);\n            case Compiler.FUNCTION_LANG :\n                return functionLang(context);\n            case Compiler.FUNCTION_ID :\n                return functionID(context);\n            case Compiler.FUNCTION_LOCAL_NAME :\n                return functionLocalName(context);\n            case Compiler.FUNCTION_NAMESPACE_URI :\n                return functionNamespaceURI(context);\n            case Compiler.FUNCTION_NAME :\n                return functionName(context);\n            case Compiler.FUNCTION_STRING :\n                return functionString(context);\n            case Compiler.FUNCTION_CONCAT :\n                return functionConcat(context);\n            case Compiler.FUNCTION_STARTS_WITH :\n                return functionStartsWith(context);\n            case Compiler.FUNCTION_CONTAINS :\n                return functionContains(context);\n            case Compiler.FUNCTION_SUBSTRING_BEFORE :\n                return functionSubstringBefore(context);\n            case Compiler.FUNCTION_SUBSTRING_AFTER :\n                return functionSubstringAfter(context);\n            case Compiler.FUNCTION_SUBSTRING :\n                return functionSubstring(context);\n            case Compiler.FUNCTION_STRING_LENGTH :\n                return functionStringLength(context);\n            case Compiler.FUNCTION_NORMALIZE_SPACE :\n                return functionNormalizeSpace(context);\n            case Compiler.FUNCTION_TRANSLATE :\n                return functionTranslate(context);\n            case Compiler.FUNCTION_BOOLEAN :\n                return functionBoolean(context);\n            case Compiler.FUNCTION_NOT :\n                return functionNot(context);\n            case Compiler.FUNCTION_TRUE :\n                return functionTrue(context);\n            case Compiler.FUNCTION_FALSE :\n                return functionFalse(context);\n            case Compiler.FUNCTION_NULL :\n                return functionNull(context);\n            case Compiler.FUNCTION_NUMBER :\n                return functionNumber(context);\n            case Compiler.FUNCTION_SUM :\n                return functionSum(context);\n            case Compiler.FUNCTION_FLOOR :\n                return functionFloor(context);\n            case Compiler.FUNCTION_CEILING :\n                return functionCeiling(context);\n            case Compiler.FUNCTION_ROUND :\n                return functionRound(context);\n            case Compiler.FUNCTION_KEY :\n                return functionKey(context);\n            case Compiler.FUNCTION_FORMAT_NUMBER :\n                return functionFormatNumber(context);\n        }\n        return null;\n    }\n\n    protected Object functionLast(EvalContext context) {\n        assertArgCount(0);\n        \n        \n        int old = context.getCurrentPosition();\n        context.reset();\n        int count = 0;\n        while (context.nextNode()) {\n            count++;\n        }\n\n        \n        if (old != 0) {\n            context.setPosition(old);\n        }\n        return new Double(count);\n    }\n\n    protected Object functionPosition(EvalContext context) {\n        assertArgCount(0);\n        return new Integer(context.getCurrentPosition());\n    }\n\n    protected Object functionCount(EvalContext context) {\n        assertArgCount(1);\n        Expression arg1 = getArg1();\n        int count = 0;\n        Object value = arg1.compute(context);\n        if (value instanceof NodePointer) {\n            value = ((NodePointer) value).getValue();\n        }\n        if (value instanceof EvalContext) {\n            EvalContext ctx = (EvalContext) value;\n            while (ctx.hasNext()) {\n                ctx.next();\n                count++;\n            }\n        }\n        else if (value instanceof Collection) {\n            count = ((Collection) value).size();\n        }\n        else if (value == null) {\n            count = 0;\n        }\n        else {\n            count = 1;\n        }\n        return new Double(count);\n    }\n\n    protected Object functionLang(EvalContext context) {\n        assertArgCount(1);\n        String lang = InfoSetUtil.stringValue(getArg1().computeValue(context));\n        NodePointer pointer = (NodePointer) context.getSingleNodePointer();\n        if (pointer == null) {\n            return Boolean.FALSE;\n        }\n        return pointer.isLanguage(lang) ? Boolean.TRUE : Boolean.FALSE;\n    }\n\n    protected Object functionID(EvalContext context) {\n        assertArgCount(1);\n        String id = InfoSetUtil.stringValue(getArg1().computeValue(context));\n        JXPathContext jxpathContext = context.getJXPathContext();\n        NodePointer pointer = (NodePointer) jxpathContext.getContextPointer();\n        return pointer.getPointerByID(jxpathContext, id);\n    }\n\n    protected Object functionKey(EvalContext context) {\n        assertArgCount(2);\n        String key = InfoSetUtil.stringValue(getArg1().computeValue(context));\n        Object value = getArg2().compute(context);\n        EvalContext ec = null;\n        if (value instanceof EvalContext) {\n            ec = (EvalContext) value;\n            if (ec.hasNext()) {\n                value = ((NodePointer) ec.next()).getValue();\n            } else { \n                return new BasicNodeSet();\n            }\n        }\n        JXPathContext jxpathContext = context.getJXPathContext();\n        NodeSet nodeSet = jxpathContext.getNodeSetByKey(key, value);\n        if (ec != null && ec.hasNext()) {\n            BasicNodeSet accum = new BasicNodeSet();\n            accum.add(nodeSet);\n            while (ec.hasNext()) {\n                value = ((NodePointer) ec.next()).getValue();\n                accum.add(jxpathContext.getNodeSetByKey(key, value));\n            }\n            nodeSet = accum;\n        }\n        return new NodeSetContext(context, nodeSet);\n    }\n\n    protected Object functionNamespaceURI(EvalContext context) {\n        if (getArgumentCount() == 0) {\n            NodePointer ptr = context.getCurrentNodePointer();\n            String str = ptr.getNamespaceURI();\n            return str == null ? \"\" : str;\n        }\n        assertArgCount(1);\n        Object set = getArg1().compute(context);\n        if (set instanceof EvalContext) {\n            EvalContext ctx = (EvalContext) set;\n            if (ctx.hasNext()) {\n                NodePointer ptr = (NodePointer) ctx.next();\n                String str = ptr.getNamespaceURI();\n                return str == null ? \"\" : str;\n            }\n        }\n        return \"\";\n    }\n\n    protected Object functionLocalName(EvalContext context) {\n        if (getArgumentCount() == 0) {\n            NodePointer ptr = context.getCurrentNodePointer();\n            return ptr.getName().getName();\n        }\n        assertArgCount(1);\n        Object set = getArg1().compute(context);\n        if (set instanceof EvalContext) {\n            EvalContext ctx = (EvalContext) set;\n            if (ctx.hasNext()) {\n                NodePointer ptr = (NodePointer) ctx.next();\n                return ptr.getName().getName();\n            }\n        }\n        return \"\";\n    }\n\n    protected Object functionName(EvalContext context) {\n        if (getArgumentCount() == 0) {\n            NodePointer ptr = context.getCurrentNodePointer();\n            return ptr.getName().toString();\n        }\n        assertArgCount(1);\n        Object set = getArg1().compute(context);\n        if (set instanceof EvalContext) {\n            EvalContext ctx = (EvalContext) set;\n            if (ctx.hasNext()) {\n                NodePointer ptr = (NodePointer) ctx.next();\n                return ptr.getName().toString();\n            }\n        }\n        return \"\";\n    }\n\n    protected Object functionString(EvalContext context) {\n        if (getArgumentCount() == 0) {\n            return InfoSetUtil.stringValue(context.getCurrentNodePointer());\n        }\n        assertArgCount(1);\n        return InfoSetUtil.stringValue(getArg1().computeValue(context));\n    }\n\n    protected Object functionConcat(EvalContext context) {\n        if (getArgumentCount() < 2) {\n            assertArgCount(2);\n        }\n        StringBuffer buffer = new StringBuffer();\n        Expression args[] = getArguments();\n        for (int i = 0; i < args.length; i++) {\n            buffer.append(InfoSetUtil.stringValue(args[i].compute(context)));\n        }\n        return buffer.toString();\n    }\n\n    protected Object functionStartsWith(EvalContext context) {\n        assertArgCount(2);\n        String s1 = InfoSetUtil.stringValue(getArg1().computeValue(context));\n        String s2 = InfoSetUtil.stringValue(getArg2().computeValue(context));\n        return s1.startsWith(s2) ? Boolean.TRUE : Boolean.FALSE;\n    }\n\n    protected Object functionContains(EvalContext context) {\n        assertArgCount(2);\n        String s1 = InfoSetUtil.stringValue(getArg1().computeValue(context));\n        String s2 = InfoSetUtil.stringValue(getArg2().computeValue(context));\n        return s1.indexOf(s2) != -1 ? Boolean.TRUE : Boolean.FALSE;\n    }\n\n    protected Object functionSubstringBefore(EvalContext context) {\n        assertArgCount(2);\n        String s1 = InfoSetUtil.stringValue(getArg1().computeValue(context));\n        String s2 = InfoSetUtil.stringValue(getArg2().computeValue(context));\n        int index = s1.indexOf(s2);\n        if (index == -1) {\n            return \"\";\n        }\n        return s1.substring(0, index);\n    }\n\n    protected Object functionSubstringAfter(EvalContext context) {\n        assertArgCount(2);\n        String s1 = InfoSetUtil.stringValue(getArg1().computeValue(context));\n        String s2 = InfoSetUtil.stringValue(getArg2().computeValue(context));\n        int index = s1.indexOf(s2);\n        if (index == -1) {\n            return \"\";\n        }\n        return s1.substring(index + s2.length());\n    }\n\n    protected Object functionSubstring(EvalContext context) {\n        int ac = getArgumentCount();\n        if (ac != 2 && ac != 3) {\n            assertArgCount(2);\n        }\n\n        String s1 = InfoSetUtil.stringValue(getArg1().computeValue(context));\n        double from = InfoSetUtil.doubleValue(getArg2().computeValue(context));\n        if (Double.isNaN(from)) {\n            return \"\";\n        }\n\n        from = Math.round(from);\n        if (from > s1.length() + 1) {\n            return \"\";\n        }\n        if (ac == 2) {\n            if (from < 1) {\n                from = 1;\n            }\n            return s1.substring((int) from - 1);\n        }\n        double length =\n            InfoSetUtil.doubleValue(getArg3().computeValue(context));\n        length = Math.round(length);\n        if (length < 0) {\n            return \"\";\n        }\n\n        double to = from + length;\n        if (to < 1) {\n            return \"\";\n        }\n\n        if (to > s1.length() + 1) {\n            if (from < 1) {\n                from = 1;\n            }\n            return s1.substring((int) from - 1);\n        }\n\n        if (from < 1) {\n            from = 1;\n        }\n        return s1.substring((int) from - 1, (int) (to - 1));\n    }\n\n    protected Object functionStringLength(EvalContext context) {\n        String s;\n        if (getArgumentCount() == 0) {\n            s = InfoSetUtil.stringValue(context.getCurrentNodePointer());\n        }\n        else {\n            assertArgCount(1);\n            s = InfoSetUtil.stringValue(getArg1().computeValue(context));\n        }\n        return new Double(s.length());\n    }\n\n    protected Object functionNormalizeSpace(EvalContext context) {\n        assertArgCount(1);\n        String s = InfoSetUtil.stringValue(getArg1().computeValue(context));\n        char chars[] = s.toCharArray();\n        int out = 0;\n        int phase = 0;\n        for (int in = 0; in < chars.length; in++) {\n            switch(chars[in]) {\n                case 0x20:\n                case 0x9:\n                case 0xD:\n                case 0xA:\n                    if (phase == 0) {      \n                        ;\n                    }\n                    else if (phase == 1) { \n                        phase = 2;\n                        chars[out++] = ' ';\n                    }\n                    break;\n                default:\n                    chars[out++] = chars[in];\n                    phase = 1;\n            }\n        }\n        if (phase == 2) { \n            out--;\n        }\n        return new String(chars, 0, out);\n    }\n\n    protected Object functionTranslate(EvalContext context) {\n        assertArgCount(3);\n        String s1 = InfoSetUtil.stringValue(getArg1().computeValue(context));\n        String s2 = InfoSetUtil.stringValue(getArg2().computeValue(context));\n        String s3 = InfoSetUtil.stringValue(getArg3().computeValue(context));\n        char chars[] = s1.toCharArray();\n        int out = 0;\n        for (int in = 0; in < chars.length; in++) {\n            char c = chars[in];\n            int inx = s2.indexOf(c);\n            if (inx != -1) {\n                if (inx < s3.length()) {\n                    chars[out++] = s3.charAt(inx);\n                }\n            }\n            else {\n                chars[out++] = c;\n            }\n        }\n        return new String(chars, 0, out);\n    }\n\n    protected Object functionBoolean(EvalContext context) {\n        assertArgCount(1);\n        return InfoSetUtil.booleanValue(getArg1().computeValue(context))\n            ? Boolean.TRUE\n            : Boolean.FALSE;\n    }\n\n    protected Object functionNot(EvalContext context) {\n        assertArgCount(1);\n        return InfoSetUtil.booleanValue(getArg1().computeValue(context))\n            ? Boolean.FALSE\n            : Boolean.TRUE;\n    }\n\n    protected Object functionTrue(EvalContext context) {\n        assertArgCount(0);\n        return Boolean.TRUE;\n    }\n\n    protected Object functionFalse(EvalContext context) {\n        assertArgCount(0);\n        return Boolean.FALSE;\n    }\n\n    protected Object functionNull(EvalContext context) {\n        assertArgCount(0);\n        return null;\n    }\n\n    protected Object functionNumber(EvalContext context) {\n        if (getArgumentCount() == 0) {\n            return InfoSetUtil.number(context.getCurrentNodePointer());\n        }\n        assertArgCount(1);\n        return InfoSetUtil.number(getArg1().computeValue(context));\n    }\n\n    protected Object functionSum(EvalContext context) {\n        assertArgCount(1);\n        Object v = getArg1().compute(context);\n        if (v == null) {\n            return ZERO;\n        }\n        if (v instanceof EvalContext) {\n            double sum = 0.0;\n            EvalContext ctx = (EvalContext) v;\n            while (ctx.hasNext()) {\n                NodePointer ptr = (NodePointer) ctx.next();\n                sum += InfoSetUtil.doubleValue(ptr);\n            }\n            return new Double(sum);\n        }\n        throw new JXPathException(\n            \"Invalid argument type for 'sum': \" + v.getClass().getName());\n    }\n\n    protected Object functionFloor(EvalContext context) {\n        assertArgCount(1);\n        double v = InfoSetUtil.doubleValue(getArg1().computeValue(context));\n        return new Double(Math.floor(v));\n    }\n\n    protected Object functionCeiling(EvalContext context) {\n        assertArgCount(1);\n        double v = InfoSetUtil.doubleValue(getArg1().computeValue(context));\n        return new Double(Math.ceil(v));\n    }\n\n    protected Object functionRound(EvalContext context) {\n        assertArgCount(1);\n        double v = InfoSetUtil.doubleValue(getArg1().computeValue(context));\n        return new Double(Math.round(v));\n    }\n\n    private Object functionFormatNumber(EvalContext context) {\n        int ac = getArgumentCount();\n        if (ac != 2 && ac != 3) {\n            assertArgCount(2);\n        }\n\n        double number =\n            InfoSetUtil.doubleValue(getArg1().computeValue(context));\n        String pattern =\n            InfoSetUtil.stringValue(getArg2().computeValue(context));\n\n        DecimalFormatSymbols symbols = null;\n        if (ac == 3) {\n            String symbolsName =\n                InfoSetUtil.stringValue(getArg3().computeValue(context));\n            symbols =\n                context.getJXPathContext().getDecimalFormatSymbols(symbolsName);\n        }\n        else {\n            NodePointer pointer = context.getCurrentNodePointer();\n            Locale locale;\n            if (pointer != null) {\n                locale = pointer.getLocale();\n            }\n            else {\n                locale = context.getJXPathContext().getLocale();\n            }\n            symbols = new DecimalFormatSymbols(locale);\n        }\n        \n        DecimalFormat format = (DecimalFormat) NumberFormat.getInstance();\n        format.setDecimalFormatSymbols(symbols);\n        format.applyLocalizedPattern(pattern);\n        return format.format(number);\n    }\n\n    private void assertArgCount(int count) {\n        assertArgRange(count, count);\n    }\n\n    private void assertArgRange(int min, int max) {\n        int ct = getArgumentCount();\n        if (ct < min || ct > max) {\n            throw new JXPathInvalidSyntaxException(\n                    \"Incorrect number of arguments: \" + this);\n        }\n    }\n}",
      "fixed_full_code": "\npackage org.apache.commons.jxpath.ri.compiler;\n\nimport java.text.DecimalFormat;\nimport java.text.DecimalFormatSymbols;\nimport java.text.NumberFormat;\nimport java.util.Collection;\nimport java.util.Locale;\n\nimport org.apache.commons.jxpath.BasicNodeSet;\nimport org.apache.commons.jxpath.JXPathContext;\nimport org.apache.commons.jxpath.JXPathException;\nimport org.apache.commons.jxpath.JXPathInvalidSyntaxException;\nimport org.apache.commons.jxpath.NodeSet;\nimport org.apache.commons.jxpath.ri.Compiler;\nimport org.apache.commons.jxpath.ri.EvalContext;\nimport org.apache.commons.jxpath.ri.InfoSetUtil;\nimport org.apache.commons.jxpath.ri.axes.NodeSetContext;\nimport org.apache.commons.jxpath.ri.model.NodePointer;\n\n\npublic class CoreFunction extends Operation { private static final Double ZERO = new Double(0); private int functionCode; public CoreFunction(int functionCode, Expression args[]) {\n        super(args);\n        this.functionCode = functionCode;\n    }\n\n    public int getFunctionCode() {\n        return functionCode;\n    }\n    \n    protected String getFunctionName() {\n        switch (functionCode) {\n            case Compiler.FUNCTION_LAST :\n                return \"last\";\n            case Compiler.FUNCTION_POSITION :\n                return \"position\";\n            case Compiler.FUNCTION_COUNT :\n                return \"count\";\n            case Compiler.FUNCTION_ID :\n                return \"id\";\n            case Compiler.FUNCTION_LOCAL_NAME :\n                return \"local-name\";\n            case Compiler.FUNCTION_NAMESPACE_URI :\n                return \"namespace-uri\";\n            case Compiler.FUNCTION_NAME :\n                return \"name\";\n            case Compiler.FUNCTION_STRING :\n                return \"string\";\n            case Compiler.FUNCTION_CONCAT :\n                return \"concat\";\n            case Compiler.FUNCTION_STARTS_WITH :\n                return \"starts-with\";\n            case Compiler.FUNCTION_CONTAINS :\n                return \"contains\";\n            case Compiler.FUNCTION_SUBSTRING_BEFORE :\n                return \"substring-before\";\n            case Compiler.FUNCTION_SUBSTRING_AFTER :\n                return \"substring-after\";\n            case Compiler.FUNCTION_SUBSTRING :\n                return \"substring\";\n            case Compiler.FUNCTION_STRING_LENGTH :\n                return \"string-length\";\n            case Compiler.FUNCTION_NORMALIZE_SPACE :\n                return \"normalize-space\";\n            case Compiler.FUNCTION_TRANSLATE :\n                return \"translate\";\n            case Compiler.FUNCTION_BOOLEAN :\n                return \"boolean\";\n            case Compiler.FUNCTION_NOT :\n                return \"not\";\n            case Compiler.FUNCTION_TRUE :\n                return \"true\";\n            case Compiler.FUNCTION_FALSE :\n                return \"false\";\n            case Compiler.FUNCTION_LANG :\n                return \"lang\";\n            case Compiler.FUNCTION_NUMBER :\n                return \"number\";\n            case Compiler.FUNCTION_SUM :\n                return \"sum\";\n            case Compiler.FUNCTION_FLOOR :\n                return \"floor\";\n            case Compiler.FUNCTION_CEILING :\n                return \"ceiling\";\n            case Compiler.FUNCTION_ROUND :\n                return \"round\";\n            case Compiler.FUNCTION_KEY :\n                return \"key\";\n            case Compiler.FUNCTION_FORMAT_NUMBER:\n                return \"format-number\";\n        }\n        return \"unknownFunction\" + functionCode + \"()\";\n    }\n\n    public Expression getArg1() {\n        return args[0];\n    }\n\n    public Expression getArg2() {\n        return args[1];\n    }\n\n    public Expression getArg3() {\n        return args[2];\n    }\n\n    public int getArgumentCount() {\n        if (args == null) {\n            return 0;\n        }\n        return args.length;\n    }\n\n    \n    public boolean computeContextDependent() {\n        if (super.computeContextDependent()) {\n            return true;\n        }\n\n        switch(functionCode) {\n            case Compiler.FUNCTION_LAST:\n            case Compiler.FUNCTION_POSITION:\n                return true;\n\n            case Compiler.FUNCTION_BOOLEAN:\n            case Compiler.FUNCTION_LOCAL_NAME:\n            case Compiler.FUNCTION_NAME:\n            case Compiler.FUNCTION_NAMESPACE_URI:\n            case Compiler.FUNCTION_STRING:\n            case Compiler.FUNCTION_LANG:\n            case Compiler.FUNCTION_NUMBER:\n                return args == null || args.length == 0;\n\n            case Compiler.FUNCTION_COUNT:\n            case Compiler.FUNCTION_ID:\n            case Compiler.FUNCTION_CONCAT:\n            case Compiler.FUNCTION_STARTS_WITH:\n            case Compiler.FUNCTION_CONTAINS:\n            case Compiler.FUNCTION_SUBSTRING_BEFORE:\n            case Compiler.FUNCTION_SUBSTRING_AFTER:\n            case Compiler.FUNCTION_SUBSTRING:\n            case Compiler.FUNCTION_STRING_LENGTH:\n            case Compiler.FUNCTION_NORMALIZE_SPACE:\n            case Compiler.FUNCTION_TRANSLATE:\n            case Compiler.FUNCTION_NOT:\n            case Compiler.FUNCTION_TRUE:\n            case Compiler.FUNCTION_FALSE:\n            case Compiler.FUNCTION_SUM:\n            case Compiler.FUNCTION_FLOOR:\n            case Compiler.FUNCTION_CEILING:\n            case Compiler.FUNCTION_ROUND:\n                return false;\n                \n            case Compiler.FUNCTION_FORMAT_NUMBER:\n                return args != null && args.length == 2;                             \n        }\n\n        return false;\n    }\n\n    public String toString() {\n        StringBuffer buffer = new StringBuffer();\n        buffer.append(getFunctionName());\n        buffer.append('(');\n        Expression args[] = getArguments();\n        if (args != null) {\n            for (int i = 0; i < args.length; i++) {\n                if (i > 0) {\n                    buffer.append(\", \");\n                }\n                buffer.append(args[i]);\n            }\n        }\n        buffer.append(')');\n        return buffer.toString();\n    }\n\n    public Object compute(EvalContext context) {\n        return computeValue(context);\n    }\n\n    \n    public Object computeValue(EvalContext context) {\n        switch (functionCode) {\n            case Compiler.FUNCTION_LAST :\n                return functionLast(context);\n            case Compiler.FUNCTION_POSITION :\n                return functionPosition(context);\n            case Compiler.FUNCTION_COUNT :\n                return functionCount(context);\n            case Compiler.FUNCTION_LANG :\n                return functionLang(context);\n            case Compiler.FUNCTION_ID :\n                return functionID(context);\n            case Compiler.FUNCTION_LOCAL_NAME :\n                return functionLocalName(context);\n            case Compiler.FUNCTION_NAMESPACE_URI :\n                return functionNamespaceURI(context);\n            case Compiler.FUNCTION_NAME :\n                return functionName(context);\n            case Compiler.FUNCTION_STRING :\n                return functionString(context);\n            case Compiler.FUNCTION_CONCAT :\n                return functionConcat(context);\n            case Compiler.FUNCTION_STARTS_WITH :\n                return functionStartsWith(context);\n            case Compiler.FUNCTION_CONTAINS :\n                return functionContains(context);\n            case Compiler.FUNCTION_SUBSTRING_BEFORE :\n                return functionSubstringBefore(context);\n            case Compiler.FUNCTION_SUBSTRING_AFTER :\n                return functionSubstringAfter(context);\n            case Compiler.FUNCTION_SUBSTRING :\n                return functionSubstring(context);\n            case Compiler.FUNCTION_STRING_LENGTH :\n                return functionStringLength(context);\n            case Compiler.FUNCTION_NORMALIZE_SPACE :\n                return functionNormalizeSpace(context);\n            case Compiler.FUNCTION_TRANSLATE :\n                return functionTranslate(context);\n            case Compiler.FUNCTION_BOOLEAN :\n                return functionBoolean(context);\n            case Compiler.FUNCTION_NOT :\n                return functionNot(context);\n            case Compiler.FUNCTION_TRUE :\n                return functionTrue(context);\n            case Compiler.FUNCTION_FALSE :\n                return functionFalse(context);\n            case Compiler.FUNCTION_NULL :\n                return functionNull(context);\n            case Compiler.FUNCTION_NUMBER :\n                return functionNumber(context);\n            case Compiler.FUNCTION_SUM :\n                return functionSum(context);\n            case Compiler.FUNCTION_FLOOR :\n                return functionFloor(context);\n            case Compiler.FUNCTION_CEILING :\n                return functionCeiling(context);\n            case Compiler.FUNCTION_ROUND :\n                return functionRound(context);\n            case Compiler.FUNCTION_KEY :\n                return functionKey(context);\n            case Compiler.FUNCTION_FORMAT_NUMBER :\n                return functionFormatNumber(context);\n        }\n        return null;\n    }\n\n    protected Object functionLast(EvalContext context) {\n        assertArgCount(0);\n        \n        \n        int old = context.getCurrentPosition();\n        context.reset();\n        int count = 0;\n        while (context.nextNode()) {\n            count++;\n        }\n\n        \n        if (old != 0) {\n            context.setPosition(old);\n        }\n        return new Double(count);\n    }\n\n    protected Object functionPosition(EvalContext context) {\n        assertArgCount(0);\n        return new Integer(context.getCurrentPosition());\n    }\n\n    protected Object functionCount(EvalContext context) {\n        assertArgCount(1);\n        Expression arg1 = getArg1();\n        int count = 0;\n        Object value = arg1.compute(context);\n        if (value instanceof NodePointer) {\n            value = ((NodePointer) value).getValue();\n        }\n        if (value instanceof EvalContext) {\n            EvalContext ctx = (EvalContext) value;\n            while (ctx.hasNext()) {\n                ctx.next();\n                count++;\n            }\n        }\n        else if (value instanceof Collection) {\n            count = ((Collection) value).size();\n        }\n        else if (value == null) {\n            count = 0;\n        }\n        else {\n            count = 1;\n        }\n        return new Double(count);\n    }\n\n    protected Object functionLang(EvalContext context) {\n        assertArgCount(1);\n        String lang = InfoSetUtil.stringValue(getArg1().computeValue(context));\n        NodePointer pointer = (NodePointer) context.getSingleNodePointer();\n        if (pointer == null) {\n            return Boolean.FALSE;\n        }\n        return pointer.isLanguage(lang) ? Boolean.TRUE : Boolean.FALSE;\n    }\n\n    protected Object functionID(EvalContext context) {\n        assertArgCount(1);\n        String id = InfoSetUtil.stringValue(getArg1().computeValue(context));\n        JXPathContext jxpathContext = context.getJXPathContext();\n        NodePointer pointer = (NodePointer) jxpathContext.getContextPointer();\n        return pointer.getPointerByID(jxpathContext, id);\n    }\n\n    protected Object functionKey(EvalContext context) {\n        assertArgCount(2);\n        String key = InfoSetUtil.stringValue(getArg1().computeValue(context));\n        Object value = getArg2().compute(context);\n        EvalContext ec = null;\n        if (value instanceof EvalContext) {\n            ec = (EvalContext) value;\n            if (ec.hasNext()) {\n                value = ((NodePointer) ec.next()).getValue();\n            } else { \n                return new BasicNodeSet();\n            }\n        }\n        JXPathContext jxpathContext = context.getJXPathContext();\n        NodeSet nodeSet = jxpathContext.getNodeSetByKey(key, value);\n        if (ec != null && ec.hasNext()) {\n            BasicNodeSet accum = new BasicNodeSet();\n            accum.add(nodeSet);\n            while (ec.hasNext()) {\n                value = ((NodePointer) ec.next()).getValue();\n                accum.add(jxpathContext.getNodeSetByKey(key, value));\n            }\n            nodeSet = accum;\n        }\n        return new NodeSetContext(context, nodeSet);\n    }\n\n    protected Object functionNamespaceURI(EvalContext context) {\n        if (getArgumentCount() == 0) {\n            NodePointer ptr = context.getCurrentNodePointer();\n            String str = ptr.getNamespaceURI();\n            return str == null ? \"\" : str;\n        }\n        assertArgCount(1);\n        Object set = getArg1().compute(context);\n        if (set instanceof EvalContext) {\n            EvalContext ctx = (EvalContext) set;\n            if (ctx.hasNext()) {\n                NodePointer ptr = (NodePointer) ctx.next();\n                String str = ptr.getNamespaceURI();\n                return str == null ? \"\" : str;\n            }\n        }\n        return \"\";\n    }\n\n    protected Object functionLocalName(EvalContext context) {\n        if (getArgumentCount() == 0) {\n            NodePointer ptr = context.getCurrentNodePointer();\n            return ptr.getName().getName();\n        }\n        assertArgCount(1);\n        Object set = getArg1().compute(context);\n        if (set instanceof EvalContext) {\n            EvalContext ctx = (EvalContext) set;\n            if (ctx.hasNext()) {\n                NodePointer ptr = (NodePointer) ctx.next();\n                return ptr.getName().getName();\n            }\n        }\n        return \"\";\n    }\n\n    protected Object functionName(EvalContext context) {\n        if (getArgumentCount() == 0) {\n            NodePointer ptr = context.getCurrentNodePointer();\n            return ptr.getName().toString();\n        }\n        assertArgCount(1);\n        Object set = getArg1().compute(context);\n        if (set instanceof EvalContext) {\n            EvalContext ctx = (EvalContext) set;\n            if (ctx.hasNext()) {\n                NodePointer ptr = (NodePointer) ctx.next();\n                return ptr.getName().toString();\n            }\n        }\n        return \"\";\n    }\n\n    protected Object functionString(EvalContext context) {\n        if (getArgumentCount() == 0) {\n            return InfoSetUtil.stringValue(context.getCurrentNodePointer());\n        }\n        assertArgCount(1);\n        return InfoSetUtil.stringValue(getArg1().computeValue(context));\n    }\n\n    protected Object functionConcat(EvalContext context) {\n        if (getArgumentCount() < 2) {\n            assertArgCount(2);\n        }\n        StringBuffer buffer = new StringBuffer();\n        Expression args[] = getArguments();\n        for (int i = 0; i < args.length; i++) {\n            buffer.append(InfoSetUtil.stringValue(args[i].compute(context)));\n        }\n        return buffer.toString();\n    }\n\n    protected Object functionStartsWith(EvalContext context) {\n        assertArgCount(2);\n        String s1 = InfoSetUtil.stringValue(getArg1().computeValue(context));\n        String s2 = InfoSetUtil.stringValue(getArg2().computeValue(context));\n        return s1.startsWith(s2) ? Boolean.TRUE : Boolean.FALSE;\n    }\n\n    protected Object functionContains(EvalContext context) {\n        assertArgCount(2);\n        String s1 = InfoSetUtil.stringValue(getArg1().computeValue(context));\n        String s2 = InfoSetUtil.stringValue(getArg2().computeValue(context));\n        return s1.indexOf(s2) != -1 ? Boolean.TRUE : Boolean.FALSE;\n    }\n\n    protected Object functionSubstringBefore(EvalContext context) {\n        assertArgCount(2);\n        String s1 = InfoSetUtil.stringValue(getArg1().computeValue(context));\n        String s2 = InfoSetUtil.stringValue(getArg2().computeValue(context));\n        int index = s1.indexOf(s2);\n        if (index == -1) {\n            return \"\";\n        }\n        return s1.substring(0, index);\n    }\n\n    protected Object functionSubstringAfter(EvalContext context) {\n        assertArgCount(2);\n        String s1 = InfoSetUtil.stringValue(getArg1().computeValue(context));\n        String s2 = InfoSetUtil.stringValue(getArg2().computeValue(context));\n        int index = s1.indexOf(s2);\n        if (index == -1) {\n            return \"\";\n        }\n        return s1.substring(index + s2.length());\n    }\n\n    protected Object functionSubstring(EvalContext context) {\n        int ac = getArgumentCount();\n        if (ac != 2 && ac != 3) {\n            assertArgCount(2);\n        }\n\n        String s1 = InfoSetUtil.stringValue(getArg1().computeValue(context));\n        double from = InfoSetUtil.doubleValue(getArg2().computeValue(context));\n        if (Double.isNaN(from)) {\n            return \"\";\n        }\n\n        from = Math.round(from);\n        if (from > s1.length() + 1) {\n            return \"\";\n        }\n        if (ac == 2) {\n            if (from < 1) {\n                from = 1;\n            }\n            return s1.substring((int) from - 1);\n        }\n        double length =\n            InfoSetUtil.doubleValue(getArg3().computeValue(context));\n        length = Math.round(length);\n        if (length < 0) {\n            return \"\";\n        }\n\n        double to = from + length;\n        if (to < 1) {\n            return \"\";\n        }\n\n        if (to > s1.length() + 1) {\n            if (from < 1) {\n                from = 1;\n            }\n            return s1.substring((int) from - 1);\n        }\n\n        if (from < 1) {\n            from = 1;\n        }\n        return s1.substring((int) from - 1, (int) (to - 1));\n    }\n\n    protected Object functionStringLength(EvalContext context) {\n        String s;\n        if (getArgumentCount() == 0) {\n            s = InfoSetUtil.stringValue(context.getCurrentNodePointer());\n        }\n        else {\n            assertArgCount(1);\n            s = InfoSetUtil.stringValue(getArg1().computeValue(context));\n        }\n        return new Double(s.length());\n    }\n\n    protected Object functionNormalizeSpace(EvalContext context) {\n        assertArgCount(1);\n        String s = InfoSetUtil.stringValue(getArg1().computeValue(context));\n        char chars[] = s.toCharArray();\n        int out = 0;\n        int phase = 0;\n        for (int in = 0; in < chars.length; in++) {\n            switch(chars[in]) {\n                case 0x20:\n                case 0x9:\n                case 0xD:\n                case 0xA:\n                    if (phase == 0) {      \n                        ;\n                    }\n                    else if (phase == 1) { \n                        phase = 2;\n                        chars[out++] = ' ';\n                    }\n                    break;\n                default:\n                    chars[out++] = chars[in];\n                    phase = 1;\n            }\n        }\n        if (phase == 2) { \n            out--;\n        }\n        return new String(chars, 0, out);\n    }\n\n    protected Object functionTranslate(EvalContext context) {\n        assertArgCount(3);\n        String s1 = InfoSetUtil.stringValue(getArg1().computeValue(context));\n        String s2 = InfoSetUtil.stringValue(getArg2().computeValue(context));\n        String s3 = InfoSetUtil.stringValue(getArg3().computeValue(context));\n        char chars[] = s1.toCharArray();\n        int out = 0;\n        for (int in = 0; in < chars.length; in++) {\n            char c = chars[in];\n            int inx = s2.indexOf(c);\n            if (inx != -1) {\n                if (inx < s3.length()) {\n                    chars[out++] = s3.charAt(inx);\n                }\n            }\n            else {\n                chars[out++] = c;\n            }\n        }\n        return new String(chars, 0, out);\n    }\n\n    protected Object functionBoolean(EvalContext context) {\n        assertArgCount(1);\n        return InfoSetUtil.booleanValue(getArg1().computeValue(context))\n            ? Boolean.TRUE\n            : Boolean.FALSE;\n    }\n\n    protected Object functionNot(EvalContext context) {\n        assertArgCount(1);\n        return InfoSetUtil.booleanValue(getArg1().computeValue(context))\n            ? Boolean.FALSE\n            : Boolean.TRUE;\n    }\n\n    protected Object functionTrue(EvalContext context) {\n        assertArgCount(0);\n        return Boolean.TRUE;\n    }\n\n    protected Object functionFalse(EvalContext context) {\n        assertArgCount(0);\n        return Boolean.FALSE;\n    }\n\n    protected Object functionNull(EvalContext context) {\n        assertArgCount(0);\n        return null;\n    }\n\n    protected Object functionNumber(EvalContext context) {\n        if (getArgumentCount() == 0) {\n            return InfoSetUtil.number(context.getCurrentNodePointer());\n        }\n        assertArgCount(1);\n        return InfoSetUtil.number(getArg1().computeValue(context));\n    }\n\n    protected Object functionSum(EvalContext context) {\n        assertArgCount(1);\n        Object v = getArg1().compute(context);\n        if (v == null) {\n            return ZERO;\n        }\n        if (v instanceof EvalContext) {\n            double sum = 0.0;\n            EvalContext ctx = (EvalContext) v;\n            while (ctx.hasNext()) {\n                NodePointer ptr = (NodePointer) ctx.next();\n                sum += InfoSetUtil.doubleValue(ptr);\n            }\n            return new Double(sum);\n        }\n        throw new JXPathException(\n            \"Invalid argument type for 'sum': \" + v.getClass().getName());\n    }\n\n    protected Object functionFloor(EvalContext context) {\n        assertArgCount(1);\n        double v = InfoSetUtil.doubleValue(getArg1().computeValue(context));\n        if (Double.isNaN(v) || Double.isInfinite(v)) {\n        \treturn new Double(v);\n        }\n        return new Double(Math.floor(v));\n    }\n\n    protected Object functionCeiling(EvalContext context) {\n        assertArgCount(1);\n        double v = InfoSetUtil.doubleValue(getArg1().computeValue(context));\n        if (Double.isNaN(v) || Double.isInfinite(v)) {\n        \treturn new Double(v);\n        }\n        return new Double(Math.ceil(v));\n    }\n\n    protected Object functionRound(EvalContext context) {\n        assertArgCount(1);\n        double v = InfoSetUtil.doubleValue(getArg1().computeValue(context));\n        if (Double.isNaN(v) || Double.isInfinite(v)) {\n        \treturn new Double(v);\n        }\n        return new Double(Math.round(v));\n    }\n\n    private Object functionFormatNumber(EvalContext context) {\n        int ac = getArgumentCount();\n        if (ac != 2 && ac != 3) {\n            assertArgCount(2);\n        }\n\n        double number =\n            InfoSetUtil.doubleValue(getArg1().computeValue(context));\n        String pattern =\n            InfoSetUtil.stringValue(getArg2().computeValue(context));\n\n        DecimalFormatSymbols symbols = null;\n        if (ac == 3) {\n            String symbolsName =\n                InfoSetUtil.stringValue(getArg3().computeValue(context));\n            symbols =\n                context.getJXPathContext().getDecimalFormatSymbols(symbolsName);\n        }\n        else {\n            NodePointer pointer = context.getCurrentNodePointer();\n            Locale locale;\n            if (pointer != null) {\n                locale = pointer.getLocale();\n            }\n            else {\n                locale = context.getJXPathContext().getLocale();\n            }\n            symbols = new DecimalFormatSymbols(locale);\n        }\n        \n        DecimalFormat format = (DecimalFormat) NumberFormat.getInstance();\n        format.setDecimalFormatSymbols(symbols);\n        format.applyLocalizedPattern(pattern);\n        return format.format(number);\n    }\n\n    private void assertArgCount(int count) {\n        assertArgRange(count, count);\n    }\n\n    private void assertArgRange(int min, int max) {\n        int ct = getArgumentCount();\n        if (ct < min || ct > max) {\n            throw new JXPathInvalidSyntaxException(\n                    \"Incorrect number of arguments: \" + this);\n        }\n    }\n}",
      "buggy_signatures": [
        "public int getFunctionCode()",
        "protected String getFunctionName()",
        "public Expression getArg1()",
        "public Expression getArg2()",
        "public Expression getArg3()",
        "public int getArgumentCount()",
        "public boolean computeContextDependent()",
        "public String toString()",
        "public Object compute(EvalContext context)",
        "public Object computeValue(EvalContext context)",
        "protected Object functionLast(EvalContext context)",
        "protected Object functionPosition(EvalContext context)",
        "protected Object functionCount(EvalContext context)",
        "protected Object functionLang(EvalContext context)",
        "protected Object functionID(EvalContext context)",
        "protected Object functionKey(EvalContext context)",
        "protected Object functionNamespaceURI(EvalContext context)",
        "protected Object functionLocalName(EvalContext context)",
        "protected Object functionName(EvalContext context)",
        "protected Object functionString(EvalContext context)",
        "protected Object functionConcat(EvalContext context)",
        "protected Object functionStartsWith(EvalContext context)",
        "protected Object functionContains(EvalContext context)",
        "protected Object functionSubstringBefore(EvalContext context)",
        "protected Object functionSubstringAfter(EvalContext context)",
        "protected Object functionSubstring(EvalContext context)",
        "protected Object functionStringLength(EvalContext context)",
        "protected Object functionNormalizeSpace(EvalContext context)",
        "protected Object functionTranslate(EvalContext context)",
        "protected Object functionBoolean(EvalContext context)",
        "protected Object functionNot(EvalContext context)",
        "protected Object functionTrue(EvalContext context)",
        "protected Object functionFalse(EvalContext context)",
        "protected Object functionNull(EvalContext context)",
        "protected Object functionNumber(EvalContext context)",
        "protected Object functionSum(EvalContext context)",
        "protected Object functionFloor(EvalContext context)",
        "protected Object functionCeiling(EvalContext context)",
        "protected Object functionRound(EvalContext context)",
        "private Object functionFormatNumber(EvalContext context)",
        "private void assertArgCount(int count)",
        "private void assertArgRange(int min, int max)"
      ],
      "fixed_signatures": [
        "public int getFunctionCode()",
        "protected String getFunctionName()",
        "public Expression getArg1()",
        "public Expression getArg2()",
        "public Expression getArg3()",
        "public int getArgumentCount()",
        "public boolean computeContextDependent()",
        "public String toString()",
        "public Object compute(EvalContext context)",
        "public Object computeValue(EvalContext context)",
        "protected Object functionLast(EvalContext context)",
        "protected Object functionPosition(EvalContext context)",
        "protected Object functionCount(EvalContext context)",
        "protected Object functionLang(EvalContext context)",
        "protected Object functionID(EvalContext context)",
        "protected Object functionKey(EvalContext context)",
        "protected Object functionNamespaceURI(EvalContext context)",
        "protected Object functionLocalName(EvalContext context)",
        "protected Object functionName(EvalContext context)",
        "protected Object functionString(EvalContext context)",
        "protected Object functionConcat(EvalContext context)",
        "protected Object functionStartsWith(EvalContext context)",
        "protected Object functionContains(EvalContext context)",
        "protected Object functionSubstringBefore(EvalContext context)",
        "protected Object functionSubstringAfter(EvalContext context)",
        "protected Object functionSubstring(EvalContext context)",
        "protected Object functionStringLength(EvalContext context)",
        "protected Object functionNormalizeSpace(EvalContext context)",
        "protected Object functionTranslate(EvalContext context)",
        "protected Object functionBoolean(EvalContext context)",
        "protected Object functionNot(EvalContext context)",
        "protected Object functionTrue(EvalContext context)",
        "protected Object functionFalse(EvalContext context)",
        "protected Object functionNull(EvalContext context)",
        "protected Object functionNumber(EvalContext context)",
        "protected Object functionSum(EvalContext context)",
        "protected Object functionFloor(EvalContext context)",
        "protected Object functionCeiling(EvalContext context)",
        "protected Object functionRound(EvalContext context)",
        "private Object functionFormatNumber(EvalContext context)",
        "private void assertArgCount(int count)",
        "private void assertArgRange(int min, int max)"
      ],
      "methods": [
        {
          "buggy_method": "  private Object functionFormatNumber(EvalContext context) {\n  int ac = getArgumentCount();\n  if (ac != 2 && ac != 3) {\n  assertArgCount(2);\n  }\n\n  double number =\n  InfoSetUtil.doubleValue(getArg1().computeValue(context));\n  String pattern =\n  InfoSetUtil.stringValue(getArg2().computeValue(context));\n\n  DecimalFormatSymbols symbols = null;\n  if (ac == 3) {\n  String symbolsName =\n  InfoSetUtil.stringValue(getArg3().computeValue(context));\n  symbols =\n  context.getJXPathContext().getDecimalFormatSymbols(symbolsName);\n  }\n  else {\n  NodePointer pointer = context.getCurrentNodePointer();\n  Locale locale;\n  if (pointer != null) {\n  locale = pointer.getLocale();\n  }\n  else {\n  locale = context.getJXPathContext().getLocale();\n  }\n  symbols = new DecimalFormatSymbols(locale);\n  }\n  \n  DecimalFormat format = (DecimalFormat) NumberFormat.getInstance();\n  format.setDecimalFormatSymbols(symbols);\n  format.applyLocalizedPattern(pattern);\n  return format.format(number);\n  }",
          "fixed_method": "  protected Object functionRound(EvalContext context) {\n  assertArgCount(1);\n  double v = InfoSetUtil.doubleValue(getArg1().computeValue(context));\n  if (Double.isNaN(v) || Double.isInfinite(v)) {\n  \treturn new Double(v);\n  }\n  return new Double(Math.round(v));\n  }",
          "diff": [
            "@@ -653,18 +653,27 @@",
            "     protected Object functionFloor(EvalContext context) {\n",
            "         assertArgCount(1);\n",
            "         double v = InfoSetUtil.doubleValue(getArg1().computeValue(context));\n",
            "+        if (Double.isNaN(v) || Double.isInfinite(v)) {\n",
            "+        \treturn new Double(v);\n",
            "+        }\n",
            "         return new Double(Math.floor(v));\n",
            "     }\n",
            " \n",
            "     protected Object functionCeiling(EvalContext context) {\n",
            "         assertArgCount(1);\n",
            "         double v = InfoSetUtil.doubleValue(getArg1().computeValue(context));\n",
            "+        if (Double.isNaN(v) || Double.isInfinite(v)) {\n",
            "+        \treturn new Double(v);\n",
            "+        }\n",
            "         return new Double(Math.ceil(v));\n",
            "     }\n",
            " \n",
            "     protected Object functionRound(EvalContext context) {\n",
            "         assertArgCount(1);\n",
            "         double v = InfoSetUtil.doubleValue(getArg1().computeValue(context));\n",
            "+        if (Double.isNaN(v) || Double.isInfinite(v)) {\n",
            "+        \treturn new Double(v);\n",
            "+        }\n",
            "         return new Double(Math.round(v));\n",
            "     }\n",
            " \n"
          ],
          "changed_lines": 9
        }
      ]
    }
  ]
}
