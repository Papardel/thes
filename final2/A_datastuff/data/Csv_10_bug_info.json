{
  "bug_id": "10",
  "failed_tests": {
    "org.apache.commons.csv.CSVPrinterTest": [
      {
        "methodName": "testHeader",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<[C1,C2,C3",
        "fail_line": "        assertEquals(\"C1,C2,C3\\r\\na,b,c\\r\\nx,y,z\\r\\n\", sw.toString());",
        "test_source": "  public void testHeader() throws IOException {\n  final StringWriter sw = new StringWriter();\n  final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuoteChar(null)\n  .withHeader(\"C1\", \"C2\", \"C3\"));\n  printer.printRecord(\"a\", \"b\", \"c\");\n  printer.printRecord(\"x\", \"y\", \"z\");\n  assertEquals(\"C1,C2,C3\\r\\na,b,c\\r\\nx,y,z\\r\\n\", sw.toString());\n  printer.close();\n  }",
        "stack": [
          "CSVPrinterTest.testHeader line 495"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/csv/CSVPrinter.java",
      "buggy_full_code": "\n\npackage org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Constants.COMMENT; import static org.apache.commons.csv.Constants.CR; import static org.apache.commons.csv.Constants.LF; import static org.apache.commons.csv.Constants.SP; import java.io.Closeable; import java.io.Flushable; import java.io.IOException; import java.sql.ResultSet; import java.sql.SQLException; public final class CSVPrinter implements Flushable, Closeable { private final Appendable out; private final CSVFormat format; private boolean newRecord = true; public CSVPrinter(final Appendable out, final CSVFormat format) throws IOException {\n        Assertions.notNull(out, \"out\");\n        Assertions.notNull(format, \"format\");\n\n        this.out = out;\n        this.format = format;\n        this.format.validate();\n        \n        \n    }\n\n    \n    \n    \n\n    public void close() throws IOException {\n        if (out instanceof Closeable) {\n            ((Closeable) out).close();\n        }\n    }\n\n    \n    public void flush() throws IOException {\n        if (out instanceof Flushable) {\n            ((Flushable) out).flush();\n        }\n    }\n\n    \n    public void print(final Object value) throws IOException {\n        \n        String strValue;\n        if (value == null) {\n            final String nullString = format.getNullString();\n            strValue = nullString == null ? Constants.EMPTY : nullString;\n        } else {\n            strValue = value.toString();\n        }\n        this.print(value, strValue, 0, strValue.length());\n    }\n\n    private void print(final Object object, final CharSequence value, final int offset, final int len) throws IOException {\n        if (!newRecord) {\n            out.append(format.getDelimiter());\n        }\n        if (format.isQuoting()) {\n            \n            printAndQuote(object, value, offset, len);\n        } else if (format.isEscaping()) {\n            printAndEscape(value, offset, len);\n        } else {\n            out.append(value, offset, offset + len);\n        }\n        newRecord = false;\n    }\n\n    \n    private void printAndEscape(final CharSequence value, final int offset, final int len) throws IOException {\n        int start = offset;\n        int pos = offset;\n        final int end = offset + len;\n\n        final char delim = format.getDelimiter();\n        final char escape = format.getEscape().charValue();\n\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == CR || c == LF || c == delim || c == escape) {\n                \n                if (pos > start) {\n                    out.append(value, start, pos);\n                }\n                if (c == LF) {\n                    c = 'n';\n                } else if (c == CR) {\n                    c = 'r';\n                }\n\n                out.append(escape);\n                out.append(c);\n\n                start = pos + 1; \n            }\n\n            pos++;\n        }\n\n        \n        if (pos > start) {\n            out.append(value, start, pos);\n        }\n    }\n\n    \n    \n    private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len) throws IOException {\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        final int end = offset + len;\n\n        final char delimChar = format.getDelimiter();\n        final char quoteChar = format.getQuoteChar().charValue();\n\n        Quote quotePolicy = format.getQuotePolicy();\n        if (quotePolicy == null) {\n            quotePolicy = Quote.MINIMAL;\n        }\n        switch (quotePolicy) {\n        case ALL:\n            quote = true;\n            break;\n        case NON_NUMERIC:\n            quote = !(object instanceof Number);\n            break;\n        case NONE:\n            \n            printAndEscape(value, offset, len);\n            return;\n        case MINIMAL:\n            if (len <= 0) {\n                \n                \n                \n                \n                if (newRecord) {\n                    quote = true;\n                }\n            } else {\n                char c = value.charAt(pos);\n\n                \n                if (newRecord && (c < '0' || (c > '9' && c < 'A') || (c > 'Z' && c < 'a') || (c > 'z'))) {\n                    quote = true;\n                    \n                } else if (c <= COMMENT) {\n                    \n                    \n                    \n                    quote = true;\n                } else {\n                    while (pos < end) {\n                        c = value.charAt(pos);\n                        if (c == LF || c == CR || c == quoteChar || c == delimChar) {\n                            quote = true;\n                            break;\n                        }\n                        pos++;\n                    }\n\n                    if (!quote) {\n                        pos = end - 1;\n                        c = value.charAt(pos);\n                        \n                        \n                        \n                        if (c <= SP) {\n                            quote = true;\n                        }\n                    }\n                }\n            }\n\n            if (!quote) {\n                \n                out.append(value, start, end);\n                return;\n            }\n            break;\n        default:\n            throw new IllegalStateException(\"Unexpected Quote value: \" + quotePolicy);\n        }\n\n        if (!quote) {\n            \n            out.append(value, start, end);\n            return;\n        }\n\n        \n        out.append(quoteChar);\n\n        \n        \n        while (pos < end) {\n            final char c = value.charAt(pos);\n            if (c == quoteChar) {\n                \n\n                \n                out.append(value, start, pos + 1);\n                \n                \n                start = pos;\n            }\n            pos++;\n        }\n\n        \n        out.append(value, start, pos);\n        out.append(quoteChar);\n    }\n\n    \n    public void printComment(final String comment) throws IOException {\n        if (!format.isCommentingEnabled()) {\n            return;\n        }\n        if (!newRecord) {\n            println();\n        }\n        out.append(format.getCommentStart().charValue());\n        out.append(SP);\n        for (int i = 0; i < comment.length(); i++) {\n            final char c = comment.charAt(i);\n            switch (c) {\n            case CR:\n                if (i + 1 < comment.length() && comment.charAt(i + 1) == LF) {\n                    i++;\n                }\n                \n            case LF:\n                println();\n                out.append(format.getCommentStart().charValue());\n                out.append(SP);\n                break;\n            default:\n                out.append(c);\n                break;\n            }\n        }\n        println();\n    }\n\n    \n    public void println() throws IOException {\n        final String recordSeparator = format.getRecordSeparator();\n        if (recordSeparator != null) {\n            out.append(recordSeparator);\n        }\n        newRecord = true;\n    }\n\n    \n    public void printRecord(final Iterable<?> values) throws IOException {\n        for (final Object value : values) {\n            print(value);\n        }\n        println();\n    }\n\n    \n    public void printRecord(final Object... values) throws IOException {\n        for (final Object value : values) {\n            print(value);\n        }\n        println();\n    }\n\n    \n    public void printRecords(final Iterable<?> values) throws IOException {\n        for (final Object value : values) {\n            if (value instanceof Object[]) {\n                this.printRecord((Object[]) value);\n            } else if (value instanceof Iterable) {\n                this.printRecord((Iterable<?>) value);\n            } else {\n                this.printRecord(value);\n            }\n        }\n    }\n\n    \n    public void printRecords(final Object[] values) throws IOException {\n        for (final Object value : values) {\n            if (value instanceof Object[]) {\n                this.printRecord((Object[]) value);\n            } else if (value instanceof Iterable) {\n                this.printRecord((Iterable<?>) value);\n            } else {\n                this.printRecord(value);\n            }\n        }\n    }\n\n    \n    public void printRecords(final ResultSet resultSet) throws SQLException, IOException {\n        final int columnCount = resultSet.getMetaData().getColumnCount();\n        while (resultSet.next()) {\n            for (int i = 1; i <= columnCount; i++) {\n                print(resultSet.getString(i));\n            }\n            println();\n        }\n    }\n\n    \n    public Appendable getOut() {\n        return this.out;\n    }\n}\n",
      "fixed_full_code": "\n\npackage org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Constants.COMMENT; import static org.apache.commons.csv.Constants.CR; import static org.apache.commons.csv.Constants.LF; import static org.apache.commons.csv.Constants.SP; import java.io.Closeable; import java.io.Flushable; import java.io.IOException; import java.sql.ResultSet; import java.sql.SQLException; public final class CSVPrinter implements Flushable, Closeable { private final Appendable out; private final CSVFormat format; private boolean newRecord = true; public CSVPrinter(final Appendable out, final CSVFormat format) throws IOException {\n        Assertions.notNull(out, \"out\");\n        Assertions.notNull(format, \"format\");\n\n        this.out = out;\n        this.format = format;\n        this.format.validate();\n        \n        \n        if (format.getHeader() != null) {\n            this.printRecord((Object[]) format.getHeader());\n        }\n    }\n\n    \n    \n    \n\n    public void close() throws IOException {\n        if (out instanceof Closeable) {\n            ((Closeable) out).close();\n        }\n    }\n\n    \n    public void flush() throws IOException {\n        if (out instanceof Flushable) {\n            ((Flushable) out).flush();\n        }\n    }\n\n    \n    public void print(final Object value) throws IOException {\n        \n        String strValue;\n        if (value == null) {\n            final String nullString = format.getNullString();\n            strValue = nullString == null ? Constants.EMPTY : nullString;\n        } else {\n            strValue = value.toString();\n        }\n        this.print(value, strValue, 0, strValue.length());\n    }\n\n    private void print(final Object object, final CharSequence value, final int offset, final int len) throws IOException {\n        if (!newRecord) {\n            out.append(format.getDelimiter());\n        }\n        if (format.isQuoting()) {\n            \n            printAndQuote(object, value, offset, len);\n        } else if (format.isEscaping()) {\n            printAndEscape(value, offset, len);\n        } else {\n            out.append(value, offset, offset + len);\n        }\n        newRecord = false;\n    }\n\n    \n    private void printAndEscape(final CharSequence value, final int offset, final int len) throws IOException {\n        int start = offset;\n        int pos = offset;\n        final int end = offset + len;\n\n        final char delim = format.getDelimiter();\n        final char escape = format.getEscape().charValue();\n\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == CR || c == LF || c == delim || c == escape) {\n                \n                if (pos > start) {\n                    out.append(value, start, pos);\n                }\n                if (c == LF) {\n                    c = 'n';\n                } else if (c == CR) {\n                    c = 'r';\n                }\n\n                out.append(escape);\n                out.append(c);\n\n                start = pos + 1; \n            }\n\n            pos++;\n        }\n\n        \n        if (pos > start) {\n            out.append(value, start, pos);\n        }\n    }\n\n    \n    \n    private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len) throws IOException {\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        final int end = offset + len;\n\n        final char delimChar = format.getDelimiter();\n        final char quoteChar = format.getQuoteChar().charValue();\n\n        Quote quotePolicy = format.getQuotePolicy();\n        if (quotePolicy == null) {\n            quotePolicy = Quote.MINIMAL;\n        }\n        switch (quotePolicy) {\n        case ALL:\n            quote = true;\n            break;\n        case NON_NUMERIC:\n            quote = !(object instanceof Number);\n            break;\n        case NONE:\n            \n            printAndEscape(value, offset, len);\n            return;\n        case MINIMAL:\n            if (len <= 0) {\n                \n                \n                \n                \n                if (newRecord) {\n                    quote = true;\n                }\n            } else {\n                char c = value.charAt(pos);\n\n                \n                if (newRecord && (c < '0' || (c > '9' && c < 'A') || (c > 'Z' && c < 'a') || (c > 'z'))) {\n                    quote = true;\n                    \n                } else if (c <= COMMENT) {\n                    \n                    \n                    \n                    quote = true;\n                } else {\n                    while (pos < end) {\n                        c = value.charAt(pos);\n                        if (c == LF || c == CR || c == quoteChar || c == delimChar) {\n                            quote = true;\n                            break;\n                        }\n                        pos++;\n                    }\n\n                    if (!quote) {\n                        pos = end - 1;\n                        c = value.charAt(pos);\n                        \n                        \n                        \n                        if (c <= SP) {\n                            quote = true;\n                        }\n                    }\n                }\n            }\n\n            if (!quote) {\n                \n                out.append(value, start, end);\n                return;\n            }\n            break;\n        default:\n            throw new IllegalStateException(\"Unexpected Quote value: \" + quotePolicy);\n        }\n\n        if (!quote) {\n            \n            out.append(value, start, end);\n            return;\n        }\n\n        \n        out.append(quoteChar);\n\n        \n        \n        while (pos < end) {\n            final char c = value.charAt(pos);\n            if (c == quoteChar) {\n                \n\n                \n                out.append(value, start, pos + 1);\n                \n                \n                start = pos;\n            }\n            pos++;\n        }\n\n        \n        out.append(value, start, pos);\n        out.append(quoteChar);\n    }\n\n    \n    public void printComment(final String comment) throws IOException {\n        if (!format.isCommentingEnabled()) {\n            return;\n        }\n        if (!newRecord) {\n            println();\n        }\n        out.append(format.getCommentStart().charValue());\n        out.append(SP);\n        for (int i = 0; i < comment.length(); i++) {\n            final char c = comment.charAt(i);\n            switch (c) {\n            case CR:\n                if (i + 1 < comment.length() && comment.charAt(i + 1) == LF) {\n                    i++;\n                }\n                \n            case LF:\n                println();\n                out.append(format.getCommentStart().charValue());\n                out.append(SP);\n                break;\n            default:\n                out.append(c);\n                break;\n            }\n        }\n        println();\n    }\n\n    \n    public void println() throws IOException {\n        final String recordSeparator = format.getRecordSeparator();\n        if (recordSeparator != null) {\n            out.append(recordSeparator);\n        }\n        newRecord = true;\n    }\n\n    \n    public void printRecord(final Iterable<?> values) throws IOException {\n        for (final Object value : values) {\n            print(value);\n        }\n        println();\n    }\n\n    \n    public void printRecord(final Object... values) throws IOException {\n        for (final Object value : values) {\n            print(value);\n        }\n        println();\n    }\n\n    \n    public void printRecords(final Iterable<?> values) throws IOException {\n        for (final Object value : values) {\n            if (value instanceof Object[]) {\n                this.printRecord((Object[]) value);\n            } else if (value instanceof Iterable) {\n                this.printRecord((Iterable<?>) value);\n            } else {\n                this.printRecord(value);\n            }\n        }\n    }\n\n    \n    public void printRecords(final Object[] values) throws IOException {\n        for (final Object value : values) {\n            if (value instanceof Object[]) {\n                this.printRecord((Object[]) value);\n            } else if (value instanceof Iterable) {\n                this.printRecord((Iterable<?>) value);\n            } else {\n                this.printRecord(value);\n            }\n        }\n    }\n\n    \n    public void printRecords(final ResultSet resultSet) throws SQLException, IOException {\n        final int columnCount = resultSet.getMetaData().getColumnCount();\n        while (resultSet.next()) {\n            for (int i = 1; i <= columnCount; i++) {\n                print(resultSet.getString(i));\n            }\n            println();\n        }\n    }\n\n    \n    public Appendable getOut() {\n        return this.out;\n    }\n}\n",
      "buggy_signatures": [
        "public void close() throws IOException",
        "public void flush() throws IOException",
        "public void print(final Object value) throws IOException",
        "private void print(final Object object, final CharSequence value, final int offset, final int len) throws IOException",
        "private void printAndEscape(final CharSequence value, final int offset, final int len) throws IOException",
        "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len) throws IOException",
        "public void printComment(final String comment) throws IOException",
        "public void println() throws IOException",
        "public void printRecord(final Iterable<?> values) throws IOException",
        "public void printRecord(final Object... values) throws IOException",
        "public void printRecords(final Iterable<?> values) throws IOException",
        "public void printRecords(final Object[] values) throws IOException",
        "public void printRecords(final ResultSet resultSet) throws SQLException, IOException",
        "public Appendable getOut()"
      ],
      "fixed_signatures": [
        "public void close() throws IOException",
        "public void flush() throws IOException",
        "public void print(final Object value) throws IOException",
        "private void print(final Object object, final CharSequence value, final int offset, final int len) throws IOException",
        "private void printAndEscape(final CharSequence value, final int offset, final int len) throws IOException",
        "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len) throws IOException",
        "public void printComment(final String comment) throws IOException",
        "public void println() throws IOException",
        "public void printRecord(final Iterable<?> values) throws IOException",
        "public void printRecord(final Object... values) throws IOException",
        "public void printRecords(final Iterable<?> values) throws IOException",
        "public void printRecords(final Object[] values) throws IOException",
        "public void printRecords(final ResultSet resultSet) throws SQLException, IOException",
        "public Appendable getOut()"
      ],
      "methods": [
        {
          "buggy_method": "  public CSVPrinter(final Appendable out, final CSVFormat format) throws IOException {\n  Assertions.notNull(out, \"out\");\n  Assertions.notNull(format, \"format\");\n\n  this.out = out;\n  this.format = format;\n  this.format.validate();\n  \n  \n  }",
          "fixed_method": "  public CSVPrinter(final Appendable out, final CSVFormat format) throws IOException {\n  Assertions.notNull(out, \"out\");\n  Assertions.notNull(format, \"format\");\n\n  this.out = out;\n  this.format = format;\n  this.format.validate();\n  \n  \n  if (format.getHeader() != null) {\n  this.printRecord((Object[]) format.getHeader());\n  }\n  }",
          "diff": [
            "@@ -67,6 +67,9 @@",
            "         this.format.validate();\n",
            "         // TODO: Is it a good idea to do this here instead of on the first call to a print method?\n",
            "         // It seems a pain to have to track whether the header has already been printed or not.\n",
            "+        if (format.getHeader() != null) {\n",
            "+            this.printRecord((Object[]) format.getHeader());\n",
            "+        }\n",
            "     }\n",
            " \n",
            "     // ======================================================\n"
          ],
          "changed_lines": 3
        }
      ]
    }
  ]
}
