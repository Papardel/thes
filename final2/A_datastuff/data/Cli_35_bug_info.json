{
  "bug_id": "35",
  "failed_tests": {
    "org.apache.commons.cli.bug.BugCLI252Test": [
      {
        "methodName": "testExactOptionNameMatch",
        "error": "org.apache.commons.cli.AmbiguousOptionException",
        "message": "Ambiguous option: '--prefix'  (could be: 'prefix', 'prefixplusplus')",
        "fail_line": "        new DefaultParser().parse(getOptions(), new String[]{\"--prefix\"});",
        "test_source": "  public void testExactOptionNameMatch() throws ParseException {\n  new DefaultParser().parse(getOptions(), new String[]{\"--prefix\"});\n  }",
        "stack": [
          "DefaultParser.handleLongOptionWithoutEqual line 398, DefaultParser.handleLongOption line 371, DefaultParser.handleToken line 239, DefaultParser.parse line 120, DefaultParser.parse line 76, DefaultParser.parse line 60, BugCLI252Test.testExactOptionNameMatch line 10"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/cli/Options.java",
      "buggy_full_code": "\n\npackage org.apache.commons.cli;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\n\n\npublic class Options implements Serializable { private static final long serialVersionUID = 1L; private final Map<String, Option> shortOpts = new LinkedHashMap<String, Option>(); private final Map<String, Option> longOpts = new LinkedHashMap<String, Option>(); private final List<Object> requiredOpts = new ArrayList<Object>(); private final Map<String, OptionGroup> optionGroups = new HashMap<String, OptionGroup>(); public Options addOptionGroup(OptionGroup group) {\n        if (group.isRequired())\n        {\n            requiredOpts.add(group);\n        }\n\n        for (Option option : group.getOptions())\n        {\n            \n            \n            \n            option.setRequired(false);\n            addOption(option);\n\n            optionGroups.put(option.getKey(), group);\n        }\n\n        return this;\n    }\n\n    \n    Collection<OptionGroup> getOptionGroups()\n    {\n        return new HashSet<OptionGroup>(optionGroups.values());\n    }\n\n    \n    public Options addOption(String opt, String description) {\n        addOption(opt, null, false, description);\n        return this;\n    }\n\n    \n    public Options addOption(String opt, boolean hasArg, String description) {\n        addOption(opt, null, hasArg, description);\n        return this;\n    }\n\n    \n    public Options addOption(String opt, String longOpt, boolean hasArg, String description) {\n        addOption(new Option(opt, longOpt, hasArg, description));\n        return this;\n    }\n\n    \n    public Options addOption(Option opt) {\n        String key = opt.getKey();\n\n        \n        if (opt.hasLongOpt())\n        {\n            longOpts.put(opt.getLongOpt(), opt);\n        }\n\n        \n        if (opt.isRequired())\n        {\n            if (requiredOpts.contains(key))\n            {\n                requiredOpts.remove(requiredOpts.indexOf(key));\n            }\n            requiredOpts.add(key);\n        }\n\n        shortOpts.put(key, opt);\n\n        return this;\n    }\n\n    \n    public Collection<Option> getOptions() {\n        return Collections.unmodifiableCollection(helpOptions());\n    }\n\n    \n    List<Option> helpOptions()\n    {\n        return new ArrayList<Option>(shortOpts.values());\n    }\n\n    \n    public List getRequiredOptions() {\n        return Collections.unmodifiableList(requiredOpts);\n    }\n\n    \n    public Option getOption(String opt) {\n        opt = Util.stripLeadingHyphens(opt);\n\n        if (shortOpts.containsKey(opt))\n        {\n            return shortOpts.get(opt);\n        }\n\n        return longOpts.get(opt);\n    }\n\n    \n    public List<String> getMatchingOptions(String opt) {\n        opt = Util.stripLeadingHyphens(opt);\n        \n        List<String> matchingOpts = new ArrayList<String>();\n\n        \n\n        for (String longOpt : longOpts.keySet())\n        {\n            if (longOpt.startsWith(opt))\n            {\n                matchingOpts.add(longOpt);\n            }\n        }\n        \n        return matchingOpts;\n    }\n\n    \n    public boolean hasOption(String opt) {\n        opt = Util.stripLeadingHyphens(opt);\n\n        return shortOpts.containsKey(opt) || longOpts.containsKey(opt);\n    }\n\n    \n    public boolean hasLongOption(String opt) {\n        opt = Util.stripLeadingHyphens(opt);\n\n        return longOpts.containsKey(opt);\n    }\n\n    \n    public boolean hasShortOption(String opt) {\n        opt = Util.stripLeadingHyphens(opt);\n\n        return shortOpts.containsKey(opt);\n    }\n\n    \n    public OptionGroup getOptionGroup(Option opt) {\n        return optionGroups.get(opt.getKey());\n    }\n\n    \n    @Override\n    public String toString() {\n        StringBuilder buf = new StringBuilder();\n\n        buf.append(\"[ Options: [ short \");\n        buf.append(shortOpts.toString());\n        buf.append(\" ] [ long \");\n        buf.append(longOpts);\n        buf.append(\" ]\");\n\n        return buf.toString();\n    }\n}\n",
      "fixed_full_code": "\n\npackage org.apache.commons.cli;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\n\n\npublic class Options implements Serializable { private static final long serialVersionUID = 1L; private final Map<String, Option> shortOpts = new LinkedHashMap<String, Option>(); private final Map<String, Option> longOpts = new LinkedHashMap<String, Option>(); private final List<Object> requiredOpts = new ArrayList<Object>(); private final Map<String, OptionGroup> optionGroups = new HashMap<String, OptionGroup>(); public Options addOptionGroup(OptionGroup group) {\n        if (group.isRequired())\n        {\n            requiredOpts.add(group);\n        }\n\n        for (Option option : group.getOptions())\n        {\n            \n            \n            \n            option.setRequired(false);\n            addOption(option);\n\n            optionGroups.put(option.getKey(), group);\n        }\n\n        return this;\n    }\n\n    \n    Collection<OptionGroup> getOptionGroups()\n    {\n        return new HashSet<OptionGroup>(optionGroups.values());\n    }\n\n    \n    public Options addOption(String opt, String description) {\n        addOption(opt, null, false, description);\n        return this;\n    }\n\n    \n    public Options addOption(String opt, boolean hasArg, String description) {\n        addOption(opt, null, hasArg, description);\n        return this;\n    }\n\n    \n    public Options addOption(String opt, String longOpt, boolean hasArg, String description) {\n        addOption(new Option(opt, longOpt, hasArg, description));\n        return this;\n    }\n\n    \n    public Options addOption(Option opt) {\n        String key = opt.getKey();\n\n        \n        if (opt.hasLongOpt())\n        {\n            longOpts.put(opt.getLongOpt(), opt);\n        }\n\n        \n        if (opt.isRequired())\n        {\n            if (requiredOpts.contains(key))\n            {\n                requiredOpts.remove(requiredOpts.indexOf(key));\n            }\n            requiredOpts.add(key);\n        }\n\n        shortOpts.put(key, opt);\n\n        return this;\n    }\n\n    \n    public Collection<Option> getOptions() {\n        return Collections.unmodifiableCollection(helpOptions());\n    }\n\n    \n    List<Option> helpOptions()\n    {\n        return new ArrayList<Option>(shortOpts.values());\n    }\n\n    \n    public List getRequiredOptions() {\n        return Collections.unmodifiableList(requiredOpts);\n    }\n\n    \n    public Option getOption(String opt) {\n        opt = Util.stripLeadingHyphens(opt);\n\n        if (shortOpts.containsKey(opt))\n        {\n            return shortOpts.get(opt);\n        }\n\n        return longOpts.get(opt);\n    }\n\n    \n    public List<String> getMatchingOptions(String opt) {\n        opt = Util.stripLeadingHyphens(opt);\n        \n        List<String> matchingOpts = new ArrayList<String>();\n\n        \n        if(longOpts.keySet().contains(opt)) {\n            return Collections.singletonList(opt);\n        }\n\n        for (String longOpt : longOpts.keySet())\n        {\n            if (longOpt.startsWith(opt))\n            {\n                matchingOpts.add(longOpt);\n            }\n        }\n        \n        return matchingOpts;\n    }\n\n    \n    public boolean hasOption(String opt) {\n        opt = Util.stripLeadingHyphens(opt);\n\n        return shortOpts.containsKey(opt) || longOpts.containsKey(opt);\n    }\n\n    \n    public boolean hasLongOption(String opt) {\n        opt = Util.stripLeadingHyphens(opt);\n\n        return longOpts.containsKey(opt);\n    }\n\n    \n    public boolean hasShortOption(String opt) {\n        opt = Util.stripLeadingHyphens(opt);\n\n        return shortOpts.containsKey(opt);\n    }\n\n    \n    public OptionGroup getOptionGroup(Option opt) {\n        return optionGroups.get(opt.getKey());\n    }\n\n    \n    @Override\n    public String toString() {\n        StringBuilder buf = new StringBuilder();\n\n        buf.append(\"[ Options: [ short \");\n        buf.append(shortOpts.toString());\n        buf.append(\" ] [ long \");\n        buf.append(longOpts);\n        buf.append(\" ]\");\n\n        return buf.toString();\n    }\n}\n",
      "buggy_signatures": [
        "public Options addOption(String opt, String description)",
        "public Options addOption(String opt, boolean hasArg, String description)",
        "public Options addOption(String opt, String longOpt, boolean hasArg, String description)",
        "public Options addOption(Option opt)",
        "public Collection<Option> getOptions()",
        "public List getRequiredOptions()",
        "public Option getOption(String opt)",
        "public List<String> getMatchingOptions(String opt)",
        "public boolean hasOption(String opt)",
        "public boolean hasLongOption(String opt)",
        "public boolean hasShortOption(String opt)",
        "public OptionGroup getOptionGroup(Option opt)",
        "public String toString()"
      ],
      "fixed_signatures": [
        "public Options addOption(String opt, String description)",
        "public Options addOption(String opt, boolean hasArg, String description)",
        "public Options addOption(String opt, String longOpt, boolean hasArg, String description)",
        "public Options addOption(Option opt)",
        "public Collection<Option> getOptions()",
        "public List getRequiredOptions()",
        "public Option getOption(String opt)",
        "public List<String> getMatchingOptions(String opt)",
        "public boolean hasOption(String opt)",
        "public boolean hasLongOption(String opt)",
        "public boolean hasShortOption(String opt)",
        "public OptionGroup getOptionGroup(Option opt)",
        "public String toString()"
      ],
      "methods": [
        {
          "buggy_method": "  public List<String> getMatchingOptions(String opt) {\n  opt = Util.stripLeadingHyphens(opt);\n  \n  List<String> matchingOpts = new ArrayList<String>();\n\n  \n\n  for (String longOpt : longOpts.keySet())\n  {\n  if (longOpt.startsWith(opt))\n  {\n  matchingOpts.add(longOpt);\n  }\n  }\n  \n  return matchingOpts;\n  }",
          "fixed_method": "  public List<String> getMatchingOptions(String opt) {\n  opt = Util.stripLeadingHyphens(opt);\n  \n  List<String> matchingOpts = new ArrayList<String>();\n\n  \n  if(longOpts.keySet().contains(opt)) {\n  return Collections.singletonList(opt);\n  }\n\n  for (String longOpt : longOpts.keySet())\n  {\n  if (longOpt.startsWith(opt))\n  {\n  matchingOpts.add(longOpt);\n  }\n  }\n  \n  return matchingOpts;\n  }",
          "diff": [
            "@@ -237,6 +237,9 @@",
            "         List<String> matchingOpts = new ArrayList<String>();\n",
            " \n",
            "         // for a perfect match return the single option only\n",
            "+        if(longOpts.keySet().contains(opt)) {\n",
            "+            return Collections.singletonList(opt);\n",
            "+        }\n",
            " \n",
            "         for (String longOpt : longOpts.keySet())\n",
            "         {\n"
          ],
          "changed_lines": 3
        }
      ]
    }
  ]
}
