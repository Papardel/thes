{
  "bug_id": "22",
  "failed_tests": {
    "org.apache.commons.collections4.map.ListOrderedMapTest": [
      {
        "methodName": "testCOLLECTIONS_474_nullValues",
        "error": "java.lang.IndexOutOfBoundsException",
        "message": "Index: 2, Size: 1",
        "fail_line": "        listMap.putAll(2, hmap);",
        "test_source": "  public void testCOLLECTIONS_474_nullValues () {\n  Object key1 = new Object();\n  Object key2 = new Object();\n  HashMap<Object, Object> hmap = new HashMap<Object, Object>();\n  hmap.put(key1, null);\n  hmap.put(key2, null);\n  assertEquals(\"Should have two elements\", 2, hmap.size());\n  ListOrderedMap<Object, Object> listMap = new ListOrderedMap<Object, Object>();\n  listMap.put(key1, null);\n  listMap.put(key2, null);\n  assertEquals(\"Should have two elements\", 2, listMap.size());\n  listMap.putAll(2, hmap);\n  }",
        "stack": [
          "ListOrderedMap.put line 450, ListOrderedMap.putAll line 246, ListOrderedMapTest.testCOLLECTIONS_474_nullValues line 399"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/collections4/map/ListOrderedMap.java",
      "buggy_full_code": "\npackage org.apache.commons.collections4.map;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.util.AbstractList;\nimport java.util.AbstractSet;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Set;\n\nimport org.apache.commons.collections4.OrderedMap;\nimport org.apache.commons.collections4.OrderedMapIterator;\nimport org.apache.commons.collections4.ResettableIterator;\nimport org.apache.commons.collections4.iterators.AbstractUntypedIteratorDecorator;\nimport org.apache.commons.collections4.keyvalue.AbstractMapEntry;\nimport org.apache.commons.collections4.list.UnmodifiableList;\n\n\npublic class ListOrderedMap<K, V> extends AbstractMapDecorator<K, V> implements OrderedMap<K, V>, Serializable { private static final long serialVersionUID = 2728177751851003750L; private final List<K> insertOrder = new ArrayList<K>(); public static <K, V> ListOrderedMap<K, V> listOrderedMap(final Map<K, V> map) {\n        return new ListOrderedMap<K, V>(map);\n    }\n\n    \n    \n    public ListOrderedMap() {\n        this(new HashMap<K, V>());\n    }\n\n    \n    protected ListOrderedMap(final Map<K, V> map) {\n        super(map);\n        insertOrder.addAll(decorated().keySet());\n    }\n\n    \n    \n    private void writeObject(final ObjectOutputStream out) throws IOException {\n        out.defaultWriteObject();\n        out.writeObject(map);\n    }\n\n    \n    @SuppressWarnings(\"unchecked\") \n    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        map = (Map<K, V>) in.readObject(); \n    }\n\n    \n    \n    @Override\n    public OrderedMapIterator<K, V> mapIterator() {\n        return new ListOrderedMapIterator<K, V>(this);\n    }\n\n    \n    public K firstKey() {\n        if (size() == 0) {\n            throw new NoSuchElementException(\"Map is empty\");\n        }\n        return insertOrder.get(0);\n    }\n\n    \n    public K lastKey() {\n        if (size() == 0) {\n            throw new NoSuchElementException(\"Map is empty\");\n        }\n        return insertOrder.get(size() - 1);\n    }\n\n    \n    public K nextKey(final Object key) {\n        final int index = insertOrder.indexOf(key);\n        if (index >= 0 && index < size() - 1) {\n            return insertOrder.get(index + 1);\n        }\n        return null;\n    }\n\n    \n    public K previousKey(final Object key) {\n        final int index = insertOrder.indexOf(key);\n        if (index > 0) {\n            return insertOrder.get(index - 1);\n        }\n        return null;\n    }\n\n    \n    @Override\n    public V put(final K key, final V value) {\n        if (decorated().containsKey(key)) {\n            \n            return decorated().put(key, value);\n        } else {\n            \n            final V result = decorated().put(key, value);\n            insertOrder.add(key);\n            return result;\n        }\n    }\n\n    @Override\n    public void putAll(final Map<? extends K, ? extends V> map) {\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            put(entry.getKey(), entry.getValue());\n        }\n    }\n\n    \n    public void putAll(int index, final Map<? extends K, ? extends V> map) {\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            final V old = put(index, entry.getKey(), entry.getValue());\n            if (old == null) {\n            \n            \n                \n                index++;\n            } else {\n                \n                index = indexOf(entry.getKey()) + 1;\n            }\n        }\n    }\n\n    @Override\n    public V remove(final Object key) {\n        V result = null;\n        if (decorated().containsKey(key)) {\n            result = decorated().remove(key);\n            insertOrder.remove(key);\n        }\n        return result;\n    }\n\n    @Override\n    public void clear() {\n        decorated().clear();\n        insertOrder.clear();\n    }\n\n    \n    \n    @Override\n    public Set<K> keySet() {\n        return new KeySetView<K>(this);\n    }\n\n    \n    public List<K> keyList() {\n        return UnmodifiableList.unmodifiableList(insertOrder);\n    }\n\n    \n    @Override\n    public Collection<V> values() {\n        return new ValuesView<V>(this);\n    }\n\n    \n    public List<V> valueList() {\n        return new ValuesView<V>(this);\n    }\n\n    \n    @Override\n    public Set<Map.Entry<K, V>> entrySet() {\n        return new EntrySetView<K, V>(this, this.insertOrder);\n    }\n\n    \n    \n    @Override\n    public String toString() {\n        if (isEmpty()) {\n            return \"{}\";\n        }\n        final StringBuilder buf = new StringBuilder();\n        buf.append('{');\n        boolean first = true;\n        for (final Map.Entry<K, V> entry : entrySet()) {\n            final K key = entry.getKey();\n            final V value = entry.getValue();\n            if (first) {\n                first = false;\n            } else {\n                buf.append(\", \");\n            }\n            buf.append(key == this ? \"(this Map)\" : key);\n            buf.append('=');\n            buf.append(value == this ? \"(this Map)\" : value);\n        }\n        buf.append('}');\n        return buf.toString();\n    }\n\n    \n    \n    public K get(final int index) {\n        return insertOrder.get(index);\n    }\n\n    \n    public V getValue(final int index) {\n        return get(insertOrder.get(index));\n    }\n\n    \n    public int indexOf(final Object key) {\n        return insertOrder.indexOf(key);\n    }\n\n    \n    public V setValue(final int index, final V value) {\n        final K key = insertOrder.get(index);\n        return put(key, value);\n    }\n\n    \n    public V put(int index, final K key, final V value) {\n        final Map<K, V> m = decorated();\n        if (m.containsKey(key)) {\n            final V result = m.remove(key);\n            final int pos = insertOrder.indexOf(key);\n            insertOrder.remove(pos);\n            if (pos < index) {\n                index--;\n            }\n            insertOrder.add(index, key);\n            m.put(key, value);\n            return result;\n        } else {\n            insertOrder.add(index, key);\n            m.put(key, value);\n            return null;\n        }\n    }\n\n    \n    public V remove(final int index) {\n        return remove(get(index));\n    }\n\n    \n    public List<K> asList() {\n        return keyList();\n    }\n\n    \n    static class ValuesView<V> extends AbstractList<V> { private final ListOrderedMap<Object, V> parent; @SuppressWarnings(\"unchecked\") ValuesView(final ListOrderedMap<?, V> parent) {\n            super();\n            this.parent = (ListOrderedMap<Object, V>) parent;\n        }\n\n        @Override\n        public int size() {\n            return this.parent.size();\n        }\n\n        @Override\n        public boolean contains(final Object value) {\n            return this.parent.containsValue(value);\n        }\n\n        @Override\n        public void clear() {\n            this.parent.clear();\n        }\n\n        @Override\n        public Iterator<V> iterator() {\n            return new AbstractUntypedIteratorDecorator<Map.Entry<Object, V>, V>(parent.entrySet().iterator()) {\n                public V next() {\n                    return getIterator().next().getValue();\n                }\n            };\n        }\n\n        @Override\n        public V get(final int index) {\n            return this.parent.getValue(index);\n        }\n\n        @Override\n        public V set(final int index, final V value) {\n            return this.parent.setValue(index, value);\n        }\n\n        @Override\n        public V remove(final int index) {\n            return this.parent.remove(index);\n        }\n    }\n\n    \n    static class KeySetView<K> extends AbstractSet<K> { private final ListOrderedMap<K, Object> parent; @SuppressWarnings(\"unchecked\") KeySetView(final ListOrderedMap<K, ?> parent) {\n            super();\n            this.parent = (ListOrderedMap<K, Object>) parent;\n        }\n\n        @Override\n        public int size() {\n            return this.parent.size();\n        }\n\n        @Override\n        public boolean contains(final Object value) {\n            return this.parent.containsKey(value);\n        }\n\n        @Override\n        public void clear() {\n            this.parent.clear();\n        }\n\n        @Override\n        public Iterator<K> iterator() {\n            return new AbstractUntypedIteratorDecorator<Map.Entry<K, Object>, K>(parent.entrySet().iterator()) {\n                public K next() {\n                    return getIterator().next().getKey();\n                }\n            };\n        }\n    }\n\n    \n    static class EntrySetView<K, V> extends AbstractSet<Map.Entry<K, V>> { private final ListOrderedMap<K, V> parent; private final List<K> insertOrder; private Set<Map.Entry<K, V>> entrySet; public EntrySetView(final ListOrderedMap<K, V> parent, final List<K> insertOrder) {\n            super();\n            this.parent = parent;\n            this.insertOrder = insertOrder;\n        }\n\n        private Set<Map.Entry<K, V>> getEntrySet() {\n            if (entrySet == null) {\n                entrySet = parent.decorated().entrySet();\n            }\n            return entrySet;\n        }\n\n        @Override\n        public int size() {\n            return this.parent.size();\n        }\n        @Override\n        public boolean isEmpty() {\n            return this.parent.isEmpty();\n        }\n\n        @Override\n        public boolean contains(final Object obj) {\n            return getEntrySet().contains(obj);\n        }\n\n        @Override\n        public boolean containsAll(final Collection<?> coll) {\n            return getEntrySet().containsAll(coll);\n        }\n\n        @Override\n        @SuppressWarnings(\"unchecked\")\n        public boolean remove(final Object obj) {\n            if (obj instanceof Map.Entry == false) {\n                return false;\n            }\n            if (getEntrySet().contains(obj)) {\n                final Object key = ((Map.Entry<K, V>) obj).getKey();\n                parent.remove(key);\n                return true;\n            }\n            return false;\n        }\n\n        @Override\n        public void clear() {\n            this.parent.clear();\n        }\n\n        @Override\n        public boolean equals(final Object obj) {\n            if (obj == this) {\n                return true;\n            }\n            return getEntrySet().equals(obj);\n        }\n\n        @Override\n        public int hashCode() {\n            return getEntrySet().hashCode();\n        }\n\n        @Override\n        public String toString() {\n            return getEntrySet().toString();\n        }\n\n        @Override\n        public Iterator<Map.Entry<K, V>> iterator() {\n            return new ListOrderedIterator<K, V>(parent, insertOrder);\n        }\n    }\n\n    \n    static class ListOrderedIterator<K, V> extends AbstractUntypedIteratorDecorator<K, Map.Entry<K, V>> { private final ListOrderedMap<K, V> parent; private K last = null; ListOrderedIterator(final ListOrderedMap<K, V> parent, final List<K> insertOrder) {\n            super(insertOrder.iterator());\n            this.parent = parent;\n        }\n\n        public Map.Entry<K, V> next() {\n            last = getIterator().next();\n            return new ListOrderedMapEntry<K, V>(parent, last);\n        }\n\n        @Override\n        public void remove() {\n            super.remove();\n            parent.decorated().remove(last);\n        }\n    }\n\n    \n    static class ListOrderedMapEntry<K, V> extends AbstractMapEntry<K, V> { private final ListOrderedMap<K, V> parent; ListOrderedMapEntry(final ListOrderedMap<K, V> parent, final K key) {\n            super(key, null);\n            this.parent = parent;\n        }\n\n        @Override\n        public V getValue() {\n            return parent.get(getKey());\n        }\n\n        @Override\n        public V setValue(final V value) {\n            return parent.decorated().put(getKey(), value);\n        }\n    }\n\n    \n    static class ListOrderedMapIterator<K, V> implements OrderedMapIterator<K, V>, ResettableIterator<K> { private final ListOrderedMap<K, V> parent; private ListIterator<K> iterator; private K last = null; private boolean readable = false; ListOrderedMapIterator(final ListOrderedMap<K, V> parent) {\n            super();\n            this.parent = parent;\n            this.iterator = parent.insertOrder.listIterator();\n        }\n\n        public boolean hasNext() {\n            return iterator.hasNext();\n        }\n\n        public K next() {\n            last = iterator.next();\n            readable = true;\n            return last;\n        }\n\n        public boolean hasPrevious() {\n            return iterator.hasPrevious();\n        }\n\n        public K previous() {\n            last = iterator.previous();\n            readable = true;\n            return last;\n        }\n\n        public void remove() {\n            if (readable == false) {\n                throw new IllegalStateException(AbstractHashedMap.REMOVE_INVALID);\n            }\n            iterator.remove();\n            parent.map.remove(last);\n            readable = false;\n        }\n\n        public K getKey() {\n            if (readable == false) {\n                throw new IllegalStateException(AbstractHashedMap.GETKEY_INVALID);\n            }\n            return last;\n        }\n\n        public V getValue() {\n            if (readable == false) {\n                throw new IllegalStateException(AbstractHashedMap.GETVALUE_INVALID);\n            }\n            return parent.get(last);\n        }\n\n        public V setValue(final V value) {\n            if (readable == false) {\n                throw new IllegalStateException(AbstractHashedMap.SETVALUE_INVALID);\n            }\n            return parent.map.put(last, value);\n        }\n\n        public void reset() {\n            iterator = parent.insertOrder.listIterator();\n            last = null;\n            readable = false;\n        }\n\n        @Override\n        public String toString() {\n            if (readable == true) {\n                return \"Iterator[\" + getKey() + \"=\" + getValue() + \"]\";\n            }\n            return \"Iterator[]\";\n        }\n    }\n\n}\n",
      "fixed_full_code": "\npackage org.apache.commons.collections4.map;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.util.AbstractList;\nimport java.util.AbstractSet;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Set;\n\nimport org.apache.commons.collections4.OrderedMap;\nimport org.apache.commons.collections4.OrderedMapIterator;\nimport org.apache.commons.collections4.ResettableIterator;\nimport org.apache.commons.collections4.iterators.AbstractUntypedIteratorDecorator;\nimport org.apache.commons.collections4.keyvalue.AbstractMapEntry;\nimport org.apache.commons.collections4.list.UnmodifiableList;\n\n\npublic class ListOrderedMap<K, V> extends AbstractMapDecorator<K, V> implements OrderedMap<K, V>, Serializable { private static final long serialVersionUID = 2728177751851003750L; private final List<K> insertOrder = new ArrayList<K>(); public static <K, V> ListOrderedMap<K, V> listOrderedMap(final Map<K, V> map) {\n        return new ListOrderedMap<K, V>(map);\n    }\n\n    \n    \n    public ListOrderedMap() {\n        this(new HashMap<K, V>());\n    }\n\n    \n    protected ListOrderedMap(final Map<K, V> map) {\n        super(map);\n        insertOrder.addAll(decorated().keySet());\n    }\n\n    \n    \n    private void writeObject(final ObjectOutputStream out) throws IOException {\n        out.defaultWriteObject();\n        out.writeObject(map);\n    }\n\n    \n    @SuppressWarnings(\"unchecked\") \n    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        map = (Map<K, V>) in.readObject(); \n    }\n\n    \n    \n    @Override\n    public OrderedMapIterator<K, V> mapIterator() {\n        return new ListOrderedMapIterator<K, V>(this);\n    }\n\n    \n    public K firstKey() {\n        if (size() == 0) {\n            throw new NoSuchElementException(\"Map is empty\");\n        }\n        return insertOrder.get(0);\n    }\n\n    \n    public K lastKey() {\n        if (size() == 0) {\n            throw new NoSuchElementException(\"Map is empty\");\n        }\n        return insertOrder.get(size() - 1);\n    }\n\n    \n    public K nextKey(final Object key) {\n        final int index = insertOrder.indexOf(key);\n        if (index >= 0 && index < size() - 1) {\n            return insertOrder.get(index + 1);\n        }\n        return null;\n    }\n\n    \n    public K previousKey(final Object key) {\n        final int index = insertOrder.indexOf(key);\n        if (index > 0) {\n            return insertOrder.get(index - 1);\n        }\n        return null;\n    }\n\n    \n    @Override\n    public V put(final K key, final V value) {\n        if (decorated().containsKey(key)) {\n            \n            return decorated().put(key, value);\n        } else {\n            \n            final V result = decorated().put(key, value);\n            insertOrder.add(key);\n            return result;\n        }\n    }\n\n    @Override\n    public void putAll(final Map<? extends K, ? extends V> map) {\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            put(entry.getKey(), entry.getValue());\n        }\n    }\n\n    \n    public void putAll(int index, final Map<? extends K, ? extends V> map) {\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            final K key = entry.getKey();\n            final boolean contains = containsKey(key);\n            \n            \n            put(index, entry.getKey(), entry.getValue());\n            if (!contains) {\n                \n                index++;\n            } else {\n                \n                index = indexOf(entry.getKey()) + 1;\n            }\n        }\n    }\n\n    @Override\n    public V remove(final Object key) {\n        V result = null;\n        if (decorated().containsKey(key)) {\n            result = decorated().remove(key);\n            insertOrder.remove(key);\n        }\n        return result;\n    }\n\n    @Override\n    public void clear() {\n        decorated().clear();\n        insertOrder.clear();\n    }\n\n    \n    \n    @Override\n    public Set<K> keySet() {\n        return new KeySetView<K>(this);\n    }\n\n    \n    public List<K> keyList() {\n        return UnmodifiableList.unmodifiableList(insertOrder);\n    }\n\n    \n    @Override\n    public Collection<V> values() {\n        return new ValuesView<V>(this);\n    }\n\n    \n    public List<V> valueList() {\n        return new ValuesView<V>(this);\n    }\n\n    \n    @Override\n    public Set<Map.Entry<K, V>> entrySet() {\n        return new EntrySetView<K, V>(this, this.insertOrder);\n    }\n\n    \n    \n    @Override\n    public String toString() {\n        if (isEmpty()) {\n            return \"{}\";\n        }\n        final StringBuilder buf = new StringBuilder();\n        buf.append('{');\n        boolean first = true;\n        for (final Map.Entry<K, V> entry : entrySet()) {\n            final K key = entry.getKey();\n            final V value = entry.getValue();\n            if (first) {\n                first = false;\n            } else {\n                buf.append(\", \");\n            }\n            buf.append(key == this ? \"(this Map)\" : key);\n            buf.append('=');\n            buf.append(value == this ? \"(this Map)\" : value);\n        }\n        buf.append('}');\n        return buf.toString();\n    }\n\n    \n    \n    public K get(final int index) {\n        return insertOrder.get(index);\n    }\n\n    \n    public V getValue(final int index) {\n        return get(insertOrder.get(index));\n    }\n\n    \n    public int indexOf(final Object key) {\n        return insertOrder.indexOf(key);\n    }\n\n    \n    public V setValue(final int index, final V value) {\n        final K key = insertOrder.get(index);\n        return put(key, value);\n    }\n\n    \n    public V put(int index, final K key, final V value) {\n        final Map<K, V> m = decorated();\n        if (m.containsKey(key)) {\n            final V result = m.remove(key);\n            final int pos = insertOrder.indexOf(key);\n            insertOrder.remove(pos);\n            if (pos < index) {\n                index--;\n            }\n            insertOrder.add(index, key);\n            m.put(key, value);\n            return result;\n        } else {\n            insertOrder.add(index, key);\n            m.put(key, value);\n            return null;\n        }\n    }\n\n    \n    public V remove(final int index) {\n        return remove(get(index));\n    }\n\n    \n    public List<K> asList() {\n        return keyList();\n    }\n\n    \n    static class ValuesView<V> extends AbstractList<V> { private final ListOrderedMap<Object, V> parent; @SuppressWarnings(\"unchecked\") ValuesView(final ListOrderedMap<?, V> parent) {\n            super();\n            this.parent = (ListOrderedMap<Object, V>) parent;\n        }\n\n        @Override\n        public int size() {\n            return this.parent.size();\n        }\n\n        @Override\n        public boolean contains(final Object value) {\n            return this.parent.containsValue(value);\n        }\n\n        @Override\n        public void clear() {\n            this.parent.clear();\n        }\n\n        @Override\n        public Iterator<V> iterator() {\n            return new AbstractUntypedIteratorDecorator<Map.Entry<Object, V>, V>(parent.entrySet().iterator()) {\n                public V next() {\n                    return getIterator().next().getValue();\n                }\n            };\n        }\n\n        @Override\n        public V get(final int index) {\n            return this.parent.getValue(index);\n        }\n\n        @Override\n        public V set(final int index, final V value) {\n            return this.parent.setValue(index, value);\n        }\n\n        @Override\n        public V remove(final int index) {\n            return this.parent.remove(index);\n        }\n    }\n\n    \n    static class KeySetView<K> extends AbstractSet<K> { private final ListOrderedMap<K, Object> parent; @SuppressWarnings(\"unchecked\") KeySetView(final ListOrderedMap<K, ?> parent) {\n            super();\n            this.parent = (ListOrderedMap<K, Object>) parent;\n        }\n\n        @Override\n        public int size() {\n            return this.parent.size();\n        }\n\n        @Override\n        public boolean contains(final Object value) {\n            return this.parent.containsKey(value);\n        }\n\n        @Override\n        public void clear() {\n            this.parent.clear();\n        }\n\n        @Override\n        public Iterator<K> iterator() {\n            return new AbstractUntypedIteratorDecorator<Map.Entry<K, Object>, K>(parent.entrySet().iterator()) {\n                public K next() {\n                    return getIterator().next().getKey();\n                }\n            };\n        }\n    }\n\n    \n    static class EntrySetView<K, V> extends AbstractSet<Map.Entry<K, V>> { private final ListOrderedMap<K, V> parent; private final List<K> insertOrder; private Set<Map.Entry<K, V>> entrySet; public EntrySetView(final ListOrderedMap<K, V> parent, final List<K> insertOrder) {\n            super();\n            this.parent = parent;\n            this.insertOrder = insertOrder;\n        }\n\n        private Set<Map.Entry<K, V>> getEntrySet() {\n            if (entrySet == null) {\n                entrySet = parent.decorated().entrySet();\n            }\n            return entrySet;\n        }\n\n        @Override\n        public int size() {\n            return this.parent.size();\n        }\n        @Override\n        public boolean isEmpty() {\n            return this.parent.isEmpty();\n        }\n\n        @Override\n        public boolean contains(final Object obj) {\n            return getEntrySet().contains(obj);\n        }\n\n        @Override\n        public boolean containsAll(final Collection<?> coll) {\n            return getEntrySet().containsAll(coll);\n        }\n\n        @Override\n        @SuppressWarnings(\"unchecked\")\n        public boolean remove(final Object obj) {\n            if (obj instanceof Map.Entry == false) {\n                return false;\n            }\n            if (getEntrySet().contains(obj)) {\n                final Object key = ((Map.Entry<K, V>) obj).getKey();\n                parent.remove(key);\n                return true;\n            }\n            return false;\n        }\n\n        @Override\n        public void clear() {\n            this.parent.clear();\n        }\n\n        @Override\n        public boolean equals(final Object obj) {\n            if (obj == this) {\n                return true;\n            }\n            return getEntrySet().equals(obj);\n        }\n\n        @Override\n        public int hashCode() {\n            return getEntrySet().hashCode();\n        }\n\n        @Override\n        public String toString() {\n            return getEntrySet().toString();\n        }\n\n        @Override\n        public Iterator<Map.Entry<K, V>> iterator() {\n            return new ListOrderedIterator<K, V>(parent, insertOrder);\n        }\n    }\n\n    \n    static class ListOrderedIterator<K, V> extends AbstractUntypedIteratorDecorator<K, Map.Entry<K, V>> { private final ListOrderedMap<K, V> parent; private K last = null; ListOrderedIterator(final ListOrderedMap<K, V> parent, final List<K> insertOrder) {\n            super(insertOrder.iterator());\n            this.parent = parent;\n        }\n\n        public Map.Entry<K, V> next() {\n            last = getIterator().next();\n            return new ListOrderedMapEntry<K, V>(parent, last);\n        }\n\n        @Override\n        public void remove() {\n            super.remove();\n            parent.decorated().remove(last);\n        }\n    }\n\n    \n    static class ListOrderedMapEntry<K, V> extends AbstractMapEntry<K, V> { private final ListOrderedMap<K, V> parent; ListOrderedMapEntry(final ListOrderedMap<K, V> parent, final K key) {\n            super(key, null);\n            this.parent = parent;\n        }\n\n        @Override\n        public V getValue() {\n            return parent.get(getKey());\n        }\n\n        @Override\n        public V setValue(final V value) {\n            return parent.decorated().put(getKey(), value);\n        }\n    }\n\n    \n    static class ListOrderedMapIterator<K, V> implements OrderedMapIterator<K, V>, ResettableIterator<K> { private final ListOrderedMap<K, V> parent; private ListIterator<K> iterator; private K last = null; private boolean readable = false; ListOrderedMapIterator(final ListOrderedMap<K, V> parent) {\n            super();\n            this.parent = parent;\n            this.iterator = parent.insertOrder.listIterator();\n        }\n\n        public boolean hasNext() {\n            return iterator.hasNext();\n        }\n\n        public K next() {\n            last = iterator.next();\n            readable = true;\n            return last;\n        }\n\n        public boolean hasPrevious() {\n            return iterator.hasPrevious();\n        }\n\n        public K previous() {\n            last = iterator.previous();\n            readable = true;\n            return last;\n        }\n\n        public void remove() {\n            if (readable == false) {\n                throw new IllegalStateException(AbstractHashedMap.REMOVE_INVALID);\n            }\n            iterator.remove();\n            parent.map.remove(last);\n            readable = false;\n        }\n\n        public K getKey() {\n            if (readable == false) {\n                throw new IllegalStateException(AbstractHashedMap.GETKEY_INVALID);\n            }\n            return last;\n        }\n\n        public V getValue() {\n            if (readable == false) {\n                throw new IllegalStateException(AbstractHashedMap.GETVALUE_INVALID);\n            }\n            return parent.get(last);\n        }\n\n        public V setValue(final V value) {\n            if (readable == false) {\n                throw new IllegalStateException(AbstractHashedMap.SETVALUE_INVALID);\n            }\n            return parent.map.put(last, value);\n        }\n\n        public void reset() {\n            iterator = parent.insertOrder.listIterator();\n            last = null;\n            readable = false;\n        }\n\n        @Override\n        public String toString() {\n            if (readable == true) {\n                return \"Iterator[\" + getKey() + \"=\" + getValue() + \"]\";\n            }\n            return \"Iterator[]\";\n        }\n    }\n\n}\n",
      "buggy_signatures": [
        "public ListOrderedMap()",
        "protected ListOrderedMap(final Map<K, V> map)",
        "private void writeObject(final ObjectOutputStream out) throws IOException",
        "private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException",
        "public OrderedMapIterator<K, V> mapIterator()",
        "public K firstKey()",
        "public K lastKey()",
        "public K nextKey(final Object key)",
        "public K previousKey(final Object key)",
        "public V put(final K key, final V value)",
        "public void putAll(final Map<? extends K, ? extends V> map)",
        "public void putAll(int index, final Map<? extends K, ? extends V> map)",
        "public V remove(final Object key)",
        "public void clear()",
        "public Set<K> keySet()",
        "public List<K> keyList()",
        "public Collection<V> values()",
        "public List<V> valueList()",
        "public Set<Map.Entry<K, V>> entrySet()",
        "public String toString()",
        "public K get(final int index)",
        "public V getValue(final int index)",
        "public int indexOf(final Object key)",
        "public V setValue(final int index, final V value)",
        "public V put(int index, final K key, final V value)",
        "public V remove(final int index)",
        "public List<K> asList()",
        "static class ValuesView<V> extends AbstractList<V> { private final ListOrderedMap<Object, V> parent; @SuppressWarnings(\"unchecked\") ValuesView(final ListOrderedMap<?, V> parent)",
        "public int size()",
        "public boolean contains(final Object value)",
        "public void clear()",
        "public Iterator<V> iterator()",
        "public V next()",
        "public V get(final int index)",
        "public V set(final int index, final V value)",
        "public V remove(final int index)",
        "static class KeySetView<K> extends AbstractSet<K> { private final ListOrderedMap<K, Object> parent; @SuppressWarnings(\"unchecked\") KeySetView(final ListOrderedMap<K, ?> parent)",
        "public int size()",
        "public boolean contains(final Object value)",
        "public void clear()",
        "public Iterator<K> iterator()",
        "public K next()",
        "static class EntrySetView<K, V> extends AbstractSet<Map.Entry<K, V>> { private final ListOrderedMap<K, V> parent; private final List<K> insertOrder; private Set<Map.Entry<K, V>> entrySet; public EntrySetView(final ListOrderedMap<K, V> parent, final List<K> insertOrder)",
        "private Set<Map.Entry<K, V>> getEntrySet()",
        "public int size()",
        "public boolean isEmpty()",
        "public boolean contains(final Object obj)",
        "public boolean containsAll(final Collection<?> coll)",
        "public boolean remove(final Object obj)",
        "public void clear()",
        "public boolean equals(final Object obj)",
        "public int hashCode()",
        "public String toString()",
        "public Iterator<Map.Entry<K, V>> iterator()",
        "public Map.Entry<K, V> next()",
        "public void remove()",
        "static class ListOrderedMapEntry<K, V> extends AbstractMapEntry<K, V> { private final ListOrderedMap<K, V> parent; ListOrderedMapEntry(final ListOrderedMap<K, V> parent, final K key)",
        "public V getValue()",
        "public V setValue(final V value)",
        "public boolean hasNext()",
        "public K next()",
        "public boolean hasPrevious()",
        "public K previous()",
        "public void remove()",
        "public K getKey()",
        "public V getValue()",
        "public V setValue(final V value)",
        "public void reset()",
        "public String toString()"
      ],
      "fixed_signatures": [
        "public ListOrderedMap()",
        "protected ListOrderedMap(final Map<K, V> map)",
        "private void writeObject(final ObjectOutputStream out) throws IOException",
        "private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException",
        "public OrderedMapIterator<K, V> mapIterator()",
        "public K firstKey()",
        "public K lastKey()",
        "public K nextKey(final Object key)",
        "public K previousKey(final Object key)",
        "public V put(final K key, final V value)",
        "public void putAll(final Map<? extends K, ? extends V> map)",
        "public void putAll(int index, final Map<? extends K, ? extends V> map)",
        "public V remove(final Object key)",
        "public void clear()",
        "public Set<K> keySet()",
        "public List<K> keyList()",
        "public Collection<V> values()",
        "public List<V> valueList()",
        "public Set<Map.Entry<K, V>> entrySet()",
        "public String toString()",
        "public K get(final int index)",
        "public V getValue(final int index)",
        "public int indexOf(final Object key)",
        "public V setValue(final int index, final V value)",
        "public V put(int index, final K key, final V value)",
        "public V remove(final int index)",
        "public List<K> asList()",
        "static class ValuesView<V> extends AbstractList<V> { private final ListOrderedMap<Object, V> parent; @SuppressWarnings(\"unchecked\") ValuesView(final ListOrderedMap<?, V> parent)",
        "public int size()",
        "public boolean contains(final Object value)",
        "public void clear()",
        "public Iterator<V> iterator()",
        "public V next()",
        "public V get(final int index)",
        "public V set(final int index, final V value)",
        "public V remove(final int index)",
        "static class KeySetView<K> extends AbstractSet<K> { private final ListOrderedMap<K, Object> parent; @SuppressWarnings(\"unchecked\") KeySetView(final ListOrderedMap<K, ?> parent)",
        "public int size()",
        "public boolean contains(final Object value)",
        "public void clear()",
        "public Iterator<K> iterator()",
        "public K next()",
        "static class EntrySetView<K, V> extends AbstractSet<Map.Entry<K, V>> { private final ListOrderedMap<K, V> parent; private final List<K> insertOrder; private Set<Map.Entry<K, V>> entrySet; public EntrySetView(final ListOrderedMap<K, V> parent, final List<K> insertOrder)",
        "private Set<Map.Entry<K, V>> getEntrySet()",
        "public int size()",
        "public boolean isEmpty()",
        "public boolean contains(final Object obj)",
        "public boolean containsAll(final Collection<?> coll)",
        "public boolean remove(final Object obj)",
        "public void clear()",
        "public boolean equals(final Object obj)",
        "public int hashCode()",
        "public String toString()",
        "public Iterator<Map.Entry<K, V>> iterator()",
        "public Map.Entry<K, V> next()",
        "public void remove()",
        "static class ListOrderedMapEntry<K, V> extends AbstractMapEntry<K, V> { private final ListOrderedMap<K, V> parent; ListOrderedMapEntry(final ListOrderedMap<K, V> parent, final K key)",
        "public V getValue()",
        "public V setValue(final V value)",
        "public boolean hasNext()",
        "public K next()",
        "public boolean hasPrevious()",
        "public K previous()",
        "public void remove()",
        "public K getKey()",
        "public V getValue()",
        "public V setValue(final V value)",
        "public void reset()",
        "public String toString()"
      ],
      "methods": [
        {
          "buggy_method": "  public void putAll(int index, final Map<? extends K, ? extends V> map) {\n  for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n  final V old = put(index, entry.getKey(), entry.getValue());\n  if (old == null) {\n  \n  \n  \n  index++;\n  } else {\n  \n  index = indexOf(entry.getKey()) + 1;\n  }\n  }\n  }",
          "fixed_method": "  public void putAll(int index, final Map<? extends K, ? extends V> map) {\n  for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n  final K key = entry.getKey();\n  final boolean contains = containsKey(key);\n  \n  \n  put(index, entry.getKey(), entry.getValue());\n  if (!contains) {\n  \n  index++;\n  } else {\n  \n  index = indexOf(entry.getKey()) + 1;\n  }\n  }\n  }",
          "diff": [
            "@@ -243,10 +243,12 @@",
            "      */\n",
            "     public void putAll(int index, final Map<? extends K, ? extends V> map) {\n",
            "         for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n",
            "-            final V old = put(index, entry.getKey(), entry.getValue());\n",
            "-            if (old == null) {\n",
            "+            final K key = entry.getKey();\n",
            "+            final boolean contains = containsKey(key);\n",
            "             // The return value of put is null if the key did not exist OR the value was null\n",
            "             // so it cannot be used to determine whether the key was added\n",
            "+            put(index, entry.getKey(), entry.getValue());\n",
            "+            if (!contains) {\n",
            "                 // if no key was replaced, increment the index\n",
            "                 index++;\n",
            "             } else {\n"
          ],
          "changed_lines": 6
        }
      ]
    }
  ]
}
