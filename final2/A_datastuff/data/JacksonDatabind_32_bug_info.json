{
  "bug_id": "32",
  "failed_tests": {
    "com.fasterxml.jackson.databind.deser.TestUntypedDeserialization": [
      {
        "methodName": "testNestedUntyped989",
        "error": "com.fasterxml.jackson.databind.JsonMappingException",
        "message": "Can not deserialize instance of java.lang.Object out of END_OBJECT token",
        "fail_line": "        pojo = r.readValue(\"{}\");",
        "test_source": "  public void testNestedUntyped989() throws IOException {\n  Untyped989 pojo;\n  ObjectReader r = MAPPER.readerFor(Untyped989.class);\n\n  pojo = r.readValue(\"[]\");\n  assertTrue(pojo.value instanceof List);\n  pojo = r.readValue(\"[{}]\");\n  assertTrue(pojo.value instanceof List);\n  \n  pojo = r.readValue(\"{}\");\n  assertTrue(pojo.value instanceof Map);\n  pojo = r.readValue(\"{\\\"a\\\":[]}\");\n  assertTrue(pojo.value instanceof Map);\n  }",
        "stack": [
          "JsonMappingException.from line 148, DeserializationContext.mappingException line 857, DeserializationContext.mappingException line 853, UntypedObjectDeserializer$Vanilla.deserialize line 540, BeanDeserializerBase.deserializeFromObjectUsingNonDefault line 1096, BeanDeserializer.deserializeFromObject line 296, BeanDeserializer.deserialize line 133, ObjectReader._bindAndClose line 1511, ObjectReader.readValue line 1136, TestUntypedDeserialization.testNestedUntyped989 line 264"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java",
      "buggy_full_code": "package com.fasterxml.jackson.databind.deser.std;\n\nimport java.io.IOException;\nimport java.util.*;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.databind.BeanProperty;\nimport com.fasterxml.jackson.databind.DeserializationContext;\nimport com.fasterxml.jackson.databind.DeserializationFeature;\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.JsonDeserializer;\nimport com.fasterxml.jackson.databind.JsonMappingException;\nimport com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\nimport com.fasterxml.jackson.databind.deser.ContextualDeserializer;\nimport com.fasterxml.jackson.databind.deser.ResolvableDeserializer;\nimport com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\nimport com.fasterxml.jackson.databind.type.TypeFactory;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\nimport com.fasterxml.jackson.databind.util.ObjectBuffer;\n\n\n@JacksonStdImpl\npublic class UntypedObjectDeserializer extends StdDeserializer<Object> implements ResolvableDeserializer, ContextualDeserializer { private static final long serialVersionUID = 1L; protected final static Object[] NO_OBJECTS = new Object[0]; @Deprecated public final static UntypedObjectDeserializer instance = new UntypedObjectDeserializer(null, null); protected JsonDeserializer<Object> _mapDeserializer; protected JsonDeserializer<Object> _listDeserializer; protected JsonDeserializer<Object> _stringDeserializer; protected JsonDeserializer<Object> _numberDeserializer; protected JavaType _listType; protected JavaType _mapType; @Deprecated public UntypedObjectDeserializer() {\n        this(null, null);\n    }\n\n    public UntypedObjectDeserializer(JavaType listType, JavaType mapType) {\n        super(Object.class);\n        _listType = listType;\n        _mapType = mapType;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public UntypedObjectDeserializer(UntypedObjectDeserializer base, JsonDeserializer<?> mapDeser, JsonDeserializer<?> listDeser, JsonDeserializer<?> stringDeser, JsonDeserializer<?> numberDeser) {\n        super(Object.class);\n        _mapDeserializer = (JsonDeserializer<Object>) mapDeser;\n        _listDeserializer = (JsonDeserializer<Object>) listDeser;\n        _stringDeserializer = (JsonDeserializer<Object>) stringDeser;\n        _numberDeserializer = (JsonDeserializer<Object>) numberDeser;\n        _listType = base._listType;\n        _mapType = base._mapType;\n    }\n\n    \n\n    \n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public void resolve(DeserializationContext ctxt) throws JsonMappingException {\n        JavaType obType = ctxt.constructType(Object.class);\n        JavaType stringType = ctxt.constructType(String.class);\n        TypeFactory tf = ctxt.getTypeFactory();\n\n        \n\n        \n        if (_listType == null) {\n            _listDeserializer = _clearIfStdImpl(_findCustomDeser(ctxt, tf.constructCollectionType(List.class, obType)));\n        } else {\n            \n            _listDeserializer = _findCustomDeser(ctxt, _listType);\n        }\n        if (_mapType == null) {\n            _mapDeserializer = _clearIfStdImpl(_findCustomDeser(ctxt, tf.constructMapType(Map.class, stringType, obType)));\n        } else {\n            \n            _mapDeserializer = _findCustomDeser(ctxt, _mapType);\n        }\n        _stringDeserializer = _clearIfStdImpl(_findCustomDeser(ctxt, stringType));\n        _numberDeserializer = _clearIfStdImpl(_findCustomDeser(ctxt, tf.constructType(Number.class)));\n\n        \n        \n        JavaType unknown = TypeFactory.unknownType();\n        _mapDeserializer = (JsonDeserializer<Object>) ctxt.handleSecondaryContextualization(_mapDeserializer, null, unknown);\n        _listDeserializer = (JsonDeserializer<Object>) ctxt.handleSecondaryContextualization(_listDeserializer, null, unknown);\n        _stringDeserializer = (JsonDeserializer<Object>) ctxt.handleSecondaryContextualization(_stringDeserializer, null, unknown);\n        _numberDeserializer = (JsonDeserializer<Object>) ctxt.handleSecondaryContextualization(_numberDeserializer, null, unknown);\n    }\n\n    protected JsonDeserializer<Object> _findCustomDeser(DeserializationContext ctxt, JavaType type) throws JsonMappingException {\n        \n        \n        return ctxt.findNonContextualValueDeserializer(type);\n    }\n\n    protected JsonDeserializer<Object> _clearIfStdImpl(JsonDeserializer<Object> deser) {\n        return ClassUtil.isJacksonStdImpl(deser) ? null : deser;\n    }\n\n    \n    @Override\n    public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException {\n        \n        \n        if ((_stringDeserializer == null) && (_numberDeserializer == null)\n                && (_mapDeserializer == null) && (_listDeserializer == null)\n                &&  getClass() == UntypedObjectDeserializer.class) {\n            return Vanilla.std;\n        }\n        return this;\n    }\n\n    protected JsonDeserializer<?> _withResolved(JsonDeserializer<?> mapDeser, JsonDeserializer<?> listDeser, JsonDeserializer<?> stringDeser, JsonDeserializer<?> numberDeser) {\n        return new UntypedObjectDeserializer(this,\n                mapDeser, listDeser, stringDeser, numberDeser);\n    }\n\n    \n\n    \n    @Override\n    public boolean isCachable() {\n        \n        return true;\n    }\n\n    @Override\n    public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n        switch (p.getCurrentTokenId()) {\n        case JsonTokenId.ID_START_OBJECT:\n        case JsonTokenId.ID_FIELD_NAME:\n            \n            \n            if (_mapDeserializer != null) {\n                return _mapDeserializer.deserialize(p, ctxt);\n            }\n            return mapObject(p, ctxt);\n        case JsonTokenId.ID_START_ARRAY:\n            if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                return mapArrayToArray(p, ctxt);\n            }\n            if (_listDeserializer != null) {\n                return _listDeserializer.deserialize(p, ctxt);\n            }\n            return mapArray(p, ctxt);\n        case JsonTokenId.ID_EMBEDDED_OBJECT:\n            return p.getEmbeddedObject();\n        case JsonTokenId.ID_STRING:\n            if (_stringDeserializer != null) {\n                return _stringDeserializer.deserialize(p, ctxt);\n            }\n            return p.getText();\n\n        case JsonTokenId.ID_NUMBER_INT:\n            if (_numberDeserializer != null) {\n                return _numberDeserializer.deserialize(p, ctxt);\n            }\n            \n            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                return _coerceIntegral(p, ctxt);\n            }\n            return p.getNumberValue(); \n\n        case JsonTokenId.ID_NUMBER_FLOAT:\n            if (_numberDeserializer != null) {\n                return _numberDeserializer.deserialize(p, ctxt);\n            }\n            \n            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                return p.getDecimalValue();\n            }\n            return p.getDoubleValue();\n\n        case JsonTokenId.ID_TRUE:\n            return Boolean.TRUE;\n        case JsonTokenId.ID_FALSE:\n            return Boolean.FALSE;\n\n        case JsonTokenId.ID_NULL: \n            return null;\n\n\n        default:\n        }\n        throw ctxt.mappingException(Object.class);\n    }\n\n    @Override\n    public Object deserializeWithType(JsonParser p, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException {\n        switch (p.getCurrentTokenId()) {\n        \n        case JsonTokenId.ID_START_ARRAY:\n        case JsonTokenId.ID_START_OBJECT:\n        case JsonTokenId.ID_FIELD_NAME:\n            \n            return typeDeserializer.deserializeTypedFromAny(p, ctxt);\n\n        case JsonTokenId.ID_EMBEDDED_OBJECT:\n            return p.getEmbeddedObject();\n            \n        \n        case JsonTokenId.ID_STRING:\n            if (_stringDeserializer != null) {\n                return _stringDeserializer.deserialize(p, ctxt);\n            }\n            return p.getText();\n\n        case JsonTokenId.ID_NUMBER_INT:\n            if (_numberDeserializer != null) {\n                return _numberDeserializer.deserialize(p, ctxt);\n            }\n            \n            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                return _coerceIntegral(p, ctxt);\n            }\n            return p.getNumberValue(); \n\n        case JsonTokenId.ID_NUMBER_FLOAT:\n            if (_numberDeserializer != null) {\n                return _numberDeserializer.deserialize(p, ctxt);\n            }\n            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                return p.getDecimalValue();\n            }\n            return Double.valueOf(p.getDoubleValue());\n\n        case JsonTokenId.ID_TRUE:\n            return Boolean.TRUE;\n        case JsonTokenId.ID_FALSE:\n            return Boolean.FALSE;\n\n        case JsonTokenId.ID_NULL: \n            return null;\n        default:\n        }\n        throw ctxt.mappingException(Object.class);\n    }\n\n    \n    \n    \n    protected Object mapArray(JsonParser jp, DeserializationContext ctxt) throws IOException {\n        \n        if (jp.nextToken()  == JsonToken.END_ARRAY) {\n            return new ArrayList<Object>(2);\n        }\n        Object value = deserialize(jp, ctxt);\n        if (jp.nextToken()  == JsonToken.END_ARRAY) {\n            ArrayList<Object> l = new ArrayList<Object>(2);\n            l.add(value);\n            return l;\n        }\n        Object value2 = deserialize(jp, ctxt);\n        if (jp.nextToken()  == JsonToken.END_ARRAY) {\n            ArrayList<Object> l = new ArrayList<Object>(2);\n            l.add(value);\n            l.add(value2);\n            return l;\n        }\n        ObjectBuffer buffer = ctxt.leaseObjectBuffer();\n        Object[] values = buffer.resetAndStart();\n        int ptr = 0;\n        values[ptr++] = value;\n        values[ptr++] = value2;\n        int totalSize = ptr;\n        do {\n            value = deserialize(jp, ctxt);\n            ++totalSize;\n            if (ptr >= values.length) {\n                values = buffer.appendCompletedChunk(values);\n                ptr = 0;\n            }\n            values[ptr++] = value;\n        } while (jp.nextToken() != JsonToken.END_ARRAY);\n        \n        ArrayList<Object> result = new ArrayList<Object>(totalSize);\n        buffer.completeAndClearBuffer(values, ptr, result);\n        return result;\n    }\n\n    \n    protected Object mapObject(JsonParser p, DeserializationContext ctxt) throws IOException {\n        String key1;\n\n        JsonToken t = p.getCurrentToken();\n        \n        if (t == JsonToken.START_OBJECT) {\n            key1 = p.nextFieldName();\n        } else if (t == JsonToken.FIELD_NAME) {\n            key1 = p.getCurrentName();\n        } else {\n            if (t != JsonToken.END_OBJECT) {\n                throw ctxt.mappingException(handledType(), p.getCurrentToken());\n            }\n            key1 = null;\n        }\n        if (key1 == null) {\n            \n            return new LinkedHashMap<String,Object>(2);\n        }\n        \n        \n        \n        p.nextToken();\n        Object value1 = deserialize(p, ctxt);\n\n        String key2 = p.nextFieldName();\n        if (key2 == null) { \n            \n            LinkedHashMap<String, Object> result = new LinkedHashMap<String, Object>(2);\n            result.put(key1, value1);\n            return result;\n        }\n        p.nextToken();\n        Object value2 = deserialize(p, ctxt);\n\n        String key = p.nextFieldName();\n\n        if (key == null) {\n            LinkedHashMap<String, Object> result = new LinkedHashMap<String, Object>(4);\n            result.put(key1, value1);\n            result.put(key2, value2);\n            return result;\n        }\n        \n        LinkedHashMap<String, Object> result = new LinkedHashMap<String, Object>();\n        result.put(key1, value1);\n        result.put(key2, value2);\n\n        do {\n            p.nextToken();\n            result.put(key, deserialize(p, ctxt));\n        } while ((key = p.nextFieldName()) != null);\n        return result;\n    }\n\n    \n    protected Object[] mapArrayToArray(JsonParser jp, DeserializationContext ctxt) throws IOException {\n        \n        if (jp.nextToken()  == JsonToken.END_ARRAY) {\n            return NO_OBJECTS;\n        }\n        ObjectBuffer buffer = ctxt.leaseObjectBuffer();\n        Object[] values = buffer.resetAndStart();\n        int ptr = 0;\n        do {\n            Object value = deserialize(jp, ctxt);\n            if (ptr >= values.length) {\n                values = buffer.appendCompletedChunk(values);\n                ptr = 0;\n            }\n            values[ptr++] = value;\n        } while (jp.nextToken() != JsonToken.END_ARRAY);\n        return buffer.completeAndClearBuffer(values, ptr);\n    }\n\n    \n\n    @JacksonStdImpl\n    public static class Vanilla extends StdDeserializer<Object> { private static final long serialVersionUID = 1L; public final static Vanilla std = new Vanilla(); public Vanilla() { super(Object.class); }\n\n        @Override\n        public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n            switch (p.getCurrentTokenId()) {\n            case JsonTokenId.ID_START_OBJECT:\n                {\n                    JsonToken t = p.nextToken();\n                    if (t == JsonToken.END_OBJECT) {\n                        return new LinkedHashMap<String,Object>(2);\n                    }\n                }\n            case JsonTokenId.ID_FIELD_NAME:\n                return mapObject(p, ctxt);\n            case JsonTokenId.ID_START_ARRAY:\n                {\n                    JsonToken t = p.nextToken();\n                    if (t == JsonToken.END_ARRAY) { \n                        if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                            return NO_OBJECTS;\n                        }\n                        return new ArrayList<Object>(2);\n                    }\n                }\n                if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                    return mapArrayToArray(p, ctxt);\n                }\n                return mapArray(p, ctxt);\n            case JsonTokenId.ID_EMBEDDED_OBJECT:\n                return p.getEmbeddedObject();\n            case JsonTokenId.ID_STRING:\n                return p.getText();\n\n            case JsonTokenId.ID_NUMBER_INT:\n                if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                    return _coerceIntegral(p, ctxt);\n                }\n                return p.getNumberValue(); \n\n            case JsonTokenId.ID_NUMBER_FLOAT:\n                if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                    return p.getDecimalValue();\n                }\n                return Double.valueOf(p.getDoubleValue());\n\n            case JsonTokenId.ID_TRUE:\n                return Boolean.TRUE;\n            case JsonTokenId.ID_FALSE:\n                return Boolean.FALSE;\n\n            case JsonTokenId.ID_NULL: \n                return null;\n\n                \n                \n\n            \n            default:\n                throw ctxt.mappingException(Object.class);\n            }\n        }\n\n        @Override\n        public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException {\n            switch (jp.getCurrentTokenId()) {\n            case JsonTokenId.ID_START_ARRAY:\n            case JsonTokenId.ID_START_OBJECT:\n            case JsonTokenId.ID_FIELD_NAME:\n                return typeDeserializer.deserializeTypedFromAny(jp, ctxt);\n\n            case JsonTokenId.ID_STRING:\n                return jp.getText();\n\n            case JsonTokenId.ID_NUMBER_INT:\n                if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) {\n                    return jp.getBigIntegerValue();\n                }\n                return jp.getNumberValue();\n\n            case JsonTokenId.ID_NUMBER_FLOAT:\n                if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                    return jp.getDecimalValue();\n                }\n                return Double.valueOf(jp.getDoubleValue());\n\n            case JsonTokenId.ID_TRUE:\n                return Boolean.TRUE;\n            case JsonTokenId.ID_FALSE:\n                return Boolean.FALSE;\n            case JsonTokenId.ID_EMBEDDED_OBJECT:\n                return jp.getEmbeddedObject();\n\n            case JsonTokenId.ID_NULL: \n                return null;\n            default:\n                throw ctxt.mappingException(Object.class);\n            }\n        }\n\n        protected Object mapArray(JsonParser jp, DeserializationContext ctxt) throws IOException {\n            Object value = deserialize(jp, ctxt);\n            if (jp.nextToken()  == JsonToken.END_ARRAY) {\n                ArrayList<Object> l = new ArrayList<Object>(2);\n                l.add(value);\n                return l;\n            }\n            Object value2 = deserialize(jp, ctxt);\n            if (jp.nextToken()  == JsonToken.END_ARRAY) {\n                ArrayList<Object> l = new ArrayList<Object>(2);\n                l.add(value);\n                l.add(value2);\n                return l;\n            }\n            ObjectBuffer buffer = ctxt.leaseObjectBuffer();\n            Object[] values = buffer.resetAndStart();\n            int ptr = 0;\n            values[ptr++] = value;\n            values[ptr++] = value2;\n            int totalSize = ptr;\n            do {\n                value = deserialize(jp, ctxt);\n                ++totalSize;\n                if (ptr >= values.length) {\n                    values = buffer.appendCompletedChunk(values);\n                    ptr = 0;\n                }\n                values[ptr++] = value;\n            } while (jp.nextToken() != JsonToken.END_ARRAY);\n            \n            ArrayList<Object> result = new ArrayList<Object>(totalSize);\n            buffer.completeAndClearBuffer(values, ptr, result);\n            return result;\n        }\n\n        \n        protected Object mapObject(JsonParser p, DeserializationContext ctxt) throws IOException {\n            \n            String key1 = p.getText();\n            p.nextToken();\n            Object value1 = deserialize(p, ctxt);\n\n            String key2 = p.nextFieldName();\n            if (key2 == null) { \n                LinkedHashMap<String, Object> result = new LinkedHashMap<String, Object>(2);\n                result.put(key1, value1);\n                return result;\n            }\n            p.nextToken();\n            Object value2 = deserialize(p, ctxt);\n\n            String key = p.nextFieldName();\n            if (key == null) {\n                LinkedHashMap<String, Object> result = new LinkedHashMap<String, Object>(4);\n                result.put(key1, value1);\n                result.put(key2, value2);\n                return result;\n            }\n            \n            LinkedHashMap<String, Object> result = new LinkedHashMap<String, Object>();\n            result.put(key1, value1);\n            result.put(key2, value2);\n            do {\n                p.nextToken();\n                result.put(key, deserialize(p, ctxt));\n            } while ((key = p.nextFieldName()) != null);\n            return result;\n        }\n\n        \n        protected Object[] mapArrayToArray(JsonParser jp, DeserializationContext ctxt) throws IOException {\n            ObjectBuffer buffer = ctxt.leaseObjectBuffer();\n            Object[] values = buffer.resetAndStart();\n            int ptr = 0;\n            do {\n                Object value = deserialize(jp, ctxt);\n                if (ptr >= values.length) {\n                    values = buffer.appendCompletedChunk(values);\n                    ptr = 0;\n                }\n                values[ptr++] = value;\n            } while (jp.nextToken() != JsonToken.END_ARRAY);\n            return buffer.completeAndClearBuffer(values, ptr);\n        }\n    }\n}\n",
      "fixed_full_code": "package com.fasterxml.jackson.databind.deser.std;\n\nimport java.io.IOException;\nimport java.util.*;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.databind.BeanProperty;\nimport com.fasterxml.jackson.databind.DeserializationContext;\nimport com.fasterxml.jackson.databind.DeserializationFeature;\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.JsonDeserializer;\nimport com.fasterxml.jackson.databind.JsonMappingException;\nimport com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\nimport com.fasterxml.jackson.databind.deser.ContextualDeserializer;\nimport com.fasterxml.jackson.databind.deser.ResolvableDeserializer;\nimport com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\nimport com.fasterxml.jackson.databind.type.TypeFactory;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\nimport com.fasterxml.jackson.databind.util.ObjectBuffer;\n\n\n@JacksonStdImpl\npublic class UntypedObjectDeserializer extends StdDeserializer<Object> implements ResolvableDeserializer, ContextualDeserializer { private static final long serialVersionUID = 1L; protected final static Object[] NO_OBJECTS = new Object[0]; @Deprecated public final static UntypedObjectDeserializer instance = new UntypedObjectDeserializer(null, null); protected JsonDeserializer<Object> _mapDeserializer; protected JsonDeserializer<Object> _listDeserializer; protected JsonDeserializer<Object> _stringDeserializer; protected JsonDeserializer<Object> _numberDeserializer; protected JavaType _listType; protected JavaType _mapType; @Deprecated public UntypedObjectDeserializer() {\n        this(null, null);\n    }\n\n    public UntypedObjectDeserializer(JavaType listType, JavaType mapType) {\n        super(Object.class);\n        _listType = listType;\n        _mapType = mapType;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public UntypedObjectDeserializer(UntypedObjectDeserializer base, JsonDeserializer<?> mapDeser, JsonDeserializer<?> listDeser, JsonDeserializer<?> stringDeser, JsonDeserializer<?> numberDeser) {\n        super(Object.class);\n        _mapDeserializer = (JsonDeserializer<Object>) mapDeser;\n        _listDeserializer = (JsonDeserializer<Object>) listDeser;\n        _stringDeserializer = (JsonDeserializer<Object>) stringDeser;\n        _numberDeserializer = (JsonDeserializer<Object>) numberDeser;\n        _listType = base._listType;\n        _mapType = base._mapType;\n    }\n\n    \n\n    \n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public void resolve(DeserializationContext ctxt) throws JsonMappingException {\n        JavaType obType = ctxt.constructType(Object.class);\n        JavaType stringType = ctxt.constructType(String.class);\n        TypeFactory tf = ctxt.getTypeFactory();\n\n        \n\n        \n        if (_listType == null) {\n            _listDeserializer = _clearIfStdImpl(_findCustomDeser(ctxt, tf.constructCollectionType(List.class, obType)));\n        } else {\n            \n            _listDeserializer = _findCustomDeser(ctxt, _listType);\n        }\n        if (_mapType == null) {\n            _mapDeserializer = _clearIfStdImpl(_findCustomDeser(ctxt, tf.constructMapType(Map.class, stringType, obType)));\n        } else {\n            \n            _mapDeserializer = _findCustomDeser(ctxt, _mapType);\n        }\n        _stringDeserializer = _clearIfStdImpl(_findCustomDeser(ctxt, stringType));\n        _numberDeserializer = _clearIfStdImpl(_findCustomDeser(ctxt, tf.constructType(Number.class)));\n\n        \n        \n        JavaType unknown = TypeFactory.unknownType();\n        _mapDeserializer = (JsonDeserializer<Object>) ctxt.handleSecondaryContextualization(_mapDeserializer, null, unknown);\n        _listDeserializer = (JsonDeserializer<Object>) ctxt.handleSecondaryContextualization(_listDeserializer, null, unknown);\n        _stringDeserializer = (JsonDeserializer<Object>) ctxt.handleSecondaryContextualization(_stringDeserializer, null, unknown);\n        _numberDeserializer = (JsonDeserializer<Object>) ctxt.handleSecondaryContextualization(_numberDeserializer, null, unknown);\n    }\n\n    protected JsonDeserializer<Object> _findCustomDeser(DeserializationContext ctxt, JavaType type) throws JsonMappingException {\n        \n        \n        return ctxt.findNonContextualValueDeserializer(type);\n    }\n\n    protected JsonDeserializer<Object> _clearIfStdImpl(JsonDeserializer<Object> deser) {\n        return ClassUtil.isJacksonStdImpl(deser) ? null : deser;\n    }\n\n    \n    @Override\n    public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException {\n        \n        \n        if ((_stringDeserializer == null) && (_numberDeserializer == null)\n                && (_mapDeserializer == null) && (_listDeserializer == null)\n                &&  getClass() == UntypedObjectDeserializer.class) {\n            return Vanilla.std;\n        }\n        return this;\n    }\n\n    protected JsonDeserializer<?> _withResolved(JsonDeserializer<?> mapDeser, JsonDeserializer<?> listDeser, JsonDeserializer<?> stringDeser, JsonDeserializer<?> numberDeser) {\n        return new UntypedObjectDeserializer(this,\n                mapDeser, listDeser, stringDeser, numberDeser);\n    }\n\n    \n\n    \n    @Override\n    public boolean isCachable() {\n        \n        return true;\n    }\n\n    @Override\n    public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n        switch (p.getCurrentTokenId()) {\n        case JsonTokenId.ID_START_OBJECT:\n        case JsonTokenId.ID_FIELD_NAME:\n            \n            \n        case JsonTokenId.ID_END_OBJECT:\n            if (_mapDeserializer != null) {\n                return _mapDeserializer.deserialize(p, ctxt);\n            }\n            return mapObject(p, ctxt);\n        case JsonTokenId.ID_START_ARRAY:\n            if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                return mapArrayToArray(p, ctxt);\n            }\n            if (_listDeserializer != null) {\n                return _listDeserializer.deserialize(p, ctxt);\n            }\n            return mapArray(p, ctxt);\n        case JsonTokenId.ID_EMBEDDED_OBJECT:\n            return p.getEmbeddedObject();\n        case JsonTokenId.ID_STRING:\n            if (_stringDeserializer != null) {\n                return _stringDeserializer.deserialize(p, ctxt);\n            }\n            return p.getText();\n\n        case JsonTokenId.ID_NUMBER_INT:\n            if (_numberDeserializer != null) {\n                return _numberDeserializer.deserialize(p, ctxt);\n            }\n            \n            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                return _coerceIntegral(p, ctxt);\n            }\n            return p.getNumberValue(); \n\n        case JsonTokenId.ID_NUMBER_FLOAT:\n            if (_numberDeserializer != null) {\n                return _numberDeserializer.deserialize(p, ctxt);\n            }\n            \n            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                return p.getDecimalValue();\n            }\n            return p.getDoubleValue();\n\n        case JsonTokenId.ID_TRUE:\n            return Boolean.TRUE;\n        case JsonTokenId.ID_FALSE:\n            return Boolean.FALSE;\n\n        case JsonTokenId.ID_NULL: \n            return null;\n\n\n        default:\n        }\n        throw ctxt.mappingException(Object.class);\n    }\n\n    @Override\n    public Object deserializeWithType(JsonParser p, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException {\n        switch (p.getCurrentTokenId()) {\n        \n        case JsonTokenId.ID_START_ARRAY:\n        case JsonTokenId.ID_START_OBJECT:\n        case JsonTokenId.ID_FIELD_NAME:\n            \n            return typeDeserializer.deserializeTypedFromAny(p, ctxt);\n\n        case JsonTokenId.ID_EMBEDDED_OBJECT:\n            return p.getEmbeddedObject();\n            \n        \n        case JsonTokenId.ID_STRING:\n            if (_stringDeserializer != null) {\n                return _stringDeserializer.deserialize(p, ctxt);\n            }\n            return p.getText();\n\n        case JsonTokenId.ID_NUMBER_INT:\n            if (_numberDeserializer != null) {\n                return _numberDeserializer.deserialize(p, ctxt);\n            }\n            \n            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                return _coerceIntegral(p, ctxt);\n            }\n            return p.getNumberValue(); \n\n        case JsonTokenId.ID_NUMBER_FLOAT:\n            if (_numberDeserializer != null) {\n                return _numberDeserializer.deserialize(p, ctxt);\n            }\n            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                return p.getDecimalValue();\n            }\n            return Double.valueOf(p.getDoubleValue());\n\n        case JsonTokenId.ID_TRUE:\n            return Boolean.TRUE;\n        case JsonTokenId.ID_FALSE:\n            return Boolean.FALSE;\n\n        case JsonTokenId.ID_NULL: \n            return null;\n        default:\n        }\n        throw ctxt.mappingException(Object.class);\n    }\n\n    \n    \n    \n    protected Object mapArray(JsonParser jp, DeserializationContext ctxt) throws IOException {\n        \n        if (jp.nextToken()  == JsonToken.END_ARRAY) {\n            return new ArrayList<Object>(2);\n        }\n        Object value = deserialize(jp, ctxt);\n        if (jp.nextToken()  == JsonToken.END_ARRAY) {\n            ArrayList<Object> l = new ArrayList<Object>(2);\n            l.add(value);\n            return l;\n        }\n        Object value2 = deserialize(jp, ctxt);\n        if (jp.nextToken()  == JsonToken.END_ARRAY) {\n            ArrayList<Object> l = new ArrayList<Object>(2);\n            l.add(value);\n            l.add(value2);\n            return l;\n        }\n        ObjectBuffer buffer = ctxt.leaseObjectBuffer();\n        Object[] values = buffer.resetAndStart();\n        int ptr = 0;\n        values[ptr++] = value;\n        values[ptr++] = value2;\n        int totalSize = ptr;\n        do {\n            value = deserialize(jp, ctxt);\n            ++totalSize;\n            if (ptr >= values.length) {\n                values = buffer.appendCompletedChunk(values);\n                ptr = 0;\n            }\n            values[ptr++] = value;\n        } while (jp.nextToken() != JsonToken.END_ARRAY);\n        \n        ArrayList<Object> result = new ArrayList<Object>(totalSize);\n        buffer.completeAndClearBuffer(values, ptr, result);\n        return result;\n    }\n\n    \n    protected Object mapObject(JsonParser p, DeserializationContext ctxt) throws IOException {\n        String key1;\n\n        JsonToken t = p.getCurrentToken();\n        \n        if (t == JsonToken.START_OBJECT) {\n            key1 = p.nextFieldName();\n        } else if (t == JsonToken.FIELD_NAME) {\n            key1 = p.getCurrentName();\n        } else {\n            if (t != JsonToken.END_OBJECT) {\n                throw ctxt.mappingException(handledType(), p.getCurrentToken());\n            }\n            key1 = null;\n        }\n        if (key1 == null) {\n            \n            return new LinkedHashMap<String,Object>(2);\n        }\n        \n        \n        \n        p.nextToken();\n        Object value1 = deserialize(p, ctxt);\n\n        String key2 = p.nextFieldName();\n        if (key2 == null) { \n            \n            LinkedHashMap<String, Object> result = new LinkedHashMap<String, Object>(2);\n            result.put(key1, value1);\n            return result;\n        }\n        p.nextToken();\n        Object value2 = deserialize(p, ctxt);\n\n        String key = p.nextFieldName();\n\n        if (key == null) {\n            LinkedHashMap<String, Object> result = new LinkedHashMap<String, Object>(4);\n            result.put(key1, value1);\n            result.put(key2, value2);\n            return result;\n        }\n        \n        LinkedHashMap<String, Object> result = new LinkedHashMap<String, Object>();\n        result.put(key1, value1);\n        result.put(key2, value2);\n\n        do {\n            p.nextToken();\n            result.put(key, deserialize(p, ctxt));\n        } while ((key = p.nextFieldName()) != null);\n        return result;\n    }\n\n    \n    protected Object[] mapArrayToArray(JsonParser jp, DeserializationContext ctxt) throws IOException {\n        \n        if (jp.nextToken()  == JsonToken.END_ARRAY) {\n            return NO_OBJECTS;\n        }\n        ObjectBuffer buffer = ctxt.leaseObjectBuffer();\n        Object[] values = buffer.resetAndStart();\n        int ptr = 0;\n        do {\n            Object value = deserialize(jp, ctxt);\n            if (ptr >= values.length) {\n                values = buffer.appendCompletedChunk(values);\n                ptr = 0;\n            }\n            values[ptr++] = value;\n        } while (jp.nextToken() != JsonToken.END_ARRAY);\n        return buffer.completeAndClearBuffer(values, ptr);\n    }\n\n    \n\n    @JacksonStdImpl\n    public static class Vanilla extends StdDeserializer<Object> { private static final long serialVersionUID = 1L; public final static Vanilla std = new Vanilla(); public Vanilla() { super(Object.class); }\n\n        @Override\n        public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n            switch (p.getCurrentTokenId()) {\n            case JsonTokenId.ID_START_OBJECT:\n                {\n                    JsonToken t = p.nextToken();\n                    if (t == JsonToken.END_OBJECT) {\n                        return new LinkedHashMap<String,Object>(2);\n                    }\n                }\n            case JsonTokenId.ID_FIELD_NAME:\n                return mapObject(p, ctxt);\n            case JsonTokenId.ID_START_ARRAY:\n                {\n                    JsonToken t = p.nextToken();\n                    if (t == JsonToken.END_ARRAY) { \n                        if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                            return NO_OBJECTS;\n                        }\n                        return new ArrayList<Object>(2);\n                    }\n                }\n                if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                    return mapArrayToArray(p, ctxt);\n                }\n                return mapArray(p, ctxt);\n            case JsonTokenId.ID_EMBEDDED_OBJECT:\n                return p.getEmbeddedObject();\n            case JsonTokenId.ID_STRING:\n                return p.getText();\n\n            case JsonTokenId.ID_NUMBER_INT:\n                if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                    return _coerceIntegral(p, ctxt);\n                }\n                return p.getNumberValue(); \n\n            case JsonTokenId.ID_NUMBER_FLOAT:\n                if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                    return p.getDecimalValue();\n                }\n                return Double.valueOf(p.getDoubleValue());\n\n            case JsonTokenId.ID_TRUE:\n                return Boolean.TRUE;\n            case JsonTokenId.ID_FALSE:\n                return Boolean.FALSE;\n\n            case JsonTokenId.ID_NULL: \n                return null;\n\n            case JsonTokenId.ID_END_OBJECT:\n                \n                \n                return new LinkedHashMap<String,Object>(2);\n\n            \n            default:\n                throw ctxt.mappingException(Object.class);\n            }\n        }\n\n        @Override\n        public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException {\n            switch (jp.getCurrentTokenId()) {\n            case JsonTokenId.ID_START_ARRAY:\n            case JsonTokenId.ID_START_OBJECT:\n            case JsonTokenId.ID_FIELD_NAME:\n                return typeDeserializer.deserializeTypedFromAny(jp, ctxt);\n\n            case JsonTokenId.ID_STRING:\n                return jp.getText();\n\n            case JsonTokenId.ID_NUMBER_INT:\n                if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) {\n                    return jp.getBigIntegerValue();\n                }\n                return jp.getNumberValue();\n\n            case JsonTokenId.ID_NUMBER_FLOAT:\n                if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                    return jp.getDecimalValue();\n                }\n                return Double.valueOf(jp.getDoubleValue());\n\n            case JsonTokenId.ID_TRUE:\n                return Boolean.TRUE;\n            case JsonTokenId.ID_FALSE:\n                return Boolean.FALSE;\n            case JsonTokenId.ID_EMBEDDED_OBJECT:\n                return jp.getEmbeddedObject();\n\n            case JsonTokenId.ID_NULL: \n                return null;\n            default:\n                throw ctxt.mappingException(Object.class);\n            }\n        }\n\n        protected Object mapArray(JsonParser jp, DeserializationContext ctxt) throws IOException {\n            Object value = deserialize(jp, ctxt);\n            if (jp.nextToken()  == JsonToken.END_ARRAY) {\n                ArrayList<Object> l = new ArrayList<Object>(2);\n                l.add(value);\n                return l;\n            }\n            Object value2 = deserialize(jp, ctxt);\n            if (jp.nextToken()  == JsonToken.END_ARRAY) {\n                ArrayList<Object> l = new ArrayList<Object>(2);\n                l.add(value);\n                l.add(value2);\n                return l;\n            }\n            ObjectBuffer buffer = ctxt.leaseObjectBuffer();\n            Object[] values = buffer.resetAndStart();\n            int ptr = 0;\n            values[ptr++] = value;\n            values[ptr++] = value2;\n            int totalSize = ptr;\n            do {\n                value = deserialize(jp, ctxt);\n                ++totalSize;\n                if (ptr >= values.length) {\n                    values = buffer.appendCompletedChunk(values);\n                    ptr = 0;\n                }\n                values[ptr++] = value;\n            } while (jp.nextToken() != JsonToken.END_ARRAY);\n            \n            ArrayList<Object> result = new ArrayList<Object>(totalSize);\n            buffer.completeAndClearBuffer(values, ptr, result);\n            return result;\n        }\n\n        \n        protected Object mapObject(JsonParser p, DeserializationContext ctxt) throws IOException {\n            \n            String key1 = p.getText();\n            p.nextToken();\n            Object value1 = deserialize(p, ctxt);\n\n            String key2 = p.nextFieldName();\n            if (key2 == null) { \n                LinkedHashMap<String, Object> result = new LinkedHashMap<String, Object>(2);\n                result.put(key1, value1);\n                return result;\n            }\n            p.nextToken();\n            Object value2 = deserialize(p, ctxt);\n\n            String key = p.nextFieldName();\n            if (key == null) {\n                LinkedHashMap<String, Object> result = new LinkedHashMap<String, Object>(4);\n                result.put(key1, value1);\n                result.put(key2, value2);\n                return result;\n            }\n            \n            LinkedHashMap<String, Object> result = new LinkedHashMap<String, Object>();\n            result.put(key1, value1);\n            result.put(key2, value2);\n            do {\n                p.nextToken();\n                result.put(key, deserialize(p, ctxt));\n            } while ((key = p.nextFieldName()) != null);\n            return result;\n        }\n\n        \n        protected Object[] mapArrayToArray(JsonParser jp, DeserializationContext ctxt) throws IOException {\n            ObjectBuffer buffer = ctxt.leaseObjectBuffer();\n            Object[] values = buffer.resetAndStart();\n            int ptr = 0;\n            do {\n                Object value = deserialize(jp, ctxt);\n                if (ptr >= values.length) {\n                    values = buffer.appendCompletedChunk(values);\n                    ptr = 0;\n                }\n                values[ptr++] = value;\n            } while (jp.nextToken() != JsonToken.END_ARRAY);\n            return buffer.completeAndClearBuffer(values, ptr);\n        }\n    }\n}\n",
      "buggy_signatures": [
        "public UntypedObjectDeserializer(JavaType listType, JavaType mapType)",
        "public UntypedObjectDeserializer(UntypedObjectDeserializer base, JsonDeserializer<?> mapDeser, JsonDeserializer<?> listDeser, JsonDeserializer<?> stringDeser, JsonDeserializer<?> numberDeser)",
        "public void resolve(DeserializationContext ctxt) throws JsonMappingException",
        "protected JsonDeserializer<Object> _findCustomDeser(DeserializationContext ctxt, JavaType type) throws JsonMappingException",
        "protected JsonDeserializer<Object> _clearIfStdImpl(JsonDeserializer<Object> deser)",
        "public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException",
        "protected JsonDeserializer<?> _withResolved(JsonDeserializer<?> mapDeser, JsonDeserializer<?> listDeser, JsonDeserializer<?> stringDeser, JsonDeserializer<?> numberDeser)",
        "public boolean isCachable()",
        "public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException",
        "public Object deserializeWithType(JsonParser p, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException",
        "protected Object mapArray(JsonParser jp, DeserializationContext ctxt) throws IOException",
        "protected Object mapObject(JsonParser p, DeserializationContext ctxt) throws IOException",
        "protected Object[] mapArrayToArray(JsonParser jp, DeserializationContext ctxt) throws IOException",
        "public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException",
        "public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException",
        "protected Object mapArray(JsonParser jp, DeserializationContext ctxt) throws IOException",
        "protected Object mapObject(JsonParser p, DeserializationContext ctxt) throws IOException",
        "protected Object[] mapArrayToArray(JsonParser jp, DeserializationContext ctxt) throws IOException"
      ],
      "fixed_signatures": [
        "public UntypedObjectDeserializer(JavaType listType, JavaType mapType)",
        "public UntypedObjectDeserializer(UntypedObjectDeserializer base, JsonDeserializer<?> mapDeser, JsonDeserializer<?> listDeser, JsonDeserializer<?> stringDeser, JsonDeserializer<?> numberDeser)",
        "public void resolve(DeserializationContext ctxt) throws JsonMappingException",
        "protected JsonDeserializer<Object> _findCustomDeser(DeserializationContext ctxt, JavaType type) throws JsonMappingException",
        "protected JsonDeserializer<Object> _clearIfStdImpl(JsonDeserializer<Object> deser)",
        "public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException",
        "protected JsonDeserializer<?> _withResolved(JsonDeserializer<?> mapDeser, JsonDeserializer<?> listDeser, JsonDeserializer<?> stringDeser, JsonDeserializer<?> numberDeser)",
        "public boolean isCachable()",
        "public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException",
        "public Object deserializeWithType(JsonParser p, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException",
        "protected Object mapArray(JsonParser jp, DeserializationContext ctxt) throws IOException",
        "protected Object mapObject(JsonParser p, DeserializationContext ctxt) throws IOException",
        "protected Object[] mapArrayToArray(JsonParser jp, DeserializationContext ctxt) throws IOException",
        "public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException",
        "public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException",
        "protected Object mapArray(JsonParser jp, DeserializationContext ctxt) throws IOException",
        "protected Object mapObject(JsonParser p, DeserializationContext ctxt) throws IOException",
        "protected Object[] mapArrayToArray(JsonParser jp, DeserializationContext ctxt) throws IOException"
      ],
      "methods": [
        {
          "buggy_method": "  public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n  switch (p.getCurrentTokenId()) {\n  case JsonTokenId.ID_START_OBJECT:\n  case JsonTokenId.ID_FIELD_NAME:\n  \n  \n  if (_mapDeserializer != null) {\n  return _mapDeserializer.deserialize(p, ctxt);\n  }\n  return mapObject(p, ctxt);\n  case JsonTokenId.ID_START_ARRAY:\n  if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n  return mapArrayToArray(p, ctxt);\n  }\n  if (_listDeserializer != null) {\n  return _listDeserializer.deserialize(p, ctxt);\n  }\n  return mapArray(p, ctxt);\n  case JsonTokenId.ID_EMBEDDED_OBJECT:\n  return p.getEmbeddedObject();\n  case JsonTokenId.ID_STRING:\n  if (_stringDeserializer != null) {\n  return _stringDeserializer.deserialize(p, ctxt);\n  }\n  return p.getText();\n\n  case JsonTokenId.ID_NUMBER_INT:\n  if (_numberDeserializer != null) {\n  return _numberDeserializer.deserialize(p, ctxt);\n  }\n  \n  if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n  return _coerceIntegral(p, ctxt);\n  }\n  return p.getNumberValue(); \n\n  case JsonTokenId.ID_NUMBER_FLOAT:\n  if (_numberDeserializer != null) {\n  return _numberDeserializer.deserialize(p, ctxt);\n  }\n  \n  if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n  return p.getDecimalValue();\n  }\n  return p.getDoubleValue();\n\n  case JsonTokenId.ID_TRUE:\n  return Boolean.TRUE;\n  case JsonTokenId.ID_FALSE:\n  return Boolean.FALSE;\n\n  case JsonTokenId.ID_NULL: \n  return null;\n\n\n  default:\n  }\n  throw ctxt.mappingException(Object.class);\n  }",
          "fixed_method": "  public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n  switch (p.getCurrentTokenId()) {\n  case JsonTokenId.ID_START_OBJECT:\n  case JsonTokenId.ID_FIELD_NAME:\n  \n  \n  case JsonTokenId.ID_END_OBJECT:\n  if (_mapDeserializer != null) {\n  return _mapDeserializer.deserialize(p, ctxt);\n  }\n  return mapObject(p, ctxt);\n  case JsonTokenId.ID_START_ARRAY:\n  if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n  return mapArrayToArray(p, ctxt);\n  }\n  if (_listDeserializer != null) {\n  return _listDeserializer.deserialize(p, ctxt);\n  }\n  return mapArray(p, ctxt);\n  case JsonTokenId.ID_EMBEDDED_OBJECT:\n  return p.getEmbeddedObject();\n  case JsonTokenId.ID_STRING:\n  if (_stringDeserializer != null) {\n  return _stringDeserializer.deserialize(p, ctxt);\n  }\n  return p.getText();\n\n  case JsonTokenId.ID_NUMBER_INT:\n  if (_numberDeserializer != null) {\n  return _numberDeserializer.deserialize(p, ctxt);\n  }\n  \n  if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n  return _coerceIntegral(p, ctxt);\n  }\n  return p.getNumberValue(); \n\n  case JsonTokenId.ID_NUMBER_FLOAT:\n  if (_numberDeserializer != null) {\n  return _numberDeserializer.deserialize(p, ctxt);\n  }\n  \n  if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n  return p.getDecimalValue();\n  }\n  return p.getDoubleValue();\n\n  case JsonTokenId.ID_TRUE:\n  return Boolean.TRUE;\n  case JsonTokenId.ID_FALSE:\n  return Boolean.FALSE;\n\n  case JsonTokenId.ID_NULL: \n  return null;\n\n\n  default:\n  }\n  throw ctxt.mappingException(Object.class);\n  }",
          "diff": [
            "@@ -218,6 +218,7 @@",
            "         case JsonTokenId.ID_FIELD_NAME:\n",
            "             // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n",
            "             //    if caller has advanced to the first token of Object, but for empty Object\n",
            "+        case JsonTokenId.ID_END_OBJECT:\n",
            "             if (_mapDeserializer != null) {\n",
            "                 return _mapDeserializer.deserialize(p, ctxt);\n",
            "             }\n",
            "@@ -532,8 +533,10 @@",
            "             case JsonTokenId.ID_NULL: // should not get this but...\n",
            "                 return null;\n",
            " \n",
            "+            case JsonTokenId.ID_END_OBJECT:\n",
            "                 // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n",
            "                 //    if caller has advanced to the first token of Object, but for empty Object\n",
            "+                return new LinkedHashMap<String,Object>(2);\n",
            " \n",
            "             //case JsonTokenId.ID_END_ARRAY: // invalid\n",
            "             default:\n"
          ],
          "changed_lines": 3
        }
      ]
    }
  ]
}
