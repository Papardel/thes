{
  "bug_id": "62",
  "failed_tests": {
    "org.apache.commons.math.optimization.univariate.MultiStartUnivariateRealOptimizerTest": [
      {
        "methodName": "testQuinticMin",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<-0.2719561293> but was:<-0.2719561278056452>",
        "fail_line": "        assertEquals(-0.2719561293, optimum.getPoint(), 1e-9);",
        "test_source": "  public void testQuinticMin() throws MathException {\n  // The quintic function has zeros at 0, +-0.5 and +-1.\n  // The function has extrema (first derivative is zero) at 0.27195613 and 0.82221643,\n  UnivariateRealFunction f = new QuinticFunction();\n  UnivariateRealOptimizer underlying = new BrentOptimizer(1e-9, 1e-14);\n  underlying.setMaxEvaluations(300);\n  JDKRandomGenerator g = new JDKRandomGenerator();\n  g.setSeed(4312000053L);\n  MultiStartUnivariateRealOptimizer optimizer =\n  new MultiStartUnivariateRealOptimizer(underlying, 5, g);\n\n  UnivariateRealPointValuePair optimum\n  = optimizer.optimize(f, GoalType.MINIMIZE, -0.3, -0.2);\n  assertEquals(-0.2719561293, optimum.getPoint(), 1e-9);\n  assertEquals(-0.0443342695, optimum.getValue(), 1e-9);\n\n  UnivariateRealPointValuePair[] optima = optimizer.getOptima();\n  for (int i = 0; i < optima.length; ++i) {\n  assertEquals(f.value(optima[i].getPoint()), optima[i].getValue(), 1e-9);\n  }\n  assertTrue(optimizer.getEvaluations() >= 50);\n  assertTrue(optimizer.getEvaluations() <= 100);\n  }",
        "stack": [
          "MultiStartUnivariateRealOptimizerTest.testQuinticMin line 71"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/math/optimization/univariate/MultiStartUnivariateRealOptimizer.java",
      "buggy_full_code": "\n\npackage org.apache.commons.math.optimization.univariate;\n\nimport java.util.Arrays;\nimport java.util.Comparator;\n\nimport org.apache.commons.math.FunctionEvaluationException;\nimport org.apache.commons.math.analysis.UnivariateRealFunction;\nimport org.apache.commons.math.exception.MathIllegalStateException;\nimport org.apache.commons.math.exception.ConvergenceException;\nimport org.apache.commons.math.exception.util.LocalizedFormats;\nimport org.apache.commons.math.random.RandomGenerator;\nimport org.apache.commons.math.optimization.GoalType;\nimport org.apache.commons.math.optimization.ConvergenceChecker;\nimport org.apache.commons.math.util.FastMath;\n\n\npublic class MultiStartUnivariateRealOptimizer<FUNC extends UnivariateRealFunction> implements BaseUnivariateRealOptimizer<FUNC> { private final BaseUnivariateRealOptimizer<FUNC> optimizer; private int maxEvaluations; private int totalEvaluations; private int starts; private RandomGenerator generator; private UnivariateRealPointValuePair[] optima; public MultiStartUnivariateRealOptimizer(final BaseUnivariateRealOptimizer<FUNC> optimizer, final int starts, final RandomGenerator generator) {\n        this.optimizer = optimizer;\n        this.starts = starts;\n        this.generator = generator;\n    }\n\n    \n    public void setConvergenceChecker(ConvergenceChecker<UnivariateRealPointValuePair> checker) {\n        optimizer.setConvergenceChecker(checker);\n    }\n\n    \n    public ConvergenceChecker<UnivariateRealPointValuePair> getConvergenceChecker() {\n        return optimizer.getConvergenceChecker();\n    }\n\n    \n    public int getMaxEvaluations() {\n        return maxEvaluations;\n    }\n\n    \n    public int getEvaluations() {\n        return totalEvaluations;\n    }\n\n    \n    public void setMaxEvaluations(int maxEvaluations) {\n        this.maxEvaluations = maxEvaluations;\n        optimizer.setMaxEvaluations(maxEvaluations);\n    }\n\n    \n    public UnivariateRealPointValuePair[] getOptima() {\n        if (optima == null) {\n            throw new MathIllegalStateException(LocalizedFormats.NO_OPTIMUM_COMPUTED_YET);\n        }\n        return optima.clone();\n    }\n\n    \n    public UnivariateRealPointValuePair optimize(final FUNC f, final GoalType goal, final double min, final double max) throws FunctionEvaluationException {\n        return optimize(f, goal, min, max, 0);\n    }\n\n    \n    public UnivariateRealPointValuePair optimize(final FUNC f, final GoalType goal, final double min, final double max, final double startValue) throws FunctionEvaluationException {\n        optima = new UnivariateRealPointValuePair[starts];\n        totalEvaluations = 0;\n\n        \n        for (int i = 0; i < starts; ++i) {\n            try {\n                final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);\n                final double bound2 = (i == 0) ? max : min + generator.nextDouble() * (max - min);\n                optima[i] = optimizer.optimize(f, goal, FastMath.min(bound1, bound2), FastMath.max(bound1, bound2));\n            } catch (FunctionEvaluationException fee) {\n                optima[i] = null;\n            } catch (ConvergenceException ce) {\n                optima[i] = null;\n            }\n\n            final int usedEvaluations = optimizer.getEvaluations();\n            optimizer.setMaxEvaluations(optimizer.getMaxEvaluations() - usedEvaluations);\n            totalEvaluations += usedEvaluations;\n        }\n\n        sortPairs(goal);\n\n        if (optima[0] == null) {\n            throw new ConvergenceException(LocalizedFormats.NO_CONVERGENCE_WITH_ANY_START_POINT,\n                                           starts);\n        }\n\n        \n        return optima[0];\n    }\n\n    \n    private void sortPairs(final GoalType goal) {\n        Arrays.sort(optima, new Comparator<UnivariateRealPointValuePair>() {\n                public int compare(final UnivariateRealPointValuePair o1, final UnivariateRealPointValuePair o2) {\n                    if (o1 == null) {\n                        return (o2 == null) ? 0 : 1;\n                    } else if (o2 == null) {\n                        return -1;\n                    }\n                    final double v1 = o1.getValue();\n                    final double v2 = o2.getValue();\n                    return (goal == GoalType.MINIMIZE) ?\n                        Double.compare(v1, v2) : Double.compare(v2, v1);\n                }\n            });\n    }\n}\n",
      "fixed_full_code": "\n\npackage org.apache.commons.math.optimization.univariate;\n\nimport java.util.Arrays;\nimport java.util.Comparator;\n\nimport org.apache.commons.math.FunctionEvaluationException;\nimport org.apache.commons.math.analysis.UnivariateRealFunction;\nimport org.apache.commons.math.exception.MathIllegalStateException;\nimport org.apache.commons.math.exception.ConvergenceException;\nimport org.apache.commons.math.exception.util.LocalizedFormats;\nimport org.apache.commons.math.random.RandomGenerator;\nimport org.apache.commons.math.optimization.GoalType;\nimport org.apache.commons.math.optimization.ConvergenceChecker;\nimport org.apache.commons.math.util.FastMath;\n\n\npublic class MultiStartUnivariateRealOptimizer<FUNC extends UnivariateRealFunction> implements BaseUnivariateRealOptimizer<FUNC> { private final BaseUnivariateRealOptimizer<FUNC> optimizer; private int maxEvaluations; private int totalEvaluations; private int starts; private RandomGenerator generator; private UnivariateRealPointValuePair[] optima; public MultiStartUnivariateRealOptimizer(final BaseUnivariateRealOptimizer<FUNC> optimizer, final int starts, final RandomGenerator generator) {\n        this.optimizer = optimizer;\n        this.starts = starts;\n        this.generator = generator;\n    }\n\n    \n    public void setConvergenceChecker(ConvergenceChecker<UnivariateRealPointValuePair> checker) {\n        optimizer.setConvergenceChecker(checker);\n    }\n\n    \n    public ConvergenceChecker<UnivariateRealPointValuePair> getConvergenceChecker() {\n        return optimizer.getConvergenceChecker();\n    }\n\n    \n    public int getMaxEvaluations() {\n        return maxEvaluations;\n    }\n\n    \n    public int getEvaluations() {\n        return totalEvaluations;\n    }\n\n    \n    public void setMaxEvaluations(int maxEvaluations) {\n        this.maxEvaluations = maxEvaluations;\n        optimizer.setMaxEvaluations(maxEvaluations);\n    }\n\n    \n    public UnivariateRealPointValuePair[] getOptima() {\n        if (optima == null) {\n            throw new MathIllegalStateException(LocalizedFormats.NO_OPTIMUM_COMPUTED_YET);\n        }\n        return optima.clone();\n    }\n\n    \n    public UnivariateRealPointValuePair optimize(final FUNC f, final GoalType goal, final double min, final double max) throws FunctionEvaluationException {\n        return optimize(f, goal, min, max, min + 0.5 * (max - min));\n    }\n\n    \n    public UnivariateRealPointValuePair optimize(final FUNC f, final GoalType goal, final double min, final double max, final double startValue) throws FunctionEvaluationException {\n        optima = new UnivariateRealPointValuePair[starts];\n        totalEvaluations = 0;\n\n        \n        for (int i = 0; i < starts; ++i) {\n            try {\n                final double s = (i == 0) ? startValue : min + generator.nextDouble() * (max - min);\n                optima[i] = optimizer.optimize(f, goal, min, max, s);\n            } catch (FunctionEvaluationException fee) {\n                optima[i] = null;\n            } catch (ConvergenceException ce) {\n                optima[i] = null;\n            }\n\n            final int usedEvaluations = optimizer.getEvaluations();\n            optimizer.setMaxEvaluations(optimizer.getMaxEvaluations() - usedEvaluations);\n            totalEvaluations += usedEvaluations;\n        }\n\n        sortPairs(goal);\n\n        if (optima[0] == null) {\n            throw new ConvergenceException(LocalizedFormats.NO_CONVERGENCE_WITH_ANY_START_POINT,\n                                           starts);\n        }\n\n        \n        return optima[0];\n    }\n\n    \n    private void sortPairs(final GoalType goal) {\n        Arrays.sort(optima, new Comparator<UnivariateRealPointValuePair>() {\n                public int compare(final UnivariateRealPointValuePair o1, final UnivariateRealPointValuePair o2) {\n                    if (o1 == null) {\n                        return (o2 == null) ? 0 : 1;\n                    } else if (o2 == null) {\n                        return -1;\n                    }\n                    final double v1 = o1.getValue();\n                    final double v2 = o2.getValue();\n                    return (goal == GoalType.MINIMIZE) ?\n                        Double.compare(v1, v2) : Double.compare(v2, v1);\n                }\n            });\n    }\n}\n",
      "buggy_signatures": [
        "public class MultiStartUnivariateRealOptimizer<FUNC extends UnivariateRealFunction> implements BaseUnivariateRealOptimizer<FUNC> { private final BaseUnivariateRealOptimizer<FUNC> optimizer; private int maxEvaluations; private int totalEvaluations; private int starts; private RandomGenerator generator; private UnivariateRealPointValuePair[] optima; public MultiStartUnivariateRealOptimizer(final BaseUnivariateRealOptimizer<FUNC> optimizer, final int starts, final RandomGenerator generator)",
        "public void setConvergenceChecker(ConvergenceChecker<UnivariateRealPointValuePair> checker)",
        "public ConvergenceChecker<UnivariateRealPointValuePair> getConvergenceChecker()",
        "public int getMaxEvaluations()",
        "public int getEvaluations()",
        "public void setMaxEvaluations(int maxEvaluations)",
        "public UnivariateRealPointValuePair[] getOptima()",
        "public UnivariateRealPointValuePair optimize(final FUNC f, final GoalType goal, final double min, final double max) throws FunctionEvaluationException",
        "public UnivariateRealPointValuePair optimize(final FUNC f, final GoalType goal, final double min, final double max, final double startValue) throws FunctionEvaluationException",
        "private void sortPairs(final GoalType goal)",
        "public int compare(final UnivariateRealPointValuePair o1, final UnivariateRealPointValuePair o2)"
      ],
      "fixed_signatures": [
        "public class MultiStartUnivariateRealOptimizer<FUNC extends UnivariateRealFunction> implements BaseUnivariateRealOptimizer<FUNC> { private final BaseUnivariateRealOptimizer<FUNC> optimizer; private int maxEvaluations; private int totalEvaluations; private int starts; private RandomGenerator generator; private UnivariateRealPointValuePair[] optima; public MultiStartUnivariateRealOptimizer(final BaseUnivariateRealOptimizer<FUNC> optimizer, final int starts, final RandomGenerator generator)",
        "public void setConvergenceChecker(ConvergenceChecker<UnivariateRealPointValuePair> checker)",
        "public ConvergenceChecker<UnivariateRealPointValuePair> getConvergenceChecker()",
        "public int getMaxEvaluations()",
        "public int getEvaluations()",
        "public void setMaxEvaluations(int maxEvaluations)",
        "public UnivariateRealPointValuePair[] getOptima()",
        "public UnivariateRealPointValuePair optimize(final FUNC f, final GoalType goal, final double min, final double max) throws FunctionEvaluationException",
        "public UnivariateRealPointValuePair optimize(final FUNC f, final GoalType goal, final double min, final double max, final double startValue) throws FunctionEvaluationException",
        "private void sortPairs(final GoalType goal)",
        "public int compare(final UnivariateRealPointValuePair o1, final UnivariateRealPointValuePair o2)"
      ],
      "methods": [
        {
          "buggy_method": "  public UnivariateRealPointValuePair optimize(final FUNC f, final GoalType goal, final double min, final double max) throws FunctionEvaluationException {\n  return optimize(f, goal, min, max, 0);\n  }",
          "fixed_method": "  public UnivariateRealPointValuePair optimize(final FUNC f, final GoalType goal, final double min, final double max) throws FunctionEvaluationException {\n  return optimize(f, goal, min, max, min + 0.5 * (max - min));\n  }",
          "diff": [
            "@@ -143,7 +143,7 @@",
            "                                                  final GoalType goal,\n",
            "                                                  final double min, final double max)\n",
            "         throws FunctionEvaluationException {\n",
            "-        return optimize(f, goal, min, max, 0);\n",
            "+        return optimize(f, goal, min, max, min + 0.5 * (max - min));\n",
            "     }\n",
            " \n",
            "     /** {@inheritDoc} */\n"
          ],
          "changed_lines": 2
        },
        {
          "buggy_method": "  public UnivariateRealPointValuePair optimize(final FUNC f, final GoalType goal, final double min, final double max, final double startValue) throws FunctionEvaluationException {\n  optima = new UnivariateRealPointValuePair[starts];\n  totalEvaluations = 0;\n\n  \n  for (int i = 0; i < starts; ++i) {\n  try {\n  final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);\n  final double bound2 = (i == 0) ? max : min + generator.nextDouble() * (max - min);\n  optima[i] = optimizer.optimize(f, goal, FastMath.min(bound1, bound2), FastMath.max(bound1, bound2));\n  } catch (FunctionEvaluationException fee) {\n  optima[i] = null;\n  } catch (ConvergenceException ce) {\n  optima[i] = null;\n  }\n\n  final int usedEvaluations = optimizer.getEvaluations();\n  optimizer.setMaxEvaluations(optimizer.getMaxEvaluations() - usedEvaluations);\n  totalEvaluations += usedEvaluations;\n  }\n\n  sortPairs(goal);\n\n  if (optima[0] == null) {\n  throw new ConvergenceException(LocalizedFormats.NO_CONVERGENCE_WITH_ANY_START_POINT,\n  starts);\n  }\n\n  \n  return optima[0];\n  }",
          "fixed_method": "  public UnivariateRealPointValuePair optimize(final FUNC f, final GoalType goal, final double min, final double max, final double startValue) throws FunctionEvaluationException {\n  optima = new UnivariateRealPointValuePair[starts];\n  totalEvaluations = 0;\n\n  \n  for (int i = 0; i < starts; ++i) {\n  try {\n  final double s = (i == 0) ? startValue : min + generator.nextDouble() * (max - min);\n  optima[i] = optimizer.optimize(f, goal, min, max, s);\n  } catch (FunctionEvaluationException fee) {\n  optima[i] = null;\n  } catch (ConvergenceException ce) {\n  optima[i] = null;\n  }\n\n  final int usedEvaluations = optimizer.getEvaluations();\n  optimizer.setMaxEvaluations(optimizer.getMaxEvaluations() - usedEvaluations);\n  totalEvaluations += usedEvaluations;\n  }\n\n  sortPairs(goal);\n\n  if (optima[0] == null) {\n  throw new ConvergenceException(LocalizedFormats.NO_CONVERGENCE_WITH_ANY_START_POINT,\n  starts);\n  }\n\n  \n  return optima[0];\n  }",
          "diff": [
            "@@ -157,9 +157,8 @@",
            "         // Multi-start loop.\n",
            "         for (int i = 0; i < starts; ++i) {\n",
            "             try {\n",
            "-                final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);\n",
            "-                final double bound2 = (i == 0) ? max : min + generator.nextDouble() * (max - min);\n",
            "-                optima[i] = optimizer.optimize(f, goal, FastMath.min(bound1, bound2), FastMath.max(bound1, bound2));\n",
            "+                final double s = (i == 0) ? startValue : min + generator.nextDouble() * (max - min);\n",
            "+                optima[i] = optimizer.optimize(f, goal, min, max, s);\n",
            "             } catch (FunctionEvaluationException fee) {\n",
            "                 optima[i] = null;\n",
            "             } catch (ConvergenceException ce) {\n"
          ],
          "changed_lines": 5
        }
      ]
    }
  ]
}
