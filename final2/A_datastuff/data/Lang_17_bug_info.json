{
  "bug_id": "17",
  "failed_tests": {
    "org.apache.commons.lang3.StringEscapeUtilsTest": [
      {
        "methodName": "testLang720",
        "error": "junit.framework.ComparisonFailure",
        "message": "expected:<𠮷[A]> but was:<𠮷[?]>",
        "fail_line": "        assertEquals(input, escaped);",
        "test_source": "  public void testLang720() {\n  String input = new StringBuilder(\"\\ud842\\udfb7\").append(\"A\").toString();\n  String escaped = StringEscapeUtils.escapeXml(input);\n  assertEquals(input, escaped);\n  }",
        "stack": [
          "StringEscapeUtilsTest.testLang720 line 431"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/lang3/text/translate/CharSequenceTranslator.java",
      "buggy_full_code": "\npackage org.apache.commons.lang3.text.translate;\n\nimport java.io.IOException;\nimport java.io.StringWriter;\nimport java.io.Writer;\nimport java.util.Locale;\n\n\npublic abstract class CharSequenceTranslator { public abstract int translate(CharSequence input, int index, Writer out) throws IOException; public final String translate(CharSequence input) {\n        if (input == null) {\n            return null;\n        }\n        try {\n            StringWriter writer = new StringWriter(input.length() * 2);\n            translate(input, writer);\n            return writer.toString();\n        } catch (IOException ioe) {\n            \n            throw new RuntimeException(ioe);\n        }\n    }\n\n    \n    public final void translate(CharSequence input, Writer out) throws IOException {\n        if (out == null) {\n            throw new IllegalArgumentException(\"The Writer must not be null\");\n        }\n        if (input == null) {\n            return;\n        }\n        int pos = 0;\n        int len = Character.codePointCount(input, 0, input.length());\n        while (pos < len) {\n            int consumed = translate(input, pos, out);\n            if (consumed == 0) {\n                char[] c = Character.toChars(Character.codePointAt(input, pos));\n                out.write(c);\n            }\n            else {\n\n\n            for (int pt = 0; pt < consumed; pt++) {\n                    if (pos < len - 2) {\n                pos += Character.charCount(Character.codePointAt(input, pos));\n                    } else {\n                        pos++;\n                    }\n                }\n                pos--;\n            }\n            pos++;\n        }\n    }\n\n    \n    public final CharSequenceTranslator with(CharSequenceTranslator... translators) {\n        CharSequenceTranslator[] newArray = new CharSequenceTranslator[translators.length + 1];\n        newArray[0] = this;\n        System.arraycopy(translators, 0, newArray, 1, translators.length);\n        return new AggregateTranslator(newArray);\n    }\n\n    \n    public static String hex(int codepoint) {\n        return Integer.toHexString(codepoint).toUpperCase(Locale.ENGLISH);\n    }\n\n}\n",
      "fixed_full_code": "\npackage org.apache.commons.lang3.text.translate;\n\nimport java.io.IOException;\nimport java.io.StringWriter;\nimport java.io.Writer;\nimport java.util.Locale;\n\n\npublic abstract class CharSequenceTranslator { public abstract int translate(CharSequence input, int index, Writer out) throws IOException; public final String translate(CharSequence input) {\n        if (input == null) {\n            return null;\n        }\n        try {\n            StringWriter writer = new StringWriter(input.length() * 2);\n            translate(input, writer);\n            return writer.toString();\n        } catch (IOException ioe) {\n            \n            throw new RuntimeException(ioe);\n        }\n    }\n\n    \n    public final void translate(CharSequence input, Writer out) throws IOException {\n        if (out == null) {\n            throw new IllegalArgumentException(\"The Writer must not be null\");\n        }\n        if (input == null) {\n            return;\n        }\n        int pos = 0;\n        int len = input.length();\n        while (pos < len) {\n            int consumed = translate(input, pos, out);\n            if (consumed == 0) {\n                char[] c = Character.toChars(Character.codePointAt(input, pos));\n                out.write(c);\n                pos+= c.length;\n                continue;\n            }\n\n\n            for (int pt = 0; pt < consumed; pt++) {\n                pos += Character.charCount(Character.codePointAt(input, pos));\n            }\n        }\n    }\n\n    \n    public final CharSequenceTranslator with(CharSequenceTranslator... translators) {\n        CharSequenceTranslator[] newArray = new CharSequenceTranslator[translators.length + 1];\n        newArray[0] = this;\n        System.arraycopy(translators, 0, newArray, 1, translators.length);\n        return new AggregateTranslator(newArray);\n    }\n\n    \n    public static String hex(int codepoint) {\n        return Integer.toHexString(codepoint).toUpperCase(Locale.ENGLISH);\n    }\n\n}\n",
      "buggy_signatures": [
        "public abstract class CharSequenceTranslator { public abstract int translate(CharSequence input, int index, Writer out) throws IOException; public final String translate(CharSequence input)",
        "public final void translate(CharSequence input, Writer out) throws IOException",
        "public final CharSequenceTranslator with(CharSequenceTranslator... translators)",
        "public static String hex(int codepoint)"
      ],
      "fixed_signatures": [
        "public abstract class CharSequenceTranslator { public abstract int translate(CharSequence input, int index, Writer out) throws IOException; public final String translate(CharSequence input)",
        "public final void translate(CharSequence input, Writer out) throws IOException",
        "public final CharSequenceTranslator with(CharSequenceTranslator... translators)",
        "public static String hex(int codepoint)"
      ],
      "methods": [
        {
          "buggy_method": "  public final void translate(CharSequence input, Writer out) throws IOException {\n  if (out == null) {\n  throw new IllegalArgumentException(\"The Writer must not be null\");\n  }\n  if (input == null) {\n  return;\n  }\n  int pos = 0;\n  int len = Character.codePointCount(input, 0, input.length());\n  while (pos < len) {\n  int consumed = translate(input, pos, out);\n  if (consumed == 0) {\n  char[] c = Character.toChars(Character.codePointAt(input, pos));\n  out.write(c);\n  }\n  else {\n\n\n  for (int pt = 0; pt < consumed; pt++) {\n  if (pos < len - 2) {\n  pos += Character.charCount(Character.codePointAt(input, pos));\n  } else {\n  pos++;\n  }\n  }\n  pos--;\n  }\n  pos++;\n  }\n  }",
          "fixed_method": "  public final void translate(CharSequence input, Writer out) throws IOException {\n  if (out == null) {\n  throw new IllegalArgumentException(\"The Writer must not be null\");\n  }\n  if (input == null) {\n  return;\n  }\n  int pos = 0;\n  int len = input.length();\n  while (pos < len) {\n  int consumed = translate(input, pos, out);\n  if (consumed == 0) {\n  char[] c = Character.toChars(Character.codePointAt(input, pos));\n  out.write(c);\n  pos+= c.length;\n  continue;\n  }\n\n\n  for (int pt = 0; pt < consumed; pt++) {\n  pos += Character.charCount(Character.codePointAt(input, pos));\n  }\n  }\n  }",
          "diff": [
            "@@ -80,26 +80,20 @@",
            "             return;\n",
            "         }\n",
            "         int pos = 0;\n",
            "-        int len = Character.codePointCount(input, 0, input.length());\n",
            "+        int len = input.length();\n",
            "         while (pos < len) {\n",
            "             int consumed = translate(input, pos, out);\n",
            "             if (consumed == 0) {\n",
            "                 char[] c = Character.toChars(Character.codePointAt(input, pos));\n",
            "                 out.write(c);\n",
            "+                pos+= c.length;\n",
            "+                continue;\n",
            "             }\n",
            "-            else {\n",
            " //          // contract with translators is that they have to understand codepoints \n",
            " //          // and they just took care of a surrogate pair\n",
            "             for (int pt = 0; pt < consumed; pt++) {\n",
            "-                    if (pos < len - 2) {\n",
            "                 pos += Character.charCount(Character.codePointAt(input, pos));\n",
            "-                    } else {\n",
            "-                        pos++;\n",
            "-                    }\n",
            "-                }\n",
            "-                pos--;\n",
            "             }\n",
            "-            pos++;\n",
            "         }\n",
            "     }\n",
            " \n"
          ],
          "changed_lines": 12
        }
      ]
    }
  ]
}
