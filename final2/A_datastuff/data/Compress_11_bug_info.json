{
  "bug_id": "11",
  "failed_tests": {
    "org.apache.commons.compress.archivers.ArchiveStreamFactoryTest": [
      {
        "methodName": "shortTextFilesAreNoTARs",
        "error": "junit.framework.AssertionFailedError",
        "message": "created an input stream for a non-archive",
        "fail_line": "            fail(\"created an input stream for a non-archive\");",
        "test_source": "  public void shortTextFilesAreNoTARs() throws Exception {\n  try {\n  new ArchiveStreamFactory()\n  .createArchiveInputStream(new ByteArrayInputStream(\"This certainly is not a tar archive, really, no kidding\".getBytes()));\n  fail(\"created an input stream for a non-archive\");\n  } catch (ArchiveException ae) {\n  assertTrue(ae.getMessage().startsWith(\"No Archiver found\"));\n  }\n  }",
        "stack": [
          "ArchiveStreamFactoryTest.shortTextFilesAreNoTARs line 36"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/compress/archivers/ArchiveStreamFactory.java",
      "buggy_full_code": "\npackage org.apache.commons.compress.archivers;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\n\nimport org.apache.commons.compress.archivers.ar.ArArchiveInputStream;\nimport org.apache.commons.compress.archivers.ar.ArArchiveOutputStream;\nimport org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream;\nimport org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream;\nimport org.apache.commons.compress.archivers.dump.DumpArchiveInputStream;\nimport org.apache.commons.compress.archivers.jar.JarArchiveInputStream;\nimport org.apache.commons.compress.archivers.jar.JarArchiveOutputStream;\nimport org.apache.commons.compress.archivers.tar.TarArchiveInputStream;\nimport org.apache.commons.compress.archivers.tar.TarArchiveOutputStream;\nimport org.apache.commons.compress.archivers.zip.ZipArchiveInputStream;\nimport org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream;\n\n\npublic class ArchiveStreamFactory { public static final String AR = \"ar\"; public static final String CPIO = \"cpio\"; public static final String DUMP = \"dump\"; public static final String JAR = \"jar\"; public static final String TAR = \"tar\"; public static final String ZIP = \"zip\"; public ArchiveInputStream createArchiveInputStream( final String archiverName, final InputStream in) throws ArchiveException {\n        \n        if (archiverName == null) {\n            throw new IllegalArgumentException(\"Archivername must not be null.\");\n        }\n        \n        if (in == null) {\n            throw new IllegalArgumentException(\"InputStream must not be null.\");\n        }\n\n        if (AR.equalsIgnoreCase(archiverName)) {\n            return new ArArchiveInputStream(in);\n        }\n        if (ZIP.equalsIgnoreCase(archiverName)) {\n            return new ZipArchiveInputStream(in);\n        }\n        if (TAR.equalsIgnoreCase(archiverName)) {\n            return new TarArchiveInputStream(in);\n        }\n        if (JAR.equalsIgnoreCase(archiverName)) {\n            return new JarArchiveInputStream(in);\n        }\n        if (CPIO.equalsIgnoreCase(archiverName)) {\n            return new CpioArchiveInputStream(in);\n        }\n        if (DUMP.equalsIgnoreCase(archiverName)) {\n            return new DumpArchiveInputStream(in);\n        }\n        \n        throw new ArchiveException(\"Archiver: \" + archiverName + \" not found.\");\n    }\n\n    \n    public ArchiveOutputStream createArchiveOutputStream( final String archiverName, final OutputStream out) throws ArchiveException {\n        if (archiverName == null) {\n            throw new IllegalArgumentException(\"Archivername must not be null.\");\n        }\n        if (out == null) {\n            throw new IllegalArgumentException(\"OutputStream must not be null.\");\n        }\n\n        if (AR.equalsIgnoreCase(archiverName)) {\n            return new ArArchiveOutputStream(out);\n        }\n        if (ZIP.equalsIgnoreCase(archiverName)) {\n            return new ZipArchiveOutputStream(out);\n        }\n        if (TAR.equalsIgnoreCase(archiverName)) {\n            return new TarArchiveOutputStream(out);\n        }\n        if (JAR.equalsIgnoreCase(archiverName)) {\n            return new JarArchiveOutputStream(out);\n        }\n        if (CPIO.equalsIgnoreCase(archiverName)) {\n            return new CpioArchiveOutputStream(out);\n        }\n        throw new ArchiveException(\"Archiver: \" + archiverName + \" not found.\");\n    }\n\n    \n    public ArchiveInputStream createArchiveInputStream(final InputStream in) throws ArchiveException {\n        if (in == null) {\n            throw new IllegalArgumentException(\"Stream must not be null.\");\n        }\n\n        if (!in.markSupported()) {\n            throw new IllegalArgumentException(\"Mark is not supported.\");\n        }\n\n        final byte[] signature = new byte[12];\n        in.mark(signature.length);\n        try {\n            int signatureLength = in.read(signature);\n            in.reset();\n            if (ZipArchiveInputStream.matches(signature, signatureLength)) {\n                return new ZipArchiveInputStream(in);\n            } else if (JarArchiveInputStream.matches(signature, signatureLength)) {\n                return new JarArchiveInputStream(in);\n            } else if (ArArchiveInputStream.matches(signature, signatureLength)) {\n                return new ArArchiveInputStream(in);\n            } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\n                return new CpioArchiveInputStream(in);\n            }\n\n            \n            final byte[] dumpsig = new byte[32];\n            in.mark(dumpsig.length);\n            signatureLength = in.read(dumpsig);\n            in.reset();\n            if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n                return new DumpArchiveInputStream(in);\n            }\n\n            \n            final byte[] tarheader = new byte[512];\n            in.mark(tarheader.length);\n            signatureLength = in.read(tarheader);\n            in.reset();\n            if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\n                return new TarArchiveInputStream(in);\n            }\n            \n            try {\n                TarArchiveInputStream tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n                tais.getNextEntry();\n                return new TarArchiveInputStream(in);\n            } catch (Exception e) { \n                \n                \n                \n            }\n        } catch (IOException e) {\n            throw new ArchiveException(\"Could not use reset and mark operations.\", e);\n        }\n\n        throw new ArchiveException(\"No Archiver found for the stream signature\");\n    }\n}\n",
      "fixed_full_code": "\npackage org.apache.commons.compress.archivers;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\n\nimport org.apache.commons.compress.archivers.ar.ArArchiveInputStream;\nimport org.apache.commons.compress.archivers.ar.ArArchiveOutputStream;\nimport org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream;\nimport org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream;\nimport org.apache.commons.compress.archivers.dump.DumpArchiveInputStream;\nimport org.apache.commons.compress.archivers.jar.JarArchiveInputStream;\nimport org.apache.commons.compress.archivers.jar.JarArchiveOutputStream;\nimport org.apache.commons.compress.archivers.tar.TarArchiveInputStream;\nimport org.apache.commons.compress.archivers.tar.TarArchiveOutputStream;\nimport org.apache.commons.compress.archivers.zip.ZipArchiveInputStream;\nimport org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream;\n\n\npublic class ArchiveStreamFactory { public static final String AR = \"ar\"; public static final String CPIO = \"cpio\"; public static final String DUMP = \"dump\"; public static final String JAR = \"jar\"; public static final String TAR = \"tar\"; public static final String ZIP = \"zip\"; public ArchiveInputStream createArchiveInputStream( final String archiverName, final InputStream in) throws ArchiveException {\n        \n        if (archiverName == null) {\n            throw new IllegalArgumentException(\"Archivername must not be null.\");\n        }\n        \n        if (in == null) {\n            throw new IllegalArgumentException(\"InputStream must not be null.\");\n        }\n\n        if (AR.equalsIgnoreCase(archiverName)) {\n            return new ArArchiveInputStream(in);\n        }\n        if (ZIP.equalsIgnoreCase(archiverName)) {\n            return new ZipArchiveInputStream(in);\n        }\n        if (TAR.equalsIgnoreCase(archiverName)) {\n            return new TarArchiveInputStream(in);\n        }\n        if (JAR.equalsIgnoreCase(archiverName)) {\n            return new JarArchiveInputStream(in);\n        }\n        if (CPIO.equalsIgnoreCase(archiverName)) {\n            return new CpioArchiveInputStream(in);\n        }\n        if (DUMP.equalsIgnoreCase(archiverName)) {\n            return new DumpArchiveInputStream(in);\n        }\n        \n        throw new ArchiveException(\"Archiver: \" + archiverName + \" not found.\");\n    }\n\n    \n    public ArchiveOutputStream createArchiveOutputStream( final String archiverName, final OutputStream out) throws ArchiveException {\n        if (archiverName == null) {\n            throw new IllegalArgumentException(\"Archivername must not be null.\");\n        }\n        if (out == null) {\n            throw new IllegalArgumentException(\"OutputStream must not be null.\");\n        }\n\n        if (AR.equalsIgnoreCase(archiverName)) {\n            return new ArArchiveOutputStream(out);\n        }\n        if (ZIP.equalsIgnoreCase(archiverName)) {\n            return new ZipArchiveOutputStream(out);\n        }\n        if (TAR.equalsIgnoreCase(archiverName)) {\n            return new TarArchiveOutputStream(out);\n        }\n        if (JAR.equalsIgnoreCase(archiverName)) {\n            return new JarArchiveOutputStream(out);\n        }\n        if (CPIO.equalsIgnoreCase(archiverName)) {\n            return new CpioArchiveOutputStream(out);\n        }\n        throw new ArchiveException(\"Archiver: \" + archiverName + \" not found.\");\n    }\n\n    \n    public ArchiveInputStream createArchiveInputStream(final InputStream in) throws ArchiveException {\n        if (in == null) {\n            throw new IllegalArgumentException(\"Stream must not be null.\");\n        }\n\n        if (!in.markSupported()) {\n            throw new IllegalArgumentException(\"Mark is not supported.\");\n        }\n\n        final byte[] signature = new byte[12];\n        in.mark(signature.length);\n        try {\n            int signatureLength = in.read(signature);\n            in.reset();\n            if (ZipArchiveInputStream.matches(signature, signatureLength)) {\n                return new ZipArchiveInputStream(in);\n            } else if (JarArchiveInputStream.matches(signature, signatureLength)) {\n                return new JarArchiveInputStream(in);\n            } else if (ArArchiveInputStream.matches(signature, signatureLength)) {\n                return new ArArchiveInputStream(in);\n            } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\n                return new CpioArchiveInputStream(in);\n            }\n\n            \n            final byte[] dumpsig = new byte[32];\n            in.mark(dumpsig.length);\n            signatureLength = in.read(dumpsig);\n            in.reset();\n            if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n                return new DumpArchiveInputStream(in);\n            }\n\n            \n            final byte[] tarheader = new byte[512];\n            in.mark(tarheader.length);\n            signatureLength = in.read(tarheader);\n            in.reset();\n            if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\n                return new TarArchiveInputStream(in);\n            }\n            \n            if (signatureLength >= 512) {\n            try {\n                TarArchiveInputStream tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n                tais.getNextEntry();\n                return new TarArchiveInputStream(in);\n            } catch (Exception e) { \n                \n                \n                \n            }\n            }\n        } catch (IOException e) {\n            throw new ArchiveException(\"Could not use reset and mark operations.\", e);\n        }\n\n        throw new ArchiveException(\"No Archiver found for the stream signature\");\n    }\n}\n",
      "buggy_signatures": [
        "public ArchiveOutputStream createArchiveOutputStream( final String archiverName, final OutputStream out) throws ArchiveException",
        "public ArchiveInputStream createArchiveInputStream(final InputStream in) throws ArchiveException"
      ],
      "fixed_signatures": [
        "public ArchiveOutputStream createArchiveOutputStream( final String archiverName, final OutputStream out) throws ArchiveException",
        "public ArchiveInputStream createArchiveInputStream(final InputStream in) throws ArchiveException"
      ],
      "methods": [
        {
          "buggy_method": "  public ArchiveInputStream createArchiveInputStream(final InputStream in) throws ArchiveException {\n  if (in == null) {\n  throw new IllegalArgumentException(\"Stream must not be null.\");\n  }\n\n  if (!in.markSupported()) {\n  throw new IllegalArgumentException(\"Mark is not supported.\");\n  }\n\n  final byte[] signature = new byte[12];\n  in.mark(signature.length);\n  try {\n  int signatureLength = in.read(signature);\n  in.reset();\n  if (ZipArchiveInputStream.matches(signature, signatureLength)) {\n  return new ZipArchiveInputStream(in);\n  } else if (JarArchiveInputStream.matches(signature, signatureLength)) {\n  return new JarArchiveInputStream(in);\n  } else if (ArArchiveInputStream.matches(signature, signatureLength)) {\n  return new ArArchiveInputStream(in);\n  } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\n  return new CpioArchiveInputStream(in);\n  }\n\n  \n  final byte[] dumpsig = new byte[32];\n  in.mark(dumpsig.length);\n  signatureLength = in.read(dumpsig);\n  in.reset();\n  if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n  return new DumpArchiveInputStream(in);\n  }\n\n  \n  final byte[] tarheader = new byte[512];\n  in.mark(tarheader.length);\n  signatureLength = in.read(tarheader);\n  in.reset();\n  if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\n  return new TarArchiveInputStream(in);\n  }\n  \n  try {\n  TarArchiveInputStream tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n  tais.getNextEntry();\n  return new TarArchiveInputStream(in);\n  } catch (Exception e) { \n  \n  \n  \n  }\n  } catch (IOException e) {\n  throw new ArchiveException(\"Could not use reset and mark operations.\", e);\n  }\n\n  throw new ArchiveException(\"No Archiver found for the stream signature\");\n  }",
          "fixed_method": "  public ArchiveInputStream createArchiveInputStream(final InputStream in) throws ArchiveException {\n  if (in == null) {\n  throw new IllegalArgumentException(\"Stream must not be null.\");\n  }\n\n  if (!in.markSupported()) {\n  throw new IllegalArgumentException(\"Mark is not supported.\");\n  }\n\n  final byte[] signature = new byte[12];\n  in.mark(signature.length);\n  try {\n  int signatureLength = in.read(signature);\n  in.reset();\n  if (ZipArchiveInputStream.matches(signature, signatureLength)) {\n  return new ZipArchiveInputStream(in);\n  } else if (JarArchiveInputStream.matches(signature, signatureLength)) {\n  return new JarArchiveInputStream(in);\n  } else if (ArArchiveInputStream.matches(signature, signatureLength)) {\n  return new ArArchiveInputStream(in);\n  } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\n  return new CpioArchiveInputStream(in);\n  }\n\n  \n  final byte[] dumpsig = new byte[32];\n  in.mark(dumpsig.length);\n  signatureLength = in.read(dumpsig);\n  in.reset();\n  if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n  return new DumpArchiveInputStream(in);\n  }\n\n  \n  final byte[] tarheader = new byte[512];\n  in.mark(tarheader.length);\n  signatureLength = in.read(tarheader);\n  in.reset();\n  if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\n  return new TarArchiveInputStream(in);\n  }\n  \n  if (signatureLength >= 512) {\n  try {\n  TarArchiveInputStream tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n  tais.getNextEntry();\n  return new TarArchiveInputStream(in);\n  } catch (Exception e) { \n  \n  \n  \n  }\n  }\n  } catch (IOException e) {\n  throw new ArchiveException(\"Could not use reset and mark operations.\", e);\n  }\n\n  throw new ArchiveException(\"No Archiver found for the stream signature\");\n  }",
          "diff": [
            "@@ -237,6 +237,7 @@",
            "                 return new TarArchiveInputStream(in);\n",
            "             }\n",
            "             // COMPRESS-117 - improve auto-recognition\n",
            "+            if (signatureLength >= 512) {\n",
            "             try {\n",
            "                 TarArchiveInputStream tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n",
            "                 tais.getNextEntry();\n",
            "@@ -246,6 +247,7 @@",
            "                 // autodetection, simply not a TAR\n",
            "                 // ignored\n",
            "             }\n",
            "+            }\n",
            "         } catch (IOException e) {\n",
            "             throw new ArchiveException(\"Could not use reset and mark operations.\", e);\n",
            "         }\n"
          ],
          "changed_lines": 2
        }
      ]
    }
  ]
}
