{
  "bug_id": "22",
  "failed_tests": {
    "org.joda.time.TestDuration_Basics": [
      {
        "methodName": "testToPeriod_fixedZone",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<0> but was:<64>",
        "fail_line": "            assertEquals(0, test.getWeeks());",
        "test_source": "  public void testToPeriod_fixedZone() throws Throwable {\n  DateTimeZone zone = DateTimeZone.getDefault();\n  try {\n  DateTimeZone.setDefault(DateTimeZone.forOffsetHours(2));\n  long length =\n  (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +\n  5L * DateTimeConstants.MILLIS_PER_HOUR +\n  6L * DateTimeConstants.MILLIS_PER_MINUTE +\n  7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;\n  Duration dur = new Duration(length);\n  Period test = dur.toPeriod();\n  assertEquals(0, test.getYears());  // (4 + (3 * 7) + (2 * 30) + 365) == 450\n  assertEquals(0, test.getMonths());\n  assertEquals(0, test.getWeeks());\n  assertEquals(0, test.getDays());\n  assertEquals((450 * 24) + 5, test.getHours());\n  assertEquals(6, test.getMinutes());\n  assertEquals(7, test.getSeconds());\n  assertEquals(8, test.getMillis());\n  } finally {\n  DateTimeZone.setDefault(zone);\n  }\n  }",
        "stack": [
          "TestDuration_Basics.testToPeriod_fixedZone line 483"
        ]
      }
    ],
    "org.joda.time.TestPeriod_Constructors": [
      {
        "methodName": "testConstructor_long_fixedZone",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<0> but was:<64>",
        "fail_line": "            assertEquals(0, test.getWeeks());",
        "test_source": "  public void testConstructor_long_fixedZone() throws Throwable {\n  DateTimeZone zone = DateTimeZone.getDefault();\n  try {\n  DateTimeZone.setDefault(DateTimeZone.forOffsetHours(2));\n  long length =\n  (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +\n  5L * DateTimeConstants.MILLIS_PER_HOUR +\n  6L * DateTimeConstants.MILLIS_PER_MINUTE +\n  7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;\n  Period test = new Period(length);\n  assertEquals(PeriodType.standard(), test.getPeriodType());\n  // only time fields are precise in AllType\n  assertEquals(0, test.getYears());  // (4 + (3 * 7) + (2 * 30) + 365) == 450\n  assertEquals(0, test.getMonths());\n  assertEquals(0, test.getWeeks());\n  assertEquals(0, test.getDays());\n  assertEquals((450 * 24) + 5, test.getHours());\n  assertEquals(6, test.getMinutes());\n  assertEquals(7, test.getSeconds());\n  assertEquals(8, test.getMillis());\n  } finally {\n  DateTimeZone.setDefault(zone);\n  }\n  }",
        "stack": [
          "TestPeriod_Constructors.testConstructor_long_fixedZone line 188"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/joda/time/base/BasePeriod.java",
      "buggy_full_code": "\npackage org.joda.time.base;\n\nimport java.io.Serializable;\n\nimport org.joda.time.Chronology;\nimport org.joda.time.DateTimeUtils;\nimport org.joda.time.Duration;\nimport org.joda.time.DurationFieldType;\nimport org.joda.time.MutablePeriod;\nimport org.joda.time.PeriodType;\nimport org.joda.time.ReadWritablePeriod;\nimport org.joda.time.ReadableDuration;\nimport org.joda.time.ReadableInstant;\nimport org.joda.time.ReadablePartial;\nimport org.joda.time.ReadablePeriod;\nimport org.joda.time.chrono.ISOChronology;\nimport org.joda.time.convert.ConverterManager;\nimport org.joda.time.convert.PeriodConverter;\nimport org.joda.time.field.FieldUtils;\n\n\npublic abstract class BasePeriod extends AbstractPeriod implements ReadablePeriod, Serializable { private static final long serialVersionUID = -2110953284060001145L; private PeriodType iType; private int[] iValues; protected BasePeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis, PeriodType type) {\n        super();\n        type = checkPeriodType(type);\n        iType = type;\n        setPeriodInternal(years, months, weeks, days, hours, minutes, seconds, millis); \n    }\n\n    \n    protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono) {\n        super();\n        type = checkPeriodType(type);\n        chrono = DateTimeUtils.getChronology(chrono);\n        iType = type;\n        iValues = chrono.get(this, startInstant, endInstant);\n    }\n\n    \n    protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type) {\n        super();\n        type = checkPeriodType(type);\n        if (startInstant == null && endInstant == null) {\n            iType = type;\n            iValues = new int[size()];\n        } else {\n            long startMillis = DateTimeUtils.getInstantMillis(startInstant);\n            long endMillis = DateTimeUtils.getInstantMillis(endInstant);\n            Chronology chrono = DateTimeUtils.getIntervalChronology(startInstant, endInstant);\n            iType = type;\n            iValues = chrono.get(this, startMillis, endMillis);\n        }\n    }\n\n    \n    protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type) {\n        super();\n        if (start == null || end == null) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n        }\n        if (start instanceof BaseLocal && end instanceof BaseLocal && start.getClass() == end.getClass()) {\n            \n            type = checkPeriodType(type);\n            long startMillis = ((BaseLocal) start).getLocalMillis();\n            long endMillis = ((BaseLocal) end).getLocalMillis();\n            Chronology chrono = start.getChronology();\n            chrono = DateTimeUtils.getChronology(chrono);\n            iType = type;\n            iValues = chrono.get(this, startMillis, endMillis);\n        } else {\n            if (start.size() != end.size()) {\n                throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n            }\n            for (int i = 0, isize = start.size(); i < isize; i++) {\n                if (start.getFieldType(i) != end.getFieldType(i)) {\n                    throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n                }\n            }\n            if (DateTimeUtils.isContiguous(start) == false) {\n                throw new IllegalArgumentException(\"ReadablePartial objects must be contiguous\");\n            }\n            iType = checkPeriodType(type);\n            Chronology chrono = DateTimeUtils.getChronology(start.getChronology()).withUTC();\n            iValues = chrono.get(this, chrono.set(start, 0L), chrono.set(end, 0L));\n        }\n    }\n\n    \n    protected BasePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type) {\n        super();\n        type = checkPeriodType(type);\n        long startMillis = DateTimeUtils.getInstantMillis(startInstant);\n        long durationMillis = DateTimeUtils.getDurationMillis(duration);\n        long endMillis = FieldUtils.safeAdd(startMillis, durationMillis);\n        Chronology chrono = DateTimeUtils.getInstantChronology(startInstant);\n        iType = type;\n        iValues = chrono.get(this, startMillis, endMillis);\n    }\n\n    \n    protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type) {\n        super();\n        type = checkPeriodType(type);\n        long durationMillis = DateTimeUtils.getDurationMillis(duration);\n        long endMillis = DateTimeUtils.getInstantMillis(endInstant);\n        long startMillis = FieldUtils.safeSubtract(endMillis, durationMillis);\n        Chronology chrono = DateTimeUtils.getInstantChronology(endInstant);\n        iType = type;\n        iValues = chrono.get(this, startMillis, endMillis);\n    }\n\n    \n    protected BasePeriod(long duration) {\n        this(duration, null, null);\n        \n    }\n\n    \n    protected BasePeriod(long duration, PeriodType type, Chronology chrono) {\n        super();\n        type = checkPeriodType(type);\n        chrono = DateTimeUtils.getChronology(chrono);\n        iType = type;\n        iValues = chrono.get(this, duration);\n    }\n\n    \n    protected BasePeriod(Object period, PeriodType type, Chronology chrono) {\n        super();\n        PeriodConverter converter = ConverterManager.getInstance().getPeriodConverter(period);\n        type = (type == null ? converter.getPeriodType(period) : type);\n        type = checkPeriodType(type);\n        iType = type;\n        if (this instanceof ReadWritablePeriod) {\n            iValues = new int[size()];\n            chrono = DateTimeUtils.getChronology(chrono);\n            converter.setInto((ReadWritablePeriod) this, period, chrono);\n        } else {\n            iValues = new MutablePeriod(period, type, chrono).getValues();\n        }\n    }\n\n    \n    protected BasePeriod(int[] values, PeriodType type) {\n        super();\n        iType = type;\n        iValues = values;\n    }\n\n    \n    \n    protected PeriodType checkPeriodType(PeriodType type) {\n        return DateTimeUtils.getPeriodType(type);\n    }\n\n    \n    \n    public PeriodType getPeriodType() {\n        return iType;\n    }\n\n    \n    \n    public int size() {\n        return iType.size();\n    }\n\n    \n    public DurationFieldType getFieldType(int index) {\n        return iType.getFieldType(index);\n    }\n\n    \n    public int getValue(int index) {\n        return iValues[index];\n    }\n\n    \n    \n    public Duration toDurationFrom(ReadableInstant startInstant) {\n        long startMillis = DateTimeUtils.getInstantMillis(startInstant);\n        Chronology chrono = DateTimeUtils.getInstantChronology(startInstant);\n        long endMillis = chrono.add(this, startMillis, 1);\n        return new Duration(startMillis, endMillis);\n    }\n\n    \n    public Duration toDurationTo(ReadableInstant endInstant) {\n        long endMillis = DateTimeUtils.getInstantMillis(endInstant);\n        Chronology chrono = DateTimeUtils.getInstantChronology(endInstant);\n        long startMillis = chrono.add(this, endMillis, -1);\n        return new Duration(startMillis, endMillis);\n    }\n\n    \n    \n    private void checkAndUpdate(DurationFieldType type, int[] values, int newValue) {\n        int index = indexOf(type);\n        if (index == -1) {\n            if (newValue != 0) {\n                throw new IllegalArgumentException(\n                    \"Period does not support field '\" + type.getName() + \"'\");\n            }\n        } else {\n            values[index] = newValue;\n        }\n    }\n\n    \n    \n    protected void setPeriod(ReadablePeriod period) {\n        if (period == null) {\n            setValues(new int[size()]);\n        } else {\n            setPeriodInternal(period);\n        }\n    }\n\n    \n    private void setPeriodInternal(ReadablePeriod period) {\n        int[] newValues = new int[size()];\n        for (int i = 0, isize = period.size(); i < isize; i++) {\n            DurationFieldType type = period.getFieldType(i);\n            int value = period.getValue(i);\n            checkAndUpdate(type, newValues, value);\n        }\n        iValues = newValues;\n    }\n\n    \n    protected void setPeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis) {\n        setPeriodInternal(years, months, weeks, days, hours, minutes, seconds, millis);\n    }\n\n    \n    private void setPeriodInternal(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis) {\n        int[] newValues = new int[size()];\n        checkAndUpdate(DurationFieldType.years(), newValues, years);\n        checkAndUpdate(DurationFieldType.months(), newValues, months);\n        checkAndUpdate(DurationFieldType.weeks(), newValues, weeks);\n        checkAndUpdate(DurationFieldType.days(), newValues, days);\n        checkAndUpdate(DurationFieldType.hours(), newValues, hours);\n        checkAndUpdate(DurationFieldType.minutes(), newValues, minutes);\n        checkAndUpdate(DurationFieldType.seconds(), newValues, seconds);\n        checkAndUpdate(DurationFieldType.millis(), newValues, millis);\n        iValues = newValues;\n    }\n\n    \n    \n    protected void setField(DurationFieldType field, int value) {\n        setFieldInto(iValues, field, value);\n    }\n\n    \n    protected void setFieldInto(int[] values, DurationFieldType field, int value) {\n        int index = indexOf(field);\n        if (index == -1) {\n            if (value != 0 || field == null) {\n                throw new IllegalArgumentException(\n                    \"Period does not support field '\" + field + \"'\");\n            }\n        } else {\n            values[index] = value;\n        }\n    }\n\n    \n    protected void addField(DurationFieldType field, int value) {\n        addFieldInto(iValues, field, value);\n    }\n\n    \n    protected void addFieldInto(int[] values, DurationFieldType field, int value) {\n        int index = indexOf(field);\n        if (index == -1) {\n            if (value != 0 || field == null) {\n                throw new IllegalArgumentException(\n                    \"Period does not support field '\" + field + \"'\");\n            }\n        } else {\n            values[index] = FieldUtils.safeAdd(values[index], value);\n        }\n    }\n\n    \n    protected void mergePeriod(ReadablePeriod period) {\n        if (period != null) {\n            iValues = mergePeriodInto(getValues(), period);\n        }\n    }\n\n    \n    protected int[] mergePeriodInto(int[] values, ReadablePeriod period) {\n         for (int i = 0, isize = period.size(); i < isize; i++) {\n             DurationFieldType type = period.getFieldType(i);\n             int value = period.getValue(i);\n             checkAndUpdate(type, values, value);\n         }\n         return values;\n    }\n\n    \n    protected void addPeriod(ReadablePeriod period) {\n        if (period != null) {\n            iValues = addPeriodInto(getValues(), period);\n        }\n    }\n\n    \n    protected int[] addPeriodInto(int[] values, ReadablePeriod period) {\n         for (int i = 0, isize = period.size(); i < isize; i++) {\n             DurationFieldType type = period.getFieldType(i);\n             int value = period.getValue(i);\n             if (value != 0) {\n                 int index = indexOf(type);\n                 if (index == -1) {\n                     throw new IllegalArgumentException(\n                         \"Period does not support field '\" + type.getName() + \"'\");\n                 } else {\n                     values[index] = FieldUtils.safeAdd(getValue(index), value);\n                 }\n             }\n         }\n         return values;\n    }\n\n    \n    \n    protected void setValue(int index, int value) {\n        iValues[index] = value;\n    }\n\n    \n    protected void setValues(int[] values) {\n        iValues = values;\n    }\n\n}\n",
      "fixed_full_code": "\npackage org.joda.time.base;\n\nimport java.io.Serializable;\n\nimport org.joda.time.Chronology;\nimport org.joda.time.DateTimeUtils;\nimport org.joda.time.Duration;\nimport org.joda.time.DurationFieldType;\nimport org.joda.time.MutablePeriod;\nimport org.joda.time.PeriodType;\nimport org.joda.time.ReadWritablePeriod;\nimport org.joda.time.ReadableDuration;\nimport org.joda.time.ReadableInstant;\nimport org.joda.time.ReadablePartial;\nimport org.joda.time.ReadablePeriod;\nimport org.joda.time.chrono.ISOChronology;\nimport org.joda.time.convert.ConverterManager;\nimport org.joda.time.convert.PeriodConverter;\nimport org.joda.time.field.FieldUtils;\n\n\npublic abstract class BasePeriod extends AbstractPeriod implements ReadablePeriod, Serializable { private static final long serialVersionUID = -2110953284060001145L; private PeriodType iType; private int[] iValues; protected BasePeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis, PeriodType type) {\n        super();\n        type = checkPeriodType(type);\n        iType = type;\n        setPeriodInternal(years, months, weeks, days, hours, minutes, seconds, millis); \n    }\n\n    \n    protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono) {\n        super();\n        type = checkPeriodType(type);\n        chrono = DateTimeUtils.getChronology(chrono);\n        iType = type;\n        iValues = chrono.get(this, startInstant, endInstant);\n    }\n\n    \n    protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type) {\n        super();\n        type = checkPeriodType(type);\n        if (startInstant == null && endInstant == null) {\n            iType = type;\n            iValues = new int[size()];\n        } else {\n            long startMillis = DateTimeUtils.getInstantMillis(startInstant);\n            long endMillis = DateTimeUtils.getInstantMillis(endInstant);\n            Chronology chrono = DateTimeUtils.getIntervalChronology(startInstant, endInstant);\n            iType = type;\n            iValues = chrono.get(this, startMillis, endMillis);\n        }\n    }\n\n    \n    protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type) {\n        super();\n        if (start == null || end == null) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n        }\n        if (start instanceof BaseLocal && end instanceof BaseLocal && start.getClass() == end.getClass()) {\n            \n            type = checkPeriodType(type);\n            long startMillis = ((BaseLocal) start).getLocalMillis();\n            long endMillis = ((BaseLocal) end).getLocalMillis();\n            Chronology chrono = start.getChronology();\n            chrono = DateTimeUtils.getChronology(chrono);\n            iType = type;\n            iValues = chrono.get(this, startMillis, endMillis);\n        } else {\n            if (start.size() != end.size()) {\n                throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n            }\n            for (int i = 0, isize = start.size(); i < isize; i++) {\n                if (start.getFieldType(i) != end.getFieldType(i)) {\n                    throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n                }\n            }\n            if (DateTimeUtils.isContiguous(start) == false) {\n                throw new IllegalArgumentException(\"ReadablePartial objects must be contiguous\");\n            }\n            iType = checkPeriodType(type);\n            Chronology chrono = DateTimeUtils.getChronology(start.getChronology()).withUTC();\n            iValues = chrono.get(this, chrono.set(start, 0L), chrono.set(end, 0L));\n        }\n    }\n\n    \n    protected BasePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type) {\n        super();\n        type = checkPeriodType(type);\n        long startMillis = DateTimeUtils.getInstantMillis(startInstant);\n        long durationMillis = DateTimeUtils.getDurationMillis(duration);\n        long endMillis = FieldUtils.safeAdd(startMillis, durationMillis);\n        Chronology chrono = DateTimeUtils.getInstantChronology(startInstant);\n        iType = type;\n        iValues = chrono.get(this, startMillis, endMillis);\n    }\n\n    \n    protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type) {\n        super();\n        type = checkPeriodType(type);\n        long durationMillis = DateTimeUtils.getDurationMillis(duration);\n        long endMillis = DateTimeUtils.getInstantMillis(endInstant);\n        long startMillis = FieldUtils.safeSubtract(endMillis, durationMillis);\n        Chronology chrono = DateTimeUtils.getInstantChronology(endInstant);\n        iType = type;\n        iValues = chrono.get(this, startMillis, endMillis);\n    }\n\n    \n    protected BasePeriod(long duration) {\n        super();\n        \n        iType = PeriodType.time();\n        int[] values = ISOChronology.getInstanceUTC().get(this, duration);\n        iType = PeriodType.standard();\n        iValues = new int[8];\n        System.arraycopy(values, 0, iValues, 4, 4);\n    }\n\n    \n    protected BasePeriod(long duration, PeriodType type, Chronology chrono) {\n        super();\n        type = checkPeriodType(type);\n        chrono = DateTimeUtils.getChronology(chrono);\n        iType = type;\n        iValues = chrono.get(this, duration);\n    }\n\n    \n    protected BasePeriod(Object period, PeriodType type, Chronology chrono) {\n        super();\n        PeriodConverter converter = ConverterManager.getInstance().getPeriodConverter(period);\n        type = (type == null ? converter.getPeriodType(period) : type);\n        type = checkPeriodType(type);\n        iType = type;\n        if (this instanceof ReadWritablePeriod) {\n            iValues = new int[size()];\n            chrono = DateTimeUtils.getChronology(chrono);\n            converter.setInto((ReadWritablePeriod) this, period, chrono);\n        } else {\n            iValues = new MutablePeriod(period, type, chrono).getValues();\n        }\n    }\n\n    \n    protected BasePeriod(int[] values, PeriodType type) {\n        super();\n        iType = type;\n        iValues = values;\n    }\n\n    \n    \n    protected PeriodType checkPeriodType(PeriodType type) {\n        return DateTimeUtils.getPeriodType(type);\n    }\n\n    \n    \n    public PeriodType getPeriodType() {\n        return iType;\n    }\n\n    \n    \n    public int size() {\n        return iType.size();\n    }\n\n    \n    public DurationFieldType getFieldType(int index) {\n        return iType.getFieldType(index);\n    }\n\n    \n    public int getValue(int index) {\n        return iValues[index];\n    }\n\n    \n    \n    public Duration toDurationFrom(ReadableInstant startInstant) {\n        long startMillis = DateTimeUtils.getInstantMillis(startInstant);\n        Chronology chrono = DateTimeUtils.getInstantChronology(startInstant);\n        long endMillis = chrono.add(this, startMillis, 1);\n        return new Duration(startMillis, endMillis);\n    }\n\n    \n    public Duration toDurationTo(ReadableInstant endInstant) {\n        long endMillis = DateTimeUtils.getInstantMillis(endInstant);\n        Chronology chrono = DateTimeUtils.getInstantChronology(endInstant);\n        long startMillis = chrono.add(this, endMillis, -1);\n        return new Duration(startMillis, endMillis);\n    }\n\n    \n    \n    private void checkAndUpdate(DurationFieldType type, int[] values, int newValue) {\n        int index = indexOf(type);\n        if (index == -1) {\n            if (newValue != 0) {\n                throw new IllegalArgumentException(\n                    \"Period does not support field '\" + type.getName() + \"'\");\n            }\n        } else {\n            values[index] = newValue;\n        }\n    }\n\n    \n    \n    protected void setPeriod(ReadablePeriod period) {\n        if (period == null) {\n            setValues(new int[size()]);\n        } else {\n            setPeriodInternal(period);\n        }\n    }\n\n    \n    private void setPeriodInternal(ReadablePeriod period) {\n        int[] newValues = new int[size()];\n        for (int i = 0, isize = period.size(); i < isize; i++) {\n            DurationFieldType type = period.getFieldType(i);\n            int value = period.getValue(i);\n            checkAndUpdate(type, newValues, value);\n        }\n        iValues = newValues;\n    }\n\n    \n    protected void setPeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis) {\n        setPeriodInternal(years, months, weeks, days, hours, minutes, seconds, millis);\n    }\n\n    \n    private void setPeriodInternal(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis) {\n        int[] newValues = new int[size()];\n        checkAndUpdate(DurationFieldType.years(), newValues, years);\n        checkAndUpdate(DurationFieldType.months(), newValues, months);\n        checkAndUpdate(DurationFieldType.weeks(), newValues, weeks);\n        checkAndUpdate(DurationFieldType.days(), newValues, days);\n        checkAndUpdate(DurationFieldType.hours(), newValues, hours);\n        checkAndUpdate(DurationFieldType.minutes(), newValues, minutes);\n        checkAndUpdate(DurationFieldType.seconds(), newValues, seconds);\n        checkAndUpdate(DurationFieldType.millis(), newValues, millis);\n        iValues = newValues;\n    }\n\n    \n    \n    protected void setField(DurationFieldType field, int value) {\n        setFieldInto(iValues, field, value);\n    }\n\n    \n    protected void setFieldInto(int[] values, DurationFieldType field, int value) {\n        int index = indexOf(field);\n        if (index == -1) {\n            if (value != 0 || field == null) {\n                throw new IllegalArgumentException(\n                    \"Period does not support field '\" + field + \"'\");\n            }\n        } else {\n            values[index] = value;\n        }\n    }\n\n    \n    protected void addField(DurationFieldType field, int value) {\n        addFieldInto(iValues, field, value);\n    }\n\n    \n    protected void addFieldInto(int[] values, DurationFieldType field, int value) {\n        int index = indexOf(field);\n        if (index == -1) {\n            if (value != 0 || field == null) {\n                throw new IllegalArgumentException(\n                    \"Period does not support field '\" + field + \"'\");\n            }\n        } else {\n            values[index] = FieldUtils.safeAdd(values[index], value);\n        }\n    }\n\n    \n    protected void mergePeriod(ReadablePeriod period) {\n        if (period != null) {\n            iValues = mergePeriodInto(getValues(), period);\n        }\n    }\n\n    \n    protected int[] mergePeriodInto(int[] values, ReadablePeriod period) {\n         for (int i = 0, isize = period.size(); i < isize; i++) {\n             DurationFieldType type = period.getFieldType(i);\n             int value = period.getValue(i);\n             checkAndUpdate(type, values, value);\n         }\n         return values;\n    }\n\n    \n    protected void addPeriod(ReadablePeriod period) {\n        if (period != null) {\n            iValues = addPeriodInto(getValues(), period);\n        }\n    }\n\n    \n    protected int[] addPeriodInto(int[] values, ReadablePeriod period) {\n         for (int i = 0, isize = period.size(); i < isize; i++) {\n             DurationFieldType type = period.getFieldType(i);\n             int value = period.getValue(i);\n             if (value != 0) {\n                 int index = indexOf(type);\n                 if (index == -1) {\n                     throw new IllegalArgumentException(\n                         \"Period does not support field '\" + type.getName() + \"'\");\n                 } else {\n                     values[index] = FieldUtils.safeAdd(getValue(index), value);\n                 }\n             }\n         }\n         return values;\n    }\n\n    \n    \n    protected void setValue(int index, int value) {\n        iValues[index] = value;\n    }\n\n    \n    protected void setValues(int[] values) {\n        iValues = values;\n    }\n\n}\n",
      "buggy_signatures": [
        "protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono)",
        "protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type)",
        "protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type)",
        "protected BasePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type)",
        "protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type)",
        "protected BasePeriod(long duration)",
        "protected BasePeriod(long duration, PeriodType type, Chronology chrono)",
        "protected BasePeriod(Object period, PeriodType type, Chronology chrono)",
        "protected BasePeriod(int[] values, PeriodType type)",
        "protected PeriodType checkPeriodType(PeriodType type)",
        "public PeriodType getPeriodType()",
        "public int size()",
        "public DurationFieldType getFieldType(int index)",
        "public int getValue(int index)",
        "public Duration toDurationFrom(ReadableInstant startInstant)",
        "public Duration toDurationTo(ReadableInstant endInstant)",
        "private void checkAndUpdate(DurationFieldType type, int[] values, int newValue)",
        "protected void setPeriod(ReadablePeriod period)",
        "private void setPeriodInternal(ReadablePeriod period)",
        "protected void setPeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis)",
        "private void setPeriodInternal(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis)",
        "protected void setField(DurationFieldType field, int value)",
        "protected void setFieldInto(int[] values, DurationFieldType field, int value)",
        "protected void addField(DurationFieldType field, int value)",
        "protected void addFieldInto(int[] values, DurationFieldType field, int value)",
        "protected void mergePeriod(ReadablePeriod period)",
        "protected int[] mergePeriodInto(int[] values, ReadablePeriod period)",
        "protected void addPeriod(ReadablePeriod period)",
        "protected int[] addPeriodInto(int[] values, ReadablePeriod period)",
        "protected void setValue(int index, int value)",
        "protected void setValues(int[] values)"
      ],
      "fixed_signatures": [
        "protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono)",
        "protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type)",
        "protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type)",
        "protected BasePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type)",
        "protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type)",
        "protected BasePeriod(long duration)",
        "protected BasePeriod(long duration, PeriodType type, Chronology chrono)",
        "protected BasePeriod(Object period, PeriodType type, Chronology chrono)",
        "protected BasePeriod(int[] values, PeriodType type)",
        "protected PeriodType checkPeriodType(PeriodType type)",
        "public PeriodType getPeriodType()",
        "public int size()",
        "public DurationFieldType getFieldType(int index)",
        "public int getValue(int index)",
        "public Duration toDurationFrom(ReadableInstant startInstant)",
        "public Duration toDurationTo(ReadableInstant endInstant)",
        "private void checkAndUpdate(DurationFieldType type, int[] values, int newValue)",
        "protected void setPeriod(ReadablePeriod period)",
        "private void setPeriodInternal(ReadablePeriod period)",
        "protected void setPeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis)",
        "private void setPeriodInternal(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis)",
        "protected void setField(DurationFieldType field, int value)",
        "protected void setFieldInto(int[] values, DurationFieldType field, int value)",
        "protected void addField(DurationFieldType field, int value)",
        "protected void addFieldInto(int[] values, DurationFieldType field, int value)",
        "protected void mergePeriod(ReadablePeriod period)",
        "protected int[] mergePeriodInto(int[] values, ReadablePeriod period)",
        "protected void addPeriod(ReadablePeriod period)",
        "protected int[] addPeriodInto(int[] values, ReadablePeriod period)",
        "protected void setValue(int index, int value)",
        "protected void setValues(int[] values)"
      ],
      "methods": [
        {
          "buggy_method": "  protected BasePeriod(long duration) {\n  this(duration, null, null);\n  \n  }",
          "fixed_method": "  protected BasePeriod(long duration) {\n  super();\n  \n  iType = PeriodType.time();\n  int[] values = ISOChronology.getInstanceUTC().get(this, duration);\n  iType = PeriodType.standard();\n  iValues = new int[8];\n  System.arraycopy(values, 0, iValues, 4, 4);\n  }",
          "diff": [
            "@@ -219,8 +219,13 @@",
            "      * @param duration  the duration, in milliseconds\n",
            "      */\n",
            "     protected BasePeriod(long duration) {\n",
            "-        this(duration, null, null);\n",
            "+        super();\n",
            "         // bug [3264409]\n",
            "+        iType = PeriodType.time();\n",
            "+        int[] values = ISOChronology.getInstanceUTC().get(this, duration);\n",
            "+        iType = PeriodType.standard();\n",
            "+        iValues = new int[8];\n",
            "+        System.arraycopy(values, 0, iValues, 4, 4);\n",
            "     }\n",
            " \n",
            "     /**\n"
          ],
          "changed_lines": 7
        }
      ]
    }
  ]
}
