{
  "bug_id": "12",
  "failed_tests": {
    "org.apache.commons.compress.archivers.TarTestCase": [
      {
        "methodName": "testCOMPRESS178",
        "error": "java.lang.IllegalArgumentException",
        "message": "Invalid byte 0 at offset 2 in '00{NUL}0765{NUL}' len=8",
        "fail_line": "            in.getNextEntry();",
        "test_source": "  public void testCOMPRESS178() throws Exception {\n  final File input = getFile(\"COMPRESS-178.tar\");\n  final InputStream is = new FileInputStream(input);\n  final ArchiveInputStream in = new ArchiveStreamFactory().createArchiveInputStream(\"tar\", is);\n  try {\n  in.getNextEntry();\n  fail(\"Expected IOException\");\n  } catch (IOException e) {\n  Throwable t = e.getCause();\n  assertTrue(\"Expected cause = IllegalArgumentException\", t instanceof IllegalArgumentException);\n  }\n  in.close();\n  }",
        "stack": [
          "TarUtils.parseOctal line 100, TarUtils.parseOctalOrBinary line 130, TarArchiveEntry.parseTarHeader line 815, TarArchiveEntry.<init> line 314, TarArchiveInputStream.getNextTarEntry line 198, TarArchiveInputStream.getNextEntry line 395, TarTestCase.testCOMPRESS178 line 309"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java",
      "buggy_full_code": "\n\n\n\npackage org.apache.commons.compress.archivers.tar;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Map.Entry;\n\nimport org.apache.commons.compress.archivers.ArchiveEntry;\nimport org.apache.commons.compress.archivers.ArchiveInputStream;\nimport org.apache.commons.compress.utils.ArchiveUtils;\n\n\npublic class TarArchiveInputStream extends ArchiveInputStream { private static final int SMALL_BUFFER_SIZE = 256; private static final int BUFFER_SIZE = 8 * 1024; private boolean hasHitEOF; private long entrySize; private long entryOffset; private byte[] readBuf; protected final TarBuffer buffer; private TarArchiveEntry currEntry; public TarArchiveInputStream(InputStream is) {\n        this(is, TarBuffer.DEFAULT_BLKSIZE, TarBuffer.DEFAULT_RCDSIZE);\n    }\n\n    \n    public TarArchiveInputStream(InputStream is, int blockSize) {\n        this(is, blockSize, TarBuffer.DEFAULT_RCDSIZE);\n    }\n\n    \n    public TarArchiveInputStream(InputStream is, int blockSize, int recordSize) {\n        this.buffer = new TarBuffer(is, blockSize, recordSize);\n        this.readBuf = null;\n        this.hasHitEOF = false;\n    }\n\n    \n    @Override\n    public void close() throws IOException {\n        buffer.close();\n    }\n\n    \n    public int getRecordSize() {\n        return buffer.getRecordSize();\n    }\n\n    \n    @Override\n    public int available() throws IOException {\n        if (entrySize - entryOffset > Integer.MAX_VALUE) {\n            return Integer.MAX_VALUE;\n        }\n        return (int) (entrySize - entryOffset);\n    }\n\n    \n    @Override\n    public long skip(long numToSkip) throws IOException {\n        \n        \n        \n        \n        byte[] skipBuf = new byte[BUFFER_SIZE];\n        long skip = numToSkip;\n        while (skip > 0) {\n            int realSkip = (int) (skip > skipBuf.length ? skipBuf.length : skip);\n            int numRead = read(skipBuf, 0, realSkip);\n            if (numRead == -1) {\n                break;\n            }\n            skip -= numRead;\n        }\n        return (numToSkip - skip);\n    }\n\n    \n    @Override\n    public synchronized void reset() {\n    }\n\n    \n    public TarArchiveEntry getNextTarEntry() throws IOException {\n        if (hasHitEOF) {\n            return null;\n        }\n\n        if (currEntry != null) {\n            long numToSkip = entrySize - entryOffset;\n\n            while (numToSkip > 0) {\n                long skipped = skip(numToSkip);\n                if (skipped <= 0) {\n                    throw new RuntimeException(\"failed to skip current tar entry\");\n                }\n                numToSkip -= skipped;\n            }\n\n            readBuf = null;\n        }\n\n        byte[] headerBuf = getRecord();\n\n        if (hasHitEOF) {\n            currEntry = null;\n            return null;\n        }\n\n        currEntry = new TarArchiveEntry(headerBuf);\n        entryOffset = 0;\n        entrySize = currEntry.getSize();\n\n        if (currEntry.isGNULongNameEntry()) {\n            \n            StringBuffer longName = new StringBuffer();\n            byte[] buf = new byte[SMALL_BUFFER_SIZE];\n            int length = 0;\n            while ((length = read(buf)) >= 0) {\n                longName.append(new String(buf, 0, length));\n            }\n            getNextEntry();\n            if (currEntry == null) {\n                \n                \n                return null;\n            }\n            \n            if (longName.length() > 0\n                && longName.charAt(longName.length() - 1) == 0) {\n                longName.deleteCharAt(longName.length() - 1);\n            }\n            currEntry.setName(longName.toString());\n        }\n\n        if (currEntry.isPaxHeader()){ \n            paxHeaders();\n        }\n\n        if (currEntry.isGNUSparse()){ \n            readGNUSparse();\n        }\n\n        \n        \n        \n        \n        entrySize = currEntry.getSize();\n        return currEntry;\n    }\n\n    \n    private byte[] getRecord() throws IOException {\n        if (hasHitEOF) {\n            return null;\n        }\n\n        byte[] headerBuf = buffer.readRecord();\n\n        if (headerBuf == null) {\n            hasHitEOF = true;\n        } else if (buffer.isEOFRecord(headerBuf)) {\n            hasHitEOF = true;\n        }\n\n        return hasHitEOF ? null : headerBuf;\n    }\n\n    private void paxHeaders() throws IOException {\n        Reader br = new InputStreamReader(this, \"UTF-8\") {\n                @Override\n                public void close() {\n                    \n                }\n            };\n        Map<String, String> headers = null;\n        try {\n            headers = parsePaxHeaders(br);\n        } finally {\n            \n            br.close();\n        }\n\n        getNextEntry(); \n        applyPaxHeadersToCurrentEntry(headers);\n    }\n\n    Map<String, String> parsePaxHeaders(Reader br) throws IOException {\n        Map<String, String> headers = new HashMap<String, String>();\n        \n        while(true){ \n            int ch;\n            int len = 0;\n            int read = 0;\n            while((ch = br.read()) != -1){\n                read++;\n                if (ch == ' '){ \n                    \n                    StringBuffer sb = new StringBuffer();\n                    while((ch = br.read()) != -1){\n                        read++;\n                        if (ch == '='){ \n                            String keyword = sb.toString();\n                            \n                            char[] cbuf = new char[len-read];\n                            int got = br.read(cbuf);\n                            if (got != len - read){\n                                throw new IOException(\"Failed to read \"\n                                                      + \"Paxheader. Expected \"\n                                                      + (len - read)\n                                                      + \" chars, read \"\n                                                      + got);\n                            }\n                            \n                            String value = new String(cbuf, 0,\n                                                      len - read - 1);\n                            headers.put(keyword, value);\n                            break;\n                        }\n                        sb.append((char) ch);\n                    }\n                    break; \n                }\n                len *= 10;\n                len += ch - '0';\n            }\n            if (ch == -1){ \n                break;\n            }\n        }\n        return headers;\n    }\n\n    private void applyPaxHeadersToCurrentEntry(Map<String, String> headers) {\n        \n        for (Entry<String, String> ent : headers.entrySet()){\n            String key = ent.getKey();\n            String val = ent.getValue();\n            if (\"path\".equals(key)){\n                currEntry.setName(val);\n            } else if (\"linkpath\".equals(key)){\n                currEntry.setLinkName(val);\n            } else if (\"gid\".equals(key)){\n                currEntry.setGroupId(Integer.parseInt(val));\n            } else if (\"gname\".equals(key)){\n                currEntry.setGroupName(val);\n            } else if (\"uid\".equals(key)){\n                currEntry.setUserId(Integer.parseInt(val));\n            } else if (\"uname\".equals(key)){\n                currEntry.setUserName(val);\n            } else if (\"size\".equals(key)){\n                currEntry.setSize(Long.parseLong(val));\n            }\n        }\n    }\n\n    \n    private void readGNUSparse() throws IOException {\n        \n        if (currEntry.isExtended()) {\n            TarArchiveSparseEntry entry;\n            do {\n                byte[] headerBuf = getRecord();\n                if (hasHitEOF) {\n                    currEntry = null;\n                    break;\n                }\n                entry = new TarArchiveSparseEntry(headerBuf);\n                \n            } while (entry.isExtended());\n        }\n    }\n\n    @Override\n    public ArchiveEntry getNextEntry() throws IOException {\n        return getNextTarEntry();\n    }\n\n    \n    @Override\n    public int read(byte[] buf, int offset, int numToRead) throws IOException {\n        int totalRead = 0;\n\n        if (entryOffset >= entrySize) {\n            return -1;\n        }\n\n        if ((numToRead + entryOffset) > entrySize) {\n            numToRead = (int) (entrySize - entryOffset);\n        }\n\n        if (readBuf != null) {\n            int sz = (numToRead > readBuf.length) ? readBuf.length\n                : numToRead;\n\n            System.arraycopy(readBuf, 0, buf, offset, sz);\n\n            if (sz >= readBuf.length) {\n                readBuf = null;\n            } else {\n                int newLen = readBuf.length - sz;\n                byte[] newBuf = new byte[newLen];\n\n                System.arraycopy(readBuf, sz, newBuf, 0, newLen);\n\n                readBuf = newBuf;\n            }\n\n            totalRead += sz;\n            numToRead -= sz;\n            offset += sz;\n        }\n\n        while (numToRead > 0) {\n            byte[] rec = buffer.readRecord();\n\n            if (rec == null) {\n                \n                throw new IOException(\"unexpected EOF with \" + numToRead\n                                      + \" bytes unread. Occured at byte: \" + getBytesRead());\n            }\n            count(rec.length);\n            int sz = numToRead;\n            int recLen = rec.length;\n\n            if (recLen > sz) {\n                System.arraycopy(rec, 0, buf, offset, sz);\n\n                readBuf = new byte[recLen - sz];\n\n                System.arraycopy(rec, sz, readBuf, 0, recLen - sz);\n            } else {\n                sz = recLen;\n\n                System.arraycopy(rec, 0, buf, offset, recLen);\n            }\n\n            totalRead += sz;\n            numToRead -= sz;\n            offset += sz;\n        }\n\n        entryOffset += totalRead;\n\n        return totalRead;\n    }\n\n    \n    @Override\n    public boolean canReadEntryData(ArchiveEntry ae) {\n        if (ae instanceof TarArchiveEntry) {\n            TarArchiveEntry te = (TarArchiveEntry) ae;\n            return !te.isGNUSparse();\n        }\n        return false;\n    }\n\n    protected final TarArchiveEntry getCurrentEntry() {\n        return currEntry;\n    }\n\n    protected final void setCurrentEntry(TarArchiveEntry e) {\n        currEntry = e;\n    }\n\n    protected final boolean isAtEOF() {\n        return hasHitEOF;\n    }\n\n    protected final void setAtEOF(boolean b) {\n        hasHitEOF = b;\n    }\n\n    \n    public static boolean matches(byte[] signature, int length) {\n        if (length < TarConstants.VERSION_OFFSET+TarConstants.VERSIONLEN) {\n            return false;\n        }\n\n        if (ArchiveUtils.matchAsciiBuffer(TarConstants.MAGIC_POSIX,\n                signature, TarConstants.MAGIC_OFFSET, TarConstants.MAGICLEN)\n            &&\n            ArchiveUtils.matchAsciiBuffer(TarConstants.VERSION_POSIX,\n                signature, TarConstants.VERSION_OFFSET, TarConstants.VERSIONLEN)\n                ){\n            return true;\n        }\n        if (ArchiveUtils.matchAsciiBuffer(TarConstants.MAGIC_GNU,\n                signature, TarConstants.MAGIC_OFFSET, TarConstants.MAGICLEN)\n            &&\n            (\n             ArchiveUtils.matchAsciiBuffer(TarConstants.VERSION_GNU_SPACE,\n                signature, TarConstants.VERSION_OFFSET, TarConstants.VERSIONLEN)\n            ||\n            ArchiveUtils.matchAsciiBuffer(TarConstants.VERSION_GNU_ZERO,\n                signature, TarConstants.VERSION_OFFSET, TarConstants.VERSIONLEN)\n            )\n                ){\n            return true;\n        }\n        \n        if (ArchiveUtils.matchAsciiBuffer(TarConstants.MAGIC_ANT,\n                signature, TarConstants.MAGIC_OFFSET, TarConstants.MAGICLEN)\n            &&\n            ArchiveUtils.matchAsciiBuffer(TarConstants.VERSION_ANT,\n                signature, TarConstants.VERSION_OFFSET, TarConstants.VERSIONLEN)\n                ){\n            return true;\n        }\n        return false;\n    }\n\n}\n",
      "fixed_full_code": "\n\n\n\npackage org.apache.commons.compress.archivers.tar;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Map.Entry;\n\nimport org.apache.commons.compress.archivers.ArchiveEntry;\nimport org.apache.commons.compress.archivers.ArchiveInputStream;\nimport org.apache.commons.compress.utils.ArchiveUtils;\n\n\npublic class TarArchiveInputStream extends ArchiveInputStream { private static final int SMALL_BUFFER_SIZE = 256; private static final int BUFFER_SIZE = 8 * 1024; private boolean hasHitEOF; private long entrySize; private long entryOffset; private byte[] readBuf; protected final TarBuffer buffer; private TarArchiveEntry currEntry; public TarArchiveInputStream(InputStream is) {\n        this(is, TarBuffer.DEFAULT_BLKSIZE, TarBuffer.DEFAULT_RCDSIZE);\n    }\n\n    \n    public TarArchiveInputStream(InputStream is, int blockSize) {\n        this(is, blockSize, TarBuffer.DEFAULT_RCDSIZE);\n    }\n\n    \n    public TarArchiveInputStream(InputStream is, int blockSize, int recordSize) {\n        this.buffer = new TarBuffer(is, blockSize, recordSize);\n        this.readBuf = null;\n        this.hasHitEOF = false;\n    }\n\n    \n    @Override\n    public void close() throws IOException {\n        buffer.close();\n    }\n\n    \n    public int getRecordSize() {\n        return buffer.getRecordSize();\n    }\n\n    \n    @Override\n    public int available() throws IOException {\n        if (entrySize - entryOffset > Integer.MAX_VALUE) {\n            return Integer.MAX_VALUE;\n        }\n        return (int) (entrySize - entryOffset);\n    }\n\n    \n    @Override\n    public long skip(long numToSkip) throws IOException {\n        \n        \n        \n        \n        byte[] skipBuf = new byte[BUFFER_SIZE];\n        long skip = numToSkip;\n        while (skip > 0) {\n            int realSkip = (int) (skip > skipBuf.length ? skipBuf.length : skip);\n            int numRead = read(skipBuf, 0, realSkip);\n            if (numRead == -1) {\n                break;\n            }\n            skip -= numRead;\n        }\n        return (numToSkip - skip);\n    }\n\n    \n    @Override\n    public synchronized void reset() {\n    }\n\n    \n    public TarArchiveEntry getNextTarEntry() throws IOException {\n        if (hasHitEOF) {\n            return null;\n        }\n\n        if (currEntry != null) {\n            long numToSkip = entrySize - entryOffset;\n\n            while (numToSkip > 0) {\n                long skipped = skip(numToSkip);\n                if (skipped <= 0) {\n                    throw new RuntimeException(\"failed to skip current tar entry\");\n                }\n                numToSkip -= skipped;\n            }\n\n            readBuf = null;\n        }\n\n        byte[] headerBuf = getRecord();\n\n        if (hasHitEOF) {\n            currEntry = null;\n            return null;\n        }\n\n        try {\n            currEntry = new TarArchiveEntry(headerBuf);\n        } catch (IllegalArgumentException e) {\n            IOException ioe = new IOException(\"Error detected parsing the header\");\n            ioe.initCause(e);\n            throw ioe;\n        }\n        entryOffset = 0;\n        entrySize = currEntry.getSize();\n\n        if (currEntry.isGNULongNameEntry()) {\n            \n            StringBuffer longName = new StringBuffer();\n            byte[] buf = new byte[SMALL_BUFFER_SIZE];\n            int length = 0;\n            while ((length = read(buf)) >= 0) {\n                longName.append(new String(buf, 0, length));\n            }\n            getNextEntry();\n            if (currEntry == null) {\n                \n                \n                return null;\n            }\n            \n            if (longName.length() > 0\n                && longName.charAt(longName.length() - 1) == 0) {\n                longName.deleteCharAt(longName.length() - 1);\n            }\n            currEntry.setName(longName.toString());\n        }\n\n        if (currEntry.isPaxHeader()){ \n            paxHeaders();\n        }\n\n        if (currEntry.isGNUSparse()){ \n            readGNUSparse();\n        }\n\n        \n        \n        \n        \n        entrySize = currEntry.getSize();\n        return currEntry;\n    }\n\n    \n    private byte[] getRecord() throws IOException {\n        if (hasHitEOF) {\n            return null;\n        }\n\n        byte[] headerBuf = buffer.readRecord();\n\n        if (headerBuf == null) {\n            hasHitEOF = true;\n        } else if (buffer.isEOFRecord(headerBuf)) {\n            hasHitEOF = true;\n        }\n\n        return hasHitEOF ? null : headerBuf;\n    }\n\n    private void paxHeaders() throws IOException {\n        Reader br = new InputStreamReader(this, \"UTF-8\") {\n                @Override\n                public void close() {\n                    \n                }\n            };\n        Map<String, String> headers = null;\n        try {\n            headers = parsePaxHeaders(br);\n        } finally {\n            \n            br.close();\n        }\n\n        getNextEntry(); \n        applyPaxHeadersToCurrentEntry(headers);\n    }\n\n    Map<String, String> parsePaxHeaders(Reader br) throws IOException {\n        Map<String, String> headers = new HashMap<String, String>();\n        \n        while(true){ \n            int ch;\n            int len = 0;\n            int read = 0;\n            while((ch = br.read()) != -1){\n                read++;\n                if (ch == ' '){ \n                    \n                    StringBuffer sb = new StringBuffer();\n                    while((ch = br.read()) != -1){\n                        read++;\n                        if (ch == '='){ \n                            String keyword = sb.toString();\n                            \n                            char[] cbuf = new char[len-read];\n                            int got = br.read(cbuf);\n                            if (got != len - read){\n                                throw new IOException(\"Failed to read \"\n                                                      + \"Paxheader. Expected \"\n                                                      + (len - read)\n                                                      + \" chars, read \"\n                                                      + got);\n                            }\n                            \n                            String value = new String(cbuf, 0,\n                                                      len - read - 1);\n                            headers.put(keyword, value);\n                            break;\n                        }\n                        sb.append((char) ch);\n                    }\n                    break; \n                }\n                len *= 10;\n                len += ch - '0';\n            }\n            if (ch == -1){ \n                break;\n            }\n        }\n        return headers;\n    }\n\n    private void applyPaxHeadersToCurrentEntry(Map<String, String> headers) {\n        \n        for (Entry<String, String> ent : headers.entrySet()){\n            String key = ent.getKey();\n            String val = ent.getValue();\n            if (\"path\".equals(key)){\n                currEntry.setName(val);\n            } else if (\"linkpath\".equals(key)){\n                currEntry.setLinkName(val);\n            } else if (\"gid\".equals(key)){\n                currEntry.setGroupId(Integer.parseInt(val));\n            } else if (\"gname\".equals(key)){\n                currEntry.setGroupName(val);\n            } else if (\"uid\".equals(key)){\n                currEntry.setUserId(Integer.parseInt(val));\n            } else if (\"uname\".equals(key)){\n                currEntry.setUserName(val);\n            } else if (\"size\".equals(key)){\n                currEntry.setSize(Long.parseLong(val));\n            }\n        }\n    }\n\n    \n    private void readGNUSparse() throws IOException {\n        \n        if (currEntry.isExtended()) {\n            TarArchiveSparseEntry entry;\n            do {\n                byte[] headerBuf = getRecord();\n                if (hasHitEOF) {\n                    currEntry = null;\n                    break;\n                }\n                entry = new TarArchiveSparseEntry(headerBuf);\n                \n            } while (entry.isExtended());\n        }\n    }\n\n    @Override\n    public ArchiveEntry getNextEntry() throws IOException {\n        return getNextTarEntry();\n    }\n\n    \n    @Override\n    public int read(byte[] buf, int offset, int numToRead) throws IOException {\n        int totalRead = 0;\n\n        if (entryOffset >= entrySize) {\n            return -1;\n        }\n\n        if ((numToRead + entryOffset) > entrySize) {\n            numToRead = (int) (entrySize - entryOffset);\n        }\n\n        if (readBuf != null) {\n            int sz = (numToRead > readBuf.length) ? readBuf.length\n                : numToRead;\n\n            System.arraycopy(readBuf, 0, buf, offset, sz);\n\n            if (sz >= readBuf.length) {\n                readBuf = null;\n            } else {\n                int newLen = readBuf.length - sz;\n                byte[] newBuf = new byte[newLen];\n\n                System.arraycopy(readBuf, sz, newBuf, 0, newLen);\n\n                readBuf = newBuf;\n            }\n\n            totalRead += sz;\n            numToRead -= sz;\n            offset += sz;\n        }\n\n        while (numToRead > 0) {\n            byte[] rec = buffer.readRecord();\n\n            if (rec == null) {\n                \n                throw new IOException(\"unexpected EOF with \" + numToRead\n                                      + \" bytes unread. Occured at byte: \" + getBytesRead());\n            }\n            count(rec.length);\n            int sz = numToRead;\n            int recLen = rec.length;\n\n            if (recLen > sz) {\n                System.arraycopy(rec, 0, buf, offset, sz);\n\n                readBuf = new byte[recLen - sz];\n\n                System.arraycopy(rec, sz, readBuf, 0, recLen - sz);\n            } else {\n                sz = recLen;\n\n                System.arraycopy(rec, 0, buf, offset, recLen);\n            }\n\n            totalRead += sz;\n            numToRead -= sz;\n            offset += sz;\n        }\n\n        entryOffset += totalRead;\n\n        return totalRead;\n    }\n\n    \n    @Override\n    public boolean canReadEntryData(ArchiveEntry ae) {\n        if (ae instanceof TarArchiveEntry) {\n            TarArchiveEntry te = (TarArchiveEntry) ae;\n            return !te.isGNUSparse();\n        }\n        return false;\n    }\n\n    protected final TarArchiveEntry getCurrentEntry() {\n        return currEntry;\n    }\n\n    protected final void setCurrentEntry(TarArchiveEntry e) {\n        currEntry = e;\n    }\n\n    protected final boolean isAtEOF() {\n        return hasHitEOF;\n    }\n\n    protected final void setAtEOF(boolean b) {\n        hasHitEOF = b;\n    }\n\n    \n    public static boolean matches(byte[] signature, int length) {\n        if (length < TarConstants.VERSION_OFFSET+TarConstants.VERSIONLEN) {\n            return false;\n        }\n\n        if (ArchiveUtils.matchAsciiBuffer(TarConstants.MAGIC_POSIX,\n                signature, TarConstants.MAGIC_OFFSET, TarConstants.MAGICLEN)\n            &&\n            ArchiveUtils.matchAsciiBuffer(TarConstants.VERSION_POSIX,\n                signature, TarConstants.VERSION_OFFSET, TarConstants.VERSIONLEN)\n                ){\n            return true;\n        }\n        if (ArchiveUtils.matchAsciiBuffer(TarConstants.MAGIC_GNU,\n                signature, TarConstants.MAGIC_OFFSET, TarConstants.MAGICLEN)\n            &&\n            (\n             ArchiveUtils.matchAsciiBuffer(TarConstants.VERSION_GNU_SPACE,\n                signature, TarConstants.VERSION_OFFSET, TarConstants.VERSIONLEN)\n            ||\n            ArchiveUtils.matchAsciiBuffer(TarConstants.VERSION_GNU_ZERO,\n                signature, TarConstants.VERSION_OFFSET, TarConstants.VERSIONLEN)\n            )\n                ){\n            return true;\n        }\n        \n        if (ArchiveUtils.matchAsciiBuffer(TarConstants.MAGIC_ANT,\n                signature, TarConstants.MAGIC_OFFSET, TarConstants.MAGICLEN)\n            &&\n            ArchiveUtils.matchAsciiBuffer(TarConstants.VERSION_ANT,\n                signature, TarConstants.VERSION_OFFSET, TarConstants.VERSIONLEN)\n                ){\n            return true;\n        }\n        return false;\n    }\n\n}\n",
      "buggy_signatures": [
        "public TarArchiveInputStream(InputStream is, int blockSize)",
        "public TarArchiveInputStream(InputStream is, int blockSize, int recordSize)",
        "public void close() throws IOException",
        "public int getRecordSize()",
        "public int available() throws IOException",
        "public long skip(long numToSkip) throws IOException",
        "public synchronized void reset()",
        "public TarArchiveEntry getNextTarEntry() throws IOException",
        "private byte[] getRecord() throws IOException",
        "private void paxHeaders() throws IOException",
        "public void close()",
        "private void applyPaxHeadersToCurrentEntry(Map<String, String> headers)",
        "private void readGNUSparse() throws IOException",
        "public ArchiveEntry getNextEntry() throws IOException",
        "public int read(byte[] buf, int offset, int numToRead) throws IOException",
        "public boolean canReadEntryData(ArchiveEntry ae)",
        "protected final TarArchiveEntry getCurrentEntry()",
        "protected final void setCurrentEntry(TarArchiveEntry e)",
        "protected final boolean isAtEOF()",
        "protected final void setAtEOF(boolean b)",
        "public static boolean matches(byte[] signature, int length)"
      ],
      "fixed_signatures": [
        "public TarArchiveInputStream(InputStream is, int blockSize)",
        "public TarArchiveInputStream(InputStream is, int blockSize, int recordSize)",
        "public void close() throws IOException",
        "public int getRecordSize()",
        "public int available() throws IOException",
        "public long skip(long numToSkip) throws IOException",
        "public synchronized void reset()",
        "public TarArchiveEntry getNextTarEntry() throws IOException",
        "private byte[] getRecord() throws IOException",
        "private void paxHeaders() throws IOException",
        "public void close()",
        "private void applyPaxHeadersToCurrentEntry(Map<String, String> headers)",
        "private void readGNUSparse() throws IOException",
        "public ArchiveEntry getNextEntry() throws IOException",
        "public int read(byte[] buf, int offset, int numToRead) throws IOException",
        "public boolean canReadEntryData(ArchiveEntry ae)",
        "protected final TarArchiveEntry getCurrentEntry()",
        "protected final void setCurrentEntry(TarArchiveEntry e)",
        "protected final boolean isAtEOF()",
        "protected final void setAtEOF(boolean b)",
        "public static boolean matches(byte[] signature, int length)"
      ],
      "methods": [
        {
          "buggy_method": "  public TarArchiveEntry getNextTarEntry() throws IOException {\n  if (hasHitEOF) {\n  return null;\n  }\n\n  if (currEntry != null) {\n  long numToSkip = entrySize - entryOffset;\n\n  while (numToSkip > 0) {\n  long skipped = skip(numToSkip);\n  if (skipped <= 0) {\n  throw new RuntimeException(\"failed to skip current tar entry\");\n  }\n  numToSkip -= skipped;\n  }\n\n  readBuf = null;\n  }\n\n  byte[] headerBuf = getRecord();\n\n  if (hasHitEOF) {\n  currEntry = null;\n  return null;\n  }\n\n  currEntry = new TarArchiveEntry(headerBuf);\n  entryOffset = 0;\n  entrySize = currEntry.getSize();\n\n  if (currEntry.isGNULongNameEntry()) {\n  \n  StringBuffer longName = new StringBuffer();\n  byte[] buf = new byte[SMALL_BUFFER_SIZE];\n  int length = 0;\n  while ((length = read(buf)) >= 0) {\n  longName.append(new String(buf, 0, length));\n  }\n  getNextEntry();\n  if (currEntry == null) {\n  \n  \n  return null;\n  }\n  \n  if (longName.length() > 0\n  && longName.charAt(longName.length() - 1) == 0) {\n  longName.deleteCharAt(longName.length() - 1);\n  }\n  currEntry.setName(longName.toString());\n  }\n\n  if (currEntry.isPaxHeader()){ \n  paxHeaders();\n  }\n\n  if (currEntry.isGNUSparse()){ \n  readGNUSparse();\n  }\n\n  \n  \n  \n  \n  entrySize = currEntry.getSize();\n  return currEntry;\n  }",
          "fixed_method": "  public TarArchiveEntry getNextTarEntry() throws IOException {\n  if (hasHitEOF) {\n  return null;\n  }\n\n  if (currEntry != null) {\n  long numToSkip = entrySize - entryOffset;\n\n  while (numToSkip > 0) {\n  long skipped = skip(numToSkip);\n  if (skipped <= 0) {\n  throw new RuntimeException(\"failed to skip current tar entry\");\n  }\n  numToSkip -= skipped;\n  }\n\n  readBuf = null;\n  }\n\n  byte[] headerBuf = getRecord();\n\n  if (hasHitEOF) {\n  currEntry = null;\n  return null;\n  }\n\n  try {\n  currEntry = new TarArchiveEntry(headerBuf);\n  } catch (IllegalArgumentException e) {\n  IOException ioe = new IOException(\"Error detected parsing the header\");\n  ioe.initCause(e);\n  throw ioe;\n  }\n  entryOffset = 0;\n  entrySize = currEntry.getSize();\n\n  if (currEntry.isGNULongNameEntry()) {\n  \n  StringBuffer longName = new StringBuffer();\n  byte[] buf = new byte[SMALL_BUFFER_SIZE];\n  int length = 0;\n  while ((length = read(buf)) >= 0) {\n  longName.append(new String(buf, 0, length));\n  }\n  getNextEntry();\n  if (currEntry == null) {\n  \n  \n  return null;\n  }\n  \n  if (longName.length() > 0\n  && longName.charAt(longName.length() - 1) == 0) {\n  longName.deleteCharAt(longName.length() - 1);\n  }\n  currEntry.setName(longName.toString());\n  }\n\n  if (currEntry.isPaxHeader()){ \n  paxHeaders();\n  }\n\n  if (currEntry.isGNUSparse()){ \n  readGNUSparse();\n  }\n\n  \n  \n  \n  \n  entrySize = currEntry.getSize();\n  return currEntry;\n  }",
          "diff": [
            "@@ -195,7 +195,13 @@",
            "             return null;\n",
            "         }\n",
            " \n",
            "-        currEntry = new TarArchiveEntry(headerBuf);\n",
            "+        try {\n",
            "+            currEntry = new TarArchiveEntry(headerBuf);\n",
            "+        } catch (IllegalArgumentException e) {\n",
            "+            IOException ioe = new IOException(\"Error detected parsing the header\");\n",
            "+            ioe.initCause(e);\n",
            "+            throw ioe;\n",
            "+        }\n",
            "         entryOffset = 0;\n",
            "         entrySize = currEntry.getSize();\n",
            " \n"
          ],
          "changed_lines": 8
        }
      ]
    }
  ]
}
