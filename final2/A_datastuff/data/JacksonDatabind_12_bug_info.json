{
  "bug_id": "12",
  "failed_tests": {
    "com.fasterxml.jackson.databind.deser.TestCustomDeserializers": [
      {
        "methodName": "testCustomMapValueDeser735",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<1> but was:<100>",
        "fail_line": "        assertEquals(1, bean.map2.get(\"a\").intValue());",
        "test_source": "  public void testCustomMapValueDeser735() throws Exception {\n  String json = \"{\\\"map1\\\":{\\\"a\\\":1},\\\"map2\\\":{\\\"a\\\":1}}\";\n  TestMapBean735 bean = MAPPER.readValue(json, TestMapBean735.class);\n\n  assertEquals(100, bean.map1.get(\"a\").intValue());\n  assertEquals(1, bean.map2.get(\"a\").intValue());\n  }",
        "stack": [
          "TestCustomDeserializers.testCustomMapValueDeser735 line 370"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "com/fasterxml/jackson/databind/deser/std/MapDeserializer.java",
      "buggy_full_code": "package com.fasterxml.jackson.databind.deser.std;\n\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.*;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\nimport com.fasterxml.jackson.databind.deser.*;\nimport com.fasterxml.jackson.databind.deser.impl.PropertyBasedCreator;\nimport com.fasterxml.jackson.databind.deser.impl.PropertyValueBuffer;\nimport com.fasterxml.jackson.databind.deser.impl.ReadableObjectId.Referring;\nimport com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\nimport com.fasterxml.jackson.databind.util.ArrayBuilders;\n\n\n@JacksonStdImpl\npublic class MapDeserializer extends ContainerDeserializerBase<Map<Object,Object>> implements ContextualDeserializer, ResolvableDeserializer { private static final long serialVersionUID = -3378654289961736240L; protected final JavaType _mapType; protected final KeyDeserializer _keyDeserializer; protected boolean _standardStringKey; protected final JsonDeserializer<Object> _valueDeserializer; protected final TypeDeserializer _valueTypeDeserializer; protected final ValueInstantiator _valueInstantiator; protected final boolean _hasDefaultCreator; protected JsonDeserializer<Object> _delegateDeserializer; protected PropertyBasedCreator _propertyBasedCreator; protected HashSet<String> _ignorableProperties; public MapDeserializer(JavaType mapType, ValueInstantiator valueInstantiator, KeyDeserializer keyDeser, JsonDeserializer<Object> valueDeser, TypeDeserializer valueTypeDeser) {\n        super(mapType);\n        _mapType = mapType;\n        _keyDeserializer = keyDeser;\n        _valueDeserializer = valueDeser;\n        _valueTypeDeserializer = valueTypeDeser;\n        _valueInstantiator = valueInstantiator;\n        _hasDefaultCreator = valueInstantiator.canCreateUsingDefault();\n        _delegateDeserializer = null;\n        _propertyBasedCreator = null;\n        _standardStringKey = _isStdKeyDeser(mapType, keyDeser);\n    }\n\n    \n    protected MapDeserializer(MapDeserializer src) {\n        super(src._mapType);\n        _mapType = src._mapType;\n        _keyDeserializer = src._keyDeserializer;\n        _valueDeserializer = src._valueDeserializer;\n        _valueTypeDeserializer = src._valueTypeDeserializer;\n        _valueInstantiator = src._valueInstantiator;\n        _propertyBasedCreator = src._propertyBasedCreator;\n        _delegateDeserializer = src._delegateDeserializer;\n        _hasDefaultCreator = src._hasDefaultCreator;\n        \n        _ignorableProperties = src._ignorableProperties;\n\n        _standardStringKey = src._standardStringKey;\n    }\n\n    protected MapDeserializer(MapDeserializer src, KeyDeserializer keyDeser, JsonDeserializer<Object> valueDeser, TypeDeserializer valueTypeDeser, HashSet<String> ignorable) {\n        super(src._mapType);\n        _mapType = src._mapType;\n        _keyDeserializer = keyDeser;\n        _valueDeserializer = valueDeser;\n        _valueTypeDeserializer = valueTypeDeser;\n        _valueInstantiator = src._valueInstantiator;\n        _propertyBasedCreator = src._propertyBasedCreator;\n        _delegateDeserializer = src._delegateDeserializer;\n        _hasDefaultCreator = src._hasDefaultCreator;\n        _ignorableProperties = ignorable;\n\n        _standardStringKey = _isStdKeyDeser(_mapType, keyDeser);\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    protected MapDeserializer withResolved(KeyDeserializer keyDeser, TypeDeserializer valueTypeDeser, JsonDeserializer<?> valueDeser, HashSet<String> ignorable) {\n        \n        if ((_keyDeserializer == keyDeser) && (_valueDeserializer == valueDeser)\n                && (_valueTypeDeserializer == valueTypeDeser) && (_ignorableProperties == ignorable)) {\n            return this;\n        }\n        return new MapDeserializer(this,\n                keyDeser, (JsonDeserializer<Object>) valueDeser, valueTypeDeser, ignorable);\n    }\n\n    \n    protected final boolean _isStdKeyDeser(JavaType mapType, KeyDeserializer keyDeser) {\n        if (keyDeser == null) {\n            return true;\n        }\n        JavaType keyType = mapType.getKeyType();\n        if (keyType == null) { \n            return true;\n        }\n        Class<?> rawKeyType = keyType.getRawClass();\n        return ((rawKeyType == String.class || rawKeyType == Object.class)\n                && isDefaultKeyDeserializer(keyDeser));\n    }\n\n    public void setIgnorableProperties(String[] ignorable) {\n        _ignorableProperties = (ignorable == null || ignorable.length == 0) ?\n            null : ArrayBuilders.arrayToSet(ignorable);\n    }\n\n    \n\n    @Override\n    public void resolve(DeserializationContext ctxt) throws JsonMappingException {\n        \n        if (_valueInstantiator.canCreateUsingDelegate()) {\n            JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig());\n            if (delegateType == null) {\n                throw new IllegalArgumentException(\"Invalid delegate-creator definition for \"+_mapType\n                        +\": value instantiator (\"+_valueInstantiator.getClass().getName()\n                        +\") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'\");\n            }\n            \n            _delegateDeserializer = findDeserializer(ctxt, delegateType, null);\n        }\n        if (_valueInstantiator.canCreateFromObjectWith()) {\n            SettableBeanProperty[] creatorProps = _valueInstantiator.getFromObjectArguments(ctxt.getConfig());\n            _propertyBasedCreator = PropertyBasedCreator.construct(ctxt, _valueInstantiator, creatorProps);\n        }\n        _standardStringKey = _isStdKeyDeser(_mapType, _keyDeserializer);\n    }\n\n    \n    @Override\n    public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException {\n        KeyDeserializer kd = _keyDeserializer;\n        if (kd == null) {\n            kd = ctxt.findKeyDeserializer(_mapType.getKeyType(), property);\n        } else {\n            if (kd instanceof ContextualKeyDeserializer) {\n                kd = ((ContextualKeyDeserializer) kd).createContextual(ctxt, property);\n            }\n        }\n        JsonDeserializer<?> vd = _valueDeserializer;\n        \n        vd = findConvertingContentDeserializer(ctxt, property, vd);\n        if (vd == null) {\n            vd = ctxt.findContextualValueDeserializer(_mapType.getContentType(), property);\n        } else { \n            vd = ctxt.handleSecondaryContextualization(vd, property);\n        }\n        TypeDeserializer vtd = _valueTypeDeserializer;\n        if (vtd != null) {\n            vtd = vtd.forProperty(property);\n        }\n        HashSet<String> ignored = _ignorableProperties;\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        if (intr != null && property != null) {\n            String[] moreToIgnore = intr.findPropertiesToIgnore(property.getMember());\n            if (moreToIgnore != null) {\n                ignored = (ignored == null) ? new HashSet<String>() : new HashSet<String>(ignored);\n                for (String str : moreToIgnore) {\n                    ignored.add(str);\n                }\n            }\n        }\n        return withResolved(kd, vtd, vd, ignored);\n    }\n    \n    \n\n    @Override\n    public JavaType getContentType() {\n        return _mapType.getContentType();\n    }\n\n    @Override\n    public JsonDeserializer<Object> getContentDeserializer() {\n        return _valueDeserializer;\n    }\n    \n    \n\n    \n    @Override\n    public boolean isCachable() {\n        \n        return (_valueTypeDeserializer == null)\n                && (_ignorableProperties == null);\n    }\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public Map<Object,Object> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException {\n        if (_propertyBasedCreator != null) {\n            return _deserializeUsingCreator(jp, ctxt);\n        }\n        if (_delegateDeserializer != null) {\n            return (Map<Object,Object>) _valueInstantiator.createUsingDelegate(ctxt,\n                    _delegateDeserializer.deserialize(jp, ctxt));\n        }\n        if (!_hasDefaultCreator) {\n            throw ctxt.instantiationException(getMapClass(), \"No default constructor found\");\n        }\n        \n        JsonToken t = jp.getCurrentToken();\n        if (t != JsonToken.START_OBJECT && t != JsonToken.FIELD_NAME && t != JsonToken.END_OBJECT) {\n            \n            if (t == JsonToken.VALUE_STRING) {\n                return (Map<Object,Object>) _valueInstantiator.createFromString(ctxt, jp.getText());\n            }\n            throw ctxt.mappingException(getMapClass());\n        }\n        final Map<Object,Object> result = (Map<Object,Object>) _valueInstantiator.createUsingDefault(ctxt);\n        if (_standardStringKey) {\n            _readAndBindStringMap(jp, ctxt, result);\n            return result;\n        }\n        _readAndBind(jp, ctxt, result);\n        return result;\n    }\n\n    @Override\n    public Map<Object,Object> deserialize(JsonParser jp, DeserializationContext ctxt, Map<Object,Object> result) throws IOException, JsonProcessingException {\n        \n        JsonToken t = jp.getCurrentToken();\n        if (t != JsonToken.START_OBJECT && t != JsonToken.FIELD_NAME) {\n            throw ctxt.mappingException(getMapClass());\n        }\n        if (_standardStringKey) {\n            _readAndBindStringMap(jp, ctxt, result);\n            return result;\n        }\n        _readAndBind(jp, ctxt, result);\n        return result;\n    }\n\n    @Override\n    public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException, JsonProcessingException {\n        \n        return typeDeserializer.deserializeTypedFromObject(jp, ctxt);\n    }\n    \n    \n\n    @SuppressWarnings(\"unchecked\")\n    public final Class<?> getMapClass() { return (Class<Map<Object,Object>>) _mapType.getRawClass(); }\n\n    @Override public JavaType getValueType() { return _mapType; }\n\n    \n\n    protected final void _readAndBind(JsonParser jp, DeserializationContext ctxt, Map<Object,Object> result) throws IOException, JsonProcessingException {\n        JsonToken t = jp.getCurrentToken();\n        if (t == JsonToken.START_OBJECT) {\n            t = jp.nextToken();\n        }\n        final KeyDeserializer keyDes = _keyDeserializer;\n        final JsonDeserializer<Object> valueDes = _valueDeserializer;\n        final TypeDeserializer typeDeser = _valueTypeDeserializer;\n\n        MapReferringAccumulator referringAccumulator = null;\n        boolean useObjectId = valueDes.getObjectIdReader() != null;\n        if (useObjectId) {\n            referringAccumulator = new MapReferringAccumulator(_mapType.getContentType().getRawClass(), result);\n        }\n        for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n            \n            String fieldName = jp.getCurrentName();\n            Object key = keyDes.deserializeKey(fieldName, ctxt);\n            \n            t = jp.nextToken();\n            if (_ignorableProperties != null && _ignorableProperties.contains(fieldName)) {\n                jp.skipChildren();\n                continue;\n            }\n            try{\n                \n                Object value;\n                if (t == JsonToken.VALUE_NULL) {\n                    value = valueDes.getNullValue();\n                } else if (typeDeser == null) {\n                    value = valueDes.deserialize(jp, ctxt);\n                } else {\n                    value = valueDes.deserializeWithType(jp, ctxt, typeDeser);\n                }\n                \n                if (useObjectId) {\n                    referringAccumulator.put(key, value);\n                } else {\n                    result.put(key, value);\n                }\n            } catch (UnresolvedForwardReference reference) {\n                handleUnresolvedReference(jp, referringAccumulator, key, reference);\n            } catch (Exception e) {\n                wrapAndThrow(e, result, fieldName);\n            }\n        }\n    }\n\n    \n    protected final void _readAndBindStringMap(JsonParser jp, DeserializationContext ctxt, Map<Object,Object> result) throws IOException, JsonProcessingException {\n        JsonToken t = jp.getCurrentToken();\n        if (t == JsonToken.START_OBJECT) {\n            t = jp.nextToken();\n        }\n        final JsonDeserializer<Object> valueDes = _valueDeserializer;\n        final TypeDeserializer typeDeser = _valueTypeDeserializer;\n        MapReferringAccumulator referringAccumulator = null;\n        boolean useObjectId = valueDes.getObjectIdReader() != null;\n        if (useObjectId) {\n            referringAccumulator = new MapReferringAccumulator(_mapType.getContentType().getRawClass(), result);\n        }\n        for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n            \n            String fieldName = jp.getCurrentName();\n            \n            t = jp.nextToken();\n            if (_ignorableProperties != null && _ignorableProperties.contains(fieldName)) {\n                jp.skipChildren();\n                continue;\n            }\n            try {\n                \n                Object value;\n                if (t == JsonToken.VALUE_NULL) {\n                    value = valueDes.getNullValue();\n                } else if (typeDeser == null) {\n                    value = valueDes.deserialize(jp, ctxt);\n                } else {\n                    value = valueDes.deserializeWithType(jp, ctxt, typeDeser);\n                }\n                if (useObjectId) {\n                    referringAccumulator.put(fieldName, value);\n                } else {\n                    result.put(fieldName, value);\n                }\n            } catch (UnresolvedForwardReference reference) {\n                handleUnresolvedReference(jp, referringAccumulator, fieldName, reference);\n            } catch (Exception e) {\n                wrapAndThrow(e, result, fieldName);\n            }\n        }\n    }\n    \n    @SuppressWarnings(\"unchecked\") \n    public Map<Object,Object> _deserializeUsingCreator(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException {\n        final PropertyBasedCreator creator = _propertyBasedCreator;\n        \n        PropertyValueBuffer buffer = creator.startBuilding(jp, ctxt, null);\n\n        JsonToken t = jp.getCurrentToken();\n        if (t == JsonToken.START_OBJECT) {\n            t = jp.nextToken();\n        }\n        final JsonDeserializer<Object> valueDes = _valueDeserializer;\n        final TypeDeserializer typeDeser = _valueTypeDeserializer;\n        for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n            String propName = jp.getCurrentName();\n            t = jp.nextToken(); \n            if (_ignorableProperties != null && _ignorableProperties.contains(propName)) {\n                jp.skipChildren(); \n                continue;\n            }\n            \n            SettableBeanProperty prop = creator.findCreatorProperty(propName);\n            if (prop != null) {\n                \n                Object value = prop.deserialize(jp, ctxt);\n                if (buffer.assignParameter(prop.getCreatorIndex(), value)) {\n                    jp.nextToken();\n                    Map<Object,Object> result;\n                    try {\n                        result = (Map<Object,Object>)creator.build(ctxt, buffer);\n                    } catch (Exception e) {\n                        wrapAndThrow(e, _mapType.getRawClass(), propName);\n                        return null;\n                    }\n                    _readAndBind(jp, ctxt, result);\n                    return result;\n                }\n                continue;\n            }\n            \n            String fieldName = jp.getCurrentName();\n            Object key = _keyDeserializer.deserializeKey(fieldName, ctxt);\n            Object value; \n\n            try {\n                if (t == JsonToken.VALUE_NULL) {\n                    value = valueDes.getNullValue();\n                } else if (typeDeser == null) {\n                    value = valueDes.deserialize(jp, ctxt);\n                } else {\n                    value = valueDes.deserializeWithType(jp, ctxt, typeDeser);\n                }\n            } catch (Exception e) {\n                wrapAndThrow(e, _mapType.getRawClass(), propName);\n                return null;\n            }\n            buffer.bufferMapProperty(key, value);\n        }\n        \n        \n        try {\n            return (Map<Object,Object>)creator.build(ctxt, buffer);\n        } catch (Exception e) {\n            wrapAndThrow(e, _mapType.getRawClass(), null);\n            return null;\n        }\n    }\n\n    @Deprecated \n    protected void wrapAndThrow(Throwable t, Object ref) throws IOException {\n        wrapAndThrow(t, ref, null);\n    }\n    \n    \n    protected void wrapAndThrow(Throwable t, Object ref, String key) throws IOException {\n        \n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        \n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        \n        if (t instanceof IOException && !(t instanceof JsonMappingException)) {\n            throw (IOException) t;\n        }\n        throw JsonMappingException.wrapWithPath(t, ref, key);\n    }\n\n    private void handleUnresolvedReference(JsonParser jp, MapReferringAccumulator accumulator, Object key, UnresolvedForwardReference reference) throws JsonMappingException {\n        if (accumulator == null) {\n            throw JsonMappingException.from(jp, \"Unresolved forward reference but no identity info.\", reference);\n        }\n        Referring referring = accumulator.handleUnresolvedReference(reference, key);\n        reference.getRoid().appendReferring(referring);\n    }\n\n    private final static class MapReferringAccumulator { private final Class<?> _valueType; private Map<Object,Object> _result; private List<MapReferring> _accumulator = new ArrayList<MapReferring>(); public MapReferringAccumulator(Class<?> valueType, Map<Object, Object> result) {\n            _valueType = valueType;\n            _result = result;\n        }\n\n        public void put(Object key, Object value) {\n            if (_accumulator.isEmpty()) {\n                _result.put(key, value);\n            } else {\n                MapReferring ref = _accumulator.get(_accumulator.size() - 1);\n                ref.next.put(key, value);\n            }\n        }\n\n        public Referring handleUnresolvedReference(UnresolvedForwardReference reference, Object key) {\n            MapReferring id = new MapReferring(this, reference, _valueType, key);\n            _accumulator.add(id);\n            return id;\n        }\n\n        public void resolveForwardReference(Object id, Object value) throws IOException {\n            Iterator<MapReferring> iterator = _accumulator.iterator();\n            \n            \n            \n            Map<Object,Object> previous = _result;\n            while (iterator.hasNext()) {\n                MapReferring ref = iterator.next();\n                if (ref.hasId(id)) {\n                    iterator.remove();\n                    previous.put(ref.key, value);\n                    previous.putAll(ref.next);\n                    return;\n                }\n                previous = ref.next;\n            }\n\n            throw new IllegalArgumentException(\"Trying to resolve a forward reference with id [\" + id\n                    + \"] that wasn't previously seen as unresolved.\");\n        }\n    }\n\n    \n    private final static class MapReferring extends Referring { private final MapReferringAccumulator _parent; public final Map<Object, Object> next = new LinkedHashMap<Object, Object>(); public final Object key; protected MapReferring(MapReferringAccumulator parent, UnresolvedForwardReference ref, Class<?> valueType, Object key) {\n            super(ref, valueType);\n            _parent = parent;\n            this.key = key;\n        }\n\n        @Override\n        public void handleResolvedForwardReference(Object id, Object value) throws IOException {\n            _parent.resolveForwardReference(id, value);\n        }\n    }\n}\n",
      "fixed_full_code": "package com.fasterxml.jackson.databind.deser.std;\n\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.*;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\nimport com.fasterxml.jackson.databind.deser.*;\nimport com.fasterxml.jackson.databind.deser.impl.PropertyBasedCreator;\nimport com.fasterxml.jackson.databind.deser.impl.PropertyValueBuffer;\nimport com.fasterxml.jackson.databind.deser.impl.ReadableObjectId.Referring;\nimport com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\nimport com.fasterxml.jackson.databind.util.ArrayBuilders;\n\n\n@JacksonStdImpl\npublic class MapDeserializer extends ContainerDeserializerBase<Map<Object,Object>> implements ContextualDeserializer, ResolvableDeserializer { private static final long serialVersionUID = -3378654289961736240L; protected final JavaType _mapType; protected final KeyDeserializer _keyDeserializer; protected boolean _standardStringKey; protected final JsonDeserializer<Object> _valueDeserializer; protected final TypeDeserializer _valueTypeDeserializer; protected final ValueInstantiator _valueInstantiator; protected final boolean _hasDefaultCreator; protected JsonDeserializer<Object> _delegateDeserializer; protected PropertyBasedCreator _propertyBasedCreator; protected HashSet<String> _ignorableProperties; public MapDeserializer(JavaType mapType, ValueInstantiator valueInstantiator, KeyDeserializer keyDeser, JsonDeserializer<Object> valueDeser, TypeDeserializer valueTypeDeser) {\n        super(mapType);\n        _mapType = mapType;\n        _keyDeserializer = keyDeser;\n        _valueDeserializer = valueDeser;\n        _valueTypeDeserializer = valueTypeDeser;\n        _valueInstantiator = valueInstantiator;\n        _hasDefaultCreator = valueInstantiator.canCreateUsingDefault();\n        _delegateDeserializer = null;\n        _propertyBasedCreator = null;\n        _standardStringKey = _isStdKeyDeser(mapType, keyDeser);\n    }\n\n    \n    protected MapDeserializer(MapDeserializer src) {\n        super(src._mapType);\n        _mapType = src._mapType;\n        _keyDeserializer = src._keyDeserializer;\n        _valueDeserializer = src._valueDeserializer;\n        _valueTypeDeserializer = src._valueTypeDeserializer;\n        _valueInstantiator = src._valueInstantiator;\n        _propertyBasedCreator = src._propertyBasedCreator;\n        _delegateDeserializer = src._delegateDeserializer;\n        _hasDefaultCreator = src._hasDefaultCreator;\n        \n        _ignorableProperties = src._ignorableProperties;\n\n        _standardStringKey = src._standardStringKey;\n    }\n\n    protected MapDeserializer(MapDeserializer src, KeyDeserializer keyDeser, JsonDeserializer<Object> valueDeser, TypeDeserializer valueTypeDeser, HashSet<String> ignorable) {\n        super(src._mapType);\n        _mapType = src._mapType;\n        _keyDeserializer = keyDeser;\n        _valueDeserializer = valueDeser;\n        _valueTypeDeserializer = valueTypeDeser;\n        _valueInstantiator = src._valueInstantiator;\n        _propertyBasedCreator = src._propertyBasedCreator;\n        _delegateDeserializer = src._delegateDeserializer;\n        _hasDefaultCreator = src._hasDefaultCreator;\n        _ignorableProperties = ignorable;\n\n        _standardStringKey = _isStdKeyDeser(_mapType, keyDeser);\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    protected MapDeserializer withResolved(KeyDeserializer keyDeser, TypeDeserializer valueTypeDeser, JsonDeserializer<?> valueDeser, HashSet<String> ignorable) {\n        \n        if ((_keyDeserializer == keyDeser) && (_valueDeserializer == valueDeser)\n                && (_valueTypeDeserializer == valueTypeDeser) && (_ignorableProperties == ignorable)) {\n            return this;\n        }\n        return new MapDeserializer(this,\n                keyDeser, (JsonDeserializer<Object>) valueDeser, valueTypeDeser, ignorable);\n    }\n\n    \n    protected final boolean _isStdKeyDeser(JavaType mapType, KeyDeserializer keyDeser) {\n        if (keyDeser == null) {\n            return true;\n        }\n        JavaType keyType = mapType.getKeyType();\n        if (keyType == null) { \n            return true;\n        }\n        Class<?> rawKeyType = keyType.getRawClass();\n        return ((rawKeyType == String.class || rawKeyType == Object.class)\n                && isDefaultKeyDeserializer(keyDeser));\n    }\n\n    public void setIgnorableProperties(String[] ignorable) {\n        _ignorableProperties = (ignorable == null || ignorable.length == 0) ?\n            null : ArrayBuilders.arrayToSet(ignorable);\n    }\n\n    \n\n    @Override\n    public void resolve(DeserializationContext ctxt) throws JsonMappingException {\n        \n        if (_valueInstantiator.canCreateUsingDelegate()) {\n            JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig());\n            if (delegateType == null) {\n                throw new IllegalArgumentException(\"Invalid delegate-creator definition for \"+_mapType\n                        +\": value instantiator (\"+_valueInstantiator.getClass().getName()\n                        +\") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'\");\n            }\n            \n            _delegateDeserializer = findDeserializer(ctxt, delegateType, null);\n        }\n        if (_valueInstantiator.canCreateFromObjectWith()) {\n            SettableBeanProperty[] creatorProps = _valueInstantiator.getFromObjectArguments(ctxt.getConfig());\n            _propertyBasedCreator = PropertyBasedCreator.construct(ctxt, _valueInstantiator, creatorProps);\n        }\n        _standardStringKey = _isStdKeyDeser(_mapType, _keyDeserializer);\n    }\n\n    \n    @Override\n    public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException {\n        KeyDeserializer kd = _keyDeserializer;\n        if (kd == null) {\n            kd = ctxt.findKeyDeserializer(_mapType.getKeyType(), property);\n        } else {\n            if (kd instanceof ContextualKeyDeserializer) {\n                kd = ((ContextualKeyDeserializer) kd).createContextual(ctxt, property);\n            }\n        }\n        JsonDeserializer<?> vd = _valueDeserializer;\n        \n        vd = findConvertingContentDeserializer(ctxt, property, vd);\n        if (vd == null) {\n            vd = ctxt.findContextualValueDeserializer(_mapType.getContentType(), property);\n        } else { \n            vd = ctxt.handleSecondaryContextualization(vd, property);\n        }\n        TypeDeserializer vtd = _valueTypeDeserializer;\n        if (vtd != null) {\n            vtd = vtd.forProperty(property);\n        }\n        HashSet<String> ignored = _ignorableProperties;\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        if (intr != null && property != null) {\n            String[] moreToIgnore = intr.findPropertiesToIgnore(property.getMember());\n            if (moreToIgnore != null) {\n                ignored = (ignored == null) ? new HashSet<String>() : new HashSet<String>(ignored);\n                for (String str : moreToIgnore) {\n                    ignored.add(str);\n                }\n            }\n        }\n        return withResolved(kd, vtd, vd, ignored);\n    }\n    \n    \n\n    @Override\n    public JavaType getContentType() {\n        return _mapType.getContentType();\n    }\n\n    @Override\n    public JsonDeserializer<Object> getContentDeserializer() {\n        return _valueDeserializer;\n    }\n    \n    \n\n    \n    @Override\n    public boolean isCachable() {\n        \n        return (_valueDeserializer == null)\n                && (_keyDeserializer == null)\n                && (_valueTypeDeserializer == null)\n                && (_ignorableProperties == null);\n    }\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public Map<Object,Object> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException {\n        if (_propertyBasedCreator != null) {\n            return _deserializeUsingCreator(jp, ctxt);\n        }\n        if (_delegateDeserializer != null) {\n            return (Map<Object,Object>) _valueInstantiator.createUsingDelegate(ctxt,\n                    _delegateDeserializer.deserialize(jp, ctxt));\n        }\n        if (!_hasDefaultCreator) {\n            throw ctxt.instantiationException(getMapClass(), \"No default constructor found\");\n        }\n        \n        JsonToken t = jp.getCurrentToken();\n        if (t != JsonToken.START_OBJECT && t != JsonToken.FIELD_NAME && t != JsonToken.END_OBJECT) {\n            \n            if (t == JsonToken.VALUE_STRING) {\n                return (Map<Object,Object>) _valueInstantiator.createFromString(ctxt, jp.getText());\n            }\n            throw ctxt.mappingException(getMapClass());\n        }\n        final Map<Object,Object> result = (Map<Object,Object>) _valueInstantiator.createUsingDefault(ctxt);\n        if (_standardStringKey) {\n            _readAndBindStringMap(jp, ctxt, result);\n            return result;\n        }\n        _readAndBind(jp, ctxt, result);\n        return result;\n    }\n\n    @Override\n    public Map<Object,Object> deserialize(JsonParser jp, DeserializationContext ctxt, Map<Object,Object> result) throws IOException, JsonProcessingException {\n        \n        JsonToken t = jp.getCurrentToken();\n        if (t != JsonToken.START_OBJECT && t != JsonToken.FIELD_NAME) {\n            throw ctxt.mappingException(getMapClass());\n        }\n        if (_standardStringKey) {\n            _readAndBindStringMap(jp, ctxt, result);\n            return result;\n        }\n        _readAndBind(jp, ctxt, result);\n        return result;\n    }\n\n    @Override\n    public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException, JsonProcessingException {\n        \n        return typeDeserializer.deserializeTypedFromObject(jp, ctxt);\n    }\n    \n    \n\n    @SuppressWarnings(\"unchecked\")\n    public final Class<?> getMapClass() { return (Class<Map<Object,Object>>) _mapType.getRawClass(); }\n\n    @Override public JavaType getValueType() { return _mapType; }\n\n    \n\n    protected final void _readAndBind(JsonParser jp, DeserializationContext ctxt, Map<Object,Object> result) throws IOException, JsonProcessingException {\n        JsonToken t = jp.getCurrentToken();\n        if (t == JsonToken.START_OBJECT) {\n            t = jp.nextToken();\n        }\n        final KeyDeserializer keyDes = _keyDeserializer;\n        final JsonDeserializer<Object> valueDes = _valueDeserializer;\n        final TypeDeserializer typeDeser = _valueTypeDeserializer;\n\n        MapReferringAccumulator referringAccumulator = null;\n        boolean useObjectId = valueDes.getObjectIdReader() != null;\n        if (useObjectId) {\n            referringAccumulator = new MapReferringAccumulator(_mapType.getContentType().getRawClass(), result);\n        }\n        for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n            \n            String fieldName = jp.getCurrentName();\n            Object key = keyDes.deserializeKey(fieldName, ctxt);\n            \n            t = jp.nextToken();\n            if (_ignorableProperties != null && _ignorableProperties.contains(fieldName)) {\n                jp.skipChildren();\n                continue;\n            }\n            try{\n                \n                Object value;\n                if (t == JsonToken.VALUE_NULL) {\n                    value = valueDes.getNullValue();\n                } else if (typeDeser == null) {\n                    value = valueDes.deserialize(jp, ctxt);\n                } else {\n                    value = valueDes.deserializeWithType(jp, ctxt, typeDeser);\n                }\n                \n                if (useObjectId) {\n                    referringAccumulator.put(key, value);\n                } else {\n                    result.put(key, value);\n                }\n            } catch (UnresolvedForwardReference reference) {\n                handleUnresolvedReference(jp, referringAccumulator, key, reference);\n            } catch (Exception e) {\n                wrapAndThrow(e, result, fieldName);\n            }\n        }\n    }\n\n    \n    protected final void _readAndBindStringMap(JsonParser jp, DeserializationContext ctxt, Map<Object,Object> result) throws IOException, JsonProcessingException {\n        JsonToken t = jp.getCurrentToken();\n        if (t == JsonToken.START_OBJECT) {\n            t = jp.nextToken();\n        }\n        final JsonDeserializer<Object> valueDes = _valueDeserializer;\n        final TypeDeserializer typeDeser = _valueTypeDeserializer;\n        MapReferringAccumulator referringAccumulator = null;\n        boolean useObjectId = valueDes.getObjectIdReader() != null;\n        if (useObjectId) {\n            referringAccumulator = new MapReferringAccumulator(_mapType.getContentType().getRawClass(), result);\n        }\n        for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n            \n            String fieldName = jp.getCurrentName();\n            \n            t = jp.nextToken();\n            if (_ignorableProperties != null && _ignorableProperties.contains(fieldName)) {\n                jp.skipChildren();\n                continue;\n            }\n            try {\n                \n                Object value;\n                if (t == JsonToken.VALUE_NULL) {\n                    value = valueDes.getNullValue();\n                } else if (typeDeser == null) {\n                    value = valueDes.deserialize(jp, ctxt);\n                } else {\n                    value = valueDes.deserializeWithType(jp, ctxt, typeDeser);\n                }\n                if (useObjectId) {\n                    referringAccumulator.put(fieldName, value);\n                } else {\n                    result.put(fieldName, value);\n                }\n            } catch (UnresolvedForwardReference reference) {\n                handleUnresolvedReference(jp, referringAccumulator, fieldName, reference);\n            } catch (Exception e) {\n                wrapAndThrow(e, result, fieldName);\n            }\n        }\n    }\n    \n    @SuppressWarnings(\"unchecked\") \n    public Map<Object,Object> _deserializeUsingCreator(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException {\n        final PropertyBasedCreator creator = _propertyBasedCreator;\n        \n        PropertyValueBuffer buffer = creator.startBuilding(jp, ctxt, null);\n\n        JsonToken t = jp.getCurrentToken();\n        if (t == JsonToken.START_OBJECT) {\n            t = jp.nextToken();\n        }\n        final JsonDeserializer<Object> valueDes = _valueDeserializer;\n        final TypeDeserializer typeDeser = _valueTypeDeserializer;\n        for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n            String propName = jp.getCurrentName();\n            t = jp.nextToken(); \n            if (_ignorableProperties != null && _ignorableProperties.contains(propName)) {\n                jp.skipChildren(); \n                continue;\n            }\n            \n            SettableBeanProperty prop = creator.findCreatorProperty(propName);\n            if (prop != null) {\n                \n                Object value = prop.deserialize(jp, ctxt);\n                if (buffer.assignParameter(prop.getCreatorIndex(), value)) {\n                    jp.nextToken();\n                    Map<Object,Object> result;\n                    try {\n                        result = (Map<Object,Object>)creator.build(ctxt, buffer);\n                    } catch (Exception e) {\n                        wrapAndThrow(e, _mapType.getRawClass(), propName);\n                        return null;\n                    }\n                    _readAndBind(jp, ctxt, result);\n                    return result;\n                }\n                continue;\n            }\n            \n            String fieldName = jp.getCurrentName();\n            Object key = _keyDeserializer.deserializeKey(fieldName, ctxt);\n            Object value; \n\n            try {\n                if (t == JsonToken.VALUE_NULL) {\n                    value = valueDes.getNullValue();\n                } else if (typeDeser == null) {\n                    value = valueDes.deserialize(jp, ctxt);\n                } else {\n                    value = valueDes.deserializeWithType(jp, ctxt, typeDeser);\n                }\n            } catch (Exception e) {\n                wrapAndThrow(e, _mapType.getRawClass(), propName);\n                return null;\n            }\n            buffer.bufferMapProperty(key, value);\n        }\n        \n        \n        try {\n            return (Map<Object,Object>)creator.build(ctxt, buffer);\n        } catch (Exception e) {\n            wrapAndThrow(e, _mapType.getRawClass(), null);\n            return null;\n        }\n    }\n\n    @Deprecated \n    protected void wrapAndThrow(Throwable t, Object ref) throws IOException {\n        wrapAndThrow(t, ref, null);\n    }\n    \n    \n    protected void wrapAndThrow(Throwable t, Object ref, String key) throws IOException {\n        \n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        \n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        \n        if (t instanceof IOException && !(t instanceof JsonMappingException)) {\n            throw (IOException) t;\n        }\n        throw JsonMappingException.wrapWithPath(t, ref, key);\n    }\n\n    private void handleUnresolvedReference(JsonParser jp, MapReferringAccumulator accumulator, Object key, UnresolvedForwardReference reference) throws JsonMappingException {\n        if (accumulator == null) {\n            throw JsonMappingException.from(jp, \"Unresolved forward reference but no identity info.\", reference);\n        }\n        Referring referring = accumulator.handleUnresolvedReference(reference, key);\n        reference.getRoid().appendReferring(referring);\n    }\n\n    private final static class MapReferringAccumulator { private final Class<?> _valueType; private Map<Object,Object> _result; private List<MapReferring> _accumulator = new ArrayList<MapReferring>(); public MapReferringAccumulator(Class<?> valueType, Map<Object, Object> result) {\n            _valueType = valueType;\n            _result = result;\n        }\n\n        public void put(Object key, Object value) {\n            if (_accumulator.isEmpty()) {\n                _result.put(key, value);\n            } else {\n                MapReferring ref = _accumulator.get(_accumulator.size() - 1);\n                ref.next.put(key, value);\n            }\n        }\n\n        public Referring handleUnresolvedReference(UnresolvedForwardReference reference, Object key) {\n            MapReferring id = new MapReferring(this, reference, _valueType, key);\n            _accumulator.add(id);\n            return id;\n        }\n\n        public void resolveForwardReference(Object id, Object value) throws IOException {\n            Iterator<MapReferring> iterator = _accumulator.iterator();\n            \n            \n            \n            Map<Object,Object> previous = _result;\n            while (iterator.hasNext()) {\n                MapReferring ref = iterator.next();\n                if (ref.hasId(id)) {\n                    iterator.remove();\n                    previous.put(ref.key, value);\n                    previous.putAll(ref.next);\n                    return;\n                }\n                previous = ref.next;\n            }\n\n            throw new IllegalArgumentException(\"Trying to resolve a forward reference with id [\" + id\n                    + \"] that wasn't previously seen as unresolved.\");\n        }\n    }\n\n    \n    private final static class MapReferring extends Referring { private final MapReferringAccumulator _parent; public final Map<Object, Object> next = new LinkedHashMap<Object, Object>(); public final Object key; protected MapReferring(MapReferringAccumulator parent, UnresolvedForwardReference ref, Class<?> valueType, Object key) {\n            super(ref, valueType);\n            _parent = parent;\n            this.key = key;\n        }\n\n        @Override\n        public void handleResolvedForwardReference(Object id, Object value) throws IOException {\n            _parent.resolveForwardReference(id, value);\n        }\n    }\n}\n",
      "buggy_signatures": [
        "protected MapDeserializer(MapDeserializer src)",
        "protected MapDeserializer(MapDeserializer src, KeyDeserializer keyDeser, JsonDeserializer<Object> valueDeser, TypeDeserializer valueTypeDeser, HashSet<String> ignorable)",
        "protected MapDeserializer withResolved(KeyDeserializer keyDeser, TypeDeserializer valueTypeDeser, JsonDeserializer<?> valueDeser, HashSet<String> ignorable)",
        "protected final boolean _isStdKeyDeser(JavaType mapType, KeyDeserializer keyDeser)",
        "public void setIgnorableProperties(String[] ignorable)",
        "public void resolve(DeserializationContext ctxt) throws JsonMappingException",
        "public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException",
        "public JavaType getContentType()",
        "public JsonDeserializer<Object> getContentDeserializer()",
        "public boolean isCachable()",
        "public Map<Object,Object> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException",
        "public Map<Object,Object> deserialize(JsonParser jp, DeserializationContext ctxt, Map<Object,Object> result) throws IOException, JsonProcessingException",
        "public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException, JsonProcessingException",
        "public final Class<?> getMapClass()",
        "public JavaType getValueType()",
        "protected final void _readAndBind(JsonParser jp, DeserializationContext ctxt, Map<Object,Object> result) throws IOException, JsonProcessingException",
        "protected final void _readAndBindStringMap(JsonParser jp, DeserializationContext ctxt, Map<Object,Object> result) throws IOException, JsonProcessingException",
        "public Map<Object,Object> _deserializeUsingCreator(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException",
        "protected void wrapAndThrow(Throwable t, Object ref) throws IOException",
        "protected void wrapAndThrow(Throwable t, Object ref, String key) throws IOException",
        "private void handleUnresolvedReference(JsonParser jp, MapReferringAccumulator accumulator, Object key, UnresolvedForwardReference reference) throws JsonMappingException",
        "public void put(Object key, Object value)",
        "public Referring handleUnresolvedReference(UnresolvedForwardReference reference, Object key)",
        "public void resolveForwardReference(Object id, Object value) throws IOException",
        "public void handleResolvedForwardReference(Object id, Object value) throws IOException"
      ],
      "fixed_signatures": [
        "protected MapDeserializer(MapDeserializer src)",
        "protected MapDeserializer(MapDeserializer src, KeyDeserializer keyDeser, JsonDeserializer<Object> valueDeser, TypeDeserializer valueTypeDeser, HashSet<String> ignorable)",
        "protected MapDeserializer withResolved(KeyDeserializer keyDeser, TypeDeserializer valueTypeDeser, JsonDeserializer<?> valueDeser, HashSet<String> ignorable)",
        "protected final boolean _isStdKeyDeser(JavaType mapType, KeyDeserializer keyDeser)",
        "public void setIgnorableProperties(String[] ignorable)",
        "public void resolve(DeserializationContext ctxt) throws JsonMappingException",
        "public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException",
        "public JavaType getContentType()",
        "public JsonDeserializer<Object> getContentDeserializer()",
        "public boolean isCachable()",
        "public Map<Object,Object> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException",
        "public Map<Object,Object> deserialize(JsonParser jp, DeserializationContext ctxt, Map<Object,Object> result) throws IOException, JsonProcessingException",
        "public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException, JsonProcessingException",
        "public final Class<?> getMapClass()",
        "public JavaType getValueType()",
        "protected final void _readAndBind(JsonParser jp, DeserializationContext ctxt, Map<Object,Object> result) throws IOException, JsonProcessingException",
        "protected final void _readAndBindStringMap(JsonParser jp, DeserializationContext ctxt, Map<Object,Object> result) throws IOException, JsonProcessingException",
        "public Map<Object,Object> _deserializeUsingCreator(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException",
        "protected void wrapAndThrow(Throwable t, Object ref) throws IOException",
        "protected void wrapAndThrow(Throwable t, Object ref, String key) throws IOException",
        "private void handleUnresolvedReference(JsonParser jp, MapReferringAccumulator accumulator, Object key, UnresolvedForwardReference reference) throws JsonMappingException",
        "public void put(Object key, Object value)",
        "public Referring handleUnresolvedReference(UnresolvedForwardReference reference, Object key)",
        "public void resolveForwardReference(Object id, Object value) throws IOException",
        "public void handleResolvedForwardReference(Object id, Object value) throws IOException"
      ],
      "methods": [
        {
          "buggy_method": "  public boolean isCachable() {\n  \n  return (_valueTypeDeserializer == null)\n  && (_ignorableProperties == null);\n  }",
          "fixed_method": "  public boolean isCachable() {\n  \n  return (_valueDeserializer == null)\n  && (_keyDeserializer == null)\n  && (_valueTypeDeserializer == null)\n  && (_ignorableProperties == null);\n  }",
          "diff": [
            "@@ -300,7 +300,9 @@",
            "         /* As per [databind#735], existence of value or key deserializer (only passed\n",
            "          * if annotated to use non-standard one) should also prevent caching.\n",
            "          */\n",
            "-        return (_valueTypeDeserializer == null)\n",
            "+        return (_valueDeserializer == null)\n",
            "+                && (_keyDeserializer == null)\n",
            "+                && (_valueTypeDeserializer == null)\n",
            "                 && (_ignorableProperties == null);\n",
            "     }\n",
            " \n"
          ],
          "changed_lines": 4
        }
      ]
    }
  ]
}
