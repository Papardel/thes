{
  "bug_id": "12",
  "failed_tests": {
    "com.google.gson.internal.bind.JsonTreeReaderTest": [
      {
        "methodName": "testSkipValue_filledJsonObject",
        "error": "java.lang.ArrayIndexOutOfBoundsException",
        "message": "Index -1 out of bounds for length 32",
        "fail_line": "    in.skipValue();",
        "test_source": "  public void testSkipValue_filledJsonObject() throws IOException {\n  JsonObject jsonObject = new JsonObject();\n  JsonArray jsonArray = new JsonArray();\n  jsonArray.add('c');\n  jsonArray.add(\"text\");\n  jsonObject.add(\"a\", jsonArray);\n  jsonObject.addProperty(\"b\", true);\n  jsonObject.addProperty(\"i\", 1);\n  jsonObject.add(\"n\", JsonNull.INSTANCE);\n  JsonObject jsonObject2 = new JsonObject();\n  jsonObject2.addProperty(\"n\", 2L);\n  jsonObject.add(\"o\", jsonObject2);\n  jsonObject.addProperty(\"s\", \"text\");\n  JsonTreeReader in = new JsonTreeReader(jsonObject);\n  in.skipValue();\n  assertEquals(JsonToken.END_DOCUMENT, in.peek());\n  }",
        "stack": [
          "JsonTreeReader.skipValue line 262, JsonTreeReaderTest.testSkipValue_filledJsonObject line 47"
        ]
      },
      {
        "methodName": "testSkipValue_emptyJsonObject",
        "error": "java.lang.ArrayIndexOutOfBoundsException",
        "message": "Index -1 out of bounds for length 32",
        "fail_line": "    in.skipValue();",
        "test_source": "  public void testSkipValue_emptyJsonObject() throws IOException {\n  JsonTreeReader in = new JsonTreeReader(new JsonObject());\n  in.skipValue();\n  assertEquals(JsonToken.END_DOCUMENT, in.peek());\n  }",
        "stack": [
          "JsonTreeReader.skipValue line 262, JsonTreeReaderTest.testSkipValue_emptyJsonObject line 29"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "com/google/gson/internal/bind/JsonTreeReader.java",
      "buggy_full_code": "\n\npackage com.google.gson.internal.bind;\n\nimport com.google.gson.JsonArray;\nimport com.google.gson.JsonElement;\nimport com.google.gson.JsonNull;\nimport com.google.gson.JsonObject;\nimport com.google.gson.JsonPrimitive;\nimport com.google.gson.stream.JsonReader;\nimport com.google.gson.stream.JsonToken;\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.util.Iterator;\nimport java.util.Map;\n\n\npublic final class JsonTreeReader extends JsonReader { private static final Reader UNREADABLE_READER = new Reader() {\n    @Override public int read(char[] buffer, int offset, int count) throws IOException {\n      throw new AssertionError();\n    }\n    @Override public void close() throws IOException {\n      throw new AssertionError();\n    }\n  };\n  private static final Object SENTINEL_CLOSED = new Object(); private Object[] stack = new Object[32]; private int stackSize = 0; private String[] pathNames = new String[32]; private int[] pathIndices = new int[32]; public JsonTreeReader(JsonElement element) {\n    super(UNREADABLE_READER);\n    push(element);\n  }\n\n  @Override public void beginArray() throws IOException {\n    expect(JsonToken.BEGIN_ARRAY);\n    JsonArray array = (JsonArray) peekStack();\n    push(array.iterator());\n    pathIndices[stackSize - 1] = 0;\n  }\n\n  @Override public void endArray() throws IOException {\n    expect(JsonToken.END_ARRAY);\n    popStack(); \n    popStack(); \n    if (stackSize > 0) {\n      pathIndices[stackSize - 1]++;\n    }\n  }\n\n  @Override public void beginObject() throws IOException {\n    expect(JsonToken.BEGIN_OBJECT);\n    JsonObject object = (JsonObject) peekStack();\n    push(object.entrySet().iterator());\n  }\n\n  @Override public void endObject() throws IOException {\n    expect(JsonToken.END_OBJECT);\n    popStack(); \n    popStack(); \n    if (stackSize > 0) {\n      pathIndices[stackSize - 1]++;\n    }\n  }\n\n  @Override public boolean hasNext() throws IOException {\n    JsonToken token = peek();\n    return token != JsonToken.END_OBJECT && token != JsonToken.END_ARRAY;\n  }\n\n  @Override public JsonToken peek() throws IOException {\n    if (stackSize == 0) {\n      return JsonToken.END_DOCUMENT;\n    }\n\n    Object o = peekStack();\n    if (o instanceof Iterator) {\n      boolean isObject = stack[stackSize - 2] instanceof JsonObject;\n      Iterator<?> iterator = (Iterator<?>) o;\n      if (iterator.hasNext()) {\n        if (isObject) {\n          return JsonToken.NAME;\n        } else {\n          push(iterator.next());\n          return peek();\n        }\n      } else {\n        return isObject ? JsonToken.END_OBJECT : JsonToken.END_ARRAY;\n      }\n    } else if (o instanceof JsonObject) {\n      return JsonToken.BEGIN_OBJECT;\n    } else if (o instanceof JsonArray) {\n      return JsonToken.BEGIN_ARRAY;\n    } else if (o instanceof JsonPrimitive) {\n      JsonPrimitive primitive = (JsonPrimitive) o;\n      if (primitive.isString()) {\n        return JsonToken.STRING;\n      } else if (primitive.isBoolean()) {\n        return JsonToken.BOOLEAN;\n      } else if (primitive.isNumber()) {\n        return JsonToken.NUMBER;\n      } else {\n        throw new AssertionError();\n      }\n    } else if (o instanceof JsonNull) {\n      return JsonToken.NULL;\n    } else if (o == SENTINEL_CLOSED) {\n      throw new IllegalStateException(\"JsonReader is closed\");\n    } else {\n      throw new AssertionError();\n    }\n  }\n\n  private Object peekStack() {\n    return stack[stackSize - 1];\n  }\n\n  private Object popStack() {\n    Object result = stack[--stackSize];\n    stack[stackSize] = null;\n    return result;\n  }\n\n  private void expect(JsonToken expected) throws IOException {\n    if (peek() != expected) {\n      throw new IllegalStateException(\n          \"Expected \" + expected + \" but was \" + peek() + locationString());\n    }\n  }\n\n  @Override public String nextName() throws IOException {\n    expect(JsonToken.NAME);\n    Iterator<?> i = (Iterator<?>) peekStack();\n    Map.Entry<?, ?> entry = (Map.Entry<?, ?>) i.next();\n    String result = (String) entry.getKey();\n    pathNames[stackSize - 1] = result;\n    push(entry.getValue());\n    return result;\n  }\n\n  @Override public String nextString() throws IOException {\n    JsonToken token = peek();\n    if (token != JsonToken.STRING && token != JsonToken.NUMBER) {\n      throw new IllegalStateException(\n          \"Expected \" + JsonToken.STRING + \" but was \" + token + locationString());\n    }\n    String result = ((JsonPrimitive) popStack()).getAsString();\n    if (stackSize > 0) {\n      pathIndices[stackSize - 1]++;\n    }\n    return result;\n  }\n\n  @Override public boolean nextBoolean() throws IOException {\n    expect(JsonToken.BOOLEAN);\n    boolean result = ((JsonPrimitive) popStack()).getAsBoolean();\n    if (stackSize > 0) {\n      pathIndices[stackSize - 1]++;\n    }\n    return result;\n  }\n\n  @Override public void nextNull() throws IOException {\n    expect(JsonToken.NULL);\n    popStack();\n    if (stackSize > 0) {\n      pathIndices[stackSize - 1]++;\n    }\n  }\n\n  @Override public double nextDouble() throws IOException {\n    JsonToken token = peek();\n    if (token != JsonToken.NUMBER && token != JsonToken.STRING) {\n      throw new IllegalStateException(\n          \"Expected \" + JsonToken.NUMBER + \" but was \" + token + locationString());\n    }\n    double result = ((JsonPrimitive) peekStack()).getAsDouble();\n    if (!isLenient() && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + result);\n    }\n    popStack();\n    if (stackSize > 0) {\n      pathIndices[stackSize - 1]++;\n    }\n    return result;\n  }\n\n  @Override public long nextLong() throws IOException {\n    JsonToken token = peek();\n    if (token != JsonToken.NUMBER && token != JsonToken.STRING) {\n      throw new IllegalStateException(\n          \"Expected \" + JsonToken.NUMBER + \" but was \" + token + locationString());\n    }\n    long result = ((JsonPrimitive) peekStack()).getAsLong();\n    popStack();\n    if (stackSize > 0) {\n      pathIndices[stackSize - 1]++;\n    }\n    return result;\n  }\n\n  @Override public int nextInt() throws IOException {\n    JsonToken token = peek();\n    if (token != JsonToken.NUMBER && token != JsonToken.STRING) {\n      throw new IllegalStateException(\n          \"Expected \" + JsonToken.NUMBER + \" but was \" + token + locationString());\n    }\n    int result = ((JsonPrimitive) peekStack()).getAsInt();\n    popStack();\n    if (stackSize > 0) {\n      pathIndices[stackSize - 1]++;\n    }\n    return result;\n  }\n\n  @Override public void close() throws IOException {\n    stack = new Object[] { SENTINEL_CLOSED };\n    stackSize = 1;\n  }\n\n  @Override public void skipValue() throws IOException {\n    if (peek() == JsonToken.NAME) {\n      nextName();\n      pathNames[stackSize - 2] = \"null\";\n    } else {\n      popStack();\n        pathNames[stackSize - 1] = \"null\";\n    }\n      pathIndices[stackSize - 1]++;\n  }\n\n  @Override public String toString() {\n    return getClass().getSimpleName();\n  }\n\n  public void promoteNameToValue() throws IOException {\n    expect(JsonToken.NAME);\n    Iterator<?> i = (Iterator<?>) peekStack();\n    Map.Entry<?, ?> entry = (Map.Entry<?, ?>) i.next();\n    push(entry.getValue());\n    push(new JsonPrimitive((String) entry.getKey()));\n  }\n\n  private void push(Object newTop) {\n    if (stackSize == stack.length) {\n      Object[] newStack = new Object[stackSize * 2];\n      int[] newPathIndices = new int[stackSize * 2];\n      String[] newPathNames = new String[stackSize * 2];\n      System.arraycopy(stack, 0, newStack, 0, stackSize);\n      System.arraycopy(pathIndices, 0, newPathIndices, 0, stackSize);\n      System.arraycopy(pathNames, 0, newPathNames, 0, stackSize);\n      stack = newStack;\n      pathIndices = newPathIndices;\n      pathNames = newPathNames;\n    }\n    stack[stackSize++] = newTop;\n  }\n\n  @Override public String getPath() {\n    StringBuilder result = new StringBuilder().append('$');\n    for (int i = 0; i < stackSize; i++) {\n      if (stack[i] instanceof JsonArray) {\n        if (stack[++i] instanceof Iterator) {\n          result.append('[').append(pathIndices[i]).append(']');\n        }\n      } else if (stack[i] instanceof JsonObject) {\n        if (stack[++i] instanceof Iterator) {\n          result.append('.');\n          if (pathNames[i] != null) {\n            result.append(pathNames[i]);\n          }\n        }\n      }\n    }\n    return result.toString();\n  }\n\n  private String locationString() {\n    return \" at path \" + getPath();\n  }\n}\n",
      "fixed_full_code": "\n\npackage com.google.gson.internal.bind;\n\nimport com.google.gson.JsonArray;\nimport com.google.gson.JsonElement;\nimport com.google.gson.JsonNull;\nimport com.google.gson.JsonObject;\nimport com.google.gson.JsonPrimitive;\nimport com.google.gson.stream.JsonReader;\nimport com.google.gson.stream.JsonToken;\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.util.Iterator;\nimport java.util.Map;\n\n\npublic final class JsonTreeReader extends JsonReader { private static final Reader UNREADABLE_READER = new Reader() {\n    @Override public int read(char[] buffer, int offset, int count) throws IOException {\n      throw new AssertionError();\n    }\n    @Override public void close() throws IOException {\n      throw new AssertionError();\n    }\n  };\n  private static final Object SENTINEL_CLOSED = new Object(); private Object[] stack = new Object[32]; private int stackSize = 0; private String[] pathNames = new String[32]; private int[] pathIndices = new int[32]; public JsonTreeReader(JsonElement element) {\n    super(UNREADABLE_READER);\n    push(element);\n  }\n\n  @Override public void beginArray() throws IOException {\n    expect(JsonToken.BEGIN_ARRAY);\n    JsonArray array = (JsonArray) peekStack();\n    push(array.iterator());\n    pathIndices[stackSize - 1] = 0;\n  }\n\n  @Override public void endArray() throws IOException {\n    expect(JsonToken.END_ARRAY);\n    popStack(); \n    popStack(); \n    if (stackSize > 0) {\n      pathIndices[stackSize - 1]++;\n    }\n  }\n\n  @Override public void beginObject() throws IOException {\n    expect(JsonToken.BEGIN_OBJECT);\n    JsonObject object = (JsonObject) peekStack();\n    push(object.entrySet().iterator());\n  }\n\n  @Override public void endObject() throws IOException {\n    expect(JsonToken.END_OBJECT);\n    popStack(); \n    popStack(); \n    if (stackSize > 0) {\n      pathIndices[stackSize - 1]++;\n    }\n  }\n\n  @Override public boolean hasNext() throws IOException {\n    JsonToken token = peek();\n    return token != JsonToken.END_OBJECT && token != JsonToken.END_ARRAY;\n  }\n\n  @Override public JsonToken peek() throws IOException {\n    if (stackSize == 0) {\n      return JsonToken.END_DOCUMENT;\n    }\n\n    Object o = peekStack();\n    if (o instanceof Iterator) {\n      boolean isObject = stack[stackSize - 2] instanceof JsonObject;\n      Iterator<?> iterator = (Iterator<?>) o;\n      if (iterator.hasNext()) {\n        if (isObject) {\n          return JsonToken.NAME;\n        } else {\n          push(iterator.next());\n          return peek();\n        }\n      } else {\n        return isObject ? JsonToken.END_OBJECT : JsonToken.END_ARRAY;\n      }\n    } else if (o instanceof JsonObject) {\n      return JsonToken.BEGIN_OBJECT;\n    } else if (o instanceof JsonArray) {\n      return JsonToken.BEGIN_ARRAY;\n    } else if (o instanceof JsonPrimitive) {\n      JsonPrimitive primitive = (JsonPrimitive) o;\n      if (primitive.isString()) {\n        return JsonToken.STRING;\n      } else if (primitive.isBoolean()) {\n        return JsonToken.BOOLEAN;\n      } else if (primitive.isNumber()) {\n        return JsonToken.NUMBER;\n      } else {\n        throw new AssertionError();\n      }\n    } else if (o instanceof JsonNull) {\n      return JsonToken.NULL;\n    } else if (o == SENTINEL_CLOSED) {\n      throw new IllegalStateException(\"JsonReader is closed\");\n    } else {\n      throw new AssertionError();\n    }\n  }\n\n  private Object peekStack() {\n    return stack[stackSize - 1];\n  }\n\n  private Object popStack() {\n    Object result = stack[--stackSize];\n    stack[stackSize] = null;\n    return result;\n  }\n\n  private void expect(JsonToken expected) throws IOException {\n    if (peek() != expected) {\n      throw new IllegalStateException(\n          \"Expected \" + expected + \" but was \" + peek() + locationString());\n    }\n  }\n\n  @Override public String nextName() throws IOException {\n    expect(JsonToken.NAME);\n    Iterator<?> i = (Iterator<?>) peekStack();\n    Map.Entry<?, ?> entry = (Map.Entry<?, ?>) i.next();\n    String result = (String) entry.getKey();\n    pathNames[stackSize - 1] = result;\n    push(entry.getValue());\n    return result;\n  }\n\n  @Override public String nextString() throws IOException {\n    JsonToken token = peek();\n    if (token != JsonToken.STRING && token != JsonToken.NUMBER) {\n      throw new IllegalStateException(\n          \"Expected \" + JsonToken.STRING + \" but was \" + token + locationString());\n    }\n    String result = ((JsonPrimitive) popStack()).getAsString();\n    if (stackSize > 0) {\n      pathIndices[stackSize - 1]++;\n    }\n    return result;\n  }\n\n  @Override public boolean nextBoolean() throws IOException {\n    expect(JsonToken.BOOLEAN);\n    boolean result = ((JsonPrimitive) popStack()).getAsBoolean();\n    if (stackSize > 0) {\n      pathIndices[stackSize - 1]++;\n    }\n    return result;\n  }\n\n  @Override public void nextNull() throws IOException {\n    expect(JsonToken.NULL);\n    popStack();\n    if (stackSize > 0) {\n      pathIndices[stackSize - 1]++;\n    }\n  }\n\n  @Override public double nextDouble() throws IOException {\n    JsonToken token = peek();\n    if (token != JsonToken.NUMBER && token != JsonToken.STRING) {\n      throw new IllegalStateException(\n          \"Expected \" + JsonToken.NUMBER + \" but was \" + token + locationString());\n    }\n    double result = ((JsonPrimitive) peekStack()).getAsDouble();\n    if (!isLenient() && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + result);\n    }\n    popStack();\n    if (stackSize > 0) {\n      pathIndices[stackSize - 1]++;\n    }\n    return result;\n  }\n\n  @Override public long nextLong() throws IOException {\n    JsonToken token = peek();\n    if (token != JsonToken.NUMBER && token != JsonToken.STRING) {\n      throw new IllegalStateException(\n          \"Expected \" + JsonToken.NUMBER + \" but was \" + token + locationString());\n    }\n    long result = ((JsonPrimitive) peekStack()).getAsLong();\n    popStack();\n    if (stackSize > 0) {\n      pathIndices[stackSize - 1]++;\n    }\n    return result;\n  }\n\n  @Override public int nextInt() throws IOException {\n    JsonToken token = peek();\n    if (token != JsonToken.NUMBER && token != JsonToken.STRING) {\n      throw new IllegalStateException(\n          \"Expected \" + JsonToken.NUMBER + \" but was \" + token + locationString());\n    }\n    int result = ((JsonPrimitive) peekStack()).getAsInt();\n    popStack();\n    if (stackSize > 0) {\n      pathIndices[stackSize - 1]++;\n    }\n    return result;\n  }\n\n  @Override public void close() throws IOException {\n    stack = new Object[] { SENTINEL_CLOSED };\n    stackSize = 1;\n  }\n\n  @Override public void skipValue() throws IOException {\n    if (peek() == JsonToken.NAME) {\n      nextName();\n      pathNames[stackSize - 2] = \"null\";\n    } else {\n      popStack();\n      if (stackSize > 0) {\n        pathNames[stackSize - 1] = \"null\";\n      }\n    }\n    if (stackSize > 0) {\n      pathIndices[stackSize - 1]++;\n    }\n  }\n\n  @Override public String toString() {\n    return getClass().getSimpleName();\n  }\n\n  public void promoteNameToValue() throws IOException {\n    expect(JsonToken.NAME);\n    Iterator<?> i = (Iterator<?>) peekStack();\n    Map.Entry<?, ?> entry = (Map.Entry<?, ?>) i.next();\n    push(entry.getValue());\n    push(new JsonPrimitive((String) entry.getKey()));\n  }\n\n  private void push(Object newTop) {\n    if (stackSize == stack.length) {\n      Object[] newStack = new Object[stackSize * 2];\n      int[] newPathIndices = new int[stackSize * 2];\n      String[] newPathNames = new String[stackSize * 2];\n      System.arraycopy(stack, 0, newStack, 0, stackSize);\n      System.arraycopy(pathIndices, 0, newPathIndices, 0, stackSize);\n      System.arraycopy(pathNames, 0, newPathNames, 0, stackSize);\n      stack = newStack;\n      pathIndices = newPathIndices;\n      pathNames = newPathNames;\n    }\n    stack[stackSize++] = newTop;\n  }\n\n  @Override public String getPath() {\n    StringBuilder result = new StringBuilder().append('$');\n    for (int i = 0; i < stackSize; i++) {\n      if (stack[i] instanceof JsonArray) {\n        if (stack[++i] instanceof Iterator) {\n          result.append('[').append(pathIndices[i]).append(']');\n        }\n      } else if (stack[i] instanceof JsonObject) {\n        if (stack[++i] instanceof Iterator) {\n          result.append('.');\n          if (pathNames[i] != null) {\n            result.append(pathNames[i]);\n          }\n        }\n      }\n    }\n    return result.toString();\n  }\n\n  private String locationString() {\n    return \" at path \" + getPath();\n  }\n}\n",
      "buggy_signatures": [
        "public int read(char[] buffer, int offset, int count) throws IOException",
        "public void close() throws IOException",
        "public void beginArray() throws IOException",
        "public void endArray() throws IOException",
        "public void beginObject() throws IOException",
        "public void endObject() throws IOException",
        "public boolean hasNext() throws IOException",
        "public JsonToken peek() throws IOException",
        "private Object peekStack()",
        "private Object popStack()",
        "private void expect(JsonToken expected) throws IOException",
        "public String nextName() throws IOException",
        "public String nextString() throws IOException",
        "public boolean nextBoolean() throws IOException",
        "public void nextNull() throws IOException",
        "public double nextDouble() throws IOException",
        "public long nextLong() throws IOException",
        "public int nextInt() throws IOException",
        "public void close() throws IOException",
        "public void skipValue() throws IOException",
        "public String toString()",
        "public void promoteNameToValue() throws IOException",
        "private void push(Object newTop)",
        "public String getPath()",
        "private String locationString()"
      ],
      "fixed_signatures": [
        "public int read(char[] buffer, int offset, int count) throws IOException",
        "public void close() throws IOException",
        "public void beginArray() throws IOException",
        "public void endArray() throws IOException",
        "public void beginObject() throws IOException",
        "public void endObject() throws IOException",
        "public boolean hasNext() throws IOException",
        "public JsonToken peek() throws IOException",
        "private Object peekStack()",
        "private Object popStack()",
        "private void expect(JsonToken expected) throws IOException",
        "public String nextName() throws IOException",
        "public String nextString() throws IOException",
        "public boolean nextBoolean() throws IOException",
        "public void nextNull() throws IOException",
        "public double nextDouble() throws IOException",
        "public long nextLong() throws IOException",
        "public int nextInt() throws IOException",
        "public void close() throws IOException",
        "public void skipValue() throws IOException",
        "public String toString()",
        "public void promoteNameToValue() throws IOException",
        "private void push(Object newTop)",
        "public String getPath()",
        "private String locationString()"
      ],
      "methods": [
        {
          "buggy_method": "  @Override public void skipValue() throws IOException {\n  if (peek() == JsonToken.NAME) {\n  nextName();\n  pathNames[stackSize - 2] = \"null\";\n  } else {\n  popStack();\n  pathNames[stackSize - 1] = \"null\";\n  }\n  pathIndices[stackSize - 1]++;\n  }",
          "fixed_method": "  @Override public void skipValue() throws IOException {\n  if (peek() == JsonToken.NAME) {\n  nextName();\n  pathNames[stackSize - 2] = \"null\";\n  } else {\n  popStack();\n  if (stackSize > 0) {\n  pathNames[stackSize - 1] = \"null\";\n  }\n  }\n  if (stackSize > 0) {\n  pathIndices[stackSize - 1]++;\n  }\n  }",
          "diff": [
            "@@ -259,9 +259,13 @@",
            "       pathNames[stackSize - 2] = \"null\";\n",
            "     } else {\n",
            "       popStack();\n",
            "+      if (stackSize > 0) {\n",
            "         pathNames[stackSize - 1] = \"null\";\n",
            "-    }\n",
            "-      pathIndices[stackSize - 1]++;\n",
            "+      }\n",
            "+    }\n",
            "+    if (stackSize > 0) {\n",
            "+      pathIndices[stackSize - 1]++;\n",
            "+    }\n",
            "   }\n",
            " \n",
            "   @Override public String toString() {\n"
          ],
          "changed_lines": 8
        }
      ]
    }
  ]
}
