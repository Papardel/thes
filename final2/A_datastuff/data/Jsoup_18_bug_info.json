{
  "bug_id": "18",
  "failed_tests": {
    "org.jsoup.parser.CharacterReaderTest": [
      {
        "methodName": "handleCarriageReturnAsLineFeed",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<one []> but was:<one [",
        "fail_line": "        assertEquals(\"one \", first);",
        "test_source": "",
        "stack": [
          "CharacterReaderTest.handleCarriageReturnAsLineFeed line 69"
        ]
      },
      {
        "methodName": "consumeToEnd",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<one two thre[e]> but was:<one two thre[]>",
        "fail_line": "        assertEquals(in, toEnd);",
        "test_source": "",
        "stack": [
          "CharacterReaderTest.consumeToEnd line 77"
        ]
      }
    ],
    "org.jsoup.parser.ParserTest": [
      {
        "methodName": "handlesNewlinesAndWhitespaceInTag",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<<a href=\"one\" []id=\"two\"></a>> but was:<<a href=\"one\" [=\"\" ]id=\"two\"></a>>",
        "fail_line": "        assertEquals(\"<a href=\\\"one\\\" id=\\\"two\\\"></a>\", doc.body().html());",
        "test_source": "",
        "stack": [
          "ParserTest.handlesNewlinesAndWhitespaceInTag line 619"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/jsoup/parser/CharacterReader.java",
      "buggy_full_code": "package org.jsoup.parser;\n\nimport org.jsoup.helper.Validate;\n\n\nclass CharacterReader {\n    static final char EOF = (char) -1; private final String input; private final int length; private int pos = 0; private int mark = 0; CharacterReader(String input) {\n        Validate.notNull(input);\n\n        this.input = input;\n        this.length = input.length();\n    }\n\n    int pos() {\n        return pos;\n    }\n\n    boolean isEmpty() {\n        return pos >= length;\n    }\n\n    char current() {\n        return isEmpty() ? EOF : input.charAt(pos);\n    }\n\n    char consume() {\n        char val = isEmpty() ? EOF : input.charAt(pos);\n        pos++;\n        return val;\n    }\n\n    void unconsume() {\n        pos--;\n    }\n\n    void advance() {\n        pos++;\n    }\n\n    void mark() {\n        mark = pos;\n    }\n\n    void rewindToMark() {\n        pos = mark;\n    }\n\n    String consumeAsString() {\n        return input.substring(pos, pos++);\n    }\n\n    String consumeTo(char c) {\n        int offset = input.indexOf(c, pos);\n        if (offset != -1) {\n            String consumed = input.substring(pos, offset);\n            pos += consumed.length();\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    String consumeTo(String seq) {\n        int offset = input.indexOf(seq, pos);\n        if (offset != -1) {\n            String consumed = input.substring(pos, offset);\n            pos += consumed.length();\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    String consumeToAny(char... seq) {\n        int start = pos;\n\n        OUTER: while (!isEmpty()) {\n            char c = input.charAt(pos);\n            for (char seek : seq) {\n                if (seek == c)\n                    break OUTER;\n            }\n            pos++;\n        }\n\n        return pos > start ? input.substring(start, pos) : \"\";\n    }\n\n    String consumeToEnd() {\n        String data = input.substring(pos, input.length() - 1);\n        pos = input.length();\n        return data;\n    }\n\n    String consumeLetterSequence() {\n        int start = pos;\n        while (!isEmpty()) {\n            char c = input.charAt(pos);\n            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))\n                pos++;\n            else\n                break;\n        }\n\n        return input.substring(start, pos);\n    }\n\n    String consumeHexSequence() {\n        int start = pos;\n        while (!isEmpty()) {\n            char c = input.charAt(pos);\n            if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f'))\n                pos++;\n            else\n                break;\n        }\n        return input.substring(start, pos);\n    }\n\n    String consumeDigitSequence() {\n        int start = pos;\n        while (!isEmpty()) {\n            char c = input.charAt(pos);\n            if (c >= '0' && c <= '9')\n                pos++;\n            else\n                break;\n        }\n        return input.substring(start, pos);\n    }\n\n    boolean matches(char c) {\n        return !isEmpty() && input.charAt(pos) == c;\n\n    }\n\n    boolean matches(String seq) {\n        return input.startsWith(seq, pos);\n    }\n\n    boolean matchesIgnoreCase(String seq) {\n        return input.regionMatches(true, pos, seq, 0, seq.length());\n    }\n\n    boolean matchesAny(char... seq) {\n        if (isEmpty())\n            return false;\n\n        char c = input.charAt(pos);\n        for (char seek : seq) {\n            if (seek == c)\n                return true;\n        }\n        return false;\n    }\n\n    boolean matchesLetter() {\n        if (isEmpty())\n            return false;\n        char c = input.charAt(pos);\n        return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n    }\n\n    boolean matchesDigit() {\n        if (isEmpty())\n            return false;\n        char c = input.charAt(pos);\n        return (c >= '0' && c <= '9');\n    }\n\n    boolean matchConsume(String seq) {\n        if (matches(seq)) {\n            pos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean matchConsumeIgnoreCase(String seq) {\n        if (matchesIgnoreCase(seq)) {\n            pos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean containsIgnoreCase(String seq) {\n        \n        String loScan = seq.toLowerCase();\n        String hiScan = seq.toUpperCase();\n        return (input.indexOf(loScan, pos) > -1) || (input.indexOf(hiScan, pos) > -1);\n    }\n\n    @Override\n    public String toString() {\n        return input.substring(pos);\n    }\n}\n",
      "fixed_full_code": "package org.jsoup.parser;\n\nimport org.jsoup.helper.Validate;\n\n\nclass CharacterReader {\n    static final char EOF = (char) -1; private final String input; private final int length; private int pos = 0; private int mark = 0; CharacterReader(String input) {\n        Validate.notNull(input);\n        input = input.replaceAll(\"\\r\\n?\", \"\\n\"); \n\n        this.input = input;\n        this.length = input.length();\n    }\n\n    int pos() {\n        return pos;\n    }\n\n    boolean isEmpty() {\n        return pos >= length;\n    }\n\n    char current() {\n        return isEmpty() ? EOF : input.charAt(pos);\n    }\n\n    char consume() {\n        char val = isEmpty() ? EOF : input.charAt(pos);\n        pos++;\n        return val;\n    }\n\n    void unconsume() {\n        pos--;\n    }\n\n    void advance() {\n        pos++;\n    }\n\n    void mark() {\n        mark = pos;\n    }\n\n    void rewindToMark() {\n        pos = mark;\n    }\n\n    String consumeAsString() {\n        return input.substring(pos, pos++);\n    }\n\n    String consumeTo(char c) {\n        int offset = input.indexOf(c, pos);\n        if (offset != -1) {\n            String consumed = input.substring(pos, offset);\n            pos += consumed.length();\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    String consumeTo(String seq) {\n        int offset = input.indexOf(seq, pos);\n        if (offset != -1) {\n            String consumed = input.substring(pos, offset);\n            pos += consumed.length();\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    String consumeToAny(char... seq) {\n        int start = pos;\n\n        OUTER: while (!isEmpty()) {\n            char c = input.charAt(pos);\n            for (char seek : seq) {\n                if (seek == c)\n                    break OUTER;\n            }\n            pos++;\n        }\n\n        return pos > start ? input.substring(start, pos) : \"\";\n    }\n\n    String consumeToEnd() {\n        String data = input.substring(pos, input.length());\n        pos = input.length();\n        return data;\n    }\n\n    String consumeLetterSequence() {\n        int start = pos;\n        while (!isEmpty()) {\n            char c = input.charAt(pos);\n            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))\n                pos++;\n            else\n                break;\n        }\n\n        return input.substring(start, pos);\n    }\n\n    String consumeHexSequence() {\n        int start = pos;\n        while (!isEmpty()) {\n            char c = input.charAt(pos);\n            if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f'))\n                pos++;\n            else\n                break;\n        }\n        return input.substring(start, pos);\n    }\n\n    String consumeDigitSequence() {\n        int start = pos;\n        while (!isEmpty()) {\n            char c = input.charAt(pos);\n            if (c >= '0' && c <= '9')\n                pos++;\n            else\n                break;\n        }\n        return input.substring(start, pos);\n    }\n\n    boolean matches(char c) {\n        return !isEmpty() && input.charAt(pos) == c;\n\n    }\n\n    boolean matches(String seq) {\n        return input.startsWith(seq, pos);\n    }\n\n    boolean matchesIgnoreCase(String seq) {\n        return input.regionMatches(true, pos, seq, 0, seq.length());\n    }\n\n    boolean matchesAny(char... seq) {\n        if (isEmpty())\n            return false;\n\n        char c = input.charAt(pos);\n        for (char seek : seq) {\n            if (seek == c)\n                return true;\n        }\n        return false;\n    }\n\n    boolean matchesLetter() {\n        if (isEmpty())\n            return false;\n        char c = input.charAt(pos);\n        return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n    }\n\n    boolean matchesDigit() {\n        if (isEmpty())\n            return false;\n        char c = input.charAt(pos);\n        return (c >= '0' && c <= '9');\n    }\n\n    boolean matchConsume(String seq) {\n        if (matches(seq)) {\n            pos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean matchConsumeIgnoreCase(String seq) {\n        if (matchesIgnoreCase(seq)) {\n            pos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean containsIgnoreCase(String seq) {\n        \n        String loScan = seq.toLowerCase();\n        String hiScan = seq.toUpperCase();\n        return (input.indexOf(loScan, pos) > -1) || (input.indexOf(hiScan, pos) > -1);\n    }\n\n    @Override\n    public String toString() {\n        return input.substring(pos);\n    }\n}\n",
      "buggy_signatures": [
        "public String toString()"
      ],
      "fixed_signatures": [
        "public String toString()"
      ],
      "methods": [
        {
          "buggy_method": "  static final char EOF = (char) -1; private final String input; private final int length; private int pos = 0; private int mark = 0; CharacterReader(String input) {\n  Validate.notNull(input);\n\n  this.input = input;\n  this.length = input.length();\n  }",
          "fixed_method": "  static final char EOF = (char) -1; private final String input; private final int length; private int pos = 0; private int mark = 0; CharacterReader(String input) {\n  Validate.notNull(input);\n  input = input.replaceAll(\"\\r\\n?\", \"\\n\"); \n\n  this.input = input;\n  this.length = input.length();\n  }",
          "diff": [
            "@@ -15,6 +15,7 @@",
            " \n",
            "     CharacterReader(String input) {\n",
            "         Validate.notNull(input);\n",
            "+        input = input.replaceAll(\"\\r\\n?\", \"\\n\"); // normalise carriage returns to newlines\n",
            " \n",
            "         this.input = input;\n",
            "         this.length = input.length();\n",
            "@@ -96,7 +97,7 @@",
            "     }\n",
            " \n",
            "     String consumeToEnd() {\n",
            "-        String data = input.substring(pos, input.length() - 1);\n",
            "+        String data = input.substring(pos, input.length());\n",
            "         pos = input.length();\n",
            "         return data;\n",
            "     }\n"
          ],
          "changed_lines": 3
        }
      ]
    }
  ]
}
