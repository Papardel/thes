{
  "bug_id": "94",
  "failed_tests": {
    "org.apache.commons.math.util.MathUtilsTest": [
      {
        "methodName": "testGcd",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<98304> but was:<3440640>",
        "fail_line": "        assertEquals(3 * (1<<15), MathUtils.gcd(3 * (1<<20), 9 * (1<<15)));",
        "test_source": "  public void testGcd() {\n  int a = 30;\n  int b = 50;\n  int c = 77;\n\n  assertEquals(0, MathUtils.gcd(0, 0));\n\n  assertEquals(b, MathUtils.gcd(0, b));\n  assertEquals(a, MathUtils.gcd(a, 0));\n  assertEquals(b, MathUtils.gcd(0, -b));\n  assertEquals(a, MathUtils.gcd(-a, 0));\n\n  assertEquals(10, MathUtils.gcd(a, b));\n  assertEquals(10, MathUtils.gcd(-a, b));\n  assertEquals(10, MathUtils.gcd(a, -b));\n  assertEquals(10, MathUtils.gcd(-a, -b));\n\n  assertEquals(1, MathUtils.gcd(a, c));\n  assertEquals(1, MathUtils.gcd(-a, c));\n  assertEquals(1, MathUtils.gcd(a, -c));\n  assertEquals(1, MathUtils.gcd(-a, -c));\n\n  assertEquals(3 * (1<<15), MathUtils.gcd(3 * (1<<20), 9 * (1<<15)));\n\n  }",
        "stack": [
          "MathUtilsTest.testGcd line 295"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/math/util/MathUtils.java",
      "buggy_full_code": "\n\npackage org.apache.commons.math.util;\n\nimport java.math.BigDecimal;\nimport java.util.Arrays;\n\n\npublic final class MathUtils { public static final double EPSILON = 0x1.0p-53; public static final double SAFE_MIN = 0x1.0p-1022; private static final byte NB = (byte)-1; private static final short NS = (short)-1; private static final byte PB = (byte)1; private static final short PS = (short)1; private static final byte ZB = (byte)0; private static final short ZS = (short)0; private static final double TWO_PI = 2 * Math.PI; private MathUtils() {\n        super();\n    }\n\n    \n    public static int addAndCheck(int x, int y) {\n        long s = (long)x + (long)y;\n        if (s < Integer.MIN_VALUE || s > Integer.MAX_VALUE) {\n            throw new ArithmeticException(\"overflow: add\");\n        }\n        return (int)s;\n    }\n\n    \n    public static long addAndCheck(long a, long b) {\n        return addAndCheck(a, b, \"overflow: add\");\n    }\n    \n    \n    private static long addAndCheck(long a, long b, String msg) {\n        long ret;\n        if (a > b) {\n            \n            ret = addAndCheck(b, a, msg);\n        } else {\n            \n            \n            if (a < 0) {\n                if (b < 0) {\n                    \n                    if (Long.MIN_VALUE - b <= a) {\n                        ret = a + b;\n                    } else {\n                        throw new ArithmeticException(msg);\n                    }\n                } else {\n                    \n                    ret = a + b;\n                }\n            } else {\n                \n                \n\n                \n                if (a <= Long.MAX_VALUE - b) {\n                    ret = a + b;\n                } else {\n                    throw new ArithmeticException(msg);\n                }\n            }\n        }\n        return ret;\n    }\n    \n    \n    public static long binomialCoefficient(final int n, final int k) {\n        if (n < k) {\n            throw new IllegalArgumentException(\n                \"must have n >= k for binomial coefficient (n,k)\");\n        }\n        if (n < 0) {\n            throw new IllegalArgumentException(\n                \"must have n >= 0 for binomial coefficient (n,k)\");\n        }\n        if ((n == k) || (k == 0)) {\n            return 1;\n        }\n        if ((k == 1) || (k == n - 1)) {\n            return n;\n        }\n\n        long result = Math.round(binomialCoefficientDouble(n, k));\n        if (result == Long.MAX_VALUE) {\n            throw new ArithmeticException(\n                \"result too large to represent in a long integer\");\n        }\n        return result;\n    }\n\n    \n    public static double binomialCoefficientDouble(final int n, final int k) {\n        return Math.floor(Math.exp(binomialCoefficientLog(n, k)) + 0.5);\n    }\n    \n    \n    public static double binomialCoefficientLog(final int n, final int k) {\n        if (n < k) {\n            throw new IllegalArgumentException(\n                \"must have n >= k for binomial coefficient (n,k)\");\n        }\n        if (n < 0) {\n            throw new IllegalArgumentException(\n                \"must have n >= 0 for binomial coefficient (n,k)\");\n        }\n        if ((n == k) || (k == 0)) {\n            return 0;\n        }\n        if ((k == 1) || (k == n - 1)) {\n            return Math.log((double)n);\n        }\n        double logSum = 0;\n\n        \n        for (int i = k + 1; i <= n; i++) {\n            logSum += Math.log((double)i);\n        }\n\n        \n        for (int i = 2; i <= n - k; i++) {\n            logSum -= Math.log((double)i);\n        }\n\n        return logSum;\n    }\n    \n    \n    public static double cosh(double x) {\n        return (Math.exp(x) + Math.exp(-x)) / 2.0;\n    }\n    \n    \n    public static boolean equals(double x, double y) {\n        return ((Double.isNaN(x) && Double.isNaN(y)) || x == y);\n    }\n\n    \n    public static boolean equals(double[] x, double[] y) {\n        if ((x == null) || (y == null)) {\n            return !((x == null) ^ (y == null));\n        }\n        if (x.length != y.length) {\n            return false;\n        }\n        for (int i = 0; i < x.length; ++i) {\n            if (!equals(x[i], y[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public static long factorial(final int n) {\n        long result = Math.round(factorialDouble(n));\n        if (result == Long.MAX_VALUE) {\n            throw new ArithmeticException(\n                \"result too large to represent in a long integer\");\n        }\n        return result;\n    }\n\n    \n    public static double factorialDouble(final int n) {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"must have n >= 0 for n!\");\n        }\n        return Math.floor(Math.exp(factorialLog(n)) + 0.5);\n    }\n\n    \n    public static double factorialLog(final int n) {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"must have n > 0 for n!\");\n        }\n        double logSum = 0;\n        for (int i = 2; i <= n; i++) {\n            logSum += Math.log((double)i);\n        }\n        return logSum;\n    }\n\n    \n    public static int gcd(int u, int v) {\n        if (u * v == 0) {\n            return (Math.abs(u) + Math.abs(v));\n        }\n        \n        \n        \n        \n        \n        if (u > 0) {\n            u = -u;\n        } \n        if (v > 0) {\n            v = -v;\n        } \n        \n        int k = 0;\n        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { \n                                                            \n            u /= 2;\n            v /= 2;\n            k++; \n        }\n        if (k == 31) {\n            throw new ArithmeticException(\"overflow: gcd is 2^31\");\n        }\n        \n        \n        int t = ((u & 1) == 1) ? v : -(u / 2);\n        \n        \n        do {\n            \n            \n            while ((t & 1) == 0) { \n                t /= 2; \n            }\n            \n            if (t > 0) {\n                u = -t;\n            } else {\n                v = t;\n            }\n            \n            t = (v - u) / 2;\n            \n            \n        } while (t != 0);\n        return -u * (1 << k); \n    }\n\n    \n    public static int hash(double value) {\n        return new Double(value).hashCode();\n    }\n\n    \n    public static int hash(double[] value) {\n        return Arrays.hashCode(value);\n    }\n\n    \n    public static byte indicator(final byte x) {\n        return (x >= ZB) ? PB : NB;\n    }\n\n    \n    public static double indicator(final double x) {\n        if (Double.isNaN(x)) {\n            return Double.NaN;\n        }\n        return (x >= 0.0) ? 1.0 : -1.0;\n    }\n\n    \n    public static float indicator(final float x) {\n        if (Float.isNaN(x)) {\n            return Float.NaN;\n        }\n        return (x >= 0.0F) ? 1.0F : -1.0F;\n    }\n\n    \n    public static int indicator(final int x) {\n        return (x >= 0) ? 1 : -1;\n    }\n\n    \n    public static long indicator(final long x) {\n        return (x >= 0L) ? 1L : -1L;\n    }\n\n    \n    public static short indicator(final short x) {\n        return (x >= ZS) ? PS : NS;\n    }\n\n    \n    public static int lcm(int a, int b) {\n        return Math.abs(mulAndCheck(a / gcd(a, b), b));\n    }\n\n     \n    public static double log(double base, double x) {\n        return Math.log(x)/Math.log(base);\n    }\n\n    \n    public static int mulAndCheck(int x, int y) {\n        long m = ((long)x) * ((long)y);\n        if (m < Integer.MIN_VALUE || m > Integer.MAX_VALUE) {\n            throw new ArithmeticException(\"overflow: mul\");\n        }\n        return (int)m;\n    }\n\n    \n    public static long mulAndCheck(long a, long b) {\n        long ret;\n        String msg = \"overflow: multiply\";\n        if (a > b) {\n            \n            ret = mulAndCheck(b, a);\n        } else {\n            if (a < 0) {\n                if (b < 0) {\n                    \n                    if (a >= Long.MAX_VALUE / b) {\n                        ret = a * b;\n                    } else {\n                        throw new ArithmeticException(msg);\n                    }\n                } else if (b > 0) {\n                    \n                    if (Long.MIN_VALUE / b <= a) {\n                        ret = a * b;\n                    } else {\n                        throw new ArithmeticException(msg);\n                        \n                    }\n                } else {\n                    \n                    ret = 0;\n                }\n            } else if (a > 0) {\n                \n                \n                \n                \n                if (a <= Long.MAX_VALUE / b) {\n                    ret = a * b;\n                } else {\n                    throw new ArithmeticException(msg);\n                }\n            } else {\n                \n                ret = 0;\n            }\n        }\n        return ret;\n    }\n\n    \n    public static double nextAfter(double d, double direction) {\n\n        \n        if (Double.isNaN(d) || Double.isInfinite(d)) {\n                return d;\n        } else if (d == 0) {\n                return (direction < 0) ? -Double.MIN_VALUE : Double.MIN_VALUE;\n        }\n        \n        \n\n        \n        long bits     = Double.doubleToLongBits(d);\n        long sign     = bits & 0x8000000000000000L;\n        long exponent = bits & 0x7ff0000000000000L;\n        long mantissa = bits & 0x000fffffffffffffL;\n\n        if (d * (direction - d) >= 0) {\n                \n                if (mantissa == 0x000fffffffffffffL) {\n                        return Double.longBitsToDouble(sign |\n                                        (exponent + 0x0010000000000000L));\n                } else {\n                        return Double.longBitsToDouble(sign |\n                                        exponent | (mantissa + 1));\n                }\n        } else {\n                \n                if (mantissa == 0L) {\n                        return Double.longBitsToDouble(sign |\n                                        (exponent - 0x0010000000000000L) |\n                                        0x000fffffffffffffL);\n                } else {\n                        return Double.longBitsToDouble(sign |\n                                        exponent | (mantissa - 1));\n                }\n        }\n\n    }\n\n    \n    public static double scalb(final double d, final int scaleFactor) {\n\n        \n        if ((d == 0) || Double.isNaN(d) || Double.isInfinite(d)) {\n            return d;\n        }\n\n        \n        final long bits     = Double.doubleToLongBits(d);\n        final long exponent = bits & 0x7ff0000000000000L;\n        final long rest     = bits & 0x800fffffffffffffL;\n\n        \n        final long newBits = rest | (exponent + (((long) scaleFactor) << 52));\n        return Double.longBitsToDouble(newBits);\n\n    }\n\n    \n     public static double normalizeAngle(double a, double center) {\n         return a - TWO_PI * Math.floor((a + Math.PI - center) / TWO_PI);\n     }\n\n    \n    public static double round(double x, int scale) {\n        return round(x, scale, BigDecimal.ROUND_HALF_UP);\n    }\n\n    \n    public static double round(double x, int scale, int roundingMethod) {\n        try {\n            return (new BigDecimal\n                   (Double.toString(x))\n                   .setScale(scale, roundingMethod))\n                   .doubleValue();\n        } catch (NumberFormatException ex) {\n            if (Double.isInfinite(x)) {\n                return x;          \n            } else {\n                return Double.NaN;\n            }\n        }\n    }\n\n    \n    public static float round(float x, int scale) {\n        return round(x, scale, BigDecimal.ROUND_HALF_UP);\n    }\n\n    \n    public static float round(float x, int scale, int roundingMethod) {\n        float sign = indicator(x);\n        float factor = (float)Math.pow(10.0f, scale) * sign;\n        return (float)roundUnscaled(x * factor, sign, roundingMethod) / factor;\n    }\n\n    \n    private static double roundUnscaled(double unscaled, double sign, int roundingMethod) {\n        switch (roundingMethod) {\n        case BigDecimal.ROUND_CEILING :\n            if (sign == -1) {\n                unscaled = Math.floor(nextAfter(unscaled, Double.NEGATIVE_INFINITY));\n            } else {\n                unscaled = Math.ceil(nextAfter(unscaled, Double.POSITIVE_INFINITY));\n            }\n            break;\n        case BigDecimal.ROUND_DOWN :\n            unscaled = Math.floor(nextAfter(unscaled, Double.NEGATIVE_INFINITY));\n            break;\n        case BigDecimal.ROUND_FLOOR :\n            if (sign == -1) {\n                unscaled = Math.ceil(nextAfter(unscaled, Double.POSITIVE_INFINITY));\n            } else {\n                unscaled = Math.floor(nextAfter(unscaled, Double.NEGATIVE_INFINITY));\n            }\n            break;\n        case BigDecimal.ROUND_HALF_DOWN : {\n            unscaled = nextAfter(unscaled, Double.NEGATIVE_INFINITY);\n            double fraction = unscaled - Math.floor(unscaled);\n            if (fraction > 0.5) {\n                unscaled = Math.ceil(unscaled);\n            } else {\n                unscaled = Math.floor(unscaled);\n            }\n            break;\n        }\n        case BigDecimal.ROUND_HALF_EVEN : {\n            double fraction = unscaled - Math.floor(unscaled);\n            if (fraction > 0.5) {\n                unscaled = Math.ceil(unscaled);\n            } else if (fraction < 0.5) {\n                unscaled = Math.floor(unscaled);\n            } else {\n                \n                if (Math.floor(unscaled) / 2.0 == Math.floor(Math\n                    .floor(unscaled) / 2.0)) { \n                    unscaled = Math.floor(unscaled);\n                } else { \n                    unscaled = Math.ceil(unscaled);\n                }\n            }\n            break;\n        }\n        case BigDecimal.ROUND_HALF_UP : {\n            unscaled = nextAfter(unscaled, Double.POSITIVE_INFINITY);\n            double fraction = unscaled - Math.floor(unscaled);\n            if (fraction >= 0.5) {\n                unscaled = Math.ceil(unscaled);\n            } else {\n                unscaled = Math.floor(unscaled);\n            }\n            break;\n        }\n        case BigDecimal.ROUND_UNNECESSARY :\n            if (unscaled != Math.floor(unscaled)) {\n                throw new ArithmeticException(\"Inexact result from rounding\");\n            }\n            break;\n        case BigDecimal.ROUND_UP :\n            unscaled = Math.ceil(nextAfter(unscaled,  Double.POSITIVE_INFINITY));\n            break;\n        default :\n            throw new IllegalArgumentException(\"Invalid rounding method.\");\n        }\n        return unscaled;\n    }\n\n    \n    public static byte sign(final byte x) {\n        return (x == ZB) ? ZB : (x > ZB) ? PB : NB;\n    }\n\n    \n    public static double sign(final double x) {\n        if (Double.isNaN(x)) {\n            return Double.NaN;\n        }\n        return (x == 0.0) ? 0.0 : (x > 0.0) ? 1.0 : -1.0;\n    }\n\n    \n    public static float sign(final float x) {\n        if (Float.isNaN(x)) {\n            return Float.NaN;\n        }\n        return (x == 0.0F) ? 0.0F : (x > 0.0F) ? 1.0F : -1.0F;\n    }\n\n    \n    public static int sign(final int x) {\n        return (x == 0) ? 0 : (x > 0) ? 1 : -1;\n    }\n\n    \n    public static long sign(final long x) {\n        return (x == 0L) ? 0L : (x > 0L) ? 1L : -1L;\n    }\n\n    \n    public static short sign(final short x) {\n        return (x == ZS) ? ZS : (x > ZS) ? PS : NS;\n    }\n\n    \n    public static double sinh(double x) {\n        return (Math.exp(x) - Math.exp(-x)) / 2.0;\n    }\n\n    \n    public static int subAndCheck(int x, int y) {\n        long s = (long)x - (long)y;\n        if (s < Integer.MIN_VALUE || s > Integer.MAX_VALUE) {\n            throw new ArithmeticException(\"overflow: subtract\");\n        }\n        return (int)s;\n    }\n\n    \n    public static long subAndCheck(long a, long b) {\n        long ret;\n        String msg = \"overflow: subtract\";\n        if (b == Long.MIN_VALUE) {\n            if (a < 0) {\n                ret = a - b;\n            } else {\n                throw new ArithmeticException(msg);\n            }\n        } else {\n            \n            ret = addAndCheck(a, -b, msg);\n        }\n        return ret;\n    }\n\n}\n",
      "fixed_full_code": "\n\npackage org.apache.commons.math.util;\n\nimport java.math.BigDecimal;\nimport java.util.Arrays;\n\n\npublic final class MathUtils { public static final double EPSILON = 0x1.0p-53; public static final double SAFE_MIN = 0x1.0p-1022; private static final byte NB = (byte)-1; private static final short NS = (short)-1; private static final byte PB = (byte)1; private static final short PS = (short)1; private static final byte ZB = (byte)0; private static final short ZS = (short)0; private static final double TWO_PI = 2 * Math.PI; private MathUtils() {\n        super();\n    }\n\n    \n    public static int addAndCheck(int x, int y) {\n        long s = (long)x + (long)y;\n        if (s < Integer.MIN_VALUE || s > Integer.MAX_VALUE) {\n            throw new ArithmeticException(\"overflow: add\");\n        }\n        return (int)s;\n    }\n\n    \n    public static long addAndCheck(long a, long b) {\n        return addAndCheck(a, b, \"overflow: add\");\n    }\n    \n    \n    private static long addAndCheck(long a, long b, String msg) {\n        long ret;\n        if (a > b) {\n            \n            ret = addAndCheck(b, a, msg);\n        } else {\n            \n            \n            if (a < 0) {\n                if (b < 0) {\n                    \n                    if (Long.MIN_VALUE - b <= a) {\n                        ret = a + b;\n                    } else {\n                        throw new ArithmeticException(msg);\n                    }\n                } else {\n                    \n                    ret = a + b;\n                }\n            } else {\n                \n                \n\n                \n                if (a <= Long.MAX_VALUE - b) {\n                    ret = a + b;\n                } else {\n                    throw new ArithmeticException(msg);\n                }\n            }\n        }\n        return ret;\n    }\n    \n    \n    public static long binomialCoefficient(final int n, final int k) {\n        if (n < k) {\n            throw new IllegalArgumentException(\n                \"must have n >= k for binomial coefficient (n,k)\");\n        }\n        if (n < 0) {\n            throw new IllegalArgumentException(\n                \"must have n >= 0 for binomial coefficient (n,k)\");\n        }\n        if ((n == k) || (k == 0)) {\n            return 1;\n        }\n        if ((k == 1) || (k == n - 1)) {\n            return n;\n        }\n\n        long result = Math.round(binomialCoefficientDouble(n, k));\n        if (result == Long.MAX_VALUE) {\n            throw new ArithmeticException(\n                \"result too large to represent in a long integer\");\n        }\n        return result;\n    }\n\n    \n    public static double binomialCoefficientDouble(final int n, final int k) {\n        return Math.floor(Math.exp(binomialCoefficientLog(n, k)) + 0.5);\n    }\n    \n    \n    public static double binomialCoefficientLog(final int n, final int k) {\n        if (n < k) {\n            throw new IllegalArgumentException(\n                \"must have n >= k for binomial coefficient (n,k)\");\n        }\n        if (n < 0) {\n            throw new IllegalArgumentException(\n                \"must have n >= 0 for binomial coefficient (n,k)\");\n        }\n        if ((n == k) || (k == 0)) {\n            return 0;\n        }\n        if ((k == 1) || (k == n - 1)) {\n            return Math.log((double)n);\n        }\n        double logSum = 0;\n\n        \n        for (int i = k + 1; i <= n; i++) {\n            logSum += Math.log((double)i);\n        }\n\n        \n        for (int i = 2; i <= n - k; i++) {\n            logSum -= Math.log((double)i);\n        }\n\n        return logSum;\n    }\n    \n    \n    public static double cosh(double x) {\n        return (Math.exp(x) + Math.exp(-x)) / 2.0;\n    }\n    \n    \n    public static boolean equals(double x, double y) {\n        return ((Double.isNaN(x) && Double.isNaN(y)) || x == y);\n    }\n\n    \n    public static boolean equals(double[] x, double[] y) {\n        if ((x == null) || (y == null)) {\n            return !((x == null) ^ (y == null));\n        }\n        if (x.length != y.length) {\n            return false;\n        }\n        for (int i = 0; i < x.length; ++i) {\n            if (!equals(x[i], y[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public static long factorial(final int n) {\n        long result = Math.round(factorialDouble(n));\n        if (result == Long.MAX_VALUE) {\n            throw new ArithmeticException(\n                \"result too large to represent in a long integer\");\n        }\n        return result;\n    }\n\n    \n    public static double factorialDouble(final int n) {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"must have n >= 0 for n!\");\n        }\n        return Math.floor(Math.exp(factorialLog(n)) + 0.5);\n    }\n\n    \n    public static double factorialLog(final int n) {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"must have n > 0 for n!\");\n        }\n        double logSum = 0;\n        for (int i = 2; i <= n; i++) {\n            logSum += Math.log((double)i);\n        }\n        return logSum;\n    }\n\n    \n    public static int gcd(int u, int v) {\n        if ((u == 0) || (v == 0)) {\n            return (Math.abs(u) + Math.abs(v));\n        }\n        \n        \n        \n        \n        \n        if (u > 0) {\n            u = -u;\n        } \n        if (v > 0) {\n            v = -v;\n        } \n        \n        int k = 0;\n        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { \n                                                            \n            u /= 2;\n            v /= 2;\n            k++; \n        }\n        if (k == 31) {\n            throw new ArithmeticException(\"overflow: gcd is 2^31\");\n        }\n        \n        \n        int t = ((u & 1) == 1) ? v : -(u / 2);\n        \n        \n        do {\n            \n            \n            while ((t & 1) == 0) { \n                t /= 2; \n            }\n            \n            if (t > 0) {\n                u = -t;\n            } else {\n                v = t;\n            }\n            \n            t = (v - u) / 2;\n            \n            \n        } while (t != 0);\n        return -u * (1 << k); \n    }\n\n    \n    public static int hash(double value) {\n        return new Double(value).hashCode();\n    }\n\n    \n    public static int hash(double[] value) {\n        return Arrays.hashCode(value);\n    }\n\n    \n    public static byte indicator(final byte x) {\n        return (x >= ZB) ? PB : NB;\n    }\n\n    \n    public static double indicator(final double x) {\n        if (Double.isNaN(x)) {\n            return Double.NaN;\n        }\n        return (x >= 0.0) ? 1.0 : -1.0;\n    }\n\n    \n    public static float indicator(final float x) {\n        if (Float.isNaN(x)) {\n            return Float.NaN;\n        }\n        return (x >= 0.0F) ? 1.0F : -1.0F;\n    }\n\n    \n    public static int indicator(final int x) {\n        return (x >= 0) ? 1 : -1;\n    }\n\n    \n    public static long indicator(final long x) {\n        return (x >= 0L) ? 1L : -1L;\n    }\n\n    \n    public static short indicator(final short x) {\n        return (x >= ZS) ? PS : NS;\n    }\n\n    \n    public static int lcm(int a, int b) {\n        return Math.abs(mulAndCheck(a / gcd(a, b), b));\n    }\n\n     \n    public static double log(double base, double x) {\n        return Math.log(x)/Math.log(base);\n    }\n\n    \n    public static int mulAndCheck(int x, int y) {\n        long m = ((long)x) * ((long)y);\n        if (m < Integer.MIN_VALUE || m > Integer.MAX_VALUE) {\n            throw new ArithmeticException(\"overflow: mul\");\n        }\n        return (int)m;\n    }\n\n    \n    public static long mulAndCheck(long a, long b) {\n        long ret;\n        String msg = \"overflow: multiply\";\n        if (a > b) {\n            \n            ret = mulAndCheck(b, a);\n        } else {\n            if (a < 0) {\n                if (b < 0) {\n                    \n                    if (a >= Long.MAX_VALUE / b) {\n                        ret = a * b;\n                    } else {\n                        throw new ArithmeticException(msg);\n                    }\n                } else if (b > 0) {\n                    \n                    if (Long.MIN_VALUE / b <= a) {\n                        ret = a * b;\n                    } else {\n                        throw new ArithmeticException(msg);\n                        \n                    }\n                } else {\n                    \n                    ret = 0;\n                }\n            } else if (a > 0) {\n                \n                \n                \n                \n                if (a <= Long.MAX_VALUE / b) {\n                    ret = a * b;\n                } else {\n                    throw new ArithmeticException(msg);\n                }\n            } else {\n                \n                ret = 0;\n            }\n        }\n        return ret;\n    }\n\n    \n    public static double nextAfter(double d, double direction) {\n\n        \n        if (Double.isNaN(d) || Double.isInfinite(d)) {\n                return d;\n        } else if (d == 0) {\n                return (direction < 0) ? -Double.MIN_VALUE : Double.MIN_VALUE;\n        }\n        \n        \n\n        \n        long bits     = Double.doubleToLongBits(d);\n        long sign     = bits & 0x8000000000000000L;\n        long exponent = bits & 0x7ff0000000000000L;\n        long mantissa = bits & 0x000fffffffffffffL;\n\n        if (d * (direction - d) >= 0) {\n                \n                if (mantissa == 0x000fffffffffffffL) {\n                        return Double.longBitsToDouble(sign |\n                                        (exponent + 0x0010000000000000L));\n                } else {\n                        return Double.longBitsToDouble(sign |\n                                        exponent | (mantissa + 1));\n                }\n        } else {\n                \n                if (mantissa == 0L) {\n                        return Double.longBitsToDouble(sign |\n                                        (exponent - 0x0010000000000000L) |\n                                        0x000fffffffffffffL);\n                } else {\n                        return Double.longBitsToDouble(sign |\n                                        exponent | (mantissa - 1));\n                }\n        }\n\n    }\n\n    \n    public static double scalb(final double d, final int scaleFactor) {\n\n        \n        if ((d == 0) || Double.isNaN(d) || Double.isInfinite(d)) {\n            return d;\n        }\n\n        \n        final long bits     = Double.doubleToLongBits(d);\n        final long exponent = bits & 0x7ff0000000000000L;\n        final long rest     = bits & 0x800fffffffffffffL;\n\n        \n        final long newBits = rest | (exponent + (((long) scaleFactor) << 52));\n        return Double.longBitsToDouble(newBits);\n\n    }\n\n    \n     public static double normalizeAngle(double a, double center) {\n         return a - TWO_PI * Math.floor((a + Math.PI - center) / TWO_PI);\n     }\n\n    \n    public static double round(double x, int scale) {\n        return round(x, scale, BigDecimal.ROUND_HALF_UP);\n    }\n\n    \n    public static double round(double x, int scale, int roundingMethod) {\n        try {\n            return (new BigDecimal\n                   (Double.toString(x))\n                   .setScale(scale, roundingMethod))\n                   .doubleValue();\n        } catch (NumberFormatException ex) {\n            if (Double.isInfinite(x)) {\n                return x;          \n            } else {\n                return Double.NaN;\n            }\n        }\n    }\n\n    \n    public static float round(float x, int scale) {\n        return round(x, scale, BigDecimal.ROUND_HALF_UP);\n    }\n\n    \n    public static float round(float x, int scale, int roundingMethod) {\n        float sign = indicator(x);\n        float factor = (float)Math.pow(10.0f, scale) * sign;\n        return (float)roundUnscaled(x * factor, sign, roundingMethod) / factor;\n    }\n\n    \n    private static double roundUnscaled(double unscaled, double sign, int roundingMethod) {\n        switch (roundingMethod) {\n        case BigDecimal.ROUND_CEILING :\n            if (sign == -1) {\n                unscaled = Math.floor(nextAfter(unscaled, Double.NEGATIVE_INFINITY));\n            } else {\n                unscaled = Math.ceil(nextAfter(unscaled, Double.POSITIVE_INFINITY));\n            }\n            break;\n        case BigDecimal.ROUND_DOWN :\n            unscaled = Math.floor(nextAfter(unscaled, Double.NEGATIVE_INFINITY));\n            break;\n        case BigDecimal.ROUND_FLOOR :\n            if (sign == -1) {\n                unscaled = Math.ceil(nextAfter(unscaled, Double.POSITIVE_INFINITY));\n            } else {\n                unscaled = Math.floor(nextAfter(unscaled, Double.NEGATIVE_INFINITY));\n            }\n            break;\n        case BigDecimal.ROUND_HALF_DOWN : {\n            unscaled = nextAfter(unscaled, Double.NEGATIVE_INFINITY);\n            double fraction = unscaled - Math.floor(unscaled);\n            if (fraction > 0.5) {\n                unscaled = Math.ceil(unscaled);\n            } else {\n                unscaled = Math.floor(unscaled);\n            }\n            break;\n        }\n        case BigDecimal.ROUND_HALF_EVEN : {\n            double fraction = unscaled - Math.floor(unscaled);\n            if (fraction > 0.5) {\n                unscaled = Math.ceil(unscaled);\n            } else if (fraction < 0.5) {\n                unscaled = Math.floor(unscaled);\n            } else {\n                \n                if (Math.floor(unscaled) / 2.0 == Math.floor(Math\n                    .floor(unscaled) / 2.0)) { \n                    unscaled = Math.floor(unscaled);\n                } else { \n                    unscaled = Math.ceil(unscaled);\n                }\n            }\n            break;\n        }\n        case BigDecimal.ROUND_HALF_UP : {\n            unscaled = nextAfter(unscaled, Double.POSITIVE_INFINITY);\n            double fraction = unscaled - Math.floor(unscaled);\n            if (fraction >= 0.5) {\n                unscaled = Math.ceil(unscaled);\n            } else {\n                unscaled = Math.floor(unscaled);\n            }\n            break;\n        }\n        case BigDecimal.ROUND_UNNECESSARY :\n            if (unscaled != Math.floor(unscaled)) {\n                throw new ArithmeticException(\"Inexact result from rounding\");\n            }\n            break;\n        case BigDecimal.ROUND_UP :\n            unscaled = Math.ceil(nextAfter(unscaled,  Double.POSITIVE_INFINITY));\n            break;\n        default :\n            throw new IllegalArgumentException(\"Invalid rounding method.\");\n        }\n        return unscaled;\n    }\n\n    \n    public static byte sign(final byte x) {\n        return (x == ZB) ? ZB : (x > ZB) ? PB : NB;\n    }\n\n    \n    public static double sign(final double x) {\n        if (Double.isNaN(x)) {\n            return Double.NaN;\n        }\n        return (x == 0.0) ? 0.0 : (x > 0.0) ? 1.0 : -1.0;\n    }\n\n    \n    public static float sign(final float x) {\n        if (Float.isNaN(x)) {\n            return Float.NaN;\n        }\n        return (x == 0.0F) ? 0.0F : (x > 0.0F) ? 1.0F : -1.0F;\n    }\n\n    \n    public static int sign(final int x) {\n        return (x == 0) ? 0 : (x > 0) ? 1 : -1;\n    }\n\n    \n    public static long sign(final long x) {\n        return (x == 0L) ? 0L : (x > 0L) ? 1L : -1L;\n    }\n\n    \n    public static short sign(final short x) {\n        return (x == ZS) ? ZS : (x > ZS) ? PS : NS;\n    }\n\n    \n    public static double sinh(double x) {\n        return (Math.exp(x) - Math.exp(-x)) / 2.0;\n    }\n\n    \n    public static int subAndCheck(int x, int y) {\n        long s = (long)x - (long)y;\n        if (s < Integer.MIN_VALUE || s > Integer.MAX_VALUE) {\n            throw new ArithmeticException(\"overflow: subtract\");\n        }\n        return (int)s;\n    }\n\n    \n    public static long subAndCheck(long a, long b) {\n        long ret;\n        String msg = \"overflow: subtract\";\n        if (b == Long.MIN_VALUE) {\n            if (a < 0) {\n                ret = a - b;\n            } else {\n                throw new ArithmeticException(msg);\n            }\n        } else {\n            \n            ret = addAndCheck(a, -b, msg);\n        }\n        return ret;\n    }\n\n}\n",
      "buggy_signatures": [
        "public static int addAndCheck(int x, int y)",
        "public static long addAndCheck(long a, long b)",
        "private static long addAndCheck(long a, long b, String msg)",
        "public static long binomialCoefficient(final int n, final int k)",
        "public static double binomialCoefficientDouble(final int n, final int k)",
        "public static double binomialCoefficientLog(final int n, final int k)",
        "public static double cosh(double x)",
        "public static boolean equals(double x, double y)",
        "public static boolean equals(double[] x, double[] y)",
        "public static long factorial(final int n)",
        "public static double factorialDouble(final int n)",
        "public static double factorialLog(final int n)",
        "public static int gcd(int u, int v)",
        "public static int hash(double value)",
        "public static int hash(double[] value)",
        "public static byte indicator(final byte x)",
        "public static double indicator(final double x)",
        "public static float indicator(final float x)",
        "public static int indicator(final int x)",
        "public static long indicator(final long x)",
        "public static short indicator(final short x)",
        "public static int lcm(int a, int b)",
        "public static double log(double base, double x)",
        "public static int mulAndCheck(int x, int y)",
        "public static long mulAndCheck(long a, long b)",
        "public static double nextAfter(double d, double direction)",
        "public static double scalb(final double d, final int scaleFactor)",
        "public static double normalizeAngle(double a, double center)",
        "public static double round(double x, int scale)",
        "public static double round(double x, int scale, int roundingMethod)",
        "public static float round(float x, int scale)",
        "public static float round(float x, int scale, int roundingMethod)",
        "private static double roundUnscaled(double unscaled, double sign, int roundingMethod)",
        "public static byte sign(final byte x)",
        "public static double sign(final double x)",
        "public static float sign(final float x)",
        "public static int sign(final int x)",
        "public static long sign(final long x)",
        "public static short sign(final short x)",
        "public static double sinh(double x)",
        "public static int subAndCheck(int x, int y)",
        "public static long subAndCheck(long a, long b)"
      ],
      "fixed_signatures": [
        "public static int addAndCheck(int x, int y)",
        "public static long addAndCheck(long a, long b)",
        "private static long addAndCheck(long a, long b, String msg)",
        "public static long binomialCoefficient(final int n, final int k)",
        "public static double binomialCoefficientDouble(final int n, final int k)",
        "public static double binomialCoefficientLog(final int n, final int k)",
        "public static double cosh(double x)",
        "public static boolean equals(double x, double y)",
        "public static boolean equals(double[] x, double[] y)",
        "public static long factorial(final int n)",
        "public static double factorialDouble(final int n)",
        "public static double factorialLog(final int n)",
        "public static int gcd(int u, int v)",
        "public static int hash(double value)",
        "public static int hash(double[] value)",
        "public static byte indicator(final byte x)",
        "public static double indicator(final double x)",
        "public static float indicator(final float x)",
        "public static int indicator(final int x)",
        "public static long indicator(final long x)",
        "public static short indicator(final short x)",
        "public static int lcm(int a, int b)",
        "public static double log(double base, double x)",
        "public static int mulAndCheck(int x, int y)",
        "public static long mulAndCheck(long a, long b)",
        "public static double nextAfter(double d, double direction)",
        "public static double scalb(final double d, final int scaleFactor)",
        "public static double normalizeAngle(double a, double center)",
        "public static double round(double x, int scale)",
        "public static double round(double x, int scale, int roundingMethod)",
        "public static float round(float x, int scale)",
        "public static float round(float x, int scale, int roundingMethod)",
        "private static double roundUnscaled(double unscaled, double sign, int roundingMethod)",
        "public static byte sign(final byte x)",
        "public static double sign(final double x)",
        "public static float sign(final float x)",
        "public static int sign(final int x)",
        "public static long sign(final long x)",
        "public static short sign(final short x)",
        "public static double sinh(double x)",
        "public static int subAndCheck(int x, int y)",
        "public static long subAndCheck(long a, long b)"
      ],
      "methods": [
        {
          "buggy_method": "  public static int gcd(int u, int v) {\n  if (u * v == 0) {\n  return (Math.abs(u) + Math.abs(v));\n  }\n  \n  \n  \n  \n  \n  if (u > 0) {\n  u = -u;\n  } \n  if (v > 0) {\n  v = -v;\n  } \n  \n  int k = 0;\n  while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { \n  \n  u /= 2;\n  v /= 2;\n  k++; \n  }\n  if (k == 31) {\n  throw new ArithmeticException(\"overflow: gcd is 2^31\");\n  }\n  \n  \n  int t = ((u & 1) == 1) ? v : -(u / 2);\n  \n  \n  do {\n  \n  \n  while ((t & 1) == 0) { \n  t /= 2; \n  }\n  \n  if (t > 0) {\n  u = -t;\n  } else {\n  v = t;\n  }\n  \n  t = (v - u) / 2;\n  \n  \n  } while (t != 0);\n  return -u * (1 << k); \n  }",
          "fixed_method": "  public static int gcd(int u, int v) {\n  if ((u == 0) || (v == 0)) {\n  return (Math.abs(u) + Math.abs(v));\n  }\n  \n  \n  \n  \n  \n  if (u > 0) {\n  u = -u;\n  } \n  if (v > 0) {\n  v = -v;\n  } \n  \n  int k = 0;\n  while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { \n  \n  u /= 2;\n  v /= 2;\n  k++; \n  }\n  if (k == 31) {\n  throw new ArithmeticException(\"overflow: gcd is 2^31\");\n  }\n  \n  \n  int t = ((u & 1) == 1) ? v : -(u / 2);\n  \n  \n  do {\n  \n  \n  while ((t & 1) == 0) { \n  t /= 2; \n  }\n  \n  if (t > 0) {\n  u = -t;\n  } else {\n  v = t;\n  }\n  \n  t = (v - u) / 2;\n  \n  \n  } while (t != 0);\n  return -u * (1 << k); \n  }",
          "diff": [
            "@@ -409,7 +409,7 @@",
            "      * @since 1.1\n",
            "      */\n",
            "     public static int gcd(int u, int v) {\n",
            "-        if (u * v == 0) {\n",
            "+        if ((u == 0) || (v == 0)) {\n",
            "             return (Math.abs(u) + Math.abs(v));\n",
            "         }\n",
            "         // keep u and v negative, as negative integers range down to\n"
          ],
          "changed_lines": 2
        }
      ]
    }
  ]
}
