{
  "bug_id": "30",
  "failed_tests": {
    "org.apache.commons.cli.BasicParserTest": [
      {
        "methodName": "testPropertyOptionGroup",
        "error": "org.apache.commons.cli.AlreadySelectedException",
        "message": "The option 'b' was specified but an option from this group has already been selected: 'a'",
        "fail_line": "",
        "test_source": "",
        "stack": [
          "OptionGroup.setSelected line 105, Parser.updateRequiredOptions line 421, Parser.processProperties line 296, Parser.parse line 241, Parser.parse line 103, ParserTestCase.parse line 875, ParserTestCase.testPropertyOptionGroup line 1037"
        ]
      },
      {
        "methodName": "testPropertyOptionUnexpected",
        "error": "java.lang.NullPointerException",
        "message": "",
        "fail_line": "",
        "test_source": "",
        "stack": [
          "Parser.processProperties line 272, Parser.parse line 241, Parser.parse line 103, ParserTestCase.parse line 875, ParserTestCase.testPropertyOptionUnexpected line 1010"
        ]
      }
    ],
    "org.apache.commons.cli.DefaultParserTest": [
      {
        "methodName": "testPropertyOptionGroup",
        "error": "org.apache.commons.cli.AlreadySelectedException",
        "message": "The option 'b' was specified but an option from this group has already been selected: 'a'",
        "fail_line": "",
        "test_source": "",
        "stack": [
          "OptionGroup.setSelected line 105, DefaultParser.updateRequiredOptions line 630, DefaultParser.handleOption line 594, DefaultParser.handleProperties line 174, DefaultParser.parse line 127, DefaultParser.parse line 75, ParserTestCase.parse line 877, ParserTestCase.testPropertyOptionGroup line 1037"
        ]
      },
      {
        "methodName": "testPropertyOptionUnexpected",
        "error": "java.lang.NullPointerException",
        "message": "",
        "fail_line": "",
        "test_source": "",
        "stack": [
          "DefaultParser.handleProperties line 159, DefaultParser.parse line 127, DefaultParser.parse line 75, ParserTestCase.parse line 877, ParserTestCase.testPropertyOptionUnexpected line 1010"
        ]
      }
    ],
    "org.apache.commons.cli.GnuParserTest": [
      {
        "methodName": "testPropertyOptionGroup",
        "error": "org.apache.commons.cli.AlreadySelectedException",
        "message": "The option 'b' was specified but an option from this group has already been selected: 'a'",
        "fail_line": "",
        "test_source": "",
        "stack": [
          "OptionGroup.setSelected line 105, Parser.updateRequiredOptions line 421, Parser.processProperties line 296, Parser.parse line 241, Parser.parse line 103, ParserTestCase.parse line 875, ParserTestCase.testPropertyOptionGroup line 1037"
        ]
      },
      {
        "methodName": "testPropertyOptionUnexpected",
        "error": "java.lang.NullPointerException",
        "message": "",
        "fail_line": "",
        "test_source": "",
        "stack": [
          "Parser.processProperties line 272, Parser.parse line 241, Parser.parse line 103, ParserTestCase.parse line 875, ParserTestCase.testPropertyOptionUnexpected line 1010"
        ]
      }
    ],
    "org.apache.commons.cli.OptionGroupTest": [
      {
        "methodName": "testTwoOptionsFromGroupWithProperties",
        "error": "org.apache.commons.cli.AlreadySelectedException",
        "message": "The option 'd' was specified but an option from this group has already been selected: 'f'",
        "fail_line": "        CommandLine cl = parser.parse( _options, args, properties);",
        "test_source": "  public void testTwoOptionsFromGroupWithProperties() throws Exception {\n  String[] args = new String[] { \"-f\" };\n  \n  Properties properties = new Properties();\n  properties.put(\"d\", \"true\");\n  \n  CommandLine cl = parser.parse( _options, args, properties);\n  assertTrue(cl.hasOption(\"f\"));\n  assertTrue(!cl.hasOption(\"d\"));\n  }",
        "stack": [
          "OptionGroup.setSelected line 105, Parser.updateRequiredOptions line 421, Parser.processProperties line 296, Parser.parse line 241, Parser.parse line 103, OptionGroupTest.testTwoOptionsFromGroupWithProperties line 198"
        ]
      }
    ],
    "org.apache.commons.cli.PosixParserTest": [
      {
        "methodName": "testPropertyOptionGroup",
        "error": "org.apache.commons.cli.AlreadySelectedException",
        "message": "The option 'b' was specified but an option from this group has already been selected: 'a'",
        "fail_line": "",
        "test_source": "",
        "stack": [
          "OptionGroup.setSelected line 105, Parser.updateRequiredOptions line 421, Parser.processProperties line 296, Parser.parse line 241, Parser.parse line 103, ParserTestCase.parse line 875, ParserTestCase.testPropertyOptionGroup line 1037"
        ]
      },
      {
        "methodName": "testPropertyOptionUnexpected",
        "error": "java.lang.NullPointerException",
        "message": "",
        "fail_line": "",
        "test_source": "",
        "stack": [
          "Parser.processProperties line 272, Parser.parse line 241, Parser.parse line 103, ParserTestCase.parse line 875, ParserTestCase.testPropertyOptionUnexpected line 1010"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/cli/DefaultParser.java",
      "buggy_full_code": "\n\npackage org.apache.commons.cli;\n\nimport java.util.ArrayList;\nimport java.util.Enumeration;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Properties;\n\n\npublic class DefaultParser implements CommandLineParser { protected CommandLine cmd; protected Options options; protected boolean stopAtNonOption; protected String currentToken; protected Option currentOption; protected boolean skipParsing; protected List expectedOpts; public CommandLine parse(Options options, String[] arguments) throws ParseException {\n        return parse(options, arguments, null);\n    }\n\n    \n    public CommandLine parse(Options options, String[] arguments, Properties properties) throws ParseException {\n        return parse(options, arguments, properties, false);\n    }\n\n    public CommandLine parse(Options options, String[] arguments, boolean stopAtNonOption) throws ParseException {\n        return parse(options, arguments, null, stopAtNonOption);\n    }\n\n    \n    public CommandLine parse(Options options, String[] arguments, Properties properties, boolean stopAtNonOption) throws ParseException {\n        this.options = options;\n        this.stopAtNonOption = stopAtNonOption;\n        skipParsing = false;\n        currentOption = null;\n        expectedOpts = new ArrayList(options.getRequiredOptions());\n        \n        \n        for (Iterator it = options.getOptionGroups().iterator(); it.hasNext();)\n        {\n            OptionGroup group = (OptionGroup) it.next();\n            group.setSelected(null);\n        }\n        \n        cmd = new CommandLine();\n\n        if (arguments != null)\n        {\n            for (int i = 0; i < arguments.length; i++)\n            {\n                handleToken(arguments[i]);\n            }\n        }\n        \n        \n        checkRequiredArgs();\n        \n        \n        handleProperties(properties);\n        \n        checkRequiredOptions();\n        \n        return cmd;\n    }\n\n    \n    private void handleProperties(Properties properties) throws ParseException {\n        if (properties == null)\n        {\n            return;\n        }\n        \n        for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n        {\n            String option = e.nextElement().toString();\n            \n            if (!cmd.hasOption(option))\n            {\n                Option opt = options.getOption(option);\n            \n            \n            \n                \n                String value = properties.getProperty(option);\n                \n                if (opt.hasArg())\n                {\n                    if (opt.getValues() == null || opt.getValues().length == 0)\n                    {\n                        opt.addValueForProcessing(value);\n                    }\n                }\n                else if (!(\"yes\".equalsIgnoreCase(value)\n                        || \"true\".equalsIgnoreCase(value)\n                        || \"1\".equalsIgnoreCase(value)))\n                {\n                    \n                    continue;\n                }\n                \n                handleOption(opt);\n                currentOption = null;\n            }\n        }\n    }\n\n    \n    private void checkRequiredOptions() throws MissingOptionException {       \n        \n        if (!expectedOpts.isEmpty())\n        {\n            throw new MissingOptionException(expectedOpts);\n        }\n    }\n\n    \n    private void checkRequiredArgs() throws ParseException {\n        if (currentOption != null && currentOption.requiresArg())\n        {\n            throw new MissingArgumentException(currentOption);\n        }\n    }\n\n    \n    private void handleToken(String token) throws ParseException {\n        currentToken = token;\n        \n        if (skipParsing)\n        {\n            cmd.addArg(token);\n        }\n        else if (\"--\".equals(token))\n        {\n            skipParsing = true;\n        }\n        else if (currentOption != null && currentOption.acceptsArg() && isArgument(token))\n        {\n            currentOption.addValueForProcessing(Util.stripLeadingAndTrailingQuotes(token));\n        }\n        else if (token.startsWith(\"--\"))\n        {\n            handleLongOption(token);\n        }\n        else if (token.startsWith(\"-\") && !\"-\".equals(token))\n        {\n            handleShortAndLongOption(token);\n        }\n        else\n        {\n            handleUnknownToken(token);\n        }\n        \n        if (currentOption != null && !currentOption.acceptsArg())\n        {\n            currentOption = null;\n        }\n    }\n\n    \n    private boolean isArgument(String token) {\n        return !isOption(token) || isNegativeNumber(token);\n    }\n\n    \n    private boolean isNegativeNumber(String token) {\n        try\n        {\n            Double.parseDouble(token);\n            return true;\n        }\n        catch (NumberFormatException e)\n        {\n            return false;\n        }\n    }\n\n    \n    private boolean isOption(String token) {\n        return isLongOption(token) || isShortOption(token);\n    }\n\n    \n    private boolean isShortOption(String token) {\n        \n        return token.startsWith(\"-\") && token.length() >= 2 && options.hasShortOption(token.substring(1, 2));\n    }\n\n    \n    private boolean isLongOption(String token) {\n        if (!token.startsWith(\"-\") || token.length() == 1)\n        {\n            return false;\n        }\n\n        int pos = token.indexOf(\"=\");\n        String t = pos == -1 ? token : token.substring(0, pos);\n        \n        if (!options.getMatchingOptions(t).isEmpty())\n        {\n            \n            return true;\n        }\n        else if (getLongPrefix(token) != null && !token.startsWith(\"--\"))\n        {\n            \n            return true;\n        }\n\n        return false;\n    }\n\n    \n    private void handleUnknownToken(String token) throws ParseException {\n        if (token.startsWith(\"-\") && token.length() > 1 && !stopAtNonOption)\n        {\n            throw new UnrecognizedOptionException(\"Unrecognized option: \" + token, token);\n        }\n        \n        cmd.addArg(token);\n        if (stopAtNonOption)\n        {\n            skipParsing = true;\n        }\n    }\n\n    \n    private void handleLongOption(String token) throws ParseException {\n        if (token.indexOf('=') == -1)\n        {\n            handleLongOptionWithoutEqual(token);\n        }\n        else\n        {\n            handleLongOptionWithEqual(token);                                   \n        }\n    }\n\n    \n    private void handleLongOptionWithoutEqual(String token) throws ParseException {\n        List matchingOpts = options.getMatchingOptions(token);\n        if (matchingOpts.isEmpty())\n        {\n            handleUnknownToken(currentToken);\n        }\n        else if (matchingOpts.size() > 1)\n        {\n            throw new AmbiguousOptionException(token, matchingOpts);\n        }\n        else\n        {\n            handleOption(options.getOption((String) matchingOpts.get(0)));\n        }\n    }\n\n    \n    private void handleLongOptionWithEqual(String token) throws ParseException {\n        int pos = token.indexOf('=');\n\n        String value = token.substring(pos + 1);\n        \n        String opt = token.substring(0, pos);\n        \n        List matchingOpts = options.getMatchingOptions(opt);\n        if (matchingOpts.isEmpty())\n        {\n            handleUnknownToken(currentToken);\n        }\n        else if (matchingOpts.size() > 1)\n        {\n            throw new AmbiguousOptionException(opt, matchingOpts);\n        }\n        else\n        {\n            Option option = options.getOption((String) matchingOpts.get(0));\n            \n            if (option.acceptsArg())\n            {\n                handleOption(option);\n                currentOption.addValueForProcessing(value);\n                currentOption = null;\n            }\n            else\n            {\n                handleUnknownToken(currentToken);\n            }\n        }\n    }\n\n    \n    private void handleShortAndLongOption(String token) throws ParseException {\n        String t = Util.stripLeadingHyphens(token);\n        \n        int pos = t.indexOf('=');\n        \n        if (t.length() == 1)\n        {\n            \n            if (options.hasShortOption(t))\n            {\n                handleOption(options.getOption(t));\n            }\n            else\n            {\n                handleUnknownToken(token);\n            }\n        }\n        else if (pos == -1)\n        {\n            if (options.hasShortOption(t))\n            {\n                handleOption(options.getOption(t));\n            }\n            else if (!options.getMatchingOptions(t).isEmpty())\n            {\n                \n                handleLongOptionWithoutEqual(token);\n            }\n            else\n            {\n                \n                String opt = getLongPrefix(t);\n                \n                if (opt != null && options.getOption(opt).acceptsArg())\n                {\n                    handleOption(options.getOption(opt));\n                    currentOption.addValueForProcessing(t.substring(opt.length()));\n                    currentOption = null;\n                }\n                else if (isJavaProperty(t))\n                {\n                    \n                    handleOption(options.getOption(t.substring(0, 1)));\n                    currentOption.addValueForProcessing(t.substring(1));\n                    currentOption = null;\n                }\n                else\n                {\n                    \n                    handleConcatenatedOptions(token);\n                }\n            }\n        }\n        else\n        {\n            String opt = t.substring(0, pos);\n            String value = t.substring(pos + 1);\n            \n            if (opt.length() == 1)\n            {\n                \n                Option option = options.getOption(opt);\n                if (option != null && option.acceptsArg())\n                {\n                    handleOption(option);\n                    currentOption.addValueForProcessing(value);\n                    currentOption = null;\n                }\n                else\n                {\n                    handleUnknownToken(token);\n                }\n            }\n            else if (isJavaProperty(opt))\n            {\n                \n                handleOption(options.getOption(opt.substring(0, 1)));\n                currentOption.addValueForProcessing(opt.substring(1));\n                currentOption.addValueForProcessing(value);\n                currentOption = null;\n            }\n            else\n            {\n                \n                handleLongOptionWithEqual(token);\n            }\n        }\n    }\n\n    \n    private String getLongPrefix(String token) {\n        String t = Util.stripLeadingHyphens(token);\n        \n        int i;\n        String opt = null;\n        for (i = t.length() - 2; i > 1; i--)\n        {\n            String prefix = t.substring(0, i);\n            if (options.hasLongOption(prefix))\n            {\n                opt = prefix;\n                break;\n            }\n        }\n        \n        return opt;\n    }\n\n    \n    private boolean isJavaProperty(String token) {\n        String opt = token.substring(0, 1);\n        Option option = options.getOption(opt);\n        \n        return option != null && (option.getArgs() >= 2 || option.getArgs() == Option.UNLIMITED_VALUES);\n    }\n\n    private void handleOption(Option option) throws ParseException {\n        \n        checkRequiredArgs();\n        \n        option = (Option) option.clone();\n        \n        updateRequiredOptions(option);\n        \n        cmd.addOption(option);\n        \n        if (option.hasArg())\n        {\n            currentOption = option;            \n        }\n        else\n        {\n            currentOption = null;\n        }\n    }\n\n    \n    private void updateRequiredOptions(Option option) throws AlreadySelectedException {\n        if (option.isRequired())\n        {\n            expectedOpts.remove(option.getKey());\n        }\n\n        \n        if (options.getOptionGroup(option) != null)\n        {\n            OptionGroup group = options.getOptionGroup(option);\n\n            if (group.isRequired())\n            {\n                expectedOpts.remove(group);\n            }\n\n            group.setSelected(option);\n        }\n    }\n\n    \n    protected void handleConcatenatedOptions(String token) throws ParseException {\n        for (int i = 1; i < token.length(); i++)\n        {\n            String ch = String.valueOf(token.charAt(i));\n\n            if (options.hasOption(ch))\n            {\n                handleOption(options.getOption(ch));\n                \n                if (currentOption != null && (token.length() != (i + 1)))\n                {\n                    \n                    currentOption.addValueForProcessing(token.substring(i + 1));\n                    break;\n                }\n            }\n            else\n            {                \n                handleUnknownToken(stopAtNonOption && i > 1 ? token.substring(i) : token);\n                break;\n            }\n        }\n    }\n}\n",
      "fixed_full_code": "\n\npackage org.apache.commons.cli;\n\nimport java.util.ArrayList;\nimport java.util.Enumeration;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Properties;\n\n\npublic class DefaultParser implements CommandLineParser { protected CommandLine cmd; protected Options options; protected boolean stopAtNonOption; protected String currentToken; protected Option currentOption; protected boolean skipParsing; protected List expectedOpts; public CommandLine parse(Options options, String[] arguments) throws ParseException {\n        return parse(options, arguments, null);\n    }\n\n    \n    public CommandLine parse(Options options, String[] arguments, Properties properties) throws ParseException {\n        return parse(options, arguments, properties, false);\n    }\n\n    public CommandLine parse(Options options, String[] arguments, boolean stopAtNonOption) throws ParseException {\n        return parse(options, arguments, null, stopAtNonOption);\n    }\n\n    \n    public CommandLine parse(Options options, String[] arguments, Properties properties, boolean stopAtNonOption) throws ParseException {\n        this.options = options;\n        this.stopAtNonOption = stopAtNonOption;\n        skipParsing = false;\n        currentOption = null;\n        expectedOpts = new ArrayList(options.getRequiredOptions());\n        \n        \n        for (Iterator it = options.getOptionGroups().iterator(); it.hasNext();)\n        {\n            OptionGroup group = (OptionGroup) it.next();\n            group.setSelected(null);\n        }\n        \n        cmd = new CommandLine();\n\n        if (arguments != null)\n        {\n            for (int i = 0; i < arguments.length; i++)\n            {\n                handleToken(arguments[i]);\n            }\n        }\n        \n        \n        checkRequiredArgs();\n        \n        \n        handleProperties(properties);\n        \n        checkRequiredOptions();\n        \n        return cmd;\n    }\n\n    \n    private void handleProperties(Properties properties) throws ParseException {\n        if (properties == null)\n        {\n            return;\n        }\n        \n        for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n        {\n            String option = e.nextElement().toString();\n            \n            Option opt = options.getOption(option);\n            if (opt == null)\n            {\n                throw new UnrecognizedOptionException(\"Default option wasn't defined\", option);\n            }\n            \n            \n            OptionGroup group = options.getOptionGroup(opt);\n            boolean selected = group != null && group.getSelected() != null;\n            \n            if (!cmd.hasOption(option) && !selected)\n            {\n                \n                String value = properties.getProperty(option);\n                \n                if (opt.hasArg())\n                {\n                    if (opt.getValues() == null || opt.getValues().length == 0)\n                    {\n                        opt.addValueForProcessing(value);\n                    }\n                }\n                else if (!(\"yes\".equalsIgnoreCase(value)\n                        || \"true\".equalsIgnoreCase(value)\n                        || \"1\".equalsIgnoreCase(value)))\n                {\n                    \n                    continue;\n                }\n                \n                handleOption(opt);\n                currentOption = null;\n            }\n        }\n    }\n\n    \n    private void checkRequiredOptions() throws MissingOptionException {       \n        \n        if (!expectedOpts.isEmpty())\n        {\n            throw new MissingOptionException(expectedOpts);\n        }\n    }\n\n    \n    private void checkRequiredArgs() throws ParseException {\n        if (currentOption != null && currentOption.requiresArg())\n        {\n            throw new MissingArgumentException(currentOption);\n        }\n    }\n\n    \n    private void handleToken(String token) throws ParseException {\n        currentToken = token;\n        \n        if (skipParsing)\n        {\n            cmd.addArg(token);\n        }\n        else if (\"--\".equals(token))\n        {\n            skipParsing = true;\n        }\n        else if (currentOption != null && currentOption.acceptsArg() && isArgument(token))\n        {\n            currentOption.addValueForProcessing(Util.stripLeadingAndTrailingQuotes(token));\n        }\n        else if (token.startsWith(\"--\"))\n        {\n            handleLongOption(token);\n        }\n        else if (token.startsWith(\"-\") && !\"-\".equals(token))\n        {\n            handleShortAndLongOption(token);\n        }\n        else\n        {\n            handleUnknownToken(token);\n        }\n        \n        if (currentOption != null && !currentOption.acceptsArg())\n        {\n            currentOption = null;\n        }\n    }\n\n    \n    private boolean isArgument(String token) {\n        return !isOption(token) || isNegativeNumber(token);\n    }\n\n    \n    private boolean isNegativeNumber(String token) {\n        try\n        {\n            Double.parseDouble(token);\n            return true;\n        }\n        catch (NumberFormatException e)\n        {\n            return false;\n        }\n    }\n\n    \n    private boolean isOption(String token) {\n        return isLongOption(token) || isShortOption(token);\n    }\n\n    \n    private boolean isShortOption(String token) {\n        \n        return token.startsWith(\"-\") && token.length() >= 2 && options.hasShortOption(token.substring(1, 2));\n    }\n\n    \n    private boolean isLongOption(String token) {\n        if (!token.startsWith(\"-\") || token.length() == 1)\n        {\n            return false;\n        }\n\n        int pos = token.indexOf(\"=\");\n        String t = pos == -1 ? token : token.substring(0, pos);\n        \n        if (!options.getMatchingOptions(t).isEmpty())\n        {\n            \n            return true;\n        }\n        else if (getLongPrefix(token) != null && !token.startsWith(\"--\"))\n        {\n            \n            return true;\n        }\n\n        return false;\n    }\n\n    \n    private void handleUnknownToken(String token) throws ParseException {\n        if (token.startsWith(\"-\") && token.length() > 1 && !stopAtNonOption)\n        {\n            throw new UnrecognizedOptionException(\"Unrecognized option: \" + token, token);\n        }\n        \n        cmd.addArg(token);\n        if (stopAtNonOption)\n        {\n            skipParsing = true;\n        }\n    }\n\n    \n    private void handleLongOption(String token) throws ParseException {\n        if (token.indexOf('=') == -1)\n        {\n            handleLongOptionWithoutEqual(token);\n        }\n        else\n        {\n            handleLongOptionWithEqual(token);                                   \n        }\n    }\n\n    \n    private void handleLongOptionWithoutEqual(String token) throws ParseException {\n        List matchingOpts = options.getMatchingOptions(token);\n        if (matchingOpts.isEmpty())\n        {\n            handleUnknownToken(currentToken);\n        }\n        else if (matchingOpts.size() > 1)\n        {\n            throw new AmbiguousOptionException(token, matchingOpts);\n        }\n        else\n        {\n            handleOption(options.getOption((String) matchingOpts.get(0)));\n        }\n    }\n\n    \n    private void handleLongOptionWithEqual(String token) throws ParseException {\n        int pos = token.indexOf('=');\n\n        String value = token.substring(pos + 1);\n        \n        String opt = token.substring(0, pos);\n        \n        List matchingOpts = options.getMatchingOptions(opt);\n        if (matchingOpts.isEmpty())\n        {\n            handleUnknownToken(currentToken);\n        }\n        else if (matchingOpts.size() > 1)\n        {\n            throw new AmbiguousOptionException(opt, matchingOpts);\n        }\n        else\n        {\n            Option option = options.getOption((String) matchingOpts.get(0));\n            \n            if (option.acceptsArg())\n            {\n                handleOption(option);\n                currentOption.addValueForProcessing(value);\n                currentOption = null;\n            }\n            else\n            {\n                handleUnknownToken(currentToken);\n            }\n        }\n    }\n\n    \n    private void handleShortAndLongOption(String token) throws ParseException {\n        String t = Util.stripLeadingHyphens(token);\n        \n        int pos = t.indexOf('=');\n        \n        if (t.length() == 1)\n        {\n            \n            if (options.hasShortOption(t))\n            {\n                handleOption(options.getOption(t));\n            }\n            else\n            {\n                handleUnknownToken(token);\n            }\n        }\n        else if (pos == -1)\n        {\n            if (options.hasShortOption(t))\n            {\n                handleOption(options.getOption(t));\n            }\n            else if (!options.getMatchingOptions(t).isEmpty())\n            {\n                \n                handleLongOptionWithoutEqual(token);\n            }\n            else\n            {\n                \n                String opt = getLongPrefix(t);\n                \n                if (opt != null && options.getOption(opt).acceptsArg())\n                {\n                    handleOption(options.getOption(opt));\n                    currentOption.addValueForProcessing(t.substring(opt.length()));\n                    currentOption = null;\n                }\n                else if (isJavaProperty(t))\n                {\n                    \n                    handleOption(options.getOption(t.substring(0, 1)));\n                    currentOption.addValueForProcessing(t.substring(1));\n                    currentOption = null;\n                }\n                else\n                {\n                    \n                    handleConcatenatedOptions(token);\n                }\n            }\n        }\n        else\n        {\n            String opt = t.substring(0, pos);\n            String value = t.substring(pos + 1);\n            \n            if (opt.length() == 1)\n            {\n                \n                Option option = options.getOption(opt);\n                if (option != null && option.acceptsArg())\n                {\n                    handleOption(option);\n                    currentOption.addValueForProcessing(value);\n                    currentOption = null;\n                }\n                else\n                {\n                    handleUnknownToken(token);\n                }\n            }\n            else if (isJavaProperty(opt))\n            {\n                \n                handleOption(options.getOption(opt.substring(0, 1)));\n                currentOption.addValueForProcessing(opt.substring(1));\n                currentOption.addValueForProcessing(value);\n                currentOption = null;\n            }\n            else\n            {\n                \n                handleLongOptionWithEqual(token);\n            }\n        }\n    }\n\n    \n    private String getLongPrefix(String token) {\n        String t = Util.stripLeadingHyphens(token);\n        \n        int i;\n        String opt = null;\n        for (i = t.length() - 2; i > 1; i--)\n        {\n            String prefix = t.substring(0, i);\n            if (options.hasLongOption(prefix))\n            {\n                opt = prefix;\n                break;\n            }\n        }\n        \n        return opt;\n    }\n\n    \n    private boolean isJavaProperty(String token) {\n        String opt = token.substring(0, 1);\n        Option option = options.getOption(opt);\n        \n        return option != null && (option.getArgs() >= 2 || option.getArgs() == Option.UNLIMITED_VALUES);\n    }\n\n    private void handleOption(Option option) throws ParseException {\n        \n        checkRequiredArgs();\n        \n        option = (Option) option.clone();\n        \n        updateRequiredOptions(option);\n        \n        cmd.addOption(option);\n        \n        if (option.hasArg())\n        {\n            currentOption = option;            \n        }\n        else\n        {\n            currentOption = null;\n        }\n    }\n\n    \n    private void updateRequiredOptions(Option option) throws AlreadySelectedException {\n        if (option.isRequired())\n        {\n            expectedOpts.remove(option.getKey());\n        }\n\n        \n        if (options.getOptionGroup(option) != null)\n        {\n            OptionGroup group = options.getOptionGroup(option);\n\n            if (group.isRequired())\n            {\n                expectedOpts.remove(group);\n            }\n\n            group.setSelected(option);\n        }\n    }\n\n    \n    protected void handleConcatenatedOptions(String token) throws ParseException {\n        for (int i = 1; i < token.length(); i++)\n        {\n            String ch = String.valueOf(token.charAt(i));\n\n            if (options.hasOption(ch))\n            {\n                handleOption(options.getOption(ch));\n                \n                if (currentOption != null && (token.length() != (i + 1)))\n                {\n                    \n                    currentOption.addValueForProcessing(token.substring(i + 1));\n                    break;\n                }\n            }\n            else\n            {                \n                handleUnknownToken(stopAtNonOption && i > 1 ? token.substring(i) : token);\n                break;\n            }\n        }\n    }\n}\n",
      "buggy_signatures": [
        "public class DefaultParser implements CommandLineParser { protected CommandLine cmd; protected Options options; protected boolean stopAtNonOption; protected String currentToken; protected Option currentOption; protected boolean skipParsing; protected List expectedOpts; public CommandLine parse(Options options, String[] arguments) throws ParseException",
        "public CommandLine parse(Options options, String[] arguments, Properties properties) throws ParseException",
        "public CommandLine parse(Options options, String[] arguments, boolean stopAtNonOption) throws ParseException",
        "public CommandLine parse(Options options, String[] arguments, Properties properties, boolean stopAtNonOption) throws ParseException",
        "private void handleProperties(Properties properties) throws ParseException",
        "private void checkRequiredOptions() throws MissingOptionException",
        "private void checkRequiredArgs() throws ParseException",
        "private void handleToken(String token) throws ParseException",
        "private boolean isArgument(String token)",
        "private boolean isNegativeNumber(String token)",
        "private boolean isOption(String token)",
        "private boolean isShortOption(String token)",
        "private boolean isLongOption(String token)",
        "private void handleUnknownToken(String token) throws ParseException",
        "private void handleLongOption(String token) throws ParseException",
        "private void handleLongOptionWithoutEqual(String token) throws ParseException",
        "private void handleLongOptionWithEqual(String token) throws ParseException",
        "private void handleShortAndLongOption(String token) throws ParseException",
        "private String getLongPrefix(String token)",
        "private boolean isJavaProperty(String token)",
        "private void handleOption(Option option) throws ParseException",
        "private void updateRequiredOptions(Option option) throws AlreadySelectedException",
        "protected void handleConcatenatedOptions(String token) throws ParseException"
      ],
      "fixed_signatures": [
        "public class DefaultParser implements CommandLineParser { protected CommandLine cmd; protected Options options; protected boolean stopAtNonOption; protected String currentToken; protected Option currentOption; protected boolean skipParsing; protected List expectedOpts; public CommandLine parse(Options options, String[] arguments) throws ParseException",
        "public CommandLine parse(Options options, String[] arguments, Properties properties) throws ParseException",
        "public CommandLine parse(Options options, String[] arguments, boolean stopAtNonOption) throws ParseException",
        "public CommandLine parse(Options options, String[] arguments, Properties properties, boolean stopAtNonOption) throws ParseException",
        "private void handleProperties(Properties properties) throws ParseException",
        "private void checkRequiredOptions() throws MissingOptionException",
        "private void checkRequiredArgs() throws ParseException",
        "private void handleToken(String token) throws ParseException",
        "private boolean isArgument(String token)",
        "private boolean isNegativeNumber(String token)",
        "private boolean isOption(String token)",
        "private boolean isShortOption(String token)",
        "private boolean isLongOption(String token)",
        "private void handleUnknownToken(String token) throws ParseException",
        "private void handleLongOption(String token) throws ParseException",
        "private void handleLongOptionWithoutEqual(String token) throws ParseException",
        "private void handleLongOptionWithEqual(String token) throws ParseException",
        "private void handleShortAndLongOption(String token) throws ParseException",
        "private String getLongPrefix(String token)",
        "private boolean isJavaProperty(String token)",
        "private void handleOption(Option option) throws ParseException",
        "private void updateRequiredOptions(Option option) throws AlreadySelectedException",
        "protected void handleConcatenatedOptions(String token) throws ParseException"
      ],
      "methods": [
        {
          "buggy_method": "  private void handleProperties(Properties properties) throws ParseException {\n  if (properties == null)\n  {\n  return;\n  }\n  \n  for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n  {\n  String option = e.nextElement().toString();\n  \n  if (!cmd.hasOption(option))\n  {\n  Option opt = options.getOption(option);\n  \n  \n  \n  \n  String value = properties.getProperty(option);\n  \n  if (opt.hasArg())\n  {\n  if (opt.getValues() == null || opt.getValues().length == 0)\n  {\n  opt.addValueForProcessing(value);\n  }\n  }\n  else if (!(\"yes\".equalsIgnoreCase(value)\n  || \"true\".equalsIgnoreCase(value)\n  || \"1\".equalsIgnoreCase(value)))\n  {\n  \n  continue;\n  }\n  \n  handleOption(opt);\n  currentOption = null;\n  }\n  }\n  }",
          "fixed_method": "  private void handleProperties(Properties properties) throws ParseException {\n  if (properties == null)\n  {\n  return;\n  }\n  \n  for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n  {\n  String option = e.nextElement().toString();\n  \n  Option opt = options.getOption(option);\n  if (opt == null)\n  {\n  throw new UnrecognizedOptionException(\"Default option wasn't defined\", option);\n  }\n  \n  \n  OptionGroup group = options.getOptionGroup(opt);\n  boolean selected = group != null && group.getSelected() != null;\n  \n  if (!cmd.hasOption(option) && !selected)\n  {\n  \n  String value = properties.getProperty(option);\n  \n  if (opt.hasArg())\n  {\n  if (opt.getValues() == null || opt.getValues().length == 0)\n  {\n  opt.addValueForProcessing(value);\n  }\n  }\n  else if (!(\"yes\".equalsIgnoreCase(value)\n  || \"true\".equalsIgnoreCase(value)\n  || \"1\".equalsIgnoreCase(value)))\n  {\n  \n  continue;\n  }\n  \n  handleOption(opt);\n  currentOption = null;\n  }\n  }\n  }",
          "diff": [
            "@@ -147,12 +147,18 @@",
            "         {\n",
            "             String option = e.nextElement().toString();\n",
            "             \n",
            "-            if (!cmd.hasOption(option))\n",
            "-            {\n",
            "-                Option opt = options.getOption(option);\n",
            "+            Option opt = options.getOption(option);\n",
            "+            if (opt == null)\n",
            "+            {\n",
            "+                throw new UnrecognizedOptionException(\"Default option wasn't defined\", option);\n",
            "+            }\n",
            "             \n",
            "             // if the option is part of a group, check if another option of the group has been selected\n",
            "+            OptionGroup group = options.getOptionGroup(opt);\n",
            "+            boolean selected = group != null && group.getSelected() != null;\n",
            "             \n",
            "+            if (!cmd.hasOption(option) && !selected)\n",
            "+            {\n",
            "                 // get the value from the properties\n",
            "                 String value = properties.getProperty(option);\n",
            "                 \n"
          ],
          "changed_lines": 12
        }
      ]
    },
    {
      "name": "org/apache/commons/cli/Parser.java",
      "buggy_full_code": "\n\npackage org.apache.commons.cli;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Properties;\n\n\npublic abstract class Parser implements CommandLineParser { protected CommandLine cmd; private Options options; private List requiredOptions; protected void setOptions(final Options options) {\n        this.options = options;\n        this.requiredOptions = new ArrayList(options.getRequiredOptions());\n    }\n\n    protected Options getOptions() {\n        return options;\n    }\n\n    protected List getRequiredOptions() {\n        return requiredOptions;\n    }\n\n    \n    protected abstract String[] flatten(Options opts, String[] arguments, boolean stopAtNonOption) throws ParseException; public CommandLine parse(Options options, String[] arguments) throws ParseException {\n        return parse(options, arguments, null, false);\n    }\n\n    \n    public CommandLine parse(Options options, String[] arguments, Properties properties) throws ParseException {\n        return parse(options, arguments, properties, false);\n    }\n\n    \n    public CommandLine parse(Options options, String[] arguments, boolean stopAtNonOption) throws ParseException {\n        return parse(options, arguments, null, stopAtNonOption);\n    }\n\n    \n    public CommandLine parse(Options options, String[] arguments, Properties properties, boolean stopAtNonOption) throws ParseException {\n        \n        for (Iterator it = options.helpOptions().iterator(); it.hasNext();)\n        {\n            Option opt = (Option) it.next();\n            opt.clearValues();\n        }\n        \n        \n        for (Iterator it = options.getOptionGroups().iterator(); it.hasNext();)\n        {\n            OptionGroup group = (OptionGroup) it.next();\n            group.setSelected(null);\n        }        \n\n        \n        setOptions(options);\n\n        cmd = new CommandLine();\n\n        boolean eatTheRest = false;\n\n        if (arguments == null)\n        {\n            arguments = new String[0];\n        }\n\n        List tokenList = Arrays.asList(flatten(getOptions(), arguments, stopAtNonOption));\n\n        ListIterator iterator = tokenList.listIterator();\n\n        \n        while (iterator.hasNext())\n        {\n            String t = (String) iterator.next();\n\n            \n            if (\"--\".equals(t))\n            {\n                eatTheRest = true;\n            }\n\n            \n            else if (\"-\".equals(t))\n            {\n                if (stopAtNonOption)\n                {\n                    eatTheRest = true;\n                }\n                else\n                {\n                    cmd.addArg(t);\n                }\n            }\n\n            \n            else if (t.startsWith(\"-\"))\n            {\n                if (stopAtNonOption && !getOptions().hasOption(t))\n                {\n                    eatTheRest = true;\n                    cmd.addArg(t);\n                }\n                else\n                {\n                    processOption(t, iterator);\n                }\n            }\n\n            \n            else\n            {\n                cmd.addArg(t);\n\n                if (stopAtNonOption)\n                {\n                    eatTheRest = true;\n                }\n            }\n\n            \n            if (eatTheRest)\n            {\n                while (iterator.hasNext())\n                {\n                    String str = (String) iterator.next();\n\n                    \n                    if (!\"--\".equals(str))\n                    {\n                        cmd.addArg(str);\n                    }\n                }\n            }\n        }\n\n        processProperties(properties);\n        checkRequiredOptions();\n\n        return cmd;\n    }\n\n    \n    protected void processProperties(Properties properties) throws ParseException {\n        if (properties == null)\n        {\n            return;\n        }\n\n        for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n        {\n            String option = e.nextElement().toString();\n            \n            if (!cmd.hasOption(option))\n            {\n                Option opt = getOptions().getOption(option);\n            \n            \n            \n                \n                String value = properties.getProperty(option);\n\n                if (opt.hasArg())\n                {\n                    if (opt.getValues() == null || opt.getValues().length == 0)\n                    {\n                        try\n                        {\n                            opt.addValueForProcessing(value);\n                        }\n                        catch (RuntimeException exp)\n                        {\n                            \n                        }\n                    }\n                }\n                else if (!(\"yes\".equalsIgnoreCase(value)\n                        || \"true\".equalsIgnoreCase(value)\n                        || \"1\".equalsIgnoreCase(value)))\n                {\n                    \n                    \n                    continue;\n                }\n\n                cmd.addOption(opt);\n                updateRequiredOptions(opt);\n            }\n        }\n    }\n\n    \n    protected void checkRequiredOptions() throws MissingOptionException {\n        \n        if (!getRequiredOptions().isEmpty())\n        {\n            throw new MissingOptionException(getRequiredOptions());\n        }\n    }\n\n    \n    public void processArgs(Option opt, ListIterator iter) throws ParseException {\n        \n        while (iter.hasNext())\n        {\n            String str = (String) iter.next();\n\n            \n            if (getOptions().hasOption(str) && str.startsWith(\"-\"))\n            {\n                iter.previous();\n                break;\n            }\n\n            \n            try\n            {\n                opt.addValueForProcessing(Util.stripLeadingAndTrailingQuotes(str));\n            }\n            catch (RuntimeException exp)\n            {\n                iter.previous();\n                break;\n            }\n        }\n\n        if (opt.getValues() == null && !opt.hasOptionalArg())\n        {\n            throw new MissingArgumentException(opt);\n        }\n    }\n\n    \n    protected void processOption(String arg, ListIterator iter) throws ParseException {\n        boolean hasOption = getOptions().hasOption(arg);\n\n        \n        if (!hasOption)\n        {\n            throw new UnrecognizedOptionException(\"Unrecognized option: \" + arg, arg);\n        }\n\n        \n        Option opt = (Option) getOptions().getOption(arg).clone();\n        \n        \n        updateRequiredOptions(opt);\n        \n        \n        if (opt.hasArg())\n        {\n            processArgs(opt, iter);\n        }\n        \n        \n        cmd.addOption(opt);\n    }\n\n    \n    private void updateRequiredOptions(Option opt) throws ParseException {\n        \n        \n        if (opt.isRequired())\n        {\n            getRequiredOptions().remove(opt.getKey());\n        }\n\n        \n        \n        if (getOptions().getOptionGroup(opt) != null)\n        {\n            OptionGroup group = getOptions().getOptionGroup(opt);\n\n            if (group.isRequired())\n            {\n                getRequiredOptions().remove(group);\n            }\n\n            group.setSelected(opt);\n        }\n    }\n}\n",
      "fixed_full_code": "\n\npackage org.apache.commons.cli;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Properties;\n\n\npublic abstract class Parser implements CommandLineParser { protected CommandLine cmd; private Options options; private List requiredOptions; protected void setOptions(final Options options) {\n        this.options = options;\n        this.requiredOptions = new ArrayList(options.getRequiredOptions());\n    }\n\n    protected Options getOptions() {\n        return options;\n    }\n\n    protected List getRequiredOptions() {\n        return requiredOptions;\n    }\n\n    \n    protected abstract String[] flatten(Options opts, String[] arguments, boolean stopAtNonOption) throws ParseException; public CommandLine parse(Options options, String[] arguments) throws ParseException {\n        return parse(options, arguments, null, false);\n    }\n\n    \n    public CommandLine parse(Options options, String[] arguments, Properties properties) throws ParseException {\n        return parse(options, arguments, properties, false);\n    }\n\n    \n    public CommandLine parse(Options options, String[] arguments, boolean stopAtNonOption) throws ParseException {\n        return parse(options, arguments, null, stopAtNonOption);\n    }\n\n    \n    public CommandLine parse(Options options, String[] arguments, Properties properties, boolean stopAtNonOption) throws ParseException {\n        \n        for (Iterator it = options.helpOptions().iterator(); it.hasNext();)\n        {\n            Option opt = (Option) it.next();\n            opt.clearValues();\n        }\n        \n        \n        for (Iterator it = options.getOptionGroups().iterator(); it.hasNext();)\n        {\n            OptionGroup group = (OptionGroup) it.next();\n            group.setSelected(null);\n        }        \n\n        \n        setOptions(options);\n\n        cmd = new CommandLine();\n\n        boolean eatTheRest = false;\n\n        if (arguments == null)\n        {\n            arguments = new String[0];\n        }\n\n        List tokenList = Arrays.asList(flatten(getOptions(), arguments, stopAtNonOption));\n\n        ListIterator iterator = tokenList.listIterator();\n\n        \n        while (iterator.hasNext())\n        {\n            String t = (String) iterator.next();\n\n            \n            if (\"--\".equals(t))\n            {\n                eatTheRest = true;\n            }\n\n            \n            else if (\"-\".equals(t))\n            {\n                if (stopAtNonOption)\n                {\n                    eatTheRest = true;\n                }\n                else\n                {\n                    cmd.addArg(t);\n                }\n            }\n\n            \n            else if (t.startsWith(\"-\"))\n            {\n                if (stopAtNonOption && !getOptions().hasOption(t))\n                {\n                    eatTheRest = true;\n                    cmd.addArg(t);\n                }\n                else\n                {\n                    processOption(t, iterator);\n                }\n            }\n\n            \n            else\n            {\n                cmd.addArg(t);\n\n                if (stopAtNonOption)\n                {\n                    eatTheRest = true;\n                }\n            }\n\n            \n            if (eatTheRest)\n            {\n                while (iterator.hasNext())\n                {\n                    String str = (String) iterator.next();\n\n                    \n                    if (!\"--\".equals(str))\n                    {\n                        cmd.addArg(str);\n                    }\n                }\n            }\n        }\n\n        processProperties(properties);\n        checkRequiredOptions();\n\n        return cmd;\n    }\n\n    \n    protected void processProperties(Properties properties) throws ParseException {\n        if (properties == null)\n        {\n            return;\n        }\n\n        for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n        {\n            String option = e.nextElement().toString();\n            \n            Option opt = options.getOption(option);\n            if (opt == null)\n            {\n                throw new UnrecognizedOptionException(\"Default option wasn't defined\", option);\n            }\n            \n            \n            OptionGroup group = options.getOptionGroup(opt);\n            boolean selected = group != null && group.getSelected() != null;\n            \n            if (!cmd.hasOption(option) && !selected)\n            {\n                \n                String value = properties.getProperty(option);\n\n                if (opt.hasArg())\n                {\n                    if (opt.getValues() == null || opt.getValues().length == 0)\n                    {\n                        try\n                        {\n                            opt.addValueForProcessing(value);\n                        }\n                        catch (RuntimeException exp)\n                        {\n                            \n                        }\n                    }\n                }\n                else if (!(\"yes\".equalsIgnoreCase(value)\n                        || \"true\".equalsIgnoreCase(value)\n                        || \"1\".equalsIgnoreCase(value)))\n                {\n                    \n                    \n                    continue;\n                }\n\n                cmd.addOption(opt);\n                updateRequiredOptions(opt);\n            }\n        }\n    }\n\n    \n    protected void checkRequiredOptions() throws MissingOptionException {\n        \n        if (!getRequiredOptions().isEmpty())\n        {\n            throw new MissingOptionException(getRequiredOptions());\n        }\n    }\n\n    \n    public void processArgs(Option opt, ListIterator iter) throws ParseException {\n        \n        while (iter.hasNext())\n        {\n            String str = (String) iter.next();\n\n            \n            if (getOptions().hasOption(str) && str.startsWith(\"-\"))\n            {\n                iter.previous();\n                break;\n            }\n\n            \n            try\n            {\n                opt.addValueForProcessing(Util.stripLeadingAndTrailingQuotes(str));\n            }\n            catch (RuntimeException exp)\n            {\n                iter.previous();\n                break;\n            }\n        }\n\n        if (opt.getValues() == null && !opt.hasOptionalArg())\n        {\n            throw new MissingArgumentException(opt);\n        }\n    }\n\n    \n    protected void processOption(String arg, ListIterator iter) throws ParseException {\n        boolean hasOption = getOptions().hasOption(arg);\n\n        \n        if (!hasOption)\n        {\n            throw new UnrecognizedOptionException(\"Unrecognized option: \" + arg, arg);\n        }\n\n        \n        Option opt = (Option) getOptions().getOption(arg).clone();\n        \n        \n        updateRequiredOptions(opt);\n        \n        \n        if (opt.hasArg())\n        {\n            processArgs(opt, iter);\n        }\n        \n        \n        cmd.addOption(opt);\n    }\n\n    \n    private void updateRequiredOptions(Option opt) throws ParseException {\n        \n        \n        if (opt.isRequired())\n        {\n            getRequiredOptions().remove(opt.getKey());\n        }\n\n        \n        \n        if (getOptions().getOptionGroup(opt) != null)\n        {\n            OptionGroup group = getOptions().getOptionGroup(opt);\n\n            if (group.isRequired())\n            {\n                getRequiredOptions().remove(group);\n            }\n\n            group.setSelected(opt);\n        }\n    }\n}\n",
      "buggy_signatures": [
        "public abstract class Parser implements CommandLineParser { protected CommandLine cmd; private Options options; private List requiredOptions; protected void setOptions(final Options options)",
        "protected Options getOptions()",
        "protected List getRequiredOptions()",
        "protected abstract String[] flatten(Options opts, String[] arguments, boolean stopAtNonOption) throws ParseException; public CommandLine parse(Options options, String[] arguments) throws ParseException",
        "public CommandLine parse(Options options, String[] arguments, Properties properties) throws ParseException",
        "public CommandLine parse(Options options, String[] arguments, boolean stopAtNonOption) throws ParseException",
        "public CommandLine parse(Options options, String[] arguments, Properties properties, boolean stopAtNonOption) throws ParseException",
        "protected void processProperties(Properties properties) throws ParseException",
        "protected void checkRequiredOptions() throws MissingOptionException",
        "public void processArgs(Option opt, ListIterator iter) throws ParseException",
        "protected void processOption(String arg, ListIterator iter) throws ParseException",
        "private void updateRequiredOptions(Option opt) throws ParseException"
      ],
      "fixed_signatures": [
        "public abstract class Parser implements CommandLineParser { protected CommandLine cmd; private Options options; private List requiredOptions; protected void setOptions(final Options options)",
        "protected Options getOptions()",
        "protected List getRequiredOptions()",
        "protected abstract String[] flatten(Options opts, String[] arguments, boolean stopAtNonOption) throws ParseException; public CommandLine parse(Options options, String[] arguments) throws ParseException",
        "public CommandLine parse(Options options, String[] arguments, Properties properties) throws ParseException",
        "public CommandLine parse(Options options, String[] arguments, boolean stopAtNonOption) throws ParseException",
        "public CommandLine parse(Options options, String[] arguments, Properties properties, boolean stopAtNonOption) throws ParseException",
        "protected void processProperties(Properties properties) throws ParseException",
        "protected void checkRequiredOptions() throws MissingOptionException",
        "public void processArgs(Option opt, ListIterator iter) throws ParseException",
        "protected void processOption(String arg, ListIterator iter) throws ParseException",
        "private void updateRequiredOptions(Option opt) throws ParseException"
      ],
      "methods": [
        {
          "buggy_method": "  protected void processProperties(Properties properties) throws ParseException {\n  if (properties == null)\n  {\n  return;\n  }\n\n  for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n  {\n  String option = e.nextElement().toString();\n  \n  if (!cmd.hasOption(option))\n  {\n  Option opt = getOptions().getOption(option);\n  \n  \n  \n  \n  String value = properties.getProperty(option);\n\n  if (opt.hasArg())\n  {\n  if (opt.getValues() == null || opt.getValues().length == 0)\n  {\n  try\n  {\n  opt.addValueForProcessing(value);\n  }\n  catch (RuntimeException exp)\n  {\n  \n  }\n  }\n  }\n  else if (!(\"yes\".equalsIgnoreCase(value)\n  || \"true\".equalsIgnoreCase(value)\n  || \"1\".equalsIgnoreCase(value)))\n  {\n  \n  \n  continue;\n  }\n\n  cmd.addOption(opt);\n  updateRequiredOptions(opt);\n  }\n  }\n  }",
          "fixed_method": "  protected void processProperties(Properties properties) throws ParseException {\n  if (properties == null)\n  {\n  return;\n  }\n\n  for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n  {\n  String option = e.nextElement().toString();\n  \n  Option opt = options.getOption(option);\n  if (opt == null)\n  {\n  throw new UnrecognizedOptionException(\"Default option wasn't defined\", option);\n  }\n  \n  \n  OptionGroup group = options.getOptionGroup(opt);\n  boolean selected = group != null && group.getSelected() != null;\n  \n  if (!cmd.hasOption(option) && !selected)\n  {\n  \n  String value = properties.getProperty(option);\n\n  if (opt.hasArg())\n  {\n  if (opt.getValues() == null || opt.getValues().length == 0)\n  {\n  try\n  {\n  opt.addValueForProcessing(value);\n  }\n  catch (RuntimeException exp)\n  {\n  \n  }\n  }\n  }\n  else if (!(\"yes\".equalsIgnoreCase(value)\n  || \"true\".equalsIgnoreCase(value)\n  || \"1\".equalsIgnoreCase(value)))\n  {\n  \n  \n  continue;\n  }\n\n  cmd.addOption(opt);\n  updateRequiredOptions(opt);\n  }\n  }\n  }",
          "diff": [
            "@@ -260,12 +260,18 @@",
            "         {\n",
            "             String option = e.nextElement().toString();\n",
            "             \n",
            "-            if (!cmd.hasOption(option))\n",
            "-            {\n",
            "-                Option opt = getOptions().getOption(option);\n",
            "+            Option opt = options.getOption(option);\n",
            "+            if (opt == null)\n",
            "+            {\n",
            "+                throw new UnrecognizedOptionException(\"Default option wasn't defined\", option);\n",
            "+            }\n",
            "             \n",
            "             // if the option is part of a group, check if another option of the group has been selected\n",
            "+            OptionGroup group = options.getOptionGroup(opt);\n",
            "+            boolean selected = group != null && group.getSelected() != null;\n",
            "             \n",
            "+            if (!cmd.hasOption(option) && !selected)\n",
            "+            {\n",
            "                 // get the value from the properties instance\n",
            "                 String value = properties.getProperty(option);\n",
            " \n"
          ],
          "changed_lines": 12
        }
      ]
    }
  ]
}
