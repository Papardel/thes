{
  "bug_id": "13",
  "failed_tests": {
    "org.apache.commons.jxpath.ri.model.ExternalXMLNamespaceTest": [
      {
        "methodName": "testCreateAndSetAttributeDOM",
        "error": "org.apache.commons.jxpath.JXPathException",
        "message": "Unknown namespace prefix: A",
        "fail_line": "        doTestCreateAndSetAttribute(DocumentContainer.MODEL_DOM);",
        "test_source": "  public void testCreateAndSetAttributeDOM() {\n  doTestCreateAndSetAttribute(DocumentContainer.MODEL_DOM);\n  }",
        "stack": [
          "JXPathContextReferenceImpl.createPathAndSetValue line 479, JXPathContextReferenceImpl.createPathAndSetValue line 467, JXPathTestCase.assertXPathCreatePathAndSetValue line 108, ExternalXMLNamespaceTest.doTestCreateAndSetAttribute line 70, ExternalXMLNamespaceTest.testCreateAndSetAttributeDOM line 83, DOMNodePointer.createAttribute line 417, NullPropertyPointer.createPath line 136, JXPathContextReferenceImpl.setValue line 510, JXPathContextReferenceImpl.createPathAndSetValue line 476"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/jxpath/ri/NamespaceResolver.java",
      "buggy_full_code": "\npackage org.apache.commons.jxpath.ri;\n\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\n\nimport org.apache.commons.jxpath.Pointer;\nimport org.apache.commons.jxpath.ri.model.NodeIterator;\nimport org.apache.commons.jxpath.ri.model.NodePointer;\n\n\npublic class NamespaceResolver implements Cloneable { final protected NamespaceResolver parent; protected HashMap namespaceMap = new HashMap(); protected HashMap reverseMap; protected NodePointer pointer; private boolean sealed; public NamespaceResolver() {\n        this(null);\n    }\n\n    \n    public NamespaceResolver(NamespaceResolver parent) {\n        this.parent = parent;\n    }\n\n    \n    public synchronized void registerNamespace(String prefix, String namespaceURI) {\n        if (isSealed()) {\n            throw new IllegalStateException(\n                    \"Cannot register namespaces on a sealed NamespaceResolver\");\n        }\n        namespaceMap.put(prefix, namespaceURI);\n        reverseMap = null;\n    }\n    \n    \n    public void setNamespaceContextPointer(NodePointer pointer) {\n        this.pointer = pointer;\n    }\n\n    \n    public Pointer getNamespaceContextPointer() {\n        if (pointer == null && parent != null) {\n            return parent.getNamespaceContextPointer();\n        }\n        return pointer;\n    }\n    \n    \n    public synchronized String getNamespaceURI(String prefix) {\n\n    \n        String uri = (String) namespaceMap.get(prefix);\n        if (uri == null && pointer != null) {\n            uri = pointer.getNamespaceURI(prefix);\n        }\n        if (uri == null && parent != null) {\n            return parent.getNamespaceURI(prefix);\n        }\n        return uri;\n    }\n\n    \n    public synchronized String getPrefix(String namespaceURI) {\n\n    \n        if (reverseMap == null) {\n            reverseMap = new HashMap();\n            NodeIterator ni = pointer.namespaceIterator();\n            if (ni != null) {\n                for (int position = 1; ni.setPosition(position); position++) {\n                    NodePointer nsPointer = ni.getNodePointer();\n                    String uri = nsPointer.getNamespaceURI();                    \n                    String prefix = nsPointer.getName().getName();\n                    if (!\"\".equals(prefix)) {\n                        reverseMap.put(uri, prefix);\n                    }\n                }\n            }\n            Iterator it = namespaceMap.entrySet().iterator();\n            while (it.hasNext()) {\n                Map.Entry entry = (Map.Entry) it.next();\n                reverseMap.put(entry.getValue(), entry.getKey());\n            }\n        }\n        String prefix = (String) reverseMap.get(namespaceURI);\n        if (prefix == null && parent != null) {\n            return parent.getPrefix(namespaceURI);\n        }\n        return prefix;\n    }\n\n    \n    public boolean isSealed() {\n        return sealed;\n    }\n\n    \n    public void seal() {\n        sealed = true;\n        if (parent != null) {\n            parent.seal();\n        }\n    }\n\n    \n    public Object clone() {\n        try {\n            NamespaceResolver result = (NamespaceResolver) super.clone();\n            result.sealed = false;\n            return result;\n        }\n        catch (CloneNotSupportedException e) {\n            \n            e.printStackTrace();\n            return null;\n        }\n    }\n\n}\n",
      "fixed_full_code": "\npackage org.apache.commons.jxpath.ri;\n\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\n\nimport org.apache.commons.jxpath.Pointer;\nimport org.apache.commons.jxpath.ri.model.NodeIterator;\nimport org.apache.commons.jxpath.ri.model.NodePointer;\n\n\npublic class NamespaceResolver implements Cloneable { final protected NamespaceResolver parent; protected HashMap namespaceMap = new HashMap(); protected HashMap reverseMap; protected NodePointer pointer; private boolean sealed; protected static String getPrefix(NodePointer pointer, String namespaceURI) {\n        NodePointer currentPointer = pointer;\n        while (currentPointer != null) {\n            NodeIterator ni = currentPointer.namespaceIterator();\n            for (int position = 1; ni != null && ni.setPosition(position); position++) {\n                NodePointer nsPointer = ni.getNodePointer();\n                String uri = nsPointer.getNamespaceURI();\n                if (uri.equals(namespaceURI)) {\n                    String prefix = nsPointer.getName().getName();\n                    if (!\"\".equals(prefix)) {\n                        return prefix;\n                    }\n                }\n            }\n            currentPointer = pointer.getParent();\n        }\n        return null;\n    }\n\n    \n    public NamespaceResolver() {\n        this(null);\n    }\n\n    \n    public NamespaceResolver(NamespaceResolver parent) {\n        this.parent = parent;\n    }\n\n    \n    public synchronized void registerNamespace(String prefix, String namespaceURI) {\n        if (isSealed()) {\n            throw new IllegalStateException(\n                    \"Cannot register namespaces on a sealed NamespaceResolver\");\n        }\n        namespaceMap.put(prefix, namespaceURI);\n        reverseMap = null;\n    }\n    \n    \n    public void setNamespaceContextPointer(NodePointer pointer) {\n        this.pointer = pointer;\n    }\n\n    \n    public Pointer getNamespaceContextPointer() {\n        if (pointer == null && parent != null) {\n            return parent.getNamespaceContextPointer();\n        }\n        return pointer;\n    }\n    \n    \n    public synchronized String getNamespaceURI(String prefix) {\n        String uri = getExternallyRegisteredNamespaceURI(prefix);\n        return uri == null && pointer != null ? pointer.getNamespaceURI(prefix)\n                : uri;\n    }\n\n    \n     protected synchronized String getExternallyRegisteredNamespaceURI( String prefix) {\n        String uri = (String) namespaceMap.get(prefix);\n        return uri == null && parent != null ? parent\n                .getExternallyRegisteredNamespaceURI(prefix) : uri;\n    }\n\n    \n    public synchronized String getPrefix(String namespaceURI) {\n        String prefix = getExternallyRegisteredPrefix(namespaceURI);\n        return prefix == null && pointer != null ? getPrefix(pointer,\n                namespaceURI) : prefix;\n    }\n\n    \n    protected synchronized String getExternallyRegisteredPrefix(String namespaceURI) {\n        if (reverseMap == null) {\n            reverseMap = new HashMap();\n            Iterator it = namespaceMap.entrySet().iterator();\n            while (it.hasNext()) {\n                Map.Entry entry = (Map.Entry) it.next();\n                reverseMap.put(entry.getValue(), entry.getKey());\n            }\n        }\n        String prefix = (String) reverseMap.get(namespaceURI);\n        return prefix == null && parent != null ? parent\n                .getExternallyRegisteredPrefix(namespaceURI) : prefix;\n    }\n\n    \n    public boolean isSealed() {\n        return sealed;\n    }\n\n    \n    public void seal() {\n        sealed = true;\n        if (parent != null) {\n            parent.seal();\n        }\n    }\n\n    \n    public Object clone() {\n        try {\n            NamespaceResolver result = (NamespaceResolver) super.clone();\n            result.sealed = false;\n            return result;\n        }\n        catch (CloneNotSupportedException e) {\n            \n            e.printStackTrace();\n            return null;\n        }\n    }\n\n}",
      "buggy_signatures": [
        "public NamespaceResolver(NamespaceResolver parent)",
        "public synchronized void registerNamespace(String prefix, String namespaceURI)",
        "public void setNamespaceContextPointer(NodePointer pointer)",
        "public Pointer getNamespaceContextPointer()",
        "public synchronized String getNamespaceURI(String prefix)",
        "public synchronized String getPrefix(String namespaceURI)",
        "public boolean isSealed()",
        "public void seal()",
        "public Object clone()"
      ],
      "fixed_signatures": [
        "public NamespaceResolver()",
        "public NamespaceResolver(NamespaceResolver parent)",
        "public synchronized void registerNamespace(String prefix, String namespaceURI)",
        "public void setNamespaceContextPointer(NodePointer pointer)",
        "public Pointer getNamespaceContextPointer()",
        "public synchronized String getNamespaceURI(String prefix)",
        "protected synchronized String getExternallyRegisteredNamespaceURI( String prefix)",
        "public synchronized String getPrefix(String namespaceURI)",
        "protected synchronized String getExternallyRegisteredPrefix(String namespaceURI)",
        "public boolean isSealed()",
        "public void seal()",
        "public Object clone()"
      ],
      "methods": [
        {
          "buggy_method": "  protected HashMap namespaceMap = new HashMap(); protected HashMap reverseMap; protected NodePointer pointer; private boolean sealed; public NamespaceResolver() {\n  this(null);\n  }",
          "fixed_method": "  protected static String getPrefix(NodePointer pointer, String namespaceURI) {\n  NodePointer currentPointer = pointer;\n  while (currentPointer != null) {\n  NodeIterator ni = currentPointer.namespaceIterator();\n  for (int position = 1; ni != null && ni.setPosition(position); position++) {\n  NodePointer nsPointer = ni.getNodePointer();\n  String uri = nsPointer.getNamespaceURI();\n  if (uri.equals(namespaceURI)) {\n  String prefix = nsPointer.getName().getName();\n  if (!\"\".equals(prefix)) {\n  return prefix;\n  }\n  }\n  }\n  currentPointer = pointer.getParent();\n  }\n  return null;\n  }",
          "diff": [
            "@@ -44,6 +44,24 @@",
            "      * @return prefix if found\n",
            "      * @since JXPath 1.3\n",
            "      */\n",
            "+    protected static String getPrefix(NodePointer pointer, String namespaceURI) {\n",
            "+        NodePointer currentPointer = pointer;\n",
            "+        while (currentPointer != null) {\n",
            "+            NodeIterator ni = currentPointer.namespaceIterator();\n",
            "+            for (int position = 1; ni != null && ni.setPosition(position); position++) {\n",
            "+                NodePointer nsPointer = ni.getNodePointer();\n",
            "+                String uri = nsPointer.getNamespaceURI();\n",
            "+                if (uri.equals(namespaceURI)) {\n",
            "+                    String prefix = nsPointer.getName().getName();\n",
            "+                    if (!\"\".equals(prefix)) {\n",
            "+                        return prefix;\n",
            "+                    }\n",
            "+                }\n",
            "+            }\n",
            "+            currentPointer = pointer.getParent();\n",
            "+        }\n",
            "+        return null;\n",
            "+    }\n",
            " \n",
            "     /**\n",
            "      * Create a new NamespaceResolver.\n"
          ],
          "changed_lines": 18
        },
        {
          "buggy_method": "  public synchronized String getNamespaceURI(String prefix) {\n\n  \n  String uri = (String) namespaceMap.get(prefix);\n  if (uri == null && pointer != null) {\n  uri = pointer.getNamespaceURI(prefix);\n  }\n  if (uri == null && parent != null) {\n  return parent.getNamespaceURI(prefix);\n  }\n  return uri;\n  }",
          "fixed_method": "  public synchronized String getNamespaceURI(String prefix) {\n  String uri = getExternallyRegisteredNamespaceURI(prefix);\n  return uri == null && pointer != null ? pointer.getNamespaceURI(prefix)\n  : uri;\n  }",
          "diff": [
            "@@ -105,6 +123,10 @@",
            "      * @return namespace URI or null if the prefix is undefined.\n",
            "      */\n",
            "     public synchronized String getNamespaceURI(String prefix) {\n",
            "+        String uri = getExternallyRegisteredNamespaceURI(prefix);\n",
            "+        return uri == null && pointer != null ? pointer.getNamespaceURI(prefix)\n",
            "+                : uri;\n",
            "+    }\n",
            " \n",
            "     /**\n",
            "      * Given a prefix, returns an externally registered namespace URI.\n",
            "@@ -113,14 +135,11 @@",
            "      * @return namespace URI or null if the prefix is undefined.\n",
            "      * @since JXPath 1.3\n",
            "      */\n",
            "+     protected synchronized String getExternallyRegisteredNamespaceURI(\n",
            "+            String prefix) {\n",
            "         String uri = (String) namespaceMap.get(prefix);\n",
            "-        if (uri == null && pointer != null) {\n",
            "-            uri = pointer.getNamespaceURI(prefix);\n",
            "-        }\n",
            "-        if (uri == null && parent != null) {\n",
            "-            return parent.getNamespaceURI(prefix);\n",
            "-        }\n",
            "-        return uri;\n",
            "+        return uri == null && parent != null ? parent\n",
            "+                .getExternallyRegisteredNamespaceURI(prefix) : uri;\n",
            "     }\n",
            " \n",
            "     /**\n"
          ],
          "changed_lines": 15
        },
        {
          "buggy_method": "  public synchronized String getPrefix(String namespaceURI) {\n\n  \n  if (reverseMap == null) {\n  reverseMap = new HashMap();\n  NodeIterator ni = pointer.namespaceIterator();\n  if (ni != null) {\n  for (int position = 1; ni.setPosition(position); position++) {\n  NodePointer nsPointer = ni.getNodePointer();\n  String uri = nsPointer.getNamespaceURI();  \n  String prefix = nsPointer.getName().getName();\n  if (!\"\".equals(prefix)) {\n  reverseMap.put(uri, prefix);\n  }\n  }\n  }\n  Iterator it = namespaceMap.entrySet().iterator();\n  while (it.hasNext()) {\n  Map.Entry entry = (Map.Entry) it.next();\n  reverseMap.put(entry.getValue(), entry.getKey());\n  }\n  }\n  String prefix = (String) reverseMap.get(namespaceURI);\n  if (prefix == null && parent != null) {\n  return parent.getPrefix(namespaceURI);\n  }\n  return prefix;\n  }",
          "fixed_method": "  public synchronized String getPrefix(String namespaceURI) {\n  String prefix = getExternallyRegisteredPrefix(namespaceURI);\n  return prefix == null && pointer != null ? getPrefix(pointer,\n  namespaceURI) : prefix;\n  }",
          "diff": [
            "@@ -129,6 +148,10 @@",
            "      * @return String prefix\n",
            "      */\n",
            "     public synchronized String getPrefix(String namespaceURI) {\n",
            "+        String prefix = getExternallyRegisteredPrefix(namespaceURI);\n",
            "+        return prefix == null && pointer != null ? getPrefix(pointer,\n",
            "+                namespaceURI) : prefix;\n",
            "+    }\n",
            " \n",
            "     /**\n",
            "      * Get the nearest prefix found that matches an externally-registered namespace. \n",
            "@@ -136,19 +159,9 @@",
            "      * @return String prefix if found.\n",
            "      * @since JXPath 1.3\n",
            "      */\n",
            "+    protected synchronized String getExternallyRegisteredPrefix(String namespaceURI) {\n",
            "         if (reverseMap == null) {\n",
            "             reverseMap = new HashMap();\n",
            "-            NodeIterator ni = pointer.namespaceIterator();\n",
            "-            if (ni != null) {\n",
            "-                for (int position = 1; ni.setPosition(position); position++) {\n",
            "-                    NodePointer nsPointer = ni.getNodePointer();\n",
            "-                    String uri = nsPointer.getNamespaceURI();                    \n",
            "-                    String prefix = nsPointer.getName().getName();\n",
            "-                    if (!\"\".equals(prefix)) {\n",
            "-                        reverseMap.put(uri, prefix);\n",
            "-                    }\n",
            "-                }\n",
            "-            }\n",
            "             Iterator it = namespaceMap.entrySet().iterator();\n",
            "             while (it.hasNext()) {\n",
            "                 Map.Entry entry = (Map.Entry) it.next();\n",
            "@@ -156,10 +169,8 @@",
            "             }\n",
            "         }\n",
            "         String prefix = (String) reverseMap.get(namespaceURI);\n",
            "-        if (prefix == null && parent != null) {\n",
            "-            return parent.getPrefix(namespaceURI);\n",
            "-        }\n",
            "-        return prefix;\n",
            "+        return prefix == null && parent != null ? parent\n",
            "+                .getExternallyRegisteredPrefix(namespaceURI) : prefix;\n",
            "     }\n",
            " \n",
            "     /**\n"
          ],
          "changed_lines": 22
        },
        {
          "buggy_method": "  public Object clone() {\n  try {\n  NamespaceResolver result = (NamespaceResolver) super.clone();\n  result.sealed = false;\n  return result;\n  }\n  catch (CloneNotSupportedException e) {\n  \n  e.printStackTrace();\n  return null;\n  }\n  }",
          "fixed_method": "  public Object clone() {\n  try {\n  NamespaceResolver result = (NamespaceResolver) super.clone();\n  result.sealed = false;\n  return result;\n  }\n  catch (CloneNotSupportedException e) {\n  \n  e.printStackTrace();\n  return null;\n  }\n  }",
          "diff": [
            "@@ -197,4 +208,4 @@",
            "         }\n",
            "     }\n",
            " \n",
            "-}\n",
            "+}"
          ],
          "changed_lines": 2
        }
      ]
    },
    {
      "name": "org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java",
      "buggy_full_code": "\npackage org.apache.commons.jxpath.ri.model.dom;\n\nimport java.util.HashMap;\nimport java.util.Locale;\nimport java.util.Map;\n\nimport org.apache.commons.jxpath.AbstractFactory;\nimport org.apache.commons.jxpath.JXPathAbstractFactoryException;\nimport org.apache.commons.jxpath.JXPathContext;\nimport org.apache.commons.jxpath.JXPathException;\nimport org.apache.commons.jxpath.Pointer;\nimport org.apache.commons.jxpath.ri.Compiler;\nimport org.apache.commons.jxpath.ri.QName;\nimport org.apache.commons.jxpath.ri.compiler.NodeNameTest;\nimport org.apache.commons.jxpath.ri.compiler.NodeTest;\nimport org.apache.commons.jxpath.ri.compiler.NodeTypeTest;\nimport org.apache.commons.jxpath.ri.compiler.ProcessingInstructionTest;\nimport org.apache.commons.jxpath.ri.model.NodeIterator;\nimport org.apache.commons.jxpath.ri.model.NodePointer;\nimport org.apache.commons.jxpath.ri.model.beans.NullPointer;\nimport org.apache.commons.jxpath.util.TypeUtils;\nimport org.w3c.dom.Attr;\nimport org.w3c.dom.Comment;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.w3c.dom.ProcessingInstruction;\n\n\npublic class DOMNodePointer extends NodePointer { private static final long serialVersionUID = -8751046933894857319L; private Node node; private Map namespaces; private String defaultNamespace; private String id; public static final String XML_NAMESPACE_URI = \"http: public static final String XMLNS_NAMESPACE_URI = \"http: public DOMNodePointer(Node node, Locale locale) {\n        super(null, locale);\n        this.node = node;\n    }\n\n    public DOMNodePointer(Node node, Locale locale, String id) {\n        super(null, locale);\n        this.node = node;\n        this.id = id;\n    }\n\n    public DOMNodePointer(NodePointer parent, Node node) {\n        super(parent);\n        this.node = node;\n    }\n    \n    public boolean testNode(NodeTest test) {\n        return testNode(node, test);\n    }\n\n    public static boolean testNode(Node node, NodeTest test) {\n        if (test == null) {\n            return true;\n        }\n        if (test instanceof NodeNameTest) {\n            if (node.getNodeType() != Node.ELEMENT_NODE) {\n                return false;\n            }\n\n            NodeNameTest nodeNameTest = (NodeNameTest) test;\n            QName testName = nodeNameTest.getNodeName();\n            String namespaceURI = nodeNameTest.getNamespaceURI();\n            boolean wildcard = nodeNameTest.isWildcard();\n            String testPrefix = testName.getPrefix();\n            if (wildcard && testPrefix == null) {\n                return true;\n            }\n            if (wildcard\n                || testName.getName()\n                        .equals(DOMNodePointer.getLocalName(node))) {\n                String nodeNS = DOMNodePointer.getNamespaceURI(node);\n                return equalStrings(namespaceURI, nodeNS) || nodeNS == null\n                        && equalStrings(testPrefix, getPrefix(node));\n            }\n            return false;\n        }\n        if (test instanceof NodeTypeTest) {\n            int nodeType = node.getNodeType();\n            switch (((NodeTypeTest) test).getNodeType()) {\n                case Compiler.NODE_TYPE_NODE :\n                    return nodeType == Node.ELEMENT_NODE\n                            || nodeType == Node.DOCUMENT_NODE;\n                case Compiler.NODE_TYPE_TEXT :\n                    return nodeType == Node.CDATA_SECTION_NODE\n                        || nodeType == Node.TEXT_NODE;\n                case Compiler.NODE_TYPE_COMMENT :\n                    return nodeType == Node.COMMENT_NODE;\n                case Compiler.NODE_TYPE_PI :\n                    return nodeType == Node.PROCESSING_INSTRUCTION_NODE;\n            }\n            return false;\n        }\n        if (test instanceof ProcessingInstructionTest) {\n            if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {\n                String testPI = ((ProcessingInstructionTest) test).getTarget();\n                String nodePI = ((ProcessingInstruction) node).getTarget();\n                return testPI.equals(nodePI);\n            }\n        }\n        return false;\n    }\n\n    private static boolean equalStrings(String s1, String s2) {\n        if (s1 == s2) {\n            return true;\n        }\n        s1 = s1 == null ? \"\" : s1.trim();\n        s2 = s2 == null ? \"\" : s2.trim();\n        return s1.equals(s2);\n    }\n\n    public QName getName() {\n        String ln = null;\n        String ns = null;\n        int type = node.getNodeType();\n        if (type == Node.ELEMENT_NODE) {\n            ns = DOMNodePointer.getPrefix(node);\n            ln = DOMNodePointer.getLocalName(node);\n        }\n        else if (type == Node.PROCESSING_INSTRUCTION_NODE) {\n            ln = ((ProcessingInstruction) node).getTarget();\n        }\n        return new QName(ns, ln);\n    }\n\n    public String getNamespaceURI() {\n        return getNamespaceURI(node);\n    }\n\n    public NodeIterator childIterator( NodeTest test, boolean reverse, NodePointer startWith) {\n        return new DOMNodeIterator(this, test, reverse, startWith);\n    }\n\n    public NodeIterator attributeIterator(QName name) {\n        return new DOMAttributeIterator(this, name);\n    }\n\n    public NodePointer namespacePointer(String prefix) {\n        return new NamespacePointer(this, prefix);\n    }\n\n    public NodeIterator namespaceIterator() {\n        return new DOMNamespaceIterator(this);\n    }\n\n    \n\n    public String getNamespaceURI(String prefix) {\n        if (prefix == null || prefix.equals(\"\")) {\n            return getDefaultNamespaceURI();\n        }\n\n        if (prefix.equals(\"xml\")) {\n            return XML_NAMESPACE_URI;\n        }\n\n        if (prefix.equals(\"xmlns\")) {\n            return XMLNS_NAMESPACE_URI;\n        }\n\n        String namespace = null;\n        if (namespaces == null) {\n            namespaces = new HashMap();\n        }\n        else {\n            namespace = (String) namespaces.get(prefix);\n        }\n\n        if (namespace == null) {\n            String qname = \"xmlns:\" + prefix;\n            Node aNode = node;\n            if (aNode instanceof Document) {\n                aNode = ((Document)aNode).getDocumentElement();\n            }\n            while (aNode != null) {\n                if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n                    Attr attr = ((Element) aNode).getAttributeNode(qname);\n                    if (attr != null) {\n                        namespace = attr.getValue();\n                        break;\n                    }\n                }\n                aNode = aNode.getParentNode();\n            }\n            if (namespace == null || namespace.equals(\"\")) {\n                namespace = NodePointer.UNKNOWN_NAMESPACE;\n            }\n        }\n\n        namespaces.put(prefix, namespace);\n        if (namespace == UNKNOWN_NAMESPACE) {\n            return null;\n        }\n        \n        \n        return namespace;\n    }\n\n    public String getDefaultNamespaceURI() {\n        if (defaultNamespace == null) {\n            Node aNode = node;\n            if (aNode instanceof Document) {\n                aNode = ((Document) aNode).getDocumentElement();\n            }\n            while (aNode != null) {\n                if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n                    Attr attr = ((Element) aNode).getAttributeNode(\"xmlns\");\n                    if (attr != null) {\n                        defaultNamespace = attr.getValue();\n                        break;\n                    }\n                }\n                aNode = aNode.getParentNode();\n            }\n        }\n        if (defaultNamespace == null) {\n            defaultNamespace = \"\";\n        }\n        \n        return defaultNamespace.equals(\"\") ? null : defaultNamespace;\n    }\n\n    public Object getBaseValue() {\n        return node;\n    }\n\n    public Object getImmediateNode() {\n        return node;\n    }\n\n    public boolean isActual() {\n        return true;\n    }\n\n    public boolean isCollection() {\n        return false;\n    }\n\n    public int getLength() {\n        return 1;\n    }\n\n    public boolean isLeaf() {\n        return !node.hasChildNodes();\n    }\n\n    \n    public boolean isLanguage(String lang) {\n        String current = getLanguage();\n        return current == null ? super.isLanguage(lang)\n                : current.toUpperCase().startsWith(lang.toUpperCase());\n    }\n\n    protected static String findEnclosingAttribute(Node n, String attrName) {\n        while (n != null) {\n            if (n.getNodeType() == Node.ELEMENT_NODE) {\n                Element e = (Element) n;\n                String attr = e.getAttribute(attrName);\n                if (attr != null && !attr.equals(\"\")) {\n                    return attr;\n                }\n            }\n            n = n.getParentNode();\n        }\n        return null;\n    }\n\n    protected String getLanguage() {\n        return findEnclosingAttribute(node, \"xml:lang\");\n    }\n\n    \n    public void setValue(Object value) {\n        if (node.getNodeType() == Node.TEXT_NODE\n            || node.getNodeType() == Node.CDATA_SECTION_NODE) {\n            String string = (String) TypeUtils.convert(value, String.class);\n            if (string != null && !string.equals(\"\")) {\n                node.setNodeValue(string);\n            }\n            else {\n                node.getParentNode().removeChild(node);\n            }\n        }\n        else {\n            NodeList children = node.getChildNodes();\n            int count = children.getLength();\n            for (int i = count; --i >= 0;) {\n                Node child = children.item(i);\n                node.removeChild(child);\n            }\n\n            if (value instanceof Node) {\n                Node valueNode = (Node) value;\n                if (valueNode instanceof Element\n                    || valueNode instanceof Document) {\n                    children = valueNode.getChildNodes();\n                    for (int i = 0; i < children.getLength(); i++) {\n                        Node child = children.item(i);\n                        node.appendChild(child.cloneNode(true));\n                    }\n                }\n                else {\n                    node.appendChild(valueNode.cloneNode(true));\n                }\n            }\n            else {\n                String string = (String) TypeUtils.convert(value, String.class);\n                if (string != null && !string.equals(\"\")) {\n                    Node textNode =\n                        node.getOwnerDocument().createTextNode(string);\n                    node.appendChild(textNode);\n                }\n            }\n        }\n    }\n    \n    public NodePointer createChild( JXPathContext context, QName name, int index) {\n        if (index == WHOLE_COLLECTION) {\n            index = 0;\n        }\n        boolean success =\n            getAbstractFactory(context).createObject(\n                context,\n                this,\n                node,\n                name.toString(),\n                index);\n        if (success) {\n            NodeTest nodeTest;\n            String prefix = name.getPrefix();\n            String namespaceURI = prefix == null ? null : \n                context.getNamespaceURI(prefix);\n            nodeTest = new NodeNameTest(name, namespaceURI);\n\n            NodeIterator it = childIterator(nodeTest, false, null);\n            if (it != null && it.setPosition(index + 1)) {\n                return it.getNodePointer();\n            }\n        }\n        throw new JXPathAbstractFactoryException(\n                \"Factory could not create a child node for path: \" + asPath()\n                        + \"/\" + name + \"[\" + (index + 1) + \"]\");\n    }\n\n    public NodePointer createChild(JXPathContext context, QName name, int index, Object value) {\n        NodePointer ptr = createChild(context, name, index);\n        ptr.setValue(value);\n        return ptr;\n    }\n\n    public NodePointer createAttribute(JXPathContext context, QName name) {\n        if (!(node instanceof Element)) {\n            return super.createAttribute(context, name);\n        }\n        Element element = (Element) node;\n        String prefix = name.getPrefix();\n        if (prefix != null) {\n            String ns = getNamespaceURI(prefix);\n            if (ns == null) {\n                throw new JXPathException(\n                    \"Unknown namespace prefix: \" + prefix);\n            }\n            element.setAttributeNS(ns, name.toString(), \"\");\n        }\n        else {\n            if (!element.hasAttribute(name.getName())) {\n                element.setAttribute(name.getName(), \"\");\n            }\n        }\n        NodeIterator it = attributeIterator(name);\n        it.setPosition(1);\n        return it.getNodePointer();\n    }\n\n    public void remove() {\n        Node parent = node.getParentNode();\n        if (parent == null) {\n            throw new JXPathException(\"Cannot remove root DOM node\");\n        }\n        parent.removeChild(node);\n    }\n\n    public String asPath() {\n        if (id != null) {\n            return \"id('\" + escape(id) + \"')\";\n        }\n\n        StringBuffer buffer = new StringBuffer();\n        if (parent != null) {\n            buffer.append(parent.asPath());\n        }\n        switch (node.getNodeType()) {\n            case Node.ELEMENT_NODE :\n                \n                \n                \n                if (parent instanceof DOMNodePointer) {\n                    if (buffer.length() == 0\n                            || buffer.charAt(buffer.length() - 1) != '/') {\n                        buffer.append('/');\n                    }\n                    String ln = DOMNodePointer.getLocalName(node);\n                    String nsURI = getNamespaceURI();\n                    if (nsURI == null) {\n                        buffer.append(ln);\n                        buffer.append('[');\n                        buffer.append(getRelativePositionByName()).append(']');\n                    }\n                    else {\n                        String prefix = getNamespaceResolver().getPrefix(nsURI);\n                        if (prefix != null) {\n                            buffer.append(prefix);\n                            buffer.append(':');\n                            buffer.append(ln);\n                            buffer.append('[');\n                            buffer.append(getRelativePositionByName());\n                            buffer.append(']');\n                        }\n                        else {\n                            buffer.append(\"node()\");\n                            buffer.append('[');\n                            buffer.append(getRelativePositionOfElement());\n                            buffer.append(']');\n                        }\n                    }\n                }\n            break;\n            case Node.TEXT_NODE :\n            case Node.CDATA_SECTION_NODE :\n                buffer.append(\"/text()\");\n                buffer.append('[');\n                buffer.append(getRelativePositionOfTextNode()).append(']');\n                break;\n            case Node.PROCESSING_INSTRUCTION_NODE :\n                String target = ((ProcessingInstruction) node).getTarget();\n                buffer.append(\"/processing-instruction(\\'\");\n                buffer.append(target).append(\"')\");\n                buffer.append('[');\n                buffer.append(getRelativePositionOfPI(target)).append(']');\n                break;\n            case Node.DOCUMENT_NODE :\n                \n        }\n        return buffer.toString();\n    }\n\n    private String escape(String string) {\n        int index = string.indexOf('\\'');\n        while (index != -1) {\n            string =\n                string.substring(0, index)\n                    + \"&apos;\"\n                    + string.substring(index + 1);\n            index = string.indexOf('\\'');\n        }\n        index = string.indexOf('\\\"');\n        while (index != -1) {\n            string =\n                string.substring(0, index)\n                    + \"&quot;\"\n                    + string.substring(index + 1);\n            index = string.indexOf('\\\"');\n        }\n        return string;\n    }\n\n    private int getRelativePositionByName() {\n        int count = 1;\n        Node n = node.getPreviousSibling();\n        while (n != null) {\n            if (n.getNodeType() == Node.ELEMENT_NODE) {\n                String nm = n.getNodeName();\n                if (nm.equals(node.getNodeName())) {\n                    count++;\n                }\n            }\n            n = n.getPreviousSibling();\n        }\n        return count;\n    }\n    \n    private int getRelativePositionOfElement() {\n        int count = 1;\n        Node n = node.getPreviousSibling();\n        while (n != null) {\n            if (n.getNodeType() == Node.ELEMENT_NODE) {\n                count++;\n            }\n            n = n.getPreviousSibling();\n        }\n        return count;\n    }\n\n    private int getRelativePositionOfTextNode() {\n        int count = 1;\n        Node n = node.getPreviousSibling();\n        while (n != null) {\n            if (n.getNodeType() == Node.TEXT_NODE\n                || n.getNodeType() == Node.CDATA_SECTION_NODE) {\n                count++;\n            }\n            n = n.getPreviousSibling();\n        }\n        return count;\n    }\n\n    private int getRelativePositionOfPI(String target) {\n        int count = 1;\n        Node n = node.getPreviousSibling();\n        while (n != null) {\n            if (n.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE\n                && ((ProcessingInstruction) n).getTarget().equals(target)) {\n                count++;\n            }\n            n = n.getPreviousSibling();\n        }\n        return count;\n    }\n\n    public int hashCode() {\n        return System.identityHashCode(node);\n    }\n\n    public boolean equals(Object object) {\n        return object == this || object instanceof DOMNodePointer && node == ((DOMNodePointer) object).node;\n    }\n\n    public static String getPrefix(Node node) {\n        String prefix = node.getPrefix();\n        if (prefix != null) {\n            return prefix;\n        }\n\n        String name = node.getNodeName();\n        int index = name.lastIndexOf(':');\n        return index < 0 ? null : name.substring(0, index);\n    }\n\n    public static String getLocalName(Node node) {\n        String localName = node.getLocalName();\n        if (localName != null) {\n            return localName;\n        }\n\n        String name = node.getNodeName();\n        int index = name.lastIndexOf(':');\n        return index < 0 ? name : name.substring(index + 1);\n    }\n    \n    public static String getNamespaceURI(Node node) {\n        if (node instanceof Document) {\n            node = ((Document) node).getDocumentElement();\n        }\n\n        Element element = (Element) node;\n\n        String uri = element.getNamespaceURI();\n        if (uri != null) {\n            return uri;\n        }\n\n        String prefix = getPrefix(node);\n        String qname = prefix == null ? \"xmlns\" : \"xmlns:\" + prefix;\n\n        Node aNode = node;\n        while (aNode != null) {\n            if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n                Attr attr = ((Element) aNode).getAttributeNode(qname);\n                if (attr != null) {\n                    return attr.getValue();\n                }\n            }\n            aNode = aNode.getParentNode();\n        }\n        return null;\n    }\n\n    public Object getValue() {\n        if (node.getNodeType() == Node.COMMENT_NODE) {\n            String text = ((Comment) node).getData();\n            return text == null ? \"\" : text.trim();\n        }\n        return stringValue(node);\n    }\n\n    private String stringValue(Node node) {\n        int nodeType = node.getNodeType();\n        if (nodeType == Node.COMMENT_NODE) {\n            return \"\";\n        }\n        boolean trim = !\"preserve\".equals(findEnclosingAttribute(node, \"xml:space\"));\n        if (nodeType == Node.TEXT_NODE || nodeType == Node.CDATA_SECTION_NODE) {\n            String text = node.getNodeValue();\n            return text == null ? \"\" : trim ? text.trim() : text;\n        }\n        if (nodeType == Node.PROCESSING_INSTRUCTION_NODE) {\n            String text = ((ProcessingInstruction) node).getData();\n            return text == null ? \"\" : trim ? text.trim() : text;\n        }\n        NodeList list = node.getChildNodes();\n        StringBuffer buf = new StringBuffer(16);\n        for (int i = 0; i < list.getLength(); i++) {\n            Node child = list.item(i);\n            buf.append(stringValue(child));\n        }\n        return buf.toString();\n    }\n\n    \n    public Pointer getPointerByID(JXPathContext context, String id) {\n        Document document = node.getNodeType() == Node.DOCUMENT_NODE ? (Document) node\n                : node.getOwnerDocument();\n        Element element = document.getElementById(id);\n        return element == null ? (Pointer) new NullPointer(getLocale(), id)\n                : new DOMNodePointer(element, getLocale(), id);\n    }\n\n    private AbstractFactory getAbstractFactory(JXPathContext context) {\n        AbstractFactory factory = context.getFactory();\n        if (factory == null) {\n            throw new JXPathException(\n                \"Factory is not set on the JXPathContext - \"\n                    + \"cannot create path: \"\n                    + asPath());\n        }\n        return factory;\n    }\n\n    public int compareChildNodePointers( NodePointer pointer1, NodePointer pointer2) {\n        Node node1 = (Node) pointer1.getBaseValue();\n        Node node2 = (Node) pointer2.getBaseValue();\n        if (node1 == node2) {\n            return 0;\n        }\n\n        int t1 = node1.getNodeType();\n        int t2 = node2.getNodeType();\n        if (t1 == Node.ATTRIBUTE_NODE && t2 != Node.ATTRIBUTE_NODE) {\n            return -1;\n        }\n        if (t1 != Node.ATTRIBUTE_NODE && t2 == Node.ATTRIBUTE_NODE) {\n            return 1;\n        }\n        if (t1 == Node.ATTRIBUTE_NODE && t2 == Node.ATTRIBUTE_NODE) {\n            NamedNodeMap map = ((Node) getNode()).getAttributes();\n            int length = map.getLength();\n            for (int i = 0; i < length; i++) {\n                Node n = map.item(i);\n                if (n == node1) {\n                    return -1;\n                }\n                if (n == node2) {\n                    return 1;\n                }\n            }\n            return 0; \n        }\n\n        Node current = node.getFirstChild();\n        while (current != null) {\n            if (current == node1) {\n                return -1;\n            }\n            if (current == node2) {\n                return 1;\n            }\n            current = current.getNextSibling();\n        }\n        return 0;\n    }\n}\n",
      "fixed_full_code": "\npackage org.apache.commons.jxpath.ri.model.dom;\n\nimport java.util.HashMap;\nimport java.util.Locale;\nimport java.util.Map;\n\nimport org.apache.commons.jxpath.AbstractFactory;\nimport org.apache.commons.jxpath.JXPathAbstractFactoryException;\nimport org.apache.commons.jxpath.JXPathContext;\nimport org.apache.commons.jxpath.JXPathException;\nimport org.apache.commons.jxpath.Pointer;\nimport org.apache.commons.jxpath.ri.Compiler;\nimport org.apache.commons.jxpath.ri.NamespaceResolver;\nimport org.apache.commons.jxpath.ri.QName;\nimport org.apache.commons.jxpath.ri.compiler.NodeNameTest;\nimport org.apache.commons.jxpath.ri.compiler.NodeTest;\nimport org.apache.commons.jxpath.ri.compiler.NodeTypeTest;\nimport org.apache.commons.jxpath.ri.compiler.ProcessingInstructionTest;\nimport org.apache.commons.jxpath.ri.model.NodeIterator;\nimport org.apache.commons.jxpath.ri.model.NodePointer;\nimport org.apache.commons.jxpath.ri.model.beans.NullPointer;\nimport org.apache.commons.jxpath.util.TypeUtils;\nimport org.w3c.dom.Attr;\nimport org.w3c.dom.Comment;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.w3c.dom.ProcessingInstruction;\n\n\npublic class DOMNodePointer extends NodePointer { private static final long serialVersionUID = -8751046933894857319L; private Node node; private Map namespaces; private String defaultNamespace; private String id; private NamespaceResolver localNamespaceResolver; public static final String XML_NAMESPACE_URI = \"http: public static final String XMLNS_NAMESPACE_URI = \"http: public DOMNodePointer(Node node, Locale locale) {\n        super(null, locale);\n        this.node = node;\n    }\n\n    public DOMNodePointer(Node node, Locale locale, String id) {\n        super(null, locale);\n        this.node = node;\n        this.id = id;\n    }\n\n    public DOMNodePointer(NodePointer parent, Node node) {\n        super(parent);\n        this.node = node;\n    }\n    \n    public boolean testNode(NodeTest test) {\n        return testNode(node, test);\n    }\n\n    public static boolean testNode(Node node, NodeTest test) {\n        if (test == null) {\n            return true;\n        }\n        if (test instanceof NodeNameTest) {\n            if (node.getNodeType() != Node.ELEMENT_NODE) {\n                return false;\n            }\n\n            NodeNameTest nodeNameTest = (NodeNameTest) test;\n            QName testName = nodeNameTest.getNodeName();\n            String namespaceURI = nodeNameTest.getNamespaceURI();\n            boolean wildcard = nodeNameTest.isWildcard();\n            String testPrefix = testName.getPrefix();\n            if (wildcard && testPrefix == null) {\n                return true;\n            }\n            if (wildcard\n                || testName.getName()\n                        .equals(DOMNodePointer.getLocalName(node))) {\n                String nodeNS = DOMNodePointer.getNamespaceURI(node);\n                return equalStrings(namespaceURI, nodeNS) || nodeNS == null\n                        && equalStrings(testPrefix, getPrefix(node));\n            }\n            return false;\n        }\n        if (test instanceof NodeTypeTest) {\n            int nodeType = node.getNodeType();\n            switch (((NodeTypeTest) test).getNodeType()) {\n                case Compiler.NODE_TYPE_NODE :\n                    return nodeType == Node.ELEMENT_NODE\n                            || nodeType == Node.DOCUMENT_NODE;\n                case Compiler.NODE_TYPE_TEXT :\n                    return nodeType == Node.CDATA_SECTION_NODE\n                        || nodeType == Node.TEXT_NODE;\n                case Compiler.NODE_TYPE_COMMENT :\n                    return nodeType == Node.COMMENT_NODE;\n                case Compiler.NODE_TYPE_PI :\n                    return nodeType == Node.PROCESSING_INSTRUCTION_NODE;\n            }\n            return false;\n        }\n        if (test instanceof ProcessingInstructionTest) {\n            if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {\n                String testPI = ((ProcessingInstructionTest) test).getTarget();\n                String nodePI = ((ProcessingInstruction) node).getTarget();\n                return testPI.equals(nodePI);\n            }\n        }\n        return false;\n    }\n\n    private static boolean equalStrings(String s1, String s2) {\n        if (s1 == s2) {\n            return true;\n        }\n        s1 = s1 == null ? \"\" : s1.trim();\n        s2 = s2 == null ? \"\" : s2.trim();\n        return s1.equals(s2);\n    }\n\n    public QName getName() {\n        String ln = null;\n        String ns = null;\n        int type = node.getNodeType();\n        if (type == Node.ELEMENT_NODE) {\n            ns = DOMNodePointer.getPrefix(node);\n            ln = DOMNodePointer.getLocalName(node);\n        }\n        else if (type == Node.PROCESSING_INSTRUCTION_NODE) {\n            ln = ((ProcessingInstruction) node).getTarget();\n        }\n        return new QName(ns, ln);\n    }\n\n    public String getNamespaceURI() {\n        return getNamespaceURI(node);\n    }\n\n    public NodeIterator childIterator( NodeTest test, boolean reverse, NodePointer startWith) {\n        return new DOMNodeIterator(this, test, reverse, startWith);\n    }\n\n    public NodeIterator attributeIterator(QName name) {\n        return new DOMAttributeIterator(this, name);\n    }\n\n    public NodePointer namespacePointer(String prefix) {\n        return new NamespacePointer(this, prefix);\n    }\n\n    public NodeIterator namespaceIterator() {\n        return new DOMNamespaceIterator(this);\n    }\n\n    \n    public synchronized NamespaceResolver getNamespaceResolver() {\n        if (localNamespaceResolver == null) {\n            localNamespaceResolver = new NamespaceResolver(super.getNamespaceResolver());\n            localNamespaceResolver.setNamespaceContextPointer(this);\n        }\n        return localNamespaceResolver;\n    }\n\n    public String getNamespaceURI(String prefix) {\n        if (prefix == null || prefix.equals(\"\")) {\n            return getDefaultNamespaceURI();\n        }\n\n        if (prefix.equals(\"xml\")) {\n            return XML_NAMESPACE_URI;\n        }\n\n        if (prefix.equals(\"xmlns\")) {\n            return XMLNS_NAMESPACE_URI;\n        }\n\n        String namespace = null;\n        if (namespaces == null) {\n            namespaces = new HashMap();\n        }\n        else {\n            namespace = (String) namespaces.get(prefix);\n        }\n\n        if (namespace == null) {\n            String qname = \"xmlns:\" + prefix;\n            Node aNode = node;\n            if (aNode instanceof Document) {\n                aNode = ((Document)aNode).getDocumentElement();\n            }\n            while (aNode != null) {\n                if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n                    Attr attr = ((Element) aNode).getAttributeNode(qname);\n                    if (attr != null) {\n                        namespace = attr.getValue();\n                        break;\n                    }\n                }\n                aNode = aNode.getParentNode();\n            }\n            if (namespace == null || namespace.equals(\"\")) {\n                namespace = NodePointer.UNKNOWN_NAMESPACE;\n            }\n        }\n\n        namespaces.put(prefix, namespace);\n        if (namespace == UNKNOWN_NAMESPACE) {\n            return null;\n        }\n        \n        \n        return namespace;\n    }\n\n    public String getDefaultNamespaceURI() {\n        if (defaultNamespace == null) {\n            Node aNode = node;\n            if (aNode instanceof Document) {\n                aNode = ((Document) aNode).getDocumentElement();\n            }\n            while (aNode != null) {\n                if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n                    Attr attr = ((Element) aNode).getAttributeNode(\"xmlns\");\n                    if (attr != null) {\n                        defaultNamespace = attr.getValue();\n                        break;\n                    }\n                }\n                aNode = aNode.getParentNode();\n            }\n        }\n        if (defaultNamespace == null) {\n            defaultNamespace = \"\";\n        }\n        \n        return defaultNamespace.equals(\"\") ? null : defaultNamespace;\n    }\n\n    public Object getBaseValue() {\n        return node;\n    }\n\n    public Object getImmediateNode() {\n        return node;\n    }\n\n    public boolean isActual() {\n        return true;\n    }\n\n    public boolean isCollection() {\n        return false;\n    }\n\n    public int getLength() {\n        return 1;\n    }\n\n    public boolean isLeaf() {\n        return !node.hasChildNodes();\n    }\n\n    \n    public boolean isLanguage(String lang) {\n        String current = getLanguage();\n        return current == null ? super.isLanguage(lang)\n                : current.toUpperCase().startsWith(lang.toUpperCase());\n    }\n\n    protected static String findEnclosingAttribute(Node n, String attrName) {\n        while (n != null) {\n            if (n.getNodeType() == Node.ELEMENT_NODE) {\n                Element e = (Element) n;\n                String attr = e.getAttribute(attrName);\n                if (attr != null && !attr.equals(\"\")) {\n                    return attr;\n                }\n            }\n            n = n.getParentNode();\n        }\n        return null;\n    }\n\n    protected String getLanguage() {\n        return findEnclosingAttribute(node, \"xml:lang\");\n    }\n\n    \n    public void setValue(Object value) {\n        if (node.getNodeType() == Node.TEXT_NODE\n            || node.getNodeType() == Node.CDATA_SECTION_NODE) {\n            String string = (String) TypeUtils.convert(value, String.class);\n            if (string != null && !string.equals(\"\")) {\n                node.setNodeValue(string);\n            }\n            else {\n                node.getParentNode().removeChild(node);\n            }\n        }\n        else {\n            NodeList children = node.getChildNodes();\n            int count = children.getLength();\n            for (int i = count; --i >= 0;) {\n                Node child = children.item(i);\n                node.removeChild(child);\n            }\n\n            if (value instanceof Node) {\n                Node valueNode = (Node) value;\n                if (valueNode instanceof Element\n                    || valueNode instanceof Document) {\n                    children = valueNode.getChildNodes();\n                    for (int i = 0; i < children.getLength(); i++) {\n                        Node child = children.item(i);\n                        node.appendChild(child.cloneNode(true));\n                    }\n                }\n                else {\n                    node.appendChild(valueNode.cloneNode(true));\n                }\n            }\n            else {\n                String string = (String) TypeUtils.convert(value, String.class);\n                if (string != null && !string.equals(\"\")) {\n                    Node textNode =\n                        node.getOwnerDocument().createTextNode(string);\n                    node.appendChild(textNode);\n                }\n            }\n        }\n    }\n    \n    public NodePointer createChild( JXPathContext context, QName name, int index) {\n        if (index == WHOLE_COLLECTION) {\n            index = 0;\n        }\n        boolean success =\n            getAbstractFactory(context).createObject(\n                context,\n                this,\n                node,\n                name.toString(),\n                index);\n        if (success) {\n            NodeTest nodeTest;\n            String prefix = name.getPrefix();\n            String namespaceURI = prefix == null ? null : \n                context.getNamespaceURI(prefix);\n            nodeTest = new NodeNameTest(name, namespaceURI);\n\n            NodeIterator it = childIterator(nodeTest, false, null);\n            if (it != null && it.setPosition(index + 1)) {\n                return it.getNodePointer();\n            }\n        }\n        throw new JXPathAbstractFactoryException(\n                \"Factory could not create a child node for path: \" + asPath()\n                        + \"/\" + name + \"[\" + (index + 1) + \"]\");\n    }\n\n    public NodePointer createChild(JXPathContext context, QName name, int index, Object value) {\n        NodePointer ptr = createChild(context, name, index);\n        ptr.setValue(value);\n        return ptr;\n    }\n\n    public NodePointer createAttribute(JXPathContext context, QName name) {\n        if (!(node instanceof Element)) {\n            return super.createAttribute(context, name);\n        }\n        Element element = (Element) node;\n        String prefix = name.getPrefix();\n        if (prefix != null) {\n            String ns = null;\n            NamespaceResolver nsr = getNamespaceResolver();\n            if (nsr != null) {\n                ns = nsr.getNamespaceURI(prefix);\n            }\n            if (ns == null) {\n                throw new JXPathException(\n                    \"Unknown namespace prefix: \" + prefix);\n            }\n            element.setAttributeNS(ns, name.toString(), \"\");\n        }\n        else {\n            if (!element.hasAttribute(name.getName())) {\n                element.setAttribute(name.getName(), \"\");\n            }\n        }\n        NodeIterator it = attributeIterator(name);\n        it.setPosition(1);\n        return it.getNodePointer();\n    }\n\n    public void remove() {\n        Node parent = node.getParentNode();\n        if (parent == null) {\n            throw new JXPathException(\"Cannot remove root DOM node\");\n        }\n        parent.removeChild(node);\n    }\n\n    public String asPath() {\n        if (id != null) {\n            return \"id('\" + escape(id) + \"')\";\n        }\n\n        StringBuffer buffer = new StringBuffer();\n        if (parent != null) {\n            buffer.append(parent.asPath());\n        }\n        switch (node.getNodeType()) {\n            case Node.ELEMENT_NODE :\n                \n                \n                \n                if (parent instanceof DOMNodePointer) {\n                    if (buffer.length() == 0\n                            || buffer.charAt(buffer.length() - 1) != '/') {\n                        buffer.append('/');\n                    }\n                    String ln = DOMNodePointer.getLocalName(node);\n                    String nsURI = getNamespaceURI();\n                    if (nsURI == null) {\n                        buffer.append(ln);\n                        buffer.append('[');\n                        buffer.append(getRelativePositionByName()).append(']');\n                    }\n                    else {\n                        String prefix = getNamespaceResolver().getPrefix(nsURI);\n                        if (prefix != null) {\n                            buffer.append(prefix);\n                            buffer.append(':');\n                            buffer.append(ln);\n                            buffer.append('[');\n                            buffer.append(getRelativePositionByName());\n                            buffer.append(']');\n                        }\n                        else {\n                            buffer.append(\"node()\");\n                            buffer.append('[');\n                            buffer.append(getRelativePositionOfElement());\n                            buffer.append(']');\n                        }\n                    }\n                }\n            break;\n            case Node.TEXT_NODE :\n            case Node.CDATA_SECTION_NODE :\n                buffer.append(\"/text()\");\n                buffer.append('[');\n                buffer.append(getRelativePositionOfTextNode()).append(']');\n                break;\n            case Node.PROCESSING_INSTRUCTION_NODE :\n                String target = ((ProcessingInstruction) node).getTarget();\n                buffer.append(\"/processing-instruction(\\'\");\n                buffer.append(target).append(\"')\");\n                buffer.append('[');\n                buffer.append(getRelativePositionOfPI(target)).append(']');\n                break;\n            case Node.DOCUMENT_NODE :\n                \n        }\n        return buffer.toString();\n    }\n\n    private String escape(String string) {\n        int index = string.indexOf('\\'');\n        while (index != -1) {\n            string =\n                string.substring(0, index)\n                    + \"&apos;\"\n                    + string.substring(index + 1);\n            index = string.indexOf('\\'');\n        }\n        index = string.indexOf('\\\"');\n        while (index != -1) {\n            string =\n                string.substring(0, index)\n                    + \"&quot;\"\n                    + string.substring(index + 1);\n            index = string.indexOf('\\\"');\n        }\n        return string;\n    }\n\n    private int getRelativePositionByName() {\n        int count = 1;\n        Node n = node.getPreviousSibling();\n        while (n != null) {\n            if (n.getNodeType() == Node.ELEMENT_NODE) {\n                String nm = n.getNodeName();\n                if (nm.equals(node.getNodeName())) {\n                    count++;\n                }\n            }\n            n = n.getPreviousSibling();\n        }\n        return count;\n    }\n    \n    private int getRelativePositionOfElement() {\n        int count = 1;\n        Node n = node.getPreviousSibling();\n        while (n != null) {\n            if (n.getNodeType() == Node.ELEMENT_NODE) {\n                count++;\n            }\n            n = n.getPreviousSibling();\n        }\n        return count;\n    }\n\n    private int getRelativePositionOfTextNode() {\n        int count = 1;\n        Node n = node.getPreviousSibling();\n        while (n != null) {\n            if (n.getNodeType() == Node.TEXT_NODE\n                || n.getNodeType() == Node.CDATA_SECTION_NODE) {\n                count++;\n            }\n            n = n.getPreviousSibling();\n        }\n        return count;\n    }\n\n    private int getRelativePositionOfPI(String target) {\n        int count = 1;\n        Node n = node.getPreviousSibling();\n        while (n != null) {\n            if (n.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE\n                && ((ProcessingInstruction) n).getTarget().equals(target)) {\n                count++;\n            }\n            n = n.getPreviousSibling();\n        }\n        return count;\n    }\n\n    public int hashCode() {\n        return System.identityHashCode(node);\n    }\n\n    public boolean equals(Object object) {\n        return object == this || object instanceof DOMNodePointer && node == ((DOMNodePointer) object).node;\n    }\n\n    public static String getPrefix(Node node) {\n        String prefix = node.getPrefix();\n        if (prefix != null) {\n            return prefix;\n        }\n\n        String name = node.getNodeName();\n        int index = name.lastIndexOf(':');\n        return index < 0 ? null : name.substring(0, index);\n    }\n\n    public static String getLocalName(Node node) {\n        String localName = node.getLocalName();\n        if (localName != null) {\n            return localName;\n        }\n\n        String name = node.getNodeName();\n        int index = name.lastIndexOf(':');\n        return index < 0 ? name : name.substring(index + 1);\n    }\n    \n    public static String getNamespaceURI(Node node) {\n        if (node instanceof Document) {\n            node = ((Document) node).getDocumentElement();\n        }\n\n        Element element = (Element) node;\n\n        String uri = element.getNamespaceURI();\n        if (uri != null) {\n            return uri;\n        }\n\n        String prefix = getPrefix(node);\n        String qname = prefix == null ? \"xmlns\" : \"xmlns:\" + prefix;\n\n        Node aNode = node;\n        while (aNode != null) {\n            if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n                Attr attr = ((Element) aNode).getAttributeNode(qname);\n                if (attr != null) {\n                    return attr.getValue();\n                }\n            }\n            aNode = aNode.getParentNode();\n        }\n        return null;\n    }\n\n    public Object getValue() {\n        if (node.getNodeType() == Node.COMMENT_NODE) {\n            String text = ((Comment) node).getData();\n            return text == null ? \"\" : text.trim();\n        }\n        return stringValue(node);\n    }\n\n    private String stringValue(Node node) {\n        int nodeType = node.getNodeType();\n        if (nodeType == Node.COMMENT_NODE) {\n            return \"\";\n        }\n        boolean trim = !\"preserve\".equals(findEnclosingAttribute(node, \"xml:space\"));\n        if (nodeType == Node.TEXT_NODE || nodeType == Node.CDATA_SECTION_NODE) {\n            String text = node.getNodeValue();\n            return text == null ? \"\" : trim ? text.trim() : text;\n        }\n        if (nodeType == Node.PROCESSING_INSTRUCTION_NODE) {\n            String text = ((ProcessingInstruction) node).getData();\n            return text == null ? \"\" : trim ? text.trim() : text;\n        }\n        NodeList list = node.getChildNodes();\n        StringBuffer buf = new StringBuffer(16);\n        for (int i = 0; i < list.getLength(); i++) {\n            Node child = list.item(i);\n            buf.append(stringValue(child));\n        }\n        return buf.toString();\n    }\n\n    \n    public Pointer getPointerByID(JXPathContext context, String id) {\n        Document document = node.getNodeType() == Node.DOCUMENT_NODE ? (Document) node\n                : node.getOwnerDocument();\n        Element element = document.getElementById(id);\n        return element == null ? (Pointer) new NullPointer(getLocale(), id)\n                : new DOMNodePointer(element, getLocale(), id);\n    }\n\n    private AbstractFactory getAbstractFactory(JXPathContext context) {\n        AbstractFactory factory = context.getFactory();\n        if (factory == null) {\n            throw new JXPathException(\n                \"Factory is not set on the JXPathContext - \"\n                    + \"cannot create path: \"\n                    + asPath());\n        }\n        return factory;\n    }\n\n    public int compareChildNodePointers( NodePointer pointer1, NodePointer pointer2) {\n        Node node1 = (Node) pointer1.getBaseValue();\n        Node node2 = (Node) pointer2.getBaseValue();\n        if (node1 == node2) {\n            return 0;\n        }\n\n        int t1 = node1.getNodeType();\n        int t2 = node2.getNodeType();\n        if (t1 == Node.ATTRIBUTE_NODE && t2 != Node.ATTRIBUTE_NODE) {\n            return -1;\n        }\n        if (t1 != Node.ATTRIBUTE_NODE && t2 == Node.ATTRIBUTE_NODE) {\n            return 1;\n        }\n        if (t1 == Node.ATTRIBUTE_NODE && t2 == Node.ATTRIBUTE_NODE) {\n            NamedNodeMap map = ((Node) getNode()).getAttributes();\n            int length = map.getLength();\n            for (int i = 0; i < length; i++) {\n                Node n = map.item(i);\n                if (n == node1) {\n                    return -1;\n                }\n                if (n == node2) {\n                    return 1;\n                }\n            }\n            return 0; \n        }\n\n        Node current = node.getFirstChild();\n        while (current != null) {\n            if (current == node1) {\n                return -1;\n            }\n            if (current == node2) {\n                return 1;\n            }\n            current = current.getNextSibling();\n        }\n        return 0;\n    }\n}\n",
      "buggy_signatures": [
        "public DOMNodePointer(Node node, Locale locale, String id)",
        "public DOMNodePointer(NodePointer parent, Node node)",
        "public boolean testNode(NodeTest test)",
        "public static boolean testNode(Node node, NodeTest test)",
        "private static boolean equalStrings(String s1, String s2)",
        "public QName getName()",
        "public String getNamespaceURI()",
        "public NodeIterator childIterator( NodeTest test, boolean reverse, NodePointer startWith)",
        "public NodeIterator attributeIterator(QName name)",
        "public NodePointer namespacePointer(String prefix)",
        "public NodeIterator namespaceIterator()",
        "public String getNamespaceURI(String prefix)",
        "public String getDefaultNamespaceURI()",
        "public Object getBaseValue()",
        "public Object getImmediateNode()",
        "public boolean isActual()",
        "public boolean isCollection()",
        "public int getLength()",
        "public boolean isLeaf()",
        "public boolean isLanguage(String lang)",
        "protected static String findEnclosingAttribute(Node n, String attrName)",
        "protected String getLanguage()",
        "public void setValue(Object value)",
        "public NodePointer createChild( JXPathContext context, QName name, int index)",
        "public NodePointer createChild(JXPathContext context, QName name, int index, Object value)",
        "public NodePointer createAttribute(JXPathContext context, QName name)",
        "public void remove()",
        "public String asPath()",
        "private String escape(String string)",
        "private int getRelativePositionByName()",
        "private int getRelativePositionOfElement()",
        "private int getRelativePositionOfTextNode()",
        "private int getRelativePositionOfPI(String target)",
        "public int hashCode()",
        "public boolean equals(Object object)",
        "public static String getPrefix(Node node)",
        "public static String getLocalName(Node node)",
        "public static String getNamespaceURI(Node node)",
        "public Object getValue()",
        "private String stringValue(Node node)",
        "public Pointer getPointerByID(JXPathContext context, String id)",
        "private AbstractFactory getAbstractFactory(JXPathContext context)",
        "public int compareChildNodePointers( NodePointer pointer1, NodePointer pointer2)"
      ],
      "fixed_signatures": [
        "public DOMNodePointer(Node node, Locale locale, String id)",
        "public DOMNodePointer(NodePointer parent, Node node)",
        "public boolean testNode(NodeTest test)",
        "public static boolean testNode(Node node, NodeTest test)",
        "private static boolean equalStrings(String s1, String s2)",
        "public QName getName()",
        "public String getNamespaceURI()",
        "public NodeIterator childIterator( NodeTest test, boolean reverse, NodePointer startWith)",
        "public NodeIterator attributeIterator(QName name)",
        "public NodePointer namespacePointer(String prefix)",
        "public NodeIterator namespaceIterator()",
        "public synchronized NamespaceResolver getNamespaceResolver()",
        "public String getNamespaceURI(String prefix)",
        "public String getDefaultNamespaceURI()",
        "public Object getBaseValue()",
        "public Object getImmediateNode()",
        "public boolean isActual()",
        "public boolean isCollection()",
        "public int getLength()",
        "public boolean isLeaf()",
        "public boolean isLanguage(String lang)",
        "protected static String findEnclosingAttribute(Node n, String attrName)",
        "protected String getLanguage()",
        "public void setValue(Object value)",
        "public NodePointer createChild( JXPathContext context, QName name, int index)",
        "public NodePointer createChild(JXPathContext context, QName name, int index, Object value)",
        "public NodePointer createAttribute(JXPathContext context, QName name)",
        "public void remove()",
        "public String asPath()",
        "private String escape(String string)",
        "private int getRelativePositionByName()",
        "private int getRelativePositionOfElement()",
        "private int getRelativePositionOfTextNode()",
        "private int getRelativePositionOfPI(String target)",
        "public int hashCode()",
        "public boolean equals(Object object)",
        "public static String getPrefix(Node node)",
        "public static String getLocalName(Node node)",
        "public static String getNamespaceURI(Node node)",
        "public Object getValue()",
        "private String stringValue(Node node)",
        "public Pointer getPointerByID(JXPathContext context, String id)",
        "private AbstractFactory getAbstractFactory(JXPathContext context)",
        "public int compareChildNodePointers( NodePointer pointer1, NodePointer pointer2)"
      ],
      "methods": [
        {
          "buggy_method": "",
          "fixed_method": "",
          "diff": [
            "@@ -26,6 +26,7 @@",
            " import org.apache.commons.jxpath.JXPathException;\n",
            " import org.apache.commons.jxpath.Pointer;\n",
            " import org.apache.commons.jxpath.ri.Compiler;\n",
            "+import org.apache.commons.jxpath.ri.NamespaceResolver;\n",
            " import org.apache.commons.jxpath.ri.QName;\n",
            " import org.apache.commons.jxpath.ri.compiler.NodeNameTest;\n",
            " import org.apache.commons.jxpath.ri.compiler.NodeTest;\n"
          ],
          "changed_lines": 1
        },
        {
          "buggy_method": "",
          "fixed_method": "",
          "diff": [
            "@@ -58,6 +59,7 @@",
            "     private Map namespaces;\n",
            "     private String defaultNamespace;\n",
            "     private String id;\n",
            "+    private NamespaceResolver localNamespaceResolver;\n",
            " \n",
            "     public static final String XML_NAMESPACE_URI = \n",
            "             \"http://www.w3.org/XML/1998/namespace\";\n"
          ],
          "changed_lines": 1
        },
        {
          "buggy_method": "  public String getNamespaceURI(String prefix) {\n  if (prefix == null || prefix.equals(\"\")) {\n  return getDefaultNamespaceURI();\n  }\n\n  if (prefix.equals(\"xml\")) {\n  return XML_NAMESPACE_URI;\n  }\n\n  if (prefix.equals(\"xmlns\")) {\n  return XMLNS_NAMESPACE_URI;\n  }\n\n  String namespace = null;\n  if (namespaces == null) {\n  namespaces = new HashMap();\n  }\n  else {\n  namespace = (String) namespaces.get(prefix);\n  }\n\n  if (namespace == null) {\n  String qname = \"xmlns:\" + prefix;\n  Node aNode = node;\n  if (aNode instanceof Document) {\n  aNode = ((Document)aNode).getDocumentElement();\n  }\n  while (aNode != null) {\n  if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n  Attr attr = ((Element) aNode).getAttributeNode(qname);\n  if (attr != null) {\n  namespace = attr.getValue();\n  break;\n  }\n  }\n  aNode = aNode.getParentNode();\n  }\n  if (namespace == null || namespace.equals(\"\")) {\n  namespace = NodePointer.UNKNOWN_NAMESPACE;\n  }\n  }\n\n  namespaces.put(prefix, namespace);\n  if (namespace == UNKNOWN_NAMESPACE) {\n  return null;\n  }\n  \n  \n  return namespace;\n  }",
          "fixed_method": "  public synchronized NamespaceResolver getNamespaceResolver() {\n  if (localNamespaceResolver == null) {\n  localNamespaceResolver = new NamespaceResolver(super.getNamespaceResolver());\n  localNamespaceResolver.setNamespaceContextPointer(this);\n  }\n  return localNamespaceResolver;\n  }",
          "diff": [
            "@@ -186,6 +188,13 @@",
            "     /* (non-Javadoc)\n",
            "      * @see org.apache.commons.jxpath.ri.model.NodePointer#getNamespaceResolver()\n",
            "      */\n",
            "+    public synchronized NamespaceResolver getNamespaceResolver() {\n",
            "+        if (localNamespaceResolver == null) {\n",
            "+            localNamespaceResolver = new NamespaceResolver(super.getNamespaceResolver());\n",
            "+            localNamespaceResolver.setNamespaceContextPointer(this);\n",
            "+        }\n",
            "+        return localNamespaceResolver;\n",
            "+    }\n",
            " \n",
            "     public String getNamespaceURI(String prefix) {\n",
            "         if (prefix == null || prefix.equals(\"\")) {\n"
          ],
          "changed_lines": 7
        },
        {
          "buggy_method": "  public NodePointer createAttribute(JXPathContext context, QName name) {\n  if (!(node instanceof Element)) {\n  return super.createAttribute(context, name);\n  }\n  Element element = (Element) node;\n  String prefix = name.getPrefix();\n  if (prefix != null) {\n  String ns = getNamespaceURI(prefix);\n  if (ns == null) {\n  throw new JXPathException(\n  \"Unknown namespace prefix: \" + prefix);\n  }\n  element.setAttributeNS(ns, name.toString(), \"\");\n  }\n  else {\n  if (!element.hasAttribute(name.getName())) {\n  element.setAttribute(name.getName(), \"\");\n  }\n  }\n  NodeIterator it = attributeIterator(name);\n  it.setPosition(1);\n  return it.getNodePointer();\n  }",
          "fixed_method": "  public NodePointer createAttribute(JXPathContext context, QName name) {\n  if (!(node instanceof Element)) {\n  return super.createAttribute(context, name);\n  }\n  Element element = (Element) node;\n  String prefix = name.getPrefix();\n  if (prefix != null) {\n  String ns = null;\n  NamespaceResolver nsr = getNamespaceResolver();\n  if (nsr != null) {\n  ns = nsr.getNamespaceURI(prefix);\n  }\n  if (ns == null) {\n  throw new JXPathException(\n  \"Unknown namespace prefix: \" + prefix);\n  }\n  element.setAttributeNS(ns, name.toString(), \"\");\n  }\n  else {\n  if (!element.hasAttribute(name.getName())) {\n  element.setAttribute(name.getName(), \"\");\n  }\n  }\n  NodeIterator it = attributeIterator(name);\n  it.setPosition(1);\n  return it.getNodePointer();\n  }",
          "diff": [
            "@@ -412,7 +421,11 @@",
            "         Element element = (Element) node;\n",
            "         String prefix = name.getPrefix();\n",
            "         if (prefix != null) {\n",
            "-            String ns = getNamespaceURI(prefix);\n",
            "+            String ns = null;\n",
            "+            NamespaceResolver nsr = getNamespaceResolver();\n",
            "+            if (nsr != null) {\n",
            "+                ns = nsr.getNamespaceURI(prefix);\n",
            "+            }\n",
            "             if (ns == null) {\n",
            "                 throw new JXPathException(\n",
            "                     \"Unknown namespace prefix: \" + prefix);\n"
          ],
          "changed_lines": 6
        }
      ]
    }
  ]
}
