{
  "bug_id": "13",
  "failed_tests": {
    "com.google.gson.stream.JsonReaderTest": [
      {
        "methodName": "testNegativeZero",
        "error": "junit.framework.ComparisonFailure",
        "message": "expected:<[-]0> but was:<[]0>",
        "fail_line": "\t    assertEquals(\"-0\", reader.nextString());",
        "test_source": "  public void testNegativeZero() throws Exception {\n\t  \tJsonReader reader = new JsonReader(reader(\"[-0]\"));\n\t  reader.setLenient(false);\n\t  reader.beginArray();\n\t  assertEquals(NUMBER, reader.peek());\n\t  assertEquals(\"-0\", reader.nextString());\n  }",
        "stack": [
          "JsonReaderTest.testNegativeZero line 573"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "com/google/gson/stream/JsonReader.java",
      "buggy_full_code": "\n\npackage com.google.gson.stream;\n\nimport com.google.gson.internal.JsonReaderInternalAccess;\nimport com.google.gson.internal.bind.JsonTreeReader;\nimport java.io.Closeable;\nimport java.io.EOFException;\nimport java.io.IOException;\nimport java.io.Reader;\n\n\npublic class JsonReader implements Closeable { private static final char[] NON_EXECUTE_PREFIX = \")]}'\\n\".toCharArray(); private static final long MIN_INCOMPLETE_INTEGER = Long.MIN_VALUE / 10; private static final int PEEKED_NONE = 0; private static final int PEEKED_BEGIN_OBJECT = 1; private static final int PEEKED_END_OBJECT = 2; private static final int PEEKED_BEGIN_ARRAY = 3; private static final int PEEKED_END_ARRAY = 4; private static final int PEEKED_TRUE = 5; private static final int PEEKED_FALSE = 6; private static final int PEEKED_NULL = 7; private static final int PEEKED_SINGLE_QUOTED = 8; private static final int PEEKED_DOUBLE_QUOTED = 9; private static final int PEEKED_UNQUOTED = 10; private static final int PEEKED_BUFFERED = 11; private static final int PEEKED_SINGLE_QUOTED_NAME = 12; private static final int PEEKED_DOUBLE_QUOTED_NAME = 13; private static final int PEEKED_UNQUOTED_NAME = 14; private static final int PEEKED_LONG = 15; private static final int PEEKED_NUMBER = 16; private static final int PEEKED_EOF = 17; private static final int NUMBER_CHAR_NONE = 0; private static final int NUMBER_CHAR_SIGN = 1; private static final int NUMBER_CHAR_DIGIT = 2; private static final int NUMBER_CHAR_DECIMAL = 3; private static final int NUMBER_CHAR_FRACTION_DIGIT = 4; private static final int NUMBER_CHAR_EXP_E = 5; private static final int NUMBER_CHAR_EXP_SIGN = 6; private static final int NUMBER_CHAR_EXP_DIGIT = 7; private final Reader in; private boolean lenient = false; private final char[] buffer = new char[1024]; private int pos = 0; private int limit = 0; private int lineNumber = 0; private int lineStart = 0; int peeked = PEEKED_NONE; private long peekedLong; private int peekedNumberLength; private String peekedString; private int[] stack = new int[32]; private int stackSize = 0; {\n    stack[stackSize++] = JsonScope.EMPTY_DOCUMENT;\n  }\n\n  \n  private String[] pathNames = new String[32]; private int[] pathIndices = new int[32]; public JsonReader(Reader in) {\n    if (in == null) {\n      throw new NullPointerException(\"in == null\");\n    }\n    this.in = in;\n  }\n\n  \n  public final void setLenient(boolean lenient) {\n    this.lenient = lenient;\n  }\n\n  \n  public final boolean isLenient() {\n    return lenient;\n  }\n\n  \n  public void beginArray() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_BEGIN_ARRAY) {\n      push(JsonScope.EMPTY_ARRAY);\n      pathIndices[stackSize - 1] = 0;\n      peeked = PEEKED_NONE;\n    } else {\n      throw new IllegalStateException(\"Expected BEGIN_ARRAY but was \" + peek() + locationString());\n    }\n  }\n\n  \n  public void endArray() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_END_ARRAY) {\n      stackSize--;\n      pathIndices[stackSize - 1]++;\n      peeked = PEEKED_NONE;\n    } else {\n      throw new IllegalStateException(\"Expected END_ARRAY but was \" + peek() + locationString());\n    }\n  }\n\n  \n  public void beginObject() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_BEGIN_OBJECT) {\n      push(JsonScope.EMPTY_OBJECT);\n      peeked = PEEKED_NONE;\n    } else {\n      throw new IllegalStateException(\"Expected BEGIN_OBJECT but was \" + peek() + locationString());\n    }\n  }\n\n  \n  public void endObject() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_END_OBJECT) {\n      stackSize--;\n      pathNames[stackSize] = null; \n      pathIndices[stackSize - 1]++;\n      peeked = PEEKED_NONE;\n    } else {\n      throw new IllegalStateException(\"Expected END_OBJECT but was \" + peek() + locationString());\n    }\n  }\n\n  \n  public boolean hasNext() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    return p != PEEKED_END_OBJECT && p != PEEKED_END_ARRAY;\n  }\n\n  \n  public JsonToken peek() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    switch (p) {\n    case PEEKED_BEGIN_OBJECT:\n      return JsonToken.BEGIN_OBJECT;\n    case PEEKED_END_OBJECT:\n      return JsonToken.END_OBJECT;\n    case PEEKED_BEGIN_ARRAY:\n      return JsonToken.BEGIN_ARRAY;\n    case PEEKED_END_ARRAY:\n      return JsonToken.END_ARRAY;\n    case PEEKED_SINGLE_QUOTED_NAME:\n    case PEEKED_DOUBLE_QUOTED_NAME:\n    case PEEKED_UNQUOTED_NAME:\n      return JsonToken.NAME;\n    case PEEKED_TRUE:\n    case PEEKED_FALSE:\n      return JsonToken.BOOLEAN;\n    case PEEKED_NULL:\n      return JsonToken.NULL;\n    case PEEKED_SINGLE_QUOTED:\n    case PEEKED_DOUBLE_QUOTED:\n    case PEEKED_UNQUOTED:\n    case PEEKED_BUFFERED:\n      return JsonToken.STRING;\n    case PEEKED_LONG:\n    case PEEKED_NUMBER:\n      return JsonToken.NUMBER;\n    case PEEKED_EOF:\n      return JsonToken.END_DOCUMENT;\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  int doPeek() throws IOException {\n    int peekStack = stack[stackSize - 1];\n    if (peekStack == JsonScope.EMPTY_ARRAY) {\n      stack[stackSize - 1] = JsonScope.NONEMPTY_ARRAY;\n    } else if (peekStack == JsonScope.NONEMPTY_ARRAY) {\n      \n      int c = nextNonWhitespace(true);\n      switch (c) {\n      case ']':\n        return peeked = PEEKED_END_ARRAY;\n      case ';':\n        checkLenient(); \n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    } else if (peekStack == JsonScope.EMPTY_OBJECT || peekStack == JsonScope.NONEMPTY_OBJECT) {\n      stack[stackSize - 1] = JsonScope.DANGLING_NAME;\n      \n      if (peekStack == JsonScope.NONEMPTY_OBJECT) {\n        int c = nextNonWhitespace(true);\n        switch (c) {\n        case '}':\n          return peeked = PEEKED_END_OBJECT;\n        case ';':\n          checkLenient(); \n        case ',':\n          break;\n        default:\n          throw syntaxError(\"Unterminated object\");\n        }\n      }\n      int c = nextNonWhitespace(true);\n      switch (c) {\n      case '\"':\n        return peeked = PEEKED_DOUBLE_QUOTED_NAME;\n      case '\\'':\n        checkLenient();\n        return peeked = PEEKED_SINGLE_QUOTED_NAME;\n      case '}':\n        if (peekStack != JsonScope.NONEMPTY_OBJECT) {\n          return peeked = PEEKED_END_OBJECT;\n        } else {\n          throw syntaxError(\"Expected name\");\n        }\n      default:\n        checkLenient();\n        pos--; \n        if (isLiteral((char) c)) {\n          return peeked = PEEKED_UNQUOTED_NAME;\n        } else {\n          throw syntaxError(\"Expected name\");\n        }\n      }\n    } else if (peekStack == JsonScope.DANGLING_NAME) {\n      stack[stackSize - 1] = JsonScope.NONEMPTY_OBJECT;\n      \n      int c = nextNonWhitespace(true);\n      switch (c) {\n      case ':':\n        break;\n      case '=':\n        checkLenient();\n        if ((pos < limit || fillBuffer(1)) && buffer[pos] == '>') {\n          pos++;\n        }\n        break;\n      default:\n        throw syntaxError(\"Expected ':'\");\n      }\n    } else if (peekStack == JsonScope.EMPTY_DOCUMENT) {\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      stack[stackSize - 1] = JsonScope.NONEMPTY_DOCUMENT;\n    } else if (peekStack == JsonScope.NONEMPTY_DOCUMENT) {\n      int c = nextNonWhitespace(false);\n      if (c == -1) {\n        return peeked = PEEKED_EOF;\n      } else {\n        checkLenient();\n        pos--;\n      }\n    } else if (peekStack == JsonScope.CLOSED) {\n      throw new IllegalStateException(\"JsonReader is closed\");\n    }\n\n    int c = nextNonWhitespace(true);\n    switch (c) {\n    case ']':\n      if (peekStack == JsonScope.EMPTY_ARRAY) {\n        return peeked = PEEKED_END_ARRAY;\n      }\n      \n    case ';':\n    case ',':\n      \n      if (peekStack == JsonScope.EMPTY_ARRAY || peekStack == JsonScope.NONEMPTY_ARRAY) {\n        checkLenient();\n        pos--;\n        return peeked = PEEKED_NULL;\n      } else {\n        throw syntaxError(\"Unexpected value\");\n      }\n    case '\\'':\n      checkLenient();\n      return peeked = PEEKED_SINGLE_QUOTED;\n    case '\"':\n      return peeked = PEEKED_DOUBLE_QUOTED;\n    case '[':\n      return peeked = PEEKED_BEGIN_ARRAY;\n    case '{':\n      return peeked = PEEKED_BEGIN_OBJECT;\n    default:\n      pos--; \n    }\n\n    int result = peekKeyword();\n    if (result != PEEKED_NONE) {\n      return result;\n    }\n\n    result = peekNumber();\n    if (result != PEEKED_NONE) {\n      return result;\n    }\n\n    if (!isLiteral(buffer[pos])) {\n      throw syntaxError(\"Expected value\");\n    }\n\n    checkLenient();\n    return peeked = PEEKED_UNQUOTED;\n  }\n\n  private int peekKeyword() throws IOException {\n    \n    char c = buffer[pos];\n    String keyword;\n    String keywordUpper;\n    int peeking;\n    if (c == 't' || c == 'T') {\n      keyword = \"true\";\n      keywordUpper = \"TRUE\";\n      peeking = PEEKED_TRUE;\n    } else if (c == 'f' || c == 'F') {\n      keyword = \"false\";\n      keywordUpper = \"FALSE\";\n      peeking = PEEKED_FALSE;\n    } else if (c == 'n' || c == 'N') {\n      keyword = \"null\";\n      keywordUpper = \"NULL\";\n      peeking = PEEKED_NULL;\n    } else {\n      return PEEKED_NONE;\n    }\n\n    \n    int length = keyword.length();\n    for (int i = 1; i < length; i++) {\n      if (pos + i >= limit && !fillBuffer(i + 1)) {\n        return PEEKED_NONE;\n      }\n      c = buffer[pos + i];\n      if (c != keyword.charAt(i) && c != keywordUpper.charAt(i)) {\n        return PEEKED_NONE;\n      }\n    }\n\n    if ((pos + length < limit || fillBuffer(length + 1))\n        && isLiteral(buffer[pos + length])) {\n      return PEEKED_NONE; \n    }\n\n    \n    pos += length;\n    return peeked = peeking;\n  }\n\n  private int peekNumber() throws IOException {\n    \n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; \n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          \n          \n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; \n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    \n    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {\n      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }\n\n  private boolean isLiteral(char c) throws IOException {\n    switch (c) {\n    case '/':\n    case '\\\\':\n    case ';':\n    case '#':\n    case '=':\n      checkLenient(); \n    case '{':\n    case '}':\n    case '[':\n    case ']':\n    case ':':\n    case ',':\n    case ' ':\n    case '\\t':\n    case '\\f':\n    case '\\r':\n    case '\\n':\n      return false;\n    default:\n      return true;\n    }\n  }\n\n  \n  public String nextName() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED_NAME) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n      result = nextQuotedValue('\"');\n    } else {\n      throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathNames[stackSize - 1] = result;\n    return result;\n  }\n\n  \n  public String nextString() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED) {\n      result = nextQuotedValue('\"');\n    } else if (p == PEEKED_BUFFERED) {\n      result = peekedString;\n      peekedString = null;\n    } else if (p == PEEKED_LONG) {\n      result = Long.toString(peekedLong);\n    } else if (p == PEEKED_NUMBER) {\n      result = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }\n\n  \n  public boolean nextBoolean() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return true;\n    } else if (p == PEEKED_FALSE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return false;\n    }\n    throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n  }\n\n  \n  public void nextNull() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_NULL) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n    } else {\n      throw new IllegalStateException(\"Expected null but was \" + peek() + locationString());\n    }\n  }\n\n  \n  public double nextDouble() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    if (p == PEEKED_LONG) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return (double) peekedLong;\n    }\n\n    if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n      peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n    } else if (p == PEEKED_UNQUOTED) {\n      peekedString = nextUnquotedValue();\n    } else if (p != PEEKED_BUFFERED) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n    }\n\n    peeked = PEEKED_BUFFERED;\n    double result = Double.parseDouble(peekedString); \n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new MalformedJsonException(\n          \"JSON forbids NaN and infinities: \" + result + locationString());\n    }\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }\n\n  \n  public long nextLong() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    if (p == PEEKED_LONG) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return peekedLong;\n    }\n\n    if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {\n      if (p == PEEKED_UNQUOTED) {\n        peekedString = nextUnquotedValue();\n      } else {\n        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n      }\n      try {\n        long result = Long.parseLong(peekedString);\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return result;\n      } catch (NumberFormatException ignored) {\n        \n      }\n    } else {\n      throw new IllegalStateException(\"Expected a long but was \" + peek() + locationString());\n    }\n\n    peeked = PEEKED_BUFFERED;\n    double asDouble = Double.parseDouble(peekedString); \n    long result = (long) asDouble;\n    if (result != asDouble) { \n      throw new NumberFormatException(\"Expected a long but was \" + peekedString + locationString());\n    }\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }\n\n  \n  private String nextQuotedValue(char quote) throws IOException {\n    \n    char[] buffer = this.buffer;\n    StringBuilder builder = null;\n    while (true) {\n      int p = pos;\n      int l = limit;\n      \n      int start = p;\n      while (p < l) {\n        int c = buffer[p++];\n\n        if (c == quote) {\n          pos = p;\n          int len = p - start - 1;\n          if (builder == null) {\n            return new String(buffer, start, len);\n          } else {\n            builder.append(buffer, start, len);\n            return builder.toString();\n          }\n        } else if (c == '\\\\') {\n          pos = p;\n          int len = p - start - 1;\n          if (builder == null) {\n            int estimatedLength = (len + 1) * 2;\n            builder = new StringBuilder(Math.max(estimatedLength, 16));\n          }\n          builder.append(buffer, start, len);\n          builder.append(readEscapeCharacter());\n          p = pos;\n          l = limit;\n          start = p;\n        } else if (c == '\\n') {\n          lineNumber++;\n          lineStart = p;\n        }\n      }\n\n      if (builder == null) {\n        int estimatedLength = (p - start) * 2;\n        builder = new StringBuilder(Math.max(estimatedLength, 16));\n      }\n      builder.append(buffer, start, p - start);\n      pos = p;\n      if (!fillBuffer(1)) {\n        throw syntaxError(\"Unterminated string\");\n      }\n    }\n  }\n\n  \n  @SuppressWarnings(\"fallthrough\")\n  private String nextUnquotedValue() throws IOException {\n    StringBuilder builder = null;\n    int i = 0;\n\n    findNonLiteralCharacter:\n    while (true) {\n      for (; pos + i < limit; i++) {\n        switch (buffer[pos + i]) {\n        case '/':\n        case '\\\\':\n        case ';':\n        case '#':\n        case '=':\n          checkLenient(); \n        case '{':\n        case '}':\n        case '[':\n        case ']':\n        case ':':\n        case ',':\n        case ' ':\n        case '\\t':\n        case '\\f':\n        case '\\r':\n        case '\\n':\n          break findNonLiteralCharacter;\n        }\n      }\n\n      \n      if (i < buffer.length) {\n        if (fillBuffer(i + 1)) {\n          continue;\n        } else {\n          break;\n        }\n      }\n\n      \n      if (builder == null) {\n        builder = new StringBuilder();\n      }\n      builder.append(buffer, pos, i);\n      pos += i;\n      i = 0;\n      if (!fillBuffer(1)) {\n        break;\n      }\n    }\n\n    String result;\n    if (builder == null) {\n      result = new String(buffer, pos, i);\n    } else {\n      builder.append(buffer, pos, i);\n      result = builder.toString();\n    }\n    pos += i;\n    return result;\n  }\n\n  private void skipQuotedValue(char quote) throws IOException {\n    \n    char[] buffer = this.buffer;\n    do {\n      int p = pos;\n      int l = limit;\n      \n      while (p < l) {\n        int c = buffer[p++];\n        if (c == quote) {\n          pos = p;\n          return;\n        } else if (c == '\\\\') {\n          pos = p;\n          readEscapeCharacter();\n          p = pos;\n          l = limit;\n        } else if (c == '\\n') {\n          lineNumber++;\n          lineStart = p;\n        }\n      }\n      pos = p;\n    } while (fillBuffer(1));\n    throw syntaxError(\"Unterminated string\");\n  }\n\n  private void skipUnquotedValue() throws IOException {\n    do {\n      int i = 0;\n      for (; pos + i < limit; i++) {\n        switch (buffer[pos + i]) {\n        case '/':\n        case '\\\\':\n        case ';':\n        case '#':\n        case '=':\n          checkLenient(); \n        case '{':\n        case '}':\n        case '[':\n        case ']':\n        case ':':\n        case ',':\n        case ' ':\n        case '\\t':\n        case '\\f':\n        case '\\r':\n        case '\\n':\n          pos += i;\n          return;\n        }\n      }\n      pos += i;\n    } while (fillBuffer(1));\n  }\n\n  \n  public int nextInt() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    int result;\n    if (p == PEEKED_LONG) {\n      result = (int) peekedLong;\n      if (peekedLong != result) { \n        throw new NumberFormatException(\"Expected an int but was \" + peekedLong + locationString());\n      }\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    }\n\n    if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {\n      if (p == PEEKED_UNQUOTED) {\n        peekedString = nextUnquotedValue();\n      } else {\n        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n      }\n      try {\n        result = Integer.parseInt(peekedString);\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return result;\n      } catch (NumberFormatException ignored) {\n        \n      }\n    } else {\n      throw new IllegalStateException(\"Expected an int but was \" + peek() + locationString());\n    }\n\n    peeked = PEEKED_BUFFERED;\n    double asDouble = Double.parseDouble(peekedString); \n    result = (int) asDouble;\n    if (result != asDouble) { \n      throw new NumberFormatException(\"Expected an int but was \" + peekedString + locationString());\n    }\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }\n\n  \n  public void close() throws IOException {\n    peeked = PEEKED_NONE;\n    stack[0] = JsonScope.CLOSED;\n    stackSize = 1;\n    in.close();\n  }\n\n  \n  public void skipValue() throws IOException {\n    int count = 0;\n    do {\n      int p = peeked;\n      if (p == PEEKED_NONE) {\n        p = doPeek();\n      }\n\n      if (p == PEEKED_BEGIN_ARRAY) {\n        push(JsonScope.EMPTY_ARRAY);\n        count++;\n      } else if (p == PEEKED_BEGIN_OBJECT) {\n        push(JsonScope.EMPTY_OBJECT);\n        count++;\n      } else if (p == PEEKED_END_ARRAY) {\n        stackSize--;\n        count--;\n      } else if (p == PEEKED_END_OBJECT) {\n        stackSize--;\n        count--;\n      } else if (p == PEEKED_UNQUOTED_NAME || p == PEEKED_UNQUOTED) {\n        skipUnquotedValue();\n      } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_SINGLE_QUOTED_NAME) {\n        skipQuotedValue('\\'');\n      } else if (p == PEEKED_DOUBLE_QUOTED || p == PEEKED_DOUBLE_QUOTED_NAME) {\n        skipQuotedValue('\"');\n      } else if (p == PEEKED_NUMBER) {\n        pos += peekedNumberLength;\n      }\n      peeked = PEEKED_NONE;\n    } while (count != 0);\n\n    pathIndices[stackSize - 1]++;\n    pathNames[stackSize - 1] = \"null\";\n  }\n\n  private void push(int newTop) {\n    if (stackSize == stack.length) {\n      int[] newStack = new int[stackSize * 2];\n      int[] newPathIndices = new int[stackSize * 2];\n      String[] newPathNames = new String[stackSize * 2];\n      System.arraycopy(stack, 0, newStack, 0, stackSize);\n      System.arraycopy(pathIndices, 0, newPathIndices, 0, stackSize);\n      System.arraycopy(pathNames, 0, newPathNames, 0, stackSize);\n      stack = newStack;\n      pathIndices = newPathIndices;\n      pathNames = newPathNames;\n    }\n    stack[stackSize++] = newTop;\n  }\n\n  \n  private boolean fillBuffer(int minimum) throws IOException {\n    char[] buffer = this.buffer;\n    lineStart -= pos;\n    if (limit != pos) {\n      limit -= pos;\n      System.arraycopy(buffer, pos, buffer, 0, limit);\n    } else {\n      limit = 0;\n    }\n\n    pos = 0;\n    int total;\n    while ((total = in.read(buffer, limit, buffer.length - limit)) != -1) {\n      limit += total;\n\n      \n      if (lineNumber == 0 && lineStart == 0 && limit > 0 && buffer[0] == '\\ufeff') {\n        pos++;\n        lineStart++;\n        minimum++;\n      }\n\n      if (limit >= minimum) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  \n  private int nextNonWhitespace(boolean throwOnEof) throws IOException {\n    \n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n    while (true) {\n      if (p == l) {\n        pos = p;\n        if (!fillBuffer(1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      int c = buffer[p++];\n      if (c == '\\n') {\n        lineNumber++;\n        lineStart = p;\n        continue;\n      } else if (c == ' ' || c == '\\r' || c == '\\t') {\n        continue;\n      }\n\n      if (c == '/') {\n        pos = p;\n        if (p == l) {\n          pos--; \n          boolean charsLoaded = fillBuffer(2);\n          pos++; \n          if (!charsLoaded) {\n            return c;\n          }\n        }\n\n        checkLenient();\n        char peek = buffer[pos];\n        switch (peek) {\n        case '*':\n          \n          pos++;\n          if (!skipTo(\"*/\")) {\n            throw syntaxError(\"Unterminated comment\");\n          }\n          p = pos + 2;\n          l = limit;\n          continue;\n\n        case '/':\n          \n          pos++;\n          skipToEndOfLine();\n          p = pos;\n          l = limit;\n          continue;\n\n        default:\n          return c;\n        }\n      } else if (c == '#') {\n        pos = p;\n        \n        checkLenient();\n        skipToEndOfLine();\n        p = pos;\n        l = limit;\n      } else {\n        pos = p;\n        return c;\n      }\n    }\n    if (throwOnEof) {\n      throw new EOFException(\"End of input\" + locationString());\n    } else {\n      return -1;\n    }\n  }\n\n  private void checkLenient() throws IOException {\n    if (!lenient) {\n      throw syntaxError(\"Use JsonReader.setLenient(true) to accept malformed JSON\");\n    }\n  }\n\n  \n  private void skipToEndOfLine() throws IOException {\n    while (pos < limit || fillBuffer(1)) {\n      char c = buffer[pos++];\n      if (c == '\\n') {\n        lineNumber++;\n        lineStart = pos;\n        break;\n      } else if (c == '\\r') {\n        break;\n      }\n    }\n  }\n\n  \n  private boolean skipTo(String toFind) throws IOException {\n    outer:\n    for (; pos + toFind.length() <= limit || fillBuffer(toFind.length()); pos++) {\n      if (buffer[pos] == '\\n') {\n        lineNumber++;\n        lineStart = pos + 1;\n        continue;\n      }\n      for (int c = 0; c < toFind.length(); c++) {\n        if (buffer[pos + c] != toFind.charAt(c)) {\n          continue outer;\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n\n  @Override public String toString() {\n    return getClass().getSimpleName() + locationString();\n  }\n\n  private String locationString() {\n    int line = lineNumber + 1;\n    int column = pos - lineStart + 1;\n    return \" at line \" + line + \" column \" + column + \" path \" + getPath();\n  }\n\n  \n  public String getPath() {\n    StringBuilder result = new StringBuilder().append('$');\n    for (int i = 0, size = stackSize; i < size; i++) {\n      switch (stack[i]) {\n        case JsonScope.EMPTY_ARRAY:\n        case JsonScope.NONEMPTY_ARRAY:\n          result.append('[').append(pathIndices[i]).append(']');\n          break;\n\n        case JsonScope.EMPTY_OBJECT:\n        case JsonScope.DANGLING_NAME:\n        case JsonScope.NONEMPTY_OBJECT:\n          result.append('.');\n          if (pathNames[i] != null) {\n            result.append(pathNames[i]);\n          }\n          break;\n\n        case JsonScope.NONEMPTY_DOCUMENT:\n        case JsonScope.EMPTY_DOCUMENT:\n        case JsonScope.CLOSED:\n          break;\n      }\n    }\n    return result.toString();\n  }\n\n  \n  private char readEscapeCharacter() throws IOException {\n    if (pos == limit && !fillBuffer(1)) {\n      throw syntaxError(\"Unterminated escape sequence\");\n    }\n\n    char escaped = buffer[pos++];\n    switch (escaped) {\n    case 'u':\n      if (pos + 4 > limit && !fillBuffer(4)) {\n        throw syntaxError(\"Unterminated escape sequence\");\n      }\n      \n      char result = 0;\n      for (int i = pos, end = i + 4; i < end; i++) {\n        char c = buffer[i];\n        result <<= 4;\n        if (c >= '0' && c <= '9') {\n          result += (c - '0');\n        } else if (c >= 'a' && c <= 'f') {\n          result += (c - 'a' + 10);\n        } else if (c >= 'A' && c <= 'F') {\n          result += (c - 'A' + 10);\n        } else {\n          throw new NumberFormatException(\"\\\\u\" + new String(buffer, pos, 4));\n        }\n      }\n      pos += 4;\n      return result;\n\n    case 't':\n      return '\\t';\n\n    case 'b':\n      return '\\b';\n\n    case 'n':\n      return '\\n';\n\n    case 'r':\n      return '\\r';\n\n    case 'f':\n      return '\\f';\n\n    case '\\n':\n      lineNumber++;\n      lineStart = pos;\n      \n\n    case '\\'':\n    case '\"':\n    case '\\\\':\n    case '/':\t\n    \treturn escaped;\n    default:\n    \t\n    \tthrow syntaxError(\"Invalid escape sequence\");\n    }\n  }\n\n  \n  private IOException syntaxError(String message) throws IOException {\n    throw new MalformedJsonException(message + locationString());\n  }\n\n  \n  private void consumeNonExecutePrefix() throws IOException {\n    \n    nextNonWhitespace(true);\n    pos--;\n\n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n\n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; \n      }\n    }\n\n    \n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  static { JsonReaderInternalAccess.INSTANCE = new JsonReaderInternalAccess() {\n      @Override public void promoteNameToValue(JsonReader reader) throws IOException {\n        if (reader instanceof JsonTreeReader) {\n          ((JsonTreeReader)reader).promoteNameToValue();\n          return;\n        }\n        int p = reader.peeked;\n        if (p == PEEKED_NONE) {\n          p = reader.doPeek();\n        }\n        if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n          reader.peeked = PEEKED_DOUBLE_QUOTED;\n        } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n          reader.peeked = PEEKED_SINGLE_QUOTED;\n        } else if (p == PEEKED_UNQUOTED_NAME) {\n          reader.peeked = PEEKED_UNQUOTED;\n        } else {\n          throw new IllegalStateException(\n              \"Expected a name but was \" + reader.peek() + reader.locationString());\n        }\n      }\n    };\n  }\n}\n",
      "fixed_full_code": "\n\npackage com.google.gson.stream;\n\nimport com.google.gson.internal.JsonReaderInternalAccess;\nimport com.google.gson.internal.bind.JsonTreeReader;\nimport java.io.Closeable;\nimport java.io.EOFException;\nimport java.io.IOException;\nimport java.io.Reader;\n\n\npublic class JsonReader implements Closeable { private static final char[] NON_EXECUTE_PREFIX = \")]}'\\n\".toCharArray(); private static final long MIN_INCOMPLETE_INTEGER = Long.MIN_VALUE / 10; private static final int PEEKED_NONE = 0; private static final int PEEKED_BEGIN_OBJECT = 1; private static final int PEEKED_END_OBJECT = 2; private static final int PEEKED_BEGIN_ARRAY = 3; private static final int PEEKED_END_ARRAY = 4; private static final int PEEKED_TRUE = 5; private static final int PEEKED_FALSE = 6; private static final int PEEKED_NULL = 7; private static final int PEEKED_SINGLE_QUOTED = 8; private static final int PEEKED_DOUBLE_QUOTED = 9; private static final int PEEKED_UNQUOTED = 10; private static final int PEEKED_BUFFERED = 11; private static final int PEEKED_SINGLE_QUOTED_NAME = 12; private static final int PEEKED_DOUBLE_QUOTED_NAME = 13; private static final int PEEKED_UNQUOTED_NAME = 14; private static final int PEEKED_LONG = 15; private static final int PEEKED_NUMBER = 16; private static final int PEEKED_EOF = 17; private static final int NUMBER_CHAR_NONE = 0; private static final int NUMBER_CHAR_SIGN = 1; private static final int NUMBER_CHAR_DIGIT = 2; private static final int NUMBER_CHAR_DECIMAL = 3; private static final int NUMBER_CHAR_FRACTION_DIGIT = 4; private static final int NUMBER_CHAR_EXP_E = 5; private static final int NUMBER_CHAR_EXP_SIGN = 6; private static final int NUMBER_CHAR_EXP_DIGIT = 7; private final Reader in; private boolean lenient = false; private final char[] buffer = new char[1024]; private int pos = 0; private int limit = 0; private int lineNumber = 0; private int lineStart = 0; int peeked = PEEKED_NONE; private long peekedLong; private int peekedNumberLength; private String peekedString; private int[] stack = new int[32]; private int stackSize = 0; {\n    stack[stackSize++] = JsonScope.EMPTY_DOCUMENT;\n  }\n\n  \n  private String[] pathNames = new String[32]; private int[] pathIndices = new int[32]; public JsonReader(Reader in) {\n    if (in == null) {\n      throw new NullPointerException(\"in == null\");\n    }\n    this.in = in;\n  }\n\n  \n  public final void setLenient(boolean lenient) {\n    this.lenient = lenient;\n  }\n\n  \n  public final boolean isLenient() {\n    return lenient;\n  }\n\n  \n  public void beginArray() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_BEGIN_ARRAY) {\n      push(JsonScope.EMPTY_ARRAY);\n      pathIndices[stackSize - 1] = 0;\n      peeked = PEEKED_NONE;\n    } else {\n      throw new IllegalStateException(\"Expected BEGIN_ARRAY but was \" + peek() + locationString());\n    }\n  }\n\n  \n  public void endArray() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_END_ARRAY) {\n      stackSize--;\n      pathIndices[stackSize - 1]++;\n      peeked = PEEKED_NONE;\n    } else {\n      throw new IllegalStateException(\"Expected END_ARRAY but was \" + peek() + locationString());\n    }\n  }\n\n  \n  public void beginObject() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_BEGIN_OBJECT) {\n      push(JsonScope.EMPTY_OBJECT);\n      peeked = PEEKED_NONE;\n    } else {\n      throw new IllegalStateException(\"Expected BEGIN_OBJECT but was \" + peek() + locationString());\n    }\n  }\n\n  \n  public void endObject() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_END_OBJECT) {\n      stackSize--;\n      pathNames[stackSize] = null; \n      pathIndices[stackSize - 1]++;\n      peeked = PEEKED_NONE;\n    } else {\n      throw new IllegalStateException(\"Expected END_OBJECT but was \" + peek() + locationString());\n    }\n  }\n\n  \n  public boolean hasNext() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    return p != PEEKED_END_OBJECT && p != PEEKED_END_ARRAY;\n  }\n\n  \n  public JsonToken peek() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    switch (p) {\n    case PEEKED_BEGIN_OBJECT:\n      return JsonToken.BEGIN_OBJECT;\n    case PEEKED_END_OBJECT:\n      return JsonToken.END_OBJECT;\n    case PEEKED_BEGIN_ARRAY:\n      return JsonToken.BEGIN_ARRAY;\n    case PEEKED_END_ARRAY:\n      return JsonToken.END_ARRAY;\n    case PEEKED_SINGLE_QUOTED_NAME:\n    case PEEKED_DOUBLE_QUOTED_NAME:\n    case PEEKED_UNQUOTED_NAME:\n      return JsonToken.NAME;\n    case PEEKED_TRUE:\n    case PEEKED_FALSE:\n      return JsonToken.BOOLEAN;\n    case PEEKED_NULL:\n      return JsonToken.NULL;\n    case PEEKED_SINGLE_QUOTED:\n    case PEEKED_DOUBLE_QUOTED:\n    case PEEKED_UNQUOTED:\n    case PEEKED_BUFFERED:\n      return JsonToken.STRING;\n    case PEEKED_LONG:\n    case PEEKED_NUMBER:\n      return JsonToken.NUMBER;\n    case PEEKED_EOF:\n      return JsonToken.END_DOCUMENT;\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  int doPeek() throws IOException {\n    int peekStack = stack[stackSize - 1];\n    if (peekStack == JsonScope.EMPTY_ARRAY) {\n      stack[stackSize - 1] = JsonScope.NONEMPTY_ARRAY;\n    } else if (peekStack == JsonScope.NONEMPTY_ARRAY) {\n      \n      int c = nextNonWhitespace(true);\n      switch (c) {\n      case ']':\n        return peeked = PEEKED_END_ARRAY;\n      case ';':\n        checkLenient(); \n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    } else if (peekStack == JsonScope.EMPTY_OBJECT || peekStack == JsonScope.NONEMPTY_OBJECT) {\n      stack[stackSize - 1] = JsonScope.DANGLING_NAME;\n      \n      if (peekStack == JsonScope.NONEMPTY_OBJECT) {\n        int c = nextNonWhitespace(true);\n        switch (c) {\n        case '}':\n          return peeked = PEEKED_END_OBJECT;\n        case ';':\n          checkLenient(); \n        case ',':\n          break;\n        default:\n          throw syntaxError(\"Unterminated object\");\n        }\n      }\n      int c = nextNonWhitespace(true);\n      switch (c) {\n      case '\"':\n        return peeked = PEEKED_DOUBLE_QUOTED_NAME;\n      case '\\'':\n        checkLenient();\n        return peeked = PEEKED_SINGLE_QUOTED_NAME;\n      case '}':\n        if (peekStack != JsonScope.NONEMPTY_OBJECT) {\n          return peeked = PEEKED_END_OBJECT;\n        } else {\n          throw syntaxError(\"Expected name\");\n        }\n      default:\n        checkLenient();\n        pos--; \n        if (isLiteral((char) c)) {\n          return peeked = PEEKED_UNQUOTED_NAME;\n        } else {\n          throw syntaxError(\"Expected name\");\n        }\n      }\n    } else if (peekStack == JsonScope.DANGLING_NAME) {\n      stack[stackSize - 1] = JsonScope.NONEMPTY_OBJECT;\n      \n      int c = nextNonWhitespace(true);\n      switch (c) {\n      case ':':\n        break;\n      case '=':\n        checkLenient();\n        if ((pos < limit || fillBuffer(1)) && buffer[pos] == '>') {\n          pos++;\n        }\n        break;\n      default:\n        throw syntaxError(\"Expected ':'\");\n      }\n    } else if (peekStack == JsonScope.EMPTY_DOCUMENT) {\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      stack[stackSize - 1] = JsonScope.NONEMPTY_DOCUMENT;\n    } else if (peekStack == JsonScope.NONEMPTY_DOCUMENT) {\n      int c = nextNonWhitespace(false);\n      if (c == -1) {\n        return peeked = PEEKED_EOF;\n      } else {\n        checkLenient();\n        pos--;\n      }\n    } else if (peekStack == JsonScope.CLOSED) {\n      throw new IllegalStateException(\"JsonReader is closed\");\n    }\n\n    int c = nextNonWhitespace(true);\n    switch (c) {\n    case ']':\n      if (peekStack == JsonScope.EMPTY_ARRAY) {\n        return peeked = PEEKED_END_ARRAY;\n      }\n      \n    case ';':\n    case ',':\n      \n      if (peekStack == JsonScope.EMPTY_ARRAY || peekStack == JsonScope.NONEMPTY_ARRAY) {\n        checkLenient();\n        pos--;\n        return peeked = PEEKED_NULL;\n      } else {\n        throw syntaxError(\"Unexpected value\");\n      }\n    case '\\'':\n      checkLenient();\n      return peeked = PEEKED_SINGLE_QUOTED;\n    case '\"':\n      return peeked = PEEKED_DOUBLE_QUOTED;\n    case '[':\n      return peeked = PEEKED_BEGIN_ARRAY;\n    case '{':\n      return peeked = PEEKED_BEGIN_OBJECT;\n    default:\n      pos--; \n    }\n\n    int result = peekKeyword();\n    if (result != PEEKED_NONE) {\n      return result;\n    }\n\n    result = peekNumber();\n    if (result != PEEKED_NONE) {\n      return result;\n    }\n\n    if (!isLiteral(buffer[pos])) {\n      throw syntaxError(\"Expected value\");\n    }\n\n    checkLenient();\n    return peeked = PEEKED_UNQUOTED;\n  }\n\n  private int peekKeyword() throws IOException {\n    \n    char c = buffer[pos];\n    String keyword;\n    String keywordUpper;\n    int peeking;\n    if (c == 't' || c == 'T') {\n      keyword = \"true\";\n      keywordUpper = \"TRUE\";\n      peeking = PEEKED_TRUE;\n    } else if (c == 'f' || c == 'F') {\n      keyword = \"false\";\n      keywordUpper = \"FALSE\";\n      peeking = PEEKED_FALSE;\n    } else if (c == 'n' || c == 'N') {\n      keyword = \"null\";\n      keywordUpper = \"NULL\";\n      peeking = PEEKED_NULL;\n    } else {\n      return PEEKED_NONE;\n    }\n\n    \n    int length = keyword.length();\n    for (int i = 1; i < length; i++) {\n      if (pos + i >= limit && !fillBuffer(i + 1)) {\n        return PEEKED_NONE;\n      }\n      c = buffer[pos + i];\n      if (c != keyword.charAt(i) && c != keywordUpper.charAt(i)) {\n        return PEEKED_NONE;\n      }\n    }\n\n    if ((pos + length < limit || fillBuffer(length + 1))\n        && isLiteral(buffer[pos + length])) {\n      return PEEKED_NONE; \n    }\n\n    \n    pos += length;\n    return peeked = peeking;\n  }\n\n  private int peekNumber() throws IOException {\n    \n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; \n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          \n          \n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; \n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    \n    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative) && (value!=0 || false==negative)) {\n      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }\n\n  private boolean isLiteral(char c) throws IOException {\n    switch (c) {\n    case '/':\n    case '\\\\':\n    case ';':\n    case '#':\n    case '=':\n      checkLenient(); \n    case '{':\n    case '}':\n    case '[':\n    case ']':\n    case ':':\n    case ',':\n    case ' ':\n    case '\\t':\n    case '\\f':\n    case '\\r':\n    case '\\n':\n      return false;\n    default:\n      return true;\n    }\n  }\n\n  \n  public String nextName() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED_NAME) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n      result = nextQuotedValue('\"');\n    } else {\n      throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathNames[stackSize - 1] = result;\n    return result;\n  }\n\n  \n  public String nextString() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED) {\n      result = nextQuotedValue('\"');\n    } else if (p == PEEKED_BUFFERED) {\n      result = peekedString;\n      peekedString = null;\n    } else if (p == PEEKED_LONG) {\n      result = Long.toString(peekedLong);\n    } else if (p == PEEKED_NUMBER) {\n      result = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }\n\n  \n  public boolean nextBoolean() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return true;\n    } else if (p == PEEKED_FALSE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return false;\n    }\n    throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n  }\n\n  \n  public void nextNull() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_NULL) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n    } else {\n      throw new IllegalStateException(\"Expected null but was \" + peek() + locationString());\n    }\n  }\n\n  \n  public double nextDouble() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    if (p == PEEKED_LONG) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return (double) peekedLong;\n    }\n\n    if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n      peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n    } else if (p == PEEKED_UNQUOTED) {\n      peekedString = nextUnquotedValue();\n    } else if (p != PEEKED_BUFFERED) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n    }\n\n    peeked = PEEKED_BUFFERED;\n    double result = Double.parseDouble(peekedString); \n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new MalformedJsonException(\n          \"JSON forbids NaN and infinities: \" + result + locationString());\n    }\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }\n\n  \n  public long nextLong() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    if (p == PEEKED_LONG) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return peekedLong;\n    }\n\n    if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {\n      if (p == PEEKED_UNQUOTED) {\n        peekedString = nextUnquotedValue();\n      } else {\n        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n      }\n      try {\n        long result = Long.parseLong(peekedString);\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return result;\n      } catch (NumberFormatException ignored) {\n        \n      }\n    } else {\n      throw new IllegalStateException(\"Expected a long but was \" + peek() + locationString());\n    }\n\n    peeked = PEEKED_BUFFERED;\n    double asDouble = Double.parseDouble(peekedString); \n    long result = (long) asDouble;\n    if (result != asDouble) { \n      throw new NumberFormatException(\"Expected a long but was \" + peekedString + locationString());\n    }\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }\n\n  \n  private String nextQuotedValue(char quote) throws IOException {\n    \n    char[] buffer = this.buffer;\n    StringBuilder builder = null;\n    while (true) {\n      int p = pos;\n      int l = limit;\n      \n      int start = p;\n      while (p < l) {\n        int c = buffer[p++];\n\n        if (c == quote) {\n          pos = p;\n          int len = p - start - 1;\n          if (builder == null) {\n            return new String(buffer, start, len);\n          } else {\n            builder.append(buffer, start, len);\n            return builder.toString();\n          }\n        } else if (c == '\\\\') {\n          pos = p;\n          int len = p - start - 1;\n          if (builder == null) {\n            int estimatedLength = (len + 1) * 2;\n            builder = new StringBuilder(Math.max(estimatedLength, 16));\n          }\n          builder.append(buffer, start, len);\n          builder.append(readEscapeCharacter());\n          p = pos;\n          l = limit;\n          start = p;\n        } else if (c == '\\n') {\n          lineNumber++;\n          lineStart = p;\n        }\n      }\n\n      if (builder == null) {\n        int estimatedLength = (p - start) * 2;\n        builder = new StringBuilder(Math.max(estimatedLength, 16));\n      }\n      builder.append(buffer, start, p - start);\n      pos = p;\n      if (!fillBuffer(1)) {\n        throw syntaxError(\"Unterminated string\");\n      }\n    }\n  }\n\n  \n  @SuppressWarnings(\"fallthrough\")\n  private String nextUnquotedValue() throws IOException {\n    StringBuilder builder = null;\n    int i = 0;\n\n    findNonLiteralCharacter:\n    while (true) {\n      for (; pos + i < limit; i++) {\n        switch (buffer[pos + i]) {\n        case '/':\n        case '\\\\':\n        case ';':\n        case '#':\n        case '=':\n          checkLenient(); \n        case '{':\n        case '}':\n        case '[':\n        case ']':\n        case ':':\n        case ',':\n        case ' ':\n        case '\\t':\n        case '\\f':\n        case '\\r':\n        case '\\n':\n          break findNonLiteralCharacter;\n        }\n      }\n\n      \n      if (i < buffer.length) {\n        if (fillBuffer(i + 1)) {\n          continue;\n        } else {\n          break;\n        }\n      }\n\n      \n      if (builder == null) {\n        builder = new StringBuilder();\n      }\n      builder.append(buffer, pos, i);\n      pos += i;\n      i = 0;\n      if (!fillBuffer(1)) {\n        break;\n      }\n    }\n\n    String result;\n    if (builder == null) {\n      result = new String(buffer, pos, i);\n    } else {\n      builder.append(buffer, pos, i);\n      result = builder.toString();\n    }\n    pos += i;\n    return result;\n  }\n\n  private void skipQuotedValue(char quote) throws IOException {\n    \n    char[] buffer = this.buffer;\n    do {\n      int p = pos;\n      int l = limit;\n      \n      while (p < l) {\n        int c = buffer[p++];\n        if (c == quote) {\n          pos = p;\n          return;\n        } else if (c == '\\\\') {\n          pos = p;\n          readEscapeCharacter();\n          p = pos;\n          l = limit;\n        } else if (c == '\\n') {\n          lineNumber++;\n          lineStart = p;\n        }\n      }\n      pos = p;\n    } while (fillBuffer(1));\n    throw syntaxError(\"Unterminated string\");\n  }\n\n  private void skipUnquotedValue() throws IOException {\n    do {\n      int i = 0;\n      for (; pos + i < limit; i++) {\n        switch (buffer[pos + i]) {\n        case '/':\n        case '\\\\':\n        case ';':\n        case '#':\n        case '=':\n          checkLenient(); \n        case '{':\n        case '}':\n        case '[':\n        case ']':\n        case ':':\n        case ',':\n        case ' ':\n        case '\\t':\n        case '\\f':\n        case '\\r':\n        case '\\n':\n          pos += i;\n          return;\n        }\n      }\n      pos += i;\n    } while (fillBuffer(1));\n  }\n\n  \n  public int nextInt() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    int result;\n    if (p == PEEKED_LONG) {\n      result = (int) peekedLong;\n      if (peekedLong != result) { \n        throw new NumberFormatException(\"Expected an int but was \" + peekedLong + locationString());\n      }\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    }\n\n    if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {\n      if (p == PEEKED_UNQUOTED) {\n        peekedString = nextUnquotedValue();\n      } else {\n        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n      }\n      try {\n        result = Integer.parseInt(peekedString);\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return result;\n      } catch (NumberFormatException ignored) {\n        \n      }\n    } else {\n      throw new IllegalStateException(\"Expected an int but was \" + peek() + locationString());\n    }\n\n    peeked = PEEKED_BUFFERED;\n    double asDouble = Double.parseDouble(peekedString); \n    result = (int) asDouble;\n    if (result != asDouble) { \n      throw new NumberFormatException(\"Expected an int but was \" + peekedString + locationString());\n    }\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }\n\n  \n  public void close() throws IOException {\n    peeked = PEEKED_NONE;\n    stack[0] = JsonScope.CLOSED;\n    stackSize = 1;\n    in.close();\n  }\n\n  \n  public void skipValue() throws IOException {\n    int count = 0;\n    do {\n      int p = peeked;\n      if (p == PEEKED_NONE) {\n        p = doPeek();\n      }\n\n      if (p == PEEKED_BEGIN_ARRAY) {\n        push(JsonScope.EMPTY_ARRAY);\n        count++;\n      } else if (p == PEEKED_BEGIN_OBJECT) {\n        push(JsonScope.EMPTY_OBJECT);\n        count++;\n      } else if (p == PEEKED_END_ARRAY) {\n        stackSize--;\n        count--;\n      } else if (p == PEEKED_END_OBJECT) {\n        stackSize--;\n        count--;\n      } else if (p == PEEKED_UNQUOTED_NAME || p == PEEKED_UNQUOTED) {\n        skipUnquotedValue();\n      } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_SINGLE_QUOTED_NAME) {\n        skipQuotedValue('\\'');\n      } else if (p == PEEKED_DOUBLE_QUOTED || p == PEEKED_DOUBLE_QUOTED_NAME) {\n        skipQuotedValue('\"');\n      } else if (p == PEEKED_NUMBER) {\n        pos += peekedNumberLength;\n      }\n      peeked = PEEKED_NONE;\n    } while (count != 0);\n\n    pathIndices[stackSize - 1]++;\n    pathNames[stackSize - 1] = \"null\";\n  }\n\n  private void push(int newTop) {\n    if (stackSize == stack.length) {\n      int[] newStack = new int[stackSize * 2];\n      int[] newPathIndices = new int[stackSize * 2];\n      String[] newPathNames = new String[stackSize * 2];\n      System.arraycopy(stack, 0, newStack, 0, stackSize);\n      System.arraycopy(pathIndices, 0, newPathIndices, 0, stackSize);\n      System.arraycopy(pathNames, 0, newPathNames, 0, stackSize);\n      stack = newStack;\n      pathIndices = newPathIndices;\n      pathNames = newPathNames;\n    }\n    stack[stackSize++] = newTop;\n  }\n\n  \n  private boolean fillBuffer(int minimum) throws IOException {\n    char[] buffer = this.buffer;\n    lineStart -= pos;\n    if (limit != pos) {\n      limit -= pos;\n      System.arraycopy(buffer, pos, buffer, 0, limit);\n    } else {\n      limit = 0;\n    }\n\n    pos = 0;\n    int total;\n    while ((total = in.read(buffer, limit, buffer.length - limit)) != -1) {\n      limit += total;\n\n      \n      if (lineNumber == 0 && lineStart == 0 && limit > 0 && buffer[0] == '\\ufeff') {\n        pos++;\n        lineStart++;\n        minimum++;\n      }\n\n      if (limit >= minimum) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  \n  private int nextNonWhitespace(boolean throwOnEof) throws IOException {\n    \n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n    while (true) {\n      if (p == l) {\n        pos = p;\n        if (!fillBuffer(1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      int c = buffer[p++];\n      if (c == '\\n') {\n        lineNumber++;\n        lineStart = p;\n        continue;\n      } else if (c == ' ' || c == '\\r' || c == '\\t') {\n        continue;\n      }\n\n      if (c == '/') {\n        pos = p;\n        if (p == l) {\n          pos--; \n          boolean charsLoaded = fillBuffer(2);\n          pos++; \n          if (!charsLoaded) {\n            return c;\n          }\n        }\n\n        checkLenient();\n        char peek = buffer[pos];\n        switch (peek) {\n        case '*':\n          \n          pos++;\n          if (!skipTo(\"*/\")) {\n            throw syntaxError(\"Unterminated comment\");\n          }\n          p = pos + 2;\n          l = limit;\n          continue;\n\n        case '/':\n          \n          pos++;\n          skipToEndOfLine();\n          p = pos;\n          l = limit;\n          continue;\n\n        default:\n          return c;\n        }\n      } else if (c == '#') {\n        pos = p;\n        \n        checkLenient();\n        skipToEndOfLine();\n        p = pos;\n        l = limit;\n      } else {\n        pos = p;\n        return c;\n      }\n    }\n    if (throwOnEof) {\n      throw new EOFException(\"End of input\" + locationString());\n    } else {\n      return -1;\n    }\n  }\n\n  private void checkLenient() throws IOException {\n    if (!lenient) {\n      throw syntaxError(\"Use JsonReader.setLenient(true) to accept malformed JSON\");\n    }\n  }\n\n  \n  private void skipToEndOfLine() throws IOException {\n    while (pos < limit || fillBuffer(1)) {\n      char c = buffer[pos++];\n      if (c == '\\n') {\n        lineNumber++;\n        lineStart = pos;\n        break;\n      } else if (c == '\\r') {\n        break;\n      }\n    }\n  }\n\n  \n  private boolean skipTo(String toFind) throws IOException {\n    outer:\n    for (; pos + toFind.length() <= limit || fillBuffer(toFind.length()); pos++) {\n      if (buffer[pos] == '\\n') {\n        lineNumber++;\n        lineStart = pos + 1;\n        continue;\n      }\n      for (int c = 0; c < toFind.length(); c++) {\n        if (buffer[pos + c] != toFind.charAt(c)) {\n          continue outer;\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n\n  @Override public String toString() {\n    return getClass().getSimpleName() + locationString();\n  }\n\n  private String locationString() {\n    int line = lineNumber + 1;\n    int column = pos - lineStart + 1;\n    return \" at line \" + line + \" column \" + column + \" path \" + getPath();\n  }\n\n  \n  public String getPath() {\n    StringBuilder result = new StringBuilder().append('$');\n    for (int i = 0, size = stackSize; i < size; i++) {\n      switch (stack[i]) {\n        case JsonScope.EMPTY_ARRAY:\n        case JsonScope.NONEMPTY_ARRAY:\n          result.append('[').append(pathIndices[i]).append(']');\n          break;\n\n        case JsonScope.EMPTY_OBJECT:\n        case JsonScope.DANGLING_NAME:\n        case JsonScope.NONEMPTY_OBJECT:\n          result.append('.');\n          if (pathNames[i] != null) {\n            result.append(pathNames[i]);\n          }\n          break;\n\n        case JsonScope.NONEMPTY_DOCUMENT:\n        case JsonScope.EMPTY_DOCUMENT:\n        case JsonScope.CLOSED:\n          break;\n      }\n    }\n    return result.toString();\n  }\n\n  \n  private char readEscapeCharacter() throws IOException {\n    if (pos == limit && !fillBuffer(1)) {\n      throw syntaxError(\"Unterminated escape sequence\");\n    }\n\n    char escaped = buffer[pos++];\n    switch (escaped) {\n    case 'u':\n      if (pos + 4 > limit && !fillBuffer(4)) {\n        throw syntaxError(\"Unterminated escape sequence\");\n      }\n      \n      char result = 0;\n      for (int i = pos, end = i + 4; i < end; i++) {\n        char c = buffer[i];\n        result <<= 4;\n        if (c >= '0' && c <= '9') {\n          result += (c - '0');\n        } else if (c >= 'a' && c <= 'f') {\n          result += (c - 'a' + 10);\n        } else if (c >= 'A' && c <= 'F') {\n          result += (c - 'A' + 10);\n        } else {\n          throw new NumberFormatException(\"\\\\u\" + new String(buffer, pos, 4));\n        }\n      }\n      pos += 4;\n      return result;\n\n    case 't':\n      return '\\t';\n\n    case 'b':\n      return '\\b';\n\n    case 'n':\n      return '\\n';\n\n    case 'r':\n      return '\\r';\n\n    case 'f':\n      return '\\f';\n\n    case '\\n':\n      lineNumber++;\n      lineStart = pos;\n      \n\n    case '\\'':\n    case '\"':\n    case '\\\\':\n    case '/':\t\n    \treturn escaped;\n    default:\n    \t\n    \tthrow syntaxError(\"Invalid escape sequence\");\n    }\n  }\n\n  \n  private IOException syntaxError(String message) throws IOException {\n    throw new MalformedJsonException(message + locationString());\n  }\n\n  \n  private void consumeNonExecutePrefix() throws IOException {\n    \n    nextNonWhitespace(true);\n    pos--;\n\n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n\n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; \n      }\n    }\n\n    \n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  static { JsonReaderInternalAccess.INSTANCE = new JsonReaderInternalAccess() {\n      @Override public void promoteNameToValue(JsonReader reader) throws IOException {\n        if (reader instanceof JsonTreeReader) {\n          ((JsonTreeReader)reader).promoteNameToValue();\n          return;\n        }\n        int p = reader.peeked;\n        if (p == PEEKED_NONE) {\n          p = reader.doPeek();\n        }\n        if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n          reader.peeked = PEEKED_DOUBLE_QUOTED;\n        } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n          reader.peeked = PEEKED_SINGLE_QUOTED;\n        } else if (p == PEEKED_UNQUOTED_NAME) {\n          reader.peeked = PEEKED_UNQUOTED;\n        } else {\n          throw new IllegalStateException(\n              \"Expected a name but was \" + reader.peek() + reader.locationString());\n        }\n      }\n    };\n  }\n}\n",
      "buggy_signatures": [
        "public final void setLenient(boolean lenient)",
        "public final boolean isLenient()",
        "public void beginArray() throws IOException",
        "public void endArray() throws IOException",
        "public void beginObject() throws IOException",
        "public void endObject() throws IOException",
        "public boolean hasNext() throws IOException",
        "public JsonToken peek() throws IOException",
        "private int peekKeyword() throws IOException",
        "private int peekNumber() throws IOException",
        "private boolean isLiteral(char c) throws IOException",
        "public String nextName() throws IOException",
        "public String nextString() throws IOException",
        "public boolean nextBoolean() throws IOException",
        "public void nextNull() throws IOException",
        "public double nextDouble() throws IOException",
        "public long nextLong() throws IOException",
        "private String nextQuotedValue(char quote) throws IOException",
        "private String nextUnquotedValue() throws IOException",
        "private void skipQuotedValue(char quote) throws IOException",
        "private void skipUnquotedValue() throws IOException",
        "public int nextInt() throws IOException",
        "public void close() throws IOException",
        "public void skipValue() throws IOException",
        "private void push(int newTop)",
        "private boolean fillBuffer(int minimum) throws IOException",
        "private int nextNonWhitespace(boolean throwOnEof) throws IOException",
        "private void checkLenient() throws IOException",
        "private void skipToEndOfLine() throws IOException",
        "private boolean skipTo(String toFind) throws IOException",
        "public String toString()",
        "private String locationString()",
        "public String getPath()",
        "private char readEscapeCharacter() throws IOException",
        "private IOException syntaxError(String message) throws IOException",
        "private void consumeNonExecutePrefix() throws IOException",
        "public void promoteNameToValue(JsonReader reader) throws IOException"
      ],
      "fixed_signatures": [
        "public final void setLenient(boolean lenient)",
        "public final boolean isLenient()",
        "public void beginArray() throws IOException",
        "public void endArray() throws IOException",
        "public void beginObject() throws IOException",
        "public void endObject() throws IOException",
        "public boolean hasNext() throws IOException",
        "public JsonToken peek() throws IOException",
        "private int peekKeyword() throws IOException",
        "private int peekNumber() throws IOException",
        "private boolean isLiteral(char c) throws IOException",
        "public String nextName() throws IOException",
        "public String nextString() throws IOException",
        "public boolean nextBoolean() throws IOException",
        "public void nextNull() throws IOException",
        "public double nextDouble() throws IOException",
        "public long nextLong() throws IOException",
        "private String nextQuotedValue(char quote) throws IOException",
        "private String nextUnquotedValue() throws IOException",
        "private void skipQuotedValue(char quote) throws IOException",
        "private void skipUnquotedValue() throws IOException",
        "public int nextInt() throws IOException",
        "public void close() throws IOException",
        "public void skipValue() throws IOException",
        "private void push(int newTop)",
        "private boolean fillBuffer(int minimum) throws IOException",
        "private int nextNonWhitespace(boolean throwOnEof) throws IOException",
        "private void checkLenient() throws IOException",
        "private void skipToEndOfLine() throws IOException",
        "private boolean skipTo(String toFind) throws IOException",
        "public String toString()",
        "private String locationString()",
        "public String getPath()",
        "private char readEscapeCharacter() throws IOException",
        "private IOException syntaxError(String message) throws IOException",
        "private void consumeNonExecutePrefix() throws IOException",
        "public void promoteNameToValue(JsonReader reader) throws IOException"
      ],
      "methods": [
        {
          "buggy_method": "  private int peekNumber() throws IOException {\n  \n  char[] buffer = this.buffer;\n  int p = pos;\n  int l = limit;\n\n  long value = 0; \n  boolean negative = false;\n  boolean fitsInLong = true;\n  int last = NUMBER_CHAR_NONE;\n\n  int i = 0;\n\n  charactersOfNumber:\n  for (; true; i++) {\n  if (p + i == l) {\n  if (i == buffer.length) {\n  \n  \n  return PEEKED_NONE;\n  }\n  if (!fillBuffer(i + 1)) {\n  break;\n  }\n  p = pos;\n  l = limit;\n  }\n\n  char c = buffer[p + i];\n  switch (c) {\n  case '-':\n  if (last == NUMBER_CHAR_NONE) {\n  negative = true;\n  last = NUMBER_CHAR_SIGN;\n  continue;\n  } else if (last == NUMBER_CHAR_EXP_E) {\n  last = NUMBER_CHAR_EXP_SIGN;\n  continue;\n  }\n  return PEEKED_NONE;\n\n  case '+':\n  if (last == NUMBER_CHAR_EXP_E) {\n  last = NUMBER_CHAR_EXP_SIGN;\n  continue;\n  }\n  return PEEKED_NONE;\n\n  case 'e':\n  case 'E':\n  if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n  last = NUMBER_CHAR_EXP_E;\n  continue;\n  }\n  return PEEKED_NONE;\n\n  case '.':\n  if (last == NUMBER_CHAR_DIGIT) {\n  last = NUMBER_CHAR_DECIMAL;\n  continue;\n  }\n  return PEEKED_NONE;\n\n  default:\n  if (c < '0' || c > '9') {\n  if (!isLiteral(c)) {\n  break charactersOfNumber;\n  }\n  return PEEKED_NONE;\n  }\n  if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n  value = -(c - '0');\n  last = NUMBER_CHAR_DIGIT;\n  } else if (last == NUMBER_CHAR_DIGIT) {\n  if (value == 0) {\n  return PEEKED_NONE; \n  }\n  long newValue = value * 10 - (c - '0');\n  fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n  || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n  value = newValue;\n  } else if (last == NUMBER_CHAR_DECIMAL) {\n  last = NUMBER_CHAR_FRACTION_DIGIT;\n  } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n  last = NUMBER_CHAR_EXP_DIGIT;\n  }\n  }\n  }\n\n  \n  if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {\n  peekedLong = negative ? value : -value;\n  pos += i;\n  return peeked = PEEKED_LONG;\n  } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n  || last == NUMBER_CHAR_EXP_DIGIT) {\n  peekedNumberLength = i;\n  return peeked = PEEKED_NUMBER;\n  } else {\n  return PEEKED_NONE;\n  }\n  }",
          "fixed_method": "  private int peekNumber() throws IOException {\n  \n  char[] buffer = this.buffer;\n  int p = pos;\n  int l = limit;\n\n  long value = 0; \n  boolean negative = false;\n  boolean fitsInLong = true;\n  int last = NUMBER_CHAR_NONE;\n\n  int i = 0;\n\n  charactersOfNumber:\n  for (; true; i++) {\n  if (p + i == l) {\n  if (i == buffer.length) {\n  \n  \n  return PEEKED_NONE;\n  }\n  if (!fillBuffer(i + 1)) {\n  break;\n  }\n  p = pos;\n  l = limit;\n  }\n\n  char c = buffer[p + i];\n  switch (c) {\n  case '-':\n  if (last == NUMBER_CHAR_NONE) {\n  negative = true;\n  last = NUMBER_CHAR_SIGN;\n  continue;\n  } else if (last == NUMBER_CHAR_EXP_E) {\n  last = NUMBER_CHAR_EXP_SIGN;\n  continue;\n  }\n  return PEEKED_NONE;\n\n  case '+':\n  if (last == NUMBER_CHAR_EXP_E) {\n  last = NUMBER_CHAR_EXP_SIGN;\n  continue;\n  }\n  return PEEKED_NONE;\n\n  case 'e':\n  case 'E':\n  if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n  last = NUMBER_CHAR_EXP_E;\n  continue;\n  }\n  return PEEKED_NONE;\n\n  case '.':\n  if (last == NUMBER_CHAR_DIGIT) {\n  last = NUMBER_CHAR_DECIMAL;\n  continue;\n  }\n  return PEEKED_NONE;\n\n  default:\n  if (c < '0' || c > '9') {\n  if (!isLiteral(c)) {\n  break charactersOfNumber;\n  }\n  return PEEKED_NONE;\n  }\n  if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n  value = -(c - '0');\n  last = NUMBER_CHAR_DIGIT;\n  } else if (last == NUMBER_CHAR_DIGIT) {\n  if (value == 0) {\n  return PEEKED_NONE; \n  }\n  long newValue = value * 10 - (c - '0');\n  fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n  || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n  value = newValue;\n  } else if (last == NUMBER_CHAR_DECIMAL) {\n  last = NUMBER_CHAR_FRACTION_DIGIT;\n  } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n  last = NUMBER_CHAR_EXP_DIGIT;\n  }\n  }\n  }\n\n  \n  if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative) && (value!=0 || false==negative)) {\n  peekedLong = negative ? value : -value;\n  pos += i;\n  return peeked = PEEKED_LONG;\n  } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n  || last == NUMBER_CHAR_EXP_DIGIT) {\n  peekedNumberLength = i;\n  return peeked = PEEKED_NUMBER;\n  } else {\n  return PEEKED_NONE;\n  }\n  }",
          "diff": [
            "@@ -728,7 +728,7 @@",
            "     }\n",
            " \n",
            "     // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\n",
            "-    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {\n",
            "+    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative) && (value!=0 || false==negative)) {\n",
            "       peekedLong = negative ? value : -value;\n",
            "       pos += i;\n",
            "       return peeked = PEEKED_LONG;\n"
          ],
          "changed_lines": 2
        }
      ]
    }
  ]
}
