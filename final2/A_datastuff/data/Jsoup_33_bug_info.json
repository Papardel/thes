{
  "bug_id": "33",
  "failed_tests": {
    "org.jsoup.parser.HtmlParserTest": [
      {
        "methodName": "handlesKnownEmptyBlocks",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<...src=\"/foo\"></script>[<div id=\"2\"><img /><img /></div><a id=\"3\"></a><i></i><foo /><foo>One</foo> <hr /> hr text <hr />] hr text two> but was:<...src=\"/foo\"></script>[&lt;div id=2&gt;&lt;img /&gt;&lt;img&gt;&lt;/div&gt;&lt;a id=3 /&gt;&lt;i /&gt;&lt;foo /&gt;&lt;foo&gt;One&lt;/foo&gt; &lt;hr /&gt; hr text &lt;hr&gt;] hr text two>",
        "fail_line": "        assertEquals(\"<div id=\\\"1\\\"></div><script src=\\\"/foo\\\"></script><div id=\\\"2\\\"><img /><img /></div><a id=\\\"3\\\"></a><i></i><foo /><foo>One</foo> <hr /> hr text <hr /> hr text two\", TextUtil.stripNewlines(doc.body().html()));",
        "test_source": "",
        "stack": [
          "HtmlParserTest.handlesKnownEmptyBlocks line 331"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/jsoup/parser/HtmlTreeBuilder.java",
      "buggy_full_code": "package org.jsoup.parser;\n\nimport org.jsoup.helper.DescendableLinkedList;\nimport org.jsoup.helper.StringUtil;\nimport org.jsoup.helper.Validate;\nimport org.jsoup.nodes.*;\nimport org.jsoup.select.Elements;\n\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\n\n\nclass HtmlTreeBuilder extends TreeBuilder {\n\n    private HtmlTreeBuilderState state; private HtmlTreeBuilderState originalState; private boolean baseUriSetFromDoc = false; private Element headElement; private FormElement formElement; private Element contextElement; private DescendableLinkedList<Element> formattingElements = new DescendableLinkedList<Element>(); private List<Token.Character> pendingTableCharacters = new ArrayList<Token.Character>(); private boolean framesetOk = true; private boolean fosterInserts = false; private boolean fragmentParsing = false; HtmlTreeBuilder() {}\n\n    @Override\n    Document parse(String input, String baseUri, ParseErrorList errors) {\n        state = HtmlTreeBuilderState.Initial;\n        return super.parse(input, baseUri, errors);\n    }\n\n    List<Node> parseFragment(String inputFragment, Element context, String baseUri, ParseErrorList errors) {\n        \n        state = HtmlTreeBuilderState.Initial;\n        initialiseParse(inputFragment, baseUri, errors);\n        contextElement = context;\n        fragmentParsing = true;\n        Element root = null;\n\n        if (context != null) {\n            if (context.ownerDocument() != null) \n                doc.quirksMode(context.ownerDocument().quirksMode());\n\n            \n            String contextTag = context.tagName();\n            if (StringUtil.in(contextTag, \"title\", \"textarea\"))\n                tokeniser.transition(TokeniserState.Rcdata);\n            else if (StringUtil.in(contextTag, \"iframe\", \"noembed\", \"noframes\", \"style\", \"xmp\"))\n                tokeniser.transition(TokeniserState.Rawtext);\n            else if (contextTag.equals(\"script\"))\n                tokeniser.transition(TokeniserState.ScriptData);\n            else if (contextTag.equals((\"noscript\")))\n                tokeniser.transition(TokeniserState.Data); \n            else if (contextTag.equals(\"plaintext\"))\n                tokeniser.transition(TokeniserState.Data);\n            else\n                tokeniser.transition(TokeniserState.Data); \n\n            root = new Element(Tag.valueOf(\"html\"), baseUri);\n            doc.appendChild(root);\n            stack.push(root);\n            resetInsertionMode();\n\n            \n            \n            Elements contextChain = context.parents();\n            contextChain.add(0, context);\n            for (Element parent: contextChain) {\n                if (parent instanceof FormElement) {\n                    formElement = (FormElement) parent;\n                    break;\n                }\n            }\n        }\n\n        runParser();\n        if (context != null)\n            return root.childNodes();\n        else\n            return doc.childNodes();\n    }\n\n    @Override\n    protected boolean process(Token token) {\n        currentToken = token;\n        return this.state.process(token, this);\n    }\n\n    boolean process(Token token, HtmlTreeBuilderState state) {\n        currentToken = token;\n        return state.process(token, this);\n    }\n\n    void transition(HtmlTreeBuilderState state) {\n        this.state = state;\n    }\n\n    HtmlTreeBuilderState state() {\n        return state;\n    }\n\n    void markInsertionMode() {\n        originalState = state;\n    }\n\n    HtmlTreeBuilderState originalState() {\n        return originalState;\n    }\n\n    void framesetOk(boolean framesetOk) {\n        this.framesetOk = framesetOk;\n    }\n\n    boolean framesetOk() {\n        return framesetOk;\n    }\n\n    Document getDocument() {\n        return doc;\n    }\n\n    String getBaseUri() {\n        return baseUri;\n    }\n\n    void maybeSetBaseUri(Element base) {\n        if (baseUriSetFromDoc) \n            return;\n\n        String href = base.absUrl(\"href\");\n        if (href.length() != 0) { \n            baseUri = href;\n            baseUriSetFromDoc = true;\n            doc.setBaseUri(href); \n        }\n    }\n\n    boolean isFragmentParsing() {\n        return fragmentParsing;\n    }\n\n    void error(HtmlTreeBuilderState state) {\n        if (errors.canAddError())\n            errors.add(new ParseError(reader.pos(), \"Unexpected token [%s] when in state [%s]\", currentToken.tokenType(), state));\n    }\n\n    Element insert(Token.StartTag startTag) {\n        \n        \n        if (startTag.isSelfClosing()) {\n            Element el = insertEmpty(startTag);\n            stack.add(el);\n            tokeniser.emit(new Token.EndTag(el.tagName()));  \n            return el;\n        }\n        \n        Element el = new Element(Tag.valueOf(startTag.name()), baseUri, startTag.attributes);\n        insert(el);\n        return el;\n    }\n\n    Element insert(String startTagName) {\n        Element el = new Element(Tag.valueOf(startTagName), baseUri);\n        insert(el);\n        return el;\n    }\n\n    void insert(Element el) {\n        insertNode(el);\n        stack.add(el);\n    }\n\n    Element insertEmpty(Token.StartTag startTag) {\n        Tag tag = Tag.valueOf(startTag.name());\n        Element el = new Element(tag, baseUri, startTag.attributes);\n        insertNode(el);\n        if (startTag.isSelfClosing()) {\n            if (tag.isKnownTag()) {\n                if (tag.isSelfClosing()) tokeniser.acknowledgeSelfClosingFlag(); \n            } else {\n                \n                tag.setSelfClosing();\n                tokeniser.acknowledgeSelfClosingFlag(); \n            }\n        }\n        return el;\n    }\n\n    FormElement insertForm(Token.StartTag startTag, boolean onStack) {\n        Tag tag = Tag.valueOf(startTag.name());\n        FormElement el = new FormElement(tag, baseUri, startTag.attributes);\n        setFormElement(el);\n        insertNode(el);\n        if (onStack)\n            stack.add(el);\n        return el;\n    }\n\n    void insert(Token.Comment commentToken) {\n        Comment comment = new Comment(commentToken.getData(), baseUri);\n        insertNode(comment);\n    }\n\n    void insert(Token.Character characterToken) {\n        Node node;\n        \n        if (StringUtil.in(currentElement().tagName(), \"script\", \"style\"))\n            node = new DataNode(characterToken.getData(), baseUri);\n        else\n            node = new TextNode(characterToken.getData(), baseUri);\n        currentElement().appendChild(node); \n    }\n\n    private void insertNode(Node node) {\n        \n        if (stack.size() == 0)\n            doc.appendChild(node);\n        else if (isFosterInserts())\n            insertInFosterParent(node);\n        else\n            currentElement().appendChild(node);\n\n        \n        if (node instanceof Element && ((Element) node).tag().isFormListed()) {\n            if (formElement != null)\n                formElement.addElement((Element) node);\n        }\n    }\n\n    Element pop() {\n        \n        if (stack.peekLast().nodeName().equals(\"td\") && !state.name().equals(\"InCell\"))\n            Validate.isFalse(true, \"pop td not in cell\");\n        if (stack.peekLast().nodeName().equals(\"html\"))\n            Validate.isFalse(true, \"popping html!\");\n        return stack.pollLast();\n    }\n\n    void push(Element element) {\n        stack.add(element);\n    }\n\n    DescendableLinkedList<Element> getStack() {\n        return stack;\n    }\n\n    boolean onStack(Element el) {\n        return isElementInQueue(stack, el);\n    }\n\n    private boolean isElementInQueue(DescendableLinkedList<Element> queue, Element element) {\n        Iterator<Element> it = queue.descendingIterator();\n        while (it.hasNext()) {\n            Element next = it.next();\n            if (next == element) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    Element getFromStack(String elName) {\n        Iterator<Element> it = stack.descendingIterator();\n        while (it.hasNext()) {\n            Element next = it.next();\n            if (next.nodeName().equals(elName)) {\n                return next;\n            }\n        }\n        return null;\n    }\n\n    boolean removeFromStack(Element el) {\n        Iterator<Element> it = stack.descendingIterator();\n        while (it.hasNext()) {\n            Element next = it.next();\n            if (next == el) {\n                it.remove();\n                return true;\n            }\n        }\n        return false;\n    }\n\n    void popStackToClose(String elName) {\n        Iterator<Element> it = stack.descendingIterator();\n        while (it.hasNext()) {\n            Element next = it.next();\n            if (next.nodeName().equals(elName)) {\n                it.remove();\n                break;\n            } else {\n                it.remove();\n            }\n        }\n    }\n\n    void popStackToClose(String... elNames) {\n        Iterator<Element> it = stack.descendingIterator();\n        while (it.hasNext()) {\n            Element next = it.next();\n            if (StringUtil.in(next.nodeName(), elNames)) {\n                it.remove();\n                break;\n            } else {\n                it.remove();\n            }\n        }\n    }\n\n    void popStackToBefore(String elName) {\n        Iterator<Element> it = stack.descendingIterator();\n        while (it.hasNext()) {\n            Element next = it.next();\n            if (next.nodeName().equals(elName)) {\n                break;\n            } else {\n                it.remove();\n            }\n        }\n    }\n\n    void clearStackToTableContext() {\n        clearStackToContext(\"table\");\n    }\n\n    void clearStackToTableBodyContext() {\n        clearStackToContext(\"tbody\", \"tfoot\", \"thead\");\n    }\n\n    void clearStackToTableRowContext() {\n        clearStackToContext(\"tr\");\n    }\n\n    private void clearStackToContext(String... nodeNames) {\n        Iterator<Element> it = stack.descendingIterator();\n        while (it.hasNext()) {\n            Element next = it.next();\n            if (StringUtil.in(next.nodeName(), nodeNames) || next.nodeName().equals(\"html\"))\n                break;\n            else\n                it.remove();\n        }\n    }\n\n    Element aboveOnStack(Element el) {\n        assert onStack(el);\n        Iterator<Element> it = stack.descendingIterator();\n        while (it.hasNext()) {\n            Element next = it.next();\n            if (next == el) {\n                return it.next();\n            }\n        }\n        return null;\n    }\n\n    void insertOnStackAfter(Element after, Element in) {\n        int i = stack.lastIndexOf(after);\n        Validate.isTrue(i != -1);\n        stack.add(i+1, in);\n    }\n\n    void replaceOnStack(Element out, Element in) {\n        replaceInQueue(stack, out, in);\n    }\n\n    private void replaceInQueue(LinkedList<Element> queue, Element out, Element in) {\n        int i = queue.lastIndexOf(out);\n        Validate.isTrue(i != -1);\n        queue.remove(i);\n        queue.add(i, in);\n    }\n\n    void resetInsertionMode() {\n        boolean last = false;\n        Iterator<Element> it = stack.descendingIterator();\n        while (it.hasNext()) {\n            Element node = it.next();\n            if (!it.hasNext()) {\n                last = true;\n                node = contextElement;\n            }\n            String name = node.nodeName();\n            if (\"select\".equals(name)) {\n                transition(HtmlTreeBuilderState.InSelect);\n                break; \n            } else if ((\"td\".equals(name) || \"td\".equals(name) && !last)) {\n                transition(HtmlTreeBuilderState.InCell);\n                break;\n            } else if (\"tr\".equals(name)) {\n                transition(HtmlTreeBuilderState.InRow);\n                break;\n            } else if (\"tbody\".equals(name) || \"thead\".equals(name) || \"tfoot\".equals(name)) {\n                transition(HtmlTreeBuilderState.InTableBody);\n                break;\n            } else if (\"caption\".equals(name)) {\n                transition(HtmlTreeBuilderState.InCaption);\n                break;\n            } else if (\"colgroup\".equals(name)) {\n                transition(HtmlTreeBuilderState.InColumnGroup);\n                break; \n            } else if (\"table\".equals(name)) {\n                transition(HtmlTreeBuilderState.InTable);\n                break;\n            } else if (\"head\".equals(name)) {\n                transition(HtmlTreeBuilderState.InBody);\n                break; \n            } else if (\"body\".equals(name)) {\n                transition(HtmlTreeBuilderState.InBody);\n                break;\n            } else if (\"frameset\".equals(name)) {\n                transition(HtmlTreeBuilderState.InFrameset);\n                break; \n            } else if (\"html\".equals(name)) {\n                transition(HtmlTreeBuilderState.BeforeHead);\n                break; \n            } else if (last) {\n                transition(HtmlTreeBuilderState.InBody);\n                break; \n            }\n        }\n    }\n\n    \n    private boolean inSpecificScope(String targetName, String[] baseTypes, String[] extraTypes) {\n        return inSpecificScope(new String[]{targetName}, baseTypes, extraTypes);\n    }\n\n    private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {\n        Iterator<Element> it = stack.descendingIterator();\n        while (it.hasNext()) {\n            Element el = it.next();\n            String elName = el.nodeName();\n            if (StringUtil.in(elName, targetNames))\n                return true;\n            if (StringUtil.in(elName, baseTypes))\n                return false;\n            if (extraTypes != null && StringUtil.in(elName, extraTypes))\n                return false;\n        }\n        Validate.fail(\"Should not be reachable\");\n        return false;\n    }\n\n    boolean inScope(String[] targetNames) {\n        return inSpecificScope(targetNames, new String[]{\"applet\", \"caption\", \"html\", \"table\", \"td\", \"th\", \"marquee\", \"object\"}, null);\n    }\n\n    boolean inScope(String targetName) {\n        return inScope(targetName, null);\n    }\n\n    boolean inScope(String targetName, String[] extras) {\n        return inSpecificScope(targetName, new String[]{\"applet\", \"caption\", \"html\", \"table\", \"td\", \"th\", \"marquee\", \"object\"}, extras);\n        \n        \n    }\n\n    boolean inListItemScope(String targetName) {\n        return inScope(targetName, new String[]{\"ol\", \"ul\"});\n    }\n\n    boolean inButtonScope(String targetName) {\n        return inScope(targetName, new String[]{\"button\"});\n    }\n\n    boolean inTableScope(String targetName) {\n        return inSpecificScope(targetName, new String[]{\"html\", \"table\"}, null);\n    }\n\n    boolean inSelectScope(String targetName) {\n        Iterator<Element> it = stack.descendingIterator();\n        while (it.hasNext()) {\n            Element el = it.next();\n            String elName = el.nodeName();\n            if (elName.equals(targetName))\n                return true;\n            if (!StringUtil.in(elName, \"optgroup\", \"option\")) \n                return false;\n        }\n        Validate.fail(\"Should not be reachable\");\n        return false;\n    }\n\n    void setHeadElement(Element headElement) {\n        this.headElement = headElement;\n    }\n\n    Element getHeadElement() {\n        return headElement;\n    }\n\n    boolean isFosterInserts() {\n        return fosterInserts;\n    }\n\n    void setFosterInserts(boolean fosterInserts) {\n        this.fosterInserts = fosterInserts;\n    }\n\n    FormElement getFormElement() {\n        return formElement;\n    }\n\n    void setFormElement(FormElement formElement) {\n        this.formElement = formElement;\n    }\n\n    void newPendingTableCharacters() {\n        pendingTableCharacters = new ArrayList<Token.Character>();\n    }\n\n    List<Token.Character> getPendingTableCharacters() {\n        return pendingTableCharacters;\n    }\n\n    void setPendingTableCharacters(List<Token.Character> pendingTableCharacters) {\n        this.pendingTableCharacters = pendingTableCharacters;\n    }\n\n    \n    void generateImpliedEndTags(String excludeTag) {\n        while ((excludeTag != null && !currentElement().nodeName().equals(excludeTag)) &&\n                StringUtil.in(currentElement().nodeName(), \"dd\", \"dt\", \"li\", \"option\", \"optgroup\", \"p\", \"rp\", \"rt\"))\n            pop();\n    }\n\n    void generateImpliedEndTags() {\n        generateImpliedEndTags(null);\n    }\n\n    boolean isSpecial(Element el) {\n        \n        \n        String name = el.nodeName();\n        return StringUtil.in(name, \"address\", \"applet\", \"area\", \"article\", \"aside\", \"base\", \"basefont\", \"bgsound\",\n                \"blockquote\", \"body\", \"br\", \"button\", \"caption\", \"center\", \"col\", \"colgroup\", \"command\", \"dd\",\n                \"details\", \"dir\", \"div\", \"dl\", \"dt\", \"embed\", \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"form\",\n                \"frame\", \"frameset\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"head\", \"header\", \"hgroup\", \"hr\", \"html\",\n                \"iframe\", \"img\", \"input\", \"isindex\", \"li\", \"link\", \"listing\", \"marquee\", \"menu\", \"meta\", \"nav\",\n                \"noembed\", \"noframes\", \"noscript\", \"object\", \"ol\", \"p\", \"param\", \"plaintext\", \"pre\", \"script\",\n                \"section\", \"select\", \"style\", \"summary\", \"table\", \"tbody\", \"td\", \"textarea\", \"tfoot\", \"th\", \"thead\",\n                \"title\", \"tr\", \"ul\", \"wbr\", \"xmp\");\n    }\n\n    \n    void pushActiveFormattingElements(Element in) {\n        int numSeen = 0;\n        Iterator<Element> iter = formattingElements.descendingIterator();\n        while (iter.hasNext()) {\n            Element el =  iter.next();\n            if (el == null) \n                break;\n\n            if (isSameFormattingElement(in, el))\n                numSeen++;\n\n            if (numSeen == 3) {\n                iter.remove();\n                break;\n            }\n        }\n        formattingElements.add(in);\n    }\n\n    private boolean isSameFormattingElement(Element a, Element b) {\n        \n        return a.nodeName().equals(b.nodeName()) &&\n                \n                a.attributes().equals(b.attributes());\n        \n    }\n\n    void reconstructFormattingElements() {\n        int size = formattingElements.size();\n        if (size == 0 || formattingElements.getLast() == null || onStack(formattingElements.getLast()))\n            return;\n\n        Element entry = formattingElements.getLast();\n        int pos = size - 1;\n        boolean skip = false;\n        while (true) {\n            if (pos == 0) { \n                skip = true;\n                break;\n            }\n            entry = formattingElements.get(--pos); \n            if (entry == null || onStack(entry)) \n                break; \n        }\n        while(true) {\n            if (!skip) \n                entry = formattingElements.get(++pos);\n            Validate.notNull(entry); \n\n            \n            skip = false; \n            Element newEl = insert(entry.nodeName()); \n            \n            newEl.attributes().addAll(entry.attributes());\n\n            \n            formattingElements.add(pos, newEl);\n            formattingElements.remove(pos + 1);\n\n            \n            if (pos == size-1) \n                break;\n        }\n    }\n\n    void clearFormattingElementsToLastMarker() {\n        while (!formattingElements.isEmpty()) {\n            Element el = formattingElements.peekLast();\n            formattingElements.removeLast();\n            if (el == null)\n                break;\n        }\n    }\n\n    void removeFromActiveFormattingElements(Element el) {\n        Iterator<Element> it = formattingElements.descendingIterator();\n        while (it.hasNext()) {\n            Element next = it.next();\n            if (next == el) {\n                it.remove();\n                break;\n            }\n        }\n    }\n\n    boolean isInActiveFormattingElements(Element el) {\n        return isElementInQueue(formattingElements, el);\n    }\n\n    Element getActiveFormattingElement(String nodeName) {\n        Iterator<Element> it = formattingElements.descendingIterator();\n        while (it.hasNext()) {\n            Element next = it.next();\n            if (next == null) \n                break;\n            else if (next.nodeName().equals(nodeName))\n                return next;\n        }\n        return null;\n    }\n\n    void replaceActiveFormattingElement(Element out, Element in) {\n        replaceInQueue(formattingElements, out, in);\n    }\n\n    void insertMarkerToFormattingElements() {\n        formattingElements.add(null);\n    }\n\n    void insertInFosterParent(Node in) {\n        Element fosterParent = null;\n        Element lastTable = getFromStack(\"table\");\n        boolean isLastTableParent = false;\n        if (lastTable != null) {\n            if (lastTable.parent() != null) {\n                fosterParent = lastTable.parent();\n                isLastTableParent = true;\n            } else\n                fosterParent = aboveOnStack(lastTable);\n        } else { \n            fosterParent = stack.get(0);\n        }\n\n        if (isLastTableParent) {\n            Validate.notNull(lastTable); \n            lastTable.before(in);\n        }\n        else\n            fosterParent.appendChild(in);\n    }\n\n    @Override\n    public String toString() {\n        return \"TreeBuilder{\" +\n                \"currentToken=\" + currentToken +\n                \", state=\" + state +\n                \", currentElement=\" + currentElement() +\n                '}';\n    }\n}\n",
      "fixed_full_code": "package org.jsoup.parser;\n\nimport org.jsoup.helper.DescendableLinkedList;\nimport org.jsoup.helper.StringUtil;\nimport org.jsoup.helper.Validate;\nimport org.jsoup.nodes.*;\nimport org.jsoup.select.Elements;\n\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\n\n\nclass HtmlTreeBuilder extends TreeBuilder {\n\n    private HtmlTreeBuilderState state; private HtmlTreeBuilderState originalState; private boolean baseUriSetFromDoc = false; private Element headElement; private FormElement formElement; private Element contextElement; private DescendableLinkedList<Element> formattingElements = new DescendableLinkedList<Element>(); private List<Token.Character> pendingTableCharacters = new ArrayList<Token.Character>(); private boolean framesetOk = true; private boolean fosterInserts = false; private boolean fragmentParsing = false; HtmlTreeBuilder() {}\n\n    @Override\n    Document parse(String input, String baseUri, ParseErrorList errors) {\n        state = HtmlTreeBuilderState.Initial;\n        return super.parse(input, baseUri, errors);\n    }\n\n    List<Node> parseFragment(String inputFragment, Element context, String baseUri, ParseErrorList errors) {\n        \n        state = HtmlTreeBuilderState.Initial;\n        initialiseParse(inputFragment, baseUri, errors);\n        contextElement = context;\n        fragmentParsing = true;\n        Element root = null;\n\n        if (context != null) {\n            if (context.ownerDocument() != null) \n                doc.quirksMode(context.ownerDocument().quirksMode());\n\n            \n            String contextTag = context.tagName();\n            if (StringUtil.in(contextTag, \"title\", \"textarea\"))\n                tokeniser.transition(TokeniserState.Rcdata);\n            else if (StringUtil.in(contextTag, \"iframe\", \"noembed\", \"noframes\", \"style\", \"xmp\"))\n                tokeniser.transition(TokeniserState.Rawtext);\n            else if (contextTag.equals(\"script\"))\n                tokeniser.transition(TokeniserState.ScriptData);\n            else if (contextTag.equals((\"noscript\")))\n                tokeniser.transition(TokeniserState.Data); \n            else if (contextTag.equals(\"plaintext\"))\n                tokeniser.transition(TokeniserState.Data);\n            else\n                tokeniser.transition(TokeniserState.Data); \n\n            root = new Element(Tag.valueOf(\"html\"), baseUri);\n            doc.appendChild(root);\n            stack.push(root);\n            resetInsertionMode();\n\n            \n            \n            Elements contextChain = context.parents();\n            contextChain.add(0, context);\n            for (Element parent: contextChain) {\n                if (parent instanceof FormElement) {\n                    formElement = (FormElement) parent;\n                    break;\n                }\n            }\n        }\n\n        runParser();\n        if (context != null)\n            return root.childNodes();\n        else\n            return doc.childNodes();\n    }\n\n    @Override\n    protected boolean process(Token token) {\n        currentToken = token;\n        return this.state.process(token, this);\n    }\n\n    boolean process(Token token, HtmlTreeBuilderState state) {\n        currentToken = token;\n        return state.process(token, this);\n    }\n\n    void transition(HtmlTreeBuilderState state) {\n        this.state = state;\n    }\n\n    HtmlTreeBuilderState state() {\n        return state;\n    }\n\n    void markInsertionMode() {\n        originalState = state;\n    }\n\n    HtmlTreeBuilderState originalState() {\n        return originalState;\n    }\n\n    void framesetOk(boolean framesetOk) {\n        this.framesetOk = framesetOk;\n    }\n\n    boolean framesetOk() {\n        return framesetOk;\n    }\n\n    Document getDocument() {\n        return doc;\n    }\n\n    String getBaseUri() {\n        return baseUri;\n    }\n\n    void maybeSetBaseUri(Element base) {\n        if (baseUriSetFromDoc) \n            return;\n\n        String href = base.absUrl(\"href\");\n        if (href.length() != 0) { \n            baseUri = href;\n            baseUriSetFromDoc = true;\n            doc.setBaseUri(href); \n        }\n    }\n\n    boolean isFragmentParsing() {\n        return fragmentParsing;\n    }\n\n    void error(HtmlTreeBuilderState state) {\n        if (errors.canAddError())\n            errors.add(new ParseError(reader.pos(), \"Unexpected token [%s] when in state [%s]\", currentToken.tokenType(), state));\n    }\n\n    Element insert(Token.StartTag startTag) {\n        \n        \n        if (startTag.isSelfClosing()) {\n            Element el = insertEmpty(startTag);\n            stack.add(el);\n            tokeniser.transition(TokeniserState.Data); \n            tokeniser.emit(new Token.EndTag(el.tagName()));  \n            return el;\n        }\n        \n        Element el = new Element(Tag.valueOf(startTag.name()), baseUri, startTag.attributes);\n        insert(el);\n        return el;\n    }\n\n    Element insert(String startTagName) {\n        Element el = new Element(Tag.valueOf(startTagName), baseUri);\n        insert(el);\n        return el;\n    }\n\n    void insert(Element el) {\n        insertNode(el);\n        stack.add(el);\n    }\n\n    Element insertEmpty(Token.StartTag startTag) {\n        Tag tag = Tag.valueOf(startTag.name());\n        Element el = new Element(tag, baseUri, startTag.attributes);\n        insertNode(el);\n        if (startTag.isSelfClosing()) {\n            if (tag.isKnownTag()) {\n                if (tag.isSelfClosing()) tokeniser.acknowledgeSelfClosingFlag(); \n            } else {\n                \n                tag.setSelfClosing();\n                tokeniser.acknowledgeSelfClosingFlag(); \n            }\n        }\n        return el;\n    }\n\n    FormElement insertForm(Token.StartTag startTag, boolean onStack) {\n        Tag tag = Tag.valueOf(startTag.name());\n        FormElement el = new FormElement(tag, baseUri, startTag.attributes);\n        setFormElement(el);\n        insertNode(el);\n        if (onStack)\n            stack.add(el);\n        return el;\n    }\n\n    void insert(Token.Comment commentToken) {\n        Comment comment = new Comment(commentToken.getData(), baseUri);\n        insertNode(comment);\n    }\n\n    void insert(Token.Character characterToken) {\n        Node node;\n        \n        if (StringUtil.in(currentElement().tagName(), \"script\", \"style\"))\n            node = new DataNode(characterToken.getData(), baseUri);\n        else\n            node = new TextNode(characterToken.getData(), baseUri);\n        currentElement().appendChild(node); \n    }\n\n    private void insertNode(Node node) {\n        \n        if (stack.size() == 0)\n            doc.appendChild(node);\n        else if (isFosterInserts())\n            insertInFosterParent(node);\n        else\n            currentElement().appendChild(node);\n\n        \n        if (node instanceof Element && ((Element) node).tag().isFormListed()) {\n            if (formElement != null)\n                formElement.addElement((Element) node);\n        }\n    }\n\n    Element pop() {\n        \n        if (stack.peekLast().nodeName().equals(\"td\") && !state.name().equals(\"InCell\"))\n            Validate.isFalse(true, \"pop td not in cell\");\n        if (stack.peekLast().nodeName().equals(\"html\"))\n            Validate.isFalse(true, \"popping html!\");\n        return stack.pollLast();\n    }\n\n    void push(Element element) {\n        stack.add(element);\n    }\n\n    DescendableLinkedList<Element> getStack() {\n        return stack;\n    }\n\n    boolean onStack(Element el) {\n        return isElementInQueue(stack, el);\n    }\n\n    private boolean isElementInQueue(DescendableLinkedList<Element> queue, Element element) {\n        Iterator<Element> it = queue.descendingIterator();\n        while (it.hasNext()) {\n            Element next = it.next();\n            if (next == element) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    Element getFromStack(String elName) {\n        Iterator<Element> it = stack.descendingIterator();\n        while (it.hasNext()) {\n            Element next = it.next();\n            if (next.nodeName().equals(elName)) {\n                return next;\n            }\n        }\n        return null;\n    }\n\n    boolean removeFromStack(Element el) {\n        Iterator<Element> it = stack.descendingIterator();\n        while (it.hasNext()) {\n            Element next = it.next();\n            if (next == el) {\n                it.remove();\n                return true;\n            }\n        }\n        return false;\n    }\n\n    void popStackToClose(String elName) {\n        Iterator<Element> it = stack.descendingIterator();\n        while (it.hasNext()) {\n            Element next = it.next();\n            if (next.nodeName().equals(elName)) {\n                it.remove();\n                break;\n            } else {\n                it.remove();\n            }\n        }\n    }\n\n    void popStackToClose(String... elNames) {\n        Iterator<Element> it = stack.descendingIterator();\n        while (it.hasNext()) {\n            Element next = it.next();\n            if (StringUtil.in(next.nodeName(), elNames)) {\n                it.remove();\n                break;\n            } else {\n                it.remove();\n            }\n        }\n    }\n\n    void popStackToBefore(String elName) {\n        Iterator<Element> it = stack.descendingIterator();\n        while (it.hasNext()) {\n            Element next = it.next();\n            if (next.nodeName().equals(elName)) {\n                break;\n            } else {\n                it.remove();\n            }\n        }\n    }\n\n    void clearStackToTableContext() {\n        clearStackToContext(\"table\");\n    }\n\n    void clearStackToTableBodyContext() {\n        clearStackToContext(\"tbody\", \"tfoot\", \"thead\");\n    }\n\n    void clearStackToTableRowContext() {\n        clearStackToContext(\"tr\");\n    }\n\n    private void clearStackToContext(String... nodeNames) {\n        Iterator<Element> it = stack.descendingIterator();\n        while (it.hasNext()) {\n            Element next = it.next();\n            if (StringUtil.in(next.nodeName(), nodeNames) || next.nodeName().equals(\"html\"))\n                break;\n            else\n                it.remove();\n        }\n    }\n\n    Element aboveOnStack(Element el) {\n        assert onStack(el);\n        Iterator<Element> it = stack.descendingIterator();\n        while (it.hasNext()) {\n            Element next = it.next();\n            if (next == el) {\n                return it.next();\n            }\n        }\n        return null;\n    }\n\n    void insertOnStackAfter(Element after, Element in) {\n        int i = stack.lastIndexOf(after);\n        Validate.isTrue(i != -1);\n        stack.add(i+1, in);\n    }\n\n    void replaceOnStack(Element out, Element in) {\n        replaceInQueue(stack, out, in);\n    }\n\n    private void replaceInQueue(LinkedList<Element> queue, Element out, Element in) {\n        int i = queue.lastIndexOf(out);\n        Validate.isTrue(i != -1);\n        queue.remove(i);\n        queue.add(i, in);\n    }\n\n    void resetInsertionMode() {\n        boolean last = false;\n        Iterator<Element> it = stack.descendingIterator();\n        while (it.hasNext()) {\n            Element node = it.next();\n            if (!it.hasNext()) {\n                last = true;\n                node = contextElement;\n            }\n            String name = node.nodeName();\n            if (\"select\".equals(name)) {\n                transition(HtmlTreeBuilderState.InSelect);\n                break; \n            } else if ((\"td\".equals(name) || \"td\".equals(name) && !last)) {\n                transition(HtmlTreeBuilderState.InCell);\n                break;\n            } else if (\"tr\".equals(name)) {\n                transition(HtmlTreeBuilderState.InRow);\n                break;\n            } else if (\"tbody\".equals(name) || \"thead\".equals(name) || \"tfoot\".equals(name)) {\n                transition(HtmlTreeBuilderState.InTableBody);\n                break;\n            } else if (\"caption\".equals(name)) {\n                transition(HtmlTreeBuilderState.InCaption);\n                break;\n            } else if (\"colgroup\".equals(name)) {\n                transition(HtmlTreeBuilderState.InColumnGroup);\n                break; \n            } else if (\"table\".equals(name)) {\n                transition(HtmlTreeBuilderState.InTable);\n                break;\n            } else if (\"head\".equals(name)) {\n                transition(HtmlTreeBuilderState.InBody);\n                break; \n            } else if (\"body\".equals(name)) {\n                transition(HtmlTreeBuilderState.InBody);\n                break;\n            } else if (\"frameset\".equals(name)) {\n                transition(HtmlTreeBuilderState.InFrameset);\n                break; \n            } else if (\"html\".equals(name)) {\n                transition(HtmlTreeBuilderState.BeforeHead);\n                break; \n            } else if (last) {\n                transition(HtmlTreeBuilderState.InBody);\n                break; \n            }\n        }\n    }\n\n    \n    private boolean inSpecificScope(String targetName, String[] baseTypes, String[] extraTypes) {\n        return inSpecificScope(new String[]{targetName}, baseTypes, extraTypes);\n    }\n\n    private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {\n        Iterator<Element> it = stack.descendingIterator();\n        while (it.hasNext()) {\n            Element el = it.next();\n            String elName = el.nodeName();\n            if (StringUtil.in(elName, targetNames))\n                return true;\n            if (StringUtil.in(elName, baseTypes))\n                return false;\n            if (extraTypes != null && StringUtil.in(elName, extraTypes))\n                return false;\n        }\n        Validate.fail(\"Should not be reachable\");\n        return false;\n    }\n\n    boolean inScope(String[] targetNames) {\n        return inSpecificScope(targetNames, new String[]{\"applet\", \"caption\", \"html\", \"table\", \"td\", \"th\", \"marquee\", \"object\"}, null);\n    }\n\n    boolean inScope(String targetName) {\n        return inScope(targetName, null);\n    }\n\n    boolean inScope(String targetName, String[] extras) {\n        return inSpecificScope(targetName, new String[]{\"applet\", \"caption\", \"html\", \"table\", \"td\", \"th\", \"marquee\", \"object\"}, extras);\n        \n        \n    }\n\n    boolean inListItemScope(String targetName) {\n        return inScope(targetName, new String[]{\"ol\", \"ul\"});\n    }\n\n    boolean inButtonScope(String targetName) {\n        return inScope(targetName, new String[]{\"button\"});\n    }\n\n    boolean inTableScope(String targetName) {\n        return inSpecificScope(targetName, new String[]{\"html\", \"table\"}, null);\n    }\n\n    boolean inSelectScope(String targetName) {\n        Iterator<Element> it = stack.descendingIterator();\n        while (it.hasNext()) {\n            Element el = it.next();\n            String elName = el.nodeName();\n            if (elName.equals(targetName))\n                return true;\n            if (!StringUtil.in(elName, \"optgroup\", \"option\")) \n                return false;\n        }\n        Validate.fail(\"Should not be reachable\");\n        return false;\n    }\n\n    void setHeadElement(Element headElement) {\n        this.headElement = headElement;\n    }\n\n    Element getHeadElement() {\n        return headElement;\n    }\n\n    boolean isFosterInserts() {\n        return fosterInserts;\n    }\n\n    void setFosterInserts(boolean fosterInserts) {\n        this.fosterInserts = fosterInserts;\n    }\n\n    FormElement getFormElement() {\n        return formElement;\n    }\n\n    void setFormElement(FormElement formElement) {\n        this.formElement = formElement;\n    }\n\n    void newPendingTableCharacters() {\n        pendingTableCharacters = new ArrayList<Token.Character>();\n    }\n\n    List<Token.Character> getPendingTableCharacters() {\n        return pendingTableCharacters;\n    }\n\n    void setPendingTableCharacters(List<Token.Character> pendingTableCharacters) {\n        this.pendingTableCharacters = pendingTableCharacters;\n    }\n\n    \n    void generateImpliedEndTags(String excludeTag) {\n        while ((excludeTag != null && !currentElement().nodeName().equals(excludeTag)) &&\n                StringUtil.in(currentElement().nodeName(), \"dd\", \"dt\", \"li\", \"option\", \"optgroup\", \"p\", \"rp\", \"rt\"))\n            pop();\n    }\n\n    void generateImpliedEndTags() {\n        generateImpliedEndTags(null);\n    }\n\n    boolean isSpecial(Element el) {\n        \n        \n        String name = el.nodeName();\n        return StringUtil.in(name, \"address\", \"applet\", \"area\", \"article\", \"aside\", \"base\", \"basefont\", \"bgsound\",\n                \"blockquote\", \"body\", \"br\", \"button\", \"caption\", \"center\", \"col\", \"colgroup\", \"command\", \"dd\",\n                \"details\", \"dir\", \"div\", \"dl\", \"dt\", \"embed\", \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"form\",\n                \"frame\", \"frameset\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"head\", \"header\", \"hgroup\", \"hr\", \"html\",\n                \"iframe\", \"img\", \"input\", \"isindex\", \"li\", \"link\", \"listing\", \"marquee\", \"menu\", \"meta\", \"nav\",\n                \"noembed\", \"noframes\", \"noscript\", \"object\", \"ol\", \"p\", \"param\", \"plaintext\", \"pre\", \"script\",\n                \"section\", \"select\", \"style\", \"summary\", \"table\", \"tbody\", \"td\", \"textarea\", \"tfoot\", \"th\", \"thead\",\n                \"title\", \"tr\", \"ul\", \"wbr\", \"xmp\");\n    }\n\n    \n    void pushActiveFormattingElements(Element in) {\n        int numSeen = 0;\n        Iterator<Element> iter = formattingElements.descendingIterator();\n        while (iter.hasNext()) {\n            Element el =  iter.next();\n            if (el == null) \n                break;\n\n            if (isSameFormattingElement(in, el))\n                numSeen++;\n\n            if (numSeen == 3) {\n                iter.remove();\n                break;\n            }\n        }\n        formattingElements.add(in);\n    }\n\n    private boolean isSameFormattingElement(Element a, Element b) {\n        \n        return a.nodeName().equals(b.nodeName()) &&\n                \n                a.attributes().equals(b.attributes());\n        \n    }\n\n    void reconstructFormattingElements() {\n        int size = formattingElements.size();\n        if (size == 0 || formattingElements.getLast() == null || onStack(formattingElements.getLast()))\n            return;\n\n        Element entry = formattingElements.getLast();\n        int pos = size - 1;\n        boolean skip = false;\n        while (true) {\n            if (pos == 0) { \n                skip = true;\n                break;\n            }\n            entry = formattingElements.get(--pos); \n            if (entry == null || onStack(entry)) \n                break; \n        }\n        while(true) {\n            if (!skip) \n                entry = formattingElements.get(++pos);\n            Validate.notNull(entry); \n\n            \n            skip = false; \n            Element newEl = insert(entry.nodeName()); \n            \n            newEl.attributes().addAll(entry.attributes());\n\n            \n            formattingElements.add(pos, newEl);\n            formattingElements.remove(pos + 1);\n\n            \n            if (pos == size-1) \n                break;\n        }\n    }\n\n    void clearFormattingElementsToLastMarker() {\n        while (!formattingElements.isEmpty()) {\n            Element el = formattingElements.peekLast();\n            formattingElements.removeLast();\n            if (el == null)\n                break;\n        }\n    }\n\n    void removeFromActiveFormattingElements(Element el) {\n        Iterator<Element> it = formattingElements.descendingIterator();\n        while (it.hasNext()) {\n            Element next = it.next();\n            if (next == el) {\n                it.remove();\n                break;\n            }\n        }\n    }\n\n    boolean isInActiveFormattingElements(Element el) {\n        return isElementInQueue(formattingElements, el);\n    }\n\n    Element getActiveFormattingElement(String nodeName) {\n        Iterator<Element> it = formattingElements.descendingIterator();\n        while (it.hasNext()) {\n            Element next = it.next();\n            if (next == null) \n                break;\n            else if (next.nodeName().equals(nodeName))\n                return next;\n        }\n        return null;\n    }\n\n    void replaceActiveFormattingElement(Element out, Element in) {\n        replaceInQueue(formattingElements, out, in);\n    }\n\n    void insertMarkerToFormattingElements() {\n        formattingElements.add(null);\n    }\n\n    void insertInFosterParent(Node in) {\n        Element fosterParent = null;\n        Element lastTable = getFromStack(\"table\");\n        boolean isLastTableParent = false;\n        if (lastTable != null) {\n            if (lastTable.parent() != null) {\n                fosterParent = lastTable.parent();\n                isLastTableParent = true;\n            } else\n                fosterParent = aboveOnStack(lastTable);\n        } else { \n            fosterParent = stack.get(0);\n        }\n\n        if (isLastTableParent) {\n            Validate.notNull(lastTable); \n            lastTable.before(in);\n        }\n        else\n            fosterParent.appendChild(in);\n    }\n\n    @Override\n    public String toString() {\n        return \"TreeBuilder{\" +\n                \"currentToken=\" + currentToken +\n                \", state=\" + state +\n                \", currentElement=\" + currentElement() +\n                '}';\n    }\n}\n",
      "buggy_signatures": [
        "protected boolean process(Token token)",
        "private void insertNode(Node node)",
        "private boolean isElementInQueue(DescendableLinkedList<Element> queue, Element element)",
        "private void clearStackToContext(String... nodeNames)",
        "private void replaceInQueue(LinkedList<Element> queue, Element out, Element in)",
        "private boolean inSpecificScope(String targetName, String[] baseTypes, String[] extraTypes)",
        "private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes)",
        "private boolean isSameFormattingElement(Element a, Element b)",
        "public String toString()"
      ],
      "fixed_signatures": [
        "protected boolean process(Token token)",
        "private void insertNode(Node node)",
        "private boolean isElementInQueue(DescendableLinkedList<Element> queue, Element element)",
        "private void clearStackToContext(String... nodeNames)",
        "private void replaceInQueue(LinkedList<Element> queue, Element out, Element in)",
        "private boolean inSpecificScope(String targetName, String[] baseTypes, String[] extraTypes)",
        "private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes)",
        "private boolean isSameFormattingElement(Element a, Element b)",
        "public String toString()"
      ],
      "methods": [
        {
          "buggy_method": "  protected boolean process(Token token) {\n  currentToken = token;\n  return this.state.process(token, this);\n  }",
          "fixed_method": "  protected boolean process(Token token) {\n  currentToken = token;\n  return this.state.process(token, this);\n  }",
          "diff": [
            "@@ -159,6 +159,7 @@",
            "         if (startTag.isSelfClosing()) {\n",
            "             Element el = insertEmpty(startTag);\n",
            "             stack.add(el);\n",
            "+            tokeniser.transition(TokeniserState.Data); // handles <script />, otherwise needs breakout steps from script data\n",
            "             tokeniser.emit(new Token.EndTag(el.tagName()));  // ensure we get out of whatever state we are in. emitted for yielded processing\n",
            "             return el;\n",
            "         }\n"
          ],
          "changed_lines": 1
        }
      ]
    }
  ]
}
