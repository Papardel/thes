{
  "bug_id": "41",
  "failed_tests": {
    "org.apache.commons.lang.ClassUtilsTest": [
      {
        "methodName": "test_getShortClassName_Class",
        "error": "junit.framework.ComparisonFailure",
        "message": "expected:<String[[]]> but was:<String[;]>",
        "fail_line": "        assertEquals(\"String[]\", ClassUtils.getShortClassName(String[].class));",
        "test_source": "  public void test_getShortClassName_Class() {\n  assertEquals(\"ClassUtils\", ClassUtils.getShortClassName(ClassUtils.class));\n  assertEquals(\"Map.Entry\", ClassUtils.getShortClassName(Map.Entry.class));\n  assertEquals(\"\", ClassUtils.getShortClassName((Class) null));\n\n  // LANG-535\n  assertEquals(\"String[]\", ClassUtils.getShortClassName(String[].class));\n  assertEquals(\"Map.Entry[]\", ClassUtils.getShortClassName(Map.Entry[].class));\n\n  // Primitives\n  assertEquals(\"boolean\", ClassUtils.getShortClassName(boolean.class));\n  assertEquals(\"byte\", ClassUtils.getShortClassName(byte.class));\n  assertEquals(\"char\", ClassUtils.getShortClassName(char.class));\n  assertEquals(\"short\", ClassUtils.getShortClassName(short.class));\n  assertEquals(\"int\", ClassUtils.getShortClassName(int.class));\n  assertEquals(\"long\", ClassUtils.getShortClassName(long.class));\n  assertEquals(\"float\", ClassUtils.getShortClassName(float.class));\n  assertEquals(\"double\", ClassUtils.getShortClassName(double.class));\n\n  // Primitive Arrays\n  assertEquals(\"boolean[]\", ClassUtils.getShortClassName(boolean[].class));\n  assertEquals(\"byte[]\", ClassUtils.getShortClassName(byte[].class));\n  assertEquals(\"char[]\", ClassUtils.getShortClassName(char[].class));\n  assertEquals(\"short[]\", ClassUtils.getShortClassName(short[].class));\n  assertEquals(\"int[]\", ClassUtils.getShortClassName(int[].class));\n  assertEquals(\"long[]\", ClassUtils.getShortClassName(long[].class));\n  assertEquals(\"float[]\", ClassUtils.getShortClassName(float[].class));\n  assertEquals(\"double[]\", ClassUtils.getShortClassName(double[].class));\n\n  // Arrays of arrays of ...\n  assertEquals(\"String[][]\", ClassUtils.getShortClassName(String[][].class));\n  assertEquals(\"String[][][]\", ClassUtils.getShortClassName(String[][][].class));\n  assertEquals(\"String[][][][]\", ClassUtils.getShortClassName(String[][][][].class));\n  }",
        "stack": [
          "ClassUtilsTest.test_getShortClassName_Class line 97"
        ]
      },
      {
        "methodName": "test_getPackageName_Class",
        "error": "junit.framework.ComparisonFailure",
        "message": "expected:<[]java.lang> but was:<[[L]java.lang>",
        "fail_line": "        assertEquals(\"java.lang\", ClassUtils.getPackageName(String[].class));",
        "test_source": "  public void test_getPackageName_Class() {\n  assertEquals(\"java.lang\", ClassUtils.getPackageName(String.class));\n  assertEquals(\"java.util\", ClassUtils.getPackageName(Map.Entry.class));\n  assertEquals(\"\", ClassUtils.getPackageName((Class)null));\n\n  // LANG-535\n  assertEquals(\"java.lang\", ClassUtils.getPackageName(String[].class));\n\n  // Primitive Arrays\n  assertEquals(\"\", ClassUtils.getPackageName(boolean[].class));\n  assertEquals(\"\", ClassUtils.getPackageName(byte[].class));\n  assertEquals(\"\", ClassUtils.getPackageName(char[].class));\n  assertEquals(\"\", ClassUtils.getPackageName(short[].class));\n  assertEquals(\"\", ClassUtils.getPackageName(int[].class));\n  assertEquals(\"\", ClassUtils.getPackageName(long[].class));\n  assertEquals(\"\", ClassUtils.getPackageName(float[].class));\n  assertEquals(\"\", ClassUtils.getPackageName(double[].class));\n\n  // Arrays of arrays of ...\n  assertEquals(\"java.lang\", ClassUtils.getPackageName(String[][].class));\n  assertEquals(\"java.lang\", ClassUtils.getPackageName(String[][][].class));\n  assertEquals(\"java.lang\", ClassUtils.getPackageName(String[][][][].class));\n  }",
        "stack": [
          "ClassUtilsTest.test_getPackageName_Class line 146"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/lang/ClassUtils.java",
      "buggy_full_code": "\npackage org.apache.commons.lang;\n\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\n\n\n\npublic class ClassUtils { public static final char PACKAGE_SEPARATOR_CHAR = '.'; public static final String PACKAGE_SEPARATOR = String.valueOf(PACKAGE_SEPARATOR_CHAR); public static final char INNER_CLASS_SEPARATOR_CHAR = '$'; public static final String INNER_CLASS_SEPARATOR = String.valueOf(INNER_CLASS_SEPARATOR_CHAR); private static final Map<Class<?>, Class<?>> primitiveWrapperMap = new HashMap<Class<?>, Class<?>>(); static {\n         primitiveWrapperMap.put(Boolean.TYPE, Boolean.class);\n         primitiveWrapperMap.put(Byte.TYPE, Byte.class);\n         primitiveWrapperMap.put(Character.TYPE, Character.class);\n         primitiveWrapperMap.put(Short.TYPE, Short.class);\n         primitiveWrapperMap.put(Integer.TYPE, Integer.class);\n         primitiveWrapperMap.put(Long.TYPE, Long.class);\n         primitiveWrapperMap.put(Double.TYPE, Double.class);\n         primitiveWrapperMap.put(Float.TYPE, Float.class);\n         primitiveWrapperMap.put(Void.TYPE, Void.TYPE);\n    }\n\n    \n    private static final Map<Class<?>, Class<?>> wrapperPrimitiveMap = new HashMap<Class<?>, Class<?>>(); static {\n        for (Class<?> primitiveClass : primitiveWrapperMap.keySet()) {\n            Class<?> wrapperClass = primitiveWrapperMap.get(primitiveClass);\n            if (!primitiveClass.equals(wrapperClass)) {\n                wrapperPrimitiveMap.put(wrapperClass, primitiveClass);\n            }\n        }\n    }\n\n    \n    private static final Map<String, String> abbreviationMap = new HashMap<String, String>(); private static final Map<String, String> reverseAbbreviationMap = new HashMap<String, String>(); private static void addAbbreviation(String primitive, String abbreviation) {\n        abbreviationMap.put(primitive, abbreviation);\n        reverseAbbreviationMap.put(abbreviation, primitive);\n    }\n\n    \n    static { addAbbreviation(\"int\", \"I\"); addAbbreviation(\"boolean\", \"Z\"); addAbbreviation(\"float\", \"F\"); addAbbreviation(\"long\", \"J\"); addAbbreviation(\"short\", \"S\"); addAbbreviation(\"byte\", \"B\"); addAbbreviation(\"double\", \"D\"); addAbbreviation(\"char\", \"C\"); } public ClassUtils() {\n      super();\n    }\n\n    \n    \n    \n    public static String getShortClassName(Object object, String valueIfNull) {\n        if (object == null) {\n            return valueIfNull;\n        }\n        return getShortClassName(object.getClass());\n    }\n\n    \n    public static String getShortClassName(Class<?> cls) {\n        if (cls == null) {\n            return StringUtils.EMPTY;\n        }\n        return getShortClassName(cls.getName());\n    }\n\n    \n    public static String getShortClassName(String className) {\n        if (className == null) {\n            return StringUtils.EMPTY;\n        }\n        if (className.length() == 0) {\n            return StringUtils.EMPTY;\n        }\n\n\n        \n            \n\n\n        int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);\n        int innerIdx = className.indexOf(\n                INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1 ? 0 : lastDotIdx + 1);\n        String out = className.substring(lastDotIdx + 1);\n        if (innerIdx != -1) {\n            out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);\n        }\n        return out;\n    }\n\n    \n    \n    \n    public static String getPackageName(Object object, String valueIfNull) {\n        if (object == null) {\n            return valueIfNull;\n        }\n        return getPackageName(object.getClass());\n    }\n\n    \n    public static String getPackageName(Class<?> cls) {\n        if (cls == null) {\n            return StringUtils.EMPTY;\n        }\n        return getPackageName(cls.getName());\n    }\n\n    \n    public static String getPackageName(String className) {\n        if (className == null) {\n            return StringUtils.EMPTY;\n        }\n\n        \n        \n\n        int i = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);\n        if (i == -1) {\n            return StringUtils.EMPTY;\n        }\n        return className.substring(0, i);\n    }\n\n    \n    \n    \n    public static List<Class<?>> getAllSuperclasses(Class<?> cls) {\n        if (cls == null) {\n            return null;\n        }\n        List<Class<?>> classes = new ArrayList<Class<?>>();\n        Class<?> superclass = cls.getSuperclass();\n        while (superclass != null) {\n            classes.add(superclass);\n            superclass = superclass.getSuperclass();\n        }\n        return classes;\n    }\n\n    \n    public static List<Class<?>> getAllInterfaces(Class<?> cls) {\n        if (cls == null) {\n            return null;\n        }\n\n        LinkedHashSet<Class<?>> interfacesFound = new LinkedHashSet<Class<?>>();\n        getAllInterfaces(cls, interfacesFound);\n\n        return new ArrayList<Class<?>>(interfacesFound);\n    }\n\n    private static void getAllInterfaces(Class<?> cls, HashSet<Class<?>> interfacesFound) {\n        while (cls != null) {\n            Class<?>[] interfaces = cls.getInterfaces();\n\n            for (Class<?> i : interfaces) {\n                if (interfacesFound.add(i)) {\n                    getAllInterfaces(i, interfacesFound);\n                }\n            }\n\n            cls = cls.getSuperclass();\n         }\n     }\n\n    \n    \n    \n    public static List<Class<?>> convertClassNamesToClasses(List<String> classNames) {\n        if (classNames == null) {\n            return null;\n        }\n        List<Class<?>> classes = new ArrayList<Class<?>>(classNames.size());\n        for (String className : classNames) {\n            try {\n                classes.add(Class.forName(className));\n            } catch (Exception ex) {\n                classes.add(null);\n            }\n        }\n        return classes;\n    }\n\n    \n    public static List<String> convertClassesToClassNames(List<Class<?>> classes) {\n        if (classes == null) {\n            return null;\n        }\n        List<String> classNames = new ArrayList<String>(classes.size());\n        for (Class<?> cls : classes) {\n            if (cls == null) {\n                classNames.add(null);\n            } else {\n                classNames.add(cls.getName());\n            }\n        }\n        return classNames;\n    }\n\n    \n    \n    \n    \n    public static boolean isAssignable(Class<?>[] classArray, Class<?>[] toClassArray) {\n        return isAssignable(classArray, toClassArray, false);\n    }\n\n    \n    public static boolean isAssignable(Class<?>[] classArray, Class<?>[] toClassArray, boolean autoboxing) {\n        if (ArrayUtils.isSameLength(classArray, toClassArray) == false) {\n            return false;\n        }\n        if (classArray == null) {\n            classArray = ArrayUtils.EMPTY_CLASS_ARRAY;\n        }\n        if (toClassArray == null) {\n            toClassArray = ArrayUtils.EMPTY_CLASS_ARRAY;\n        }\n        for (int i = 0; i < classArray.length; i++) {\n            if (isAssignable(classArray[i], toClassArray[i], autoboxing) == false) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    \n    public static boolean isAssignable(Class<?> cls, Class<?> toClass) {\n        return isAssignable(cls, toClass, false);\n    }\n\n    \n    public static boolean isAssignable(Class<?> cls, Class<?> toClass, boolean autoboxing) {\n        if (toClass == null) {\n            return false;\n        }\n        \n        if (cls == null) {\n            return !(toClass.isPrimitive());\n        }\n        \n        if (autoboxing) {\n            if (cls.isPrimitive() && !toClass.isPrimitive()) {\n                cls = primitiveToWrapper(cls);\n                if (cls == null) {\n                    return false;\n                }\n            }\n            if (toClass.isPrimitive() && !cls.isPrimitive()) {\n                cls = wrapperToPrimitive(cls);\n                if (cls == null) {\n                    return false;\n                }\n            }\n        }\n        if (cls.equals(toClass)) {\n            return true;\n        }\n        if (cls.isPrimitive()) {\n            if (toClass.isPrimitive() == false) {\n                return false;\n            }\n            if (Integer.TYPE.equals(cls)) {\n                return Long.TYPE.equals(toClass)\n                    || Float.TYPE.equals(toClass)\n                    || Double.TYPE.equals(toClass);\n            }\n            if (Long.TYPE.equals(cls)) {\n                return Float.TYPE.equals(toClass)\n                    || Double.TYPE.equals(toClass);\n            }\n            if (Boolean.TYPE.equals(cls)) {\n                return false;\n            }\n            if (Double.TYPE.equals(cls)) {\n                return false;\n            }\n            if (Float.TYPE.equals(cls)) {\n                return Double.TYPE.equals(toClass);\n            }\n            if (Character.TYPE.equals(cls)) {\n                return Integer.TYPE.equals(toClass)\n                    || Long.TYPE.equals(toClass)\n                    || Float.TYPE.equals(toClass)\n                    || Double.TYPE.equals(toClass);\n            }\n            if (Short.TYPE.equals(cls)) {\n                return Integer.TYPE.equals(toClass)\n                    || Long.TYPE.equals(toClass)\n                    || Float.TYPE.equals(toClass)\n                    || Double.TYPE.equals(toClass);\n            }\n            if (Byte.TYPE.equals(cls)) {\n                return Short.TYPE.equals(toClass)\n                    || Integer.TYPE.equals(toClass)\n                    || Long.TYPE.equals(toClass)\n                    || Float.TYPE.equals(toClass)\n                    || Double.TYPE.equals(toClass);\n            }\n            \n            return false;\n        }\n        return toClass.isAssignableFrom(cls);\n    }\n\n    \n    public static Class<?> primitiveToWrapper(Class<?> cls) {\n        Class<?> convertedClass = cls;\n        if (cls != null && cls.isPrimitive()) {\n            convertedClass = primitiveWrapperMap.get(cls);\n        }\n        return convertedClass;\n    }\n\n    \n    public static Class<?>[] primitivesToWrappers(Class<?>[] classes) {\n        if (classes == null) {\n            return null;\n        }\n\n        if (classes.length == 0) {\n            return classes;\n        }\n\n        Class<?>[] convertedClasses = new Class[classes.length];\n        for (int i = 0; i < classes.length; i++) {\n            convertedClasses[i] = primitiveToWrapper(classes[i]);\n        }\n        return convertedClasses;\n    }\n\n    \n    public static Class<?> wrapperToPrimitive(Class<?> cls) {\n        return wrapperPrimitiveMap.get(cls);\n    }\n\n    \n    public static Class<?>[] wrappersToPrimitives(Class<?>[] classes) {\n        if (classes == null) {\n            return null;\n        }\n\n        if (classes.length == 0) {\n            return classes;\n        }\n\n        Class<?>[] convertedClasses = new Class[classes.length];\n        for (int i = 0; i < classes.length; i++) {\n            convertedClasses[i] = wrapperToPrimitive(classes[i]);\n        }\n        return convertedClasses;\n    }\n\n    \n    \n    \n    public static boolean isInnerClass(Class<?> cls) {\n        if (cls == null) {\n            return false;\n        }\n        return cls.getName().indexOf(INNER_CLASS_SEPARATOR_CHAR) >= 0;\n    }\n\n    \n    \n    \n    public static Class<?> getClass( ClassLoader classLoader, String className, boolean initialize) throws ClassNotFoundException {\n        Class<?> clazz;\n        if (abbreviationMap.containsKey(className)) {\n            String clsName = \"[\" + abbreviationMap.get(className);\n            clazz = Class.forName(clsName, initialize, classLoader).getComponentType();\n        } else {\n            clazz = Class.forName(toCanonicalName(className), initialize, classLoader);\n        }\n        return clazz;\n    }\n\n    \n    public static Class<?> getClass(ClassLoader classLoader, String className) throws ClassNotFoundException {\n        return getClass(classLoader, className, true);\n    }\n\n    \n    public static Class<?> getClass(String className) throws ClassNotFoundException {\n        return getClass(className, true);\n    }\n\n    \n    public static Class<?> getClass(String className, boolean initialize) throws ClassNotFoundException {\n        ClassLoader contextCL = Thread.currentThread().getContextClassLoader();\n        ClassLoader loader = contextCL == null ? ClassUtils.class.getClassLoader() : contextCL;\n        return getClass(loader, className, initialize );\n    }\n\n    \n    \n    \n    public static Method getPublicMethod(Class<?> cls, String methodName, Class<?> parameterTypes[]) throws SecurityException, NoSuchMethodException {\n\n        Method declaredMethod = cls.getMethod(methodName, parameterTypes);\n        if (Modifier.isPublic(declaredMethod.getDeclaringClass().getModifiers())) {\n            return declaredMethod;\n        }\n\n        List<Class<?>> candidateClasses = new ArrayList<Class<?>>();\n        candidateClasses.addAll(getAllInterfaces(cls));\n        candidateClasses.addAll(getAllSuperclasses(cls));\n\n        for (Class<?> candidateClass : candidateClasses) {\n            if (!Modifier.isPublic(candidateClass.getModifiers())) {\n                continue;\n            }\n            Method candidateMethod;\n            try {\n                candidateMethod = candidateClass.getMethod(methodName, parameterTypes);\n            } catch (NoSuchMethodException ex) {\n                continue;\n            }\n            if (Modifier.isPublic(candidateMethod.getDeclaringClass().getModifiers())) {\n                return candidateMethod;\n            }\n        }\n\n        throw new NoSuchMethodException(\"Can't find a public method for \" + methodName + \" \" + ArrayUtils.toString(parameterTypes)); } private static String toCanonicalName(String className) {\n        className = StringUtils.deleteWhitespace(className);\n        if (className == null) {\n            throw new NullPointerException(\"className must not be null.\");\n        } else if (className.endsWith(\"[]\")) {\n            StringBuffer classNameBuffer = new StringBuffer();\n            while (className.endsWith(\"[]\")) {\n                className = className.substring(0, className.length() - 2);\n                classNameBuffer.append(\"[\");\n            }\n            String abbreviation = abbreviationMap.get(className);\n            if (abbreviation != null) {\n                classNameBuffer.append(abbreviation);\n            } else {\n                classNameBuffer.append(\"L\").append(className).append(\";\");\n            }\n            className = classNameBuffer.toString();\n        }\n        return className;\n    }\n\n    \n    public static Class<?>[] toClass(Object[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_CLASS_ARRAY;\n        }\n        Class<?>[] classes = new Class[array.length];\n        for (int i = 0; i < array.length; i++) {\n            classes[i] = array[i].getClass();\n        }\n        return classes;\n    }\n\n    \n    \n    \n    public static String getShortCanonicalName(Object object, String valueIfNull) {\n        if (object == null) {\n            return valueIfNull;\n        }\n        return getShortCanonicalName(object.getClass().getName());\n    }\n\n    \n    public static String getShortCanonicalName(Class<?> cls) {\n        if (cls == null) {\n            return StringUtils.EMPTY;\n        }\n        return getShortCanonicalName(cls.getName());\n    }\n\n    \n    public static String getShortCanonicalName(String canonicalName) {\n        return ClassUtils.getShortClassName(getCanonicalName(canonicalName));\n    }\n\n    \n    \n    \n    public static String getPackageCanonicalName(Object object, String valueIfNull) {\n        if (object == null) {\n            return valueIfNull;\n        }\n        return getPackageCanonicalName(object.getClass().getName());\n    }\n\n    \n    public static String getPackageCanonicalName(Class<?> cls) {\n        if (cls == null) {\n            return StringUtils.EMPTY;\n        }\n        return getPackageCanonicalName(cls.getName());\n    }\n\n    \n    public static String getPackageCanonicalName(String canonicalName) {\n        return ClassUtils.getPackageName(getCanonicalName(canonicalName));\n    }\n\n    \n    private static String getCanonicalName(String className) {\n        className = StringUtils.deleteWhitespace(className);\n        if (className == null) {\n            return null;\n        } else {\n            int dim = 0;\n            while (className.startsWith(\"[\")) {\n                dim++;\n                className = className.substring(1);\n            }\n            if (dim < 1) {\n                return className;\n            } else {\n                if (className.startsWith(\"L\")) {\n                    className = className.substring(\n                        1,\n                        className.endsWith(\";\")\n                            ? className.length() - 1\n                            : className.length());\n                } else {\n                    if (className.length() > 0) {\n                        className = reverseAbbreviationMap.get(className.substring(0, 1));\n                    }\n                }\n                StringBuffer canonicalClassNameBuffer = new StringBuffer(className);\n                for (int i = 0; i < dim; i++) {\n                    canonicalClassNameBuffer.append(\"[]\");\n                }\n                return canonicalClassNameBuffer.toString();\n            }\n        }\n    }\n}\n",
      "fixed_full_code": "\npackage org.apache.commons.lang;\n\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\n\n\n\npublic class ClassUtils { public static final char PACKAGE_SEPARATOR_CHAR = '.'; public static final String PACKAGE_SEPARATOR = String.valueOf(PACKAGE_SEPARATOR_CHAR); public static final char INNER_CLASS_SEPARATOR_CHAR = '$'; public static final String INNER_CLASS_SEPARATOR = String.valueOf(INNER_CLASS_SEPARATOR_CHAR); private static final Map<Class<?>, Class<?>> primitiveWrapperMap = new HashMap<Class<?>, Class<?>>(); static {\n         primitiveWrapperMap.put(Boolean.TYPE, Boolean.class);\n         primitiveWrapperMap.put(Byte.TYPE, Byte.class);\n         primitiveWrapperMap.put(Character.TYPE, Character.class);\n         primitiveWrapperMap.put(Short.TYPE, Short.class);\n         primitiveWrapperMap.put(Integer.TYPE, Integer.class);\n         primitiveWrapperMap.put(Long.TYPE, Long.class);\n         primitiveWrapperMap.put(Double.TYPE, Double.class);\n         primitiveWrapperMap.put(Float.TYPE, Float.class);\n         primitiveWrapperMap.put(Void.TYPE, Void.TYPE);\n    }\n\n    \n    private static final Map<Class<?>, Class<?>> wrapperPrimitiveMap = new HashMap<Class<?>, Class<?>>(); static {\n        for (Class<?> primitiveClass : primitiveWrapperMap.keySet()) {\n            Class<?> wrapperClass = primitiveWrapperMap.get(primitiveClass);\n            if (!primitiveClass.equals(wrapperClass)) {\n                wrapperPrimitiveMap.put(wrapperClass, primitiveClass);\n            }\n        }\n    }\n\n    \n    private static final Map<String, String> abbreviationMap = new HashMap<String, String>(); private static final Map<String, String> reverseAbbreviationMap = new HashMap<String, String>(); private static void addAbbreviation(String primitive, String abbreviation) {\n        abbreviationMap.put(primitive, abbreviation);\n        reverseAbbreviationMap.put(abbreviation, primitive);\n    }\n\n    \n    static { addAbbreviation(\"int\", \"I\"); addAbbreviation(\"boolean\", \"Z\"); addAbbreviation(\"float\", \"F\"); addAbbreviation(\"long\", \"J\"); addAbbreviation(\"short\", \"S\"); addAbbreviation(\"byte\", \"B\"); addAbbreviation(\"double\", \"D\"); addAbbreviation(\"char\", \"C\"); } public ClassUtils() {\n      super();\n    }\n\n    \n    \n    \n    public static String getShortClassName(Object object, String valueIfNull) {\n        if (object == null) {\n            return valueIfNull;\n        }\n        return getShortClassName(object.getClass());\n    }\n\n    \n    public static String getShortClassName(Class<?> cls) {\n        if (cls == null) {\n            return StringUtils.EMPTY;\n        }\n        return getShortClassName(cls.getName());\n    }\n\n    \n    public static String getShortClassName(String className) {\n        if (className == null) {\n            return StringUtils.EMPTY;\n        }\n        if (className.length() == 0) {\n            return StringUtils.EMPTY;\n        }\n\n        StringBuffer arrayPrefix = new StringBuffer();\n\n        \n        if (className.startsWith(\"[\")) {\n            while (className.charAt(0) == '[') {\n                className = className.substring(1);\n                arrayPrefix.append(\"[]\");\n            }\n            \n            if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') {\n                className = className.substring(1, className.length() - 1);\n            }\n        }\n\n        if (reverseAbbreviationMap.containsKey(className)) {\n            className = reverseAbbreviationMap.get(className);\n        }\n\n        int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);\n        int innerIdx = className.indexOf(\n                INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1 ? 0 : lastDotIdx + 1);\n        String out = className.substring(lastDotIdx + 1);\n        if (innerIdx != -1) {\n            out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);\n        }\n        return out + arrayPrefix;\n    }\n\n    \n    \n    \n    public static String getPackageName(Object object, String valueIfNull) {\n        if (object == null) {\n            return valueIfNull;\n        }\n        return getPackageName(object.getClass());\n    }\n\n    \n    public static String getPackageName(Class<?> cls) {\n        if (cls == null) {\n            return StringUtils.EMPTY;\n        }\n        return getPackageName(cls.getName());\n    }\n\n    \n    public static String getPackageName(String className) {\n        if (className == null || className.length() == 0) {\n            return StringUtils.EMPTY;\n        }\n\n        \n        while (className.charAt(0) == '[') {\n            className = className.substring(1);\n        }\n        \n        if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') {\n            className = className.substring(1);\n        }\n\n        int i = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);\n        if (i == -1) {\n            return StringUtils.EMPTY;\n        }\n        return className.substring(0, i);\n    }\n\n    \n    \n    \n    public static List<Class<?>> getAllSuperclasses(Class<?> cls) {\n        if (cls == null) {\n            return null;\n        }\n        List<Class<?>> classes = new ArrayList<Class<?>>();\n        Class<?> superclass = cls.getSuperclass();\n        while (superclass != null) {\n            classes.add(superclass);\n            superclass = superclass.getSuperclass();\n        }\n        return classes;\n    }\n\n    \n    public static List<Class<?>> getAllInterfaces(Class<?> cls) {\n        if (cls == null) {\n            return null;\n        }\n\n        LinkedHashSet<Class<?>> interfacesFound = new LinkedHashSet<Class<?>>();\n        getAllInterfaces(cls, interfacesFound);\n\n        return new ArrayList<Class<?>>(interfacesFound);\n    }\n\n    private static void getAllInterfaces(Class<?> cls, HashSet<Class<?>> interfacesFound) {\n        while (cls != null) {\n            Class<?>[] interfaces = cls.getInterfaces();\n\n            for (Class<?> i : interfaces) {\n                if (interfacesFound.add(i)) {\n                    getAllInterfaces(i, interfacesFound);\n                }\n            }\n\n            cls = cls.getSuperclass();\n         }\n     }\n\n    \n    \n    \n    public static List<Class<?>> convertClassNamesToClasses(List<String> classNames) {\n        if (classNames == null) {\n            return null;\n        }\n        List<Class<?>> classes = new ArrayList<Class<?>>(classNames.size());\n        for (String className : classNames) {\n            try {\n                classes.add(Class.forName(className));\n            } catch (Exception ex) {\n                classes.add(null);\n            }\n        }\n        return classes;\n    }\n\n    \n    public static List<String> convertClassesToClassNames(List<Class<?>> classes) {\n        if (classes == null) {\n            return null;\n        }\n        List<String> classNames = new ArrayList<String>(classes.size());\n        for (Class<?> cls : classes) {\n            if (cls == null) {\n                classNames.add(null);\n            } else {\n                classNames.add(cls.getName());\n            }\n        }\n        return classNames;\n    }\n\n    \n    \n    \n    \n    public static boolean isAssignable(Class<?>[] classArray, Class<?>[] toClassArray) {\n        return isAssignable(classArray, toClassArray, false);\n    }\n\n    \n    public static boolean isAssignable(Class<?>[] classArray, Class<?>[] toClassArray, boolean autoboxing) {\n        if (ArrayUtils.isSameLength(classArray, toClassArray) == false) {\n            return false;\n        }\n        if (classArray == null) {\n            classArray = ArrayUtils.EMPTY_CLASS_ARRAY;\n        }\n        if (toClassArray == null) {\n            toClassArray = ArrayUtils.EMPTY_CLASS_ARRAY;\n        }\n        for (int i = 0; i < classArray.length; i++) {\n            if (isAssignable(classArray[i], toClassArray[i], autoboxing) == false) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    \n    public static boolean isAssignable(Class<?> cls, Class<?> toClass) {\n        return isAssignable(cls, toClass, false);\n    }\n\n    \n    public static boolean isAssignable(Class<?> cls, Class<?> toClass, boolean autoboxing) {\n        if (toClass == null) {\n            return false;\n        }\n        \n        if (cls == null) {\n            return !(toClass.isPrimitive());\n        }\n        \n        if (autoboxing) {\n            if (cls.isPrimitive() && !toClass.isPrimitive()) {\n                cls = primitiveToWrapper(cls);\n                if (cls == null) {\n                    return false;\n                }\n            }\n            if (toClass.isPrimitive() && !cls.isPrimitive()) {\n                cls = wrapperToPrimitive(cls);\n                if (cls == null) {\n                    return false;\n                }\n            }\n        }\n        if (cls.equals(toClass)) {\n            return true;\n        }\n        if (cls.isPrimitive()) {\n            if (toClass.isPrimitive() == false) {\n                return false;\n            }\n            if (Integer.TYPE.equals(cls)) {\n                return Long.TYPE.equals(toClass)\n                    || Float.TYPE.equals(toClass)\n                    || Double.TYPE.equals(toClass);\n            }\n            if (Long.TYPE.equals(cls)) {\n                return Float.TYPE.equals(toClass)\n                    || Double.TYPE.equals(toClass);\n            }\n            if (Boolean.TYPE.equals(cls)) {\n                return false;\n            }\n            if (Double.TYPE.equals(cls)) {\n                return false;\n            }\n            if (Float.TYPE.equals(cls)) {\n                return Double.TYPE.equals(toClass);\n            }\n            if (Character.TYPE.equals(cls)) {\n                return Integer.TYPE.equals(toClass)\n                    || Long.TYPE.equals(toClass)\n                    || Float.TYPE.equals(toClass)\n                    || Double.TYPE.equals(toClass);\n            }\n            if (Short.TYPE.equals(cls)) {\n                return Integer.TYPE.equals(toClass)\n                    || Long.TYPE.equals(toClass)\n                    || Float.TYPE.equals(toClass)\n                    || Double.TYPE.equals(toClass);\n            }\n            if (Byte.TYPE.equals(cls)) {\n                return Short.TYPE.equals(toClass)\n                    || Integer.TYPE.equals(toClass)\n                    || Long.TYPE.equals(toClass)\n                    || Float.TYPE.equals(toClass)\n                    || Double.TYPE.equals(toClass);\n            }\n            \n            return false;\n        }\n        return toClass.isAssignableFrom(cls);\n    }\n\n    \n    public static Class<?> primitiveToWrapper(Class<?> cls) {\n        Class<?> convertedClass = cls;\n        if (cls != null && cls.isPrimitive()) {\n            convertedClass = primitiveWrapperMap.get(cls);\n        }\n        return convertedClass;\n    }\n\n    \n    public static Class<?>[] primitivesToWrappers(Class<?>[] classes) {\n        if (classes == null) {\n            return null;\n        }\n\n        if (classes.length == 0) {\n            return classes;\n        }\n\n        Class<?>[] convertedClasses = new Class[classes.length];\n        for (int i = 0; i < classes.length; i++) {\n            convertedClasses[i] = primitiveToWrapper(classes[i]);\n        }\n        return convertedClasses;\n    }\n\n    \n    public static Class<?> wrapperToPrimitive(Class<?> cls) {\n        return wrapperPrimitiveMap.get(cls);\n    }\n\n    \n    public static Class<?>[] wrappersToPrimitives(Class<?>[] classes) {\n        if (classes == null) {\n            return null;\n        }\n\n        if (classes.length == 0) {\n            return classes;\n        }\n\n        Class<?>[] convertedClasses = new Class[classes.length];\n        for (int i = 0; i < classes.length; i++) {\n            convertedClasses[i] = wrapperToPrimitive(classes[i]);\n        }\n        return convertedClasses;\n    }\n\n    \n    \n    \n    public static boolean isInnerClass(Class<?> cls) {\n        if (cls == null) {\n            return false;\n        }\n        return cls.getName().indexOf(INNER_CLASS_SEPARATOR_CHAR) >= 0;\n    }\n\n    \n    \n    \n    public static Class<?> getClass( ClassLoader classLoader, String className, boolean initialize) throws ClassNotFoundException {\n        Class<?> clazz;\n        if (abbreviationMap.containsKey(className)) {\n            String clsName = \"[\" + abbreviationMap.get(className);\n            clazz = Class.forName(clsName, initialize, classLoader).getComponentType();\n        } else {\n            clazz = Class.forName(toCanonicalName(className), initialize, classLoader);\n        }\n        return clazz;\n    }\n\n    \n    public static Class<?> getClass(ClassLoader classLoader, String className) throws ClassNotFoundException {\n        return getClass(classLoader, className, true);\n    }\n\n    \n    public static Class<?> getClass(String className) throws ClassNotFoundException {\n        return getClass(className, true);\n    }\n\n    \n    public static Class<?> getClass(String className, boolean initialize) throws ClassNotFoundException {\n        ClassLoader contextCL = Thread.currentThread().getContextClassLoader();\n        ClassLoader loader = contextCL == null ? ClassUtils.class.getClassLoader() : contextCL;\n        return getClass(loader, className, initialize );\n    }\n\n    \n    \n    \n    public static Method getPublicMethod(Class<?> cls, String methodName, Class<?> parameterTypes[]) throws SecurityException, NoSuchMethodException {\n\n        Method declaredMethod = cls.getMethod(methodName, parameterTypes);\n        if (Modifier.isPublic(declaredMethod.getDeclaringClass().getModifiers())) {\n            return declaredMethod;\n        }\n\n        List<Class<?>> candidateClasses = new ArrayList<Class<?>>();\n        candidateClasses.addAll(getAllInterfaces(cls));\n        candidateClasses.addAll(getAllSuperclasses(cls));\n\n        for (Class<?> candidateClass : candidateClasses) {\n            if (!Modifier.isPublic(candidateClass.getModifiers())) {\n                continue;\n            }\n            Method candidateMethod;\n            try {\n                candidateMethod = candidateClass.getMethod(methodName, parameterTypes);\n            } catch (NoSuchMethodException ex) {\n                continue;\n            }\n            if (Modifier.isPublic(candidateMethod.getDeclaringClass().getModifiers())) {\n                return candidateMethod;\n            }\n        }\n\n        throw new NoSuchMethodException(\"Can't find a public method for \" + methodName + \" \" + ArrayUtils.toString(parameterTypes)); } private static String toCanonicalName(String className) {\n        className = StringUtils.deleteWhitespace(className);\n        if (className == null) {\n            throw new NullPointerException(\"className must not be null.\");\n        } else if (className.endsWith(\"[]\")) {\n            StringBuffer classNameBuffer = new StringBuffer();\n            while (className.endsWith(\"[]\")) {\n                className = className.substring(0, className.length() - 2);\n                classNameBuffer.append(\"[\");\n            }\n            String abbreviation = abbreviationMap.get(className);\n            if (abbreviation != null) {\n                classNameBuffer.append(abbreviation);\n            } else {\n                classNameBuffer.append(\"L\").append(className).append(\";\");\n            }\n            className = classNameBuffer.toString();\n        }\n        return className;\n    }\n\n    \n    public static Class<?>[] toClass(Object[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_CLASS_ARRAY;\n        }\n        Class<?>[] classes = new Class[array.length];\n        for (int i = 0; i < array.length; i++) {\n            classes[i] = array[i].getClass();\n        }\n        return classes;\n    }\n\n    \n    \n    \n    public static String getShortCanonicalName(Object object, String valueIfNull) {\n        if (object == null) {\n            return valueIfNull;\n        }\n        return getShortCanonicalName(object.getClass().getName());\n    }\n\n    \n    public static String getShortCanonicalName(Class<?> cls) {\n        if (cls == null) {\n            return StringUtils.EMPTY;\n        }\n        return getShortCanonicalName(cls.getName());\n    }\n\n    \n    public static String getShortCanonicalName(String canonicalName) {\n        return ClassUtils.getShortClassName(getCanonicalName(canonicalName));\n    }\n\n    \n    \n    \n    public static String getPackageCanonicalName(Object object, String valueIfNull) {\n        if (object == null) {\n            return valueIfNull;\n        }\n        return getPackageCanonicalName(object.getClass().getName());\n    }\n\n    \n    public static String getPackageCanonicalName(Class<?> cls) {\n        if (cls == null) {\n            return StringUtils.EMPTY;\n        }\n        return getPackageCanonicalName(cls.getName());\n    }\n\n    \n    public static String getPackageCanonicalName(String canonicalName) {\n        return ClassUtils.getPackageName(getCanonicalName(canonicalName));\n    }\n\n    \n    private static String getCanonicalName(String className) {\n        className = StringUtils.deleteWhitespace(className);\n        if (className == null) {\n            return null;\n        } else {\n            int dim = 0;\n            while (className.startsWith(\"[\")) {\n                dim++;\n                className = className.substring(1);\n            }\n            if (dim < 1) {\n                return className;\n            } else {\n                if (className.startsWith(\"L\")) {\n                    className = className.substring(\n                        1,\n                        className.endsWith(\";\")\n                            ? className.length() - 1\n                            : className.length());\n                } else {\n                    if (className.length() > 0) {\n                        className = reverseAbbreviationMap.get(className.substring(0, 1));\n                    }\n                }\n                StringBuffer canonicalClassNameBuffer = new StringBuffer(className);\n                for (int i = 0; i < dim; i++) {\n                    canonicalClassNameBuffer.append(\"[]\");\n                }\n                return canonicalClassNameBuffer.toString();\n            }\n        }\n    }\n}\n",
      "buggy_signatures": [
        "static { addAbbreviation(\"int\", \"I\"); addAbbreviation(\"boolean\", \"Z\"); addAbbreviation(\"float\", \"F\"); addAbbreviation(\"long\", \"J\"); addAbbreviation(\"short\", \"S\"); addAbbreviation(\"byte\", \"B\"); addAbbreviation(\"double\", \"D\"); addAbbreviation(\"char\", \"C\"); } public ClassUtils()",
        "public static String getShortClassName(Object object, String valueIfNull)",
        "public static String getShortClassName(Class<?> cls)",
        "public static String getShortClassName(String className)",
        "public static String getPackageName(Object object, String valueIfNull)",
        "public static String getPackageName(Class<?> cls)",
        "public static String getPackageName(String className)",
        "public static List<Class<?>> getAllSuperclasses(Class<?> cls)",
        "public static List<Class<?>> getAllInterfaces(Class<?> cls)",
        "private static void getAllInterfaces(Class<?> cls, HashSet<Class<?>> interfacesFound)",
        "public static List<Class<?>> convertClassNamesToClasses(List<String> classNames)",
        "public static List<String> convertClassesToClassNames(List<Class<?>> classes)",
        "public static boolean isAssignable(Class<?>[] classArray, Class<?>[] toClassArray)",
        "public static boolean isAssignable(Class<?>[] classArray, Class<?>[] toClassArray, boolean autoboxing)",
        "public static boolean isAssignable(Class<?> cls, Class<?> toClass)",
        "public static boolean isAssignable(Class<?> cls, Class<?> toClass, boolean autoboxing)",
        "public static Class<?> primitiveToWrapper(Class<?> cls)",
        "public static Class<?>[] primitivesToWrappers(Class<?>[] classes)",
        "public static Class<?> wrapperToPrimitive(Class<?> cls)",
        "public static Class<?>[] wrappersToPrimitives(Class<?>[] classes)",
        "public static boolean isInnerClass(Class<?> cls)",
        "public static Class<?> getClass( ClassLoader classLoader, String className, boolean initialize) throws ClassNotFoundException",
        "public static Class<?> getClass(ClassLoader classLoader, String className) throws ClassNotFoundException",
        "public static Class<?> getClass(String className) throws ClassNotFoundException",
        "public static Class<?> getClass(String className, boolean initialize) throws ClassNotFoundException",
        "public static Method getPublicMethod(Class<?> cls, String methodName, Class<?> parameterTypes[]) throws SecurityException, NoSuchMethodException",
        "public method for \" + methodName + \" \" + ArrayUtils.toString(parameterTypes)); } private static String toCanonicalName(String className)",
        "public static Class<?>[] toClass(Object[] array)",
        "public static String getShortCanonicalName(Object object, String valueIfNull)",
        "public static String getShortCanonicalName(Class<?> cls)",
        "public static String getShortCanonicalName(String canonicalName)",
        "public static String getPackageCanonicalName(Object object, String valueIfNull)",
        "public static String getPackageCanonicalName(Class<?> cls)",
        "public static String getPackageCanonicalName(String canonicalName)",
        "private static String getCanonicalName(String className)"
      ],
      "fixed_signatures": [
        "static { addAbbreviation(\"int\", \"I\"); addAbbreviation(\"boolean\", \"Z\"); addAbbreviation(\"float\", \"F\"); addAbbreviation(\"long\", \"J\"); addAbbreviation(\"short\", \"S\"); addAbbreviation(\"byte\", \"B\"); addAbbreviation(\"double\", \"D\"); addAbbreviation(\"char\", \"C\"); } public ClassUtils()",
        "public static String getShortClassName(Object object, String valueIfNull)",
        "public static String getShortClassName(Class<?> cls)",
        "public static String getShortClassName(String className)",
        "public static String getPackageName(Object object, String valueIfNull)",
        "public static String getPackageName(Class<?> cls)",
        "public static String getPackageName(String className)",
        "public static List<Class<?>> getAllSuperclasses(Class<?> cls)",
        "public static List<Class<?>> getAllInterfaces(Class<?> cls)",
        "private static void getAllInterfaces(Class<?> cls, HashSet<Class<?>> interfacesFound)",
        "public static List<Class<?>> convertClassNamesToClasses(List<String> classNames)",
        "public static List<String> convertClassesToClassNames(List<Class<?>> classes)",
        "public static boolean isAssignable(Class<?>[] classArray, Class<?>[] toClassArray)",
        "public static boolean isAssignable(Class<?>[] classArray, Class<?>[] toClassArray, boolean autoboxing)",
        "public static boolean isAssignable(Class<?> cls, Class<?> toClass)",
        "public static boolean isAssignable(Class<?> cls, Class<?> toClass, boolean autoboxing)",
        "public static Class<?> primitiveToWrapper(Class<?> cls)",
        "public static Class<?>[] primitivesToWrappers(Class<?>[] classes)",
        "public static Class<?> wrapperToPrimitive(Class<?> cls)",
        "public static Class<?>[] wrappersToPrimitives(Class<?>[] classes)",
        "public static boolean isInnerClass(Class<?> cls)",
        "public static Class<?> getClass( ClassLoader classLoader, String className, boolean initialize) throws ClassNotFoundException",
        "public static Class<?> getClass(ClassLoader classLoader, String className) throws ClassNotFoundException",
        "public static Class<?> getClass(String className) throws ClassNotFoundException",
        "public static Class<?> getClass(String className, boolean initialize) throws ClassNotFoundException",
        "public static Method getPublicMethod(Class<?> cls, String methodName, Class<?> parameterTypes[]) throws SecurityException, NoSuchMethodException",
        "public method for \" + methodName + \" \" + ArrayUtils.toString(parameterTypes)); } private static String toCanonicalName(String className)",
        "public static Class<?>[] toClass(Object[] array)",
        "public static String getShortCanonicalName(Object object, String valueIfNull)",
        "public static String getShortCanonicalName(Class<?> cls)",
        "public static String getShortCanonicalName(String canonicalName)",
        "public static String getPackageCanonicalName(Object object, String valueIfNull)",
        "public static String getPackageCanonicalName(Class<?> cls)",
        "public static String getPackageCanonicalName(String canonicalName)",
        "private static String getCanonicalName(String className)"
      ],
      "methods": [
        {
          "buggy_method": "  public static String getShortClassName(String className) {\n  if (className == null) {\n  return StringUtils.EMPTY;\n  }\n  if (className.length() == 0) {\n  return StringUtils.EMPTY;\n  }\n\n\n  \n  \n\n\n  int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);\n  int innerIdx = className.indexOf(\n  INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1 ? 0 : lastDotIdx + 1);\n  String out = className.substring(lastDotIdx + 1);\n  if (innerIdx != -1) {\n  out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);\n  }\n  return out;\n  }",
          "fixed_method": "  public static String getShortClassName(String className) {\n  if (className == null) {\n  return StringUtils.EMPTY;\n  }\n  if (className.length() == 0) {\n  return StringUtils.EMPTY;\n  }\n\n  StringBuffer arrayPrefix = new StringBuffer();\n\n  \n  if (className.startsWith(\"[\")) {\n  while (className.charAt(0) == '[') {\n  className = className.substring(1);\n  arrayPrefix.append(\"[]\");\n  }\n  \n  if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') {\n  className = className.substring(1, className.length() - 1);\n  }\n  }\n\n  if (reverseAbbreviationMap.containsKey(className)) {\n  className = reverseAbbreviationMap.get(className);\n  }\n\n  int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);\n  int innerIdx = className.indexOf(\n  INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1 ? 0 : lastDotIdx + 1);\n  String out = className.substring(lastDotIdx + 1);\n  if (innerIdx != -1) {\n  out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);\n  }\n  return out + arrayPrefix;\n  }",
          "diff": [
            "@@ -188,10 +188,23 @@",
            "             return StringUtils.EMPTY;\n",
            "         }\n",
            " \n",
            "+        StringBuffer arrayPrefix = new StringBuffer();\n",
            " \n",
            "         // Handle array encoding\n",
            "+        if (className.startsWith(\"[\")) {\n",
            "+            while (className.charAt(0) == '[') {\n",
            "+                className = className.substring(1);\n",
            "+                arrayPrefix.append(\"[]\");\n",
            "+            }\n",
            "             // Strip Object type encoding\n",
            "-\n",
            "+            if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') {\n",
            "+                className = className.substring(1, className.length() - 1);\n",
            "+            }\n",
            "+        }\n",
            "+\n",
            "+        if (reverseAbbreviationMap.containsKey(className)) {\n",
            "+            className = reverseAbbreviationMap.get(className);\n",
            "+        }\n",
            " \n",
            "         int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);\n",
            "         int innerIdx = className.indexOf(\n",
            "@@ -200,7 +213,7 @@",
            "         if (innerIdx != -1) {\n",
            "             out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);\n",
            "         }\n",
            "-        return out;\n",
            "+        return out + arrayPrefix;\n",
            "     }\n",
            " \n",
            "     // Package name\n"
          ],
          "changed_lines": 17
        },
        {
          "buggy_method": "  public static String getPackageName(String className) {\n  if (className == null) {\n  return StringUtils.EMPTY;\n  }\n\n  \n  \n\n  int i = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);\n  if (i == -1) {\n  return StringUtils.EMPTY;\n  }\n  return className.substring(0, i);\n  }",
          "fixed_method": "  public static String getPackageName(String className) {\n  if (className == null || className.length() == 0) {\n  return StringUtils.EMPTY;\n  }\n\n  \n  while (className.charAt(0) == '[') {\n  className = className.substring(1);\n  }\n  \n  if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') {\n  className = className.substring(1);\n  }\n\n  int i = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);\n  if (i == -1) {\n  return StringUtils.EMPTY;\n  }\n  return className.substring(0, i);\n  }",
          "diff": [
            "@@ -242,12 +255,18 @@",
            "      * @return the package name or an empty string\n",
            "      */\n",
            "     public static String getPackageName(String className) {\n",
            "-        if (className == null) {\n",
            "+        if (className == null || className.length() == 0) {\n",
            "             return StringUtils.EMPTY;\n",
            "         }\n",
            " \n",
            "         // Strip array encoding\n",
            "+        while (className.charAt(0) == '[') {\n",
            "+            className = className.substring(1);\n",
            "+        }\n",
            "         // Strip Object type encoding\n",
            "+        if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') {\n",
            "+            className = className.substring(1);\n",
            "+        }\n",
            " \n",
            "         int i = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);\n",
            "         if (i == -1) {\n"
          ],
          "changed_lines": 8
        }
      ]
    }
  ]
}
