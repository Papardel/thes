{
  "bug_id": "38",
  "failed_tests": {
    "org.apache.commons.math.optimization.direct.BOBYQAOptimizerTest": [
      {
        "methodName": "testConstrainedRosenWithMoreInterpolationPoints",
        "error": "org.apache.commons.math.optimization.direct.BOBYQAOptimizer$PathIsExploredException",
        "message": "If this exception is thrown, just remove it from the code prelim (at line 1752)",
        "fail_line": "            doTest(new Rosen(), startPoint, boundaries,",
        "test_source": "  public void testConstrainedRosenWithMoreInterpolationPoints() {\n  final double[] startPoint = point(DIM, 0.1);\n  final double[][] boundaries = boundaries(DIM, -1, 2);\n  final RealPointValuePair expected = new RealPointValuePair(point(DIM, 1.0), 0.0);\n\n  // This should have been 78 because in the code the hard limit is\n  // said to be\n  //  ((DIM + 1) * (DIM + 2)) / 2 - (2 * DIM + 1)\n  // i.e. 78 in this case, but the test fails for 48, 59, 62, 63, 64,\n  // 65, 66, ...\n  final int maxAdditionalPoints = 47;\n\n  for (int num = 1; num <= maxAdditionalPoints; num++) {\n  doTest(new Rosen(), startPoint, boundaries,\n  GoalType.MINIMIZE,\n  1e-12, 1e-6, 2000,\n  num,\n  expected,\n  \"num=\" + num);\n  }\n  }",
        "stack": [
          "BOBYQAOptimizer.prelim line 1752, BOBYQAOptimizer.bobyqb line 407, BOBYQAOptimizer.bobyqa line 332, BOBYQAOptimizer.doOptimize line 244, BaseAbstractMultivariateOptimizer.optimize line 125, BaseAbstractMultivariateSimpleBoundsOptimizer.optimize line 138, BOBYQAOptimizerTest.doTest line 327, BOBYQAOptimizerTest.testConstrainedRosenWithMoreInterpolationPoints line 255"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/math/optimization/direct/BOBYQAOptimizer.java",
      "buggy_full_code": "\n\npackage org.apache.commons.math.optimization.direct;\n\nimport java.util.Arrays;\n\nimport org.apache.commons.math.analysis.MultivariateFunction;\nimport org.apache.commons.math.exception.MathIllegalStateException;\nimport org.apache.commons.math.exception.NumberIsTooSmallException;\nimport org.apache.commons.math.exception.OutOfRangeException;\nimport org.apache.commons.math.exception.util.LocalizedFormats;\nimport org.apache.commons.math.linear.Array2DRowRealMatrix;\nimport org.apache.commons.math.linear.ArrayRealVector;\nimport org.apache.commons.math.linear.RealVector;\nimport org.apache.commons.math.optimization.GoalType;\nimport org.apache.commons.math.optimization.RealPointValuePair;\nimport org.apache.commons.math.optimization.MultivariateOptimizer;\n\n\npublic class BOBYQAOptimizer extends BaseAbstractMultivariateSimpleBoundsOptimizer<MultivariateFunction> implements MultivariateOptimizer { public static final int MINIMUM_PROBLEM_DIMENSION = 2; public static final double DEFAULT_INITIAL_RADIUS = 10.0; public static final double DEFAULT_STOPPING_RADIUS = 1E-8; private static final double ZERO = 0d; private static final double ONE = 1d; private static final double TWO = 2d; private static final double TEN = 10d; private static final double SIXTEEN = 16d; private static final double TWO_HUNDRED_FIFTY = 250d; private static final double MINUS_ONE = -ONE; private static final double HALF = ONE / 2; private static final double ONE_OVER_FOUR = ONE / 4; private static final double ONE_OVER_EIGHT = ONE / 8; private static final double ONE_OVER_TEN = ONE / 10; private static final double ONE_OVER_A_THOUSAND = ONE / 1000; private final int numberOfInterpolationPoints; private double initialTrustRegionRadius; private final double stoppingTrustRegionRadius; private boolean isMinimize; private ArrayRealVector currentBest; private double[] boundDifference; private int trustRegionCenterInterpolationPointIndex; private Array2DRowRealMatrix bMatrix; private Array2DRowRealMatrix zMatrix; private Array2DRowRealMatrix interpolationPoints; private ArrayRealVector originShift; private ArrayRealVector fAtInterpolationPoints; private ArrayRealVector trustRegionCenterOffset; private ArrayRealVector gradientAtTrustRegionCenter; private ArrayRealVector lowerDifference; private ArrayRealVector upperDifference; private ArrayRealVector modelSecondDerivativesParameters; private ArrayRealVector newPoint; private ArrayRealVector alternativeNewPoint; private ArrayRealVector trialStepPoint; private ArrayRealVector lagrangeValuesAtNewPoint; private ArrayRealVector modelSecondDerivativesValues; public BOBYQAOptimizer(int numberOfInterpolationPoints) {\n        this(numberOfInterpolationPoints,\n             DEFAULT_INITIAL_RADIUS,\n             DEFAULT_STOPPING_RADIUS);\n    }\n\n    \n    public BOBYQAOptimizer(int numberOfInterpolationPoints, double initialTrustRegionRadius, double stoppingTrustRegionRadius) {\n        this.numberOfInterpolationPoints = numberOfInterpolationPoints;\n        this.initialTrustRegionRadius = initialTrustRegionRadius;\n        this.stoppingTrustRegionRadius = stoppingTrustRegionRadius;\n    }\n\n    \n    @Override\n    protected RealPointValuePair doOptimize() {\n        final double[] lowerBound = getLowerBound();\n        final double[] upperBound = getUpperBound();\n\n        \n        setup(lowerBound, upperBound);\n\n        isMinimize = (getGoalType() == GoalType.MINIMIZE);\n        currentBest = new ArrayRealVector(getStartPoint());\n\n        final double value = bobyqa(lowerBound, upperBound);\n\n        return new RealPointValuePair(currentBest.getDataRef(),\n                                      isMinimize ? value : -value);\n    }\n\n    \n    private double bobyqa(double[] lowerBound, double[] upperBound) {\n        printMethod(); \n\n        final int n = currentBest.getDimension();\n\n        \n        \n        \n        \n        \n        \n\n        for (int j = 0; j < n; j++) {\n            final double boundDiff = boundDifference[j];\n            lowerDifference.setEntry(j, lowerBound[j] - currentBest.getEntry(j));\n            upperDifference.setEntry(j, upperBound[j] - currentBest.getEntry(j));\n            if (lowerDifference.getEntry(j) >= -initialTrustRegionRadius) {\n                if (lowerDifference.getEntry(j) >= ZERO) {\n                    currentBest.setEntry(j, lowerBound[j]);\n                    lowerDifference.setEntry(j, ZERO);\n                    upperDifference.setEntry(j, boundDiff);\n                } else {\n                    currentBest.setEntry(j, lowerBound[j] + initialTrustRegionRadius);\n                    lowerDifference.setEntry(j, -initialTrustRegionRadius);\n                    \n                    final double deltaOne = upperBound[j] - currentBest.getEntry(j);\n                    upperDifference.setEntry(j, Math.max(deltaOne, initialTrustRegionRadius));\n                }\n            } else if (upperDifference.getEntry(j) <= initialTrustRegionRadius) {\n                if (upperDifference.getEntry(j) <= ZERO) {\n                    currentBest.setEntry(j, upperBound[j]);\n                    lowerDifference.setEntry(j, -boundDiff);\n                    upperDifference.setEntry(j, ZERO);\n                } else {\n                    currentBest.setEntry(j, upperBound[j] - initialTrustRegionRadius);\n                    \n                    final double deltaOne = lowerBound[j] - currentBest.getEntry(j);\n                    final double deltaTwo = -initialTrustRegionRadius;\n                    lowerDifference.setEntry(j, Math.min(deltaOne, deltaTwo));\n                    upperDifference.setEntry(j, initialTrustRegionRadius);\n                }\n            }\n        }\n\n        \n\n        return bobyqb(lowerBound, upperBound);\n    } \n\n    \n\n    \n    private double bobyqb(double[] lowerBound, double[] upperBound) {\n        printMethod(); \n\n        final int n = currentBest.getDimension();\n        final int npt = numberOfInterpolationPoints;\n        final int np = n + 1;\n        final int nptm = npt - np;\n        final int nh = n * np / 2;\n\n        final ArrayRealVector work1 = new ArrayRealVector(n);\n        final ArrayRealVector work2 = new ArrayRealVector(npt);\n        final ArrayRealVector work3 = new ArrayRealVector(npt);\n\n        double cauchy = Double.NaN;\n        double alpha = Double.NaN;\n        double dsq = Double.NaN;\n        double crvmin = Double.NaN;\n\n        \n        \n\n        \n\n        \n        \n        \n        \n        \n        \n\n        trustRegionCenterInterpolationPointIndex = 0;\n\n        prelim(lowerBound, upperBound);\n        double xoptsq = ZERO;\n        for (int i = 0; i < n; i++) {\n            trustRegionCenterOffset.setEntry(i, interpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex, i));\n            \n            final double deltaOne = trustRegionCenterOffset.getEntry(i);\n            xoptsq += deltaOne * deltaOne;\n        }\n        double fsave = fAtInterpolationPoints.getEntry(0);\n        final int kbase = 0;\n\n        \n\n        int ntrits = 0;\n        int itest = 0;\n        int knew = 0;\n        int nfsav = getEvaluations();\n        double rho = initialTrustRegionRadius;\n        double delta = rho;\n        double diffa = ZERO;\n        double diffb = ZERO;\n        double diffc = ZERO;\n        double f = ZERO;\n        double beta = ZERO;\n        double adelt = ZERO;\n        double denom = ZERO;\n        double ratio = ZERO;\n        double dnorm = ZERO;\n        double scaden = ZERO;\n        double biglsq = ZERO;\n        double distsq = ZERO;\n\n        \n        \n\n        int state = 20;\n        for(;;) switch (state) {\n        case 20: {\n            printState(20); \n            if (trustRegionCenterInterpolationPointIndex != kbase) {\n                int ih = 0;\n                for (int j = 0; j < n; j++) {\n                    for (int i = 0; i <= j; i++) {\n                        if (i < j) {\n                            gradientAtTrustRegionCenter.setEntry(j,  gradientAtTrustRegionCenter.getEntry(j) + modelSecondDerivativesValues.getEntry(ih) * trustRegionCenterOffset.getEntry(i));\n                        }\n                        gradientAtTrustRegionCenter.setEntry(i,  gradientAtTrustRegionCenter.getEntry(i) + modelSecondDerivativesValues.getEntry(ih) * trustRegionCenterOffset.getEntry(j));\n                        ih++;\n                    }\n                }\n                if (getEvaluations() > npt) {\n                    for (int k = 0; k < npt; k++) {\n                        double temp = ZERO;\n                        for (int j = 0; j < n; j++) {\n                            temp += interpolationPoints.getEntry(k, j) * trustRegionCenterOffset.getEntry(j);\n                        }\n                        temp *= modelSecondDerivativesParameters.getEntry(k);\n                        for (int i = 0; i < n; i++) {\n                            gradientAtTrustRegionCenter.setEntry(i, gradientAtTrustRegionCenter.getEntry(i) + temp * interpolationPoints.getEntry(k, i));\n                        }\n                    }\n                    throw new PathIsExploredException(); \n                }\n            }\n\n            \n            \n            \n            \n            \n            \n\n        }\n        case 60: {\n            printState(60); \n            final ArrayRealVector gnew = new ArrayRealVector(n);\n            final ArrayRealVector xbdi = new ArrayRealVector(n);\n            final ArrayRealVector s = new ArrayRealVector(n);\n            final ArrayRealVector hs = new ArrayRealVector(n);\n            final ArrayRealVector hred = new ArrayRealVector(n);\n\n            final double[] dsqCrvmin = trsbox(delta, gnew, xbdi, s,\n                                              hs, hred);\n            dsq = dsqCrvmin[0];\n            crvmin = dsqCrvmin[1];\n\n            \n            double deltaOne = delta;\n            double deltaTwo = Math.sqrt(dsq);\n            dnorm = Math.min(deltaOne, deltaTwo);\n            if (dnorm < HALF * rho) {\n                ntrits = -1;\n                \n                deltaOne = TEN * rho;\n                distsq = deltaOne * deltaOne;\n                if (getEvaluations() <= nfsav + 2) {\n                    state = 650; break;\n                }\n\n                \n                \n                \n                \n                \n\n                \n                deltaOne = Math.max(diffa, diffb);\n                final double errbig = Math.max(deltaOne, diffc);\n                final double frhosq = rho * ONE_OVER_EIGHT * rho;\n                if (crvmin > ZERO &&\n                    errbig > frhosq * crvmin) {\n                    state = 650; break;\n                }\n                final double bdtol = errbig / rho;\n                for (int j = 0; j < n; j++) {\n                    double bdtest = bdtol;\n                    if (newPoint.getEntry(j) == lowerDifference.getEntry(j)) {\n                        bdtest = work1.getEntry(j);\n                    }\n                    if (newPoint.getEntry(j) == upperDifference.getEntry(j)) {\n                        bdtest = -work1.getEntry(j);\n                    }\n                    if (bdtest < bdtol) {\n                        double curv = modelSecondDerivativesValues.getEntry((j + j * j) / 2);\n                        for (int k = 0; k < npt; k++) {\n                            \n                            final double d1 = interpolationPoints.getEntry(k, j);\n                            curv += modelSecondDerivativesParameters.getEntry(k) * (d1 * d1);\n                        }\n                        bdtest += HALF * curv * rho;\n                        if (bdtest < bdtol) {\n                            state = 650; break;\n                        }\n                        throw new PathIsExploredException(); \n                    }\n                }\n                state = 680; break;\n            }\n            ++ntrits;\n\n            \n            \n            \n            \n            \n\n        }\n        case 90: {\n            printState(90); \n            if (dsq <= xoptsq * ONE_OVER_A_THOUSAND) {\n                final double fracsq = xoptsq * ONE_OVER_FOUR;\n                double sumpq = ZERO;\n                \n                \n                for (int k = 0; k < npt; k++) {\n                    sumpq += modelSecondDerivativesParameters.getEntry(k);\n                    double sum = -HALF * xoptsq;\n                    for (int i = 0; i < n; i++) {\n                        sum += interpolationPoints.getEntry(k, i) * trustRegionCenterOffset.getEntry(i);\n                    }\n                    \n                    work2.setEntry(k, sum);\n                    final double temp = fracsq - HALF * sum;\n                    for (int i = 0; i < n; i++) {\n                        work1.setEntry(i, bMatrix.getEntry(k, i));\n                        lagrangeValuesAtNewPoint.setEntry(i, sum * interpolationPoints.getEntry(k, i) + temp * trustRegionCenterOffset.getEntry(i));\n                        final int ip = npt + i;\n                        for (int j = 0; j <= i; j++) {\n                            bMatrix.setEntry(ip, j,\n                                          bMatrix.getEntry(ip, j)\n                                          + work1.getEntry(i) * lagrangeValuesAtNewPoint.getEntry(j)\n                                          + lagrangeValuesAtNewPoint.getEntry(i) * work1.getEntry(j));\n                        }\n                    }\n                }\n\n                \n\n                for (int m = 0; m < nptm; m++) {\n                    double sumz = ZERO;\n                    double sumw = ZERO;\n                    for (int k = 0; k < npt; k++) {\n                        sumz += zMatrix.getEntry(k, m);\n                        lagrangeValuesAtNewPoint.setEntry(k, work2.getEntry(k) * zMatrix.getEntry(k, m));\n                        sumw += lagrangeValuesAtNewPoint.getEntry(k);\n                    }\n                    for (int j = 0; j < n; j++) {\n                        double sum = (fracsq * sumz - HALF * sumw) * trustRegionCenterOffset.getEntry(j);\n                        for (int k = 0; k < npt; k++) {\n                            sum += lagrangeValuesAtNewPoint.getEntry(k) * interpolationPoints.getEntry(k, j);\n                        }\n                        work1.setEntry(j, sum);\n                        for (int k = 0; k < npt; k++) {\n                            bMatrix.setEntry(k, j,\n                                          bMatrix.getEntry(k, j)\n                                          + sum * zMatrix.getEntry(k, m));\n                        }\n                    }\n                    for (int i = 0; i < n; i++) {\n                        final int ip = i + npt;\n                        final double temp = work1.getEntry(i);\n                        for (int j = 0; j <= i; j++) {\n                            bMatrix.setEntry(ip, j,\n                                          bMatrix.getEntry(ip, j)\n                                          + temp * work1.getEntry(j));\n                        }\n                    }\n                }\n\n                \n                \n\n                int ih = 0;\n                for (int j = 0; j < n; j++) {\n                    work1.setEntry(j, -HALF * sumpq * trustRegionCenterOffset.getEntry(j));\n                    for (int k = 0; k < npt; k++) {\n                        work1.setEntry(j, work1.getEntry(j) + modelSecondDerivativesParameters.getEntry(k) * interpolationPoints.getEntry(k, j));\n                        interpolationPoints.setEntry(k, j, interpolationPoints.getEntry(k, j) - trustRegionCenterOffset.getEntry(j));\n                    }\n                    for (int i = 0; i <= j; i++) {\n                         modelSecondDerivativesValues.setEntry(ih,\n                                    modelSecondDerivativesValues.getEntry(ih)\n                                    + work1.getEntry(i) * trustRegionCenterOffset.getEntry(j)\n                                    + trustRegionCenterOffset.getEntry(i) * work1.getEntry(j));\n                        bMatrix.setEntry(npt + i, j, bMatrix.getEntry(npt + j, i));\n                        ih++;\n                    }\n                }\n                for (int i = 0; i < n; i++) {\n                    originShift.setEntry(i, originShift.getEntry(i) + trustRegionCenterOffset.getEntry(i));\n                    newPoint.setEntry(i, newPoint.getEntry(i) - trustRegionCenterOffset.getEntry(i));\n                    lowerDifference.setEntry(i, lowerDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i));\n                    upperDifference.setEntry(i, upperDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i));\n                    trustRegionCenterOffset.setEntry(i, ZERO);\n                }\n                xoptsq = ZERO;\n            }\n            if (ntrits == 0) {\n                state = 210; break;\n            }\n            state = 230; break;\n\n            \n            \n            \n            \n            \n            \n            \n            \n\n        }\n        case 210: {\n            printState(210); \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n\n            final double[] alphaCauchy = altmov(knew, adelt);\n            alpha = alphaCauchy[0];\n            cauchy = alphaCauchy[1];\n\n            for (int i = 0; i < n; i++) {\n                trialStepPoint.setEntry(i, newPoint.getEntry(i) - trustRegionCenterOffset.getEntry(i));\n            }\n\n            \n            \n            \n\n        }\n        case 230: {\n            printState(230); \n            for (int k = 0; k < npt; k++) {\n                double suma = ZERO;\n                double sumb = ZERO;\n                double sum = ZERO;\n                for (int j = 0; j < n; j++) {\n                    suma += interpolationPoints.getEntry(k, j) * trialStepPoint.getEntry(j);\n                    sumb += interpolationPoints.getEntry(k, j) * trustRegionCenterOffset.getEntry(j);\n                    sum += bMatrix.getEntry(k, j) * trialStepPoint.getEntry(j);\n                }\n                work3.setEntry(k, suma * (HALF * suma + sumb));\n                lagrangeValuesAtNewPoint.setEntry(k, sum);\n                work2.setEntry(k, suma);\n            }\n            beta = ZERO;\n            for (int m = 0; m < nptm; m++) {\n                double sum = ZERO;\n                for (int k = 0; k < npt; k++) {\n                    sum += zMatrix.getEntry(k, m) * work3.getEntry(k);\n                }\n                beta -= sum * sum;\n                for (int k = 0; k < npt; k++) {\n                    lagrangeValuesAtNewPoint.setEntry(k, lagrangeValuesAtNewPoint.getEntry(k) + sum * zMatrix.getEntry(k, m));\n                }\n            }\n            dsq = ZERO;\n            double bsum = ZERO;\n            double dx = ZERO;\n            for (int j = 0; j < n; j++) {\n                \n                final double d1 = trialStepPoint.getEntry(j);\n                dsq += d1 * d1;\n                double sum = ZERO;\n                for (int k = 0; k < npt; k++) {\n                    sum += work3.getEntry(k) * bMatrix.getEntry(k, j);\n                }\n                bsum += sum * trialStepPoint.getEntry(j);\n                final int jp = npt + j;\n                for (int i = 0; i < n; i++) {\n                    sum += bMatrix.getEntry(jp, i) * trialStepPoint.getEntry(i);\n                }\n                lagrangeValuesAtNewPoint.setEntry(jp, sum);\n                bsum += sum * trialStepPoint.getEntry(j);\n                dx += trialStepPoint.getEntry(j) * trustRegionCenterOffset.getEntry(j);\n            }\n\n            beta = dx * dx + dsq * (xoptsq + dx + dx + HALF * dsq) + beta - bsum; \n            \n            \n\n            lagrangeValuesAtNewPoint.setEntry(trustRegionCenterInterpolationPointIndex,\n                          lagrangeValuesAtNewPoint.getEntry(trustRegionCenterInterpolationPointIndex) + ONE);\n\n            \n            \n            \n\n            if (ntrits == 0) {\n                \n                final double d1 = lagrangeValuesAtNewPoint.getEntry(knew);\n                denom = d1 * d1 + alpha * beta;\n                if (denom < cauchy && cauchy > ZERO) {\n                    for (int i = 0; i < n; i++) {\n                        newPoint.setEntry(i, alternativeNewPoint.getEntry(i));\n                        trialStepPoint.setEntry(i, newPoint.getEntry(i) - trustRegionCenterOffset.getEntry(i));\n                    }\n                    cauchy = ZERO; \n                    state = 230; break;\n                }\n                \n                \n                \n                \n                \n\n            } else {\n                final double delsq = delta * delta;\n                scaden = ZERO;\n                biglsq = ZERO;\n                knew = 0;\n                for (int k = 0; k < npt; k++) {\n                    if (k == trustRegionCenterInterpolationPointIndex) {\n                        continue;\n                    }\n                    double hdiag = ZERO;\n                    for (int m = 0; m < nptm; m++) {\n                        \n                        final double d1 = zMatrix.getEntry(k, m);\n                        hdiag += d1 * d1;\n                    }\n                    \n                    final double d2 = lagrangeValuesAtNewPoint.getEntry(k);\n                    final double den = beta * hdiag + d2 * d2;\n                    distsq = ZERO;\n                    for (int j = 0; j < n; j++) {\n                        \n                        final double d3 = interpolationPoints.getEntry(k, j) - trustRegionCenterOffset.getEntry(j);\n                        distsq += d3 * d3;\n                    }\n                    \n                    \n                    final double d4 = distsq / delsq;\n                    final double temp = Math.max(ONE, d4 * d4);\n                    if (temp * den > scaden) {\n                        scaden = temp * den;\n                        knew = k;\n                        denom = den;\n                    }\n                    \n                    \n                    final double d5 = lagrangeValuesAtNewPoint.getEntry(k);\n                    biglsq = Math.max(biglsq, temp * (d5 * d5));\n                }\n            }\n\n            \n            \n\n            \n            \n\n        }\n        case 360: {\n            printState(360); \n            for (int i = 0; i < n; i++) {\n                \n                \n                final double d3 = lowerBound[i];\n                final double d4 = originShift.getEntry(i) + newPoint.getEntry(i);\n                final double d1 = Math.max(d3, d4);\n                final double d2 = upperBound[i];\n                currentBest.setEntry(i, Math.min(d1, d2));\n                if (newPoint.getEntry(i) == lowerDifference.getEntry(i)) {\n                    currentBest.setEntry(i, lowerBound[i]);\n                }\n                if (newPoint.getEntry(i) == upperDifference.getEntry(i)) {\n                    currentBest.setEntry(i, upperBound[i]);\n                }\n            }\n\n            f = computeObjectiveValue(currentBest.toArray());\n\n            if (!isMinimize)\n                f = -f;\n            if (ntrits == -1) {\n                fsave = f;\n                state = 720; break;\n            }\n\n            \n            \n\n            final double fopt = fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex);\n            double vquad = ZERO;\n            int ih = 0;\n            for (int j = 0; j < n; j++) {\n                vquad += trialStepPoint.getEntry(j) * gradientAtTrustRegionCenter.getEntry(j);\n                for (int i = 0; i <= j; i++) {\n                    double temp = trialStepPoint.getEntry(i) * trialStepPoint.getEntry(j);\n                    if (i == j) {\n                        temp *= HALF;\n                    }\n                    vquad += modelSecondDerivativesValues.getEntry(ih) * temp;\n                    ih++;\n               }\n            }\n            for (int k = 0; k < npt; k++) {\n                \n                final double d1 = work2.getEntry(k);\n                final double d2 = d1 * d1; \n                vquad += HALF * modelSecondDerivativesParameters.getEntry(k) * d2;\n            }\n            final double diff = f - fopt - vquad;\n            diffc = diffb;\n            diffb = diffa;\n            diffa = Math.abs(diff);\n            if (dnorm > rho) {\n                nfsav = getEvaluations();\n            }\n\n            \n\n            if (ntrits > 0) {\n                if (vquad >= ZERO) {\n                    throw new MathIllegalStateException(LocalizedFormats.TRUST_REGION_STEP_FAILED, vquad);\n                }\n                ratio = (f - fopt) / vquad;\n                final double hDelta = HALF * delta;\n                if (ratio <= ONE_OVER_TEN) {\n                    \n                    delta = Math.min(hDelta, dnorm);\n                } else if (ratio <= .7) {\n                    \n                    delta = Math.max(hDelta, dnorm);\n                } else {\n                    \n                    delta = Math.max(hDelta, 2 * dnorm);\n                }\n                if (delta <= rho * 1.5) {\n                    delta = rho;\n                }\n\n                \n\n                if (f < fopt) {\n                    final int ksav = knew;\n                    final double densav = denom;\n                    final double delsq = delta * delta;\n                    scaden = ZERO;\n                    biglsq = ZERO;\n                    knew = 0;\n                    for (int k = 0; k < npt; k++) {\n                        double hdiag = ZERO;\n                        for (int m = 0; m < nptm; m++) {\n                            \n                            final double d1 = zMatrix.getEntry(k, m);\n                            hdiag += d1 * d1;\n                        }\n                        \n                        final double d1 = lagrangeValuesAtNewPoint.getEntry(k);\n                        final double den = beta * hdiag + d1 * d1;\n                        distsq = ZERO;\n                        for (int j = 0; j < n; j++) {\n                            \n                            final double d2 = interpolationPoints.getEntry(k, j) - newPoint.getEntry(j);\n                            distsq += d2 * d2;\n                        }\n                        \n                        \n                        final double d3 = distsq / delsq;\n                        final double temp = Math.max(ONE, d3 * d3);\n                        if (temp * den > scaden) {\n                            scaden = temp * den;\n                            knew = k;\n                            denom = den;\n                        }\n                        \n                        \n                        final double d4 = lagrangeValuesAtNewPoint.getEntry(k);\n                        final double d5 = temp * (d4 * d4);\n                        biglsq = Math.max(biglsq, d5);\n                    }\n                    if (scaden <= HALF * biglsq) {\n                        knew = ksav;\n                        denom = densav;\n                    }\n                }\n            }\n\n            \n            \n\n            update(beta, denom, knew);\n\n            ih = 0;\n            final double pqold = modelSecondDerivativesParameters.getEntry(knew);\n            modelSecondDerivativesParameters.setEntry(knew, ZERO);\n            for (int i = 0; i < n; i++) {\n                final double temp = pqold * interpolationPoints.getEntry(knew, i);\n                for (int j = 0; j <= i; j++) {\n                    modelSecondDerivativesValues.setEntry(ih, modelSecondDerivativesValues.getEntry(ih) + temp * interpolationPoints.getEntry(knew, j));\n                    ih++;\n                }\n            }\n            for (int m = 0; m < nptm; m++) {\n                final double temp = diff * zMatrix.getEntry(knew, m);\n                for (int k = 0; k < npt; k++) {\n                    modelSecondDerivativesParameters.setEntry(k, modelSecondDerivativesParameters.getEntry(k) + temp * zMatrix.getEntry(k, m));\n                }\n            }\n\n            \n            \n\n            fAtInterpolationPoints.setEntry(knew,  f);\n            for (int i = 0; i < n; i++) {\n                interpolationPoints.setEntry(knew, i, newPoint.getEntry(i));\n                work1.setEntry(i, bMatrix.getEntry(knew, i));\n            }\n            for (int k = 0; k < npt; k++) {\n                double suma = ZERO;\n                for (int m = 0; m < nptm; m++) {\n                    suma += zMatrix.getEntry(knew, m) * zMatrix.getEntry(k, m);\n                }\n                double sumb = ZERO;\n                for (int j = 0; j < n; j++) {\n                    sumb += interpolationPoints.getEntry(k, j) * trustRegionCenterOffset.getEntry(j);\n                }\n                final double temp = suma * sumb;\n                for (int i = 0; i < n; i++) {\n                    work1.setEntry(i, work1.getEntry(i) + temp * interpolationPoints.getEntry(k, i));\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                gradientAtTrustRegionCenter.setEntry(i, gradientAtTrustRegionCenter.getEntry(i) + diff * work1.getEntry(i));\n            }\n\n            \n\n            if (f < fopt) {\n                trustRegionCenterInterpolationPointIndex = knew;\n                xoptsq = ZERO;\n                ih = 0;\n                for (int j = 0; j < n; j++) {\n                    trustRegionCenterOffset.setEntry(j, newPoint.getEntry(j));\n                    \n                    final double d1 = trustRegionCenterOffset.getEntry(j);\n                    xoptsq += d1 * d1;\n                    for (int i = 0; i <= j; i++) {\n                        if (i < j) {\n                            gradientAtTrustRegionCenter.setEntry(j, gradientAtTrustRegionCenter.getEntry(j) + modelSecondDerivativesValues.getEntry(ih) * trialStepPoint.getEntry(i));\n                        }\n                        gradientAtTrustRegionCenter.setEntry(i, gradientAtTrustRegionCenter.getEntry(i) + modelSecondDerivativesValues.getEntry(ih) * trialStepPoint.getEntry(j));\n                        ih++;\n                    }\n                }\n                for (int k = 0; k < npt; k++) {\n                    double temp = ZERO;\n                    for (int j = 0; j < n; j++) {\n                        temp += interpolationPoints.getEntry(k, j) * trialStepPoint.getEntry(j);\n                    }\n                    temp *= modelSecondDerivativesParameters.getEntry(k);\n                    for (int i = 0; i < n; i++) {\n                        gradientAtTrustRegionCenter.setEntry(i, gradientAtTrustRegionCenter.getEntry(i) + temp * interpolationPoints.getEntry(k, i));\n                    }\n                }\n            }\n\n            \n            \n            \n\n            if (ntrits > 0) {\n                for (int k = 0; k < npt; k++) {\n                    lagrangeValuesAtNewPoint.setEntry(k, fAtInterpolationPoints.getEntry(k) - fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex));\n                    work3.setEntry(k, ZERO);\n                }\n                for (int j = 0; j < nptm; j++) {\n                    double sum = ZERO;\n                    for (int k = 0; k < npt; k++) {\n                        sum += zMatrix.getEntry(k, j) * lagrangeValuesAtNewPoint.getEntry(k);\n                    }\n                    for (int k = 0; k < npt; k++) {\n                        work3.setEntry(k, work3.getEntry(k) + sum * zMatrix.getEntry(k, j));\n                    }\n                }\n                for (int k = 0; k < npt; k++) {\n                    double sum = ZERO;\n                    for (int j = 0; j < n; j++) {\n                        sum += interpolationPoints.getEntry(k, j) * trustRegionCenterOffset.getEntry(j);\n                    }\n                    work2.setEntry(k, work3.getEntry(k));\n                    work3.setEntry(k, sum * work3.getEntry(k));\n                }\n                double gqsq = ZERO;\n                double gisq = ZERO;\n                for (int i = 0; i < n; i++) {\n                    double sum = ZERO;\n                    for (int k = 0; k < npt; k++) {\n                        sum += bMatrix.getEntry(k, i) *\n                            lagrangeValuesAtNewPoint.getEntry(k) + interpolationPoints.getEntry(k, i) * work3.getEntry(k);\n                    }\n                    if (trustRegionCenterOffset.getEntry(i) == lowerDifference.getEntry(i)) {\n                        \n                        \n                        final double d1 = Math.min(ZERO, gradientAtTrustRegionCenter.getEntry(i));\n                        gqsq += d1 * d1;\n                        \n                        final double d2 = Math.min(ZERO, sum);\n                        gisq += d2 * d2;\n                    } else if (trustRegionCenterOffset.getEntry(i) == upperDifference.getEntry(i)) {\n                        \n                        \n                        final double d1 = Math.max(ZERO, gradientAtTrustRegionCenter.getEntry(i));\n                        gqsq += d1 * d1;\n                        \n                        final double d2 = Math.max(ZERO, sum);\n                        gisq += d2 * d2;\n                    } else {\n                        \n                        final double d1 = gradientAtTrustRegionCenter.getEntry(i);\n                        gqsq += d1 * d1;\n                        gisq += sum * sum;\n                    }\n                    lagrangeValuesAtNewPoint.setEntry(npt + i, sum);\n                }\n\n                \n                \n\n                ++itest;\n                if (gqsq < TEN * gisq) {\n                    itest = 0;\n                }\n                if (itest >= 3) {\n                    for (int i = 0, max = Math.max(npt, nh); i < max; i++) {\n                        if (i < n) {\n                            gradientAtTrustRegionCenter.setEntry(i, lagrangeValuesAtNewPoint.getEntry(npt + i));\n                        }\n                        if (i < npt) {\n                            modelSecondDerivativesParameters.setEntry(i, work2.getEntry(i));\n                        }\n                        if (i < nh) {\n                            modelSecondDerivativesValues.setEntry(i, ZERO);\n                        }\n                        itest = 0;\n                    }\n                }\n            }\n\n            \n            \n            \n\n            if (ntrits == 0) {\n                state = 60; break;\n            }\n            if (f <= fopt + ONE_OVER_TEN * vquad) {\n                state = 60; break;\n            }\n\n            \n            \n\n            \n            \n            final double d1 = TWO * delta;\n            \n            final double d2 = TEN * rho;\n            distsq = Math.max(d1 * d1, d2 * d2);\n        }\n        case 650: {\n            printState(650); \n            knew = -1;\n            for (int k = 0; k < npt; k++) {\n                double sum = ZERO;\n                for (int j = 0; j < n; j++) {\n                    \n                    final double d1 = interpolationPoints.getEntry(k, j) - trustRegionCenterOffset.getEntry(j);\n                    sum += d1 * d1;\n                }\n                if (sum > distsq) {\n                    knew = k;\n                    distsq = sum;\n                }\n            }\n\n            \n            \n            \n            \n            \n\n            if (knew >= 0) {\n                final double dist = Math.sqrt(distsq);\n                if (ntrits == -1) {\n                    \n                    delta = Math.min(ONE_OVER_TEN * delta, HALF * dist);\n                    if (delta <= rho * 1.5) {\n                        delta = rho;\n                    }\n                }\n                ntrits = 0;\n                \n                \n                final double d1 = Math.min(ONE_OVER_TEN * dist, delta);\n                adelt = Math.max(d1, rho);\n                dsq = adelt * adelt;\n                state = 90; break;\n            }\n            if (ntrits == -1) {\n                state = 680; break;\n            }\n            if (ratio > ZERO) {\n                state = 60; break;\n            }\n            if (Math.max(delta, dnorm) > rho) {\n                state = 60; break;\n            }\n\n            \n            \n        }\n        case 680: {\n            printState(680); \n            if (rho > stoppingTrustRegionRadius) {\n                delta = HALF * rho;\n                ratio = rho / stoppingTrustRegionRadius;\n                if (ratio <= SIXTEEN) {\n                    rho = stoppingTrustRegionRadius;\n                } else if (ratio <= TWO_HUNDRED_FIFTY) {\n                    rho = Math.sqrt(ratio) * stoppingTrustRegionRadius;\n                } else {\n                    rho *= ONE_OVER_TEN;\n                }\n                delta = Math.max(delta, rho);\n                ntrits = 0;\n                nfsav = getEvaluations();\n                state = 60; break;\n            }\n\n            \n            \n\n            if (ntrits == -1) {\n                state = 360; break;\n            }\n        }\n        case 720: {\n            printState(720); \n            if (fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex) <= fsave) {\n                for (int i = 0; i < n; i++) {\n                    \n                    \n                    final double d3 = lowerBound[i];\n                    final double d4 = originShift.getEntry(i) + trustRegionCenterOffset.getEntry(i);\n                    final double d1 = Math.max(d3, d4);\n                    final double d2 = upperBound[i];\n                    currentBest.setEntry(i, Math.min(d1, d2));\n                    if (trustRegionCenterOffset.getEntry(i) == lowerDifference.getEntry(i)) {\n                        currentBest.setEntry(i, lowerBound[i]);\n                    }\n                    if (trustRegionCenterOffset.getEntry(i) == upperDifference.getEntry(i)) {\n                        currentBest.setEntry(i, upperBound[i]);\n                    }\n                }\n                f = fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex);\n            }\n            return f;\n        }\n        default: {\n            throw new MathIllegalStateException(LocalizedFormats.SIMPLE_MESSAGE, \"bobyqb\");\n        }}\n    } \n\n    \n\n    \n    private double[] altmov( int knew, double adelt ) {\n        printMethod(); \n\n        final int n = currentBest.getDimension();\n        final int npt = numberOfInterpolationPoints;\n\n        final ArrayRealVector glag = new ArrayRealVector(n);\n        final ArrayRealVector hcol = new ArrayRealVector(npt);\n\n        final ArrayRealVector work1 = new ArrayRealVector(n);\n        final ArrayRealVector work2 = new ArrayRealVector(n);\n\n        for (int k = 0; k < npt; k++) {\n            hcol.setEntry(k, ZERO);\n        }\n        for (int j = 0, max = npt - n - 1; j < max; j++) {\n            final double tmp = zMatrix.getEntry(knew, j);\n            for (int k = 0; k < npt; k++) {\n                hcol.setEntry(k, hcol.getEntry(k) + tmp * zMatrix.getEntry(k, j));\n            }\n        }\n        final double alpha = hcol.getEntry(knew);\n        final double ha = HALF * alpha;\n\n        \n\n        for (int i = 0; i < n; i++) {\n            glag.setEntry(i, bMatrix.getEntry(knew, i));\n        }\n        for (int k = 0; k < npt; k++) {\n            double tmp = ZERO;\n            for (int j = 0; j < n; j++) {\n                tmp += interpolationPoints.getEntry(k, j) * trustRegionCenterOffset.getEntry(j);\n            }\n            tmp *= hcol.getEntry(k);\n            for (int i = 0; i < n; i++) {\n                glag.setEntry(i, glag.getEntry(i) + tmp * interpolationPoints.getEntry(k, i));\n            }\n        }\n\n        \n        \n        \n        \n        \n\n        double presav = ZERO;\n        double step = Double.NaN;\n        int ksav = 0;\n        int ibdsav = 0;\n        double stpsav = 0;\n        for (int k = 0; k < npt; k++) {\n            if (k == trustRegionCenterInterpolationPointIndex) {\n                continue;\n            }\n            double dderiv = ZERO;\n            double distsq = ZERO;\n            for (int i = 0; i < n; i++) {\n                final double tmp = interpolationPoints.getEntry(k, i) - trustRegionCenterOffset.getEntry(i);\n                dderiv += glag.getEntry(i) * tmp;\n                distsq += tmp * tmp;\n            }\n            double subd = adelt / Math.sqrt(distsq);\n            double slbd = -subd;\n            int ilbd = 0;\n            int iubd = 0;\n            final double sumin = Math.min(ONE, subd);\n\n            \n\n            for (int i = 0; i < n; i++) {\n                final double tmp = interpolationPoints.getEntry(k, i) - trustRegionCenterOffset.getEntry(i);\n                if (tmp > ZERO) {\n                    if (slbd * tmp < lowerDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i)) {\n                        slbd = (lowerDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i)) / tmp;\n                        ilbd = -i - 1;\n                    }\n                    if (subd * tmp > upperDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i)) {\n                        \n                        subd = Math.max(sumin,\n                                        (upperDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i)) / tmp);\n                        iubd = i + 1;\n                    }\n                } else if (tmp < ZERO) {\n                    if (slbd * tmp > upperDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i)) {\n                        slbd = (upperDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i)) / tmp;\n                        ilbd = i + 1;\n                    }\n                    if (subd * tmp < lowerDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i)) {\n                        \n                        subd = Math.max(sumin,\n                                        (lowerDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i)) / tmp);\n                        iubd = -i - 1;\n                    }\n                }\n            }\n\n            \n            \n\n            step = slbd;\n            int isbd = ilbd;\n            double vlag = Double.NaN;\n            if (k == knew) {\n                final double diff = dderiv - ONE;\n                vlag = slbd * (dderiv - slbd * diff);\n                final double d1 = subd * (dderiv - subd * diff);\n                if (Math.abs(d1) > Math.abs(vlag)) {\n                    step = subd;\n                    vlag = d1;\n                    isbd = iubd;\n                }\n                final double d2 = HALF * dderiv;\n                final double d3 = d2 - diff * slbd;\n                final double d4 = d2 - diff * subd;\n                if (d3 * d4 < ZERO) {\n                    final double d5 = d2 * d2 / diff;\n                    if (Math.abs(d5) > Math.abs(vlag)) {\n                        step = d2 / diff;\n                        vlag = d5;\n                        isbd = 0;\n                    }\n                }\n\n                \n\n            } else {\n                vlag = slbd * (ONE - slbd);\n                final double tmp = subd * (ONE - subd);\n                if (Math.abs(tmp) > Math.abs(vlag)) {\n                    step = subd;\n                    vlag = tmp;\n                    isbd = iubd;\n                }\n                if (subd > HALF) {\n                    if (Math.abs(vlag) < ONE_OVER_FOUR) {\n                        step = HALF;\n                        vlag = ONE_OVER_FOUR;\n                        isbd = 0;\n                    }\n                }\n                vlag *= dderiv;\n            }\n\n            \n\n            final double tmp = step * (ONE - step) * distsq;\n            final double predsq = vlag * vlag * (vlag * vlag + ha * tmp * tmp);\n            if (predsq > presav) {\n                presav = predsq;\n                ksav = k;\n                stpsav = step;\n                ibdsav = isbd;\n            }\n        }\n\n        \n\n        for (int i = 0; i < n; i++) {\n            final double tmp = trustRegionCenterOffset.getEntry(i) + stpsav * (interpolationPoints.getEntry(ksav, i) - trustRegionCenterOffset.getEntry(i));\n            newPoint.setEntry(i, Math.max(lowerDifference.getEntry(i),\n                                      Math.min(upperDifference.getEntry(i), tmp)));\n        }\n        if (ibdsav < 0) {\n            newPoint.setEntry(-ibdsav - 1, lowerDifference.getEntry(-ibdsav - 1));\n        }\n        if (ibdsav > 0) {\n            newPoint.setEntry(ibdsav - 1, upperDifference.getEntry(ibdsav - 1));\n        }\n\n        \n        \n        \n\n        final double bigstp = adelt + adelt;\n        int iflag = 0;\n        double cauchy = Double.NaN;\n        double csave = ZERO;\n        while (true) {\n            double wfixsq = ZERO;\n            double ggfree = ZERO;\n            for (int i = 0; i < n; i++) {\n                final double glagValue = glag.getEntry(i);\n                work1.setEntry(i, ZERO);\n                if (Math.min(trustRegionCenterOffset.getEntry(i) - lowerDifference.getEntry(i), glagValue) > ZERO ||\n                    Math.max(trustRegionCenterOffset.getEntry(i) - upperDifference.getEntry(i), glagValue) < ZERO) {\n                    work1.setEntry(i, bigstp);\n                    \n                    ggfree += glagValue * glagValue;\n                }\n            }\n            if (ggfree == ZERO) {\n                return new double[] { alpha, ZERO };\n            }\n\n            \n            final double tmp1 = adelt * adelt - wfixsq;\n            if (tmp1 > ZERO) {\n                step = Math.sqrt(tmp1 / ggfree);\n                ggfree = ZERO;\n                for (int i = 0; i < n; i++) {\n                    if (work1.getEntry(i) == bigstp) {\n                        final double tmp2 = trustRegionCenterOffset.getEntry(i) - step * glag.getEntry(i);\n                        if (tmp2 <= lowerDifference.getEntry(i)) {\n                            work1.setEntry(i, lowerDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i));\n                            \n                            final double d1 = work1.getEntry(i);\n                            wfixsq += d1 * d1;\n                        } else if (tmp2 >= upperDifference.getEntry(i)) {\n                            work1.setEntry(i, upperDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i));\n                            \n                            final double d1 = work1.getEntry(i);\n                            wfixsq += d1 * d1;\n                        } else {\n                            \n                            final double d1 = glag.getEntry(i);\n                            ggfree += d1 * d1;\n                        }\n                    }\n                }\n            }\n\n            \n            \n\n            double gw = ZERO;\n            for (int i = 0; i < n; i++) {\n                final double glagValue = glag.getEntry(i);\n                if (work1.getEntry(i) == bigstp) {\n                    work1.setEntry(i, -step * glagValue);\n                    final double min = Math.min(upperDifference.getEntry(i),\n                                                trustRegionCenterOffset.getEntry(i) + work1.getEntry(i));\n                    alternativeNewPoint.setEntry(i, Math.max(lowerDifference.getEntry(i), min));\n                } else if (work1.getEntry(i) == ZERO) {\n                    alternativeNewPoint.setEntry(i, trustRegionCenterOffset.getEntry(i));\n                } else if (glagValue > ZERO) {\n                    alternativeNewPoint.setEntry(i, lowerDifference.getEntry(i));\n                } else {\n                    alternativeNewPoint.setEntry(i, upperDifference.getEntry(i));\n                }\n                gw += glagValue * work1.getEntry(i);\n            }\n\n            \n            \n            \n            \n\n            double curv = ZERO;\n            for (int k = 0; k < npt; k++) {\n                double tmp = ZERO;\n                for (int j = 0; j < n; j++) {\n                    tmp += interpolationPoints.getEntry(k, j) * work1.getEntry(j);\n                }\n                curv += hcol.getEntry(k) * tmp * tmp;\n            }\n            if (iflag == 1) {\n                curv = -curv;\n            }\n            if (curv > -gw &&\n                curv < -gw * (ONE + Math.sqrt(TWO))) {\n                final double scale = -gw / curv;\n                for (int i = 0; i < n; i++) {\n                    final double tmp = trustRegionCenterOffset.getEntry(i) + scale * work1.getEntry(i);\n                    alternativeNewPoint.setEntry(i, Math.max(lowerDifference.getEntry(i),\n                                              Math.min(upperDifference.getEntry(i), tmp)));\n                }\n                \n                final double d1 = HALF * gw * scale;\n                cauchy = d1 * d1;\n            } else {\n                \n                final double d1 = gw + HALF * curv;\n                cauchy = d1 * d1;\n            }\n\n            \n            \n            \n\n            if (iflag == 0) {\n                for (int i = 0; i < n; i++) {\n                    glag.setEntry(i, -glag.getEntry(i));\n                    work2.setEntry(i, alternativeNewPoint.getEntry(i));\n                }\n                csave = cauchy;\n                iflag = 1;\n            } else {\n                break;\n            }\n        }\n        if (csave > cauchy) {\n            for (int i = 0; i < n; i++) {\n                alternativeNewPoint.setEntry(i, work2.getEntry(i));\n            }\n            cauchy = csave;\n        }\n\n        return new double[] { alpha, cauchy };\n    } \n\n    \n\n    \n    private void prelim(double[] lowerBound, double[] upperBound) {\n        printMethod(); \n\n        final int n = currentBest.getDimension();\n        final int npt = numberOfInterpolationPoints;\n        final int ndim = bMatrix.getRowDimension();\n\n        final double rhosq = initialTrustRegionRadius * initialTrustRegionRadius;\n        final double recip = 1d / rhosq;\n        final int np = n + 1;\n\n        \n        \n\n        for (int j = 0; j < n; j++) {\n            originShift.setEntry(j, currentBest.getEntry(j));\n            for (int k = 0; k < npt; k++) {\n                interpolationPoints.setEntry(k, j, ZERO);\n            }\n            for (int i = 0; i < ndim; i++) {\n                bMatrix.setEntry(i, j, ZERO);\n            }\n        }\n        for (int i = 0, max = n * np / 2; i < max; i++) {\n            modelSecondDerivativesValues.setEntry(i, ZERO);\n        }\n        for (int k = 0; k < npt; k++) {\n            modelSecondDerivativesParameters.setEntry(k, ZERO);\n            for (int j = 0, max = npt - np; j < max; j++) {\n                zMatrix.setEntry(k, j, ZERO);\n            }\n        }\n\n        \n        \n        \n\n        int ipt = 0;\n        int jpt = 0;\n        double fbeg = Double.NaN;\n        do {\n            final int nfm = getEvaluations();\n            final int nfx = nfm - n;\n            final int nfmm = nfm - 1;\n            final int nfxm = nfx - 1;\n            double stepa = 0;\n            double stepb = 0;\n            if (nfm <= 2 * n) {\n                if (nfm >= 1 &&\n                    nfm <= n) {\n                    stepa = initialTrustRegionRadius;\n                    if (upperDifference.getEntry(nfmm) == ZERO) {\n                        stepa = -stepa;\n                        throw new PathIsExploredException(); \n                    }\n                    interpolationPoints.setEntry(nfm, nfmm, stepa);\n                } else if (nfm > n) {\n                    stepa = interpolationPoints.getEntry(nfx, nfxm);\n                    stepb = -initialTrustRegionRadius;\n                    if (lowerDifference.getEntry(nfxm) == ZERO) {\n                        stepb = Math.min(TWO * initialTrustRegionRadius, upperDifference.getEntry(nfxm));\n                        throw new PathIsExploredException(); \n                    }\n                    if (upperDifference.getEntry(nfxm) == ZERO) {\n                        stepb = Math.max(-TWO * initialTrustRegionRadius, lowerDifference.getEntry(nfxm));\n                        throw new PathIsExploredException(); \n                    }\n                    interpolationPoints.setEntry(nfm, nfxm, stepb);\n                }\n            } else {\n                final int tmp1 = (nfm - np) / n;\n                jpt = nfm - tmp1 * n - n;\n                ipt = jpt + tmp1;\n                if (ipt > n) {\n                    final int tmp2 = jpt;\n                    jpt = ipt - n;\n                    ipt = tmp2;\n                    throw new PathIsExploredException(); \n                }\n                final int iptMinus1 = ipt;\n                final int jptMinus1 = jpt;\n                interpolationPoints.setEntry(nfm, iptMinus1, interpolationPoints.getEntry(ipt, iptMinus1));\n                interpolationPoints.setEntry(nfm, jptMinus1, interpolationPoints.getEntry(jpt, jptMinus1));\n            }\n\n            \n            \n\n            for (int j = 0; j < n; j++) {\n                currentBest.setEntry(j, Math.min(Math.max(lowerBound[j],\n                                                          originShift.getEntry(j) + interpolationPoints.getEntry(nfm, j)),\n                                                 upperBound[j]));\n                if (interpolationPoints.getEntry(nfm, j) == lowerDifference.getEntry(j)) {\n                    currentBest.setEntry(j, lowerBound[j]);\n                }\n                if (interpolationPoints.getEntry(nfm, j) == upperDifference.getEntry(j)) {\n                    currentBest.setEntry(j, upperBound[j]);\n                }\n            }\n\n            final double objectiveValue = computeObjectiveValue(currentBest.toArray());\n            final double f = isMinimize ? objectiveValue : -objectiveValue;\n            final int numEval = getEvaluations(); \n            fAtInterpolationPoints.setEntry(nfm, f);\n\n            if (numEval == 1) {\n                fbeg = f;\n                trustRegionCenterInterpolationPointIndex = 0;\n            } else if (f < fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex)) {\n                trustRegionCenterInterpolationPointIndex = nfm;\n            }\n\n            \n            \n            \n            \n            \n\n            if (numEval <= 2 * n + 1) {\n                if (numEval >= 2 &&\n                    numEval <= n + 1) {\n                    gradientAtTrustRegionCenter.setEntry(nfmm, (f - fbeg) / stepa);\n                    if (npt < numEval + n) {\n                        final double oneOverStepA = ONE / stepa;\n                        bMatrix.setEntry(0, nfmm, -oneOverStepA);\n                        bMatrix.setEntry(nfm, nfmm, oneOverStepA);\n                        bMatrix.setEntry(npt + nfmm, nfmm, -HALF * rhosq);\n                        throw new PathIsExploredException(); \n                    }\n                } else if (numEval >= n + 2) {\n                    final int ih = nfx * (nfx + 1) / 2 - 1;\n                    final double tmp = (f - fbeg) / stepb;\n                    final double diff = stepb - stepa;\n                    modelSecondDerivativesValues.setEntry(ih, TWO * (tmp - gradientAtTrustRegionCenter.getEntry(nfxm)) / diff);\n                    gradientAtTrustRegionCenter.setEntry(nfxm, (gradientAtTrustRegionCenter.getEntry(nfxm) * stepb - tmp * stepa) / diff);\n                    if (stepa * stepb < ZERO) {\n                        if (f < fAtInterpolationPoints.getEntry(nfm - n)) {\n                            fAtInterpolationPoints.setEntry(nfm, fAtInterpolationPoints.getEntry(nfm - n));\n                            fAtInterpolationPoints.setEntry(nfm - n, f);\n                            if (trustRegionCenterInterpolationPointIndex == nfm) {\n                                trustRegionCenterInterpolationPointIndex = nfm - n;\n                            }\n                            interpolationPoints.setEntry(nfm - n, nfxm, stepb);\n                            interpolationPoints.setEntry(nfm, nfxm, stepa);\n                        }\n                    }\n                    bMatrix.setEntry(0, nfxm, -(stepa + stepb) / (stepa * stepb));\n                    bMatrix.setEntry(nfm, nfxm, -HALF / interpolationPoints.getEntry(nfm - n, nfxm));\n                    bMatrix.setEntry(nfm - n, nfxm,\n                                  -bMatrix.getEntry(0, nfxm) - bMatrix.getEntry(nfm, nfxm));\n                    zMatrix.setEntry(0, nfxm, Math.sqrt(TWO) / (stepa * stepb));\n                    zMatrix.setEntry(nfm, nfxm, Math.sqrt(HALF) / rhosq);\n                    \n                    zMatrix.setEntry(nfm - n, nfxm,\n                                  -zMatrix.getEntry(0, nfxm) - zMatrix.getEntry(nfm, nfxm));\n                }\n\n                \n                \n\n            } else {\n                zMatrix.setEntry(0, nfxm, recip);\n                zMatrix.setEntry(nfm, nfxm, recip);\n                zMatrix.setEntry(ipt, nfxm, -recip);\n                zMatrix.setEntry(jpt, nfxm, -recip);\n\n                final int ih = ipt * (ipt - 1) / 2 + jpt - 1;\n                final double tmp = interpolationPoints.getEntry(nfm, ipt - 1) * interpolationPoints.getEntry(nfm, jpt - 1);\n                modelSecondDerivativesValues.setEntry(ih, (fbeg - fAtInterpolationPoints.getEntry(ipt) - fAtInterpolationPoints.getEntry(jpt) + f) / tmp);\n                throw new PathIsExploredException(); \n            }\n        } while (getEvaluations() < npt);\n    } \n\n\n    \n\n    \n    private double[] trsbox( double delta, ArrayRealVector gnew, ArrayRealVector xbdi, ArrayRealVector s, ArrayRealVector hs, ArrayRealVector hred ) {\n        printMethod(); \n\n        final int n = currentBest.getDimension();\n        final int npt = numberOfInterpolationPoints;\n\n        double dsq = Double.NaN;\n        double crvmin = Double.NaN;\n\n        \n        double ds;\n        int iu;\n        double dhd, dhs, cth, shs, sth, ssq, beta=0, sdec, blen;\n        int iact = -1;\n        int nact = 0;\n        double angt = 0, qred;\n        int isav;\n        double temp = 0, xsav = 0, xsum = 0, angbd = 0, dredg = 0, sredg = 0;\n        int iterc;\n        double resid = 0, delsq = 0, ggsav = 0, tempa = 0, tempb = 0,\n        redmax = 0, dredsq = 0, redsav = 0, gredsq = 0, rednew = 0;\n        int itcsav = 0;\n        double rdprev = 0, rdnext = 0, stplen = 0, stepsq = 0;\n        int itermax = 0;\n\n        \n\n        \n\n        \n        \n        \n        \n        \n        \n\n        iterc = 0;\n        nact = 0;\n        for (int i = 0; i < n; i++) {\n            xbdi.setEntry(i, ZERO);\n            if (trustRegionCenterOffset.getEntry(i) <= lowerDifference.getEntry(i)) {\n                if (gradientAtTrustRegionCenter.getEntry(i) >= ZERO) {\n                    xbdi.setEntry(i, MINUS_ONE);\n                }\n            } else if (trustRegionCenterOffset.getEntry(i) >= upperDifference.getEntry(i)) {\n                if (gradientAtTrustRegionCenter.getEntry(i) <= ZERO) {\n                    xbdi.setEntry(i, ONE);\n                }\n            }\n            if (xbdi.getEntry(i) != ZERO) {\n                ++nact;\n            }\n            trialStepPoint.setEntry(i, ZERO);\n            gnew.setEntry(i, gradientAtTrustRegionCenter.getEntry(i));\n        }\n        delsq = delta * delta;\n        qred = ZERO;\n        crvmin = MINUS_ONE;\n\n        \n        \n        \n        \n        \n\n        int state = 20;\n        for(;;) {\n            switch (state) {\n        case 20: {\n            printState(20); \n            beta = ZERO;\n        }\n        case 30: {\n            printState(30); \n            stepsq = ZERO;\n            for (int i = 0; i < n; i++) {\n                if (xbdi.getEntry(i) != ZERO) {\n                    s.setEntry(i, ZERO);\n                } else if (beta == ZERO) {\n                    s.setEntry(i, -gnew.getEntry(i));\n                } else {\n                    s.setEntry(i, beta * s.getEntry(i) - gnew.getEntry(i));\n                }\n                \n                final double d1 = s.getEntry(i);\n                stepsq += d1 * d1;\n            }\n            if (stepsq == ZERO) {\n                state = 190; break;\n            }\n            if (beta == ZERO) {\n                gredsq = stepsq;\n                itermax = iterc + n - nact;\n            }\n            if (gredsq * delsq <= qred * 1e-4 * qred) {\n                state = 190; break;\n            }\n\n            \n            \n            \n            \n\n            state = 210; break;\n        }\n        case 50: {\n            printState(50); \n            resid = delsq;\n            ds = ZERO;\n            shs = ZERO;\n            for (int i = 0; i < n; i++) {\n                if (xbdi.getEntry(i) == ZERO) {\n                    \n                    final double d1 = trialStepPoint.getEntry(i);\n                    resid -= d1 * d1;\n                    ds += s.getEntry(i) * trialStepPoint.getEntry(i);\n                    shs += s.getEntry(i) * hs.getEntry(i);\n                }\n            }\n            if (resid <= ZERO) {\n                state = 90; break;\n            }\n            temp = Math.sqrt(stepsq * resid + ds * ds);\n            if (ds < ZERO) {\n                blen = (temp - ds) / stepsq;\n            } else {\n                blen = resid / (temp + ds);\n            }\n            stplen = blen;\n            if (shs > ZERO) {\n                \n                stplen = Math.min(blen, gredsq / shs);\n            }\n\n            \n            \n\n            iact = -1;\n            for (int i = 0; i < n; i++) {\n                if (s.getEntry(i) != ZERO) {\n                    xsum = trustRegionCenterOffset.getEntry(i) + trialStepPoint.getEntry(i);\n                    if (s.getEntry(i) > ZERO) {\n                        temp = (upperDifference.getEntry(i) - xsum) / s.getEntry(i);\n                    } else {\n                        temp = (lowerDifference.getEntry(i) - xsum) / s.getEntry(i);\n                    }\n                    if (temp < stplen) {\n                        stplen = temp;\n                        iact = i;\n                    }\n                }\n            }\n\n            \n\n            sdec = ZERO;\n            if (stplen > ZERO) {\n                ++iterc;\n                temp = shs / stepsq;\n                if (iact == -1 && temp > ZERO) {\n                    crvmin = Math.min(crvmin,temp);\n                    if (crvmin == MINUS_ONE) {\n                        crvmin = temp;\n                    }\n                }\n                ggsav = gredsq;\n                gredsq = ZERO;\n                for (int i = 0; i < n; i++) {\n                    gnew.setEntry(i, gnew.getEntry(i) + stplen * hs.getEntry(i));\n                    if (xbdi.getEntry(i) == ZERO) {\n                        \n                        final double d1 = gnew.getEntry(i);\n                        gredsq += d1 * d1;\n                    }\n                    trialStepPoint.setEntry(i, trialStepPoint.getEntry(i) + stplen * s.getEntry(i));\n                }\n                \n                final double d1 = stplen * (ggsav - HALF * stplen * shs);\n                sdec = Math.max(d1, ZERO);\n                qred += sdec;\n            }\n\n            \n\n            if (iact >= 0) {\n                ++nact;\n                xbdi.setEntry(iact, ONE);\n                if (s.getEntry(iact) < ZERO) {\n                    xbdi.setEntry(iact, MINUS_ONE);\n                }\n                \n                final double d1 = trialStepPoint.getEntry(iact);\n                delsq -= d1 * d1;\n                if (delsq <= ZERO) {\n                    state = 190; break;\n                }\n                state = 20; break;\n            }\n\n            \n            \n\n            if (stplen < blen) {\n                if (iterc == itermax) {\n                    state = 190; break;\n                }\n                if (sdec <= qred * .01) {\n                    state = 190; break;\n                }\n                beta = gredsq / ggsav;\n                state = 30; break;\n            }\n        }\n        case 90: {\n            printState(90); \n            crvmin = ZERO;\n\n            \n            \n            \n\n        }\n        case 100: {\n            printState(100); \n            if (nact >= n - 1) {\n                state = 190; break;\n            }\n            dredsq = ZERO;\n            dredg = ZERO;\n            gredsq = ZERO;\n            for (int i = 0; i < n; i++) {\n                if (xbdi.getEntry(i) == ZERO) {\n                    \n                    double d1 = trialStepPoint.getEntry(i);\n                    dredsq += d1 * d1;\n                    dredg += trialStepPoint.getEntry(i) * gnew.getEntry(i);\n                    \n                    d1 = gnew.getEntry(i);\n                    gredsq += d1 * d1;\n                    s.setEntry(i, trialStepPoint.getEntry(i));\n                } else {\n                    s.setEntry(i, ZERO);\n                }\n            }\n            itcsav = iterc;\n            state = 210; break;\n            \n            \n        }\n        case 120: {\n            printState(120); \n            ++iterc;\n            temp = gredsq * dredsq - dredg * dredg;\n            if (temp <= qred * 1e-4 * qred) {\n                state = 190; break;\n            }\n            temp = Math.sqrt(temp);\n            for (int i = 0; i < n; i++) {\n                if (xbdi.getEntry(i) == ZERO) {\n                    s.setEntry(i, (dredg * trialStepPoint.getEntry(i) - dredsq * gnew.getEntry(i)) / temp);\n                } else {\n                    s.setEntry(i, ZERO);\n                }\n            }\n            sredg = -temp;\n\n            \n            \n            \n            \n\n            angbd = ONE;\n            iact = -1;\n            for (int i = 0; i < n; i++) {\n                if (xbdi.getEntry(i) == ZERO) {\n                    tempa = trustRegionCenterOffset.getEntry(i) + trialStepPoint.getEntry(i) - lowerDifference.getEntry(i);\n                    tempb = upperDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i) - trialStepPoint.getEntry(i);\n                    if (tempa <= ZERO) {\n                        ++nact;\n                        xbdi.setEntry(i, MINUS_ONE);\n                        state = 100; break;\n                    } else if (tempb <= ZERO) {\n                        ++nact;\n                        xbdi.setEntry(i, ONE);\n                        state = 100; break;\n                    }\n                    \n                    double d1 = trialStepPoint.getEntry(i);\n                    \n                    double d2 = s.getEntry(i);\n                    ssq = d1 * d1 + d2 * d2;\n                    \n                    d1 = trustRegionCenterOffset.getEntry(i) - lowerDifference.getEntry(i);\n                    temp = ssq - d1 * d1;\n                    if (temp > ZERO) {\n                        temp = Math.sqrt(temp) - s.getEntry(i);\n                        if (angbd * temp > tempa) {\n                            angbd = tempa / temp;\n                            iact = i;\n                            xsav = MINUS_ONE;\n                        }\n                    }\n                    \n                    d1 = upperDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i);\n                    temp = ssq - d1 * d1;\n                    if (temp > ZERO) {\n                        temp = Math.sqrt(temp) + s.getEntry(i);\n                        if (angbd * temp > tempb) {\n                            angbd = tempb / temp;\n                            iact = i;\n                            xsav = ONE;\n                        }\n                    }\n                }\n            }\n\n            \n\n            state = 210; break;\n        }\n        case 150: {\n            printState(150); \n            shs = ZERO;\n            dhs = ZERO;\n            dhd = ZERO;\n            for (int i = 0; i < n; i++) {\n                if (xbdi.getEntry(i) == ZERO) {\n                    shs += s.getEntry(i) * hs.getEntry(i);\n                    dhs += trialStepPoint.getEntry(i) * hs.getEntry(i);\n                    dhd += trialStepPoint.getEntry(i) * hred.getEntry(i);\n                }\n            }\n\n            \n            \n            \n\n            redmax = ZERO;\n            isav = -1;\n            redsav = ZERO;\n            iu = (int) (angbd * 17. + 3.1);\n            for (int i = 0; i < iu; i++) {\n                angt = angbd * i / iu;\n                sth = (angt + angt) / (ONE + angt * angt);\n                temp = shs + angt * (angt * dhd - dhs - dhs);\n                rednew = sth * (angt * dredg - sredg - HALF * sth * temp);\n                if (rednew > redmax) {\n                    redmax = rednew;\n                    isav = i;\n                    rdprev = redsav;\n                } else if (i == isav + 1) {\n                    rdnext = rednew;\n                }\n                redsav = rednew;\n            }\n\n            \n            \n\n            if (isav < 0) {\n                state = 190; break;\n            }\n            if (isav < iu) {\n                temp = (rdnext - rdprev) / (redmax + redmax - rdprev - rdnext);\n                angt = angbd * (isav + HALF * temp) / iu;\n            }\n            cth = (ONE - angt * angt) / (ONE + angt * angt);\n            sth = (angt + angt) / (ONE + angt * angt);\n            temp = shs + angt * (angt * dhd - dhs - dhs);\n            sdec = sth * (angt * dredg - sredg - HALF * sth * temp);\n            if (sdec <= ZERO) {\n                state = 190; break;\n            }\n\n            \n            \n            \n\n            dredg = ZERO;\n            gredsq = ZERO;\n            for (int i = 0; i < n; i++) {\n                gnew.setEntry(i, gnew.getEntry(i) + (cth - ONE) * hred.getEntry(i) + sth * hs.getEntry(i));\n                if (xbdi.getEntry(i) == ZERO) {\n                    trialStepPoint.setEntry(i, cth * trialStepPoint.getEntry(i) + sth * s.getEntry(i));\n                    dredg += trialStepPoint.getEntry(i) * gnew.getEntry(i);\n                    \n                    final double d1 = gnew.getEntry(i);\n                    gredsq += d1 * d1;\n                }\n                hred.setEntry(i, cth * hred.getEntry(i) + sth * hs.getEntry(i));\n            }\n            qred += sdec;\n            if (iact >= 0 && isav == iu) {\n                ++nact;\n                xbdi.setEntry(iact, xsav);\n                state = 100; break;\n            }\n\n            \n            \n\n            if (sdec > qred * .01) {\n                state = 120; break;\n            }\n        }\n        case 190: {\n            printState(190); \n            dsq = ZERO;\n            for (int i = 0; i < n; i++) {\n                \n                \n                final double min = Math.min(trustRegionCenterOffset.getEntry(i) + trialStepPoint.getEntry(i),\n                                            upperDifference.getEntry(i));\n                newPoint.setEntry(i, Math.max(min, lowerDifference.getEntry(i)));\n                if (xbdi.getEntry(i) == MINUS_ONE) {\n                    newPoint.setEntry(i, lowerDifference.getEntry(i));\n                }\n                if (xbdi.getEntry(i) == ONE) {\n                    newPoint.setEntry(i, upperDifference.getEntry(i));\n                }\n                trialStepPoint.setEntry(i, newPoint.getEntry(i) - trustRegionCenterOffset.getEntry(i));\n                \n                final double d1 = trialStepPoint.getEntry(i);\n                dsq += d1 * d1;\n            }\n            return new double[] { dsq, crvmin };\n            \n            \n            \n            \n        }\n        case 210: {\n            printState(210); \n            int ih = 0;\n            for (int j = 0; j < n; j++) {\n                hs.setEntry(j, ZERO);\n                for (int i = 0; i <= j; i++) {\n                    if (i < j) {\n                        hs.setEntry(j, hs.getEntry(j) + modelSecondDerivativesValues.getEntry(ih) * s.getEntry(i));\n                    }\n                    hs.setEntry(i, hs.getEntry(i) + modelSecondDerivativesValues.getEntry(ih) * s.getEntry(j));\n                    ih++;\n                }\n            }\n            final RealVector tmp = interpolationPoints.operate(s).ebeMultiply(modelSecondDerivativesParameters);\n            for (int k = 0; k < npt; k++) {\n                if (modelSecondDerivativesParameters.getEntry(k) != ZERO) {\n                    for (int i = 0; i < n; i++) {\n                        hs.setEntry(i, hs.getEntry(i) + tmp.getEntry(k) * interpolationPoints.getEntry(k, i));\n                    }\n                }\n            }\n            if (crvmin != ZERO) {\n                state = 50; break;\n            }\n            if (iterc > itcsav) {\n                state = 150; break;\n            }\n            for (int i = 0; i < n; i++) {\n                hred.setEntry(i, hs.getEntry(i));\n            }\n            state = 120; break;\n        }\n        default: {\n            throw new MathIllegalStateException(LocalizedFormats.SIMPLE_MESSAGE, \"trsbox\");\n        }}\n        }\n    } \n\n    \n\n    \n    private void update( double beta, double denom, int knew ) {\n        printMethod(); \n\n        final int n = currentBest.getDimension();\n        final int npt = numberOfInterpolationPoints;\n        final int nptm = npt - n - 1;\n\n        \n        final ArrayRealVector work = new ArrayRealVector(npt + n);\n\n        double ztest = ZERO;\n        for (int k = 0; k < npt; k++) {\n            for (int j = 0; j < nptm; j++) {\n                \n                ztest = Math.max(ztest, Math.abs(zMatrix.getEntry(k, j)));\n            }\n        }\n        ztest *= 1e-20;\n\n        \n\n        for (int j = 1; j < nptm; j++) {\n            final double d1 = zMatrix.getEntry(knew, j);\n            if (Math.abs(d1) > ztest) {\n                \n                final double d2 = zMatrix.getEntry(knew, 0);\n                \n                final double d3 = zMatrix.getEntry(knew, j);\n                final double d4 = Math.sqrt(d2 * d2 + d3 * d3);\n                final double d5 = zMatrix.getEntry(knew, 0) / d4;\n                final double d6 = zMatrix.getEntry(knew, j) / d4;\n                for (int i = 0; i < npt; i++) {\n                    final double d7 = d5 * zMatrix.getEntry(i, 0) + d6 * zMatrix.getEntry(i, j);\n                    zMatrix.setEntry(i, j, d5 * zMatrix.getEntry(i, j) - d6 * zMatrix.getEntry(i, 0));\n                    zMatrix.setEntry(i, 0, d7);\n                }\n            }\n            zMatrix.setEntry(knew, j, ZERO);\n        }\n\n        \n        \n\n        for (int i = 0; i < npt; i++) {\n            work.setEntry(i, zMatrix.getEntry(knew, 0) * zMatrix.getEntry(i, 0));\n        }\n        final double alpha = work.getEntry(knew);\n        final double tau = lagrangeValuesAtNewPoint.getEntry(knew);\n        lagrangeValuesAtNewPoint.setEntry(knew, lagrangeValuesAtNewPoint.getEntry(knew) - ONE);\n\n        \n\n        final double sqrtDenom = Math.sqrt(denom);\n        final double d1 = tau / sqrtDenom;\n        final double d2 = zMatrix.getEntry(knew, 0) / sqrtDenom;\n        for (int i = 0; i < npt; i++) {\n            zMatrix.setEntry(i, 0,\n                          d1 * zMatrix.getEntry(i, 0) - d2 * lagrangeValuesAtNewPoint.getEntry(i));\n        }\n\n        \n\n        for (int j = 0; j < n; j++) {\n            final int jp = npt + j;\n            work.setEntry(jp, bMatrix.getEntry(knew, j));\n            final double d3 = (alpha * lagrangeValuesAtNewPoint.getEntry(jp) - tau * work.getEntry(jp)) / denom;\n            final double d4 = (-beta * work.getEntry(jp) - tau * lagrangeValuesAtNewPoint.getEntry(jp)) / denom;\n            for (int i = 0; i <= jp; i++) {\n                bMatrix.setEntry(i, j,\n                              bMatrix.getEntry(i, j) + d3 * lagrangeValuesAtNewPoint.getEntry(i) + d4 * work.getEntry(i));\n                if (i >= npt) {\n                    bMatrix.setEntry(jp, (i - npt), bMatrix.getEntry(i, j));\n                }\n            }\n        }\n    } \n\n    \n    private void setup(double[] lowerBound, double[] upperBound) {\n        printMethod(); \n\n        double[] init = getStartPoint();\n        final int dimension = init.length;\n\n        \n        if (dimension < MINIMUM_PROBLEM_DIMENSION) {\n            throw new NumberIsTooSmallException(dimension, MINIMUM_PROBLEM_DIMENSION, true);\n        }\n        \n        final int[] nPointsInterval = { dimension + 2, (dimension + 2) * (dimension + 1) / 2 };\n        if (numberOfInterpolationPoints < nPointsInterval[0] ||\n            numberOfInterpolationPoints > nPointsInterval[1]) {\n            throw new OutOfRangeException(LocalizedFormats.NUMBER_OF_INTERPOLATION_POINTS,\n                                          numberOfInterpolationPoints,\n                                          nPointsInterval[0],\n                                          nPointsInterval[1]);\n        }\n\n        \n        boundDifference = new double[dimension];\n\n        double requiredMinDiff = 2 * initialTrustRegionRadius;\n        double minDiff = Double.POSITIVE_INFINITY;\n        for (int i = 0; i < dimension; i++) {\n            boundDifference[i] = upperBound[i] - lowerBound[i];\n            minDiff = Math.min(minDiff, boundDifference[i]);\n        }\n        if (minDiff < requiredMinDiff) {\n            initialTrustRegionRadius = minDiff / 3.0;\n        }\n\n        \n        bMatrix = new Array2DRowRealMatrix(dimension + numberOfInterpolationPoints,\n                                           dimension);\n        zMatrix = new Array2DRowRealMatrix(numberOfInterpolationPoints,\n                                           numberOfInterpolationPoints - dimension - 1);\n        interpolationPoints = new Array2DRowRealMatrix(numberOfInterpolationPoints,\n                                                       dimension);\n        originShift = new ArrayRealVector(dimension);\n        fAtInterpolationPoints = new ArrayRealVector(numberOfInterpolationPoints);\n        trustRegionCenterOffset = new ArrayRealVector(dimension);\n        gradientAtTrustRegionCenter = new ArrayRealVector(dimension);\n        lowerDifference = new ArrayRealVector(dimension);\n        upperDifference = new ArrayRealVector(dimension);\n        modelSecondDerivativesParameters = new ArrayRealVector(numberOfInterpolationPoints);\n        newPoint = new ArrayRealVector(dimension);\n        alternativeNewPoint = new ArrayRealVector(dimension);\n        trialStepPoint = new ArrayRealVector(dimension);\n        lagrangeValuesAtNewPoint = new ArrayRealVector(dimension + numberOfInterpolationPoints);\n        modelSecondDerivativesValues = new ArrayRealVector(dimension * (dimension + 1) / 2);\n    }\n\n    \n    private static double[] fillNewArray(int n, double value) {\n        double[] ds = new double[n];\n        Arrays.fill(ds, value);\n        return ds;\n    }\n\n    \n    private static String caller(int n) {\n        final Throwable t = new Throwable();\n        final StackTraceElement[] elements = t.getStackTrace();\n        final StackTraceElement e = elements[n];\n        return e.getMethodName() + \" (at line \" + e.getLineNumber() + \")\";\n    }\n    \n    private static void printState(int s) {\n        \n    }\n    \n    private static void printMethod() {\n        \n    }\n\n    \n    private static class PathIsExploredException extends RuntimeException { private static final long serialVersionUID = 745350979634801853L; private static final String PATH_IS_EXPLORED = \"If this exception is thrown, just remove it from the code\"; PathIsExploredException() {\n            super(PATH_IS_EXPLORED + \" \" + BOBYQAOptimizer.caller(3));\n        }\n    }\n}\n",
      "fixed_full_code": "\n\npackage org.apache.commons.math.optimization.direct;\n\nimport java.util.Arrays;\n\nimport org.apache.commons.math.analysis.MultivariateFunction;\nimport org.apache.commons.math.exception.MathIllegalStateException;\nimport org.apache.commons.math.exception.NumberIsTooSmallException;\nimport org.apache.commons.math.exception.OutOfRangeException;\nimport org.apache.commons.math.exception.util.LocalizedFormats;\nimport org.apache.commons.math.linear.Array2DRowRealMatrix;\nimport org.apache.commons.math.linear.ArrayRealVector;\nimport org.apache.commons.math.linear.RealVector;\nimport org.apache.commons.math.optimization.GoalType;\nimport org.apache.commons.math.optimization.RealPointValuePair;\nimport org.apache.commons.math.optimization.MultivariateOptimizer;\n\n\npublic class BOBYQAOptimizer extends BaseAbstractMultivariateSimpleBoundsOptimizer<MultivariateFunction> implements MultivariateOptimizer { public static final int MINIMUM_PROBLEM_DIMENSION = 2; public static final double DEFAULT_INITIAL_RADIUS = 10.0; public static final double DEFAULT_STOPPING_RADIUS = 1E-8; private static final double ZERO = 0d; private static final double ONE = 1d; private static final double TWO = 2d; private static final double TEN = 10d; private static final double SIXTEEN = 16d; private static final double TWO_HUNDRED_FIFTY = 250d; private static final double MINUS_ONE = -ONE; private static final double HALF = ONE / 2; private static final double ONE_OVER_FOUR = ONE / 4; private static final double ONE_OVER_EIGHT = ONE / 8; private static final double ONE_OVER_TEN = ONE / 10; private static final double ONE_OVER_A_THOUSAND = ONE / 1000; private final int numberOfInterpolationPoints; private double initialTrustRegionRadius; private final double stoppingTrustRegionRadius; private boolean isMinimize; private ArrayRealVector currentBest; private double[] boundDifference; private int trustRegionCenterInterpolationPointIndex; private Array2DRowRealMatrix bMatrix; private Array2DRowRealMatrix zMatrix; private Array2DRowRealMatrix interpolationPoints; private ArrayRealVector originShift; private ArrayRealVector fAtInterpolationPoints; private ArrayRealVector trustRegionCenterOffset; private ArrayRealVector gradientAtTrustRegionCenter; private ArrayRealVector lowerDifference; private ArrayRealVector upperDifference; private ArrayRealVector modelSecondDerivativesParameters; private ArrayRealVector newPoint; private ArrayRealVector alternativeNewPoint; private ArrayRealVector trialStepPoint; private ArrayRealVector lagrangeValuesAtNewPoint; private ArrayRealVector modelSecondDerivativesValues; public BOBYQAOptimizer(int numberOfInterpolationPoints) {\n        this(numberOfInterpolationPoints,\n             DEFAULT_INITIAL_RADIUS,\n             DEFAULT_STOPPING_RADIUS);\n    }\n\n    \n    public BOBYQAOptimizer(int numberOfInterpolationPoints, double initialTrustRegionRadius, double stoppingTrustRegionRadius) {\n        this.numberOfInterpolationPoints = numberOfInterpolationPoints;\n        this.initialTrustRegionRadius = initialTrustRegionRadius;\n        this.stoppingTrustRegionRadius = stoppingTrustRegionRadius;\n    }\n\n    \n    @Override\n    protected RealPointValuePair doOptimize() {\n        final double[] lowerBound = getLowerBound();\n        final double[] upperBound = getUpperBound();\n\n        \n        setup(lowerBound, upperBound);\n\n        isMinimize = (getGoalType() == GoalType.MINIMIZE);\n        currentBest = new ArrayRealVector(getStartPoint());\n\n        final double value = bobyqa(lowerBound, upperBound);\n\n        return new RealPointValuePair(currentBest.getDataRef(),\n                                      isMinimize ? value : -value);\n    }\n\n    \n    private double bobyqa(double[] lowerBound, double[] upperBound) {\n        printMethod(); \n\n        final int n = currentBest.getDimension();\n\n        \n        \n        \n        \n        \n        \n\n        for (int j = 0; j < n; j++) {\n            final double boundDiff = boundDifference[j];\n            lowerDifference.setEntry(j, lowerBound[j] - currentBest.getEntry(j));\n            upperDifference.setEntry(j, upperBound[j] - currentBest.getEntry(j));\n            if (lowerDifference.getEntry(j) >= -initialTrustRegionRadius) {\n                if (lowerDifference.getEntry(j) >= ZERO) {\n                    currentBest.setEntry(j, lowerBound[j]);\n                    lowerDifference.setEntry(j, ZERO);\n                    upperDifference.setEntry(j, boundDiff);\n                } else {\n                    currentBest.setEntry(j, lowerBound[j] + initialTrustRegionRadius);\n                    lowerDifference.setEntry(j, -initialTrustRegionRadius);\n                    \n                    final double deltaOne = upperBound[j] - currentBest.getEntry(j);\n                    upperDifference.setEntry(j, Math.max(deltaOne, initialTrustRegionRadius));\n                }\n            } else if (upperDifference.getEntry(j) <= initialTrustRegionRadius) {\n                if (upperDifference.getEntry(j) <= ZERO) {\n                    currentBest.setEntry(j, upperBound[j]);\n                    lowerDifference.setEntry(j, -boundDiff);\n                    upperDifference.setEntry(j, ZERO);\n                } else {\n                    currentBest.setEntry(j, upperBound[j] - initialTrustRegionRadius);\n                    \n                    final double deltaOne = lowerBound[j] - currentBest.getEntry(j);\n                    final double deltaTwo = -initialTrustRegionRadius;\n                    lowerDifference.setEntry(j, Math.min(deltaOne, deltaTwo));\n                    upperDifference.setEntry(j, initialTrustRegionRadius);\n                }\n            }\n        }\n\n        \n\n        return bobyqb(lowerBound, upperBound);\n    } \n\n    \n\n    \n    private double bobyqb(double[] lowerBound, double[] upperBound) {\n        printMethod(); \n\n        final int n = currentBest.getDimension();\n        final int npt = numberOfInterpolationPoints;\n        final int np = n + 1;\n        final int nptm = npt - np;\n        final int nh = n * np / 2;\n\n        final ArrayRealVector work1 = new ArrayRealVector(n);\n        final ArrayRealVector work2 = new ArrayRealVector(npt);\n        final ArrayRealVector work3 = new ArrayRealVector(npt);\n\n        double cauchy = Double.NaN;\n        double alpha = Double.NaN;\n        double dsq = Double.NaN;\n        double crvmin = Double.NaN;\n\n        \n        \n\n        \n\n        \n        \n        \n        \n        \n        \n\n        trustRegionCenterInterpolationPointIndex = 0;\n\n        prelim(lowerBound, upperBound);\n        double xoptsq = ZERO;\n        for (int i = 0; i < n; i++) {\n            trustRegionCenterOffset.setEntry(i, interpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex, i));\n            \n            final double deltaOne = trustRegionCenterOffset.getEntry(i);\n            xoptsq += deltaOne * deltaOne;\n        }\n        double fsave = fAtInterpolationPoints.getEntry(0);\n        final int kbase = 0;\n\n        \n\n        int ntrits = 0;\n        int itest = 0;\n        int knew = 0;\n        int nfsav = getEvaluations();\n        double rho = initialTrustRegionRadius;\n        double delta = rho;\n        double diffa = ZERO;\n        double diffb = ZERO;\n        double diffc = ZERO;\n        double f = ZERO;\n        double beta = ZERO;\n        double adelt = ZERO;\n        double denom = ZERO;\n        double ratio = ZERO;\n        double dnorm = ZERO;\n        double scaden = ZERO;\n        double biglsq = ZERO;\n        double distsq = ZERO;\n\n        \n        \n\n        int state = 20;\n        for(;;) switch (state) {\n        case 20: {\n            printState(20); \n            if (trustRegionCenterInterpolationPointIndex != kbase) {\n                int ih = 0;\n                for (int j = 0; j < n; j++) {\n                    for (int i = 0; i <= j; i++) {\n                        if (i < j) {\n                            gradientAtTrustRegionCenter.setEntry(j,  gradientAtTrustRegionCenter.getEntry(j) + modelSecondDerivativesValues.getEntry(ih) * trustRegionCenterOffset.getEntry(i));\n                        }\n                        gradientAtTrustRegionCenter.setEntry(i,  gradientAtTrustRegionCenter.getEntry(i) + modelSecondDerivativesValues.getEntry(ih) * trustRegionCenterOffset.getEntry(j));\n                        ih++;\n                    }\n                }\n                if (getEvaluations() > npt) {\n                    for (int k = 0; k < npt; k++) {\n                        double temp = ZERO;\n                        for (int j = 0; j < n; j++) {\n                            temp += interpolationPoints.getEntry(k, j) * trustRegionCenterOffset.getEntry(j);\n                        }\n                        temp *= modelSecondDerivativesParameters.getEntry(k);\n                        for (int i = 0; i < n; i++) {\n                            gradientAtTrustRegionCenter.setEntry(i, gradientAtTrustRegionCenter.getEntry(i) + temp * interpolationPoints.getEntry(k, i));\n                        }\n                    }\n                    throw new PathIsExploredException(); \n                }\n            }\n\n            \n            \n            \n            \n            \n            \n\n        }\n        case 60: {\n            printState(60); \n            final ArrayRealVector gnew = new ArrayRealVector(n);\n            final ArrayRealVector xbdi = new ArrayRealVector(n);\n            final ArrayRealVector s = new ArrayRealVector(n);\n            final ArrayRealVector hs = new ArrayRealVector(n);\n            final ArrayRealVector hred = new ArrayRealVector(n);\n\n            final double[] dsqCrvmin = trsbox(delta, gnew, xbdi, s,\n                                              hs, hred);\n            dsq = dsqCrvmin[0];\n            crvmin = dsqCrvmin[1];\n\n            \n            double deltaOne = delta;\n            double deltaTwo = Math.sqrt(dsq);\n            dnorm = Math.min(deltaOne, deltaTwo);\n            if (dnorm < HALF * rho) {\n                ntrits = -1;\n                \n                deltaOne = TEN * rho;\n                distsq = deltaOne * deltaOne;\n                if (getEvaluations() <= nfsav + 2) {\n                    state = 650; break;\n                }\n\n                \n                \n                \n                \n                \n\n                \n                deltaOne = Math.max(diffa, diffb);\n                final double errbig = Math.max(deltaOne, diffc);\n                final double frhosq = rho * ONE_OVER_EIGHT * rho;\n                if (crvmin > ZERO &&\n                    errbig > frhosq * crvmin) {\n                    state = 650; break;\n                }\n                final double bdtol = errbig / rho;\n                for (int j = 0; j < n; j++) {\n                    double bdtest = bdtol;\n                    if (newPoint.getEntry(j) == lowerDifference.getEntry(j)) {\n                        bdtest = work1.getEntry(j);\n                    }\n                    if (newPoint.getEntry(j) == upperDifference.getEntry(j)) {\n                        bdtest = -work1.getEntry(j);\n                    }\n                    if (bdtest < bdtol) {\n                        double curv = modelSecondDerivativesValues.getEntry((j + j * j) / 2);\n                        for (int k = 0; k < npt; k++) {\n                            \n                            final double d1 = interpolationPoints.getEntry(k, j);\n                            curv += modelSecondDerivativesParameters.getEntry(k) * (d1 * d1);\n                        }\n                        bdtest += HALF * curv * rho;\n                        if (bdtest < bdtol) {\n                            state = 650; break;\n                        }\n                        throw new PathIsExploredException(); \n                    }\n                }\n                state = 680; break;\n            }\n            ++ntrits;\n\n            \n            \n            \n            \n            \n\n        }\n        case 90: {\n            printState(90); \n            if (dsq <= xoptsq * ONE_OVER_A_THOUSAND) {\n                final double fracsq = xoptsq * ONE_OVER_FOUR;\n                double sumpq = ZERO;\n                \n                \n                for (int k = 0; k < npt; k++) {\n                    sumpq += modelSecondDerivativesParameters.getEntry(k);\n                    double sum = -HALF * xoptsq;\n                    for (int i = 0; i < n; i++) {\n                        sum += interpolationPoints.getEntry(k, i) * trustRegionCenterOffset.getEntry(i);\n                    }\n                    \n                    work2.setEntry(k, sum);\n                    final double temp = fracsq - HALF * sum;\n                    for (int i = 0; i < n; i++) {\n                        work1.setEntry(i, bMatrix.getEntry(k, i));\n                        lagrangeValuesAtNewPoint.setEntry(i, sum * interpolationPoints.getEntry(k, i) + temp * trustRegionCenterOffset.getEntry(i));\n                        final int ip = npt + i;\n                        for (int j = 0; j <= i; j++) {\n                            bMatrix.setEntry(ip, j,\n                                          bMatrix.getEntry(ip, j)\n                                          + work1.getEntry(i) * lagrangeValuesAtNewPoint.getEntry(j)\n                                          + lagrangeValuesAtNewPoint.getEntry(i) * work1.getEntry(j));\n                        }\n                    }\n                }\n\n                \n\n                for (int m = 0; m < nptm; m++) {\n                    double sumz = ZERO;\n                    double sumw = ZERO;\n                    for (int k = 0; k < npt; k++) {\n                        sumz += zMatrix.getEntry(k, m);\n                        lagrangeValuesAtNewPoint.setEntry(k, work2.getEntry(k) * zMatrix.getEntry(k, m));\n                        sumw += lagrangeValuesAtNewPoint.getEntry(k);\n                    }\n                    for (int j = 0; j < n; j++) {\n                        double sum = (fracsq * sumz - HALF * sumw) * trustRegionCenterOffset.getEntry(j);\n                        for (int k = 0; k < npt; k++) {\n                            sum += lagrangeValuesAtNewPoint.getEntry(k) * interpolationPoints.getEntry(k, j);\n                        }\n                        work1.setEntry(j, sum);\n                        for (int k = 0; k < npt; k++) {\n                            bMatrix.setEntry(k, j,\n                                          bMatrix.getEntry(k, j)\n                                          + sum * zMatrix.getEntry(k, m));\n                        }\n                    }\n                    for (int i = 0; i < n; i++) {\n                        final int ip = i + npt;\n                        final double temp = work1.getEntry(i);\n                        for (int j = 0; j <= i; j++) {\n                            bMatrix.setEntry(ip, j,\n                                          bMatrix.getEntry(ip, j)\n                                          + temp * work1.getEntry(j));\n                        }\n                    }\n                }\n\n                \n                \n\n                int ih = 0;\n                for (int j = 0; j < n; j++) {\n                    work1.setEntry(j, -HALF * sumpq * trustRegionCenterOffset.getEntry(j));\n                    for (int k = 0; k < npt; k++) {\n                        work1.setEntry(j, work1.getEntry(j) + modelSecondDerivativesParameters.getEntry(k) * interpolationPoints.getEntry(k, j));\n                        interpolationPoints.setEntry(k, j, interpolationPoints.getEntry(k, j) - trustRegionCenterOffset.getEntry(j));\n                    }\n                    for (int i = 0; i <= j; i++) {\n                         modelSecondDerivativesValues.setEntry(ih,\n                                    modelSecondDerivativesValues.getEntry(ih)\n                                    + work1.getEntry(i) * trustRegionCenterOffset.getEntry(j)\n                                    + trustRegionCenterOffset.getEntry(i) * work1.getEntry(j));\n                        bMatrix.setEntry(npt + i, j, bMatrix.getEntry(npt + j, i));\n                        ih++;\n                    }\n                }\n                for (int i = 0; i < n; i++) {\n                    originShift.setEntry(i, originShift.getEntry(i) + trustRegionCenterOffset.getEntry(i));\n                    newPoint.setEntry(i, newPoint.getEntry(i) - trustRegionCenterOffset.getEntry(i));\n                    lowerDifference.setEntry(i, lowerDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i));\n                    upperDifference.setEntry(i, upperDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i));\n                    trustRegionCenterOffset.setEntry(i, ZERO);\n                }\n                xoptsq = ZERO;\n            }\n            if (ntrits == 0) {\n                state = 210; break;\n            }\n            state = 230; break;\n\n            \n            \n            \n            \n            \n            \n            \n            \n\n        }\n        case 210: {\n            printState(210); \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n\n            final double[] alphaCauchy = altmov(knew, adelt);\n            alpha = alphaCauchy[0];\n            cauchy = alphaCauchy[1];\n\n            for (int i = 0; i < n; i++) {\n                trialStepPoint.setEntry(i, newPoint.getEntry(i) - trustRegionCenterOffset.getEntry(i));\n            }\n\n            \n            \n            \n\n        }\n        case 230: {\n            printState(230); \n            for (int k = 0; k < npt; k++) {\n                double suma = ZERO;\n                double sumb = ZERO;\n                double sum = ZERO;\n                for (int j = 0; j < n; j++) {\n                    suma += interpolationPoints.getEntry(k, j) * trialStepPoint.getEntry(j);\n                    sumb += interpolationPoints.getEntry(k, j) * trustRegionCenterOffset.getEntry(j);\n                    sum += bMatrix.getEntry(k, j) * trialStepPoint.getEntry(j);\n                }\n                work3.setEntry(k, suma * (HALF * suma + sumb));\n                lagrangeValuesAtNewPoint.setEntry(k, sum);\n                work2.setEntry(k, suma);\n            }\n            beta = ZERO;\n            for (int m = 0; m < nptm; m++) {\n                double sum = ZERO;\n                for (int k = 0; k < npt; k++) {\n                    sum += zMatrix.getEntry(k, m) * work3.getEntry(k);\n                }\n                beta -= sum * sum;\n                for (int k = 0; k < npt; k++) {\n                    lagrangeValuesAtNewPoint.setEntry(k, lagrangeValuesAtNewPoint.getEntry(k) + sum * zMatrix.getEntry(k, m));\n                }\n            }\n            dsq = ZERO;\n            double bsum = ZERO;\n            double dx = ZERO;\n            for (int j = 0; j < n; j++) {\n                \n                final double d1 = trialStepPoint.getEntry(j);\n                dsq += d1 * d1;\n                double sum = ZERO;\n                for (int k = 0; k < npt; k++) {\n                    sum += work3.getEntry(k) * bMatrix.getEntry(k, j);\n                }\n                bsum += sum * trialStepPoint.getEntry(j);\n                final int jp = npt + j;\n                for (int i = 0; i < n; i++) {\n                    sum += bMatrix.getEntry(jp, i) * trialStepPoint.getEntry(i);\n                }\n                lagrangeValuesAtNewPoint.setEntry(jp, sum);\n                bsum += sum * trialStepPoint.getEntry(j);\n                dx += trialStepPoint.getEntry(j) * trustRegionCenterOffset.getEntry(j);\n            }\n\n            beta = dx * dx + dsq * (xoptsq + dx + dx + HALF * dsq) + beta - bsum; \n            \n            \n\n            lagrangeValuesAtNewPoint.setEntry(trustRegionCenterInterpolationPointIndex,\n                          lagrangeValuesAtNewPoint.getEntry(trustRegionCenterInterpolationPointIndex) + ONE);\n\n            \n            \n            \n\n            if (ntrits == 0) {\n                \n                final double d1 = lagrangeValuesAtNewPoint.getEntry(knew);\n                denom = d1 * d1 + alpha * beta;\n                if (denom < cauchy && cauchy > ZERO) {\n                    for (int i = 0; i < n; i++) {\n                        newPoint.setEntry(i, alternativeNewPoint.getEntry(i));\n                        trialStepPoint.setEntry(i, newPoint.getEntry(i) - trustRegionCenterOffset.getEntry(i));\n                    }\n                    cauchy = ZERO; \n                    state = 230; break;\n                }\n                \n                \n                \n                \n                \n\n            } else {\n                final double delsq = delta * delta;\n                scaden = ZERO;\n                biglsq = ZERO;\n                knew = 0;\n                for (int k = 0; k < npt; k++) {\n                    if (k == trustRegionCenterInterpolationPointIndex) {\n                        continue;\n                    }\n                    double hdiag = ZERO;\n                    for (int m = 0; m < nptm; m++) {\n                        \n                        final double d1 = zMatrix.getEntry(k, m);\n                        hdiag += d1 * d1;\n                    }\n                    \n                    final double d2 = lagrangeValuesAtNewPoint.getEntry(k);\n                    final double den = beta * hdiag + d2 * d2;\n                    distsq = ZERO;\n                    for (int j = 0; j < n; j++) {\n                        \n                        final double d3 = interpolationPoints.getEntry(k, j) - trustRegionCenterOffset.getEntry(j);\n                        distsq += d3 * d3;\n                    }\n                    \n                    \n                    final double d4 = distsq / delsq;\n                    final double temp = Math.max(ONE, d4 * d4);\n                    if (temp * den > scaden) {\n                        scaden = temp * den;\n                        knew = k;\n                        denom = den;\n                    }\n                    \n                    \n                    final double d5 = lagrangeValuesAtNewPoint.getEntry(k);\n                    biglsq = Math.max(biglsq, temp * (d5 * d5));\n                }\n            }\n\n            \n            \n\n            \n            \n\n        }\n        case 360: {\n            printState(360); \n            for (int i = 0; i < n; i++) {\n                \n                \n                final double d3 = lowerBound[i];\n                final double d4 = originShift.getEntry(i) + newPoint.getEntry(i);\n                final double d1 = Math.max(d3, d4);\n                final double d2 = upperBound[i];\n                currentBest.setEntry(i, Math.min(d1, d2));\n                if (newPoint.getEntry(i) == lowerDifference.getEntry(i)) {\n                    currentBest.setEntry(i, lowerBound[i]);\n                }\n                if (newPoint.getEntry(i) == upperDifference.getEntry(i)) {\n                    currentBest.setEntry(i, upperBound[i]);\n                }\n            }\n\n            f = computeObjectiveValue(currentBest.toArray());\n\n            if (!isMinimize)\n                f = -f;\n            if (ntrits == -1) {\n                fsave = f;\n                state = 720; break;\n            }\n\n            \n            \n\n            final double fopt = fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex);\n            double vquad = ZERO;\n            int ih = 0;\n            for (int j = 0; j < n; j++) {\n                vquad += trialStepPoint.getEntry(j) * gradientAtTrustRegionCenter.getEntry(j);\n                for (int i = 0; i <= j; i++) {\n                    double temp = trialStepPoint.getEntry(i) * trialStepPoint.getEntry(j);\n                    if (i == j) {\n                        temp *= HALF;\n                    }\n                    vquad += modelSecondDerivativesValues.getEntry(ih) * temp;\n                    ih++;\n               }\n            }\n            for (int k = 0; k < npt; k++) {\n                \n                final double d1 = work2.getEntry(k);\n                final double d2 = d1 * d1; \n                vquad += HALF * modelSecondDerivativesParameters.getEntry(k) * d2;\n            }\n            final double diff = f - fopt - vquad;\n            diffc = diffb;\n            diffb = diffa;\n            diffa = Math.abs(diff);\n            if (dnorm > rho) {\n                nfsav = getEvaluations();\n            }\n\n            \n\n            if (ntrits > 0) {\n                if (vquad >= ZERO) {\n                    throw new MathIllegalStateException(LocalizedFormats.TRUST_REGION_STEP_FAILED, vquad);\n                }\n                ratio = (f - fopt) / vquad;\n                final double hDelta = HALF * delta;\n                if (ratio <= ONE_OVER_TEN) {\n                    \n                    delta = Math.min(hDelta, dnorm);\n                } else if (ratio <= .7) {\n                    \n                    delta = Math.max(hDelta, dnorm);\n                } else {\n                    \n                    delta = Math.max(hDelta, 2 * dnorm);\n                }\n                if (delta <= rho * 1.5) {\n                    delta = rho;\n                }\n\n                \n\n                if (f < fopt) {\n                    final int ksav = knew;\n                    final double densav = denom;\n                    final double delsq = delta * delta;\n                    scaden = ZERO;\n                    biglsq = ZERO;\n                    knew = 0;\n                    for (int k = 0; k < npt; k++) {\n                        double hdiag = ZERO;\n                        for (int m = 0; m < nptm; m++) {\n                            \n                            final double d1 = zMatrix.getEntry(k, m);\n                            hdiag += d1 * d1;\n                        }\n                        \n                        final double d1 = lagrangeValuesAtNewPoint.getEntry(k);\n                        final double den = beta * hdiag + d1 * d1;\n                        distsq = ZERO;\n                        for (int j = 0; j < n; j++) {\n                            \n                            final double d2 = interpolationPoints.getEntry(k, j) - newPoint.getEntry(j);\n                            distsq += d2 * d2;\n                        }\n                        \n                        \n                        final double d3 = distsq / delsq;\n                        final double temp = Math.max(ONE, d3 * d3);\n                        if (temp * den > scaden) {\n                            scaden = temp * den;\n                            knew = k;\n                            denom = den;\n                        }\n                        \n                        \n                        final double d4 = lagrangeValuesAtNewPoint.getEntry(k);\n                        final double d5 = temp * (d4 * d4);\n                        biglsq = Math.max(biglsq, d5);\n                    }\n                    if (scaden <= HALF * biglsq) {\n                        knew = ksav;\n                        denom = densav;\n                    }\n                }\n            }\n\n            \n            \n\n            update(beta, denom, knew);\n\n            ih = 0;\n            final double pqold = modelSecondDerivativesParameters.getEntry(knew);\n            modelSecondDerivativesParameters.setEntry(knew, ZERO);\n            for (int i = 0; i < n; i++) {\n                final double temp = pqold * interpolationPoints.getEntry(knew, i);\n                for (int j = 0; j <= i; j++) {\n                    modelSecondDerivativesValues.setEntry(ih, modelSecondDerivativesValues.getEntry(ih) + temp * interpolationPoints.getEntry(knew, j));\n                    ih++;\n                }\n            }\n            for (int m = 0; m < nptm; m++) {\n                final double temp = diff * zMatrix.getEntry(knew, m);\n                for (int k = 0; k < npt; k++) {\n                    modelSecondDerivativesParameters.setEntry(k, modelSecondDerivativesParameters.getEntry(k) + temp * zMatrix.getEntry(k, m));\n                }\n            }\n\n            \n            \n\n            fAtInterpolationPoints.setEntry(knew,  f);\n            for (int i = 0; i < n; i++) {\n                interpolationPoints.setEntry(knew, i, newPoint.getEntry(i));\n                work1.setEntry(i, bMatrix.getEntry(knew, i));\n            }\n            for (int k = 0; k < npt; k++) {\n                double suma = ZERO;\n                for (int m = 0; m < nptm; m++) {\n                    suma += zMatrix.getEntry(knew, m) * zMatrix.getEntry(k, m);\n                }\n                double sumb = ZERO;\n                for (int j = 0; j < n; j++) {\n                    sumb += interpolationPoints.getEntry(k, j) * trustRegionCenterOffset.getEntry(j);\n                }\n                final double temp = suma * sumb;\n                for (int i = 0; i < n; i++) {\n                    work1.setEntry(i, work1.getEntry(i) + temp * interpolationPoints.getEntry(k, i));\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                gradientAtTrustRegionCenter.setEntry(i, gradientAtTrustRegionCenter.getEntry(i) + diff * work1.getEntry(i));\n            }\n\n            \n\n            if (f < fopt) {\n                trustRegionCenterInterpolationPointIndex = knew;\n                xoptsq = ZERO;\n                ih = 0;\n                for (int j = 0; j < n; j++) {\n                    trustRegionCenterOffset.setEntry(j, newPoint.getEntry(j));\n                    \n                    final double d1 = trustRegionCenterOffset.getEntry(j);\n                    xoptsq += d1 * d1;\n                    for (int i = 0; i <= j; i++) {\n                        if (i < j) {\n                            gradientAtTrustRegionCenter.setEntry(j, gradientAtTrustRegionCenter.getEntry(j) + modelSecondDerivativesValues.getEntry(ih) * trialStepPoint.getEntry(i));\n                        }\n                        gradientAtTrustRegionCenter.setEntry(i, gradientAtTrustRegionCenter.getEntry(i) + modelSecondDerivativesValues.getEntry(ih) * trialStepPoint.getEntry(j));\n                        ih++;\n                    }\n                }\n                for (int k = 0; k < npt; k++) {\n                    double temp = ZERO;\n                    for (int j = 0; j < n; j++) {\n                        temp += interpolationPoints.getEntry(k, j) * trialStepPoint.getEntry(j);\n                    }\n                    temp *= modelSecondDerivativesParameters.getEntry(k);\n                    for (int i = 0; i < n; i++) {\n                        gradientAtTrustRegionCenter.setEntry(i, gradientAtTrustRegionCenter.getEntry(i) + temp * interpolationPoints.getEntry(k, i));\n                    }\n                }\n            }\n\n            \n            \n            \n\n            if (ntrits > 0) {\n                for (int k = 0; k < npt; k++) {\n                    lagrangeValuesAtNewPoint.setEntry(k, fAtInterpolationPoints.getEntry(k) - fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex));\n                    work3.setEntry(k, ZERO);\n                }\n                for (int j = 0; j < nptm; j++) {\n                    double sum = ZERO;\n                    for (int k = 0; k < npt; k++) {\n                        sum += zMatrix.getEntry(k, j) * lagrangeValuesAtNewPoint.getEntry(k);\n                    }\n                    for (int k = 0; k < npt; k++) {\n                        work3.setEntry(k, work3.getEntry(k) + sum * zMatrix.getEntry(k, j));\n                    }\n                }\n                for (int k = 0; k < npt; k++) {\n                    double sum = ZERO;\n                    for (int j = 0; j < n; j++) {\n                        sum += interpolationPoints.getEntry(k, j) * trustRegionCenterOffset.getEntry(j);\n                    }\n                    work2.setEntry(k, work3.getEntry(k));\n                    work3.setEntry(k, sum * work3.getEntry(k));\n                }\n                double gqsq = ZERO;\n                double gisq = ZERO;\n                for (int i = 0; i < n; i++) {\n                    double sum = ZERO;\n                    for (int k = 0; k < npt; k++) {\n                        sum += bMatrix.getEntry(k, i) *\n                            lagrangeValuesAtNewPoint.getEntry(k) + interpolationPoints.getEntry(k, i) * work3.getEntry(k);\n                    }\n                    if (trustRegionCenterOffset.getEntry(i) == lowerDifference.getEntry(i)) {\n                        \n                        \n                        final double d1 = Math.min(ZERO, gradientAtTrustRegionCenter.getEntry(i));\n                        gqsq += d1 * d1;\n                        \n                        final double d2 = Math.min(ZERO, sum);\n                        gisq += d2 * d2;\n                    } else if (trustRegionCenterOffset.getEntry(i) == upperDifference.getEntry(i)) {\n                        \n                        \n                        final double d1 = Math.max(ZERO, gradientAtTrustRegionCenter.getEntry(i));\n                        gqsq += d1 * d1;\n                        \n                        final double d2 = Math.max(ZERO, sum);\n                        gisq += d2 * d2;\n                    } else {\n                        \n                        final double d1 = gradientAtTrustRegionCenter.getEntry(i);\n                        gqsq += d1 * d1;\n                        gisq += sum * sum;\n                    }\n                    lagrangeValuesAtNewPoint.setEntry(npt + i, sum);\n                }\n\n                \n                \n\n                ++itest;\n                if (gqsq < TEN * gisq) {\n                    itest = 0;\n                }\n                if (itest >= 3) {\n                    for (int i = 0, max = Math.max(npt, nh); i < max; i++) {\n                        if (i < n) {\n                            gradientAtTrustRegionCenter.setEntry(i, lagrangeValuesAtNewPoint.getEntry(npt + i));\n                        }\n                        if (i < npt) {\n                            modelSecondDerivativesParameters.setEntry(i, work2.getEntry(i));\n                        }\n                        if (i < nh) {\n                            modelSecondDerivativesValues.setEntry(i, ZERO);\n                        }\n                        itest = 0;\n                    }\n                }\n            }\n\n            \n            \n            \n\n            if (ntrits == 0) {\n                state = 60; break;\n            }\n            if (f <= fopt + ONE_OVER_TEN * vquad) {\n                state = 60; break;\n            }\n\n            \n            \n\n            \n            \n            final double d1 = TWO * delta;\n            \n            final double d2 = TEN * rho;\n            distsq = Math.max(d1 * d1, d2 * d2);\n        }\n        case 650: {\n            printState(650); \n            knew = -1;\n            for (int k = 0; k < npt; k++) {\n                double sum = ZERO;\n                for (int j = 0; j < n; j++) {\n                    \n                    final double d1 = interpolationPoints.getEntry(k, j) - trustRegionCenterOffset.getEntry(j);\n                    sum += d1 * d1;\n                }\n                if (sum > distsq) {\n                    knew = k;\n                    distsq = sum;\n                }\n            }\n\n            \n            \n            \n            \n            \n\n            if (knew >= 0) {\n                final double dist = Math.sqrt(distsq);\n                if (ntrits == -1) {\n                    \n                    delta = Math.min(ONE_OVER_TEN * delta, HALF * dist);\n                    if (delta <= rho * 1.5) {\n                        delta = rho;\n                    }\n                }\n                ntrits = 0;\n                \n                \n                final double d1 = Math.min(ONE_OVER_TEN * dist, delta);\n                adelt = Math.max(d1, rho);\n                dsq = adelt * adelt;\n                state = 90; break;\n            }\n            if (ntrits == -1) {\n                state = 680; break;\n            }\n            if (ratio > ZERO) {\n                state = 60; break;\n            }\n            if (Math.max(delta, dnorm) > rho) {\n                state = 60; break;\n            }\n\n            \n            \n        }\n        case 680: {\n            printState(680); \n            if (rho > stoppingTrustRegionRadius) {\n                delta = HALF * rho;\n                ratio = rho / stoppingTrustRegionRadius;\n                if (ratio <= SIXTEEN) {\n                    rho = stoppingTrustRegionRadius;\n                } else if (ratio <= TWO_HUNDRED_FIFTY) {\n                    rho = Math.sqrt(ratio) * stoppingTrustRegionRadius;\n                } else {\n                    rho *= ONE_OVER_TEN;\n                }\n                delta = Math.max(delta, rho);\n                ntrits = 0;\n                nfsav = getEvaluations();\n                state = 60; break;\n            }\n\n            \n            \n\n            if (ntrits == -1) {\n                state = 360; break;\n            }\n        }\n        case 720: {\n            printState(720); \n            if (fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex) <= fsave) {\n                for (int i = 0; i < n; i++) {\n                    \n                    \n                    final double d3 = lowerBound[i];\n                    final double d4 = originShift.getEntry(i) + trustRegionCenterOffset.getEntry(i);\n                    final double d1 = Math.max(d3, d4);\n                    final double d2 = upperBound[i];\n                    currentBest.setEntry(i, Math.min(d1, d2));\n                    if (trustRegionCenterOffset.getEntry(i) == lowerDifference.getEntry(i)) {\n                        currentBest.setEntry(i, lowerBound[i]);\n                    }\n                    if (trustRegionCenterOffset.getEntry(i) == upperDifference.getEntry(i)) {\n                        currentBest.setEntry(i, upperBound[i]);\n                    }\n                }\n                f = fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex);\n            }\n            return f;\n        }\n        default: {\n            throw new MathIllegalStateException(LocalizedFormats.SIMPLE_MESSAGE, \"bobyqb\");\n        }}\n    } \n\n    \n\n    \n    private double[] altmov( int knew, double adelt ) {\n        printMethod(); \n\n        final int n = currentBest.getDimension();\n        final int npt = numberOfInterpolationPoints;\n\n        final ArrayRealVector glag = new ArrayRealVector(n);\n        final ArrayRealVector hcol = new ArrayRealVector(npt);\n\n        final ArrayRealVector work1 = new ArrayRealVector(n);\n        final ArrayRealVector work2 = new ArrayRealVector(n);\n\n        for (int k = 0; k < npt; k++) {\n            hcol.setEntry(k, ZERO);\n        }\n        for (int j = 0, max = npt - n - 1; j < max; j++) {\n            final double tmp = zMatrix.getEntry(knew, j);\n            for (int k = 0; k < npt; k++) {\n                hcol.setEntry(k, hcol.getEntry(k) + tmp * zMatrix.getEntry(k, j));\n            }\n        }\n        final double alpha = hcol.getEntry(knew);\n        final double ha = HALF * alpha;\n\n        \n\n        for (int i = 0; i < n; i++) {\n            glag.setEntry(i, bMatrix.getEntry(knew, i));\n        }\n        for (int k = 0; k < npt; k++) {\n            double tmp = ZERO;\n            for (int j = 0; j < n; j++) {\n                tmp += interpolationPoints.getEntry(k, j) * trustRegionCenterOffset.getEntry(j);\n            }\n            tmp *= hcol.getEntry(k);\n            for (int i = 0; i < n; i++) {\n                glag.setEntry(i, glag.getEntry(i) + tmp * interpolationPoints.getEntry(k, i));\n            }\n        }\n\n        \n        \n        \n        \n        \n\n        double presav = ZERO;\n        double step = Double.NaN;\n        int ksav = 0;\n        int ibdsav = 0;\n        double stpsav = 0;\n        for (int k = 0; k < npt; k++) {\n            if (k == trustRegionCenterInterpolationPointIndex) {\n                continue;\n            }\n            double dderiv = ZERO;\n            double distsq = ZERO;\n            for (int i = 0; i < n; i++) {\n                final double tmp = interpolationPoints.getEntry(k, i) - trustRegionCenterOffset.getEntry(i);\n                dderiv += glag.getEntry(i) * tmp;\n                distsq += tmp * tmp;\n            }\n            double subd = adelt / Math.sqrt(distsq);\n            double slbd = -subd;\n            int ilbd = 0;\n            int iubd = 0;\n            final double sumin = Math.min(ONE, subd);\n\n            \n\n            for (int i = 0; i < n; i++) {\n                final double tmp = interpolationPoints.getEntry(k, i) - trustRegionCenterOffset.getEntry(i);\n                if (tmp > ZERO) {\n                    if (slbd * tmp < lowerDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i)) {\n                        slbd = (lowerDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i)) / tmp;\n                        ilbd = -i - 1;\n                    }\n                    if (subd * tmp > upperDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i)) {\n                        \n                        subd = Math.max(sumin,\n                                        (upperDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i)) / tmp);\n                        iubd = i + 1;\n                    }\n                } else if (tmp < ZERO) {\n                    if (slbd * tmp > upperDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i)) {\n                        slbd = (upperDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i)) / tmp;\n                        ilbd = i + 1;\n                    }\n                    if (subd * tmp < lowerDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i)) {\n                        \n                        subd = Math.max(sumin,\n                                        (lowerDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i)) / tmp);\n                        iubd = -i - 1;\n                    }\n                }\n            }\n\n            \n            \n\n            step = slbd;\n            int isbd = ilbd;\n            double vlag = Double.NaN;\n            if (k == knew) {\n                final double diff = dderiv - ONE;\n                vlag = slbd * (dderiv - slbd * diff);\n                final double d1 = subd * (dderiv - subd * diff);\n                if (Math.abs(d1) > Math.abs(vlag)) {\n                    step = subd;\n                    vlag = d1;\n                    isbd = iubd;\n                }\n                final double d2 = HALF * dderiv;\n                final double d3 = d2 - diff * slbd;\n                final double d4 = d2 - diff * subd;\n                if (d3 * d4 < ZERO) {\n                    final double d5 = d2 * d2 / diff;\n                    if (Math.abs(d5) > Math.abs(vlag)) {\n                        step = d2 / diff;\n                        vlag = d5;\n                        isbd = 0;\n                    }\n                }\n\n                \n\n            } else {\n                vlag = slbd * (ONE - slbd);\n                final double tmp = subd * (ONE - subd);\n                if (Math.abs(tmp) > Math.abs(vlag)) {\n                    step = subd;\n                    vlag = tmp;\n                    isbd = iubd;\n                }\n                if (subd > HALF) {\n                    if (Math.abs(vlag) < ONE_OVER_FOUR) {\n                        step = HALF;\n                        vlag = ONE_OVER_FOUR;\n                        isbd = 0;\n                    }\n                }\n                vlag *= dderiv;\n            }\n\n            \n\n            final double tmp = step * (ONE - step) * distsq;\n            final double predsq = vlag * vlag * (vlag * vlag + ha * tmp * tmp);\n            if (predsq > presav) {\n                presav = predsq;\n                ksav = k;\n                stpsav = step;\n                ibdsav = isbd;\n            }\n        }\n\n        \n\n        for (int i = 0; i < n; i++) {\n            final double tmp = trustRegionCenterOffset.getEntry(i) + stpsav * (interpolationPoints.getEntry(ksav, i) - trustRegionCenterOffset.getEntry(i));\n            newPoint.setEntry(i, Math.max(lowerDifference.getEntry(i),\n                                      Math.min(upperDifference.getEntry(i), tmp)));\n        }\n        if (ibdsav < 0) {\n            newPoint.setEntry(-ibdsav - 1, lowerDifference.getEntry(-ibdsav - 1));\n        }\n        if (ibdsav > 0) {\n            newPoint.setEntry(ibdsav - 1, upperDifference.getEntry(ibdsav - 1));\n        }\n\n        \n        \n        \n\n        final double bigstp = adelt + adelt;\n        int iflag = 0;\n        double cauchy = Double.NaN;\n        double csave = ZERO;\n        while (true) {\n            double wfixsq = ZERO;\n            double ggfree = ZERO;\n            for (int i = 0; i < n; i++) {\n                final double glagValue = glag.getEntry(i);\n                work1.setEntry(i, ZERO);\n                if (Math.min(trustRegionCenterOffset.getEntry(i) - lowerDifference.getEntry(i), glagValue) > ZERO ||\n                    Math.max(trustRegionCenterOffset.getEntry(i) - upperDifference.getEntry(i), glagValue) < ZERO) {\n                    work1.setEntry(i, bigstp);\n                    \n                    ggfree += glagValue * glagValue;\n                }\n            }\n            if (ggfree == ZERO) {\n                return new double[] { alpha, ZERO };\n            }\n\n            \n            final double tmp1 = adelt * adelt - wfixsq;\n            if (tmp1 > ZERO) {\n                step = Math.sqrt(tmp1 / ggfree);\n                ggfree = ZERO;\n                for (int i = 0; i < n; i++) {\n                    if (work1.getEntry(i) == bigstp) {\n                        final double tmp2 = trustRegionCenterOffset.getEntry(i) - step * glag.getEntry(i);\n                        if (tmp2 <= lowerDifference.getEntry(i)) {\n                            work1.setEntry(i, lowerDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i));\n                            \n                            final double d1 = work1.getEntry(i);\n                            wfixsq += d1 * d1;\n                        } else if (tmp2 >= upperDifference.getEntry(i)) {\n                            work1.setEntry(i, upperDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i));\n                            \n                            final double d1 = work1.getEntry(i);\n                            wfixsq += d1 * d1;\n                        } else {\n                            \n                            final double d1 = glag.getEntry(i);\n                            ggfree += d1 * d1;\n                        }\n                    }\n                }\n            }\n\n            \n            \n\n            double gw = ZERO;\n            for (int i = 0; i < n; i++) {\n                final double glagValue = glag.getEntry(i);\n                if (work1.getEntry(i) == bigstp) {\n                    work1.setEntry(i, -step * glagValue);\n                    final double min = Math.min(upperDifference.getEntry(i),\n                                                trustRegionCenterOffset.getEntry(i) + work1.getEntry(i));\n                    alternativeNewPoint.setEntry(i, Math.max(lowerDifference.getEntry(i), min));\n                } else if (work1.getEntry(i) == ZERO) {\n                    alternativeNewPoint.setEntry(i, trustRegionCenterOffset.getEntry(i));\n                } else if (glagValue > ZERO) {\n                    alternativeNewPoint.setEntry(i, lowerDifference.getEntry(i));\n                } else {\n                    alternativeNewPoint.setEntry(i, upperDifference.getEntry(i));\n                }\n                gw += glagValue * work1.getEntry(i);\n            }\n\n            \n            \n            \n            \n\n            double curv = ZERO;\n            for (int k = 0; k < npt; k++) {\n                double tmp = ZERO;\n                for (int j = 0; j < n; j++) {\n                    tmp += interpolationPoints.getEntry(k, j) * work1.getEntry(j);\n                }\n                curv += hcol.getEntry(k) * tmp * tmp;\n            }\n            if (iflag == 1) {\n                curv = -curv;\n            }\n            if (curv > -gw &&\n                curv < -gw * (ONE + Math.sqrt(TWO))) {\n                final double scale = -gw / curv;\n                for (int i = 0; i < n; i++) {\n                    final double tmp = trustRegionCenterOffset.getEntry(i) + scale * work1.getEntry(i);\n                    alternativeNewPoint.setEntry(i, Math.max(lowerDifference.getEntry(i),\n                                              Math.min(upperDifference.getEntry(i), tmp)));\n                }\n                \n                final double d1 = HALF * gw * scale;\n                cauchy = d1 * d1;\n            } else {\n                \n                final double d1 = gw + HALF * curv;\n                cauchy = d1 * d1;\n            }\n\n            \n            \n            \n\n            if (iflag == 0) {\n                for (int i = 0; i < n; i++) {\n                    glag.setEntry(i, -glag.getEntry(i));\n                    work2.setEntry(i, alternativeNewPoint.getEntry(i));\n                }\n                csave = cauchy;\n                iflag = 1;\n            } else {\n                break;\n            }\n        }\n        if (csave > cauchy) {\n            for (int i = 0; i < n; i++) {\n                alternativeNewPoint.setEntry(i, work2.getEntry(i));\n            }\n            cauchy = csave;\n        }\n\n        return new double[] { alpha, cauchy };\n    } \n\n    \n\n    \n    private void prelim(double[] lowerBound, double[] upperBound) {\n        printMethod(); \n\n        final int n = currentBest.getDimension();\n        final int npt = numberOfInterpolationPoints;\n        final int ndim = bMatrix.getRowDimension();\n\n        final double rhosq = initialTrustRegionRadius * initialTrustRegionRadius;\n        final double recip = 1d / rhosq;\n        final int np = n + 1;\n\n        \n        \n\n        for (int j = 0; j < n; j++) {\n            originShift.setEntry(j, currentBest.getEntry(j));\n            for (int k = 0; k < npt; k++) {\n                interpolationPoints.setEntry(k, j, ZERO);\n            }\n            for (int i = 0; i < ndim; i++) {\n                bMatrix.setEntry(i, j, ZERO);\n            }\n        }\n        for (int i = 0, max = n * np / 2; i < max; i++) {\n            modelSecondDerivativesValues.setEntry(i, ZERO);\n        }\n        for (int k = 0; k < npt; k++) {\n            modelSecondDerivativesParameters.setEntry(k, ZERO);\n            for (int j = 0, max = npt - np; j < max; j++) {\n                zMatrix.setEntry(k, j, ZERO);\n            }\n        }\n\n        \n        \n        \n\n        int ipt = 0;\n        int jpt = 0;\n        double fbeg = Double.NaN;\n        do {\n            final int nfm = getEvaluations();\n            final int nfx = nfm - n;\n            final int nfmm = nfm - 1;\n            final int nfxm = nfx - 1;\n            double stepa = 0;\n            double stepb = 0;\n            if (nfm <= 2 * n) {\n                if (nfm >= 1 &&\n                    nfm <= n) {\n                    stepa = initialTrustRegionRadius;\n                    if (upperDifference.getEntry(nfmm) == ZERO) {\n                        stepa = -stepa;\n                        throw new PathIsExploredException(); \n                    }\n                    interpolationPoints.setEntry(nfm, nfmm, stepa);\n                } else if (nfm > n) {\n                    stepa = interpolationPoints.getEntry(nfx, nfxm);\n                    stepb = -initialTrustRegionRadius;\n                    if (lowerDifference.getEntry(nfxm) == ZERO) {\n                        stepb = Math.min(TWO * initialTrustRegionRadius, upperDifference.getEntry(nfxm));\n                        throw new PathIsExploredException(); \n                    }\n                    if (upperDifference.getEntry(nfxm) == ZERO) {\n                        stepb = Math.max(-TWO * initialTrustRegionRadius, lowerDifference.getEntry(nfxm));\n                        throw new PathIsExploredException(); \n                    }\n                    interpolationPoints.setEntry(nfm, nfxm, stepb);\n                }\n            } else {\n                final int tmp1 = (nfm - np) / n;\n                jpt = nfm - tmp1 * n - n;\n                ipt = jpt + tmp1;\n                if (ipt > n) {\n                    final int tmp2 = jpt;\n                    jpt = ipt - n;\n                    ipt = tmp2;\n\n                }\n                final int iptMinus1 = ipt - 1;\n                final int jptMinus1 = jpt - 1;\n                interpolationPoints.setEntry(nfm, iptMinus1, interpolationPoints.getEntry(ipt, iptMinus1));\n                interpolationPoints.setEntry(nfm, jptMinus1, interpolationPoints.getEntry(jpt, jptMinus1));\n            }\n\n            \n            \n\n            for (int j = 0; j < n; j++) {\n                currentBest.setEntry(j, Math.min(Math.max(lowerBound[j],\n                                                          originShift.getEntry(j) + interpolationPoints.getEntry(nfm, j)),\n                                                 upperBound[j]));\n                if (interpolationPoints.getEntry(nfm, j) == lowerDifference.getEntry(j)) {\n                    currentBest.setEntry(j, lowerBound[j]);\n                }\n                if (interpolationPoints.getEntry(nfm, j) == upperDifference.getEntry(j)) {\n                    currentBest.setEntry(j, upperBound[j]);\n                }\n            }\n\n            final double objectiveValue = computeObjectiveValue(currentBest.toArray());\n            final double f = isMinimize ? objectiveValue : -objectiveValue;\n            final int numEval = getEvaluations(); \n            fAtInterpolationPoints.setEntry(nfm, f);\n\n            if (numEval == 1) {\n                fbeg = f;\n                trustRegionCenterInterpolationPointIndex = 0;\n            } else if (f < fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex)) {\n                trustRegionCenterInterpolationPointIndex = nfm;\n            }\n\n            \n            \n            \n            \n            \n\n            if (numEval <= 2 * n + 1) {\n                if (numEval >= 2 &&\n                    numEval <= n + 1) {\n                    gradientAtTrustRegionCenter.setEntry(nfmm, (f - fbeg) / stepa);\n                    if (npt < numEval + n) {\n                        final double oneOverStepA = ONE / stepa;\n                        bMatrix.setEntry(0, nfmm, -oneOverStepA);\n                        bMatrix.setEntry(nfm, nfmm, oneOverStepA);\n                        bMatrix.setEntry(npt + nfmm, nfmm, -HALF * rhosq);\n                        throw new PathIsExploredException(); \n                    }\n                } else if (numEval >= n + 2) {\n                    final int ih = nfx * (nfx + 1) / 2 - 1;\n                    final double tmp = (f - fbeg) / stepb;\n                    final double diff = stepb - stepa;\n                    modelSecondDerivativesValues.setEntry(ih, TWO * (tmp - gradientAtTrustRegionCenter.getEntry(nfxm)) / diff);\n                    gradientAtTrustRegionCenter.setEntry(nfxm, (gradientAtTrustRegionCenter.getEntry(nfxm) * stepb - tmp * stepa) / diff);\n                    if (stepa * stepb < ZERO) {\n                        if (f < fAtInterpolationPoints.getEntry(nfm - n)) {\n                            fAtInterpolationPoints.setEntry(nfm, fAtInterpolationPoints.getEntry(nfm - n));\n                            fAtInterpolationPoints.setEntry(nfm - n, f);\n                            if (trustRegionCenterInterpolationPointIndex == nfm) {\n                                trustRegionCenterInterpolationPointIndex = nfm - n;\n                            }\n                            interpolationPoints.setEntry(nfm - n, nfxm, stepb);\n                            interpolationPoints.setEntry(nfm, nfxm, stepa);\n                        }\n                    }\n                    bMatrix.setEntry(0, nfxm, -(stepa + stepb) / (stepa * stepb));\n                    bMatrix.setEntry(nfm, nfxm, -HALF / interpolationPoints.getEntry(nfm - n, nfxm));\n                    bMatrix.setEntry(nfm - n, nfxm,\n                                  -bMatrix.getEntry(0, nfxm) - bMatrix.getEntry(nfm, nfxm));\n                    zMatrix.setEntry(0, nfxm, Math.sqrt(TWO) / (stepa * stepb));\n                    zMatrix.setEntry(nfm, nfxm, Math.sqrt(HALF) / rhosq);\n                    \n                    zMatrix.setEntry(nfm - n, nfxm,\n                                  -zMatrix.getEntry(0, nfxm) - zMatrix.getEntry(nfm, nfxm));\n                }\n\n                \n                \n\n            } else {\n                zMatrix.setEntry(0, nfxm, recip);\n                zMatrix.setEntry(nfm, nfxm, recip);\n                zMatrix.setEntry(ipt, nfxm, -recip);\n                zMatrix.setEntry(jpt, nfxm, -recip);\n\n                final int ih = ipt * (ipt - 1) / 2 + jpt - 1;\n                final double tmp = interpolationPoints.getEntry(nfm, ipt - 1) * interpolationPoints.getEntry(nfm, jpt - 1);\n                modelSecondDerivativesValues.setEntry(ih, (fbeg - fAtInterpolationPoints.getEntry(ipt) - fAtInterpolationPoints.getEntry(jpt) + f) / tmp);\n\n            }\n        } while (getEvaluations() < npt);\n    } \n\n\n    \n\n    \n    private double[] trsbox( double delta, ArrayRealVector gnew, ArrayRealVector xbdi, ArrayRealVector s, ArrayRealVector hs, ArrayRealVector hred ) {\n        printMethod(); \n\n        final int n = currentBest.getDimension();\n        final int npt = numberOfInterpolationPoints;\n\n        double dsq = Double.NaN;\n        double crvmin = Double.NaN;\n\n        \n        double ds;\n        int iu;\n        double dhd, dhs, cth, shs, sth, ssq, beta=0, sdec, blen;\n        int iact = -1;\n        int nact = 0;\n        double angt = 0, qred;\n        int isav;\n        double temp = 0, xsav = 0, xsum = 0, angbd = 0, dredg = 0, sredg = 0;\n        int iterc;\n        double resid = 0, delsq = 0, ggsav = 0, tempa = 0, tempb = 0,\n        redmax = 0, dredsq = 0, redsav = 0, gredsq = 0, rednew = 0;\n        int itcsav = 0;\n        double rdprev = 0, rdnext = 0, stplen = 0, stepsq = 0;\n        int itermax = 0;\n\n        \n\n        \n\n        \n        \n        \n        \n        \n        \n\n        iterc = 0;\n        nact = 0;\n        for (int i = 0; i < n; i++) {\n            xbdi.setEntry(i, ZERO);\n            if (trustRegionCenterOffset.getEntry(i) <= lowerDifference.getEntry(i)) {\n                if (gradientAtTrustRegionCenter.getEntry(i) >= ZERO) {\n                    xbdi.setEntry(i, MINUS_ONE);\n                }\n            } else if (trustRegionCenterOffset.getEntry(i) >= upperDifference.getEntry(i)) {\n                if (gradientAtTrustRegionCenter.getEntry(i) <= ZERO) {\n                    xbdi.setEntry(i, ONE);\n                }\n            }\n            if (xbdi.getEntry(i) != ZERO) {\n                ++nact;\n            }\n            trialStepPoint.setEntry(i, ZERO);\n            gnew.setEntry(i, gradientAtTrustRegionCenter.getEntry(i));\n        }\n        delsq = delta * delta;\n        qred = ZERO;\n        crvmin = MINUS_ONE;\n\n        \n        \n        \n        \n        \n\n        int state = 20;\n        for(;;) {\n            switch (state) {\n        case 20: {\n            printState(20); \n            beta = ZERO;\n        }\n        case 30: {\n            printState(30); \n            stepsq = ZERO;\n            for (int i = 0; i < n; i++) {\n                if (xbdi.getEntry(i) != ZERO) {\n                    s.setEntry(i, ZERO);\n                } else if (beta == ZERO) {\n                    s.setEntry(i, -gnew.getEntry(i));\n                } else {\n                    s.setEntry(i, beta * s.getEntry(i) - gnew.getEntry(i));\n                }\n                \n                final double d1 = s.getEntry(i);\n                stepsq += d1 * d1;\n            }\n            if (stepsq == ZERO) {\n                state = 190; break;\n            }\n            if (beta == ZERO) {\n                gredsq = stepsq;\n                itermax = iterc + n - nact;\n            }\n            if (gredsq * delsq <= qred * 1e-4 * qred) {\n                state = 190; break;\n            }\n\n            \n            \n            \n            \n\n            state = 210; break;\n        }\n        case 50: {\n            printState(50); \n            resid = delsq;\n            ds = ZERO;\n            shs = ZERO;\n            for (int i = 0; i < n; i++) {\n                if (xbdi.getEntry(i) == ZERO) {\n                    \n                    final double d1 = trialStepPoint.getEntry(i);\n                    resid -= d1 * d1;\n                    ds += s.getEntry(i) * trialStepPoint.getEntry(i);\n                    shs += s.getEntry(i) * hs.getEntry(i);\n                }\n            }\n            if (resid <= ZERO) {\n                state = 90; break;\n            }\n            temp = Math.sqrt(stepsq * resid + ds * ds);\n            if (ds < ZERO) {\n                blen = (temp - ds) / stepsq;\n            } else {\n                blen = resid / (temp + ds);\n            }\n            stplen = blen;\n            if (shs > ZERO) {\n                \n                stplen = Math.min(blen, gredsq / shs);\n            }\n\n            \n            \n\n            iact = -1;\n            for (int i = 0; i < n; i++) {\n                if (s.getEntry(i) != ZERO) {\n                    xsum = trustRegionCenterOffset.getEntry(i) + trialStepPoint.getEntry(i);\n                    if (s.getEntry(i) > ZERO) {\n                        temp = (upperDifference.getEntry(i) - xsum) / s.getEntry(i);\n                    } else {\n                        temp = (lowerDifference.getEntry(i) - xsum) / s.getEntry(i);\n                    }\n                    if (temp < stplen) {\n                        stplen = temp;\n                        iact = i;\n                    }\n                }\n            }\n\n            \n\n            sdec = ZERO;\n            if (stplen > ZERO) {\n                ++iterc;\n                temp = shs / stepsq;\n                if (iact == -1 && temp > ZERO) {\n                    crvmin = Math.min(crvmin,temp);\n                    if (crvmin == MINUS_ONE) {\n                        crvmin = temp;\n                    }\n                }\n                ggsav = gredsq;\n                gredsq = ZERO;\n                for (int i = 0; i < n; i++) {\n                    gnew.setEntry(i, gnew.getEntry(i) + stplen * hs.getEntry(i));\n                    if (xbdi.getEntry(i) == ZERO) {\n                        \n                        final double d1 = gnew.getEntry(i);\n                        gredsq += d1 * d1;\n                    }\n                    trialStepPoint.setEntry(i, trialStepPoint.getEntry(i) + stplen * s.getEntry(i));\n                }\n                \n                final double d1 = stplen * (ggsav - HALF * stplen * shs);\n                sdec = Math.max(d1, ZERO);\n                qred += sdec;\n            }\n\n            \n\n            if (iact >= 0) {\n                ++nact;\n                xbdi.setEntry(iact, ONE);\n                if (s.getEntry(iact) < ZERO) {\n                    xbdi.setEntry(iact, MINUS_ONE);\n                }\n                \n                final double d1 = trialStepPoint.getEntry(iact);\n                delsq -= d1 * d1;\n                if (delsq <= ZERO) {\n                    state = 190; break;\n                }\n                state = 20; break;\n            }\n\n            \n            \n\n            if (stplen < blen) {\n                if (iterc == itermax) {\n                    state = 190; break;\n                }\n                if (sdec <= qred * .01) {\n                    state = 190; break;\n                }\n                beta = gredsq / ggsav;\n                state = 30; break;\n            }\n        }\n        case 90: {\n            printState(90); \n            crvmin = ZERO;\n\n            \n            \n            \n\n        }\n        case 100: {\n            printState(100); \n            if (nact >= n - 1) {\n                state = 190; break;\n            }\n            dredsq = ZERO;\n            dredg = ZERO;\n            gredsq = ZERO;\n            for (int i = 0; i < n; i++) {\n                if (xbdi.getEntry(i) == ZERO) {\n                    \n                    double d1 = trialStepPoint.getEntry(i);\n                    dredsq += d1 * d1;\n                    dredg += trialStepPoint.getEntry(i) * gnew.getEntry(i);\n                    \n                    d1 = gnew.getEntry(i);\n                    gredsq += d1 * d1;\n                    s.setEntry(i, trialStepPoint.getEntry(i));\n                } else {\n                    s.setEntry(i, ZERO);\n                }\n            }\n            itcsav = iterc;\n            state = 210; break;\n            \n            \n        }\n        case 120: {\n            printState(120); \n            ++iterc;\n            temp = gredsq * dredsq - dredg * dredg;\n            if (temp <= qred * 1e-4 * qred) {\n                state = 190; break;\n            }\n            temp = Math.sqrt(temp);\n            for (int i = 0; i < n; i++) {\n                if (xbdi.getEntry(i) == ZERO) {\n                    s.setEntry(i, (dredg * trialStepPoint.getEntry(i) - dredsq * gnew.getEntry(i)) / temp);\n                } else {\n                    s.setEntry(i, ZERO);\n                }\n            }\n            sredg = -temp;\n\n            \n            \n            \n            \n\n            angbd = ONE;\n            iact = -1;\n            for (int i = 0; i < n; i++) {\n                if (xbdi.getEntry(i) == ZERO) {\n                    tempa = trustRegionCenterOffset.getEntry(i) + trialStepPoint.getEntry(i) - lowerDifference.getEntry(i);\n                    tempb = upperDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i) - trialStepPoint.getEntry(i);\n                    if (tempa <= ZERO) {\n                        ++nact;\n                        xbdi.setEntry(i, MINUS_ONE);\n                        state = 100; break;\n                    } else if (tempb <= ZERO) {\n                        ++nact;\n                        xbdi.setEntry(i, ONE);\n                        state = 100; break;\n                    }\n                    \n                    double d1 = trialStepPoint.getEntry(i);\n                    \n                    double d2 = s.getEntry(i);\n                    ssq = d1 * d1 + d2 * d2;\n                    \n                    d1 = trustRegionCenterOffset.getEntry(i) - lowerDifference.getEntry(i);\n                    temp = ssq - d1 * d1;\n                    if (temp > ZERO) {\n                        temp = Math.sqrt(temp) - s.getEntry(i);\n                        if (angbd * temp > tempa) {\n                            angbd = tempa / temp;\n                            iact = i;\n                            xsav = MINUS_ONE;\n                        }\n                    }\n                    \n                    d1 = upperDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i);\n                    temp = ssq - d1 * d1;\n                    if (temp > ZERO) {\n                        temp = Math.sqrt(temp) + s.getEntry(i);\n                        if (angbd * temp > tempb) {\n                            angbd = tempb / temp;\n                            iact = i;\n                            xsav = ONE;\n                        }\n                    }\n                }\n            }\n\n            \n\n            state = 210; break;\n        }\n        case 150: {\n            printState(150); \n            shs = ZERO;\n            dhs = ZERO;\n            dhd = ZERO;\n            for (int i = 0; i < n; i++) {\n                if (xbdi.getEntry(i) == ZERO) {\n                    shs += s.getEntry(i) * hs.getEntry(i);\n                    dhs += trialStepPoint.getEntry(i) * hs.getEntry(i);\n                    dhd += trialStepPoint.getEntry(i) * hred.getEntry(i);\n                }\n            }\n\n            \n            \n            \n\n            redmax = ZERO;\n            isav = -1;\n            redsav = ZERO;\n            iu = (int) (angbd * 17. + 3.1);\n            for (int i = 0; i < iu; i++) {\n                angt = angbd * i / iu;\n                sth = (angt + angt) / (ONE + angt * angt);\n                temp = shs + angt * (angt * dhd - dhs - dhs);\n                rednew = sth * (angt * dredg - sredg - HALF * sth * temp);\n                if (rednew > redmax) {\n                    redmax = rednew;\n                    isav = i;\n                    rdprev = redsav;\n                } else if (i == isav + 1) {\n                    rdnext = rednew;\n                }\n                redsav = rednew;\n            }\n\n            \n            \n\n            if (isav < 0) {\n                state = 190; break;\n            }\n            if (isav < iu) {\n                temp = (rdnext - rdprev) / (redmax + redmax - rdprev - rdnext);\n                angt = angbd * (isav + HALF * temp) / iu;\n            }\n            cth = (ONE - angt * angt) / (ONE + angt * angt);\n            sth = (angt + angt) / (ONE + angt * angt);\n            temp = shs + angt * (angt * dhd - dhs - dhs);\n            sdec = sth * (angt * dredg - sredg - HALF * sth * temp);\n            if (sdec <= ZERO) {\n                state = 190; break;\n            }\n\n            \n            \n            \n\n            dredg = ZERO;\n            gredsq = ZERO;\n            for (int i = 0; i < n; i++) {\n                gnew.setEntry(i, gnew.getEntry(i) + (cth - ONE) * hred.getEntry(i) + sth * hs.getEntry(i));\n                if (xbdi.getEntry(i) == ZERO) {\n                    trialStepPoint.setEntry(i, cth * trialStepPoint.getEntry(i) + sth * s.getEntry(i));\n                    dredg += trialStepPoint.getEntry(i) * gnew.getEntry(i);\n                    \n                    final double d1 = gnew.getEntry(i);\n                    gredsq += d1 * d1;\n                }\n                hred.setEntry(i, cth * hred.getEntry(i) + sth * hs.getEntry(i));\n            }\n            qred += sdec;\n            if (iact >= 0 && isav == iu) {\n                ++nact;\n                xbdi.setEntry(iact, xsav);\n                state = 100; break;\n            }\n\n            \n            \n\n            if (sdec > qred * .01) {\n                state = 120; break;\n            }\n        }\n        case 190: {\n            printState(190); \n            dsq = ZERO;\n            for (int i = 0; i < n; i++) {\n                \n                \n                final double min = Math.min(trustRegionCenterOffset.getEntry(i) + trialStepPoint.getEntry(i),\n                                            upperDifference.getEntry(i));\n                newPoint.setEntry(i, Math.max(min, lowerDifference.getEntry(i)));\n                if (xbdi.getEntry(i) == MINUS_ONE) {\n                    newPoint.setEntry(i, lowerDifference.getEntry(i));\n                }\n                if (xbdi.getEntry(i) == ONE) {\n                    newPoint.setEntry(i, upperDifference.getEntry(i));\n                }\n                trialStepPoint.setEntry(i, newPoint.getEntry(i) - trustRegionCenterOffset.getEntry(i));\n                \n                final double d1 = trialStepPoint.getEntry(i);\n                dsq += d1 * d1;\n            }\n            return new double[] { dsq, crvmin };\n            \n            \n            \n            \n        }\n        case 210: {\n            printState(210); \n            int ih = 0;\n            for (int j = 0; j < n; j++) {\n                hs.setEntry(j, ZERO);\n                for (int i = 0; i <= j; i++) {\n                    if (i < j) {\n                        hs.setEntry(j, hs.getEntry(j) + modelSecondDerivativesValues.getEntry(ih) * s.getEntry(i));\n                    }\n                    hs.setEntry(i, hs.getEntry(i) + modelSecondDerivativesValues.getEntry(ih) * s.getEntry(j));\n                    ih++;\n                }\n            }\n            final RealVector tmp = interpolationPoints.operate(s).ebeMultiply(modelSecondDerivativesParameters);\n            for (int k = 0; k < npt; k++) {\n                if (modelSecondDerivativesParameters.getEntry(k) != ZERO) {\n                    for (int i = 0; i < n; i++) {\n                        hs.setEntry(i, hs.getEntry(i) + tmp.getEntry(k) * interpolationPoints.getEntry(k, i));\n                    }\n                }\n            }\n            if (crvmin != ZERO) {\n                state = 50; break;\n            }\n            if (iterc > itcsav) {\n                state = 150; break;\n            }\n            for (int i = 0; i < n; i++) {\n                hred.setEntry(i, hs.getEntry(i));\n            }\n            state = 120; break;\n        }\n        default: {\n            throw new MathIllegalStateException(LocalizedFormats.SIMPLE_MESSAGE, \"trsbox\");\n        }}\n        }\n    } \n\n    \n\n    \n    private void update( double beta, double denom, int knew ) {\n        printMethod(); \n\n        final int n = currentBest.getDimension();\n        final int npt = numberOfInterpolationPoints;\n        final int nptm = npt - n - 1;\n\n        \n        final ArrayRealVector work = new ArrayRealVector(npt + n);\n\n        double ztest = ZERO;\n        for (int k = 0; k < npt; k++) {\n            for (int j = 0; j < nptm; j++) {\n                \n                ztest = Math.max(ztest, Math.abs(zMatrix.getEntry(k, j)));\n            }\n        }\n        ztest *= 1e-20;\n\n        \n\n        for (int j = 1; j < nptm; j++) {\n            final double d1 = zMatrix.getEntry(knew, j);\n            if (Math.abs(d1) > ztest) {\n                \n                final double d2 = zMatrix.getEntry(knew, 0);\n                \n                final double d3 = zMatrix.getEntry(knew, j);\n                final double d4 = Math.sqrt(d2 * d2 + d3 * d3);\n                final double d5 = zMatrix.getEntry(knew, 0) / d4;\n                final double d6 = zMatrix.getEntry(knew, j) / d4;\n                for (int i = 0; i < npt; i++) {\n                    final double d7 = d5 * zMatrix.getEntry(i, 0) + d6 * zMatrix.getEntry(i, j);\n                    zMatrix.setEntry(i, j, d5 * zMatrix.getEntry(i, j) - d6 * zMatrix.getEntry(i, 0));\n                    zMatrix.setEntry(i, 0, d7);\n                }\n            }\n            zMatrix.setEntry(knew, j, ZERO);\n        }\n\n        \n        \n\n        for (int i = 0; i < npt; i++) {\n            work.setEntry(i, zMatrix.getEntry(knew, 0) * zMatrix.getEntry(i, 0));\n        }\n        final double alpha = work.getEntry(knew);\n        final double tau = lagrangeValuesAtNewPoint.getEntry(knew);\n        lagrangeValuesAtNewPoint.setEntry(knew, lagrangeValuesAtNewPoint.getEntry(knew) - ONE);\n\n        \n\n        final double sqrtDenom = Math.sqrt(denom);\n        final double d1 = tau / sqrtDenom;\n        final double d2 = zMatrix.getEntry(knew, 0) / sqrtDenom;\n        for (int i = 0; i < npt; i++) {\n            zMatrix.setEntry(i, 0,\n                          d1 * zMatrix.getEntry(i, 0) - d2 * lagrangeValuesAtNewPoint.getEntry(i));\n        }\n\n        \n\n        for (int j = 0; j < n; j++) {\n            final int jp = npt + j;\n            work.setEntry(jp, bMatrix.getEntry(knew, j));\n            final double d3 = (alpha * lagrangeValuesAtNewPoint.getEntry(jp) - tau * work.getEntry(jp)) / denom;\n            final double d4 = (-beta * work.getEntry(jp) - tau * lagrangeValuesAtNewPoint.getEntry(jp)) / denom;\n            for (int i = 0; i <= jp; i++) {\n                bMatrix.setEntry(i, j,\n                              bMatrix.getEntry(i, j) + d3 * lagrangeValuesAtNewPoint.getEntry(i) + d4 * work.getEntry(i));\n                if (i >= npt) {\n                    bMatrix.setEntry(jp, (i - npt), bMatrix.getEntry(i, j));\n                }\n            }\n        }\n    } \n\n    \n    private void setup(double[] lowerBound, double[] upperBound) {\n        printMethod(); \n\n        double[] init = getStartPoint();\n        final int dimension = init.length;\n\n        \n        if (dimension < MINIMUM_PROBLEM_DIMENSION) {\n            throw new NumberIsTooSmallException(dimension, MINIMUM_PROBLEM_DIMENSION, true);\n        }\n        \n        final int[] nPointsInterval = { dimension + 2, (dimension + 2) * (dimension + 1) / 2 };\n        if (numberOfInterpolationPoints < nPointsInterval[0] ||\n            numberOfInterpolationPoints > nPointsInterval[1]) {\n            throw new OutOfRangeException(LocalizedFormats.NUMBER_OF_INTERPOLATION_POINTS,\n                                          numberOfInterpolationPoints,\n                                          nPointsInterval[0],\n                                          nPointsInterval[1]);\n        }\n\n        \n        boundDifference = new double[dimension];\n\n        double requiredMinDiff = 2 * initialTrustRegionRadius;\n        double minDiff = Double.POSITIVE_INFINITY;\n        for (int i = 0; i < dimension; i++) {\n            boundDifference[i] = upperBound[i] - lowerBound[i];\n            minDiff = Math.min(minDiff, boundDifference[i]);\n        }\n        if (minDiff < requiredMinDiff) {\n            initialTrustRegionRadius = minDiff / 3.0;\n        }\n\n        \n        bMatrix = new Array2DRowRealMatrix(dimension + numberOfInterpolationPoints,\n                                           dimension);\n        zMatrix = new Array2DRowRealMatrix(numberOfInterpolationPoints,\n                                           numberOfInterpolationPoints - dimension - 1);\n        interpolationPoints = new Array2DRowRealMatrix(numberOfInterpolationPoints,\n                                                       dimension);\n        originShift = new ArrayRealVector(dimension);\n        fAtInterpolationPoints = new ArrayRealVector(numberOfInterpolationPoints);\n        trustRegionCenterOffset = new ArrayRealVector(dimension);\n        gradientAtTrustRegionCenter = new ArrayRealVector(dimension);\n        lowerDifference = new ArrayRealVector(dimension);\n        upperDifference = new ArrayRealVector(dimension);\n        modelSecondDerivativesParameters = new ArrayRealVector(numberOfInterpolationPoints);\n        newPoint = new ArrayRealVector(dimension);\n        alternativeNewPoint = new ArrayRealVector(dimension);\n        trialStepPoint = new ArrayRealVector(dimension);\n        lagrangeValuesAtNewPoint = new ArrayRealVector(dimension + numberOfInterpolationPoints);\n        modelSecondDerivativesValues = new ArrayRealVector(dimension * (dimension + 1) / 2);\n    }\n\n    \n    private static double[] fillNewArray(int n, double value) {\n        double[] ds = new double[n];\n        Arrays.fill(ds, value);\n        return ds;\n    }\n\n    \n    private static String caller(int n) {\n        final Throwable t = new Throwable();\n        final StackTraceElement[] elements = t.getStackTrace();\n        final StackTraceElement e = elements[n];\n        return e.getMethodName() + \" (at line \" + e.getLineNumber() + \")\";\n    }\n    \n    private static void printState(int s) {\n        \n    }\n    \n    private static void printMethod() {\n        \n    }\n\n    \n    private static class PathIsExploredException extends RuntimeException { private static final long serialVersionUID = 745350979634801853L; private static final String PATH_IS_EXPLORED = \"If this exception is thrown, just remove it from the code\"; PathIsExploredException() {\n            super(PATH_IS_EXPLORED + \" \" + BOBYQAOptimizer.caller(3));\n        }\n    }\n}\n",
      "buggy_signatures": [
        "public BOBYQAOptimizer(int numberOfInterpolationPoints, double initialTrustRegionRadius, double stoppingTrustRegionRadius)",
        "protected RealPointValuePair doOptimize()",
        "private double bobyqa(double[] lowerBound, double[] upperBound)",
        "private double bobyqb(double[] lowerBound, double[] upperBound)",
        "private double[] altmov( int knew, double adelt )",
        "private void prelim(double[] lowerBound, double[] upperBound)",
        "private double[] trsbox( double delta, ArrayRealVector gnew, ArrayRealVector xbdi, ArrayRealVector s, ArrayRealVector hs, ArrayRealVector hred )",
        "private void update( double beta, double denom, int knew )",
        "private void setup(double[] lowerBound, double[] upperBound)",
        "private static double[] fillNewArray(int n, double value)",
        "private static String caller(int n)",
        "private static void printState(int s)",
        "private static void printMethod()"
      ],
      "fixed_signatures": [
        "public BOBYQAOptimizer(int numberOfInterpolationPoints, double initialTrustRegionRadius, double stoppingTrustRegionRadius)",
        "protected RealPointValuePair doOptimize()",
        "private double bobyqa(double[] lowerBound, double[] upperBound)",
        "private double bobyqb(double[] lowerBound, double[] upperBound)",
        "private double[] altmov( int knew, double adelt )",
        "private void prelim(double[] lowerBound, double[] upperBound)",
        "private double[] trsbox( double delta, ArrayRealVector gnew, ArrayRealVector xbdi, ArrayRealVector s, ArrayRealVector hs, ArrayRealVector hred )",
        "private void update( double beta, double denom, int knew )",
        "private void setup(double[] lowerBound, double[] upperBound)",
        "private static double[] fillNewArray(int n, double value)",
        "private static String caller(int n)",
        "private static void printState(int s)",
        "private static void printMethod()"
      ],
      "methods": [
        {
          "buggy_method": "  private void prelim(double[] lowerBound, double[] upperBound) {\n  printMethod(); \n\n  final int n = currentBest.getDimension();\n  final int npt = numberOfInterpolationPoints;\n  final int ndim = bMatrix.getRowDimension();\n\n  final double rhosq = initialTrustRegionRadius * initialTrustRegionRadius;\n  final double recip = 1d / rhosq;\n  final int np = n + 1;\n\n  \n  \n\n  for (int j = 0; j < n; j++) {\n  originShift.setEntry(j, currentBest.getEntry(j));\n  for (int k = 0; k < npt; k++) {\n  interpolationPoints.setEntry(k, j, ZERO);\n  }\n  for (int i = 0; i < ndim; i++) {\n  bMatrix.setEntry(i, j, ZERO);\n  }\n  }\n  for (int i = 0, max = n * np / 2; i < max; i++) {\n  modelSecondDerivativesValues.setEntry(i, ZERO);\n  }\n  for (int k = 0; k < npt; k++) {\n  modelSecondDerivativesParameters.setEntry(k, ZERO);\n  for (int j = 0, max = npt - np; j < max; j++) {\n  zMatrix.setEntry(k, j, ZERO);\n  }\n  }\n\n  \n  \n  \n\n  int ipt = 0;\n  int jpt = 0;\n  double fbeg = Double.NaN;\n  do {\n  final int nfm = getEvaluations();\n  final int nfx = nfm - n;\n  final int nfmm = nfm - 1;\n  final int nfxm = nfx - 1;\n  double stepa = 0;\n  double stepb = 0;\n  if (nfm <= 2 * n) {\n  if (nfm >= 1 &&\n  nfm <= n) {\n  stepa = initialTrustRegionRadius;\n  if (upperDifference.getEntry(nfmm) == ZERO) {\n  stepa = -stepa;\n  throw new PathIsExploredException(); \n  }\n  interpolationPoints.setEntry(nfm, nfmm, stepa);\n  } else if (nfm > n) {\n  stepa = interpolationPoints.getEntry(nfx, nfxm);\n  stepb = -initialTrustRegionRadius;\n  if (lowerDifference.getEntry(nfxm) == ZERO) {\n  stepb = Math.min(TWO * initialTrustRegionRadius, upperDifference.getEntry(nfxm));\n  throw new PathIsExploredException(); \n  }\n  if (upperDifference.getEntry(nfxm) == ZERO) {\n  stepb = Math.max(-TWO * initialTrustRegionRadius, lowerDifference.getEntry(nfxm));\n  throw new PathIsExploredException(); \n  }\n  interpolationPoints.setEntry(nfm, nfxm, stepb);\n  }\n  } else {\n  final int tmp1 = (nfm - np) / n;\n  jpt = nfm - tmp1 * n - n;\n  ipt = jpt + tmp1;\n  if (ipt > n) {\n  final int tmp2 = jpt;\n  jpt = ipt - n;\n  ipt = tmp2;\n  throw new PathIsExploredException(); \n  }\n  final int iptMinus1 = ipt;\n  final int jptMinus1 = jpt;\n  interpolationPoints.setEntry(nfm, iptMinus1, interpolationPoints.getEntry(ipt, iptMinus1));\n  interpolationPoints.setEntry(nfm, jptMinus1, interpolationPoints.getEntry(jpt, jptMinus1));\n  }\n\n  \n  \n\n  for (int j = 0; j < n; j++) {\n  currentBest.setEntry(j, Math.min(Math.max(lowerBound[j],\n  originShift.getEntry(j) + interpolationPoints.getEntry(nfm, j)),\n  upperBound[j]));\n  if (interpolationPoints.getEntry(nfm, j) == lowerDifference.getEntry(j)) {\n  currentBest.setEntry(j, lowerBound[j]);\n  }\n  if (interpolationPoints.getEntry(nfm, j) == upperDifference.getEntry(j)) {\n  currentBest.setEntry(j, upperBound[j]);\n  }\n  }\n\n  final double objectiveValue = computeObjectiveValue(currentBest.toArray());\n  final double f = isMinimize ? objectiveValue : -objectiveValue;\n  final int numEval = getEvaluations(); \n  fAtInterpolationPoints.setEntry(nfm, f);\n\n  if (numEval == 1) {\n  fbeg = f;\n  trustRegionCenterInterpolationPointIndex = 0;\n  } else if (f < fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex)) {\n  trustRegionCenterInterpolationPointIndex = nfm;\n  }\n\n  \n  \n  \n  \n  \n\n  if (numEval <= 2 * n + 1) {\n  if (numEval >= 2 &&\n  numEval <= n + 1) {\n  gradientAtTrustRegionCenter.setEntry(nfmm, (f - fbeg) / stepa);\n  if (npt < numEval + n) {\n  final double oneOverStepA = ONE / stepa;\n  bMatrix.setEntry(0, nfmm, -oneOverStepA);\n  bMatrix.setEntry(nfm, nfmm, oneOverStepA);\n  bMatrix.setEntry(npt + nfmm, nfmm, -HALF * rhosq);\n  throw new PathIsExploredException(); \n  }\n  } else if (numEval >= n + 2) {\n  final int ih = nfx * (nfx + 1) / 2 - 1;\n  final double tmp = (f - fbeg) / stepb;\n  final double diff = stepb - stepa;\n  modelSecondDerivativesValues.setEntry(ih, TWO * (tmp - gradientAtTrustRegionCenter.getEntry(nfxm)) / diff);\n  gradientAtTrustRegionCenter.setEntry(nfxm, (gradientAtTrustRegionCenter.getEntry(nfxm) * stepb - tmp * stepa) / diff);\n  if (stepa * stepb < ZERO) {\n  if (f < fAtInterpolationPoints.getEntry(nfm - n)) {\n  fAtInterpolationPoints.setEntry(nfm, fAtInterpolationPoints.getEntry(nfm - n));\n  fAtInterpolationPoints.setEntry(nfm - n, f);\n  if (trustRegionCenterInterpolationPointIndex == nfm) {\n  trustRegionCenterInterpolationPointIndex = nfm - n;\n  }\n  interpolationPoints.setEntry(nfm - n, nfxm, stepb);\n  interpolationPoints.setEntry(nfm, nfxm, stepa);\n  }\n  }\n  bMatrix.setEntry(0, nfxm, -(stepa + stepb) / (stepa * stepb));\n  bMatrix.setEntry(nfm, nfxm, -HALF / interpolationPoints.getEntry(nfm - n, nfxm));\n  bMatrix.setEntry(nfm - n, nfxm,\n  -bMatrix.getEntry(0, nfxm) - bMatrix.getEntry(nfm, nfxm));\n  zMatrix.setEntry(0, nfxm, Math.sqrt(TWO) / (stepa * stepb));\n  zMatrix.setEntry(nfm, nfxm, Math.sqrt(HALF) / rhosq);\n  \n  zMatrix.setEntry(nfm - n, nfxm,\n  -zMatrix.getEntry(0, nfxm) - zMatrix.getEntry(nfm, nfxm));\n  }\n\n  \n  \n\n  } else {\n  zMatrix.setEntry(0, nfxm, recip);\n  zMatrix.setEntry(nfm, nfxm, recip);\n  zMatrix.setEntry(ipt, nfxm, -recip);\n  zMatrix.setEntry(jpt, nfxm, -recip);\n\n  final int ih = ipt * (ipt - 1) / 2 + jpt - 1;\n  final double tmp = interpolationPoints.getEntry(nfm, ipt - 1) * interpolationPoints.getEntry(nfm, jpt - 1);\n  modelSecondDerivativesValues.setEntry(ih, (fbeg - fAtInterpolationPoints.getEntry(ipt) - fAtInterpolationPoints.getEntry(jpt) + f) / tmp);\n  throw new PathIsExploredException(); \n  }\n  } while (getEvaluations() < npt);\n  } ",
          "fixed_method": "  private void prelim(double[] lowerBound, double[] upperBound) {\n  printMethod(); \n\n  final int n = currentBest.getDimension();\n  final int npt = numberOfInterpolationPoints;\n  final int ndim = bMatrix.getRowDimension();\n\n  final double rhosq = initialTrustRegionRadius * initialTrustRegionRadius;\n  final double recip = 1d / rhosq;\n  final int np = n + 1;\n\n  \n  \n\n  for (int j = 0; j < n; j++) {\n  originShift.setEntry(j, currentBest.getEntry(j));\n  for (int k = 0; k < npt; k++) {\n  interpolationPoints.setEntry(k, j, ZERO);\n  }\n  for (int i = 0; i < ndim; i++) {\n  bMatrix.setEntry(i, j, ZERO);\n  }\n  }\n  for (int i = 0, max = n * np / 2; i < max; i++) {\n  modelSecondDerivativesValues.setEntry(i, ZERO);\n  }\n  for (int k = 0; k < npt; k++) {\n  modelSecondDerivativesParameters.setEntry(k, ZERO);\n  for (int j = 0, max = npt - np; j < max; j++) {\n  zMatrix.setEntry(k, j, ZERO);\n  }\n  }\n\n  \n  \n  \n\n  int ipt = 0;\n  int jpt = 0;\n  double fbeg = Double.NaN;\n  do {\n  final int nfm = getEvaluations();\n  final int nfx = nfm - n;\n  final int nfmm = nfm - 1;\n  final int nfxm = nfx - 1;\n  double stepa = 0;\n  double stepb = 0;\n  if (nfm <= 2 * n) {\n  if (nfm >= 1 &&\n  nfm <= n) {\n  stepa = initialTrustRegionRadius;\n  if (upperDifference.getEntry(nfmm) == ZERO) {\n  stepa = -stepa;\n  throw new PathIsExploredException(); \n  }\n  interpolationPoints.setEntry(nfm, nfmm, stepa);\n  } else if (nfm > n) {\n  stepa = interpolationPoints.getEntry(nfx, nfxm);\n  stepb = -initialTrustRegionRadius;\n  if (lowerDifference.getEntry(nfxm) == ZERO) {\n  stepb = Math.min(TWO * initialTrustRegionRadius, upperDifference.getEntry(nfxm));\n  throw new PathIsExploredException(); \n  }\n  if (upperDifference.getEntry(nfxm) == ZERO) {\n  stepb = Math.max(-TWO * initialTrustRegionRadius, lowerDifference.getEntry(nfxm));\n  throw new PathIsExploredException(); \n  }\n  interpolationPoints.setEntry(nfm, nfxm, stepb);\n  }\n  } else {\n  final int tmp1 = (nfm - np) / n;\n  jpt = nfm - tmp1 * n - n;\n  ipt = jpt + tmp1;\n  if (ipt > n) {\n  final int tmp2 = jpt;\n  jpt = ipt - n;\n  ipt = tmp2;\n\n  }\n  final int iptMinus1 = ipt - 1;\n  final int jptMinus1 = jpt - 1;\n  interpolationPoints.setEntry(nfm, iptMinus1, interpolationPoints.getEntry(ipt, iptMinus1));\n  interpolationPoints.setEntry(nfm, jptMinus1, interpolationPoints.getEntry(jpt, jptMinus1));\n  }\n\n  \n  \n\n  for (int j = 0; j < n; j++) {\n  currentBest.setEntry(j, Math.min(Math.max(lowerBound[j],\n  originShift.getEntry(j) + interpolationPoints.getEntry(nfm, j)),\n  upperBound[j]));\n  if (interpolationPoints.getEntry(nfm, j) == lowerDifference.getEntry(j)) {\n  currentBest.setEntry(j, lowerBound[j]);\n  }\n  if (interpolationPoints.getEntry(nfm, j) == upperDifference.getEntry(j)) {\n  currentBest.setEntry(j, upperBound[j]);\n  }\n  }\n\n  final double objectiveValue = computeObjectiveValue(currentBest.toArray());\n  final double f = isMinimize ? objectiveValue : -objectiveValue;\n  final int numEval = getEvaluations(); \n  fAtInterpolationPoints.setEntry(nfm, f);\n\n  if (numEval == 1) {\n  fbeg = f;\n  trustRegionCenterInterpolationPointIndex = 0;\n  } else if (f < fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex)) {\n  trustRegionCenterInterpolationPointIndex = nfm;\n  }\n\n  \n  \n  \n  \n  \n\n  if (numEval <= 2 * n + 1) {\n  if (numEval >= 2 &&\n  numEval <= n + 1) {\n  gradientAtTrustRegionCenter.setEntry(nfmm, (f - fbeg) / stepa);\n  if (npt < numEval + n) {\n  final double oneOverStepA = ONE / stepa;\n  bMatrix.setEntry(0, nfmm, -oneOverStepA);\n  bMatrix.setEntry(nfm, nfmm, oneOverStepA);\n  bMatrix.setEntry(npt + nfmm, nfmm, -HALF * rhosq);\n  throw new PathIsExploredException(); \n  }\n  } else if (numEval >= n + 2) {\n  final int ih = nfx * (nfx + 1) / 2 - 1;\n  final double tmp = (f - fbeg) / stepb;\n  final double diff = stepb - stepa;\n  modelSecondDerivativesValues.setEntry(ih, TWO * (tmp - gradientAtTrustRegionCenter.getEntry(nfxm)) / diff);\n  gradientAtTrustRegionCenter.setEntry(nfxm, (gradientAtTrustRegionCenter.getEntry(nfxm) * stepb - tmp * stepa) / diff);\n  if (stepa * stepb < ZERO) {\n  if (f < fAtInterpolationPoints.getEntry(nfm - n)) {\n  fAtInterpolationPoints.setEntry(nfm, fAtInterpolationPoints.getEntry(nfm - n));\n  fAtInterpolationPoints.setEntry(nfm - n, f);\n  if (trustRegionCenterInterpolationPointIndex == nfm) {\n  trustRegionCenterInterpolationPointIndex = nfm - n;\n  }\n  interpolationPoints.setEntry(nfm - n, nfxm, stepb);\n  interpolationPoints.setEntry(nfm, nfxm, stepa);\n  }\n  }\n  bMatrix.setEntry(0, nfxm, -(stepa + stepb) / (stepa * stepb));\n  bMatrix.setEntry(nfm, nfxm, -HALF / interpolationPoints.getEntry(nfm - n, nfxm));\n  bMatrix.setEntry(nfm - n, nfxm,\n  -bMatrix.getEntry(0, nfxm) - bMatrix.getEntry(nfm, nfxm));\n  zMatrix.setEntry(0, nfxm, Math.sqrt(TWO) / (stepa * stepb));\n  zMatrix.setEntry(nfm, nfxm, Math.sqrt(HALF) / rhosq);\n  \n  zMatrix.setEntry(nfm - n, nfxm,\n  -zMatrix.getEntry(0, nfxm) - zMatrix.getEntry(nfm, nfxm));\n  }\n\n  \n  \n\n  } else {\n  zMatrix.setEntry(0, nfxm, recip);\n  zMatrix.setEntry(nfm, nfxm, recip);\n  zMatrix.setEntry(ipt, nfxm, -recip);\n  zMatrix.setEntry(jpt, nfxm, -recip);\n\n  final int ih = ipt * (ipt - 1) / 2 + jpt - 1;\n  final double tmp = interpolationPoints.getEntry(nfm, ipt - 1) * interpolationPoints.getEntry(nfm, jpt - 1);\n  modelSecondDerivativesValues.setEntry(ih, (fbeg - fAtInterpolationPoints.getEntry(ipt) - fAtInterpolationPoints.getEntry(jpt) + f) / tmp);\n\n  }\n  } while (getEvaluations() < npt);\n  } ",
          "diff": [
            "@@ -1657,10 +1657,10 @@",
            "                     final int tmp2 = jpt;\n",
            "                     jpt = ipt - n;\n",
            "                     ipt = tmp2;\n",
            "-                    throw new PathIsExploredException(); // XXX\n",
            "-                }\n",
            "-                final int iptMinus1 = ipt;\n",
            "-                final int jptMinus1 = jpt;\n",
            "+//                     throw new PathIsExploredException(); // XXX\n",
            "+                }\n",
            "+                final int iptMinus1 = ipt - 1;\n",
            "+                final int jptMinus1 = jpt - 1;\n",
            "                 interpolationPoints.setEntry(nfm, iptMinus1, interpolationPoints.getEntry(ipt, iptMinus1));\n",
            "                 interpolationPoints.setEntry(nfm, jptMinus1, interpolationPoints.getEntry(jpt, jptMinus1));\n",
            "             }\n",
            "@@ -1749,7 +1749,7 @@",
            "                 final int ih = ipt * (ipt - 1) / 2 + jpt - 1;\n",
            "                 final double tmp = interpolationPoints.getEntry(nfm, ipt - 1) * interpolationPoints.getEntry(nfm, jpt - 1);\n",
            "                 modelSecondDerivativesValues.setEntry(ih, (fbeg - fAtInterpolationPoints.getEntry(ipt) - fAtInterpolationPoints.getEntry(jpt) + f) / tmp);\n",
            "-                throw new PathIsExploredException(); // XXX\n",
            "+//                 throw new PathIsExploredException(); // XXX\n",
            "             }\n",
            "         } while (getEvaluations() < npt);\n",
            "     } // prelim\n"
          ],
          "changed_lines": 10
        }
      ]
    }
  ]
}
