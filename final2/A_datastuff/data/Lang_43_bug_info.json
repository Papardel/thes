{
  "bug_id": "43",
  "failed_tests": {
    "org.apache.commons.lang.text.ExtendedMessageFormatTest": [
      {
        "methodName": "testEscapedQuote_LANG_477",
        "error": "java.lang.OutOfMemoryError",
        "message": "Requested array size exceeds VM limit",
        "fail_line": "        ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry);",
        "test_source": "  public void testEscapedQuote_LANG_477() {\n  String pattern = \"it''s a {0,lower} 'test'!\";\n  ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry);\n  assertEquals(\"it's a dummy test!\", emf.format(new Object[] {\"DUMMY\"}));\n  }",
        "stack": [
          "ExtendedMessageFormat.appendQuotedString line 422, ExtendedMessageFormat.applyPattern line 158, ExtendedMessageFormat.<init> line 127, ExtendedMessageFormat.<init> line 112, ExtendedMessageFormatTest.testEscapedQuote_LANG_477 line 100"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/lang/text/ExtendedMessageFormat.java",
      "buggy_full_code": "\npackage org.apache.commons.lang.text;\n\nimport java.text.Format;\nimport java.text.MessageFormat;\nimport java.text.ParsePosition;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.Locale;\nimport java.util.Map;\n\nimport org.apache.commons.lang.Validate;\n\n\npublic class ExtendedMessageFormat extends MessageFormat { private static final long serialVersionUID = -2362048321261811743L; private static final String DUMMY_PATTERN = \"\"; private static final String ESCAPED_QUOTE = \"''\"; private static final char START_FMT = ','; private static final char END_FE = '}'; private static final char START_FE = '{'; private static final char QUOTE = '\\''; private String toPattern; private Map registry; public ExtendedMessageFormat(String pattern) {\n        this(pattern, Locale.getDefault());\n    }\n\n    \n    public ExtendedMessageFormat(String pattern, Locale locale) {\n        this(pattern, locale, null);\n    }\n\n    \n    public ExtendedMessageFormat(String pattern, Map registry) {\n        this(pattern, Locale.getDefault(), registry);\n    }\n\n    \n    public ExtendedMessageFormat(String pattern, Locale locale, Map registry) {\n        super(DUMMY_PATTERN);\n        setLocale(locale);\n        this.registry = registry;\n        applyPattern(pattern);\n    }\n\n    \n    public String toPattern() {\n        return toPattern;\n    }\n\n    \n    public final void applyPattern(String pattern) {\n        if (registry == null) {\n            super.applyPattern(pattern);\n            toPattern = super.toPattern();\n            return;\n        }\n        ArrayList foundFormats = new ArrayList();\n        ArrayList foundDescriptions = new ArrayList();\n        StringBuffer stripCustom = new StringBuffer(pattern.length());\n\n        ParsePosition pos = new ParsePosition(0);\n        char[] c = pattern.toCharArray();\n        int fmtCount = 0;\n        while (pos.getIndex() < pattern.length()) {\n            switch (c[pos.getIndex()]) {\n            case QUOTE:\n                appendQuotedString(pattern, pos, stripCustom, true);\n                break;\n            case START_FE:\n                fmtCount++;\n                seekNonWs(pattern, pos);\n                int start = pos.getIndex();\n                int index = readArgumentIndex(pattern, next(pos));\n                stripCustom.append(START_FE).append(index);\n                seekNonWs(pattern, pos);\n                Format format = null;\n                String formatDescription = null;\n                if (c[pos.getIndex()] == START_FMT) {\n                    formatDescription = parseFormatDescription(pattern,\n                            next(pos));\n                    format = getFormat(formatDescription);\n                    if (format == null) {\n                        stripCustom.append(START_FMT).append(formatDescription);\n                    }\n                }\n                foundFormats.add(format);\n                foundDescriptions.add(format == null ? null : formatDescription);\n                Validate.isTrue(foundFormats.size() == fmtCount);\n                Validate.isTrue(foundDescriptions.size() == fmtCount);\n                if (c[pos.getIndex()] != END_FE) {\n                    throw new IllegalArgumentException(\n                            \"Unreadable format element at position \" + start);\n                }\n                \n            default:\n                stripCustom.append(c[pos.getIndex()]);\n                next(pos);\n            }\n        }\n        super.applyPattern(stripCustom.toString());\n        toPattern = insertFormats(super.toPattern(), foundDescriptions);\n        if (containsElements(foundFormats)) {\n            Format[] origFormats = getFormats();\n            \n            \n            int i = 0;\n            for (Iterator it = foundFormats.iterator(); it.hasNext(); i++) {\n                Format f = (Format) it.next();\n                if (f != null) {\n                    origFormats[i] = f;\n                }\n            }\n            super.setFormats(origFormats);\n        }\n    }\n\n    \n    public void setFormat(int formatElementIndex, Format newFormat) {\n        throw new UnsupportedOperationException();\n    }\n\n    \n    public void setFormatByArgumentIndex(int argumentIndex, Format newFormat) {\n        throw new UnsupportedOperationException();\n    }\n\n    \n    public void setFormats(Format[] newFormats) {\n        throw new UnsupportedOperationException();\n    }\n\n    \n    public void setFormatsByArgumentIndex(Format[] newFormats) {\n        throw new UnsupportedOperationException();\n    }\n\n    \n    private Format getFormat(String desc) {\n        if (registry != null) {\n            String name = desc;\n            String args = null;\n            int i = desc.indexOf(START_FMT);\n            if (i > 0) {\n                name = desc.substring(0, i).trim();\n                args = desc.substring(i + 1).trim();\n            }\n            FormatFactory factory = (FormatFactory) registry.get(name);\n            if (factory != null) {\n                return factory.getFormat(name, args, getLocale());\n            }\n        }\n        return null;\n    }\n\n    \n    private int readArgumentIndex(String pattern, ParsePosition pos) {\n        int start = pos.getIndex();\n        seekNonWs(pattern, pos);\n        StringBuffer result = new StringBuffer();\n        boolean error = false;\n        for (; !error && pos.getIndex() < pattern.length(); next(pos)) {\n            char c = pattern.charAt(pos.getIndex());\n            if (Character.isWhitespace(c)) {\n                seekNonWs(pattern, pos);\n                c = pattern.charAt(pos.getIndex());\n                if (c != START_FMT && c != END_FE) {\n                    error = true;\n                    continue;\n                }\n            }\n            if ((c == START_FMT || c == END_FE) && result.length() > 0) {\n                try {\n                    return Integer.parseInt(result.toString());\n                } catch (NumberFormatException e) {\n                    \n                    \n                }\n            }\n            error = !Character.isDigit(c);\n            result.append(c);\n        }\n        if (error) {\n            throw new IllegalArgumentException(\n                    \"Invalid format argument index at position \" + start + \": \"\n                            + pattern.substring(start, pos.getIndex()));\n        }\n        throw new IllegalArgumentException(\n                \"Unterminated format element at position \" + start);\n    }\n\n    \n    private String parseFormatDescription(String pattern, ParsePosition pos) {\n        int start = pos.getIndex();\n        seekNonWs(pattern, pos);\n        int text = pos.getIndex();\n        int depth = 1;\n        for (; pos.getIndex() < pattern.length(); next(pos)) {\n            switch (pattern.charAt(pos.getIndex())) {\n            case START_FE:\n                depth++;\n                break;\n            case END_FE:\n                depth--;\n                if (depth == 0) {\n                    return pattern.substring(text, pos.getIndex());\n                }\n                break;\n            case QUOTE:\n                getQuotedString(pattern, pos, false);\n                break;\n            }\n        }\n        throw new IllegalArgumentException(\n                \"Unterminated format element at position \" + start);\n    }\n\n    \n    private String insertFormats(String pattern, ArrayList customPatterns) {\n        if (!containsElements(customPatterns)) {\n            return pattern;\n        }\n        StringBuffer sb = new StringBuffer(pattern.length() * 2);\n        ParsePosition pos = new ParsePosition(0);\n        int fe = -1;\n        int depth = 0;\n        while (pos.getIndex() < pattern.length()) {\n            char c = pattern.charAt(pos.getIndex());\n            switch (c) {\n            case QUOTE:\n                appendQuotedString(pattern, pos, sb, false);\n                break;\n            case START_FE:\n                depth++;\n                if (depth == 1) {\n                    fe++;\n                    sb.append(START_FE).append(\n                            readArgumentIndex(pattern, next(pos)));\n                    String customPattern = (String) customPatterns.get(fe);\n                    if (customPattern != null) {\n                        sb.append(START_FMT).append(customPattern);\n                    }\n                }\n                break;\n            case END_FE:\n                depth--;\n                \n            default:\n                sb.append(c);\n                next(pos);\n            }\n        }\n        return sb.toString();\n    }\n\n    \n    private void seekNonWs(String pattern, ParsePosition pos) {\n        int len = 0;\n        char[] buffer = pattern.toCharArray();\n        do {\n            len = StrMatcher.splitMatcher().isMatch(buffer, pos.getIndex());\n            pos.setIndex(pos.getIndex() + len);\n        } while (len > 0 && pos.getIndex() < pattern.length());\n    }\n\n    \n    private ParsePosition next(ParsePosition pos) {\n        pos.setIndex(pos.getIndex() + 1);\n        return pos;\n    }\n\n    \n    private StringBuffer appendQuotedString(String pattern, ParsePosition pos, StringBuffer appendTo, boolean escapingOn) {\n        int start = pos.getIndex();\n        char[] c = pattern.toCharArray();\n        if (escapingOn && c[start] == QUOTE) {\n            return appendTo == null ? null : appendTo.append(QUOTE);\n        }\n        int lastHold = start;\n        for (int i = pos.getIndex(); i < pattern.length(); i++) {\n            if (escapingOn && pattern.substring(i).startsWith(ESCAPED_QUOTE)) {\n                appendTo.append(c, lastHold, pos.getIndex() - lastHold).append(\n                        QUOTE);\n                pos.setIndex(i + ESCAPED_QUOTE.length());\n                lastHold = pos.getIndex();\n                continue;\n            }\n            switch (c[pos.getIndex()]) {\n            case QUOTE:\n                next(pos);\n                return appendTo == null ? null : appendTo.append(c, lastHold,\n                        pos.getIndex() - lastHold);\n            default:\n                next(pos);\n            }\n        }\n        throw new IllegalArgumentException(\n                \"Unterminated quoted string at position \" + start);\n    }\n\n    \n    private void getQuotedString(String pattern, ParsePosition pos, boolean escapingOn) {\n        appendQuotedString(pattern, pos, null, escapingOn);\n    }\n\n    \n    private boolean containsElements(Collection coll) {\n        if (coll == null || coll.size() == 0) {\n            return false;\n        }\n        for (Iterator iter = coll.iterator(); iter.hasNext();) {\n            if (iter.next() != null) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n",
      "fixed_full_code": "\npackage org.apache.commons.lang.text;\n\nimport java.text.Format;\nimport java.text.MessageFormat;\nimport java.text.ParsePosition;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.Locale;\nimport java.util.Map;\n\nimport org.apache.commons.lang.Validate;\n\n\npublic class ExtendedMessageFormat extends MessageFormat { private static final long serialVersionUID = -2362048321261811743L; private static final String DUMMY_PATTERN = \"\"; private static final String ESCAPED_QUOTE = \"''\"; private static final char START_FMT = ','; private static final char END_FE = '}'; private static final char START_FE = '{'; private static final char QUOTE = '\\''; private String toPattern; private Map registry; public ExtendedMessageFormat(String pattern) {\n        this(pattern, Locale.getDefault());\n    }\n\n    \n    public ExtendedMessageFormat(String pattern, Locale locale) {\n        this(pattern, locale, null);\n    }\n\n    \n    public ExtendedMessageFormat(String pattern, Map registry) {\n        this(pattern, Locale.getDefault(), registry);\n    }\n\n    \n    public ExtendedMessageFormat(String pattern, Locale locale, Map registry) {\n        super(DUMMY_PATTERN);\n        setLocale(locale);\n        this.registry = registry;\n        applyPattern(pattern);\n    }\n\n    \n    public String toPattern() {\n        return toPattern;\n    }\n\n    \n    public final void applyPattern(String pattern) {\n        if (registry == null) {\n            super.applyPattern(pattern);\n            toPattern = super.toPattern();\n            return;\n        }\n        ArrayList foundFormats = new ArrayList();\n        ArrayList foundDescriptions = new ArrayList();\n        StringBuffer stripCustom = new StringBuffer(pattern.length());\n\n        ParsePosition pos = new ParsePosition(0);\n        char[] c = pattern.toCharArray();\n        int fmtCount = 0;\n        while (pos.getIndex() < pattern.length()) {\n            switch (c[pos.getIndex()]) {\n            case QUOTE:\n                appendQuotedString(pattern, pos, stripCustom, true);\n                break;\n            case START_FE:\n                fmtCount++;\n                seekNonWs(pattern, pos);\n                int start = pos.getIndex();\n                int index = readArgumentIndex(pattern, next(pos));\n                stripCustom.append(START_FE).append(index);\n                seekNonWs(pattern, pos);\n                Format format = null;\n                String formatDescription = null;\n                if (c[pos.getIndex()] == START_FMT) {\n                    formatDescription = parseFormatDescription(pattern,\n                            next(pos));\n                    format = getFormat(formatDescription);\n                    if (format == null) {\n                        stripCustom.append(START_FMT).append(formatDescription);\n                    }\n                }\n                foundFormats.add(format);\n                foundDescriptions.add(format == null ? null : formatDescription);\n                Validate.isTrue(foundFormats.size() == fmtCount);\n                Validate.isTrue(foundDescriptions.size() == fmtCount);\n                if (c[pos.getIndex()] != END_FE) {\n                    throw new IllegalArgumentException(\n                            \"Unreadable format element at position \" + start);\n                }\n                \n            default:\n                stripCustom.append(c[pos.getIndex()]);\n                next(pos);\n            }\n        }\n        super.applyPattern(stripCustom.toString());\n        toPattern = insertFormats(super.toPattern(), foundDescriptions);\n        if (containsElements(foundFormats)) {\n            Format[] origFormats = getFormats();\n            \n            \n            int i = 0;\n            for (Iterator it = foundFormats.iterator(); it.hasNext(); i++) {\n                Format f = (Format) it.next();\n                if (f != null) {\n                    origFormats[i] = f;\n                }\n            }\n            super.setFormats(origFormats);\n        }\n    }\n\n    \n    public void setFormat(int formatElementIndex, Format newFormat) {\n        throw new UnsupportedOperationException();\n    }\n\n    \n    public void setFormatByArgumentIndex(int argumentIndex, Format newFormat) {\n        throw new UnsupportedOperationException();\n    }\n\n    \n    public void setFormats(Format[] newFormats) {\n        throw new UnsupportedOperationException();\n    }\n\n    \n    public void setFormatsByArgumentIndex(Format[] newFormats) {\n        throw new UnsupportedOperationException();\n    }\n\n    \n    private Format getFormat(String desc) {\n        if (registry != null) {\n            String name = desc;\n            String args = null;\n            int i = desc.indexOf(START_FMT);\n            if (i > 0) {\n                name = desc.substring(0, i).trim();\n                args = desc.substring(i + 1).trim();\n            }\n            FormatFactory factory = (FormatFactory) registry.get(name);\n            if (factory != null) {\n                return factory.getFormat(name, args, getLocale());\n            }\n        }\n        return null;\n    }\n\n    \n    private int readArgumentIndex(String pattern, ParsePosition pos) {\n        int start = pos.getIndex();\n        seekNonWs(pattern, pos);\n        StringBuffer result = new StringBuffer();\n        boolean error = false;\n        for (; !error && pos.getIndex() < pattern.length(); next(pos)) {\n            char c = pattern.charAt(pos.getIndex());\n            if (Character.isWhitespace(c)) {\n                seekNonWs(pattern, pos);\n                c = pattern.charAt(pos.getIndex());\n                if (c != START_FMT && c != END_FE) {\n                    error = true;\n                    continue;\n                }\n            }\n            if ((c == START_FMT || c == END_FE) && result.length() > 0) {\n                try {\n                    return Integer.parseInt(result.toString());\n                } catch (NumberFormatException e) {\n                    \n                    \n                }\n            }\n            error = !Character.isDigit(c);\n            result.append(c);\n        }\n        if (error) {\n            throw new IllegalArgumentException(\n                    \"Invalid format argument index at position \" + start + \": \"\n                            + pattern.substring(start, pos.getIndex()));\n        }\n        throw new IllegalArgumentException(\n                \"Unterminated format element at position \" + start);\n    }\n\n    \n    private String parseFormatDescription(String pattern, ParsePosition pos) {\n        int start = pos.getIndex();\n        seekNonWs(pattern, pos);\n        int text = pos.getIndex();\n        int depth = 1;\n        for (; pos.getIndex() < pattern.length(); next(pos)) {\n            switch (pattern.charAt(pos.getIndex())) {\n            case START_FE:\n                depth++;\n                break;\n            case END_FE:\n                depth--;\n                if (depth == 0) {\n                    return pattern.substring(text, pos.getIndex());\n                }\n                break;\n            case QUOTE:\n                getQuotedString(pattern, pos, false);\n                break;\n            }\n        }\n        throw new IllegalArgumentException(\n                \"Unterminated format element at position \" + start);\n    }\n\n    \n    private String insertFormats(String pattern, ArrayList customPatterns) {\n        if (!containsElements(customPatterns)) {\n            return pattern;\n        }\n        StringBuffer sb = new StringBuffer(pattern.length() * 2);\n        ParsePosition pos = new ParsePosition(0);\n        int fe = -1;\n        int depth = 0;\n        while (pos.getIndex() < pattern.length()) {\n            char c = pattern.charAt(pos.getIndex());\n            switch (c) {\n            case QUOTE:\n                appendQuotedString(pattern, pos, sb, false);\n                break;\n            case START_FE:\n                depth++;\n                if (depth == 1) {\n                    fe++;\n                    sb.append(START_FE).append(\n                            readArgumentIndex(pattern, next(pos)));\n                    String customPattern = (String) customPatterns.get(fe);\n                    if (customPattern != null) {\n                        sb.append(START_FMT).append(customPattern);\n                    }\n                }\n                break;\n            case END_FE:\n                depth--;\n                \n            default:\n                sb.append(c);\n                next(pos);\n            }\n        }\n        return sb.toString();\n    }\n\n    \n    private void seekNonWs(String pattern, ParsePosition pos) {\n        int len = 0;\n        char[] buffer = pattern.toCharArray();\n        do {\n            len = StrMatcher.splitMatcher().isMatch(buffer, pos.getIndex());\n            pos.setIndex(pos.getIndex() + len);\n        } while (len > 0 && pos.getIndex() < pattern.length());\n    }\n\n    \n    private ParsePosition next(ParsePosition pos) {\n        pos.setIndex(pos.getIndex() + 1);\n        return pos;\n    }\n\n    \n    private StringBuffer appendQuotedString(String pattern, ParsePosition pos, StringBuffer appendTo, boolean escapingOn) {\n        int start = pos.getIndex();\n        char[] c = pattern.toCharArray();\n        if (escapingOn && c[start] == QUOTE) {\n            next(pos);\n            return appendTo == null ? null : appendTo.append(QUOTE);\n        }\n        int lastHold = start;\n        for (int i = pos.getIndex(); i < pattern.length(); i++) {\n            if (escapingOn && pattern.substring(i).startsWith(ESCAPED_QUOTE)) {\n                appendTo.append(c, lastHold, pos.getIndex() - lastHold).append(\n                        QUOTE);\n                pos.setIndex(i + ESCAPED_QUOTE.length());\n                lastHold = pos.getIndex();\n                continue;\n            }\n            switch (c[pos.getIndex()]) {\n            case QUOTE:\n                next(pos);\n                return appendTo == null ? null : appendTo.append(c, lastHold,\n                        pos.getIndex() - lastHold);\n            default:\n                next(pos);\n            }\n        }\n        throw new IllegalArgumentException(\n                \"Unterminated quoted string at position \" + start);\n    }\n\n    \n    private void getQuotedString(String pattern, ParsePosition pos, boolean escapingOn) {\n        appendQuotedString(pattern, pos, null, escapingOn);\n    }\n\n    \n    private boolean containsElements(Collection coll) {\n        if (coll == null || coll.size() == 0) {\n            return false;\n        }\n        for (Iterator iter = coll.iterator(); iter.hasNext();) {\n            if (iter.next() != null) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n",
      "buggy_signatures": [
        "public ExtendedMessageFormat(String pattern, Locale locale)",
        "public ExtendedMessageFormat(String pattern, Map registry)",
        "public ExtendedMessageFormat(String pattern, Locale locale, Map registry)",
        "public String toPattern()",
        "public final void applyPattern(String pattern)",
        "public void setFormat(int formatElementIndex, Format newFormat)",
        "public void setFormatByArgumentIndex(int argumentIndex, Format newFormat)",
        "public void setFormats(Format[] newFormats)",
        "public void setFormatsByArgumentIndex(Format[] newFormats)",
        "private Format getFormat(String desc)",
        "private int readArgumentIndex(String pattern, ParsePosition pos)",
        "private String parseFormatDescription(String pattern, ParsePosition pos)",
        "private String insertFormats(String pattern, ArrayList customPatterns)",
        "private void seekNonWs(String pattern, ParsePosition pos)",
        "private ParsePosition next(ParsePosition pos)",
        "private StringBuffer appendQuotedString(String pattern, ParsePosition pos, StringBuffer appendTo, boolean escapingOn)",
        "private void getQuotedString(String pattern, ParsePosition pos, boolean escapingOn)",
        "private boolean containsElements(Collection coll)"
      ],
      "fixed_signatures": [
        "public ExtendedMessageFormat(String pattern, Locale locale)",
        "public ExtendedMessageFormat(String pattern, Map registry)",
        "public ExtendedMessageFormat(String pattern, Locale locale, Map registry)",
        "public String toPattern()",
        "public final void applyPattern(String pattern)",
        "public void setFormat(int formatElementIndex, Format newFormat)",
        "public void setFormatByArgumentIndex(int argumentIndex, Format newFormat)",
        "public void setFormats(Format[] newFormats)",
        "public void setFormatsByArgumentIndex(Format[] newFormats)",
        "private Format getFormat(String desc)",
        "private int readArgumentIndex(String pattern, ParsePosition pos)",
        "private String parseFormatDescription(String pattern, ParsePosition pos)",
        "private String insertFormats(String pattern, ArrayList customPatterns)",
        "private void seekNonWs(String pattern, ParsePosition pos)",
        "private ParsePosition next(ParsePosition pos)",
        "private StringBuffer appendQuotedString(String pattern, ParsePosition pos, StringBuffer appendTo, boolean escapingOn)",
        "private void getQuotedString(String pattern, ParsePosition pos, boolean escapingOn)",
        "private boolean containsElements(Collection coll)"
      ],
      "methods": [
        {
          "buggy_method": "  private StringBuffer appendQuotedString(String pattern, ParsePosition pos, StringBuffer appendTo, boolean escapingOn) {\n  int start = pos.getIndex();\n  char[] c = pattern.toCharArray();\n  if (escapingOn && c[start] == QUOTE) {\n  return appendTo == null ? null : appendTo.append(QUOTE);\n  }\n  int lastHold = start;\n  for (int i = pos.getIndex(); i < pattern.length(); i++) {\n  if (escapingOn && pattern.substring(i).startsWith(ESCAPED_QUOTE)) {\n  appendTo.append(c, lastHold, pos.getIndex() - lastHold).append(\n  QUOTE);\n  pos.setIndex(i + ESCAPED_QUOTE.length());\n  lastHold = pos.getIndex();\n  continue;\n  }\n  switch (c[pos.getIndex()]) {\n  case QUOTE:\n  next(pos);\n  return appendTo == null ? null : appendTo.append(c, lastHold,\n  pos.getIndex() - lastHold);\n  default:\n  next(pos);\n  }\n  }\n  throw new IllegalArgumentException(\n  \"Unterminated quoted string at position \" + start);\n  }",
          "fixed_method": "  private StringBuffer appendQuotedString(String pattern, ParsePosition pos, StringBuffer appendTo, boolean escapingOn) {\n  int start = pos.getIndex();\n  char[] c = pattern.toCharArray();\n  if (escapingOn && c[start] == QUOTE) {\n  next(pos);\n  return appendTo == null ? null : appendTo.append(QUOTE);\n  }\n  int lastHold = start;\n  for (int i = pos.getIndex(); i < pattern.length(); i++) {\n  if (escapingOn && pattern.substring(i).startsWith(ESCAPED_QUOTE)) {\n  appendTo.append(c, lastHold, pos.getIndex() - lastHold).append(\n  QUOTE);\n  pos.setIndex(i + ESCAPED_QUOTE.length());\n  lastHold = pos.getIndex();\n  continue;\n  }\n  switch (c[pos.getIndex()]) {\n  case QUOTE:\n  next(pos);\n  return appendTo == null ? null : appendTo.append(c, lastHold,\n  pos.getIndex() - lastHold);\n  default:\n  next(pos);\n  }\n  }\n  throw new IllegalArgumentException(\n  \"Unterminated quoted string at position \" + start);\n  }",
          "diff": [
            "@@ -419,6 +419,7 @@",
            "         int start = pos.getIndex();\n",
            "         char[] c = pattern.toCharArray();\n",
            "         if (escapingOn && c[start] == QUOTE) {\n",
            "+            next(pos);\n",
            "             return appendTo == null ? null : appendTo.append(QUOTE);\n",
            "         }\n",
            "         int lastHold = start;\n"
          ],
          "changed_lines": 1
        }
      ]
    }
  ]
}
