{
  "bug_id": "46",
  "failed_tests": {
    "org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestampTest": [
      {
        "methodName": "testGettersSetters",
        "error": "junit.framework.AssertionFailedError",
        "message": "Time too big for 32 bits!",
        "fail_line": "            fail(\"Time too big for 32 bits!\");",
        "test_source": "  public void testGettersSetters() {\n  // X5455 is concerned with time, so let's\n  // get a timestamp to play with (Jan 1st, 2000).\n  final Calendar cal = Calendar.getInstance(TimeZone.getTimeZone(\"UTC\"));\n  cal.set(Calendar.YEAR, 2000);\n  cal.set(Calendar.MONTH, Calendar.JANUARY);\n  cal.set(Calendar.DATE, 1);\n  cal.set(Calendar.HOUR_OF_DAY, 0);\n  cal.set(Calendar.MINUTE, 0);\n  cal.set(Calendar.SECOND, 0);\n  cal.set(Calendar.MILLISECOND, 0);\n  final long timeMillis = cal.getTimeInMillis();\n  final ZipLong time = new ZipLong(timeMillis / 1000);\n\n  // set too big\n  try {\n  // Java time is 1000 x larger (milliseconds).\n  xf.setModifyJavaTime(new Date(1000L * (MAX_TIME_SECONDS.getValue() + 1L)));\n  fail(\"Time too big for 32 bits!\");\n  } catch (final IllegalArgumentException iae) {\n  // All is good.\n  }\n\n  // get/set modify time\n  xf.setModifyTime(time);\n  assertEquals(time, xf.getModifyTime());\n  Date xfModifyJavaTime = xf.getModifyJavaTime();\n  assertEquals(timeMillis, xfModifyJavaTime.getTime());\n  xf.setModifyJavaTime(new Date(timeMillis));\n  assertEquals(time, xf.getModifyTime());\n  assertEquals(timeMillis, xf.getModifyJavaTime().getTime());\n  // Make sure milliseconds get zeroed out:\n  xf.setModifyJavaTime(new Date(timeMillis + 123));\n  assertEquals(time, xf.getModifyTime());\n  assertEquals(timeMillis, xf.getModifyJavaTime().getTime());\n  // Null\n  xf.setModifyTime(null);\n  assertNull(xf.getModifyJavaTime());\n  xf.setModifyJavaTime(null);\n  assertNull(xf.getModifyTime());\n\n  // get/set access time\n  xf.setAccessTime(time);\n  assertEquals(time, xf.getAccessTime());\n  assertEquals(timeMillis, xf.getAccessJavaTime().getTime());\n  xf.setAccessJavaTime(new Date(timeMillis));\n  assertEquals(time, xf.getAccessTime());\n  assertEquals(timeMillis, xf.getAccessJavaTime().getTime());\n  // Make sure milliseconds get zeroed out:\n  xf.setAccessJavaTime(new Date(timeMillis + 123));\n  assertEquals(time, xf.getAccessTime());\n  assertEquals(timeMillis, xf.getAccessJavaTime().getTime());\n  // Null\n  xf.setAccessTime(null);\n  assertNull(xf.getAccessJavaTime());\n  xf.setAccessJavaTime(null);\n  assertNull(xf.getAccessTime());\n\n  // get/set create time\n  xf.setCreateTime(time);\n  assertEquals(time, xf.getCreateTime());\n  assertEquals(timeMillis, xf.getCreateJavaTime().getTime());\n  xf.setCreateJavaTime(new Date(timeMillis));\n  assertEquals(time, xf.getCreateTime());\n  assertEquals(timeMillis, xf.getCreateJavaTime().getTime());\n  // Make sure milliseconds get zeroed out:\n  xf.setCreateJavaTime(new Date(timeMillis + 123));\n  assertEquals(time, xf.getCreateTime());\n  assertEquals(timeMillis, xf.getCreateJavaTime().getTime());\n  // Null\n  xf.setCreateTime(null);\n  assertNull(xf.getCreateJavaTime());\n  xf.setCreateJavaTime(null);\n  assertNull(xf.getCreateTime());\n\n\n  // initialize for flags\n  xf.setModifyTime(time);\n  xf.setAccessTime(time);\n  xf.setCreateTime(time);\n\n  // get/set flags: 000\n  xf.setFlags((byte) 0);\n  assertEquals(0, xf.getFlags());\n  assertFalse(xf.isBit0_modifyTimePresent());\n  assertFalse(xf.isBit1_accessTimePresent());\n  assertFalse(xf.isBit2_createTimePresent());\n  // Local length=1, Central length=1 (flags only!)\n  assertEquals(1, xf.getLocalFileDataLength().getValue());\n  assertEquals(1, xf.getCentralDirectoryLength().getValue());\n\n  // get/set flags: 001\n  xf.setFlags((byte) 1);\n  assertEquals(1, xf.getFlags());\n  assertTrue(xf.isBit0_modifyTimePresent());\n  assertFalse(xf.isBit1_accessTimePresent());\n  assertFalse(xf.isBit2_createTimePresent());\n  // Local length=5, Central length=5 (flags + mod)\n  assertEquals(5, xf.getLocalFileDataLength().getValue());\n  assertEquals(5, xf.getCentralDirectoryLength().getValue());\n\n  // get/set flags: 010\n  xf.setFlags((byte) 2);\n  assertEquals(2, xf.getFlags());\n  assertFalse(xf.isBit0_modifyTimePresent());\n  assertTrue(xf.isBit1_accessTimePresent());\n  assertFalse(xf.isBit2_createTimePresent());\n  // Local length=5, Central length=1\n  assertEquals(5, xf.getLocalFileDataLength().getValue());\n  assertEquals(1, xf.getCentralDirectoryLength().getValue());\n\n  // get/set flags: 100\n  xf.setFlags((byte) 4);\n  assertEquals(4, xf.getFlags());\n  assertFalse(xf.isBit0_modifyTimePresent());\n  assertFalse(xf.isBit1_accessTimePresent());\n  assertTrue(xf.isBit2_createTimePresent());\n  // Local length=5, Central length=1\n  assertEquals(5, xf.getLocalFileDataLength().getValue());\n  assertEquals(1, xf.getCentralDirectoryLength().getValue());\n\n  // get/set flags: 111\n  xf.setFlags((byte) 7);\n  assertEquals(7, xf.getFlags());\n  assertTrue(xf.isBit0_modifyTimePresent());\n  assertTrue(xf.isBit1_accessTimePresent());\n  assertTrue(xf.isBit2_createTimePresent());\n  // Local length=13, Central length=5\n  assertEquals(13, xf.getLocalFileDataLength().getValue());\n  assertEquals(5, xf.getCentralDirectoryLength().getValue());\n\n  // get/set flags: 11111111\n  xf.setFlags((byte) -1);\n  assertEquals(-1, xf.getFlags());\n  assertTrue(xf.isBit0_modifyTimePresent());\n  assertTrue(xf.isBit1_accessTimePresent());\n  assertTrue(xf.isBit2_createTimePresent());\n  // Local length=13, Central length=5\n  assertEquals(13, xf.getLocalFileDataLength().getValue());\n  assertEquals(5, xf.getCentralDirectoryLength().getValue());\n  }",
        "stack": [
          "X5455_ExtendedTimestampTest.testGettersSetters line 215"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/compress/archivers/zip/X5455_ExtendedTimestamp.java",
      "buggy_full_code": "\npackage org.apache.commons.compress.archivers.zip;\n\nimport java.io.Serializable;\nimport java.util.Date;\nimport java.util.zip.ZipException;\n\n\npublic class X5455_ExtendedTimestamp implements ZipExtraField, Cloneable, Serializable { private static final ZipShort HEADER_ID = new ZipShort(0x5455); private static final long serialVersionUID = 1L; public static final byte MODIFY_TIME_BIT = 1; public static final byte ACCESS_TIME_BIT = 2; public static final byte CREATE_TIME_BIT = 4; private byte flags; private boolean bit0_modifyTimePresent; private boolean bit1_accessTimePresent; private boolean bit2_createTimePresent; private ZipLong modifyTime; private ZipLong accessTime; private ZipLong createTime; public X5455_ExtendedTimestamp() {}\n\n    \n    @Override\n    public ZipShort getHeaderId() {\n        return HEADER_ID;\n    }\n\n    \n    @Override\n    public ZipShort getLocalFileDataLength() {\n        return new ZipShort(1 +\n                (bit0_modifyTimePresent ? 4 : 0) +\n                (bit1_accessTimePresent && accessTime != null ? 4 : 0) +\n                (bit2_createTimePresent && createTime != null ? 4 : 0)\n        );\n    }\n\n    \n    @Override\n    public ZipShort getCentralDirectoryLength() {\n        return new ZipShort(1 +\n                (bit0_modifyTimePresent ? 4 : 0)\n        );\n    }\n\n    \n    @Override\n    public byte[] getLocalFileDataData() {\n        final byte[] data = new byte[getLocalFileDataLength().getValue()];\n        int pos = 0;\n        data[pos++] = 0;\n        if (bit0_modifyTimePresent) {\n            data[0] |= MODIFY_TIME_BIT;\n            System.arraycopy(modifyTime.getBytes(), 0, data, pos, 4);\n            pos += 4;\n        }\n        if (bit1_accessTimePresent && accessTime != null) {\n            data[0] |= ACCESS_TIME_BIT;\n            System.arraycopy(accessTime.getBytes(), 0, data, pos, 4);\n            pos += 4;\n        }\n        if (bit2_createTimePresent && createTime != null) {\n            data[0] |= CREATE_TIME_BIT;\n            System.arraycopy(createTime.getBytes(), 0, data, pos, 4);\n            pos += 4; \n        }\n        return data;\n    }\n\n    \n    @Override\n    public byte[] getCentralDirectoryData() {\n        final byte[] centralData = new byte[getCentralDirectoryLength().getValue()];\n        final byte[] localData = getLocalFileDataData();\n\n        \n        \n        System.arraycopy(localData, 0, centralData, 0, centralData.length);\n        return centralData;\n    }\n\n    \n    @Override\n    public void parseFromLocalFileData( final byte[] data, int offset, final int length ) throws ZipException {\n        reset();\n        final int len = offset + length;\n        setFlags(data[offset++]);\n        if (bit0_modifyTimePresent) {\n            modifyTime = new ZipLong(data, offset);\n            offset += 4;\n        }\n\n        \n        \n        if (bit1_accessTimePresent && offset + 4 <= len) {\n            accessTime = new ZipLong(data, offset);\n            offset += 4;\n        }\n        if (bit2_createTimePresent && offset + 4 <= len) {\n            createTime = new ZipLong(data, offset);\n            offset += 4; \n        }\n    }\n\n    \n    @Override\n    public void parseFromCentralDirectoryData( final byte[] buffer, final int offset, final int length ) throws ZipException {\n        reset();\n        parseFromLocalFileData(buffer, offset, length);\n    }\n\n    \n    private void reset() {\n        setFlags((byte) 0);\n        this.modifyTime = null;\n        this.accessTime = null;\n        this.createTime = null;\n    }\n\n    \n    public void setFlags(final byte flags) {\n        this.flags = flags;\n        this.bit0_modifyTimePresent = (flags & MODIFY_TIME_BIT) == MODIFY_TIME_BIT;\n        this.bit1_accessTimePresent = (flags & ACCESS_TIME_BIT) == ACCESS_TIME_BIT;\n        this.bit2_createTimePresent = (flags & CREATE_TIME_BIT) == CREATE_TIME_BIT;\n    }\n\n    \n    public byte getFlags() { return flags; }\n\n    \n    public boolean isBit0_modifyTimePresent() { return bit0_modifyTimePresent; }\n\n    \n    public boolean isBit1_accessTimePresent() { return bit1_accessTimePresent; }\n\n    \n    public boolean isBit2_createTimePresent() { return bit2_createTimePresent; }\n\n    \n    public ZipLong getModifyTime() { return modifyTime; }\n\n    \n    public ZipLong getAccessTime() { return accessTime; }\n\n    \n    public ZipLong getCreateTime() { return createTime; }\n\n    \n    public Date getModifyJavaTime() {\n        return zipLongToDate(modifyTime);\n    }\n\n    \n    public Date getAccessJavaTime() {\n        return zipLongToDate(accessTime);\n    }\n\n    private static Date zipLongToDate(ZipLong unixTime) {\n        return unixTime != null ? new Date(unixTime.getIntValue() * 1000L) : null;\n    }\n\n    \n    public Date getCreateJavaTime() {\n        return zipLongToDate(createTime);\n    }\n\n    \n    public void setModifyTime(final ZipLong l) {\n        bit0_modifyTimePresent = l != null;\n        flags = (byte) (l != null ? (flags | MODIFY_TIME_BIT)\n                        : (flags & ~MODIFY_TIME_BIT));\n        this.modifyTime = l;\n    }\n\n    \n    public void setAccessTime(final ZipLong l) {\n        bit1_accessTimePresent = l != null;\n        flags = (byte) (l != null ? (flags | ACCESS_TIME_BIT)\n                        : (flags & ~ACCESS_TIME_BIT));\n        this.accessTime = l;\n    }\n\n    \n    public void setCreateTime(final ZipLong l) {\n        bit2_createTimePresent = l != null;\n        flags = (byte) (l != null ? (flags | CREATE_TIME_BIT)\n                        : (flags & ~CREATE_TIME_BIT));\n        this.createTime = l;\n    }\n\n    \n    public void setModifyJavaTime(final Date d) { setModifyTime(dateToZipLong(d)); }\n\n    \n    public void setAccessJavaTime(final Date d) { setAccessTime(dateToZipLong(d)); }\n\n    \n    public void setCreateJavaTime(final Date d) { setCreateTime(dateToZipLong(d)); }\n\n    \n    private static ZipLong dateToZipLong(final Date d) {\n        if (d == null) { return null; }\n\n        return unixTimeToZipLong(d.getTime() / 1000);\n    }\n\n    private static ZipLong unixTimeToZipLong(long l) {\n        final long TWO_TO_32 = 0x100000000L;\n        if (l >= TWO_TO_32) {\n            throw new IllegalArgumentException(\"X5455 timestamps must fit in a signed 32 bit integer: \" + l);\n        }\n        return new ZipLong(l);\n    }\n\n    \n    @Override\n    public String toString() {\n        final StringBuilder buf = new StringBuilder();\n        buf.append(\"0x5455 Zip Extra Field: Flags=\");\n        buf.append(Integer.toBinaryString(ZipUtil.unsignedIntToSignedByte(flags))).append(\" \");\n        if (bit0_modifyTimePresent && modifyTime != null) {\n            final Date m = getModifyJavaTime();\n            buf.append(\" Modify:[\").append(m).append(\"] \");\n        }\n        if (bit1_accessTimePresent && accessTime != null) {\n            final Date a = getAccessJavaTime();\n            buf.append(\" Access:[\").append(a).append(\"] \");\n        }\n        if (bit2_createTimePresent && createTime != null) {\n            final Date c = getCreateJavaTime();\n            buf.append(\" Create:[\").append(c).append(\"] \");\n        }\n        return buf.toString();\n    }\n\n    @Override\n    public Object clone() throws CloneNotSupportedException {\n        return super.clone();\n    }\n\n    @Override\n    public boolean equals(final Object o) {\n        if (o instanceof X5455_ExtendedTimestamp) {\n            final X5455_ExtendedTimestamp xf = (X5455_ExtendedTimestamp) o;\n\n            \n            \n            return ((flags & 0x07) == (xf.flags & 0x07)) &&\n                    (modifyTime == xf.modifyTime || (modifyTime != null && modifyTime.equals(xf.modifyTime))) &&\n                    (accessTime == xf.accessTime || (accessTime != null && accessTime.equals(xf.accessTime))) &&\n                    (createTime == xf.createTime || (createTime != null && createTime.equals(xf.createTime)));\n        }\n        return false;\n    }\n\n    @Override\n    public int hashCode() {\n        int hc = (-123 * (flags & 0x07)); \n        if (modifyTime != null) {\n            hc ^= modifyTime.hashCode();\n        }\n        if (accessTime != null) {\n            \n            \n            hc ^= Integer.rotateLeft(accessTime.hashCode(), 11);\n        }\n        if (createTime != null) {\n            hc ^= Integer.rotateLeft(createTime.hashCode(), 22);\n        }\n        return hc;\n    }\n\n}\n",
      "fixed_full_code": "\npackage org.apache.commons.compress.archivers.zip;\n\nimport java.io.Serializable;\nimport java.util.Date;\nimport java.util.zip.ZipException;\n\n\npublic class X5455_ExtendedTimestamp implements ZipExtraField, Cloneable, Serializable { private static final ZipShort HEADER_ID = new ZipShort(0x5455); private static final long serialVersionUID = 1L; public static final byte MODIFY_TIME_BIT = 1; public static final byte ACCESS_TIME_BIT = 2; public static final byte CREATE_TIME_BIT = 4; private byte flags; private boolean bit0_modifyTimePresent; private boolean bit1_accessTimePresent; private boolean bit2_createTimePresent; private ZipLong modifyTime; private ZipLong accessTime; private ZipLong createTime; public X5455_ExtendedTimestamp() {}\n\n    \n    @Override\n    public ZipShort getHeaderId() {\n        return HEADER_ID;\n    }\n\n    \n    @Override\n    public ZipShort getLocalFileDataLength() {\n        return new ZipShort(1 +\n                (bit0_modifyTimePresent ? 4 : 0) +\n                (bit1_accessTimePresent && accessTime != null ? 4 : 0) +\n                (bit2_createTimePresent && createTime != null ? 4 : 0)\n        );\n    }\n\n    \n    @Override\n    public ZipShort getCentralDirectoryLength() {\n        return new ZipShort(1 +\n                (bit0_modifyTimePresent ? 4 : 0)\n        );\n    }\n\n    \n    @Override\n    public byte[] getLocalFileDataData() {\n        final byte[] data = new byte[getLocalFileDataLength().getValue()];\n        int pos = 0;\n        data[pos++] = 0;\n        if (bit0_modifyTimePresent) {\n            data[0] |= MODIFY_TIME_BIT;\n            System.arraycopy(modifyTime.getBytes(), 0, data, pos, 4);\n            pos += 4;\n        }\n        if (bit1_accessTimePresent && accessTime != null) {\n            data[0] |= ACCESS_TIME_BIT;\n            System.arraycopy(accessTime.getBytes(), 0, data, pos, 4);\n            pos += 4;\n        }\n        if (bit2_createTimePresent && createTime != null) {\n            data[0] |= CREATE_TIME_BIT;\n            System.arraycopy(createTime.getBytes(), 0, data, pos, 4);\n            pos += 4; \n        }\n        return data;\n    }\n\n    \n    @Override\n    public byte[] getCentralDirectoryData() {\n        final byte[] centralData = new byte[getCentralDirectoryLength().getValue()];\n        final byte[] localData = getLocalFileDataData();\n\n        \n        \n        System.arraycopy(localData, 0, centralData, 0, centralData.length);\n        return centralData;\n    }\n\n    \n    @Override\n    public void parseFromLocalFileData( final byte[] data, int offset, final int length ) throws ZipException {\n        reset();\n        final int len = offset + length;\n        setFlags(data[offset++]);\n        if (bit0_modifyTimePresent) {\n            modifyTime = new ZipLong(data, offset);\n            offset += 4;\n        }\n\n        \n        \n        if (bit1_accessTimePresent && offset + 4 <= len) {\n            accessTime = new ZipLong(data, offset);\n            offset += 4;\n        }\n        if (bit2_createTimePresent && offset + 4 <= len) {\n            createTime = new ZipLong(data, offset);\n            offset += 4; \n        }\n    }\n\n    \n    @Override\n    public void parseFromCentralDirectoryData( final byte[] buffer, final int offset, final int length ) throws ZipException {\n        reset();\n        parseFromLocalFileData(buffer, offset, length);\n    }\n\n    \n    private void reset() {\n        setFlags((byte) 0);\n        this.modifyTime = null;\n        this.accessTime = null;\n        this.createTime = null;\n    }\n\n    \n    public void setFlags(final byte flags) {\n        this.flags = flags;\n        this.bit0_modifyTimePresent = (flags & MODIFY_TIME_BIT) == MODIFY_TIME_BIT;\n        this.bit1_accessTimePresent = (flags & ACCESS_TIME_BIT) == ACCESS_TIME_BIT;\n        this.bit2_createTimePresent = (flags & CREATE_TIME_BIT) == CREATE_TIME_BIT;\n    }\n\n    \n    public byte getFlags() { return flags; }\n\n    \n    public boolean isBit0_modifyTimePresent() { return bit0_modifyTimePresent; }\n\n    \n    public boolean isBit1_accessTimePresent() { return bit1_accessTimePresent; }\n\n    \n    public boolean isBit2_createTimePresent() { return bit2_createTimePresent; }\n\n    \n    public ZipLong getModifyTime() { return modifyTime; }\n\n    \n    public ZipLong getAccessTime() { return accessTime; }\n\n    \n    public ZipLong getCreateTime() { return createTime; }\n\n    \n    public Date getModifyJavaTime() {\n        return zipLongToDate(modifyTime);\n    }\n\n    \n    public Date getAccessJavaTime() {\n        return zipLongToDate(accessTime);\n    }\n\n    private static Date zipLongToDate(ZipLong unixTime) {\n        return unixTime != null ? new Date(unixTime.getIntValue() * 1000L) : null;\n    }\n\n    \n    public Date getCreateJavaTime() {\n        return zipLongToDate(createTime);\n    }\n\n    \n    public void setModifyTime(final ZipLong l) {\n        bit0_modifyTimePresent = l != null;\n        flags = (byte) (l != null ? (flags | MODIFY_TIME_BIT)\n                        : (flags & ~MODIFY_TIME_BIT));\n        this.modifyTime = l;\n    }\n\n    \n    public void setAccessTime(final ZipLong l) {\n        bit1_accessTimePresent = l != null;\n        flags = (byte) (l != null ? (flags | ACCESS_TIME_BIT)\n                        : (flags & ~ACCESS_TIME_BIT));\n        this.accessTime = l;\n    }\n\n    \n    public void setCreateTime(final ZipLong l) {\n        bit2_createTimePresent = l != null;\n        flags = (byte) (l != null ? (flags | CREATE_TIME_BIT)\n                        : (flags & ~CREATE_TIME_BIT));\n        this.createTime = l;\n    }\n\n    \n    public void setModifyJavaTime(final Date d) { setModifyTime(dateToZipLong(d)); }\n\n    \n    public void setAccessJavaTime(final Date d) { setAccessTime(dateToZipLong(d)); }\n\n    \n    public void setCreateJavaTime(final Date d) { setCreateTime(dateToZipLong(d)); }\n\n    \n    private static ZipLong dateToZipLong(final Date d) {\n        if (d == null) { return null; }\n\n        return unixTimeToZipLong(d.getTime() / 1000);\n    }\n\n    private static ZipLong unixTimeToZipLong(long l) {\n        if (l < Integer.MIN_VALUE || l > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\"X5455 timestamps must fit in a signed 32 bit integer: \" + l);\n        }\n        return new ZipLong(l);\n    }\n\n    \n    @Override\n    public String toString() {\n        final StringBuilder buf = new StringBuilder();\n        buf.append(\"0x5455 Zip Extra Field: Flags=\");\n        buf.append(Integer.toBinaryString(ZipUtil.unsignedIntToSignedByte(flags))).append(\" \");\n        if (bit0_modifyTimePresent && modifyTime != null) {\n            final Date m = getModifyJavaTime();\n            buf.append(\" Modify:[\").append(m).append(\"] \");\n        }\n        if (bit1_accessTimePresent && accessTime != null) {\n            final Date a = getAccessJavaTime();\n            buf.append(\" Access:[\").append(a).append(\"] \");\n        }\n        if (bit2_createTimePresent && createTime != null) {\n            final Date c = getCreateJavaTime();\n            buf.append(\" Create:[\").append(c).append(\"] \");\n        }\n        return buf.toString();\n    }\n\n    @Override\n    public Object clone() throws CloneNotSupportedException {\n        return super.clone();\n    }\n\n    @Override\n    public boolean equals(final Object o) {\n        if (o instanceof X5455_ExtendedTimestamp) {\n            final X5455_ExtendedTimestamp xf = (X5455_ExtendedTimestamp) o;\n\n            \n            \n            return ((flags & 0x07) == (xf.flags & 0x07)) &&\n                    (modifyTime == xf.modifyTime || (modifyTime != null && modifyTime.equals(xf.modifyTime))) &&\n                    (accessTime == xf.accessTime || (accessTime != null && accessTime.equals(xf.accessTime))) &&\n                    (createTime == xf.createTime || (createTime != null && createTime.equals(xf.createTime)));\n        }\n        return false;\n    }\n\n    @Override\n    public int hashCode() {\n        int hc = (-123 * (flags & 0x07)); \n        if (modifyTime != null) {\n            hc ^= modifyTime.hashCode();\n        }\n        if (accessTime != null) {\n            \n            \n            hc ^= Integer.rotateLeft(accessTime.hashCode(), 11);\n        }\n        if (createTime != null) {\n            hc ^= Integer.rotateLeft(createTime.hashCode(), 22);\n        }\n        return hc;\n    }\n\n}\n",
      "buggy_signatures": [
        "public ZipShort getHeaderId()",
        "public ZipShort getLocalFileDataLength()",
        "public ZipShort getCentralDirectoryLength()",
        "public byte[] getLocalFileDataData()",
        "public byte[] getCentralDirectoryData()",
        "public void parseFromLocalFileData( final byte[] data, int offset, final int length ) throws ZipException",
        "public void parseFromCentralDirectoryData( final byte[] buffer, final int offset, final int length ) throws ZipException",
        "private void reset()",
        "public void setFlags(final byte flags)",
        "public byte getFlags()",
        "public boolean isBit0_modifyTimePresent()",
        "public boolean isBit1_accessTimePresent()",
        "public boolean isBit2_createTimePresent()",
        "public ZipLong getModifyTime()",
        "public ZipLong getAccessTime()",
        "public ZipLong getCreateTime()",
        "public Date getModifyJavaTime()",
        "public Date getAccessJavaTime()",
        "private static Date zipLongToDate(ZipLong unixTime)",
        "public Date getCreateJavaTime()",
        "public void setModifyTime(final ZipLong l)",
        "public void setAccessTime(final ZipLong l)",
        "public void setCreateTime(final ZipLong l)",
        "public void setModifyJavaTime(final Date d)",
        "public void setAccessJavaTime(final Date d)",
        "public void setCreateJavaTime(final Date d)",
        "private static ZipLong dateToZipLong(final Date d)",
        "private static ZipLong unixTimeToZipLong(long l)",
        "public String toString()",
        "public Object clone() throws CloneNotSupportedException",
        "public boolean equals(final Object o)",
        "public int hashCode()"
      ],
      "fixed_signatures": [
        "public ZipShort getHeaderId()",
        "public ZipShort getLocalFileDataLength()",
        "public ZipShort getCentralDirectoryLength()",
        "public byte[] getLocalFileDataData()",
        "public byte[] getCentralDirectoryData()",
        "public void parseFromLocalFileData( final byte[] data, int offset, final int length ) throws ZipException",
        "public void parseFromCentralDirectoryData( final byte[] buffer, final int offset, final int length ) throws ZipException",
        "private void reset()",
        "public void setFlags(final byte flags)",
        "public byte getFlags()",
        "public boolean isBit0_modifyTimePresent()",
        "public boolean isBit1_accessTimePresent()",
        "public boolean isBit2_createTimePresent()",
        "public ZipLong getModifyTime()",
        "public ZipLong getAccessTime()",
        "public ZipLong getCreateTime()",
        "public Date getModifyJavaTime()",
        "public Date getAccessJavaTime()",
        "private static Date zipLongToDate(ZipLong unixTime)",
        "public Date getCreateJavaTime()",
        "public void setModifyTime(final ZipLong l)",
        "public void setAccessTime(final ZipLong l)",
        "public void setCreateTime(final ZipLong l)",
        "public void setModifyJavaTime(final Date d)",
        "public void setAccessJavaTime(final Date d)",
        "public void setCreateJavaTime(final Date d)",
        "private static ZipLong dateToZipLong(final Date d)",
        "private static ZipLong unixTimeToZipLong(long l)",
        "public String toString()",
        "public Object clone() throws CloneNotSupportedException",
        "public boolean equals(final Object o)",
        "public int hashCode()"
      ],
      "methods": [
        {
          "buggy_method": "  private static ZipLong unixTimeToZipLong(long l) {\n  final long TWO_TO_32 = 0x100000000L;\n  if (l >= TWO_TO_32) {\n  throw new IllegalArgumentException(\"X5455 timestamps must fit in a signed 32 bit integer: \" + l);\n  }\n  return new ZipLong(l);\n  }",
          "fixed_method": "  private static ZipLong unixTimeToZipLong(long l) {\n  if (l < Integer.MIN_VALUE || l > Integer.MAX_VALUE) {\n  throw new IllegalArgumentException(\"X5455 timestamps must fit in a signed 32 bit integer: \" + l);\n  }\n  return new ZipLong(l);\n  }",
          "diff": [
            "@@ -526,8 +526,7 @@",
            "     }\n",
            " \n",
            "     private static ZipLong unixTimeToZipLong(long l) {\n",
            "-        final long TWO_TO_32 = 0x100000000L;\n",
            "-        if (l >= TWO_TO_32) {\n",
            "+        if (l < Integer.MIN_VALUE || l > Integer.MAX_VALUE) {\n",
            "             throw new IllegalArgumentException(\"X5455 timestamps must fit in a signed 32 bit integer: \" + l);\n",
            "         }\n",
            "         return new ZipLong(l);\n"
          ],
          "changed_lines": 3
        }
      ]
    }
  ]
}
