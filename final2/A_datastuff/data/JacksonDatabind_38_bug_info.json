{
  "bug_id": "38",
  "failed_tests": {
    "com.fasterxml.jackson.databind.interop.DeprecatedTypeHandling1102Test": [
      {
        "methodName": "testExplicitMapType",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<class com.fasterxml.jackson.databind.interop.DeprecatedTypeHandling1102Test$Point> but was:<class java.util.LinkedHashMap>",
        "fail_line": "        assertEquals(Point.class, ob.getClass());",
        "test_source": "  public void testExplicitMapType() throws Exception {\n  JavaType key = SimpleType.construct(String.class);\n  JavaType elem = SimpleType.construct(Point.class);\n  JavaType t = MapType.construct(Map.class, key, elem);\n\n  final String json = aposToQuotes(\"{'x':{'x':3,'y':5}}\");  \n\n  Map<String,Point> m = MAPPER.readValue(json, t);\n  assertNotNull(m);\n  assertEquals(1, m.size());\n  Object ob = m.values().iterator().next();\n  assertEquals(Point.class, ob.getClass());\n  Point p = (Point) ob;\n  assertEquals(3, p.x);\n  assertEquals(5, p.getY());\n  }",
        "stack": [
          "DeprecatedTypeHandling1102Test.testExplicitMapType line 85"
        ]
      },
      {
        "methodName": "testExplicitCollectionType",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<class com.fasterxml.jackson.databind.interop.DeprecatedTypeHandling1102Test$Point> but was:<class java.util.LinkedHashMap>",
        "fail_line": "        assertEquals(Point.class, ob.getClass());",
        "test_source": "  public void testExplicitCollectionType() throws Exception {\n  JavaType elem = SimpleType.construct(Point.class);\n  JavaType t = CollectionType.construct(List.class, elem);\n\n  final String json = aposToQuotes(\"[ {'x':1,'y':2}, {'x':3,'y':6 }]\");  \n\n  List<Point> l = MAPPER.readValue(json, t);\n  assertNotNull(l);\n  assertEquals(2, l.size());\n  Object ob = l.get(0);\n  assertEquals(Point.class, ob.getClass());\n  Point p = (Point) ob;\n  assertEquals(1, p.x);\n  assertEquals(2, p.getY());\n  }",
        "stack": [
          "DeprecatedTypeHandling1102Test.testExplicitCollectionType line 66"
        ]
      },
      {
        "methodName": "testPOJOSubType",
        "error": "com.fasterxml.jackson.databind.exc.UnrecognizedPropertyException",
        "message": "Unrecognized field \"x\" (class com.fasterxml.jackson.databind.interop.DeprecatedTypeHandling1102Test$Point3D), not marked as ignorable (one known property: \"z\"])",
        "fail_line": "        Point3D p = MAPPER.readValue(aposToQuotes(\"{'x':1,'z':3,'y':2}\"), elem);",
        "test_source": "  public void testPOJOSubType() throws Exception {\n  JavaType elem = SimpleType.construct(Point3D.class);\n\n  Point3D p = MAPPER.readValue(aposToQuotes(\"{'x':1,'z':3,'y':2}\"), elem);\n  assertNotNull(p);\n  assertEquals(1, p.x);\n  assertEquals(2, p.getY());\n  assertEquals(3, p.z);\n  }",
        "stack": [
          "UnrecognizedPropertyException.from line 63, DeserializationContext.reportUnknownProperty line 855, StdDeserializer.handleUnknownProperty line 1083, BeanDeserializerBase.handleUnknownProperty line 1389, BeanDeserializerBase.handleUnknownVanilla line 1367, BeanDeserializer.vanillaDeserialize line 266, BeanDeserializer.deserialize line 125, ObjectMapper._readMapAndClose line 3788, ObjectMapper.readValue line 2817, DeprecatedTypeHandling1102Test.testPOJOSubType line 47"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "com/fasterxml/jackson/databind/type/CollectionType.java",
      "buggy_full_code": "package com.fasterxml.jackson.databind.type;\n\n\nimport com.fasterxml.jackson.databind.JavaType;\n\n\npublic final class CollectionType extends CollectionLikeType { private static final long serialVersionUID = 1L; private CollectionType(Class<?> collT, TypeBindings bindings, JavaType superClass, JavaType[] superInts, JavaType elemT, Object valueHandler, Object typeHandler, boolean asStatic) {\n        super(collT, bindings, superClass, superInts, elemT, valueHandler, typeHandler, asStatic);\n    }\n\n    \n    protected CollectionType(TypeBase base, JavaType elemT) {\n        super(base, elemT);\n    }\n\n    \n    public static CollectionType construct(Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInts, JavaType elemT) {\n        return new CollectionType(rawType, bindings, superClass, superInts, elemT,\n                null, null, false);\n    }\n\n    \n    @Deprecated \n    public static CollectionType construct(Class<?> rawType, JavaType elemT) {\n        \n        \n        return new CollectionType(rawType, null,\n                \n                _bogusSuperClass(rawType), null, elemT,\n                null, null, false);\n    }\n\n    @Deprecated \n    @Override\n    protected JavaType _narrow(Class<?> subclass) {\n        return new CollectionType(subclass, _bindings,\n                _superClass, _superInterfaces, _elementType, null, null, _asStatic);\n    }\n\n    @Override\n    public JavaType withContentType(JavaType contentType) {\n        if (_elementType == contentType) {\n            return this;\n        }\n        return new CollectionType(_class, _bindings, _superClass, _superInterfaces,\n                contentType, _valueHandler, _typeHandler, _asStatic);\n    }\n    \n    @Override\n    public CollectionType withTypeHandler(Object h) {\n        return new CollectionType(_class, _bindings,\n                _superClass, _superInterfaces, _elementType, _valueHandler, h, _asStatic);\n    }\n\n    @Override\n    public CollectionType withContentTypeHandler(Object h) {\n        return new CollectionType(_class, _bindings,\n                _superClass, _superInterfaces, _elementType.withTypeHandler(h),\n                _valueHandler, _typeHandler, _asStatic);\n    }\n\n    @Override\n    public CollectionType withValueHandler(Object h) {\n        return new CollectionType(_class, _bindings,\n                _superClass, _superInterfaces, _elementType, h, _typeHandler, _asStatic);\n    }\n\n    @Override\n    public CollectionType withContentValueHandler(Object h) {\n        return new CollectionType(_class, _bindings,\n                _superClass, _superInterfaces, _elementType.withValueHandler(h),\n                _valueHandler, _typeHandler, _asStatic);\n    }\n\n    @Override\n    public CollectionType withStaticTyping() {\n        if (_asStatic) {\n            return this;\n        }\n        return new CollectionType(_class, _bindings,\n                _superClass, _superInterfaces, _elementType.withStaticTyping(),\n                _valueHandler, _typeHandler, true);\n    }\n\n    @Override\n    public JavaType refine(Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) {\n        return new CollectionType(rawType, bindings,\n                superClass, superInterfaces, _elementType,\n                _valueHandler, _typeHandler, _asStatic);\n    }\n\n    \n\n    @Override\n    public String toString() {\n        return \"[collection type; class \"+_class.getName()+\", contains \"+_elementType+\"]\";\n    }\n}\n",
      "fixed_full_code": "package com.fasterxml.jackson.databind.type;\n\nimport java.lang.reflect.TypeVariable;\n\nimport com.fasterxml.jackson.databind.JavaType;\n\n\npublic final class CollectionType extends CollectionLikeType { private static final long serialVersionUID = 1L; private CollectionType(Class<?> collT, TypeBindings bindings, JavaType superClass, JavaType[] superInts, JavaType elemT, Object valueHandler, Object typeHandler, boolean asStatic) {\n        super(collT, bindings, superClass, superInts, elemT, valueHandler, typeHandler, asStatic);\n    }\n\n    \n    protected CollectionType(TypeBase base, JavaType elemT) {\n        super(base, elemT);\n    }\n\n    \n    public static CollectionType construct(Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInts, JavaType elemT) {\n        return new CollectionType(rawType, bindings, superClass, superInts, elemT,\n                null, null, false);\n    }\n\n    \n    @Deprecated \n    public static CollectionType construct(Class<?> rawType, JavaType elemT) {\n        \n        \n        TypeVariable<?>[] vars = rawType.getTypeParameters();\n        TypeBindings bindings;\n        if ((vars == null) || (vars.length != 1)) {\n            bindings = TypeBindings.emptyBindings();\n        } else {\n            bindings = TypeBindings.create(rawType, elemT);\n        }\n        return new CollectionType(rawType, bindings,\n                \n                _bogusSuperClass(rawType), null, elemT,\n                null, null, false);\n    }\n\n    @Deprecated \n    @Override\n    protected JavaType _narrow(Class<?> subclass) {\n        return new CollectionType(subclass, _bindings,\n                _superClass, _superInterfaces, _elementType, null, null, _asStatic);\n    }\n\n    @Override\n    public JavaType withContentType(JavaType contentType) {\n        if (_elementType == contentType) {\n            return this;\n        }\n        return new CollectionType(_class, _bindings, _superClass, _superInterfaces,\n                contentType, _valueHandler, _typeHandler, _asStatic);\n    }\n    \n    @Override\n    public CollectionType withTypeHandler(Object h) {\n        return new CollectionType(_class, _bindings,\n                _superClass, _superInterfaces, _elementType, _valueHandler, h, _asStatic);\n    }\n\n    @Override\n    public CollectionType withContentTypeHandler(Object h) {\n        return new CollectionType(_class, _bindings,\n                _superClass, _superInterfaces, _elementType.withTypeHandler(h),\n                _valueHandler, _typeHandler, _asStatic);\n    }\n\n    @Override\n    public CollectionType withValueHandler(Object h) {\n        return new CollectionType(_class, _bindings,\n                _superClass, _superInterfaces, _elementType, h, _typeHandler, _asStatic);\n    }\n\n    @Override\n    public CollectionType withContentValueHandler(Object h) {\n        return new CollectionType(_class, _bindings,\n                _superClass, _superInterfaces, _elementType.withValueHandler(h),\n                _valueHandler, _typeHandler, _asStatic);\n    }\n\n    @Override\n    public CollectionType withStaticTyping() {\n        if (_asStatic) {\n            return this;\n        }\n        return new CollectionType(_class, _bindings,\n                _superClass, _superInterfaces, _elementType.withStaticTyping(),\n                _valueHandler, _typeHandler, true);\n    }\n\n    @Override\n    public JavaType refine(Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) {\n        return new CollectionType(rawType, bindings,\n                superClass, superInterfaces, _elementType,\n                _valueHandler, _typeHandler, _asStatic);\n    }\n\n    \n\n    @Override\n    public String toString() {\n        return \"[collection type; class \"+_class.getName()+\", contains \"+_elementType+\"]\";\n    }\n}\n",
      "buggy_signatures": [
        "protected CollectionType(TypeBase base, JavaType elemT)",
        "public static CollectionType construct(Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInts, JavaType elemT)",
        "public static CollectionType construct(Class<?> rawType, JavaType elemT)",
        "protected JavaType _narrow(Class<?> subclass)",
        "public JavaType withContentType(JavaType contentType)",
        "public CollectionType withTypeHandler(Object h)",
        "public CollectionType withContentTypeHandler(Object h)",
        "public CollectionType withValueHandler(Object h)",
        "public CollectionType withContentValueHandler(Object h)",
        "public CollectionType withStaticTyping()",
        "public JavaType refine(Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces)",
        "public String toString()"
      ],
      "fixed_signatures": [
        "protected CollectionType(TypeBase base, JavaType elemT)",
        "public static CollectionType construct(Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInts, JavaType elemT)",
        "public static CollectionType construct(Class<?> rawType, JavaType elemT)",
        "protected JavaType _narrow(Class<?> subclass)",
        "public JavaType withContentType(JavaType contentType)",
        "public CollectionType withTypeHandler(Object h)",
        "public CollectionType withContentTypeHandler(Object h)",
        "public CollectionType withValueHandler(Object h)",
        "public CollectionType withContentValueHandler(Object h)",
        "public CollectionType withStaticTyping()",
        "public JavaType refine(Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces)",
        "public String toString()"
      ],
      "methods": [
        {
          "buggy_method": "",
          "fixed_method": "",
          "diff": [
            "@@ -1,5 +1,6 @@",
            " package com.fasterxml.jackson.databind.type;\n",
            " \n",
            "+import java.lang.reflect.TypeVariable;\n",
            " \n",
            " import com.fasterxml.jackson.databind.JavaType;\n",
            " \n"
          ],
          "changed_lines": 1
        },
        {
          "buggy_method": "  public static CollectionType construct(Class<?> rawType, JavaType elemT) {\n  \n  \n  return new CollectionType(rawType, null,\n  \n  _bogusSuperClass(rawType), null, elemT,\n  null, null, false);\n  }",
          "fixed_method": "  public static CollectionType construct(Class<?> rawType, JavaType elemT) {\n  \n  \n  TypeVariable<?>[] vars = rawType.getTypeParameters();\n  TypeBindings bindings;\n  if ((vars == null) || (vars.length != 1)) {\n  bindings = TypeBindings.emptyBindings();\n  } else {\n  bindings = TypeBindings.create(rawType, elemT);\n  }\n  return new CollectionType(rawType, bindings,\n  \n  _bogusSuperClass(rawType), null, elemT,\n  null, null, false);\n  }",
          "diff": [
            "@@ -47,7 +48,14 @@",
            "     public static CollectionType construct(Class<?> rawType, JavaType elemT) {\n",
            "         // First: may need to fabricate TypeBindings (needed for refining into\n",
            "         // concrete collection types, as per [databind#1102])\n",
            "-        return new CollectionType(rawType, null,\n",
            "+        TypeVariable<?>[] vars = rawType.getTypeParameters();\n",
            "+        TypeBindings bindings;\n",
            "+        if ((vars == null) || (vars.length != 1)) {\n",
            "+            bindings = TypeBindings.emptyBindings();\n",
            "+        } else {\n",
            "+            bindings = TypeBindings.create(rawType, elemT);\n",
            "+        }\n",
            "+        return new CollectionType(rawType, bindings,\n",
            "                 // !!! TODO: Wrong, does have supertypes, but:\n",
            "                 _bogusSuperClass(rawType), null, elemT,\n",
            "                 null, null, false);\n"
          ],
          "changed_lines": 9
        }
      ]
    },
    {
      "name": "com/fasterxml/jackson/databind/type/MapType.java",
      "buggy_full_code": "package com.fasterxml.jackson.databind.type;\n\n\nimport com.fasterxml.jackson.databind.JavaType;\n\n\npublic final class MapType extends MapLikeType { private static final long serialVersionUID = 1L; private MapType(Class<?> mapType, TypeBindings bindings, JavaType superClass, JavaType[] superInts, JavaType keyT, JavaType valueT, Object valueHandler, Object typeHandler, boolean asStatic) {\n        super(mapType, bindings, superClass, superInts,\n                keyT, valueT, valueHandler, typeHandler, asStatic);\n    }\n\n    \n    protected MapType(TypeBase base, JavaType keyT, JavaType valueT) {\n        super(base, keyT, valueT);\n    }\n\n    \n    public static MapType construct(Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInts, JavaType keyT, JavaType valueT) {\n        return new MapType(rawType, bindings, superClass, superInts, keyT, valueT, null, null, false);\n    }\n    \n    @Deprecated \n    public static MapType construct(Class<?> rawType, JavaType keyT, JavaType valueT) {\n        \n        \n        \n        return new MapType(rawType, null, _bogusSuperClass(rawType), null,\n                keyT, valueT, null, null, false);\n    }\n\n    @Deprecated \n    @Override\n    protected JavaType _narrow(Class<?> subclass) {\n        return new MapType(subclass, _bindings,\n                _superClass, _superInterfaces, _keyType, _valueType,\n                _valueHandler, _typeHandler, _asStatic);\n    }\n\n    @Override\n    public MapType withTypeHandler(Object h) {\n        return new MapType(_class, _bindings,\n                _superClass, _superInterfaces, _keyType, _valueType, _valueHandler, h, _asStatic);\n    }\n\n    @Override\n    public MapType withContentTypeHandler(Object h) {\n        return new MapType(_class, _bindings,\n                _superClass, _superInterfaces, _keyType, _valueType.withTypeHandler(h),\n                _valueHandler, _typeHandler, _asStatic);\n    }\n    \n    @Override\n    public MapType withValueHandler(Object h) {\n        return new MapType(_class, _bindings,\n                _superClass, _superInterfaces, _keyType, _valueType, h, _typeHandler, _asStatic);\n    }\n\n    @Override\n    public MapType withContentValueHandler(Object h) {\n        return new MapType(_class, _bindings,\n                _superClass, _superInterfaces, _keyType, _valueType.withValueHandler(h),\n                _valueHandler, _typeHandler, _asStatic);\n    }\n\n    @Override\n    public MapType withStaticTyping() {\n        if (_asStatic) {\n            return this;\n        }\n        return new MapType(_class, _bindings,\n                _superClass, _superInterfaces, _keyType.withStaticTyping(), _valueType.withStaticTyping(),\n                _valueHandler, _typeHandler, true);\n    }\n\n    @Override\n    public JavaType withContentType(JavaType contentType) {\n        if (_valueType == contentType) {\n            return this;\n        }\n        return new MapType(_class, _bindings, _superClass, _superInterfaces,\n                _keyType, contentType, _valueHandler, _typeHandler, _asStatic);\n    }\n    \n    @Override\n    public MapType withKeyType(JavaType keyType) {\n        if (keyType == _keyType) {\n            return this;\n        }\n        return new MapType(_class, _bindings, _superClass, _superInterfaces,\n                keyType, _valueType, _valueHandler, _typeHandler, _asStatic);\n    }\n    \n    @Override\n    public JavaType refine(Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) {\n        return new MapType(rawType, bindings,\n                superClass, superInterfaces, _keyType, _valueType,\n                _valueHandler, _typeHandler, _asStatic);\n    }\n\n    \n    \n    @Override\n    public MapType withKeyTypeHandler(Object h) {\n        return new MapType(_class, _bindings,\n                _superClass, _superInterfaces, _keyType.withTypeHandler(h), _valueType,\n                _valueHandler, _typeHandler, _asStatic);\n    }\n\n    @Override\n    public MapType withKeyValueHandler(Object h) {\n        return new MapType(_class, _bindings,\n                _superClass, _superInterfaces, _keyType.withValueHandler(h), _valueType,\n                _valueHandler, _typeHandler, _asStatic);\n    }\n\n    \n\n    @Override\n    public String toString() {\n        return \"[map type; class \"+_class.getName()+\", \"+_keyType+\" -> \"+_valueType+\"]\";\n    }\n}\n",
      "fixed_full_code": "package com.fasterxml.jackson.databind.type;\n\nimport java.lang.reflect.TypeVariable;\n\nimport com.fasterxml.jackson.databind.JavaType;\n\n\npublic final class MapType extends MapLikeType { private static final long serialVersionUID = 1L; private MapType(Class<?> mapType, TypeBindings bindings, JavaType superClass, JavaType[] superInts, JavaType keyT, JavaType valueT, Object valueHandler, Object typeHandler, boolean asStatic) {\n        super(mapType, bindings, superClass, superInts,\n                keyT, valueT, valueHandler, typeHandler, asStatic);\n    }\n\n    \n    protected MapType(TypeBase base, JavaType keyT, JavaType valueT) {\n        super(base, keyT, valueT);\n    }\n\n    \n    public static MapType construct(Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInts, JavaType keyT, JavaType valueT) {\n        return new MapType(rawType, bindings, superClass, superInts, keyT, valueT, null, null, false);\n    }\n    \n    @Deprecated \n    public static MapType construct(Class<?> rawType, JavaType keyT, JavaType valueT) {\n        \n        \n        TypeVariable<?>[] vars = rawType.getTypeParameters();\n        TypeBindings bindings;\n        if ((vars == null) || (vars.length != 2)) {\n            bindings = TypeBindings.emptyBindings();\n        } else {\n            bindings = TypeBindings.create(rawType, keyT, valueT);\n        }\n        \n        return new MapType(rawType, bindings, _bogusSuperClass(rawType), null,\n                keyT, valueT, null, null, false);\n    }\n\n    @Deprecated \n    @Override\n    protected JavaType _narrow(Class<?> subclass) {\n        return new MapType(subclass, _bindings,\n                _superClass, _superInterfaces, _keyType, _valueType,\n                _valueHandler, _typeHandler, _asStatic);\n    }\n\n    @Override\n    public MapType withTypeHandler(Object h) {\n        return new MapType(_class, _bindings,\n                _superClass, _superInterfaces, _keyType, _valueType, _valueHandler, h, _asStatic);\n    }\n\n    @Override\n    public MapType withContentTypeHandler(Object h) {\n        return new MapType(_class, _bindings,\n                _superClass, _superInterfaces, _keyType, _valueType.withTypeHandler(h),\n                _valueHandler, _typeHandler, _asStatic);\n    }\n    \n    @Override\n    public MapType withValueHandler(Object h) {\n        return new MapType(_class, _bindings,\n                _superClass, _superInterfaces, _keyType, _valueType, h, _typeHandler, _asStatic);\n    }\n\n    @Override\n    public MapType withContentValueHandler(Object h) {\n        return new MapType(_class, _bindings,\n                _superClass, _superInterfaces, _keyType, _valueType.withValueHandler(h),\n                _valueHandler, _typeHandler, _asStatic);\n    }\n\n    @Override\n    public MapType withStaticTyping() {\n        if (_asStatic) {\n            return this;\n        }\n        return new MapType(_class, _bindings,\n                _superClass, _superInterfaces, _keyType.withStaticTyping(), _valueType.withStaticTyping(),\n                _valueHandler, _typeHandler, true);\n    }\n\n    @Override\n    public JavaType withContentType(JavaType contentType) {\n        if (_valueType == contentType) {\n            return this;\n        }\n        return new MapType(_class, _bindings, _superClass, _superInterfaces,\n                _keyType, contentType, _valueHandler, _typeHandler, _asStatic);\n    }\n    \n    @Override\n    public MapType withKeyType(JavaType keyType) {\n        if (keyType == _keyType) {\n            return this;\n        }\n        return new MapType(_class, _bindings, _superClass, _superInterfaces,\n                keyType, _valueType, _valueHandler, _typeHandler, _asStatic);\n    }\n    \n    @Override\n    public JavaType refine(Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) {\n        return new MapType(rawType, bindings,\n                superClass, superInterfaces, _keyType, _valueType,\n                _valueHandler, _typeHandler, _asStatic);\n    }\n\n    \n    \n    @Override\n    public MapType withKeyTypeHandler(Object h) {\n        return new MapType(_class, _bindings,\n                _superClass, _superInterfaces, _keyType.withTypeHandler(h), _valueType,\n                _valueHandler, _typeHandler, _asStatic);\n    }\n\n    @Override\n    public MapType withKeyValueHandler(Object h) {\n        return new MapType(_class, _bindings,\n                _superClass, _superInterfaces, _keyType.withValueHandler(h), _valueType,\n                _valueHandler, _typeHandler, _asStatic);\n    }\n\n    \n\n    @Override\n    public String toString() {\n        return \"[map type; class \"+_class.getName()+\", \"+_keyType+\" -> \"+_valueType+\"]\";\n    }\n}\n",
      "buggy_signatures": [
        "protected MapType(TypeBase base, JavaType keyT, JavaType valueT)",
        "public static MapType construct(Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInts, JavaType keyT, JavaType valueT)",
        "public static MapType construct(Class<?> rawType, JavaType keyT, JavaType valueT)",
        "protected JavaType _narrow(Class<?> subclass)",
        "public MapType withTypeHandler(Object h)",
        "public MapType withContentTypeHandler(Object h)",
        "public MapType withValueHandler(Object h)",
        "public MapType withContentValueHandler(Object h)",
        "public MapType withStaticTyping()",
        "public JavaType withContentType(JavaType contentType)",
        "public MapType withKeyType(JavaType keyType)",
        "public JavaType refine(Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces)",
        "public MapType withKeyTypeHandler(Object h)",
        "public MapType withKeyValueHandler(Object h)",
        "public String toString()"
      ],
      "fixed_signatures": [
        "protected MapType(TypeBase base, JavaType keyT, JavaType valueT)",
        "public static MapType construct(Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInts, JavaType keyT, JavaType valueT)",
        "public static MapType construct(Class<?> rawType, JavaType keyT, JavaType valueT)",
        "protected JavaType _narrow(Class<?> subclass)",
        "public MapType withTypeHandler(Object h)",
        "public MapType withContentTypeHandler(Object h)",
        "public MapType withValueHandler(Object h)",
        "public MapType withContentValueHandler(Object h)",
        "public MapType withStaticTyping()",
        "public JavaType withContentType(JavaType contentType)",
        "public MapType withKeyType(JavaType keyType)",
        "public JavaType refine(Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces)",
        "public MapType withKeyTypeHandler(Object h)",
        "public MapType withKeyValueHandler(Object h)",
        "public String toString()"
      ],
      "methods": [
        {
          "buggy_method": "",
          "fixed_method": "",
          "diff": [
            "@@ -1,5 +1,6 @@",
            " package com.fasterxml.jackson.databind.type;\n",
            " \n",
            "+import java.lang.reflect.TypeVariable;\n",
            " \n",
            " import com.fasterxml.jackson.databind.JavaType;\n",
            " \n"
          ],
          "changed_lines": 1
        },
        {
          "buggy_method": "  public static MapType construct(Class<?> rawType, JavaType keyT, JavaType valueT) {\n  \n  \n  \n  return new MapType(rawType, null, _bogusSuperClass(rawType), null,\n  keyT, valueT, null, null, false);\n  }",
          "fixed_method": "  public static MapType construct(Class<?> rawType, JavaType keyT, JavaType valueT) {\n  \n  \n  TypeVariable<?>[] vars = rawType.getTypeParameters();\n  TypeBindings bindings;\n  if ((vars == null) || (vars.length != 2)) {\n  bindings = TypeBindings.emptyBindings();\n  } else {\n  bindings = TypeBindings.create(rawType, keyT, valueT);\n  }\n  \n  return new MapType(rawType, bindings, _bogusSuperClass(rawType), null,\n  keyT, valueT, null, null, false);\n  }",
          "diff": [
            "@@ -44,8 +45,15 @@",
            "     {\n",
            "         // First: may need to fabricate TypeBindings (needed for refining into\n",
            "         // concrete collection types, as per [databind#1102])\n",
            "+        TypeVariable<?>[] vars = rawType.getTypeParameters();\n",
            "+        TypeBindings bindings;\n",
            "+        if ((vars == null) || (vars.length != 2)) {\n",
            "+            bindings = TypeBindings.emptyBindings();\n",
            "+        } else {\n",
            "+            bindings = TypeBindings.create(rawType, keyT, valueT);\n",
            "+        }\n",
            "         // !!! TODO: Wrong, does have supertypes\n",
            "-        return new MapType(rawType, null, _bogusSuperClass(rawType), null,\n",
            "+        return new MapType(rawType, bindings, _bogusSuperClass(rawType), null,\n",
            "                 keyT, valueT, null, null, false);\n",
            "     }\n",
            " \n"
          ],
          "changed_lines": 9
        }
      ]
    },
    {
      "name": "com/fasterxml/jackson/databind/type/SimpleType.java",
      "buggy_full_code": "package com.fasterxml.jackson.databind.type;\n\nimport java.util.*;\n\nimport com.fasterxml.jackson.databind.JavaType;\n\n\npublic class SimpleType extends TypeBase { private static final long serialVersionUID = 1L; protected SimpleType(Class<?> cls) {\n        this(cls, TypeBindings.emptyBindings(), null, null);\n    }\n\n    protected SimpleType(Class<?> cls, TypeBindings bindings, JavaType superClass, JavaType[] superInts) {\n        this(cls, bindings, superClass, superInts, null, null, false);\n    }\n\n    \n    protected SimpleType(TypeBase base) {\n        super(base);\n    }\n\n    protected SimpleType(Class<?> cls, TypeBindings bindings, JavaType superClass, JavaType[] superInts, Object valueHandler, Object typeHandler, boolean asStatic) {\n        super(cls, bindings, superClass, superInts,\n                0, valueHandler, typeHandler, asStatic);\n    }\n\n    \n    protected SimpleType(Class<?> cls, TypeBindings bindings, JavaType superClass, JavaType[] superInts, int extraHash, Object valueHandler, Object typeHandler, boolean asStatic) {\n        super(cls, bindings, superClass, superInts, \n                extraHash, valueHandler, typeHandler, asStatic);\n    }\n    \n    \n    public static SimpleType constructUnsafe(Class<?> raw) {\n        return new SimpleType(raw, null,\n                \n                null, null, null, null, false);\n    }\n\n    \n    @Deprecated\n    public static SimpleType construct(Class<?> cls) {\n        \n        if (Map.class.isAssignableFrom(cls)) {\n            throw new IllegalArgumentException(\"Can not construct SimpleType for a Map (class: \"+cls.getName()+\")\");\n        }\n        if (Collection.class.isAssignableFrom(cls)) {\n            throw new IllegalArgumentException(\"Can not construct SimpleType for a Collection (class: \"+cls.getName()+\")\");\n        }\n        \n        if (cls.isArray()) {\n            throw new IllegalArgumentException(\"Can not construct SimpleType for an array (class: \"+cls.getName()+\")\");\n        }\n        return new SimpleType(cls, TypeBindings.emptyBindings(),\n                _bogusSuperClass(cls), null, null, null, false);\n    }\n\n    @Override\n    @Deprecated\n    protected JavaType _narrow(Class<?> subclass) {\n        if (_class == subclass) {\n            return this;\n        }\n        \n        \n        \n        \n        \n        return new SimpleType(subclass, _bindings, this, _superInterfaces,\n                _valueHandler, _typeHandler, _asStatic);\n    }\n    \n    @Override\n    public JavaType withContentType(JavaType contentType) {\n        throw new IllegalArgumentException(\"Simple types have no content types; can not call withContentType()\");\n    }\n    \n    @Override\n    public SimpleType withTypeHandler(Object h) {\n        if (_typeHandler == h) {\n            return this;\n        }\n        return new SimpleType(_class, _bindings, _superClass, _superInterfaces, _valueHandler, h, _asStatic);\n    }\n\n    @Override\n    public JavaType withContentTypeHandler(Object h) {\n        \n        throw new IllegalArgumentException(\"Simple types have no content types; can not call withContenTypeHandler()\");\n    }\n\n    @Override\n    public SimpleType withValueHandler(Object h) {\n        if (h == _valueHandler) {\n            return this;\n        }\n        return new SimpleType(_class, _bindings, _superClass, _superInterfaces, h, _typeHandler, _asStatic);\n    }\n    \n    @Override\n    public SimpleType withContentValueHandler(Object h) {\n        \n        throw new IllegalArgumentException(\"Simple types have no content types; can not call withContenValueHandler()\");\n    }\n\n    @Override\n    public SimpleType withStaticTyping() {\n        return _asStatic ? this : new SimpleType(_class, _bindings,\n                _superClass, _superInterfaces, _valueHandler, _typeHandler, true);\n    }\n\n    @Override\n    public JavaType refine(Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) {\n        \n        return null;\n    }\n    \n    @Override\n    protected String buildCanonicalName() {\n        StringBuilder sb = new StringBuilder();\n        sb.append(_class.getName());\n\n        final int count = _bindings.size();\n        if (count > 0) {\n            sb.append('<');\n            for (int i = 0; i < count; ++i) {\n                JavaType t = containedType(i);\n                if (i > 0) {\n                    sb.append(',');\n                }\n                sb.append(t.toCanonical());\n            }\n            sb.append('>');\n        }\n        return sb.toString();\n    }\n\n    \n\n    @Override\n    public boolean isContainerType() { return false; }\n\n    @Override\n    public StringBuilder getErasedSignature(StringBuilder sb) {\n        return _classSignature(_class, sb, true);\n    }\n    \n    @Override\n    public StringBuilder getGenericSignature(StringBuilder sb) {\n        _classSignature(_class, sb, false);\n\n        final int count = _bindings.size();\n        if (count > 0) {\n            sb.append('<');\n            for (int i = 0; i < count; ++i) {\n                sb = containedType(i).getGenericSignature(sb);\n            }\n            sb.append('>');\n        }\n        sb.append(';');\n        return sb;\n    }\n\n    \n\n    \n\n    \n\n    @Override\n    public String toString() {\n        StringBuilder sb = new StringBuilder(40);\n        sb.append(\"[simple type, class \").append(buildCanonicalName()).append(']');\n        return sb.toString();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (o == this) return true;\n        if (o == null) return false;\n        if (o.getClass() != getClass()) return false;\n\n        SimpleType other = (SimpleType) o;\n\n        \n        if (other._class != this._class) return false;\n\n        \n        TypeBindings b1 = _bindings;\n        TypeBindings b2 = other._bindings;\n        return b1.equals(b2);\n    }\n}\n",
      "fixed_full_code": "package com.fasterxml.jackson.databind.type;\n\nimport java.util.*;\n\nimport com.fasterxml.jackson.databind.JavaType;\n\n\npublic class SimpleType extends TypeBase { private static final long serialVersionUID = 1L; protected SimpleType(Class<?> cls) {\n        this(cls, TypeBindings.emptyBindings(), null, null);\n    }\n\n    protected SimpleType(Class<?> cls, TypeBindings bindings, JavaType superClass, JavaType[] superInts) {\n        this(cls, bindings, superClass, superInts, null, null, false);\n    }\n\n    \n    protected SimpleType(TypeBase base) {\n        super(base);\n    }\n\n    protected SimpleType(Class<?> cls, TypeBindings bindings, JavaType superClass, JavaType[] superInts, Object valueHandler, Object typeHandler, boolean asStatic) {\n        super(cls, bindings, superClass, superInts,\n                0, valueHandler, typeHandler, asStatic);\n    }\n\n    \n    protected SimpleType(Class<?> cls, TypeBindings bindings, JavaType superClass, JavaType[] superInts, int extraHash, Object valueHandler, Object typeHandler, boolean asStatic) {\n        super(cls, bindings, superClass, superInts, \n                extraHash, valueHandler, typeHandler, asStatic);\n    }\n    \n    \n    public static SimpleType constructUnsafe(Class<?> raw) {\n        return new SimpleType(raw, null,\n                \n                null, null, null, null, false);\n    }\n\n    \n    @Deprecated\n    public static SimpleType construct(Class<?> cls) {\n        \n        if (Map.class.isAssignableFrom(cls)) {\n            throw new IllegalArgumentException(\"Can not construct SimpleType for a Map (class: \"+cls.getName()+\")\");\n        }\n        if (Collection.class.isAssignableFrom(cls)) {\n            throw new IllegalArgumentException(\"Can not construct SimpleType for a Collection (class: \"+cls.getName()+\")\");\n        }\n        \n        if (cls.isArray()) {\n            throw new IllegalArgumentException(\"Can not construct SimpleType for an array (class: \"+cls.getName()+\")\");\n        }\n        TypeBindings b = TypeBindings.emptyBindings();\n        return new SimpleType(cls, b,\n                _buildSuperClass(cls.getSuperclass(), b), null, null, null, false);\n    }\n\n    @Override\n    @Deprecated\n    protected JavaType _narrow(Class<?> subclass) {\n        if (_class == subclass) {\n            return this;\n        }\n        \n        \n        \n        \n        \n        return new SimpleType(subclass, _bindings, this, _superInterfaces,\n                _valueHandler, _typeHandler, _asStatic);\n    }\n    \n    @Override\n    public JavaType withContentType(JavaType contentType) {\n        throw new IllegalArgumentException(\"Simple types have no content types; can not call withContentType()\");\n    }\n    \n    @Override\n    public SimpleType withTypeHandler(Object h) {\n        if (_typeHandler == h) {\n            return this;\n        }\n        return new SimpleType(_class, _bindings, _superClass, _superInterfaces, _valueHandler, h, _asStatic);\n    }\n\n    @Override\n    public JavaType withContentTypeHandler(Object h) {\n        \n        throw new IllegalArgumentException(\"Simple types have no content types; can not call withContenTypeHandler()\");\n    }\n\n    @Override\n    public SimpleType withValueHandler(Object h) {\n        if (h == _valueHandler) {\n            return this;\n        }\n        return new SimpleType(_class, _bindings, _superClass, _superInterfaces, h, _typeHandler, _asStatic);\n    }\n    \n    @Override\n    public SimpleType withContentValueHandler(Object h) {\n        \n        throw new IllegalArgumentException(\"Simple types have no content types; can not call withContenValueHandler()\");\n    }\n\n    @Override\n    public SimpleType withStaticTyping() {\n        return _asStatic ? this : new SimpleType(_class, _bindings,\n                _superClass, _superInterfaces, _valueHandler, _typeHandler, true);\n    }\n\n    @Override\n    public JavaType refine(Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) {\n        \n        return null;\n    }\n    \n    @Override\n    protected String buildCanonicalName() {\n        StringBuilder sb = new StringBuilder();\n        sb.append(_class.getName());\n\n        final int count = _bindings.size();\n        if (count > 0) {\n            sb.append('<');\n            for (int i = 0; i < count; ++i) {\n                JavaType t = containedType(i);\n                if (i > 0) {\n                    sb.append(',');\n                }\n                sb.append(t.toCanonical());\n            }\n            sb.append('>');\n        }\n        return sb.toString();\n    }\n\n    \n\n    @Override\n    public boolean isContainerType() { return false; }\n\n    @Override\n    public StringBuilder getErasedSignature(StringBuilder sb) {\n        return _classSignature(_class, sb, true);\n    }\n    \n    @Override\n    public StringBuilder getGenericSignature(StringBuilder sb) {\n        _classSignature(_class, sb, false);\n\n        final int count = _bindings.size();\n        if (count > 0) {\n            sb.append('<');\n            for (int i = 0; i < count; ++i) {\n                sb = containedType(i).getGenericSignature(sb);\n            }\n            sb.append('>');\n        }\n        sb.append(';');\n        return sb;\n    }\n\n    \n\n    \n    private static JavaType _buildSuperClass(Class<?> superClass, TypeBindings b) {\n        if (superClass == null) {\n            return null;\n        }\n        if (superClass == Object.class) {\n            return TypeFactory.unknownType();\n        }\n        JavaType superSuper = _buildSuperClass(superClass.getSuperclass(), b);\n        return new SimpleType(superClass, b,\n                superSuper, null, null, null, false);\n    }\n\n    \n\n    @Override\n    public String toString() {\n        StringBuilder sb = new StringBuilder(40);\n        sb.append(\"[simple type, class \").append(buildCanonicalName()).append(']');\n        return sb.toString();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (o == this) return true;\n        if (o == null) return false;\n        if (o.getClass() != getClass()) return false;\n\n        SimpleType other = (SimpleType) o;\n\n        \n        if (other._class != this._class) return false;\n\n        \n        TypeBindings b1 = _bindings;\n        TypeBindings b2 = other._bindings;\n        return b1.equals(b2);\n    }\n}\n",
      "buggy_signatures": [
        "protected SimpleType(Class<?> cls, TypeBindings bindings, JavaType superClass, JavaType[] superInts)",
        "protected SimpleType(TypeBase base)",
        "protected SimpleType(Class<?> cls, TypeBindings bindings, JavaType superClass, JavaType[] superInts, Object valueHandler, Object typeHandler, boolean asStatic)",
        "protected SimpleType(Class<?> cls, TypeBindings bindings, JavaType superClass, JavaType[] superInts, int extraHash, Object valueHandler, Object typeHandler, boolean asStatic)",
        "public static SimpleType constructUnsafe(Class<?> raw)",
        "public static SimpleType construct(Class<?> cls)",
        "protected JavaType _narrow(Class<?> subclass)",
        "public JavaType withContentType(JavaType contentType)",
        "public SimpleType withTypeHandler(Object h)",
        "public JavaType withContentTypeHandler(Object h)",
        "public SimpleType withValueHandler(Object h)",
        "public SimpleType withContentValueHandler(Object h)",
        "public SimpleType withStaticTyping()",
        "public JavaType refine(Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces)",
        "protected String buildCanonicalName()",
        "public boolean isContainerType()",
        "public StringBuilder getErasedSignature(StringBuilder sb)",
        "public StringBuilder getGenericSignature(StringBuilder sb)",
        "public String toString()",
        "public boolean equals(Object o)"
      ],
      "fixed_signatures": [
        "protected SimpleType(Class<?> cls, TypeBindings bindings, JavaType superClass, JavaType[] superInts)",
        "protected SimpleType(TypeBase base)",
        "protected SimpleType(Class<?> cls, TypeBindings bindings, JavaType superClass, JavaType[] superInts, Object valueHandler, Object typeHandler, boolean asStatic)",
        "protected SimpleType(Class<?> cls, TypeBindings bindings, JavaType superClass, JavaType[] superInts, int extraHash, Object valueHandler, Object typeHandler, boolean asStatic)",
        "public static SimpleType constructUnsafe(Class<?> raw)",
        "public static SimpleType construct(Class<?> cls)",
        "protected JavaType _narrow(Class<?> subclass)",
        "public JavaType withContentType(JavaType contentType)",
        "public SimpleType withTypeHandler(Object h)",
        "public JavaType withContentTypeHandler(Object h)",
        "public SimpleType withValueHandler(Object h)",
        "public SimpleType withContentValueHandler(Object h)",
        "public SimpleType withStaticTyping()",
        "public JavaType refine(Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces)",
        "protected String buildCanonicalName()",
        "public boolean isContainerType()",
        "public StringBuilder getErasedSignature(StringBuilder sb)",
        "public StringBuilder getGenericSignature(StringBuilder sb)",
        "private static JavaType _buildSuperClass(Class<?> superClass, TypeBindings b)",
        "public String toString()",
        "public boolean equals(Object o)"
      ],
      "methods": [
        {
          "buggy_method": "  public static SimpleType construct(Class<?> cls) {\n  \n  if (Map.class.isAssignableFrom(cls)) {\n  throw new IllegalArgumentException(\"Can not construct SimpleType for a Map (class: \"+cls.getName()+\")\");\n  }\n  if (Collection.class.isAssignableFrom(cls)) {\n  throw new IllegalArgumentException(\"Can not construct SimpleType for a Collection (class: \"+cls.getName()+\")\");\n  }\n  \n  if (cls.isArray()) {\n  throw new IllegalArgumentException(\"Can not construct SimpleType for an array (class: \"+cls.getName()+\")\");\n  }\n  return new SimpleType(cls, TypeBindings.emptyBindings(),\n  _bogusSuperClass(cls), null, null, null, false);\n  }",
          "fixed_method": "  public static SimpleType construct(Class<?> cls) {\n  \n  if (Map.class.isAssignableFrom(cls)) {\n  throw new IllegalArgumentException(\"Can not construct SimpleType for a Map (class: \"+cls.getName()+\")\");\n  }\n  if (Collection.class.isAssignableFrom(cls)) {\n  throw new IllegalArgumentException(\"Can not construct SimpleType for a Collection (class: \"+cls.getName()+\")\");\n  }\n  \n  if (cls.isArray()) {\n  throw new IllegalArgumentException(\"Can not construct SimpleType for an array (class: \"+cls.getName()+\")\");\n  }\n  TypeBindings b = TypeBindings.emptyBindings();\n  return new SimpleType(cls, b,\n  _buildSuperClass(cls.getSuperclass(), b), null, null, null, false);\n  }",
          "diff": [
            "@@ -113,8 +113,9 @@",
            "         if (cls.isArray()) {\n",
            "             throw new IllegalArgumentException(\"Can not construct SimpleType for an array (class: \"+cls.getName()+\")\");\n",
            "         }\n",
            "-        return new SimpleType(cls, TypeBindings.emptyBindings(),\n",
            "-                _bogusSuperClass(cls), null, null, null, false);\n",
            "+        TypeBindings b = TypeBindings.emptyBindings();\n",
            "+        return new SimpleType(cls, b,\n",
            "+                _buildSuperClass(cls.getSuperclass(), b), null, null, null, false);\n",
            "     }\n",
            " \n",
            "     @Override\n"
          ],
          "changed_lines": 5
        },
        {
          "buggy_method": "  public StringBuilder getGenericSignature(StringBuilder sb) {\n  _classSignature(_class, sb, false);\n\n  final int count = _bindings.size();\n  if (count > 0) {\n  sb.append('<');\n  for (int i = 0; i < count; ++i) {\n  sb = containedType(i).getGenericSignature(sb);\n  }\n  sb.append('>');\n  }\n  sb.append(';');\n  return sb;\n  }",
          "fixed_method": "  private static JavaType _buildSuperClass(Class<?> superClass, TypeBindings b) {\n  if (superClass == null) {\n  return null;\n  }\n  if (superClass == Object.class) {\n  return TypeFactory.unknownType();\n  }\n  JavaType superSuper = _buildSuperClass(superClass.getSuperclass(), b);\n  return new SimpleType(superClass, b,\n  superSuper, null, null, null, false);\n  }",
          "diff": [
            "@@ -248,6 +249,18 @@",
            "      * \n",
            "      * @since 2.7 -- remove when not needed (2.8?)\n",
            "      */\n",
            "+    private static JavaType _buildSuperClass(Class<?> superClass, TypeBindings b)\n",
            "+    {\n",
            "+        if (superClass == null) {\n",
            "+            return null;\n",
            "+        }\n",
            "+        if (superClass == Object.class) {\n",
            "+            return TypeFactory.unknownType();\n",
            "+        }\n",
            "+        JavaType superSuper = _buildSuperClass(superClass.getSuperclass(), b);\n",
            "+        return new SimpleType(superClass, b,\n",
            "+                superSuper, null, null, null, false);\n",
            "+    }\n",
            " \n",
            "     /*\n",
            "     /**********************************************************\n"
          ],
          "changed_lines": 12
        }
      ]
    }
  ]
}
