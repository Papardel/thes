{
  "bug_id": "44",
  "failed_tests": {
    "org.jsoup.parser.HtmlParserTest": [
      {
        "methodName": "testInvalidTableContents",
        "error": "junit.framework.AssertionFailedError",
        "message": "Search text did not come after comment",
        "fail_line": "        assertTrue(\"Search text did not come after comment\", guarantee > endOfEmail);",
        "test_source": "  public void testInvalidTableContents() throws IOException {\n  File in = ParseTest.getFile(\"/htmltests/table-invalid-elements.html\");\n  Document doc = Jsoup.parse(in, \"UTF-8\");\n  doc.outputSettings().prettyPrint(true);\n  String rendered = doc.toString();\n  int endOfEmail = rendered.indexOf(\"Comment\");\n  int guarantee = rendered.indexOf(\"Why am I here?\");\n  assertTrue(\"Comment not found\", endOfEmail > -1);\n  assertTrue(\"Search text not found\", guarantee > -1);\n  assertTrue(\"Search text did not come after comment\", guarantee > endOfEmail);\n  }",
        "stack": [
          "HtmlParserTest.testInvalidTableContents line 864"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/jsoup/parser/TreeBuilder.java",
      "buggy_full_code": "package org.jsoup.parser;\n\nimport org.jsoup.helper.Validate;\nimport org.jsoup.nodes.Attributes;\nimport org.jsoup.nodes.Document;\nimport org.jsoup.nodes.Element;\n\nimport java.util.ArrayList;\n\n\nabstract class TreeBuilder { CharacterReader reader; Tokeniser tokeniser; protected Document doc; protected ArrayList<Element> stack; protected String baseUri; protected Token currentToken; protected ParseErrorList errors; private Token.StartTag start = new Token.StartTag(); private Token.EndTag end = new Token.EndTag(); protected void initialiseParse(String input, String baseUri, ParseErrorList errors) {\n        Validate.notNull(input, \"String input must not be null\");\n        Validate.notNull(baseUri, \"BaseURI must not be null\");\n\n        doc = new Document(baseUri);\n        reader = new CharacterReader(input);\n        this.errors = errors;\n        tokeniser = new Tokeniser(reader, errors);\n        stack = new ArrayList<Element>(32);\n        this.baseUri = baseUri;\n    }\n\n    Document parse(String input, String baseUri) {\n        return parse(input, baseUri, ParseErrorList.noTracking());\n    }\n\n    Document parse(String input, String baseUri, ParseErrorList errors) {\n        initialiseParse(input, baseUri, errors);\n        runParser();\n        return doc;\n    }\n\n    protected void runParser() {\n        while (true) {\n            Token token = tokeniser.read();\n            process(token);\n            token.reset();\n\n            if (token.type == Token.TokenType.EOF)\n                break;\n        }\n    }\n\n    protected abstract boolean process(Token token); protected boolean processStartTag(String name) {\n        return process(start.reset().name(name));\n    }\n\n    public boolean processStartTag(String name, Attributes attrs) {\n        start.reset();\n        start.nameAttr(name, attrs);\n        return process(start);\n    }\n\n    protected boolean processEndTag(String name) {\n        return process(end.reset().name(name));\n    }\n\n\n    protected Element currentElement() {\n        int size = stack.size();\n        return size > 0 ? stack.get(size-1) : null;\n    }\n}\n",
      "fixed_full_code": "package org.jsoup.parser;\n\nimport org.jsoup.helper.Validate;\nimport org.jsoup.nodes.Attributes;\nimport org.jsoup.nodes.Document;\nimport org.jsoup.nodes.Element;\n\nimport java.util.ArrayList;\n\n\nabstract class TreeBuilder { CharacterReader reader; Tokeniser tokeniser; protected Document doc; protected ArrayList<Element> stack; protected String baseUri; protected Token currentToken; protected ParseErrorList errors; private Token.StartTag start = new Token.StartTag(); private Token.EndTag end = new Token.EndTag(); protected void initialiseParse(String input, String baseUri, ParseErrorList errors) {\n        Validate.notNull(input, \"String input must not be null\");\n        Validate.notNull(baseUri, \"BaseURI must not be null\");\n\n        doc = new Document(baseUri);\n        reader = new CharacterReader(input);\n        this.errors = errors;\n        tokeniser = new Tokeniser(reader, errors);\n        stack = new ArrayList<Element>(32);\n        this.baseUri = baseUri;\n    }\n\n    Document parse(String input, String baseUri) {\n        return parse(input, baseUri, ParseErrorList.noTracking());\n    }\n\n    Document parse(String input, String baseUri, ParseErrorList errors) {\n        initialiseParse(input, baseUri, errors);\n        runParser();\n        return doc;\n    }\n\n    protected void runParser() {\n        while (true) {\n            Token token = tokeniser.read();\n            process(token);\n            token.reset();\n\n            if (token.type == Token.TokenType.EOF)\n                break;\n        }\n    }\n\n    protected abstract boolean process(Token token); protected boolean processStartTag(String name) {\n        if (currentToken == start) { \n            return process(new Token.StartTag().name(name));\n        }\n        return process(start.reset().name(name));\n    }\n\n    public boolean processStartTag(String name, Attributes attrs) {\n        if (currentToken == start) { \n            return process(new Token.StartTag().nameAttr(name, attrs));\n        }\n        start.reset();\n        start.nameAttr(name, attrs);\n        return process(start);\n    }\n\n    protected boolean processEndTag(String name) {\n        if (currentToken == end) { \n            return process(new Token.EndTag().name(name));\n        }\n        return process(end.reset().name(name));\n    }\n\n\n    protected Element currentElement() {\n        int size = stack.size();\n        return size > 0 ? stack.get(size-1) : null;\n    }\n}\n",
      "buggy_signatures": [
        "protected void runParser()",
        "protected abstract boolean process(Token token); protected boolean processStartTag(String name)",
        "public boolean processStartTag(String name, Attributes attrs)",
        "protected boolean processEndTag(String name)",
        "protected Element currentElement()"
      ],
      "fixed_signatures": [
        "protected void runParser()",
        "protected abstract boolean process(Token token); protected boolean processStartTag(String name)",
        "public boolean processStartTag(String name, Attributes attrs)",
        "protected boolean processEndTag(String name)",
        "protected Element currentElement()"
      ],
      "methods": [
        {
          "buggy_method": "  protected boolean processEndTag(String name) {\n  return process(end.reset().name(name));\n  }",
          "fixed_method": "  public boolean processStartTag(String name, Attributes attrs) {\n  if (currentToken == start) { \n  return process(new Token.StartTag().nameAttr(name, attrs));\n  }\n  start.reset();\n  start.nameAttr(name, attrs);\n  return process(start);\n  }",
          "diff": [
            "@@ -58,16 +58,25 @@",
            "     protected abstract boolean process(Token token);\n",
            " \n",
            "     protected boolean processStartTag(String name) {\n",
            "+        if (currentToken == start) { // don't recycle an in-use token\n",
            "+            return process(new Token.StartTag().name(name));\n",
            "+        }\n",
            "         return process(start.reset().name(name));\n",
            "     }\n",
            " \n",
            "     public boolean processStartTag(String name, Attributes attrs) {\n",
            "+        if (currentToken == start) { // don't recycle an in-use token\n",
            "+            return process(new Token.StartTag().nameAttr(name, attrs));\n",
            "+        }\n",
            "         start.reset();\n",
            "         start.nameAttr(name, attrs);\n",
            "         return process(start);\n",
            "     }\n",
            " \n",
            "     protected boolean processEndTag(String name) {\n",
            "+        if (currentToken == end) { // don't recycle an in-use token\n",
            "+            return process(new Token.EndTag().name(name));\n",
            "+        }\n",
            "         return process(end.reset().name(name));\n",
            "     }\n",
            " \n"
          ],
          "changed_lines": 9
        }
      ]
    }
  ]
}
