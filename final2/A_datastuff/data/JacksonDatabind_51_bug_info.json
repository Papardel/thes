{
  "bug_id": "51",
  "failed_tests": {
    "com.fasterxml.jackson.databind.jsontype.TestCustomTypeIdResolver": [
      {
        "methodName": "testPolymorphicTypeViaCustom",
        "error": "com.fasterxml.jackson.databind.JsonMappingException",
        "message": "Problem deserializing property 'options' (expected type: [simple type, class java.lang.Object]; actual type: java.util.LinkedHashMap), problem: Can not set com.fasterxml.jackson.databind.jsontype.TestCustomTypeIdResolver$Poly1Base field com.fasterxml.jackson.databind.jsontype.TestCustomTypeIdResolver$Base1270.options to java.util.LinkedHashMap",
        "fail_line": "        Top1270 itemRead = MAPPER.readValue(json, Top1270.class);",
        "test_source": "  public void testPolymorphicTypeViaCustom() throws Exception {\n  Base1270<Poly1> req = new Base1270<Poly1>();\n  Poly1 o = new Poly1();\n  o.val = \"optionValue\";\n  req.options = o;\n  req.val = \"some value\";\n  Top1270 top = new Top1270();\n  top.b = req;\n  String json = MAPPER.writeValueAsString(top);\n  JsonNode tree = MAPPER.readTree(json);\n  assertNotNull(tree.get(\"b\"));\n  assertNotNull(tree.get(\"b\").get(\"options\"));\n  assertNotNull(tree.get(\"b\").get(\"options\").get(\"val\"));\n\n  // Can we reverse the process? I have some doubts\n  Top1270 itemRead = MAPPER.readValue(json, Top1270.class);\n  assertNotNull(itemRead);\n  assertNotNull(itemRead.b);\n  }",
        "stack": [
          "JsonMappingException.from line 268, SettableBeanProperty._throwAsIOE line 516, FieldProperty.deserializeAndSet line 105, BeanDeserializer.vanillaDeserialize line 276, BeanDeserializer._deserializeOther line 178, BeanDeserializer.deserialize line 150, AsPropertyTypeDeserializer._deserializeTypedForId line 126, AsPropertyTypeDeserializer.deserializeTypedFromObject line 97, BeanDeserializerBase.deserializeWithType line 1079, SettableBeanProperty.deserialize line 488, FieldProperty.deserializeAndSet line 101, BeanDeserializer.vanillaDeserialize line 276, BeanDeserializer.deserialize line 140, ObjectMapper._readMapAndClose line 3789, ObjectMapper.readValue line 2833, TestCustomTypeIdResolver.testPolymorphicTypeViaCustom line 226, FieldProperty.deserializeAndSet line 103"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java",
      "buggy_full_code": "package com.fasterxml.jackson.databind.jsontype.impl;\n\nimport java.io.IOException;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\nimport com.fasterxml.jackson.annotation.JsonTypeInfo;\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.databind.BeanProperty;\nimport com.fasterxml.jackson.databind.DeserializationContext;\nimport com.fasterxml.jackson.databind.DeserializationFeature;\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.JsonDeserializer;\nimport com.fasterxml.jackson.databind.deser.std.NullifyingDeserializer;\nimport com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\nimport com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\n\n\npublic abstract class TypeDeserializerBase extends TypeDeserializer implements java.io.Serializable { private static final long serialVersionUID = 1; protected final TypeIdResolver _idResolver; protected final JavaType _baseType; protected final BeanProperty _property; protected final JavaType _defaultImpl; protected final String _typePropertyName; protected final boolean _typeIdVisible; protected final Map<String,JsonDeserializer<Object>> _deserializers; protected JsonDeserializer<Object> _defaultImplDeserializer; protected TypeDeserializerBase(JavaType baseType, TypeIdResolver idRes, String typePropertyName, boolean typeIdVisible, JavaType defaultImpl) {\n        _baseType = baseType;\n        _idResolver = idRes;\n        \n        _typePropertyName = (typePropertyName == null) ? \"\" : typePropertyName;\n        _typeIdVisible = typeIdVisible;\n        \n        _deserializers = new ConcurrentHashMap<String, JsonDeserializer<Object>>(16, 0.75f, 2);\n        _defaultImpl = defaultImpl;\n        _property = null;\n    }\n\n    protected TypeDeserializerBase(TypeDeserializerBase src, BeanProperty property) {\n        _baseType = src._baseType;\n        _idResolver = src._idResolver;\n        _typePropertyName = src._typePropertyName;\n        _typeIdVisible = src._typeIdVisible;\n        _deserializers = src._deserializers;\n        _defaultImpl = src._defaultImpl;\n        _defaultImplDeserializer = src._defaultImplDeserializer;\n        _property = property;\n    }\n\n    @Override\n    public abstract TypeDeserializer forProperty(BeanProperty prop); @Override public abstract JsonTypeInfo.As getTypeInclusion(); public String baseTypeName() { return _baseType.getRawClass().getName(); }\n\n    @Override\n    public final String getPropertyName() { return _typePropertyName; }\n    \n    @Override    \n    public TypeIdResolver getTypeIdResolver() { return _idResolver; }\n\n    @Override    \n    public Class<?> getDefaultImpl() {\n        return (_defaultImpl == null) ? null : _defaultImpl.getRawClass();\n    }\n    \n    @Override\n    public String toString() {\n        StringBuilder sb = new StringBuilder();\n        sb.append('[').append(getClass().getName());\n        sb.append(\"; base-type:\").append(_baseType);\n        sb.append(\"; id-resolver: \").append(_idResolver);\n    \t    sb.append(']');\n    \t    return sb.toString();\n    }\n    \n    \n\n    protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n        JsonDeserializer<Object> deser = _deserializers.get(typeId);\n        if (deser == null) {\n            \n            JavaType type = _idResolver.typeFromId(ctxt, typeId);\n            if (type == null) {\n                \n                deser = _findDefaultImplDeserializer(ctxt);\n                if (deser == null) {\n                    \n                    JavaType actual = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);\n                    if (actual == null) { \n                        \n                        return null;\n                    }\n                    \n                    deser = ctxt.findContextualValueDeserializer(actual, _property);\n                }\n            } else {\n                \n                if ((_baseType != null)\n                        && _baseType.getClass() == type.getClass()) {\n                    \n                    \n                    \n                    \n                    \n                        type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n                }\n                deser = ctxt.findContextualValueDeserializer(type, _property);\n            }\n            _deserializers.put(typeId, deser);\n        }\n        return deser;\n    }\n\n    protected final JsonDeserializer<Object> _findDefaultImplDeserializer(DeserializationContext ctxt) throws IOException {\n        \n        if (_defaultImpl == null) {\n            if (!ctxt.isEnabled(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE)) {\n                return NullifyingDeserializer.instance;\n            }\n            return null;\n        }\n        Class<?> raw = _defaultImpl.getRawClass();\n        if (ClassUtil.isBogusClass(raw)) {\n            return NullifyingDeserializer.instance;\n        }\n        \n        synchronized (_defaultImpl) {\n            if (_defaultImplDeserializer == null) {\n                _defaultImplDeserializer = ctxt.findContextualValueDeserializer(\n                        _defaultImpl, _property);\n            }\n            return _defaultImplDeserializer;\n        }\n    }\n\n    \n    @Deprecated\n    protected Object _deserializeWithNativeTypeId(JsonParser jp, DeserializationContext ctxt) throws IOException {\n        return _deserializeWithNativeTypeId(jp, ctxt, jp.getTypeId());\n    }\n\n    \n    protected Object _deserializeWithNativeTypeId(JsonParser jp, DeserializationContext ctxt, Object typeId) throws IOException {\n        JsonDeserializer<Object> deser;\n        if (typeId == null) {\n            \n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                ctxt.reportMappingException(\"No (native) type id found when one was expected for polymorphic type handling\"); return null; } } else { String typeIdStr = (typeId instanceof String) ? (String) typeId : String.valueOf(typeId); deser = _findDeserializer(ctxt, typeIdStr); } return deser.deserialize(jp, ctxt); } protected JavaType _handleUnknownTypeId(DeserializationContext ctxt, String typeId, TypeIdResolver idResolver, JavaType baseType) throws IOException { String extraDesc; if (idResolver instanceof TypeIdResolverBase) { extraDesc = ((TypeIdResolverBase) idResolver).getDescForKnownTypeIds(); if (extraDesc == null) {\n                extraDesc = \"known type ids are not statically known\";\n            } else {\n                extraDesc = \"known type ids = \" + extraDesc;\n            }\n        } else {\n            extraDesc = null;\n        }\n        return ctxt.handleUnknownTypeId(_baseType, typeId, idResolver, extraDesc);\n    }\n}\n",
      "fixed_full_code": "package com.fasterxml.jackson.databind.jsontype.impl;\n\nimport java.io.IOException;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\nimport com.fasterxml.jackson.annotation.JsonTypeInfo;\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.databind.BeanProperty;\nimport com.fasterxml.jackson.databind.DeserializationContext;\nimport com.fasterxml.jackson.databind.DeserializationFeature;\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.JsonDeserializer;\nimport com.fasterxml.jackson.databind.deser.std.NullifyingDeserializer;\nimport com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\nimport com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\n\n\npublic abstract class TypeDeserializerBase extends TypeDeserializer implements java.io.Serializable { private static final long serialVersionUID = 1; protected final TypeIdResolver _idResolver; protected final JavaType _baseType; protected final BeanProperty _property; protected final JavaType _defaultImpl; protected final String _typePropertyName; protected final boolean _typeIdVisible; protected final Map<String,JsonDeserializer<Object>> _deserializers; protected JsonDeserializer<Object> _defaultImplDeserializer; protected TypeDeserializerBase(JavaType baseType, TypeIdResolver idRes, String typePropertyName, boolean typeIdVisible, JavaType defaultImpl) {\n        _baseType = baseType;\n        _idResolver = idRes;\n        \n        _typePropertyName = (typePropertyName == null) ? \"\" : typePropertyName;\n        _typeIdVisible = typeIdVisible;\n        \n        _deserializers = new ConcurrentHashMap<String, JsonDeserializer<Object>>(16, 0.75f, 2);\n        _defaultImpl = defaultImpl;\n        _property = null;\n    }\n\n    protected TypeDeserializerBase(TypeDeserializerBase src, BeanProperty property) {\n        _baseType = src._baseType;\n        _idResolver = src._idResolver;\n        _typePropertyName = src._typePropertyName;\n        _typeIdVisible = src._typeIdVisible;\n        _deserializers = src._deserializers;\n        _defaultImpl = src._defaultImpl;\n        _defaultImplDeserializer = src._defaultImplDeserializer;\n        _property = property;\n    }\n\n    @Override\n    public abstract TypeDeserializer forProperty(BeanProperty prop); @Override public abstract JsonTypeInfo.As getTypeInclusion(); public String baseTypeName() { return _baseType.getRawClass().getName(); }\n\n    @Override\n    public final String getPropertyName() { return _typePropertyName; }\n    \n    @Override    \n    public TypeIdResolver getTypeIdResolver() { return _idResolver; }\n\n    @Override    \n    public Class<?> getDefaultImpl() {\n        return (_defaultImpl == null) ? null : _defaultImpl.getRawClass();\n    }\n    \n    @Override\n    public String toString() {\n        StringBuilder sb = new StringBuilder();\n        sb.append('[').append(getClass().getName());\n        sb.append(\"; base-type:\").append(_baseType);\n        sb.append(\"; id-resolver: \").append(_idResolver);\n    \t    sb.append(']');\n    \t    return sb.toString();\n    }\n    \n    \n\n    protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n        JsonDeserializer<Object> deser = _deserializers.get(typeId);\n        if (deser == null) {\n            \n            JavaType type = _idResolver.typeFromId(ctxt, typeId);\n            if (type == null) {\n                \n                deser = _findDefaultImplDeserializer(ctxt);\n                if (deser == null) {\n                    \n                    JavaType actual = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);\n                    if (actual == null) { \n                        \n                        return null;\n                    }\n                    \n                    deser = ctxt.findContextualValueDeserializer(actual, _property);\n                }\n            } else {\n                \n                if ((_baseType != null)\n                        && _baseType.getClass() == type.getClass()) {\n                    \n                    \n                    \n                    \n                    \n                    if (!type.hasGenericTypes()) {\n                        type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n                    }\n                }\n                deser = ctxt.findContextualValueDeserializer(type, _property);\n            }\n            _deserializers.put(typeId, deser);\n        }\n        return deser;\n    }\n\n    protected final JsonDeserializer<Object> _findDefaultImplDeserializer(DeserializationContext ctxt) throws IOException {\n        \n        if (_defaultImpl == null) {\n            if (!ctxt.isEnabled(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE)) {\n                return NullifyingDeserializer.instance;\n            }\n            return null;\n        }\n        Class<?> raw = _defaultImpl.getRawClass();\n        if (ClassUtil.isBogusClass(raw)) {\n            return NullifyingDeserializer.instance;\n        }\n        \n        synchronized (_defaultImpl) {\n            if (_defaultImplDeserializer == null) {\n                _defaultImplDeserializer = ctxt.findContextualValueDeserializer(\n                        _defaultImpl, _property);\n            }\n            return _defaultImplDeserializer;\n        }\n    }\n\n    \n    @Deprecated\n    protected Object _deserializeWithNativeTypeId(JsonParser jp, DeserializationContext ctxt) throws IOException {\n        return _deserializeWithNativeTypeId(jp, ctxt, jp.getTypeId());\n    }\n\n    \n    protected Object _deserializeWithNativeTypeId(JsonParser jp, DeserializationContext ctxt, Object typeId) throws IOException {\n        JsonDeserializer<Object> deser;\n        if (typeId == null) {\n            \n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                ctxt.reportMappingException(\"No (native) type id found when one was expected for polymorphic type handling\"); return null; } } else { String typeIdStr = (typeId instanceof String) ? (String) typeId : String.valueOf(typeId); deser = _findDeserializer(ctxt, typeIdStr); } return deser.deserialize(jp, ctxt); } protected JavaType _handleUnknownTypeId(DeserializationContext ctxt, String typeId, TypeIdResolver idResolver, JavaType baseType) throws IOException { String extraDesc; if (idResolver instanceof TypeIdResolverBase) { extraDesc = ((TypeIdResolverBase) idResolver).getDescForKnownTypeIds(); if (extraDesc == null) {\n                extraDesc = \"known type ids are not statically known\";\n            } else {\n                extraDesc = \"known type ids = \" + extraDesc;\n            }\n        } else {\n            extraDesc = null;\n        }\n        return ctxt.handleUnknownTypeId(_baseType, typeId, idResolver, extraDesc);\n    }\n}\n",
      "buggy_signatures": [
        "protected TypeDeserializerBase(TypeDeserializerBase src, BeanProperty property)",
        "public abstract TypeDeserializer forProperty(BeanProperty prop); @Override public abstract JsonTypeInfo.As getTypeInclusion(); public String baseTypeName()",
        "public final String getPropertyName()",
        "public TypeIdResolver getTypeIdResolver()",
        "public Class<?> getDefaultImpl()",
        "public String toString()",
        "protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException",
        "protected final JsonDeserializer<Object> _findDefaultImplDeserializer(DeserializationContext ctxt) throws IOException",
        "synchronized (_defaultImpl)",
        "protected Object _deserializeWithNativeTypeId(JsonParser jp, DeserializationContext ctxt) throws IOException",
        "protected Object _deserializeWithNativeTypeId(JsonParser jp, DeserializationContext ctxt, Object typeId) throws IOException"
      ],
      "fixed_signatures": [
        "protected TypeDeserializerBase(TypeDeserializerBase src, BeanProperty property)",
        "public abstract TypeDeserializer forProperty(BeanProperty prop); @Override public abstract JsonTypeInfo.As getTypeInclusion(); public String baseTypeName()",
        "public final String getPropertyName()",
        "public TypeIdResolver getTypeIdResolver()",
        "public Class<?> getDefaultImpl()",
        "public String toString()",
        "protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException",
        "protected final JsonDeserializer<Object> _findDefaultImplDeserializer(DeserializationContext ctxt) throws IOException",
        "synchronized (_defaultImpl)",
        "protected Object _deserializeWithNativeTypeId(JsonParser jp, DeserializationContext ctxt) throws IOException",
        "protected Object _deserializeWithNativeTypeId(JsonParser jp, DeserializationContext ctxt, Object typeId) throws IOException"
      ],
      "methods": [
        {
          "buggy_method": "  protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n  JsonDeserializer<Object> deser = _deserializers.get(typeId);\n  if (deser == null) {\n  \n  JavaType type = _idResolver.typeFromId(ctxt, typeId);\n  if (type == null) {\n  \n  deser = _findDefaultImplDeserializer(ctxt);\n  if (deser == null) {\n  \n  JavaType actual = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);\n  if (actual == null) { \n  \n  return null;\n  }\n  \n  deser = ctxt.findContextualValueDeserializer(actual, _property);\n  }\n  } else {\n  \n  if ((_baseType != null)\n  && _baseType.getClass() == type.getClass()) {\n  \n  \n  \n  \n  \n  type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n  }\n  deser = ctxt.findContextualValueDeserializer(type, _property);\n  }\n  _deserializers.put(typeId, deser);\n  }\n  return deser;\n  }",
          "fixed_method": "  protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n  JsonDeserializer<Object> deser = _deserializers.get(typeId);\n  if (deser == null) {\n  \n  JavaType type = _idResolver.typeFromId(ctxt, typeId);\n  if (type == null) {\n  \n  deser = _findDefaultImplDeserializer(ctxt);\n  if (deser == null) {\n  \n  JavaType actual = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);\n  if (actual == null) { \n  \n  return null;\n  }\n  \n  deser = ctxt.findContextualValueDeserializer(actual, _property);\n  }\n  } else {\n  \n  if ((_baseType != null)\n  && _baseType.getClass() == type.getClass()) {\n  \n  \n  \n  \n  \n  if (!type.hasGenericTypes()) {\n  type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n  }\n  }\n  deser = ctxt.findContextualValueDeserializer(type, _property);\n  }\n  _deserializers.put(typeId, deser);\n  }\n  return deser;\n  }",
          "diff": [
            "@@ -181,7 +181,9 @@",
            "                     //   generic type with custom type resolvers. If so, should try to retain them.\n",
            "                     //  Whether this is sufficient to avoid problems remains to be seen, but for\n",
            "                     //  now it should improve things.\n",
            "+                    if (!type.hasGenericTypes()) {\n",
            "                         type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n",
            "+                    }\n",
            "                 }\n",
            "                 deser = ctxt.findContextualValueDeserializer(type, _property);\n",
            "             }\n"
          ],
          "changed_lines": 2
        }
      ]
    }
  ]
}
