{
  "bug_id": "7",
  "failed_tests": {
    "com.fasterxml.jackson.databind.creators.TestCreatorsDelegating": [
      {
        "methodName": "testDelegateWithTokenBuffer",
        "error": "junit.framework.AssertionFailedError",
        "message": "Expected token START_OBJECT, current token FIELD_NAME",
        "fail_line": "        assertToken(JsonToken.START_OBJECT, jp.nextToken());",
        "test_source": "  public void testDelegateWithTokenBuffer() throws Exception {\n  ObjectMapper mapper = new ObjectMapper();\n  Value592 value = mapper.readValue(\"{\\\"a\\\":1,\\\"b\\\":2}\", Value592.class);\n  assertNotNull(value);\n  Object ob = value.stuff;\n  assertEquals(TokenBuffer.class, ob.getClass());\n  JsonParser jp = ((TokenBuffer) ob).asParser();\n  assertToken(JsonToken.START_OBJECT, jp.nextToken());\n  assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n  assertEquals(\"a\", jp.getCurrentName());\n  assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n  assertEquals(1, jp.getIntValue());\n  assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n  assertEquals(\"b\", jp.getCurrentName());\n  assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n  assertEquals(2, jp.getIntValue());\n  assertToken(JsonToken.END_OBJECT, jp.nextToken());\n  jp.close();\n  }",
        "stack": [
          "BaseTest.assertToken line 333, TestCreatorsDelegating.testDelegateWithTokenBuffer line 132"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "com/fasterxml/jackson/databind/util/TokenBuffer.java",
      "buggy_full_code": "package com.fasterxml.jackson.databind.util;\n\nimport java.io.*;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.util.TreeMap;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.base.ParserMinimalBase;\nimport com.fasterxml.jackson.core.json.JsonReadContext;\nimport com.fasterxml.jackson.core.json.JsonWriteContext;\nimport com.fasterxml.jackson.core.util.ByteArrayBuilder;\nimport com.fasterxml.jackson.databind.*;\n\n\npublic class TokenBuffer extends JsonGenerator { protected final static int DEFAULT_GENERATOR_FEATURES = JsonGenerator.Feature.collectDefaults(); protected ObjectCodec _objectCodec; protected int _generatorFeatures; protected boolean _closed; protected boolean _hasNativeTypeIds; protected boolean _hasNativeObjectIds; protected boolean _mayHaveNativeIds; protected Segment _first; protected Segment _last; protected int _appendAt; protected Object _typeId; protected Object _objectId; protected boolean _hasNativeId = false; protected JsonWriteContext _writeContext; @Deprecated public TokenBuffer(ObjectCodec codec) {\n        this(codec, false);\n    }\n\n    \n    public TokenBuffer(ObjectCodec codec, boolean hasNativeIds) {\n        _objectCodec = codec;\n        _generatorFeatures = DEFAULT_GENERATOR_FEATURES;\n        _writeContext = JsonWriteContext.createRootContext(null);\n        \n        _first = _last = new Segment();\n        _appendAt = 0;\n        _hasNativeTypeIds = hasNativeIds;\n        _hasNativeObjectIds = hasNativeIds;\n\n        _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds;\n    }\n\n    \n    public TokenBuffer(JsonParser jp) {\n        _objectCodec = jp.getCodec();\n        _generatorFeatures = DEFAULT_GENERATOR_FEATURES;\n        _writeContext = JsonWriteContext.createRootContext(null);\n        \n        _first = _last = new Segment();\n        _appendAt = 0;\n        _hasNativeTypeIds = jp.canReadTypeId();\n        _hasNativeObjectIds = jp.canReadObjectId();\n        _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds;\n    }\n    \n    @Override\n    public Version version() {\n        return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION;\n    }\n\n    \n    public JsonParser asParser() {\n        return asParser(_objectCodec);\n    }\n\n    \n    public JsonParser asParser(ObjectCodec codec) {\n        return new Parser(_first, codec, _hasNativeTypeIds, _hasNativeObjectIds);\n    }\n\n    \n    public JsonParser asParser(JsonParser src) {\n        Parser p = new Parser(_first, src.getCodec(), _hasNativeTypeIds, _hasNativeObjectIds);\n        p.setLocation(src.getTokenLocation());\n        return p;\n    }\n    \n    \n\n    public JsonToken firstToken() {\n        if (_first != null) {\n            return _first.type(0);\n        }\n        return null;\n    }\n    \n    \n\n    \n    @SuppressWarnings(\"resource\")\n    public TokenBuffer append(TokenBuffer other) throws IOException, JsonGenerationException {\n        \n        if (!_hasNativeTypeIds) {  \n            _hasNativeTypeIds = other.canWriteTypeId();\n        }\n        if (!_hasNativeObjectIds) {\n            _hasNativeObjectIds = other.canWriteObjectId();\n        }\n        _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds;\n        \n        JsonParser jp = other.asParser();\n        while (jp.nextToken() != null) {\n            copyCurrentStructure(jp);\n        }\n        return this;\n    }\n    \n    \n    public void serialize(JsonGenerator jgen) throws IOException, JsonGenerationException {\n        Segment segment = _first;\n        int ptr = -1;\n\n        final boolean checkIds = _mayHaveNativeIds;\n        boolean hasIds = checkIds && (segment.hasIds());\n\n        while (true) {\n            if (++ptr >= Segment.TOKENS_PER_SEGMENT) {\n                ptr = 0;\n                segment = segment.next();\n                if (segment == null) break;\n                hasIds = checkIds && (segment.hasIds());\n            }\n            JsonToken t = segment.type(ptr);\n            if (t == null) break;\n\n            if (hasIds) {\n                Object id = segment.findObjectId(ptr);\n                if (id != null) {\n                    jgen.writeObjectId(id);\n                }\n                id = segment.findTypeId(ptr);\n                if (id != null) {\n                    jgen.writeTypeId(id);\n                }\n            }\n            \n            \n            switch (t) {\n            case START_OBJECT:\n                jgen.writeStartObject();\n                break;\n            case END_OBJECT:\n                jgen.writeEndObject();\n                break;\n            case START_ARRAY:\n                jgen.writeStartArray();\n                break;\n            case END_ARRAY:\n                jgen.writeEndArray();\n                break;\n            case FIELD_NAME:\n            {\n                \n                Object ob = segment.get(ptr);\n                if (ob instanceof SerializableString) {\n                    jgen.writeFieldName((SerializableString) ob);\n                } else {\n                    jgen.writeFieldName((String) ob);\n                }\n            }\n                break;\n            case VALUE_STRING:\n                {\n                    Object ob = segment.get(ptr);\n                    if (ob instanceof SerializableString) {\n                        jgen.writeString((SerializableString) ob);\n                    } else {\n                        jgen.writeString((String) ob);\n                    }\n                }\n                break;\n            case VALUE_NUMBER_INT:\n                {\n                    Object n = segment.get(ptr);\n                    if (n instanceof Integer) {\n                        jgen.writeNumber((Integer) n);\n                    } else if (n instanceof BigInteger) {\n                        jgen.writeNumber((BigInteger) n);\n                    } else if (n instanceof Long) {\n                        jgen.writeNumber((Long) n);\n                    } else if (n instanceof Short) {\n                        jgen.writeNumber((Short) n);\n                    } else {\n                        jgen.writeNumber(((Number) n).intValue());\n                    }\n                }\n                break;\n            case VALUE_NUMBER_FLOAT:\n                {\n                    Object n = segment.get(ptr);\n                    if (n instanceof Double) {\n                        jgen.writeNumber(((Double) n).doubleValue());\n                    } else if (n instanceof BigDecimal) {\n                        jgen.writeNumber((BigDecimal) n);\n                    } else if (n instanceof Float) {\n                        jgen.writeNumber(((Float) n).floatValue());\n                    } else if (n == null) {\n                        jgen.writeNull();\n                    } else if (n instanceof String) {\n                        jgen.writeNumber((String) n);\n                    } else {\n                        throw new JsonGenerationException(\"Unrecognized value type for VALUE_NUMBER_FLOAT: \"+n.getClass().getName()+\", can not serialize\");\n                    }\n                }\n                break;\n            case VALUE_TRUE:\n                jgen.writeBoolean(true);\n                break;\n            case VALUE_FALSE:\n                jgen.writeBoolean(false);\n                break;\n            case VALUE_NULL:\n                jgen.writeNull();\n                break;\n            case VALUE_EMBEDDED_OBJECT:\n                jgen.writeObject(segment.get(ptr));\n                break;\n            default:\n                throw new RuntimeException(\"Internal error: should never end up through this code path\");\n            }\n        }\n    }\n\n    \n    public TokenBuffer deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {\n            copyCurrentStructure(jp);\n        \n        return this;\n    }\n    \n    @Override\n    @SuppressWarnings(\"resource\")\n    public String toString() {\n        \n        final int MAX_COUNT = 100;\n\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"[TokenBuffer: \");\n\n        \n        \n        JsonParser jp = asParser();\n        int count = 0;\n        final boolean hasNativeIds = _hasNativeTypeIds || _hasNativeObjectIds;\n\n        while (true) {\n            JsonToken t;\n            try {\n                t = jp.nextToken();\n                if (t == null) break;\n\n                if (hasNativeIds) {\n                    _appendNativeIds(sb);\n                }\n                        \n                if (count < MAX_COUNT) {\n                    if (count > 0) {\n                        sb.append(\", \");\n                    }\n                    sb.append(t.toString());\n                    if (t == JsonToken.FIELD_NAME) {\n                        sb.append('(');\n                        sb.append(jp.getCurrentName());\n                        sb.append(')');\n                    }\n                }\n            } catch (IOException ioe) { \n                throw new IllegalStateException(ioe);\n            }\n            ++count;\n        }\n\n        if (count >= MAX_COUNT) {\n            sb.append(\" ... (truncated \").append(count-MAX_COUNT).append(\" entries)\");\n        }\n        sb.append(']');\n        return sb.toString();\n    }\n\n    private final void _appendNativeIds(StringBuilder sb) {\n        Object objectId = _last.findObjectId(_appendAt-1);\n        if (objectId != null) {\n            sb.append(\"[objectId=\").append(String.valueOf(objectId)).append(']');\n        }\n        Object typeId = _last.findTypeId(_appendAt-1);\n        if (typeId != null) {\n            sb.append(\"[typeId=\").append(String.valueOf(typeId)).append(']');\n        }\n    }\n    \n    \n\n    @Override\n    public JsonGenerator enable(Feature f) {\n        _generatorFeatures |= f.getMask();\n        return this;\n    }\n\n    @Override\n    public JsonGenerator disable(Feature f) {\n        _generatorFeatures &= ~f.getMask();\n        return this;\n    }\n\n    \n\n    @Override\n    public boolean isEnabled(Feature f) {\n        return (_generatorFeatures & f.getMask()) != 0;\n    }\n\n    @Override\n    public int getFeatureMask() {\n        return _generatorFeatures;\n    }\n\n    @Override\n    public JsonGenerator setFeatureMask(int mask) {\n        _generatorFeatures = mask;\n        return this;\n    }\n    \n    @Override\n    public JsonGenerator useDefaultPrettyPrinter() {\n        \n        return this;\n    }\n\n    @Override\n    public JsonGenerator setCodec(ObjectCodec oc) {\n        _objectCodec = oc;\n        return this;\n    }\n\n    @Override\n    public ObjectCodec getCodec() { return _objectCodec; }\n\n    @Override\n    public final JsonWriteContext getOutputContext() { return _writeContext; }\n\n    \n    \n    \n    @Override\n    public boolean canWriteBinaryNatively() {\n        return true;\n    }\n    \n    \n\n    @Override\n    public void flush() throws IOException {  }\n\n    @Override\n    public void close() throws IOException {\n        _closed = true;\n    }\n\n    @Override\n    public boolean isClosed() { return _closed; }\n\n    \n\n    @Override\n    public final void writeStartArray() throws IOException, JsonGenerationException {\n        _append(JsonToken.START_ARRAY);\n        _writeContext = _writeContext.createChildArrayContext();\n    }\n\n    @Override\n    public final void writeEndArray() throws IOException, JsonGenerationException {\n        _append(JsonToken.END_ARRAY);\n        \n        JsonWriteContext c = _writeContext.getParent();\n        if (c != null) {\n            _writeContext = c;\n        }\n    }\n\n    @Override\n    public final void writeStartObject() throws IOException, JsonGenerationException {\n        _append(JsonToken.START_OBJECT);\n        _writeContext = _writeContext.createChildObjectContext();\n    }\n\n    @Override\n    public final void writeEndObject() throws IOException, JsonGenerationException {\n        _append(JsonToken.END_OBJECT);\n        \n        JsonWriteContext c = _writeContext.getParent();\n        if (c != null) {\n            _writeContext = c;\n        }\n    }\n\n    @Override\n    public final void writeFieldName(String name) throws IOException, JsonGenerationException {\n        _append(JsonToken.FIELD_NAME, name);\n        _writeContext.writeFieldName(name);\n    }\n\n    @Override\n    public void writeFieldName(SerializableString name) throws IOException, JsonGenerationException {\n        _append(JsonToken.FIELD_NAME, name);\n        _writeContext.writeFieldName(name.getValue());\n    }\n    \n    \n\n    @Override\n    public void writeString(String text) throws IOException,JsonGenerationException {\n        if (text == null) {\n            writeNull();\n        } else {\n            _append(JsonToken.VALUE_STRING, text);\n        }\n    }\n\n    @Override\n    public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException {\n        writeString(new String(text, offset, len));\n    }\n\n    @Override\n    public void writeString(SerializableString text) throws IOException, JsonGenerationException {\n        if (text == null) {\n            writeNull();\n        } else {\n            _append(JsonToken.VALUE_STRING, text);\n        }\n    }\n    \n    @Override\n    public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException {\n        \n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException {\n        \n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeRaw(String text) throws IOException, JsonGenerationException {\n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException {\n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeRaw(SerializableString text) throws IOException, JsonGenerationException {\n        _reportUnsupportedOperation();\n    }\n    \n    @Override\n    public void writeRaw(char[] text, int offset, int len) throws IOException, JsonGenerationException {\n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeRaw(char c) throws IOException, JsonGenerationException {\n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeRawValue(String text) throws IOException, JsonGenerationException {\n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeRawValue(String text, int offset, int len) throws IOException, JsonGenerationException {\n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeRawValue(char[] text, int offset, int len) throws IOException, JsonGenerationException {\n        _reportUnsupportedOperation();\n    }\n\n    \n\n    @Override\n    public void writeNumber(short i) throws IOException, JsonGenerationException {\n        _append(JsonToken.VALUE_NUMBER_INT, Short.valueOf(i));\n    }\n\n    @Override\n    public void writeNumber(int i) throws IOException, JsonGenerationException {\n        _append(JsonToken.VALUE_NUMBER_INT, Integer.valueOf(i));\n    }\n\n    @Override\n    public void writeNumber(long l) throws IOException, JsonGenerationException {\n        _append(JsonToken.VALUE_NUMBER_INT, Long.valueOf(l));\n    }\n\n    @Override\n    public void writeNumber(double d) throws IOException,JsonGenerationException {\n        _append(JsonToken.VALUE_NUMBER_FLOAT, Double.valueOf(d));\n    }\n\n    @Override\n    public void writeNumber(float f) throws IOException, JsonGenerationException {\n        _append(JsonToken.VALUE_NUMBER_FLOAT, Float.valueOf(f));\n    }\n\n    @Override\n    public void writeNumber(BigDecimal dec) throws IOException,JsonGenerationException {\n        if (dec == null) {\n            writeNull();\n        } else {\n            _append(JsonToken.VALUE_NUMBER_FLOAT, dec);\n        }\n    }\n\n    @Override\n    public void writeNumber(BigInteger v) throws IOException, JsonGenerationException {\n        if (v == null) {\n            writeNull();\n        } else {\n            _append(JsonToken.VALUE_NUMBER_INT, v);\n        }\n    }\n\n    @Override\n    public void writeNumber(String encodedValue) throws IOException, JsonGenerationException {\n        \n        _append(JsonToken.VALUE_NUMBER_FLOAT, encodedValue);\n    }\n\n    @Override\n    public void writeBoolean(boolean state) throws IOException,JsonGenerationException {\n        _append(state ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE);\n    }\n\n    @Override\n    public void writeNull() throws IOException, JsonGenerationException {\n        _append(JsonToken.VALUE_NULL);\n    }\n\n    \n\n    @Override\n    public void writeObject(Object value) throws IOException {\n        if (value == null) {\n            writeNull();\n            return;\n        }\n        Class<?> raw = value.getClass();\n        if (raw == byte[].class) {\n            _append(JsonToken.VALUE_EMBEDDED_OBJECT, value);\n            return;\n        } else if (_objectCodec == null) {\n            \n\n            _append(JsonToken.VALUE_EMBEDDED_OBJECT, value);\n        } else {\n            _objectCodec.writeValue(this, value);\n        }\n    }\n\n    @Override\n    public void writeTree(TreeNode node) throws IOException {\n        if (node == null) {\n            writeNull();\n            return;\n        }\n\n        if (_objectCodec == null) {\n            \n            _append(JsonToken.VALUE_EMBEDDED_OBJECT, node);\n        } else {\n            _objectCodec.writeTree(this, node);\n        }\n    }\n\n    \n\n    @Override\n    public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException {\n        \n        byte[] copy = new byte[len];\n        System.arraycopy(data, offset, copy, 0, len);\n        writeObject(copy);\n    }\n\n    \n    @Override\n    public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) {\n        throw new UnsupportedOperationException();\n    }\n\n    \n\n    @Override\n    public boolean canWriteTypeId() {\n        return _hasNativeTypeIds;\n    }\n\n    @Override\n    public boolean canWriteObjectId() {\n        return _hasNativeObjectIds;\n    }\n    \n    @Override\n    public void writeTypeId(Object id) {\n        _typeId = id;\n        _hasNativeId = true;\n    }\n    \n    @Override\n    public void writeObjectId(Object id) {\n        _objectId = id;\n        _hasNativeId = true;\n    }\n\n    \n\n    @Override\n    public void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException {\n        if (_mayHaveNativeIds) {\n            _checkNativeIds(jp);\n        }\n        switch (jp.getCurrentToken()) {\n        case START_OBJECT:\n            writeStartObject();\n            break;\n        case END_OBJECT:\n            writeEndObject();\n            break;\n        case START_ARRAY:\n            writeStartArray();\n            break;\n        case END_ARRAY:\n            writeEndArray();\n            break;\n        case FIELD_NAME:\n            writeFieldName(jp.getCurrentName());\n            break;\n        case VALUE_STRING:\n            if (jp.hasTextCharacters()) {\n                writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength());\n            } else {\n                writeString(jp.getText());\n            }\n            break;\n        case VALUE_NUMBER_INT:\n            switch (jp.getNumberType()) {\n            case INT:\n                writeNumber(jp.getIntValue());\n                break;\n            case BIG_INTEGER:\n                writeNumber(jp.getBigIntegerValue());\n                break;\n            default:\n                writeNumber(jp.getLongValue());\n            }\n            break;\n        case VALUE_NUMBER_FLOAT:\n            switch (jp.getNumberType()) {\n            case BIG_DECIMAL:\n                writeNumber(jp.getDecimalValue());\n                break;\n            case FLOAT:\n                writeNumber(jp.getFloatValue());\n                break;\n            default:\n                writeNumber(jp.getDoubleValue());\n            }\n            break;\n        case VALUE_TRUE:\n            writeBoolean(true);\n            break;\n        case VALUE_FALSE:\n            writeBoolean(false);\n            break;\n        case VALUE_NULL:\n            writeNull();\n            break;\n        case VALUE_EMBEDDED_OBJECT:\n            writeObject(jp.getEmbeddedObject());\n            break;\n        default:\n            throw new RuntimeException(\"Internal error: should never end up through this code path\");\n        }\n    }\n    \n    @Override\n    public void copyCurrentStructure(JsonParser jp) throws IOException, JsonProcessingException {\n        JsonToken t = jp.getCurrentToken();\n\n        \n        if (t == JsonToken.FIELD_NAME) {\n            if (_mayHaveNativeIds) {\n                _checkNativeIds(jp);\n            }\n            writeFieldName(jp.getCurrentName());\n            t = jp.nextToken();\n            \n        }\n\n        if (_mayHaveNativeIds) {\n            _checkNativeIds(jp);\n        }\n        \n        switch (t) {\n        case START_ARRAY:\n            writeStartArray();\n            while (jp.nextToken() != JsonToken.END_ARRAY) {\n                copyCurrentStructure(jp);\n            }\n            writeEndArray();\n            break;\n        case START_OBJECT:\n            writeStartObject();\n            while (jp.nextToken() != JsonToken.END_OBJECT) {\n                copyCurrentStructure(jp);\n            }\n            writeEndObject();\n            break;\n        default: \n            copyCurrentEvent(jp);\n        }\n    }\n\n    \n    private final void _checkNativeIds(JsonParser jp) throws IOException, JsonProcessingException {\n        if ((_typeId = jp.getTypeId()) != null) {\n            _hasNativeId = true;\n        }\n        if ((_objectId = jp.getObjectId()) != null) {\n            _hasNativeId = true;\n        }\n    }\n    \n    \n\n    protected final void _append(JsonToken type) {\n        Segment next = _hasNativeId\n                ? _last.append(_appendAt, type, _objectId, _typeId)\n                : _last.append(_appendAt, type);\n        if (next == null) {\n            ++_appendAt;\n        } else {\n            _last = next;\n            _appendAt = 1; \n        }\n    }\n\n    protected final void _append(JsonToken type, Object value) {\n        Segment next = _hasNativeId\n                ? _last.append(_appendAt, type, value, _objectId, _typeId)\n                : _last.append(_appendAt, type, value);\n        if (next == null) {\n            ++_appendAt;\n        } else {\n            _last = next;\n            _appendAt = 1;\n        }\n    }\n\n    protected final void _appendRaw(int rawType, Object value) {\n        Segment next = _hasNativeId\n                ? _last.appendRaw(_appendAt, rawType, value, _objectId, _typeId)\n                : _last.appendRaw(_appendAt, rawType, value);\n        if (next == null) {\n            ++_appendAt;\n        } else {\n            _last = next;\n            _appendAt = 1;\n        }\n    }\n\n    @Override\n    protected void _reportUnsupportedOperation() {\n        throw new UnsupportedOperationException(\"Called operation not supported for TokenBuffer\");\n    }\n    \n    \n\n    protected final static class Parser extends ParserMinimalBase { protected ObjectCodec _codec; protected final boolean _hasNativeTypeIds; protected final boolean _hasNativeObjectIds; protected final boolean _hasNativeIds; protected Segment _segment; protected int _segmentPtr; protected JsonReadContext _parsingContext; protected boolean _closed; protected transient ByteArrayBuilder _byteBuilder; protected JsonLocation _location = null; @Deprecated protected Parser(Segment firstSeg, ObjectCodec codec) {\n            this(firstSeg, codec, false, false);\n        }\n\n        \n        public Parser(Segment firstSeg, ObjectCodec codec, boolean hasNativeTypeIds, boolean hasNativeObjectIds) {\n            super(0);\n            _segment = firstSeg;\n            _segmentPtr = -1; \n            _codec = codec;\n            _parsingContext = JsonReadContext.createRootContext(null);\n            _hasNativeTypeIds = hasNativeTypeIds;\n            _hasNativeObjectIds = hasNativeObjectIds;\n            _hasNativeIds = (hasNativeTypeIds | hasNativeObjectIds);\n        }\n\n        public void setLocation(JsonLocation l) {\n            _location = l;\n        }\n        \n        @Override\n        public ObjectCodec getCodec() { return _codec; }\n\n        @Override\n        public void setCodec(ObjectCodec c) { _codec = c; }\n\n        @Override\n        public Version version() {\n            return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION;\n        }\n\n        \n        \n        public JsonToken peekNextToken() throws IOException, JsonParseException {\n            \n            if (_closed) return null;\n            Segment seg = _segment;\n            int ptr = _segmentPtr+1;\n            if (ptr >= Segment.TOKENS_PER_SEGMENT) {\n                ptr = 0;\n                seg = (seg == null) ? null : seg.next();\n            }\n            return (seg == null) ? null : seg.type(ptr);\n        }\n        \n        \n\n        @Override\n        public void close() throws IOException {\n            if (!_closed) {\n                _closed = true;\n            }\n        }\n\n        \n        \n        @Override\n        public JsonToken nextToken() throws IOException, JsonParseException {\n            \n            if (_closed || (_segment == null)) return null;\n\n            \n            if (++_segmentPtr >= Segment.TOKENS_PER_SEGMENT) {\n                _segmentPtr = 0;\n                _segment = _segment.next();\n                if (_segment == null) {\n                    return null;\n                }\n            }\n            _currToken = _segment.type(_segmentPtr);\n            \n            if (_currToken == JsonToken.FIELD_NAME) {\n                Object ob = _currentObject();\n                String name = (ob instanceof String) ? ((String) ob) : ob.toString();\n                _parsingContext.setCurrentName(name);\n            } else if (_currToken == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n            } else if (_currToken == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(-1, -1);\n            } else if (_currToken == JsonToken.END_OBJECT\n                    || _currToken == JsonToken.END_ARRAY) {\n                \n                _parsingContext = _parsingContext.getParent();\n                \n                if (_parsingContext == null) {\n                    _parsingContext = JsonReadContext.createRootContext(null);\n                }\n            }\n            return _currToken;\n        }\n\n        @Override\n        public boolean isClosed() { return _closed; }\n\n        \n        \n        @Override\n        public JsonStreamContext getParsingContext() { return _parsingContext; }\n\n        @Override\n        public JsonLocation getTokenLocation() { return getCurrentLocation(); }\n\n        @Override\n        public JsonLocation getCurrentLocation() {\n            return (_location == null) ? JsonLocation.NA : _location;\n        }\n\n        @Override\n        public String getCurrentName() { return _parsingContext.getCurrentName(); }\n\n        @Override\n        public void overrideCurrentName(String name) {\n            \n            JsonReadContext ctxt = _parsingContext;\n            if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\n                ctxt = ctxt.getParent();\n            }\n            try {\n                ctxt.setCurrentName(name);\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        \n        \n        \n        @Override\n        public String getText() {\n            \n            if (_currToken == JsonToken.VALUE_STRING\n                    || _currToken == JsonToken.FIELD_NAME) {\n                Object ob = _currentObject();\n                if (ob instanceof String) {\n                    return (String) ob;\n                }\n                return (ob == null) ? null : ob.toString();\n            }\n            if (_currToken == null) {\n                return null;\n            }\n            switch (_currToken) {\n            case VALUE_NUMBER_INT:\n            case VALUE_NUMBER_FLOAT:\n                Object ob = _currentObject();\n                return (ob == null) ? null : ob.toString();\n            default:\n            \treturn _currToken.asString();\n            }\n        }\n\n        @Override\n        public char[] getTextCharacters() {\n            String str = getText();\n            return (str == null) ? null : str.toCharArray();\n        }\n\n        @Override\n        public int getTextLength() {\n            String str = getText();\n            return (str == null) ? 0 : str.length();\n        }\n\n        @Override\n        public int getTextOffset() { return 0; }\n\n        @Override\n        public boolean hasTextCharacters() {\n            \n            return false;\n        }\n        \n        \n\n        @Override\n        public BigInteger getBigIntegerValue() throws IOException, JsonParseException {\n            Number n = getNumberValue();\n            if (n instanceof BigInteger) {\n                return (BigInteger) n;\n            }\n            if (getNumberType() == NumberType.BIG_DECIMAL) {\n                return ((BigDecimal) n).toBigInteger();\n            }\n            \n            return BigInteger.valueOf(n.longValue());\n        }\n\n        @Override\n        public BigDecimal getDecimalValue() throws IOException, JsonParseException {\n            Number n = getNumberValue();\n            if (n instanceof BigDecimal) {\n                return (BigDecimal) n;\n            }\n            switch (getNumberType()) {\n            case INT:\n            case LONG:\n                return BigDecimal.valueOf(n.longValue());\n            case BIG_INTEGER:\n                return new BigDecimal((BigInteger) n);\n            default:\n            }\n            \n            return BigDecimal.valueOf(n.doubleValue());\n        }\n\n        @Override\n        public double getDoubleValue() throws IOException, JsonParseException {\n            return getNumberValue().doubleValue();\n        }\n\n        @Override\n        public float getFloatValue() throws IOException, JsonParseException {\n            return getNumberValue().floatValue();\n        }\n\n        @Override\n        public int getIntValue() throws IOException, JsonParseException {\n            \n            if (_currToken == JsonToken.VALUE_NUMBER_INT) {\n                return ((Number) _currentObject()).intValue();\n            }\n            return getNumberValue().intValue();\n        }\n\n        @Override\n        public long getLongValue() throws IOException, JsonParseException {\n            return getNumberValue().longValue();\n        }\n\n        @Override\n        public NumberType getNumberType() throws IOException, JsonParseException {\n            Number n = getNumberValue();\n            if (n instanceof Integer) return NumberType.INT;\n            if (n instanceof Long) return NumberType.LONG;\n            if (n instanceof Double) return NumberType.DOUBLE;\n            if (n instanceof BigDecimal) return NumberType.BIG_DECIMAL;\n            if (n instanceof BigInteger) return NumberType.BIG_INTEGER;\n            if (n instanceof Float) return NumberType.FLOAT;\n            if (n instanceof Short) return NumberType.INT;       \n            return null;\n        }\n\n        @Override\n        public final Number getNumberValue() throws IOException, JsonParseException {\n            _checkIsNumber();\n            Object value = _currentObject();\n            if (value instanceof Number) {\n                return (Number) value;\n            }\n            \n            \n            \n            if (value instanceof String) {\n                String str = (String) value;\n                if (str.indexOf('.') >= 0) {\n                    return Double.parseDouble(str);\n                }\n                return Long.parseLong(str);\n            }\n            if (value == null) {\n                return null;\n            }\n            throw new IllegalStateException(\"Internal error: entry should be a Number, but is of type \"\n                    +value.getClass().getName());\n        }\n\n        \n\n        @Override\n        public Object getEmbeddedObject() {\n            if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) {\n                return _currentObject();\n            }\n            return null;\n        }\n\n        @Override\n        @SuppressWarnings(\"resource\")\n        public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException {\n            \n            if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) {\n                \n                Object ob = _currentObject();\n                if (ob instanceof byte[]) {\n                    return (byte[]) ob;\n                }\n                \n            }\n            if (_currToken != JsonToken.VALUE_STRING) {\n                throw _constructError(\"Current token (\"+_currToken+\") not VALUE_STRING (or VALUE_EMBEDDED_OBJECT with byte[]), can not access as binary\");\n            }\n            final String str = getText();\n            if (str == null) {\n                return null;\n            }\n            ByteArrayBuilder builder = _byteBuilder;\n            if (builder == null) {\n                _byteBuilder = builder = new ByteArrayBuilder(100);\n            } else {\n                _byteBuilder.reset();\n            }\n            _decodeBase64(str, builder, b64variant);\n            return builder.toByteArray();\n        }\n\n        @Override\n        public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException {\n            byte[] data = getBinaryValue(b64variant);\n            if (data != null) {\n                out.write(data, 0, data.length);\n                return data.length;\n            }\n            return 0;\n        }\n\n        \n\n        @Override\n        public boolean canReadObjectId() {\n            return _hasNativeObjectIds;\n        }\n\n        @Override\n        public boolean canReadTypeId() {\n            return _hasNativeTypeIds;\n        }\n\n        @Override\n        public Object getTypeId() {\n            return _segment.findTypeId(_segmentPtr);\n        }\n\n        @Override\n        public Object getObjectId() {\n            return _segment.findObjectId(_segmentPtr);\n        }\n        \n        \n\n        protected final Object _currentObject() {\n            return _segment.get(_segmentPtr);\n        }\n\n        protected final void _checkIsNumber() throws JsonParseException {\n            if (_currToken == null || !_currToken.isNumeric()) {\n                throw _constructError(\"Current token (\"+_currToken+\") not numeric, can not use numeric value accessors\");\n            }\n        }\n\n        @Override\n        protected void _handleEOF() throws JsonParseException {\n            _throwInternal();\n        }\n    }\n    \n    \n    protected final static class Segment { public final static int TOKENS_PER_SEGMENT = 16; private final static JsonToken[] TOKEN_TYPES_BY_INDEX; static { TOKEN_TYPES_BY_INDEX = new JsonToken[16]; JsonToken[] t = JsonToken.values(); System.arraycopy(t, 1, TOKEN_TYPES_BY_INDEX, 1, Math.min(15, t.length - 1)); } protected Segment _next; protected long _tokenTypes; protected final Object[] _tokens = new Object[TOKENS_PER_SEGMENT]; protected TreeMap<Integer,Object> _nativeIds; public Segment() { }\n\n        \n\n        public JsonToken type(int index) {\n            long l = _tokenTypes;\n            if (index > 0) {\n                l >>= (index << 2);\n            }\n            int ix = ((int) l) & 0xF;\n            return TOKEN_TYPES_BY_INDEX[ix];\n        }\n\n        public int rawType(int index) {\n            long l = _tokenTypes;\n            if (index > 0) {\n                l >>= (index << 2);\n            }\n            int ix = ((int) l) & 0xF;\n            return ix;\n        }\n        \n        public Object get(int index) {\n            return _tokens[index];\n        }\n\n        public Segment next() { return _next; }\n\n        \n        public boolean hasIds() {\n            return _nativeIds != null;\n        }\n        \n        \n        \n        public Segment append(int index, JsonToken tokenType) {\n            if (index < TOKENS_PER_SEGMENT) {\n                set(index, tokenType);\n                return null;\n            }\n            _next = new Segment();\n            _next.set(0, tokenType);\n            return _next;\n        }\n\n        public Segment append(int index, JsonToken tokenType, Object objectId, Object typeId) {\n            if (index < TOKENS_PER_SEGMENT) {\n                set(index, tokenType, objectId, typeId);\n                return null;\n            }\n            _next = new Segment();\n            _next.set(0, tokenType, objectId, typeId);\n            return _next;\n        }\n\n        public Segment append(int index, JsonToken tokenType, Object value) {\n            if (index < TOKENS_PER_SEGMENT) {\n                set(index, tokenType, value);\n                return null;\n            }\n            _next = new Segment();\n            _next.set(0, tokenType, value);\n            return _next;\n        }\n\n        public Segment append(int index, JsonToken tokenType, Object value, Object objectId, Object typeId) {\n            if (index < TOKENS_PER_SEGMENT) {\n                set(index, tokenType, value, objectId, typeId);\n                return null;\n            }\n            _next = new Segment();\n            _next.set(0, tokenType, value, objectId, typeId);\n            return _next;\n        }\n\n        public Segment appendRaw(int index, int rawTokenType, Object value) {\n            if (index < TOKENS_PER_SEGMENT) {\n                set(index, rawTokenType, value);\n                return null;\n            }\n            _next = new Segment();\n            _next.set(0, rawTokenType, value);\n            return _next;\n        }\n\n        public Segment appendRaw(int index, int rawTokenType, Object value, Object objectId, Object typeId) {\n            if (index < TOKENS_PER_SEGMENT) {\n                set(index, rawTokenType, value, objectId, typeId);\n                return null;\n            }\n            _next = new Segment();\n            _next.set(0, rawTokenType, value, objectId, typeId);\n            return _next;\n        }\n\n        private void set(int index, JsonToken tokenType) {\n            \n            long typeCode = tokenType.ordinal();\n            if (index > 0) {\n                typeCode <<= (index << 2);\n            }\n            _tokenTypes |= typeCode;\n        }\n\n        private void set(int index, JsonToken tokenType, Object objectId, Object typeId) {\n            long typeCode = tokenType.ordinal();\n            if (index > 0) {\n                typeCode <<= (index << 2);\n            }\n            _tokenTypes |= typeCode;\n            assignNativeIds(index, objectId, typeId);\n        }\n\n        private void set(int index, JsonToken tokenType, Object value) {\n            _tokens[index] = value;\n            long typeCode = tokenType.ordinal();\n            if (index > 0) {\n                typeCode <<= (index << 2);\n            }\n            _tokenTypes |= typeCode;\n        }\n\n        private void set(int index, JsonToken tokenType, Object value, Object objectId, Object typeId) {\n            _tokens[index] = value;\n            long typeCode = tokenType.ordinal();\n            if (index > 0) {\n                typeCode <<= (index << 2);\n            }\n            _tokenTypes |= typeCode;\n            assignNativeIds(index, objectId, typeId);\n        }\n\n        private void set(int index, int rawTokenType, Object value) {\n            _tokens[index] = value;\n            long typeCode = (long) rawTokenType;\n            if (index > 0) {\n                typeCode <<= (index << 2);\n            }\n            _tokenTypes |= typeCode;\n        }\n\n        private void set(int index, int rawTokenType, Object value, Object objectId, Object typeId) {\n            _tokens[index] = value;\n            long typeCode = (long) rawTokenType;\n            if (index > 0) {\n                typeCode <<= (index << 2);\n            }\n            _tokenTypes |= typeCode;\n            assignNativeIds(index, objectId, typeId);\n        }\n\n        private final void assignNativeIds(int index, Object objectId, Object typeId) {\n            if (_nativeIds == null) {\n                _nativeIds = new TreeMap<Integer,Object>();\n            }\n            if (objectId != null) {\n                _nativeIds.put(_objectIdIndex(index), objectId);\n            }\n            if (typeId != null) {\n                _nativeIds.put(_typeIdIndex(index), typeId);\n            }\n        }\n\n        \n        public Object findObjectId(int index) {\n            return (_nativeIds == null) ? null : _nativeIds.get(_objectIdIndex(index));\n        }\n        \n        \n        public Object findTypeId(int index) {\n            return (_nativeIds == null) ? null : _nativeIds.get(_typeIdIndex(index));\n        }\n\n        private final int _typeIdIndex(int i) { return i+i; }\n        private final int _objectIdIndex(int i) { return i+i+1; }\n    }\n}\n",
      "fixed_full_code": "package com.fasterxml.jackson.databind.util;\n\nimport java.io.*;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.util.TreeMap;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.base.ParserMinimalBase;\nimport com.fasterxml.jackson.core.json.JsonReadContext;\nimport com.fasterxml.jackson.core.json.JsonWriteContext;\nimport com.fasterxml.jackson.core.util.ByteArrayBuilder;\nimport com.fasterxml.jackson.databind.*;\n\n\npublic class TokenBuffer extends JsonGenerator { protected final static int DEFAULT_GENERATOR_FEATURES = JsonGenerator.Feature.collectDefaults(); protected ObjectCodec _objectCodec; protected int _generatorFeatures; protected boolean _closed; protected boolean _hasNativeTypeIds; protected boolean _hasNativeObjectIds; protected boolean _mayHaveNativeIds; protected Segment _first; protected Segment _last; protected int _appendAt; protected Object _typeId; protected Object _objectId; protected boolean _hasNativeId = false; protected JsonWriteContext _writeContext; @Deprecated public TokenBuffer(ObjectCodec codec) {\n        this(codec, false);\n    }\n\n    \n    public TokenBuffer(ObjectCodec codec, boolean hasNativeIds) {\n        _objectCodec = codec;\n        _generatorFeatures = DEFAULT_GENERATOR_FEATURES;\n        _writeContext = JsonWriteContext.createRootContext(null);\n        \n        _first = _last = new Segment();\n        _appendAt = 0;\n        _hasNativeTypeIds = hasNativeIds;\n        _hasNativeObjectIds = hasNativeIds;\n\n        _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds;\n    }\n\n    \n    public TokenBuffer(JsonParser jp) {\n        _objectCodec = jp.getCodec();\n        _generatorFeatures = DEFAULT_GENERATOR_FEATURES;\n        _writeContext = JsonWriteContext.createRootContext(null);\n        \n        _first = _last = new Segment();\n        _appendAt = 0;\n        _hasNativeTypeIds = jp.canReadTypeId();\n        _hasNativeObjectIds = jp.canReadObjectId();\n        _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds;\n    }\n    \n    @Override\n    public Version version() {\n        return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION;\n    }\n\n    \n    public JsonParser asParser() {\n        return asParser(_objectCodec);\n    }\n\n    \n    public JsonParser asParser(ObjectCodec codec) {\n        return new Parser(_first, codec, _hasNativeTypeIds, _hasNativeObjectIds);\n    }\n\n    \n    public JsonParser asParser(JsonParser src) {\n        Parser p = new Parser(_first, src.getCodec(), _hasNativeTypeIds, _hasNativeObjectIds);\n        p.setLocation(src.getTokenLocation());\n        return p;\n    }\n    \n    \n\n    public JsonToken firstToken() {\n        if (_first != null) {\n            return _first.type(0);\n        }\n        return null;\n    }\n    \n    \n\n    \n    @SuppressWarnings(\"resource\")\n    public TokenBuffer append(TokenBuffer other) throws IOException, JsonGenerationException {\n        \n        if (!_hasNativeTypeIds) {  \n            _hasNativeTypeIds = other.canWriteTypeId();\n        }\n        if (!_hasNativeObjectIds) {\n            _hasNativeObjectIds = other.canWriteObjectId();\n        }\n        _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds;\n        \n        JsonParser jp = other.asParser();\n        while (jp.nextToken() != null) {\n            copyCurrentStructure(jp);\n        }\n        return this;\n    }\n    \n    \n    public void serialize(JsonGenerator jgen) throws IOException, JsonGenerationException {\n        Segment segment = _first;\n        int ptr = -1;\n\n        final boolean checkIds = _mayHaveNativeIds;\n        boolean hasIds = checkIds && (segment.hasIds());\n\n        while (true) {\n            if (++ptr >= Segment.TOKENS_PER_SEGMENT) {\n                ptr = 0;\n                segment = segment.next();\n                if (segment == null) break;\n                hasIds = checkIds && (segment.hasIds());\n            }\n            JsonToken t = segment.type(ptr);\n            if (t == null) break;\n\n            if (hasIds) {\n                Object id = segment.findObjectId(ptr);\n                if (id != null) {\n                    jgen.writeObjectId(id);\n                }\n                id = segment.findTypeId(ptr);\n                if (id != null) {\n                    jgen.writeTypeId(id);\n                }\n            }\n            \n            \n            switch (t) {\n            case START_OBJECT:\n                jgen.writeStartObject();\n                break;\n            case END_OBJECT:\n                jgen.writeEndObject();\n                break;\n            case START_ARRAY:\n                jgen.writeStartArray();\n                break;\n            case END_ARRAY:\n                jgen.writeEndArray();\n                break;\n            case FIELD_NAME:\n            {\n                \n                Object ob = segment.get(ptr);\n                if (ob instanceof SerializableString) {\n                    jgen.writeFieldName((SerializableString) ob);\n                } else {\n                    jgen.writeFieldName((String) ob);\n                }\n            }\n                break;\n            case VALUE_STRING:\n                {\n                    Object ob = segment.get(ptr);\n                    if (ob instanceof SerializableString) {\n                        jgen.writeString((SerializableString) ob);\n                    } else {\n                        jgen.writeString((String) ob);\n                    }\n                }\n                break;\n            case VALUE_NUMBER_INT:\n                {\n                    Object n = segment.get(ptr);\n                    if (n instanceof Integer) {\n                        jgen.writeNumber((Integer) n);\n                    } else if (n instanceof BigInteger) {\n                        jgen.writeNumber((BigInteger) n);\n                    } else if (n instanceof Long) {\n                        jgen.writeNumber((Long) n);\n                    } else if (n instanceof Short) {\n                        jgen.writeNumber((Short) n);\n                    } else {\n                        jgen.writeNumber(((Number) n).intValue());\n                    }\n                }\n                break;\n            case VALUE_NUMBER_FLOAT:\n                {\n                    Object n = segment.get(ptr);\n                    if (n instanceof Double) {\n                        jgen.writeNumber(((Double) n).doubleValue());\n                    } else if (n instanceof BigDecimal) {\n                        jgen.writeNumber((BigDecimal) n);\n                    } else if (n instanceof Float) {\n                        jgen.writeNumber(((Float) n).floatValue());\n                    } else if (n == null) {\n                        jgen.writeNull();\n                    } else if (n instanceof String) {\n                        jgen.writeNumber((String) n);\n                    } else {\n                        throw new JsonGenerationException(\"Unrecognized value type for VALUE_NUMBER_FLOAT: \"+n.getClass().getName()+\", can not serialize\");\n                    }\n                }\n                break;\n            case VALUE_TRUE:\n                jgen.writeBoolean(true);\n                break;\n            case VALUE_FALSE:\n                jgen.writeBoolean(false);\n                break;\n            case VALUE_NULL:\n                jgen.writeNull();\n                break;\n            case VALUE_EMBEDDED_OBJECT:\n                jgen.writeObject(segment.get(ptr));\n                break;\n            default:\n                throw new RuntimeException(\"Internal error: should never end up through this code path\");\n            }\n        }\n    }\n\n    \n    public TokenBuffer deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {\n        if (jp.getCurrentTokenId() != JsonToken.FIELD_NAME.id()) {\n            copyCurrentStructure(jp);\n            return this;\n        }\n        \n        JsonToken t;\n        writeStartObject();\n        do {\n            copyCurrentStructure(jp);\n        } while ((t = jp.nextToken()) == JsonToken.FIELD_NAME);\n        if (t != JsonToken.END_OBJECT) {\n            throw ctxt.mappingException(\"Expected END_OBJECT after copying contents of a JsonParser into TokenBuffer, got \"+t);\n        }\n        writeEndObject();\n        return this;\n    }\n    \n    @Override\n    @SuppressWarnings(\"resource\")\n    public String toString() {\n        \n        final int MAX_COUNT = 100;\n\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"[TokenBuffer: \");\n\n        \n        \n        JsonParser jp = asParser();\n        int count = 0;\n        final boolean hasNativeIds = _hasNativeTypeIds || _hasNativeObjectIds;\n\n        while (true) {\n            JsonToken t;\n            try {\n                t = jp.nextToken();\n                if (t == null) break;\n\n                if (hasNativeIds) {\n                    _appendNativeIds(sb);\n                }\n                        \n                if (count < MAX_COUNT) {\n                    if (count > 0) {\n                        sb.append(\", \");\n                    }\n                    sb.append(t.toString());\n                    if (t == JsonToken.FIELD_NAME) {\n                        sb.append('(');\n                        sb.append(jp.getCurrentName());\n                        sb.append(')');\n                    }\n                }\n            } catch (IOException ioe) { \n                throw new IllegalStateException(ioe);\n            }\n            ++count;\n        }\n\n        if (count >= MAX_COUNT) {\n            sb.append(\" ... (truncated \").append(count-MAX_COUNT).append(\" entries)\");\n        }\n        sb.append(']');\n        return sb.toString();\n    }\n\n    private final void _appendNativeIds(StringBuilder sb) {\n        Object objectId = _last.findObjectId(_appendAt-1);\n        if (objectId != null) {\n            sb.append(\"[objectId=\").append(String.valueOf(objectId)).append(']');\n        }\n        Object typeId = _last.findTypeId(_appendAt-1);\n        if (typeId != null) {\n            sb.append(\"[typeId=\").append(String.valueOf(typeId)).append(']');\n        }\n    }\n    \n    \n\n    @Override\n    public JsonGenerator enable(Feature f) {\n        _generatorFeatures |= f.getMask();\n        return this;\n    }\n\n    @Override\n    public JsonGenerator disable(Feature f) {\n        _generatorFeatures &= ~f.getMask();\n        return this;\n    }\n\n    \n\n    @Override\n    public boolean isEnabled(Feature f) {\n        return (_generatorFeatures & f.getMask()) != 0;\n    }\n\n    @Override\n    public int getFeatureMask() {\n        return _generatorFeatures;\n    }\n\n    @Override\n    public JsonGenerator setFeatureMask(int mask) {\n        _generatorFeatures = mask;\n        return this;\n    }\n    \n    @Override\n    public JsonGenerator useDefaultPrettyPrinter() {\n        \n        return this;\n    }\n\n    @Override\n    public JsonGenerator setCodec(ObjectCodec oc) {\n        _objectCodec = oc;\n        return this;\n    }\n\n    @Override\n    public ObjectCodec getCodec() { return _objectCodec; }\n\n    @Override\n    public final JsonWriteContext getOutputContext() { return _writeContext; }\n\n    \n    \n    \n    @Override\n    public boolean canWriteBinaryNatively() {\n        return true;\n    }\n    \n    \n\n    @Override\n    public void flush() throws IOException {  }\n\n    @Override\n    public void close() throws IOException {\n        _closed = true;\n    }\n\n    @Override\n    public boolean isClosed() { return _closed; }\n\n    \n\n    @Override\n    public final void writeStartArray() throws IOException, JsonGenerationException {\n        _append(JsonToken.START_ARRAY);\n        _writeContext = _writeContext.createChildArrayContext();\n    }\n\n    @Override\n    public final void writeEndArray() throws IOException, JsonGenerationException {\n        _append(JsonToken.END_ARRAY);\n        \n        JsonWriteContext c = _writeContext.getParent();\n        if (c != null) {\n            _writeContext = c;\n        }\n    }\n\n    @Override\n    public final void writeStartObject() throws IOException, JsonGenerationException {\n        _append(JsonToken.START_OBJECT);\n        _writeContext = _writeContext.createChildObjectContext();\n    }\n\n    @Override\n    public final void writeEndObject() throws IOException, JsonGenerationException {\n        _append(JsonToken.END_OBJECT);\n        \n        JsonWriteContext c = _writeContext.getParent();\n        if (c != null) {\n            _writeContext = c;\n        }\n    }\n\n    @Override\n    public final void writeFieldName(String name) throws IOException, JsonGenerationException {\n        _append(JsonToken.FIELD_NAME, name);\n        _writeContext.writeFieldName(name);\n    }\n\n    @Override\n    public void writeFieldName(SerializableString name) throws IOException, JsonGenerationException {\n        _append(JsonToken.FIELD_NAME, name);\n        _writeContext.writeFieldName(name.getValue());\n    }\n    \n    \n\n    @Override\n    public void writeString(String text) throws IOException,JsonGenerationException {\n        if (text == null) {\n            writeNull();\n        } else {\n            _append(JsonToken.VALUE_STRING, text);\n        }\n    }\n\n    @Override\n    public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException {\n        writeString(new String(text, offset, len));\n    }\n\n    @Override\n    public void writeString(SerializableString text) throws IOException, JsonGenerationException {\n        if (text == null) {\n            writeNull();\n        } else {\n            _append(JsonToken.VALUE_STRING, text);\n        }\n    }\n    \n    @Override\n    public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException {\n        \n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException {\n        \n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeRaw(String text) throws IOException, JsonGenerationException {\n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException {\n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeRaw(SerializableString text) throws IOException, JsonGenerationException {\n        _reportUnsupportedOperation();\n    }\n    \n    @Override\n    public void writeRaw(char[] text, int offset, int len) throws IOException, JsonGenerationException {\n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeRaw(char c) throws IOException, JsonGenerationException {\n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeRawValue(String text) throws IOException, JsonGenerationException {\n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeRawValue(String text, int offset, int len) throws IOException, JsonGenerationException {\n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeRawValue(char[] text, int offset, int len) throws IOException, JsonGenerationException {\n        _reportUnsupportedOperation();\n    }\n\n    \n\n    @Override\n    public void writeNumber(short i) throws IOException, JsonGenerationException {\n        _append(JsonToken.VALUE_NUMBER_INT, Short.valueOf(i));\n    }\n\n    @Override\n    public void writeNumber(int i) throws IOException, JsonGenerationException {\n        _append(JsonToken.VALUE_NUMBER_INT, Integer.valueOf(i));\n    }\n\n    @Override\n    public void writeNumber(long l) throws IOException, JsonGenerationException {\n        _append(JsonToken.VALUE_NUMBER_INT, Long.valueOf(l));\n    }\n\n    @Override\n    public void writeNumber(double d) throws IOException,JsonGenerationException {\n        _append(JsonToken.VALUE_NUMBER_FLOAT, Double.valueOf(d));\n    }\n\n    @Override\n    public void writeNumber(float f) throws IOException, JsonGenerationException {\n        _append(JsonToken.VALUE_NUMBER_FLOAT, Float.valueOf(f));\n    }\n\n    @Override\n    public void writeNumber(BigDecimal dec) throws IOException,JsonGenerationException {\n        if (dec == null) {\n            writeNull();\n        } else {\n            _append(JsonToken.VALUE_NUMBER_FLOAT, dec);\n        }\n    }\n\n    @Override\n    public void writeNumber(BigInteger v) throws IOException, JsonGenerationException {\n        if (v == null) {\n            writeNull();\n        } else {\n            _append(JsonToken.VALUE_NUMBER_INT, v);\n        }\n    }\n\n    @Override\n    public void writeNumber(String encodedValue) throws IOException, JsonGenerationException {\n        \n        _append(JsonToken.VALUE_NUMBER_FLOAT, encodedValue);\n    }\n\n    @Override\n    public void writeBoolean(boolean state) throws IOException,JsonGenerationException {\n        _append(state ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE);\n    }\n\n    @Override\n    public void writeNull() throws IOException, JsonGenerationException {\n        _append(JsonToken.VALUE_NULL);\n    }\n\n    \n\n    @Override\n    public void writeObject(Object value) throws IOException {\n        if (value == null) {\n            writeNull();\n            return;\n        }\n        Class<?> raw = value.getClass();\n        if (raw == byte[].class) {\n            _append(JsonToken.VALUE_EMBEDDED_OBJECT, value);\n            return;\n        } else if (_objectCodec == null) {\n            \n\n            _append(JsonToken.VALUE_EMBEDDED_OBJECT, value);\n        } else {\n            _objectCodec.writeValue(this, value);\n        }\n    }\n\n    @Override\n    public void writeTree(TreeNode node) throws IOException {\n        if (node == null) {\n            writeNull();\n            return;\n        }\n\n        if (_objectCodec == null) {\n            \n            _append(JsonToken.VALUE_EMBEDDED_OBJECT, node);\n        } else {\n            _objectCodec.writeTree(this, node);\n        }\n    }\n\n    \n\n    @Override\n    public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException {\n        \n        byte[] copy = new byte[len];\n        System.arraycopy(data, offset, copy, 0, len);\n        writeObject(copy);\n    }\n\n    \n    @Override\n    public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) {\n        throw new UnsupportedOperationException();\n    }\n\n    \n\n    @Override\n    public boolean canWriteTypeId() {\n        return _hasNativeTypeIds;\n    }\n\n    @Override\n    public boolean canWriteObjectId() {\n        return _hasNativeObjectIds;\n    }\n    \n    @Override\n    public void writeTypeId(Object id) {\n        _typeId = id;\n        _hasNativeId = true;\n    }\n    \n    @Override\n    public void writeObjectId(Object id) {\n        _objectId = id;\n        _hasNativeId = true;\n    }\n\n    \n\n    @Override\n    public void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException {\n        if (_mayHaveNativeIds) {\n            _checkNativeIds(jp);\n        }\n        switch (jp.getCurrentToken()) {\n        case START_OBJECT:\n            writeStartObject();\n            break;\n        case END_OBJECT:\n            writeEndObject();\n            break;\n        case START_ARRAY:\n            writeStartArray();\n            break;\n        case END_ARRAY:\n            writeEndArray();\n            break;\n        case FIELD_NAME:\n            writeFieldName(jp.getCurrentName());\n            break;\n        case VALUE_STRING:\n            if (jp.hasTextCharacters()) {\n                writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength());\n            } else {\n                writeString(jp.getText());\n            }\n            break;\n        case VALUE_NUMBER_INT:\n            switch (jp.getNumberType()) {\n            case INT:\n                writeNumber(jp.getIntValue());\n                break;\n            case BIG_INTEGER:\n                writeNumber(jp.getBigIntegerValue());\n                break;\n            default:\n                writeNumber(jp.getLongValue());\n            }\n            break;\n        case VALUE_NUMBER_FLOAT:\n            switch (jp.getNumberType()) {\n            case BIG_DECIMAL:\n                writeNumber(jp.getDecimalValue());\n                break;\n            case FLOAT:\n                writeNumber(jp.getFloatValue());\n                break;\n            default:\n                writeNumber(jp.getDoubleValue());\n            }\n            break;\n        case VALUE_TRUE:\n            writeBoolean(true);\n            break;\n        case VALUE_FALSE:\n            writeBoolean(false);\n            break;\n        case VALUE_NULL:\n            writeNull();\n            break;\n        case VALUE_EMBEDDED_OBJECT:\n            writeObject(jp.getEmbeddedObject());\n            break;\n        default:\n            throw new RuntimeException(\"Internal error: should never end up through this code path\");\n        }\n    }\n    \n    @Override\n    public void copyCurrentStructure(JsonParser jp) throws IOException, JsonProcessingException {\n        JsonToken t = jp.getCurrentToken();\n\n        \n        if (t == JsonToken.FIELD_NAME) {\n            if (_mayHaveNativeIds) {\n                _checkNativeIds(jp);\n            }\n            writeFieldName(jp.getCurrentName());\n            t = jp.nextToken();\n            \n        }\n\n        if (_mayHaveNativeIds) {\n            _checkNativeIds(jp);\n        }\n        \n        switch (t) {\n        case START_ARRAY:\n            writeStartArray();\n            while (jp.nextToken() != JsonToken.END_ARRAY) {\n                copyCurrentStructure(jp);\n            }\n            writeEndArray();\n            break;\n        case START_OBJECT:\n            writeStartObject();\n            while (jp.nextToken() != JsonToken.END_OBJECT) {\n                copyCurrentStructure(jp);\n            }\n            writeEndObject();\n            break;\n        default: \n            copyCurrentEvent(jp);\n        }\n    }\n\n    \n    private final void _checkNativeIds(JsonParser jp) throws IOException, JsonProcessingException {\n        if ((_typeId = jp.getTypeId()) != null) {\n            _hasNativeId = true;\n        }\n        if ((_objectId = jp.getObjectId()) != null) {\n            _hasNativeId = true;\n        }\n    }\n    \n    \n\n    protected final void _append(JsonToken type) {\n        Segment next = _hasNativeId\n                ? _last.append(_appendAt, type, _objectId, _typeId)\n                : _last.append(_appendAt, type);\n        if (next == null) {\n            ++_appendAt;\n        } else {\n            _last = next;\n            _appendAt = 1; \n        }\n    }\n\n    protected final void _append(JsonToken type, Object value) {\n        Segment next = _hasNativeId\n                ? _last.append(_appendAt, type, value, _objectId, _typeId)\n                : _last.append(_appendAt, type, value);\n        if (next == null) {\n            ++_appendAt;\n        } else {\n            _last = next;\n            _appendAt = 1;\n        }\n    }\n\n    protected final void _appendRaw(int rawType, Object value) {\n        Segment next = _hasNativeId\n                ? _last.appendRaw(_appendAt, rawType, value, _objectId, _typeId)\n                : _last.appendRaw(_appendAt, rawType, value);\n        if (next == null) {\n            ++_appendAt;\n        } else {\n            _last = next;\n            _appendAt = 1;\n        }\n    }\n\n    @Override\n    protected void _reportUnsupportedOperation() {\n        throw new UnsupportedOperationException(\"Called operation not supported for TokenBuffer\");\n    }\n    \n    \n\n    protected final static class Parser extends ParserMinimalBase { protected ObjectCodec _codec; protected final boolean _hasNativeTypeIds; protected final boolean _hasNativeObjectIds; protected final boolean _hasNativeIds; protected Segment _segment; protected int _segmentPtr; protected JsonReadContext _parsingContext; protected boolean _closed; protected transient ByteArrayBuilder _byteBuilder; protected JsonLocation _location = null; @Deprecated protected Parser(Segment firstSeg, ObjectCodec codec) {\n            this(firstSeg, codec, false, false);\n        }\n\n        \n        public Parser(Segment firstSeg, ObjectCodec codec, boolean hasNativeTypeIds, boolean hasNativeObjectIds) {\n            super(0);\n            _segment = firstSeg;\n            _segmentPtr = -1; \n            _codec = codec;\n            _parsingContext = JsonReadContext.createRootContext(null);\n            _hasNativeTypeIds = hasNativeTypeIds;\n            _hasNativeObjectIds = hasNativeObjectIds;\n            _hasNativeIds = (hasNativeTypeIds | hasNativeObjectIds);\n        }\n\n        public void setLocation(JsonLocation l) {\n            _location = l;\n        }\n        \n        @Override\n        public ObjectCodec getCodec() { return _codec; }\n\n        @Override\n        public void setCodec(ObjectCodec c) { _codec = c; }\n\n        @Override\n        public Version version() {\n            return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION;\n        }\n\n        \n        \n        public JsonToken peekNextToken() throws IOException, JsonParseException {\n            \n            if (_closed) return null;\n            Segment seg = _segment;\n            int ptr = _segmentPtr+1;\n            if (ptr >= Segment.TOKENS_PER_SEGMENT) {\n                ptr = 0;\n                seg = (seg == null) ? null : seg.next();\n            }\n            return (seg == null) ? null : seg.type(ptr);\n        }\n        \n        \n\n        @Override\n        public void close() throws IOException {\n            if (!_closed) {\n                _closed = true;\n            }\n        }\n\n        \n        \n        @Override\n        public JsonToken nextToken() throws IOException, JsonParseException {\n            \n            if (_closed || (_segment == null)) return null;\n\n            \n            if (++_segmentPtr >= Segment.TOKENS_PER_SEGMENT) {\n                _segmentPtr = 0;\n                _segment = _segment.next();\n                if (_segment == null) {\n                    return null;\n                }\n            }\n            _currToken = _segment.type(_segmentPtr);\n            \n            if (_currToken == JsonToken.FIELD_NAME) {\n                Object ob = _currentObject();\n                String name = (ob instanceof String) ? ((String) ob) : ob.toString();\n                _parsingContext.setCurrentName(name);\n            } else if (_currToken == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n            } else if (_currToken == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(-1, -1);\n            } else if (_currToken == JsonToken.END_OBJECT\n                    || _currToken == JsonToken.END_ARRAY) {\n                \n                _parsingContext = _parsingContext.getParent();\n                \n                if (_parsingContext == null) {\n                    _parsingContext = JsonReadContext.createRootContext(null);\n                }\n            }\n            return _currToken;\n        }\n\n        @Override\n        public boolean isClosed() { return _closed; }\n\n        \n        \n        @Override\n        public JsonStreamContext getParsingContext() { return _parsingContext; }\n\n        @Override\n        public JsonLocation getTokenLocation() { return getCurrentLocation(); }\n\n        @Override\n        public JsonLocation getCurrentLocation() {\n            return (_location == null) ? JsonLocation.NA : _location;\n        }\n\n        @Override\n        public String getCurrentName() { return _parsingContext.getCurrentName(); }\n\n        @Override\n        public void overrideCurrentName(String name) {\n            \n            JsonReadContext ctxt = _parsingContext;\n            if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\n                ctxt = ctxt.getParent();\n            }\n            try {\n                ctxt.setCurrentName(name);\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        \n        \n        \n        @Override\n        public String getText() {\n            \n            if (_currToken == JsonToken.VALUE_STRING\n                    || _currToken == JsonToken.FIELD_NAME) {\n                Object ob = _currentObject();\n                if (ob instanceof String) {\n                    return (String) ob;\n                }\n                return (ob == null) ? null : ob.toString();\n            }\n            if (_currToken == null) {\n                return null;\n            }\n            switch (_currToken) {\n            case VALUE_NUMBER_INT:\n            case VALUE_NUMBER_FLOAT:\n                Object ob = _currentObject();\n                return (ob == null) ? null : ob.toString();\n            default:\n            \treturn _currToken.asString();\n            }\n        }\n\n        @Override\n        public char[] getTextCharacters() {\n            String str = getText();\n            return (str == null) ? null : str.toCharArray();\n        }\n\n        @Override\n        public int getTextLength() {\n            String str = getText();\n            return (str == null) ? 0 : str.length();\n        }\n\n        @Override\n        public int getTextOffset() { return 0; }\n\n        @Override\n        public boolean hasTextCharacters() {\n            \n            return false;\n        }\n        \n        \n\n        @Override\n        public BigInteger getBigIntegerValue() throws IOException, JsonParseException {\n            Number n = getNumberValue();\n            if (n instanceof BigInteger) {\n                return (BigInteger) n;\n            }\n            if (getNumberType() == NumberType.BIG_DECIMAL) {\n                return ((BigDecimal) n).toBigInteger();\n            }\n            \n            return BigInteger.valueOf(n.longValue());\n        }\n\n        @Override\n        public BigDecimal getDecimalValue() throws IOException, JsonParseException {\n            Number n = getNumberValue();\n            if (n instanceof BigDecimal) {\n                return (BigDecimal) n;\n            }\n            switch (getNumberType()) {\n            case INT:\n            case LONG:\n                return BigDecimal.valueOf(n.longValue());\n            case BIG_INTEGER:\n                return new BigDecimal((BigInteger) n);\n            default:\n            }\n            \n            return BigDecimal.valueOf(n.doubleValue());\n        }\n\n        @Override\n        public double getDoubleValue() throws IOException, JsonParseException {\n            return getNumberValue().doubleValue();\n        }\n\n        @Override\n        public float getFloatValue() throws IOException, JsonParseException {\n            return getNumberValue().floatValue();\n        }\n\n        @Override\n        public int getIntValue() throws IOException, JsonParseException {\n            \n            if (_currToken == JsonToken.VALUE_NUMBER_INT) {\n                return ((Number) _currentObject()).intValue();\n            }\n            return getNumberValue().intValue();\n        }\n\n        @Override\n        public long getLongValue() throws IOException, JsonParseException {\n            return getNumberValue().longValue();\n        }\n\n        @Override\n        public NumberType getNumberType() throws IOException, JsonParseException {\n            Number n = getNumberValue();\n            if (n instanceof Integer) return NumberType.INT;\n            if (n instanceof Long) return NumberType.LONG;\n            if (n instanceof Double) return NumberType.DOUBLE;\n            if (n instanceof BigDecimal) return NumberType.BIG_DECIMAL;\n            if (n instanceof BigInteger) return NumberType.BIG_INTEGER;\n            if (n instanceof Float) return NumberType.FLOAT;\n            if (n instanceof Short) return NumberType.INT;       \n            return null;\n        }\n\n        @Override\n        public final Number getNumberValue() throws IOException, JsonParseException {\n            _checkIsNumber();\n            Object value = _currentObject();\n            if (value instanceof Number) {\n                return (Number) value;\n            }\n            \n            \n            \n            if (value instanceof String) {\n                String str = (String) value;\n                if (str.indexOf('.') >= 0) {\n                    return Double.parseDouble(str);\n                }\n                return Long.parseLong(str);\n            }\n            if (value == null) {\n                return null;\n            }\n            throw new IllegalStateException(\"Internal error: entry should be a Number, but is of type \"\n                    +value.getClass().getName());\n        }\n\n        \n\n        @Override\n        public Object getEmbeddedObject() {\n            if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) {\n                return _currentObject();\n            }\n            return null;\n        }\n\n        @Override\n        @SuppressWarnings(\"resource\")\n        public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException {\n            \n            if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) {\n                \n                Object ob = _currentObject();\n                if (ob instanceof byte[]) {\n                    return (byte[]) ob;\n                }\n                \n            }\n            if (_currToken != JsonToken.VALUE_STRING) {\n                throw _constructError(\"Current token (\"+_currToken+\") not VALUE_STRING (or VALUE_EMBEDDED_OBJECT with byte[]), can not access as binary\");\n            }\n            final String str = getText();\n            if (str == null) {\n                return null;\n            }\n            ByteArrayBuilder builder = _byteBuilder;\n            if (builder == null) {\n                _byteBuilder = builder = new ByteArrayBuilder(100);\n            } else {\n                _byteBuilder.reset();\n            }\n            _decodeBase64(str, builder, b64variant);\n            return builder.toByteArray();\n        }\n\n        @Override\n        public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException {\n            byte[] data = getBinaryValue(b64variant);\n            if (data != null) {\n                out.write(data, 0, data.length);\n                return data.length;\n            }\n            return 0;\n        }\n\n        \n\n        @Override\n        public boolean canReadObjectId() {\n            return _hasNativeObjectIds;\n        }\n\n        @Override\n        public boolean canReadTypeId() {\n            return _hasNativeTypeIds;\n        }\n\n        @Override\n        public Object getTypeId() {\n            return _segment.findTypeId(_segmentPtr);\n        }\n\n        @Override\n        public Object getObjectId() {\n            return _segment.findObjectId(_segmentPtr);\n        }\n        \n        \n\n        protected final Object _currentObject() {\n            return _segment.get(_segmentPtr);\n        }\n\n        protected final void _checkIsNumber() throws JsonParseException {\n            if (_currToken == null || !_currToken.isNumeric()) {\n                throw _constructError(\"Current token (\"+_currToken+\") not numeric, can not use numeric value accessors\");\n            }\n        }\n\n        @Override\n        protected void _handleEOF() throws JsonParseException {\n            _throwInternal();\n        }\n    }\n    \n    \n    protected final static class Segment { public final static int TOKENS_PER_SEGMENT = 16; private final static JsonToken[] TOKEN_TYPES_BY_INDEX; static { TOKEN_TYPES_BY_INDEX = new JsonToken[16]; JsonToken[] t = JsonToken.values(); System.arraycopy(t, 1, TOKEN_TYPES_BY_INDEX, 1, Math.min(15, t.length - 1)); } protected Segment _next; protected long _tokenTypes; protected final Object[] _tokens = new Object[TOKENS_PER_SEGMENT]; protected TreeMap<Integer,Object> _nativeIds; public Segment() { }\n\n        \n\n        public JsonToken type(int index) {\n            long l = _tokenTypes;\n            if (index > 0) {\n                l >>= (index << 2);\n            }\n            int ix = ((int) l) & 0xF;\n            return TOKEN_TYPES_BY_INDEX[ix];\n        }\n\n        public int rawType(int index) {\n            long l = _tokenTypes;\n            if (index > 0) {\n                l >>= (index << 2);\n            }\n            int ix = ((int) l) & 0xF;\n            return ix;\n        }\n        \n        public Object get(int index) {\n            return _tokens[index];\n        }\n\n        public Segment next() { return _next; }\n\n        \n        public boolean hasIds() {\n            return _nativeIds != null;\n        }\n        \n        \n        \n        public Segment append(int index, JsonToken tokenType) {\n            if (index < TOKENS_PER_SEGMENT) {\n                set(index, tokenType);\n                return null;\n            }\n            _next = new Segment();\n            _next.set(0, tokenType);\n            return _next;\n        }\n\n        public Segment append(int index, JsonToken tokenType, Object objectId, Object typeId) {\n            if (index < TOKENS_PER_SEGMENT) {\n                set(index, tokenType, objectId, typeId);\n                return null;\n            }\n            _next = new Segment();\n            _next.set(0, tokenType, objectId, typeId);\n            return _next;\n        }\n\n        public Segment append(int index, JsonToken tokenType, Object value) {\n            if (index < TOKENS_PER_SEGMENT) {\n                set(index, tokenType, value);\n                return null;\n            }\n            _next = new Segment();\n            _next.set(0, tokenType, value);\n            return _next;\n        }\n\n        public Segment append(int index, JsonToken tokenType, Object value, Object objectId, Object typeId) {\n            if (index < TOKENS_PER_SEGMENT) {\n                set(index, tokenType, value, objectId, typeId);\n                return null;\n            }\n            _next = new Segment();\n            _next.set(0, tokenType, value, objectId, typeId);\n            return _next;\n        }\n\n        public Segment appendRaw(int index, int rawTokenType, Object value) {\n            if (index < TOKENS_PER_SEGMENT) {\n                set(index, rawTokenType, value);\n                return null;\n            }\n            _next = new Segment();\n            _next.set(0, rawTokenType, value);\n            return _next;\n        }\n\n        public Segment appendRaw(int index, int rawTokenType, Object value, Object objectId, Object typeId) {\n            if (index < TOKENS_PER_SEGMENT) {\n                set(index, rawTokenType, value, objectId, typeId);\n                return null;\n            }\n            _next = new Segment();\n            _next.set(0, rawTokenType, value, objectId, typeId);\n            return _next;\n        }\n\n        private void set(int index, JsonToken tokenType) {\n            \n            long typeCode = tokenType.ordinal();\n            if (index > 0) {\n                typeCode <<= (index << 2);\n            }\n            _tokenTypes |= typeCode;\n        }\n\n        private void set(int index, JsonToken tokenType, Object objectId, Object typeId) {\n            long typeCode = tokenType.ordinal();\n            if (index > 0) {\n                typeCode <<= (index << 2);\n            }\n            _tokenTypes |= typeCode;\n            assignNativeIds(index, objectId, typeId);\n        }\n\n        private void set(int index, JsonToken tokenType, Object value) {\n            _tokens[index] = value;\n            long typeCode = tokenType.ordinal();\n            if (index > 0) {\n                typeCode <<= (index << 2);\n            }\n            _tokenTypes |= typeCode;\n        }\n\n        private void set(int index, JsonToken tokenType, Object value, Object objectId, Object typeId) {\n            _tokens[index] = value;\n            long typeCode = tokenType.ordinal();\n            if (index > 0) {\n                typeCode <<= (index << 2);\n            }\n            _tokenTypes |= typeCode;\n            assignNativeIds(index, objectId, typeId);\n        }\n\n        private void set(int index, int rawTokenType, Object value) {\n            _tokens[index] = value;\n            long typeCode = (long) rawTokenType;\n            if (index > 0) {\n                typeCode <<= (index << 2);\n            }\n            _tokenTypes |= typeCode;\n        }\n\n        private void set(int index, int rawTokenType, Object value, Object objectId, Object typeId) {\n            _tokens[index] = value;\n            long typeCode = (long) rawTokenType;\n            if (index > 0) {\n                typeCode <<= (index << 2);\n            }\n            _tokenTypes |= typeCode;\n            assignNativeIds(index, objectId, typeId);\n        }\n\n        private final void assignNativeIds(int index, Object objectId, Object typeId) {\n            if (_nativeIds == null) {\n                _nativeIds = new TreeMap<Integer,Object>();\n            }\n            if (objectId != null) {\n                _nativeIds.put(_objectIdIndex(index), objectId);\n            }\n            if (typeId != null) {\n                _nativeIds.put(_typeIdIndex(index), typeId);\n            }\n        }\n\n        \n        public Object findObjectId(int index) {\n            return (_nativeIds == null) ? null : _nativeIds.get(_objectIdIndex(index));\n        }\n        \n        \n        public Object findTypeId(int index) {\n            return (_nativeIds == null) ? null : _nativeIds.get(_typeIdIndex(index));\n        }\n\n        private final int _typeIdIndex(int i) { return i+i; }\n        private final int _objectIdIndex(int i) { return i+i+1; }\n    }\n}\n",
      "buggy_signatures": [
        "public TokenBuffer(ObjectCodec codec, boolean hasNativeIds)",
        "public TokenBuffer(JsonParser jp)",
        "public Version version()",
        "public JsonParser asParser()",
        "public JsonParser asParser(ObjectCodec codec)",
        "public JsonParser asParser(JsonParser src)",
        "public JsonToken firstToken()",
        "public TokenBuffer append(TokenBuffer other) throws IOException, JsonGenerationException",
        "public void serialize(JsonGenerator jgen) throws IOException, JsonGenerationException",
        "public TokenBuffer deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException",
        "public String toString()",
        "private final void _appendNativeIds(StringBuilder sb)",
        "public JsonGenerator enable(Feature f)",
        "public JsonGenerator disable(Feature f)",
        "public boolean isEnabled(Feature f)",
        "public int getFeatureMask()",
        "public JsonGenerator setFeatureMask(int mask)",
        "public JsonGenerator useDefaultPrettyPrinter()",
        "public JsonGenerator setCodec(ObjectCodec oc)",
        "public ObjectCodec getCodec()",
        "public final JsonWriteContext getOutputContext()",
        "public boolean canWriteBinaryNatively()",
        "public void flush() throws IOException",
        "public void close() throws IOException",
        "public boolean isClosed()",
        "public final void writeStartArray() throws IOException, JsonGenerationException",
        "public final void writeEndArray() throws IOException, JsonGenerationException",
        "public final void writeStartObject() throws IOException, JsonGenerationException",
        "public final void writeEndObject() throws IOException, JsonGenerationException",
        "public final void writeFieldName(String name) throws IOException, JsonGenerationException",
        "public void writeFieldName(SerializableString name) throws IOException, JsonGenerationException",
        "public void writeString(String text) throws IOException,JsonGenerationException",
        "public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException",
        "public void writeString(SerializableString text) throws IOException, JsonGenerationException",
        "public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException",
        "public void writeUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException",
        "public void writeRaw(String text) throws IOException, JsonGenerationException",
        "public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException",
        "public void writeRaw(SerializableString text) throws IOException, JsonGenerationException",
        "public void writeRaw(char[] text, int offset, int len) throws IOException, JsonGenerationException",
        "public void writeRaw(char c) throws IOException, JsonGenerationException",
        "public void writeRawValue(String text) throws IOException, JsonGenerationException",
        "public void writeRawValue(String text, int offset, int len) throws IOException, JsonGenerationException",
        "public void writeRawValue(char[] text, int offset, int len) throws IOException, JsonGenerationException",
        "public void writeNumber(short i) throws IOException, JsonGenerationException",
        "public void writeNumber(int i) throws IOException, JsonGenerationException",
        "public void writeNumber(long l) throws IOException, JsonGenerationException",
        "public void writeNumber(double d) throws IOException,JsonGenerationException",
        "public void writeNumber(float f) throws IOException, JsonGenerationException",
        "public void writeNumber(BigDecimal dec) throws IOException,JsonGenerationException",
        "public void writeNumber(BigInteger v) throws IOException, JsonGenerationException",
        "public void writeNumber(String encodedValue) throws IOException, JsonGenerationException",
        "public void writeBoolean(boolean state) throws IOException,JsonGenerationException",
        "public void writeNull() throws IOException, JsonGenerationException",
        "public void writeObject(Object value) throws IOException",
        "public void writeTree(TreeNode node) throws IOException",
        "public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException",
        "public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength)",
        "public boolean canWriteTypeId()",
        "public boolean canWriteObjectId()",
        "public void writeTypeId(Object id)",
        "public void writeObjectId(Object id)",
        "public void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException",
        "public void copyCurrentStructure(JsonParser jp) throws IOException, JsonProcessingException",
        "private final void _checkNativeIds(JsonParser jp) throws IOException, JsonProcessingException",
        "protected final void _append(JsonToken type)",
        "protected final void _append(JsonToken type, Object value)",
        "protected final void _appendRaw(int rawType, Object value)",
        "protected void _reportUnsupportedOperation()",
        "public Parser(Segment firstSeg, ObjectCodec codec, boolean hasNativeTypeIds, boolean hasNativeObjectIds)",
        "public void setLocation(JsonLocation l)",
        "public ObjectCodec getCodec()",
        "public void setCodec(ObjectCodec c)",
        "public Version version()",
        "public JsonToken peekNextToken() throws IOException, JsonParseException",
        "public void close() throws IOException",
        "public JsonToken nextToken() throws IOException, JsonParseException",
        "public boolean isClosed()",
        "public JsonStreamContext getParsingContext()",
        "public JsonLocation getTokenLocation()",
        "public JsonLocation getCurrentLocation()",
        "public String getCurrentName()",
        "public void overrideCurrentName(String name)",
        "public String getText()",
        "public char[] getTextCharacters()",
        "public int getTextLength()",
        "public int getTextOffset()",
        "public boolean hasTextCharacters()",
        "public BigInteger getBigIntegerValue() throws IOException, JsonParseException",
        "public BigDecimal getDecimalValue() throws IOException, JsonParseException",
        "public double getDoubleValue() throws IOException, JsonParseException",
        "public float getFloatValue() throws IOException, JsonParseException",
        "public int getIntValue() throws IOException, JsonParseException",
        "public long getLongValue() throws IOException, JsonParseException",
        "public NumberType getNumberType() throws IOException, JsonParseException",
        "public final Number getNumberValue() throws IOException, JsonParseException",
        "public Object getEmbeddedObject()",
        "public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException",
        "public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException",
        "public boolean canReadObjectId()",
        "public boolean canReadTypeId()",
        "public Object getTypeId()",
        "public Object getObjectId()",
        "protected final Object _currentObject()",
        "protected final void _checkIsNumber() throws JsonParseException",
        "protected void _handleEOF() throws JsonParseException",
        "public JsonToken type(int index)",
        "public int rawType(int index)",
        "public Object get(int index)",
        "public Segment next()",
        "public boolean hasIds()",
        "public Segment append(int index, JsonToken tokenType)",
        "public Segment append(int index, JsonToken tokenType, Object objectId, Object typeId)",
        "public Segment append(int index, JsonToken tokenType, Object value)",
        "public Segment append(int index, JsonToken tokenType, Object value, Object objectId, Object typeId)",
        "public Segment appendRaw(int index, int rawTokenType, Object value)",
        "public Segment appendRaw(int index, int rawTokenType, Object value, Object objectId, Object typeId)",
        "private void set(int index, JsonToken tokenType)",
        "private void set(int index, JsonToken tokenType, Object objectId, Object typeId)",
        "private void set(int index, JsonToken tokenType, Object value)",
        "private void set(int index, JsonToken tokenType, Object value, Object objectId, Object typeId)",
        "private void set(int index, int rawTokenType, Object value)",
        "private void set(int index, int rawTokenType, Object value, Object objectId, Object typeId)",
        "private final void assignNativeIds(int index, Object objectId, Object typeId)",
        "public Object findObjectId(int index)",
        "public Object findTypeId(int index)",
        "private final int _typeIdIndex(int i)",
        "private final int _objectIdIndex(int i)"
      ],
      "fixed_signatures": [
        "public TokenBuffer(ObjectCodec codec, boolean hasNativeIds)",
        "public TokenBuffer(JsonParser jp)",
        "public Version version()",
        "public JsonParser asParser()",
        "public JsonParser asParser(ObjectCodec codec)",
        "public JsonParser asParser(JsonParser src)",
        "public JsonToken firstToken()",
        "public TokenBuffer append(TokenBuffer other) throws IOException, JsonGenerationException",
        "public void serialize(JsonGenerator jgen) throws IOException, JsonGenerationException",
        "public TokenBuffer deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException",
        "public String toString()",
        "private final void _appendNativeIds(StringBuilder sb)",
        "public JsonGenerator enable(Feature f)",
        "public JsonGenerator disable(Feature f)",
        "public boolean isEnabled(Feature f)",
        "public int getFeatureMask()",
        "public JsonGenerator setFeatureMask(int mask)",
        "public JsonGenerator useDefaultPrettyPrinter()",
        "public JsonGenerator setCodec(ObjectCodec oc)",
        "public ObjectCodec getCodec()",
        "public final JsonWriteContext getOutputContext()",
        "public boolean canWriteBinaryNatively()",
        "public void flush() throws IOException",
        "public void close() throws IOException",
        "public boolean isClosed()",
        "public final void writeStartArray() throws IOException, JsonGenerationException",
        "public final void writeEndArray() throws IOException, JsonGenerationException",
        "public final void writeStartObject() throws IOException, JsonGenerationException",
        "public final void writeEndObject() throws IOException, JsonGenerationException",
        "public final void writeFieldName(String name) throws IOException, JsonGenerationException",
        "public void writeFieldName(SerializableString name) throws IOException, JsonGenerationException",
        "public void writeString(String text) throws IOException,JsonGenerationException",
        "public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException",
        "public void writeString(SerializableString text) throws IOException, JsonGenerationException",
        "public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException",
        "public void writeUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException",
        "public void writeRaw(String text) throws IOException, JsonGenerationException",
        "public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException",
        "public void writeRaw(SerializableString text) throws IOException, JsonGenerationException",
        "public void writeRaw(char[] text, int offset, int len) throws IOException, JsonGenerationException",
        "public void writeRaw(char c) throws IOException, JsonGenerationException",
        "public void writeRawValue(String text) throws IOException, JsonGenerationException",
        "public void writeRawValue(String text, int offset, int len) throws IOException, JsonGenerationException",
        "public void writeRawValue(char[] text, int offset, int len) throws IOException, JsonGenerationException",
        "public void writeNumber(short i) throws IOException, JsonGenerationException",
        "public void writeNumber(int i) throws IOException, JsonGenerationException",
        "public void writeNumber(long l) throws IOException, JsonGenerationException",
        "public void writeNumber(double d) throws IOException,JsonGenerationException",
        "public void writeNumber(float f) throws IOException, JsonGenerationException",
        "public void writeNumber(BigDecimal dec) throws IOException,JsonGenerationException",
        "public void writeNumber(BigInteger v) throws IOException, JsonGenerationException",
        "public void writeNumber(String encodedValue) throws IOException, JsonGenerationException",
        "public void writeBoolean(boolean state) throws IOException,JsonGenerationException",
        "public void writeNull() throws IOException, JsonGenerationException",
        "public void writeObject(Object value) throws IOException",
        "public void writeTree(TreeNode node) throws IOException",
        "public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException",
        "public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength)",
        "public boolean canWriteTypeId()",
        "public boolean canWriteObjectId()",
        "public void writeTypeId(Object id)",
        "public void writeObjectId(Object id)",
        "public void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException",
        "public void copyCurrentStructure(JsonParser jp) throws IOException, JsonProcessingException",
        "private final void _checkNativeIds(JsonParser jp) throws IOException, JsonProcessingException",
        "protected final void _append(JsonToken type)",
        "protected final void _append(JsonToken type, Object value)",
        "protected final void _appendRaw(int rawType, Object value)",
        "protected void _reportUnsupportedOperation()",
        "public Parser(Segment firstSeg, ObjectCodec codec, boolean hasNativeTypeIds, boolean hasNativeObjectIds)",
        "public void setLocation(JsonLocation l)",
        "public ObjectCodec getCodec()",
        "public void setCodec(ObjectCodec c)",
        "public Version version()",
        "public JsonToken peekNextToken() throws IOException, JsonParseException",
        "public void close() throws IOException",
        "public JsonToken nextToken() throws IOException, JsonParseException",
        "public boolean isClosed()",
        "public JsonStreamContext getParsingContext()",
        "public JsonLocation getTokenLocation()",
        "public JsonLocation getCurrentLocation()",
        "public String getCurrentName()",
        "public void overrideCurrentName(String name)",
        "public String getText()",
        "public char[] getTextCharacters()",
        "public int getTextLength()",
        "public int getTextOffset()",
        "public boolean hasTextCharacters()",
        "public BigInteger getBigIntegerValue() throws IOException, JsonParseException",
        "public BigDecimal getDecimalValue() throws IOException, JsonParseException",
        "public double getDoubleValue() throws IOException, JsonParseException",
        "public float getFloatValue() throws IOException, JsonParseException",
        "public int getIntValue() throws IOException, JsonParseException",
        "public long getLongValue() throws IOException, JsonParseException",
        "public NumberType getNumberType() throws IOException, JsonParseException",
        "public final Number getNumberValue() throws IOException, JsonParseException",
        "public Object getEmbeddedObject()",
        "public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException",
        "public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException",
        "public boolean canReadObjectId()",
        "public boolean canReadTypeId()",
        "public Object getTypeId()",
        "public Object getObjectId()",
        "protected final Object _currentObject()",
        "protected final void _checkIsNumber() throws JsonParseException",
        "protected void _handleEOF() throws JsonParseException",
        "public JsonToken type(int index)",
        "public int rawType(int index)",
        "public Object get(int index)",
        "public Segment next()",
        "public boolean hasIds()",
        "public Segment append(int index, JsonToken tokenType)",
        "public Segment append(int index, JsonToken tokenType, Object objectId, Object typeId)",
        "public Segment append(int index, JsonToken tokenType, Object value)",
        "public Segment append(int index, JsonToken tokenType, Object value, Object objectId, Object typeId)",
        "public Segment appendRaw(int index, int rawTokenType, Object value)",
        "public Segment appendRaw(int index, int rawTokenType, Object value, Object objectId, Object typeId)",
        "private void set(int index, JsonToken tokenType)",
        "private void set(int index, JsonToken tokenType, Object objectId, Object typeId)",
        "private void set(int index, JsonToken tokenType, Object value)",
        "private void set(int index, JsonToken tokenType, Object value, Object objectId, Object typeId)",
        "private void set(int index, int rawTokenType, Object value)",
        "private void set(int index, int rawTokenType, Object value, Object objectId, Object typeId)",
        "private final void assignNativeIds(int index, Object objectId, Object typeId)",
        "public Object findObjectId(int index)",
        "public Object findTypeId(int index)",
        "private final int _typeIdIndex(int i)",
        "private final int _objectIdIndex(int i)"
      ],
      "methods": [
        {
          "buggy_method": "  public TokenBuffer deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {\n  copyCurrentStructure(jp);\n  \n  return this;\n  }",
          "fixed_method": "  public TokenBuffer deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {\n  if (jp.getCurrentTokenId() != JsonToken.FIELD_NAME.id()) {\n  copyCurrentStructure(jp);\n  return this;\n  }\n  \n  JsonToken t;\n  writeStartObject();\n  do {\n  copyCurrentStructure(jp);\n  } while ((t = jp.nextToken()) == JsonToken.FIELD_NAME);\n  if (t != JsonToken.END_OBJECT) {\n  throw ctxt.mappingException(\"Expected END_OBJECT after copying contents of a JsonParser into TokenBuffer, got \"+t);\n  }\n  writeEndObject();\n  return this;\n  }",
          "diff": [
            "@@ -402,11 +402,23 @@",
            "      */\n",
            "     public TokenBuffer deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException\n",
            "     {\n",
            "+        if (jp.getCurrentTokenId() != JsonToken.FIELD_NAME.id()) {\n",
            "             copyCurrentStructure(jp);\n",
            "+            return this;\n",
            "+        }\n",
            "         /* 28-Oct-2014, tatu: As per #592, need to support a special case of starting from\n",
            "          *    FIELD_NAME, which is taken to mean that we are missing START_OBJECT, but need\n",
            "          *    to assume one did exist.\n",
            "          */\n",
            "+        JsonToken t;\n",
            "+        writeStartObject();\n",
            "+        do {\n",
            "+            copyCurrentStructure(jp);\n",
            "+        } while ((t = jp.nextToken()) == JsonToken.FIELD_NAME);\n",
            "+        if (t != JsonToken.END_OBJECT) {\n",
            "+            throw ctxt.mappingException(\"Expected END_OBJECT after copying contents of a JsonParser into TokenBuffer, got \"+t);\n",
            "+        }\n",
            "+        writeEndObject();\n",
            "         return this;\n",
            "     }\n",
            "     \n"
          ],
          "changed_lines": 12
        }
      ]
    }
  ]
}
