{
  "bug_id": "106",
  "failed_tests": {
    "com.fasterxml.jackson.databind.node.TestTreeTraversingParser": [
      {
        "methodName": "testNumberOverflowLong",
        "error": "junit.framework.AssertionFailedError",
        "message": "Expected failure for `long` overflow",
        "fail_line": "                fail(\"Expected failure for `long` overflow\");",
        "test_source": "  public void testNumberOverflowLong() throws IOException {\n  final BigInteger tooBig = BigInteger.valueOf(Long.MAX_VALUE).add(BigInteger.ONE);\n  try (final JsonParser p = MAPPER.readTree(\"[ \"+tooBig+\" ]\").traverse()) {\n  assertToken(JsonToken.START_ARRAY, p.nextToken());\n  assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());\n  assertEquals(NumberType.BIG_INTEGER, p.getNumberType());\n  try {\n  p.getLongValue();\n  fail(\"Expected failure for `long` overflow\");\n  } catch (InputCoercionException e) {\n  verifyException(e, \"Numeric value (\"+tooBig+\") out of range of long\");\n  }\n  }\n  try (final JsonParser p = MAPPER.readTree(\"{ \\\"value\\\" : \"+tooBig+\" }\").traverse()) {\n  assertToken(JsonToken.START_OBJECT, p.nextToken());\n  assertToken(JsonToken.FIELD_NAME, p.nextToken());\n  assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());\n  assertEquals(NumberType.BIG_INTEGER, p.getNumberType());\n  try {\n  p.getLongValue();\n  fail(\"Expected failure for `long` overflow\");\n  } catch (InputCoercionException e) {\n  verifyException(e, \"Numeric value (\"+tooBig+\") out of range of long\");\n  }\n  }\n  // But also from floating-point\n  final String tooBig2 = \"1.0e30\";\n  try (final JsonParser p = MAPPER.readTree(\"[ \"+tooBig2+\" ]\").traverse()) {\n  assertToken(JsonToken.START_ARRAY, p.nextToken());\n  assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());\n  assertEquals(NumberType.DOUBLE, p.getNumberType());\n  try {\n  p.getLongValue();\n  fail(\"Expected failure for `long` overflow\");\n  } catch (InputCoercionException e) {\n  verifyException(e, \"Numeric value (\"+tooBig2+\") out of range of long\");\n  }\n  }\n  }",
        "stack": [
          "TestTreeTraversingParser.testNumberOverflowLong line 323"
        ]
      },
      {
        "methodName": "testNumberOverflowInt",
        "error": "junit.framework.AssertionFailedError",
        "message": "Expected failure for `int` overflow",
        "fail_line": "                fail(\"Expected failure for `int` overflow\");",
        "test_source": "  public void testNumberOverflowInt() throws IOException {\n  final long tooBig = 1L + Integer.MAX_VALUE;\n  try (final JsonParser p = MAPPER.readTree(\"[ \"+tooBig+\" ]\").traverse()) {\n  assertToken(JsonToken.START_ARRAY, p.nextToken());\n  assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());\n  assertEquals(NumberType.LONG, p.getNumberType());\n  try {\n  p.getIntValue();\n  fail(\"Expected failure for `int` overflow\");\n  } catch (InputCoercionException e) {\n  verifyException(e, \"Numeric value (\"+tooBig+\") out of range of int\");\n  }\n  }\n  try (final JsonParser p = MAPPER.readTree(\"{ \\\"value\\\" : \"+tooBig+\" }\").traverse()) {\n  assertToken(JsonToken.START_OBJECT, p.nextToken());\n  assertToken(JsonToken.FIELD_NAME, p.nextToken());\n  assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());\n  assertEquals(NumberType.LONG, p.getNumberType());\n  try {\n  p.getIntValue();\n  fail(\"Expected failure for `int` overflow\");\n  } catch (InputCoercionException e) {\n  verifyException(e, \"Numeric value (\"+tooBig+\") out of range of int\");\n  }\n  }\n  // But also from floating-point\n  final String tooBig2 = \"1.0e10\";\n  try (final JsonParser p = MAPPER.readTree(\"[ \"+tooBig2+\" ]\").traverse()) {\n  assertToken(JsonToken.START_ARRAY, p.nextToken());\n  assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());\n  assertEquals(NumberType.DOUBLE, p.getNumberType());\n  try {\n  p.getIntValue();\n  fail(\"Expected failure for `int` overflow\");\n  } catch (InputCoercionException e) {\n  verifyException(e, \"Numeric value (\"+tooBig2+\") out of range of int\");\n  }\n  }\n  }",
        "stack": [
          "TestTreeTraversingParser.testNumberOverflowInt line 282"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "com/fasterxml/jackson/databind/node/TreeTraversingParser.java",
      "buggy_full_code": "package com.fasterxml.jackson.databind.node;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.base.ParserMinimalBase;\n\nimport com.fasterxml.jackson.databind.JsonNode;\n\n\npublic class TreeTraversingParser extends ParserMinimalBase { protected ObjectCodec _objectCodec; protected NodeCursor _nodeCursor; protected JsonToken _nextToken; protected boolean _startContainer; protected boolean _closed; public TreeTraversingParser(JsonNode n) { this(n, null); }\n\n    public TreeTraversingParser(JsonNode n, ObjectCodec codec) {\n        super(0);\n        _objectCodec = codec;\n        if (n.isArray()) {\n            _nextToken = JsonToken.START_ARRAY;\n            _nodeCursor = new NodeCursor.ArrayCursor(n, null);\n        } else if (n.isObject()) {\n            _nextToken = JsonToken.START_OBJECT;\n            _nodeCursor = new NodeCursor.ObjectCursor(n, null);\n        } else { \n            _nodeCursor = new NodeCursor.RootCursor(n, null);\n        }\n    }\n\n    @Override\n    public void setCodec(ObjectCodec c) {\n        _objectCodec = c;\n    }\n\n    @Override\n    public ObjectCodec getCodec() {\n        return _objectCodec;\n    }\n\n    @Override\n    public Version version() {\n        return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION;\n    }\n    \n    \n\n    @Override\n    public void close() throws IOException {\n        if (!_closed) {\n            _closed = true;\n            _nodeCursor = null;\n            _currToken = null;\n        }\n    }\n\n    \n\n    @Override\n    public JsonToken nextToken() throws IOException, JsonParseException {\n        if (_nextToken != null) {\n            _currToken = _nextToken;\n            _nextToken = null;\n            return _currToken;\n        }\n        \n        if (_startContainer) {\n            _startContainer = false;\n            \n            if (!_nodeCursor.currentHasChildren()) {\n                _currToken = (_currToken == JsonToken.START_OBJECT) ?\n                    JsonToken.END_OBJECT : JsonToken.END_ARRAY;\n                return _currToken;\n            }\n            _nodeCursor = _nodeCursor.iterateChildren();\n            _currToken = _nodeCursor.nextToken();\n            if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\n                _startContainer = true;\n            }\n            return _currToken;\n        }\n        \n        if (_nodeCursor == null) {\n            _closed = true; \n            return null;\n        }\n        \n        _currToken = _nodeCursor.nextToken();\n        if (_currToken != null) {\n            if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\n                _startContainer = true;\n            }\n            return _currToken;\n        }\n        \n        _currToken = _nodeCursor.endToken();\n        _nodeCursor = _nodeCursor.getParent();\n        return _currToken;\n    }\n    \n    \n    \n\n    @Override\n    public JsonParser skipChildren() throws IOException, JsonParseException {\n        if (_currToken == JsonToken.START_OBJECT) {\n            _startContainer = false;\n            _currToken = JsonToken.END_OBJECT;\n        } else if (_currToken == JsonToken.START_ARRAY) {\n            _startContainer = false;\n            _currToken = JsonToken.END_ARRAY;\n        }\n        return this;\n    }\n\n    @Override\n    public boolean isClosed() {\n        return _closed;\n    }\n\n    \n\n    @Override\n    public String getCurrentName() {\n        return (_nodeCursor == null) ? null : _nodeCursor.getCurrentName();\n    }\n\n    @Override\n    public void overrideCurrentName(String name) {\n        if (_nodeCursor != null) {\n            _nodeCursor.overrideCurrentName(name);\n        }\n    }\n    \n    @Override\n    public JsonStreamContext getParsingContext() {\n        return _nodeCursor;\n    }\n\n    @Override\n    public JsonLocation getTokenLocation() {\n        return JsonLocation.NA;\n    }\n\n    @Override\n    public JsonLocation getCurrentLocation() {\n        return JsonLocation.NA;\n    }\n\n    \n\n    @Override\n    public String getText() {\n        if (_closed) {\n            return null;\n        }\n        \n        switch (_currToken) {\n        case FIELD_NAME:\n            return _nodeCursor.getCurrentName();\n        case VALUE_STRING:\n            return currentNode().textValue();\n        case VALUE_NUMBER_INT:\n        case VALUE_NUMBER_FLOAT:\n            return String.valueOf(currentNode().numberValue());\n        case VALUE_EMBEDDED_OBJECT:\n            JsonNode n = currentNode();\n            if (n != null && n.isBinary()) {\n                \n                return n.asText();\n            }\n        default:\n        \treturn (_currToken == null) ? null : _currToken.asString();\n        }\n    }\n\n    @Override\n    public char[] getTextCharacters() throws IOException, JsonParseException {\n        return getText().toCharArray();\n    }\n\n    @Override\n    public int getTextLength() throws IOException, JsonParseException {\n        return getText().length();\n    }\n\n    @Override\n    public int getTextOffset() throws IOException, JsonParseException {\n        return 0;\n    }\n\n    @Override\n    public boolean hasTextCharacters() {\n        \n        return false;\n    }\n    \n    \n\n    \n\n    @Override\n    public NumberType getNumberType() throws IOException {\n        JsonNode n = currentNumericNode();\n        return (n == null) ? null : n.numberType();\n    }\n\n    @Override\n    public BigInteger getBigIntegerValue() throws IOException {\n        return currentNumericNode().bigIntegerValue();\n    }\n\n    @Override\n    public BigDecimal getDecimalValue() throws IOException {\n        return currentNumericNode().decimalValue();\n    }\n\n    @Override\n    public double getDoubleValue() throws IOException {\n        return currentNumericNode().doubleValue();\n    }\n\n    @Override\n    public float getFloatValue() throws IOException {\n        return (float) currentNumericNode().doubleValue();\n    }\n\n    @Override\n    public int getIntValue() throws IOException {\n        final NumericNode node = (NumericNode) currentNumericNode();\n        return node.intValue();\n    }\n\n    @Override\n    public long getLongValue() throws IOException {\n        final NumericNode node = (NumericNode) currentNumericNode();\n        return node.longValue();\n    }\n\n    @Override\n    public Number getNumberValue() throws IOException {\n        return currentNumericNode().numberValue();\n    }\n\n    @Override\n    public Object getEmbeddedObject() {\n        if (!_closed) {\n            JsonNode n = currentNode();\n            if (n != null) {\n                if (n.isPojo()) {\n                    return ((POJONode) n).getPojo();\n                }\n                if (n.isBinary()) {\n                    return ((BinaryNode) n).binaryValue();\n                }\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public boolean isNaN() {\n        if (!_closed) {\n            JsonNode n = currentNode();\n            if (n instanceof NumericNode) {\n                return ((NumericNode) n).isNaN();\n            }\n        }\n        return false;\n    }\n\n    \n\n    @Override\n    public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException {\n        \n        JsonNode n = currentNode();\n        if (n != null) {\n            \n            \n            if (n instanceof TextNode) {\n                return ((TextNode) n).getBinaryValue(b64variant);\n            }\n            return n.binaryValue();\n        }\n        \n        return null;\n    }\n\n\n    @Override\n    public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException {\n        byte[] data = getBinaryValue(b64variant);\n        if (data != null) {\n            out.write(data, 0, data.length);\n            return data.length;\n        }\n        return 0;\n    }\n\n    \n\n    protected JsonNode currentNode() {\n        if (_closed || _nodeCursor == null) {\n            return null;\n        }\n        return _nodeCursor.currentNode();\n    }\n\n    protected JsonNode currentNumericNode() throws JsonParseException {\n        JsonNode n = currentNode();\n        if (n == null || !n.isNumber()) {\n            JsonToken t = (n == null) ? null : n.asToken();\n            throw _constructError(\"Current token (\"+t+\") not numeric, cannot use numeric value accessors\");\n        }\n        return n;\n    }\n\n    @Override\n    protected void _handleEOF() throws JsonParseException {\n        _throwInternal(); \n    }\n}\n",
      "fixed_full_code": "package com.fasterxml.jackson.databind.node;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.base.ParserMinimalBase;\n\nimport com.fasterxml.jackson.databind.JsonNode;\n\n\npublic class TreeTraversingParser extends ParserMinimalBase { protected ObjectCodec _objectCodec; protected NodeCursor _nodeCursor; protected JsonToken _nextToken; protected boolean _startContainer; protected boolean _closed; public TreeTraversingParser(JsonNode n) { this(n, null); }\n\n    public TreeTraversingParser(JsonNode n, ObjectCodec codec) {\n        super(0);\n        _objectCodec = codec;\n        if (n.isArray()) {\n            _nextToken = JsonToken.START_ARRAY;\n            _nodeCursor = new NodeCursor.ArrayCursor(n, null);\n        } else if (n.isObject()) {\n            _nextToken = JsonToken.START_OBJECT;\n            _nodeCursor = new NodeCursor.ObjectCursor(n, null);\n        } else { \n            _nodeCursor = new NodeCursor.RootCursor(n, null);\n        }\n    }\n\n    @Override\n    public void setCodec(ObjectCodec c) {\n        _objectCodec = c;\n    }\n\n    @Override\n    public ObjectCodec getCodec() {\n        return _objectCodec;\n    }\n\n    @Override\n    public Version version() {\n        return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION;\n    }\n    \n    \n\n    @Override\n    public void close() throws IOException {\n        if (!_closed) {\n            _closed = true;\n            _nodeCursor = null;\n            _currToken = null;\n        }\n    }\n\n    \n\n    @Override\n    public JsonToken nextToken() throws IOException, JsonParseException {\n        if (_nextToken != null) {\n            _currToken = _nextToken;\n            _nextToken = null;\n            return _currToken;\n        }\n        \n        if (_startContainer) {\n            _startContainer = false;\n            \n            if (!_nodeCursor.currentHasChildren()) {\n                _currToken = (_currToken == JsonToken.START_OBJECT) ?\n                    JsonToken.END_OBJECT : JsonToken.END_ARRAY;\n                return _currToken;\n            }\n            _nodeCursor = _nodeCursor.iterateChildren();\n            _currToken = _nodeCursor.nextToken();\n            if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\n                _startContainer = true;\n            }\n            return _currToken;\n        }\n        \n        if (_nodeCursor == null) {\n            _closed = true; \n            return null;\n        }\n        \n        _currToken = _nodeCursor.nextToken();\n        if (_currToken != null) {\n            if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\n                _startContainer = true;\n            }\n            return _currToken;\n        }\n        \n        _currToken = _nodeCursor.endToken();\n        _nodeCursor = _nodeCursor.getParent();\n        return _currToken;\n    }\n    \n    \n    \n\n    @Override\n    public JsonParser skipChildren() throws IOException, JsonParseException {\n        if (_currToken == JsonToken.START_OBJECT) {\n            _startContainer = false;\n            _currToken = JsonToken.END_OBJECT;\n        } else if (_currToken == JsonToken.START_ARRAY) {\n            _startContainer = false;\n            _currToken = JsonToken.END_ARRAY;\n        }\n        return this;\n    }\n\n    @Override\n    public boolean isClosed() {\n        return _closed;\n    }\n\n    \n\n    @Override\n    public String getCurrentName() {\n        return (_nodeCursor == null) ? null : _nodeCursor.getCurrentName();\n    }\n\n    @Override\n    public void overrideCurrentName(String name) {\n        if (_nodeCursor != null) {\n            _nodeCursor.overrideCurrentName(name);\n        }\n    }\n    \n    @Override\n    public JsonStreamContext getParsingContext() {\n        return _nodeCursor;\n    }\n\n    @Override\n    public JsonLocation getTokenLocation() {\n        return JsonLocation.NA;\n    }\n\n    @Override\n    public JsonLocation getCurrentLocation() {\n        return JsonLocation.NA;\n    }\n\n    \n\n    @Override\n    public String getText() {\n        if (_closed) {\n            return null;\n        }\n        \n        switch (_currToken) {\n        case FIELD_NAME:\n            return _nodeCursor.getCurrentName();\n        case VALUE_STRING:\n            return currentNode().textValue();\n        case VALUE_NUMBER_INT:\n        case VALUE_NUMBER_FLOAT:\n            return String.valueOf(currentNode().numberValue());\n        case VALUE_EMBEDDED_OBJECT:\n            JsonNode n = currentNode();\n            if (n != null && n.isBinary()) {\n                \n                return n.asText();\n            }\n        default:\n        \treturn (_currToken == null) ? null : _currToken.asString();\n        }\n    }\n\n    @Override\n    public char[] getTextCharacters() throws IOException, JsonParseException {\n        return getText().toCharArray();\n    }\n\n    @Override\n    public int getTextLength() throws IOException, JsonParseException {\n        return getText().length();\n    }\n\n    @Override\n    public int getTextOffset() throws IOException, JsonParseException {\n        return 0;\n    }\n\n    @Override\n    public boolean hasTextCharacters() {\n        \n        return false;\n    }\n    \n    \n\n    \n\n    @Override\n    public NumberType getNumberType() throws IOException {\n        JsonNode n = currentNumericNode();\n        return (n == null) ? null : n.numberType();\n    }\n\n    @Override\n    public BigInteger getBigIntegerValue() throws IOException {\n        return currentNumericNode().bigIntegerValue();\n    }\n\n    @Override\n    public BigDecimal getDecimalValue() throws IOException {\n        return currentNumericNode().decimalValue();\n    }\n\n    @Override\n    public double getDoubleValue() throws IOException {\n        return currentNumericNode().doubleValue();\n    }\n\n    @Override\n    public float getFloatValue() throws IOException {\n        return (float) currentNumericNode().doubleValue();\n    }\n\n    @Override\n    public int getIntValue() throws IOException {\n        final NumericNode node = (NumericNode) currentNumericNode();\n        if (!node.canConvertToInt()) {\n            reportOverflowInt();\n        }\n        return node.intValue();\n    }\n\n    @Override\n    public long getLongValue() throws IOException {\n        final NumericNode node = (NumericNode) currentNumericNode();\n        if (!node.canConvertToInt()) {\n            reportOverflowLong();\n        }\n        return node.longValue();\n    }\n\n    @Override\n    public Number getNumberValue() throws IOException {\n        return currentNumericNode().numberValue();\n    }\n\n    @Override\n    public Object getEmbeddedObject() {\n        if (!_closed) {\n            JsonNode n = currentNode();\n            if (n != null) {\n                if (n.isPojo()) {\n                    return ((POJONode) n).getPojo();\n                }\n                if (n.isBinary()) {\n                    return ((BinaryNode) n).binaryValue();\n                }\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public boolean isNaN() {\n        if (!_closed) {\n            JsonNode n = currentNode();\n            if (n instanceof NumericNode) {\n                return ((NumericNode) n).isNaN();\n            }\n        }\n        return false;\n    }\n\n    \n\n    @Override\n    public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException {\n        \n        JsonNode n = currentNode();\n        if (n != null) {\n            \n            \n            if (n instanceof TextNode) {\n                return ((TextNode) n).getBinaryValue(b64variant);\n            }\n            return n.binaryValue();\n        }\n        \n        return null;\n    }\n\n\n    @Override\n    public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException {\n        byte[] data = getBinaryValue(b64variant);\n        if (data != null) {\n            out.write(data, 0, data.length);\n            return data.length;\n        }\n        return 0;\n    }\n\n    \n\n    protected JsonNode currentNode() {\n        if (_closed || _nodeCursor == null) {\n            return null;\n        }\n        return _nodeCursor.currentNode();\n    }\n\n    protected JsonNode currentNumericNode() throws JsonParseException {\n        JsonNode n = currentNode();\n        if (n == null || !n.isNumber()) {\n            JsonToken t = (n == null) ? null : n.asToken();\n            throw _constructError(\"Current token (\"+t+\") not numeric, cannot use numeric value accessors\");\n        }\n        return n;\n    }\n\n    @Override\n    protected void _handleEOF() throws JsonParseException {\n        _throwInternal(); \n    }\n}\n",
      "buggy_signatures": [
        "public class TreeTraversingParser extends ParserMinimalBase { protected ObjectCodec _objectCodec; protected NodeCursor _nodeCursor; protected JsonToken _nextToken; protected boolean _startContainer; protected boolean _closed; public TreeTraversingParser(JsonNode n)",
        "public TreeTraversingParser(JsonNode n, ObjectCodec codec)",
        "public void setCodec(ObjectCodec c)",
        "public ObjectCodec getCodec()",
        "public Version version()",
        "public void close() throws IOException",
        "public JsonToken nextToken() throws IOException, JsonParseException",
        "public JsonParser skipChildren() throws IOException, JsonParseException",
        "public boolean isClosed()",
        "public String getCurrentName()",
        "public void overrideCurrentName(String name)",
        "public JsonStreamContext getParsingContext()",
        "public JsonLocation getTokenLocation()",
        "public JsonLocation getCurrentLocation()",
        "public String getText()",
        "public char[] getTextCharacters() throws IOException, JsonParseException",
        "public int getTextLength() throws IOException, JsonParseException",
        "public int getTextOffset() throws IOException, JsonParseException",
        "public boolean hasTextCharacters()",
        "public NumberType getNumberType() throws IOException",
        "public BigInteger getBigIntegerValue() throws IOException",
        "public BigDecimal getDecimalValue() throws IOException",
        "public double getDoubleValue() throws IOException",
        "public float getFloatValue() throws IOException",
        "public int getIntValue() throws IOException",
        "public long getLongValue() throws IOException",
        "public Number getNumberValue() throws IOException",
        "public Object getEmbeddedObject()",
        "public boolean isNaN()",
        "public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException",
        "public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException",
        "protected JsonNode currentNode()",
        "protected JsonNode currentNumericNode() throws JsonParseException",
        "protected void _handleEOF() throws JsonParseException"
      ],
      "fixed_signatures": [
        "public class TreeTraversingParser extends ParserMinimalBase { protected ObjectCodec _objectCodec; protected NodeCursor _nodeCursor; protected JsonToken _nextToken; protected boolean _startContainer; protected boolean _closed; public TreeTraversingParser(JsonNode n)",
        "public TreeTraversingParser(JsonNode n, ObjectCodec codec)",
        "public void setCodec(ObjectCodec c)",
        "public ObjectCodec getCodec()",
        "public Version version()",
        "public void close() throws IOException",
        "public JsonToken nextToken() throws IOException, JsonParseException",
        "public JsonParser skipChildren() throws IOException, JsonParseException",
        "public boolean isClosed()",
        "public String getCurrentName()",
        "public void overrideCurrentName(String name)",
        "public JsonStreamContext getParsingContext()",
        "public JsonLocation getTokenLocation()",
        "public JsonLocation getCurrentLocation()",
        "public String getText()",
        "public char[] getTextCharacters() throws IOException, JsonParseException",
        "public int getTextLength() throws IOException, JsonParseException",
        "public int getTextOffset() throws IOException, JsonParseException",
        "public boolean hasTextCharacters()",
        "public NumberType getNumberType() throws IOException",
        "public BigInteger getBigIntegerValue() throws IOException",
        "public BigDecimal getDecimalValue() throws IOException",
        "public double getDoubleValue() throws IOException",
        "public float getFloatValue() throws IOException",
        "public int getIntValue() throws IOException",
        "public long getLongValue() throws IOException",
        "public Number getNumberValue() throws IOException",
        "public Object getEmbeddedObject()",
        "public boolean isNaN()",
        "public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException",
        "public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException",
        "protected JsonNode currentNode()",
        "protected JsonNode currentNumericNode() throws JsonParseException",
        "protected void _handleEOF() throws JsonParseException"
      ],
      "methods": [
        {
          "buggy_method": "  public long getLongValue() throws IOException {\n  final NumericNode node = (NumericNode) currentNumericNode();\n  return node.longValue();\n  }",
          "fixed_method": "  public long getLongValue() throws IOException {\n  final NumericNode node = (NumericNode) currentNumericNode();\n  if (!node.canConvertToInt()) {\n  reportOverflowLong();\n  }\n  return node.longValue();\n  }",
          "diff": [
            "@@ -305,12 +305,18 @@",
            "     @Override\n",
            "     public int getIntValue() throws IOException {\n",
            "         final NumericNode node = (NumericNode) currentNumericNode();\n",
            "+        if (!node.canConvertToInt()) {\n",
            "+            reportOverflowInt();\n",
            "+        }\n",
            "         return node.intValue();\n",
            "     }\n",
            " \n",
            "     @Override\n",
            "     public long getLongValue() throws IOException {\n",
            "         final NumericNode node = (NumericNode) currentNumericNode();\n",
            "+        if (!node.canConvertToInt()) {\n",
            "+            reportOverflowLong();\n",
            "+        }\n",
            "         return node.longValue();\n",
            "     }\n",
            " \n"
          ],
          "changed_lines": 6
        }
      ]
    }
  ]
}
