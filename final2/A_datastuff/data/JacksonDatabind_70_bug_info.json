{
  "bug_id": "70",
  "failed_tests": {
    "com.fasterxml.jackson.databind.struct.TestUnwrapped": [
      {
        "methodName": "testCaseInsensitiveUnwrap",
        "error": "java.util.NoSuchElementException",
        "message": "No entry 'businessAddress' found, can't remove",
        "fail_line": "        Person p = mapper.readValue(\"{ }\", Person.class);",
        "test_source": "  public void testCaseInsensitiveUnwrap() throws Exception {\n  ObjectMapper mapper = new ObjectMapper();\n  mapper.enable(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES);\n  Person p = mapper.readValue(\"{ }\", Person.class);\n  assertNotNull(p);\n  }",
        "stack": [
          "BeanPropertyMap.remove line 450, BeanDeserializerBase.resolve line 534, DeserializerCache._createAndCache2 line 293, DeserializerCache._createAndCacheValueDeserializer line 244, DeserializerCache.findValueDeserializer line 142, DeserializationContext.findRootValueDeserializer line 476, ObjectMapper._findRootDeserializer line 3899, ObjectMapper._readMapAndClose line 3794, ObjectMapper.readValue line 2842, TestUnwrapped.testCaseInsensitiveUnwrap line 215"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java",
      "buggy_full_code": "package com.fasterxml.jackson.databind.deser.impl;\n\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.*;\n\nimport com.fasterxml.jackson.core.JsonParser;\nimport com.fasterxml.jackson.core.JsonProcessingException;\nimport com.fasterxml.jackson.databind.DeserializationContext;\nimport com.fasterxml.jackson.databind.DeserializationFeature;\nimport com.fasterxml.jackson.databind.JsonDeserializer;\nimport com.fasterxml.jackson.databind.JsonMappingException;\nimport com.fasterxml.jackson.databind.deser.SettableBeanProperty;\nimport com.fasterxml.jackson.databind.util.NameTransformer;\n\n\npublic class BeanPropertyMap implements Iterable<SettableBeanProperty>, java.io.Serializable { private static final long serialVersionUID = 2L; protected final boolean _caseInsensitive; private int _hashMask; private int _size; private int _spillCount; private Object[] _hashArea; private SettableBeanProperty[] _propsInOrder; public BeanPropertyMap(boolean caseInsensitive, Collection<SettableBeanProperty> props) {\n        _caseInsensitive = caseInsensitive;\n        _propsInOrder = props.toArray(new SettableBeanProperty[props.size()]);\n        init(props);\n    }\n\n    \n    protected BeanPropertyMap(BeanPropertyMap base, boolean caseInsensitive) {\n        _caseInsensitive = caseInsensitive;\n\n        \n        \n        _propsInOrder = Arrays.copyOf(base._propsInOrder, base._propsInOrder.length);\n        init(Arrays.asList(_propsInOrder));\n    }\n\n    \n    public BeanPropertyMap withCaseInsensitivity(boolean state) {\n        if (_caseInsensitive == state) {\n            return this;\n        }\n        return new BeanPropertyMap(this, state);\n    }\n\n    protected void init(Collection<SettableBeanProperty> props) {\n        _size = props.size();\n\n        \n        final int hashSize = findSize(_size);\n        _hashMask = hashSize-1;\n\n        \n        int alloc = (hashSize + (hashSize>>1)) * 2;\n        Object[] hashed = new Object[alloc];\n        int spillCount = 0;\n\n        for (SettableBeanProperty prop : props) {\n            \n            if (prop == null) {\n                continue;\n            }\n            \n            String key = getPropertyName(prop);\n            int slot = _hashCode(key);\n            int ix = (slot<<1);\n\n            \n            if (hashed[ix] != null) {\n                \n                ix = (hashSize + (slot >> 1)) << 1;\n                if (hashed[ix] != null) {\n                    \n                    ix = ((hashSize + (hashSize >> 1) ) << 1) + spillCount;\n                    spillCount += 2;\n                    if (ix >= hashed.length) {\n                        hashed = Arrays.copyOf(hashed, hashed.length + 4);\n                    }\n                }\n            }\n\n            hashed[ix] = key;\n            hashed[ix+1] = prop;\n        }\n\n        _hashArea = hashed;\n        _spillCount = spillCount;\n    }\n    \n    private final static int findSize(int size) {\n        if (size <= 5) {\n            return 8;\n        }\n        if (size <= 12) {\n            return 16;\n        }\n        int needed = size + (size >> 2); \n        int result = 32;\n        while (result < needed) {\n            result += result;\n        }\n        return result;\n    }\n    \n    \n    public static BeanPropertyMap construct(Collection<SettableBeanProperty> props, boolean caseInsensitive) {\n        return new BeanPropertyMap(caseInsensitive, props);\n    }\n    \n    \n    public BeanPropertyMap withProperty(SettableBeanProperty newProp) {\n        \n        String key = getPropertyName(newProp);\n\n        for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n            SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n            if ((prop != null) && prop.getName().equals(key)) {\n                _hashArea[i] = newProp;\n                _propsInOrder[_findFromOrdered(prop)] = newProp;\n                return this;\n            }\n        }\n        \n        final int slot = _hashCode(key);\n        final int hashSize = _hashMask+1;\n        int ix = (slot<<1);\n        \n        \n        if (_hashArea[ix] != null) {\n            \n            ix = (hashSize + (slot >> 1)) << 1;\n            if (_hashArea[ix] != null) {\n                \n                ix = ((hashSize + (hashSize >> 1) ) << 1) + _spillCount;\n                _spillCount += 2;\n                if (ix >= _hashArea.length) {\n                    _hashArea = Arrays.copyOf(_hashArea, _hashArea.length + 4);\n                    \n                    \n                \n                }\n            }\n        }\n        _hashArea[ix] = key;\n        _hashArea[ix+1] = newProp;\n\n        int last = _propsInOrder.length;\n        _propsInOrder = Arrays.copyOf(_propsInOrder, last+1);\n        _propsInOrder[last] = newProp;\n\n        \n        \n        return this;\n    }\n\n    public BeanPropertyMap assignIndexes() {\n        \n        int index = 0;\n        for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n            SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n            if (prop != null) {\n                prop.assignIndex(index++);\n            }\n        }\n        return this;\n    }\n\n    \n    public BeanPropertyMap renameAll(NameTransformer transformer) {\n        if (transformer == null || (transformer == NameTransformer.NOP)) {\n            return this;\n        }\n        \n        final int len = _propsInOrder.length;\n        ArrayList<SettableBeanProperty> newProps = new ArrayList<SettableBeanProperty>(len);\n\n        for (int i = 0; i < len; ++i) {\n            SettableBeanProperty prop = _propsInOrder[i];\n            \n            \n            if (prop == null) {\n                newProps.add(prop);\n                continue;\n            }\n            newProps.add(_rename(prop, transformer));\n        }\n        \n        return new BeanPropertyMap(_caseInsensitive, newProps);\n    }\n\n    \n    public BeanPropertyMap withoutProperties(Collection<String> toExclude) {\n        if (toExclude.isEmpty()) {\n            return this;\n        }\n        final int len = _propsInOrder.length;\n        ArrayList<SettableBeanProperty> newProps = new ArrayList<SettableBeanProperty>(len);\n\n        for (int i = 0; i < len; ++i) {\n            SettableBeanProperty prop = _propsInOrder[i];\n            \n            \n            \n            if (prop != null) { \n                if (!toExclude.contains(prop.getName())) {\n                    newProps.add(prop);\n                }\n            }\n        }\n        \n        return new BeanPropertyMap(_caseInsensitive, newProps);\n    }\n    \n    \n    public void replace(SettableBeanProperty newProp) {\n        String key = getPropertyName(newProp);\n        int ix = _findIndexInHash(key);\n        \n        if (ix >= 0) {\n            SettableBeanProperty prop = (SettableBeanProperty) _hashArea[ix];\n            _hashArea[ix] = newProp;\n            \n            _propsInOrder[_findFromOrdered(prop)] = newProp;\n            return;\n        }\n        \n        throw new NoSuchElementException(\"No entry '\"+key+\"' found, can't replace\");\n    }\n\n    private List<SettableBeanProperty> properties() {\n        ArrayList<SettableBeanProperty> p = new ArrayList<SettableBeanProperty>(_size);\n        for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n            SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n            if (prop != null) {\n                p.add(prop);\n            }\n        }\n        return p;\n    }\n\n    \n    @Override\n    public Iterator<SettableBeanProperty> iterator() {\n        return properties().iterator();\n    }\n\n    \n    public SettableBeanProperty[] getPropertiesInInsertionOrder() {\n        return _propsInOrder;\n    }\n\n    \n    \n    protected final String getPropertyName(SettableBeanProperty prop) {\n        return _caseInsensitive ? prop.getName().toLowerCase() : prop.getName();\n    }\n\n    \n    public SettableBeanProperty find(int index) {\n        \n        \n        for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n            SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n            if ((prop != null) && (index == prop.getPropertyIndex())) {\n                return prop;\n            }\n        }\n        return null;\n    }\n\n    public SettableBeanProperty find(String key) {\n        if (key == null) {\n            throw new IllegalArgumentException(\"Can not pass null property name\");\n        }\n        if (_caseInsensitive) {\n            key = key.toLowerCase();\n        }\n            \n        \n        int slot = key.hashCode() & _hashMask;\n\n\n\n        int ix = (slot<<1);\n        Object match = _hashArea[ix];\n        if ((match == key) || key.equals(match)) {\n            return (SettableBeanProperty) _hashArea[ix+1];\n        }\n        return _find2(key, slot, match);\n    }\n\n    private final SettableBeanProperty _find2(String key, int slot, Object match) {\n        if (match == null) {\n            return null;\n        }\n        \n        int hashSize = _hashMask+1;\n        int ix = hashSize + (slot>>1) << 1;\n        match = _hashArea[ix];\n        if (key.equals(match)) {\n            return (SettableBeanProperty) _hashArea[ix+1];\n        }\n        if (match != null) { \n            int i = (hashSize + (hashSize>>1)) << 1;\n            for (int end = i + _spillCount; i < end; i += 2) {\n                match = _hashArea[i];\n                if ((match == key) || key.equals(match)) {\n                    return (SettableBeanProperty) _hashArea[i+1];\n                }\n            }\n        }\n        return null;\n    }\n    \n    \n\n    public int size() { return _size; }\n\n    \n    public void remove(SettableBeanProperty propToRm) {\n        ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(_size);\n        String key = getPropertyName(propToRm);\n        boolean found = false;\n\n        for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n            SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n            if (prop == null) {\n                continue;\n            }\n            if (!found) {\n                \n                \n                found = key.equals(prop.getName());\n                if (found) {\n                    \n                    _propsInOrder[_findFromOrdered(prop)] = null;\n                    continue;\n                }\n            }\n            props.add(prop);\n        }\n        if (!found) {\n            throw new NoSuchElementException(\"No entry '\"+propToRm.getName()+\"' found, can't remove\");\n        }\n        init(props);\n    }\n\n    \n    public boolean findDeserializeAndSet(JsonParser p, DeserializationContext ctxt, Object bean, String key) throws IOException {\n        final SettableBeanProperty prop = find(key);\n        if (prop == null) {\n            return false;\n        }\n        try {\n            prop.deserializeAndSet(p, ctxt, bean);\n        } catch (Exception e) {\n            wrapAndThrow(e, bean, key, ctxt);\n        }\n        return true;\n    }\n\n    @Override\n    public String toString() {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"Properties=[\");\n        int count = 0;\n\n        Iterator<SettableBeanProperty> it = iterator();\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            if (count++ > 0) {\n                sb.append(\", \");\n            }\n            sb.append(prop.getName());\n            sb.append('(');\n            sb.append(prop.getType());\n            sb.append(')');\n        }\n        sb.append(']');\n        return sb.toString();\n    }\n    \n    \n\n    protected SettableBeanProperty _rename(SettableBeanProperty prop, NameTransformer xf) {\n        if (prop == null) {\n            return prop;\n        }\n        String newName = xf.transform(prop.getName());\n        prop = prop.withSimpleName(newName);\n        JsonDeserializer<?> deser = prop.getValueDeserializer();\n        if (deser != null) {\n            @SuppressWarnings(\"unchecked\")\n            JsonDeserializer<Object> newDeser = (JsonDeserializer<Object>)\n                deser.unwrappingDeserializer(xf);\n            if (newDeser != deser) {\n                prop = prop.withValueDeserializer(newDeser);\n            }\n        }\n        return prop;\n    }\n\n    protected void wrapAndThrow(Throwable t, Object bean, String fieldName, DeserializationContext ctxt) throws IOException {\n        \n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        \n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        \n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        \n        if (t instanceof IOException) {\n            if (!wrap || !(t instanceof JsonProcessingException)) {\n                throw (IOException) t;\n            }\n        } else if (!wrap) { \n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n        }\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }\n\n    \n    private final int _findIndexInHash(String key) {\n        final int slot = _hashCode(key);\n        int ix = (slot<<1);\n        \n        \n        if (key.equals(_hashArea[ix])) {\n            return ix+1;\n        }\n        \n        int hashSize = _hashMask+1;\n        ix = hashSize + (slot>>1) << 1;\n        if (key.equals(_hashArea[ix])) {\n            return ix+1;\n        }\n        \n        int i = (hashSize + (hashSize>>1)) << 1;\n        for (int end = i + _spillCount; i < end; i += 2) {\n            if (key.equals(_hashArea[i])) {\n                return i+1;\n            }\n        }\n        return -1;\n    }\n    \n    private final int _findFromOrdered(SettableBeanProperty prop) {\n        for (int i = 0, end = _propsInOrder.length; i < end; ++i) {\n            if (_propsInOrder[i] == prop) {\n                return i;\n            }\n        }\n        throw new IllegalStateException(\"Illegal state: property '\"+prop.getName()+\"' missing from _propsInOrder\");\n    }\n\n    \n    private final int _hashCode(String key) {\n        \n        \n\n        \n\n        \n        return key.hashCode() & _hashMask;\n    }\n}\n",
      "fixed_full_code": "package com.fasterxml.jackson.databind.deser.impl;\n\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.*;\n\nimport com.fasterxml.jackson.core.JsonParser;\nimport com.fasterxml.jackson.core.JsonProcessingException;\nimport com.fasterxml.jackson.databind.DeserializationContext;\nimport com.fasterxml.jackson.databind.DeserializationFeature;\nimport com.fasterxml.jackson.databind.JsonDeserializer;\nimport com.fasterxml.jackson.databind.JsonMappingException;\nimport com.fasterxml.jackson.databind.deser.SettableBeanProperty;\nimport com.fasterxml.jackson.databind.util.NameTransformer;\n\n\npublic class BeanPropertyMap implements Iterable<SettableBeanProperty>, java.io.Serializable { private static final long serialVersionUID = 2L; protected final boolean _caseInsensitive; private int _hashMask; private int _size; private int _spillCount; private Object[] _hashArea; private SettableBeanProperty[] _propsInOrder; public BeanPropertyMap(boolean caseInsensitive, Collection<SettableBeanProperty> props) {\n        _caseInsensitive = caseInsensitive;\n        _propsInOrder = props.toArray(new SettableBeanProperty[props.size()]);\n        init(props);\n    }\n\n    \n    protected BeanPropertyMap(BeanPropertyMap base, boolean caseInsensitive) {\n        _caseInsensitive = caseInsensitive;\n\n        \n        \n        _propsInOrder = Arrays.copyOf(base._propsInOrder, base._propsInOrder.length);\n        init(Arrays.asList(_propsInOrder));\n    }\n\n    \n    public BeanPropertyMap withCaseInsensitivity(boolean state) {\n        if (_caseInsensitive == state) {\n            return this;\n        }\n        return new BeanPropertyMap(this, state);\n    }\n\n    protected void init(Collection<SettableBeanProperty> props) {\n        _size = props.size();\n\n        \n        final int hashSize = findSize(_size);\n        _hashMask = hashSize-1;\n\n        \n        int alloc = (hashSize + (hashSize>>1)) * 2;\n        Object[] hashed = new Object[alloc];\n        int spillCount = 0;\n\n        for (SettableBeanProperty prop : props) {\n            \n            if (prop == null) {\n                continue;\n            }\n            \n            String key = getPropertyName(prop);\n            int slot = _hashCode(key);\n            int ix = (slot<<1);\n\n            \n            if (hashed[ix] != null) {\n                \n                ix = (hashSize + (slot >> 1)) << 1;\n                if (hashed[ix] != null) {\n                    \n                    ix = ((hashSize + (hashSize >> 1) ) << 1) + spillCount;\n                    spillCount += 2;\n                    if (ix >= hashed.length) {\n                        hashed = Arrays.copyOf(hashed, hashed.length + 4);\n                    }\n                }\n            }\n\n            hashed[ix] = key;\n            hashed[ix+1] = prop;\n        }\n\n        _hashArea = hashed;\n        _spillCount = spillCount;\n    }\n    \n    private final static int findSize(int size) {\n        if (size <= 5) {\n            return 8;\n        }\n        if (size <= 12) {\n            return 16;\n        }\n        int needed = size + (size >> 2); \n        int result = 32;\n        while (result < needed) {\n            result += result;\n        }\n        return result;\n    }\n    \n    \n    public static BeanPropertyMap construct(Collection<SettableBeanProperty> props, boolean caseInsensitive) {\n        return new BeanPropertyMap(caseInsensitive, props);\n    }\n    \n    \n    public BeanPropertyMap withProperty(SettableBeanProperty newProp) {\n        \n        String key = getPropertyName(newProp);\n\n        for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n            SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n            if ((prop != null) && prop.getName().equals(key)) {\n                _hashArea[i] = newProp;\n                _propsInOrder[_findFromOrdered(prop)] = newProp;\n                return this;\n            }\n        }\n        \n        final int slot = _hashCode(key);\n        final int hashSize = _hashMask+1;\n        int ix = (slot<<1);\n        \n        \n        if (_hashArea[ix] != null) {\n            \n            ix = (hashSize + (slot >> 1)) << 1;\n            if (_hashArea[ix] != null) {\n                \n                ix = ((hashSize + (hashSize >> 1) ) << 1) + _spillCount;\n                _spillCount += 2;\n                if (ix >= _hashArea.length) {\n                    _hashArea = Arrays.copyOf(_hashArea, _hashArea.length + 4);\n                    \n                    \n                \n                }\n            }\n        }\n        _hashArea[ix] = key;\n        _hashArea[ix+1] = newProp;\n\n        int last = _propsInOrder.length;\n        _propsInOrder = Arrays.copyOf(_propsInOrder, last+1);\n        _propsInOrder[last] = newProp;\n\n        \n        \n        return this;\n    }\n\n    public BeanPropertyMap assignIndexes() {\n        \n        int index = 0;\n        for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n            SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n            if (prop != null) {\n                prop.assignIndex(index++);\n            }\n        }\n        return this;\n    }\n\n    \n    public BeanPropertyMap renameAll(NameTransformer transformer) {\n        if (transformer == null || (transformer == NameTransformer.NOP)) {\n            return this;\n        }\n        \n        final int len = _propsInOrder.length;\n        ArrayList<SettableBeanProperty> newProps = new ArrayList<SettableBeanProperty>(len);\n\n        for (int i = 0; i < len; ++i) {\n            SettableBeanProperty prop = _propsInOrder[i];\n            \n            \n            if (prop == null) {\n                newProps.add(prop);\n                continue;\n            }\n            newProps.add(_rename(prop, transformer));\n        }\n        \n        return new BeanPropertyMap(_caseInsensitive, newProps);\n    }\n\n    \n    public BeanPropertyMap withoutProperties(Collection<String> toExclude) {\n        if (toExclude.isEmpty()) {\n            return this;\n        }\n        final int len = _propsInOrder.length;\n        ArrayList<SettableBeanProperty> newProps = new ArrayList<SettableBeanProperty>(len);\n\n        for (int i = 0; i < len; ++i) {\n            SettableBeanProperty prop = _propsInOrder[i];\n            \n            \n            \n            if (prop != null) { \n                if (!toExclude.contains(prop.getName())) {\n                    newProps.add(prop);\n                }\n            }\n        }\n        \n        return new BeanPropertyMap(_caseInsensitive, newProps);\n    }\n    \n    \n    public void replace(SettableBeanProperty newProp) {\n        String key = getPropertyName(newProp);\n        int ix = _findIndexInHash(key);\n        \n        if (ix >= 0) {\n            SettableBeanProperty prop = (SettableBeanProperty) _hashArea[ix];\n            _hashArea[ix] = newProp;\n            \n            _propsInOrder[_findFromOrdered(prop)] = newProp;\n            return;\n        }\n        \n        throw new NoSuchElementException(\"No entry '\"+key+\"' found, can't replace\");\n    }\n\n    private List<SettableBeanProperty> properties() {\n        ArrayList<SettableBeanProperty> p = new ArrayList<SettableBeanProperty>(_size);\n        for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n            SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n            if (prop != null) {\n                p.add(prop);\n            }\n        }\n        return p;\n    }\n\n    \n    @Override\n    public Iterator<SettableBeanProperty> iterator() {\n        return properties().iterator();\n    }\n\n    \n    public SettableBeanProperty[] getPropertiesInInsertionOrder() {\n        return _propsInOrder;\n    }\n\n    \n    \n    protected final String getPropertyName(SettableBeanProperty prop) {\n        return _caseInsensitive ? prop.getName().toLowerCase() : prop.getName();\n    }\n\n    \n    public SettableBeanProperty find(int index) {\n        \n        \n        for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n            SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n            if ((prop != null) && (index == prop.getPropertyIndex())) {\n                return prop;\n            }\n        }\n        return null;\n    }\n\n    public SettableBeanProperty find(String key) {\n        if (key == null) {\n            throw new IllegalArgumentException(\"Can not pass null property name\");\n        }\n        if (_caseInsensitive) {\n            key = key.toLowerCase();\n        }\n            \n        \n        int slot = key.hashCode() & _hashMask;\n\n\n\n        int ix = (slot<<1);\n        Object match = _hashArea[ix];\n        if ((match == key) || key.equals(match)) {\n            return (SettableBeanProperty) _hashArea[ix+1];\n        }\n        return _find2(key, slot, match);\n    }\n\n    private final SettableBeanProperty _find2(String key, int slot, Object match) {\n        if (match == null) {\n            return null;\n        }\n        \n        int hashSize = _hashMask+1;\n        int ix = hashSize + (slot>>1) << 1;\n        match = _hashArea[ix];\n        if (key.equals(match)) {\n            return (SettableBeanProperty) _hashArea[ix+1];\n        }\n        if (match != null) { \n            int i = (hashSize + (hashSize>>1)) << 1;\n            for (int end = i + _spillCount; i < end; i += 2) {\n                match = _hashArea[i];\n                if ((match == key) || key.equals(match)) {\n                    return (SettableBeanProperty) _hashArea[i+1];\n                }\n            }\n        }\n        return null;\n    }\n    \n    \n\n    public int size() { return _size; }\n\n    \n    public void remove(SettableBeanProperty propToRm) {\n        ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(_size);\n        String key = getPropertyName(propToRm);\n        boolean found = false;\n\n        for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n            SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n            if (prop == null) {\n                continue;\n            }\n            if (!found) {\n                \n                \n                found = key.equals(_hashArea[i-1]);\n                if (found) {\n                    \n                    _propsInOrder[_findFromOrdered(prop)] = null;\n                    continue;\n                }\n            }\n            props.add(prop);\n        }\n        if (!found) {\n            throw new NoSuchElementException(\"No entry '\"+propToRm.getName()+\"' found, can't remove\");\n        }\n        init(props);\n    }\n\n    \n    public boolean findDeserializeAndSet(JsonParser p, DeserializationContext ctxt, Object bean, String key) throws IOException {\n        final SettableBeanProperty prop = find(key);\n        if (prop == null) {\n            return false;\n        }\n        try {\n            prop.deserializeAndSet(p, ctxt, bean);\n        } catch (Exception e) {\n            wrapAndThrow(e, bean, key, ctxt);\n        }\n        return true;\n    }\n\n    @Override\n    public String toString() {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"Properties=[\");\n        int count = 0;\n\n        Iterator<SettableBeanProperty> it = iterator();\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            if (count++ > 0) {\n                sb.append(\", \");\n            }\n            sb.append(prop.getName());\n            sb.append('(');\n            sb.append(prop.getType());\n            sb.append(')');\n        }\n        sb.append(']');\n        return sb.toString();\n    }\n    \n    \n\n    protected SettableBeanProperty _rename(SettableBeanProperty prop, NameTransformer xf) {\n        if (prop == null) {\n            return prop;\n        }\n        String newName = xf.transform(prop.getName());\n        prop = prop.withSimpleName(newName);\n        JsonDeserializer<?> deser = prop.getValueDeserializer();\n        if (deser != null) {\n            @SuppressWarnings(\"unchecked\")\n            JsonDeserializer<Object> newDeser = (JsonDeserializer<Object>)\n                deser.unwrappingDeserializer(xf);\n            if (newDeser != deser) {\n                prop = prop.withValueDeserializer(newDeser);\n            }\n        }\n        return prop;\n    }\n\n    protected void wrapAndThrow(Throwable t, Object bean, String fieldName, DeserializationContext ctxt) throws IOException {\n        \n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        \n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        \n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        \n        if (t instanceof IOException) {\n            if (!wrap || !(t instanceof JsonProcessingException)) {\n                throw (IOException) t;\n            }\n        } else if (!wrap) { \n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n        }\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }\n\n    \n    private final int _findIndexInHash(String key) {\n        final int slot = _hashCode(key);\n        int ix = (slot<<1);\n        \n        \n        if (key.equals(_hashArea[ix])) {\n            return ix+1;\n        }\n        \n        int hashSize = _hashMask+1;\n        ix = hashSize + (slot>>1) << 1;\n        if (key.equals(_hashArea[ix])) {\n            return ix+1;\n        }\n        \n        int i = (hashSize + (hashSize>>1)) << 1;\n        for (int end = i + _spillCount; i < end; i += 2) {\n            if (key.equals(_hashArea[i])) {\n                return i+1;\n            }\n        }\n        return -1;\n    }\n    \n    private final int _findFromOrdered(SettableBeanProperty prop) {\n        for (int i = 0, end = _propsInOrder.length; i < end; ++i) {\n            if (_propsInOrder[i] == prop) {\n                return i;\n            }\n        }\n        throw new IllegalStateException(\"Illegal state: property '\"+prop.getName()+\"' missing from _propsInOrder\");\n    }\n\n    \n    private final int _hashCode(String key) {\n        \n        \n\n        \n\n        \n        return key.hashCode() & _hashMask;\n    }\n}\n",
      "buggy_signatures": [
        "protected BeanPropertyMap(BeanPropertyMap base, boolean caseInsensitive)",
        "public BeanPropertyMap withCaseInsensitivity(boolean state)",
        "protected void init(Collection<SettableBeanProperty> props)",
        "private final static int findSize(int size)",
        "public static BeanPropertyMap construct(Collection<SettableBeanProperty> props, boolean caseInsensitive)",
        "public BeanPropertyMap withProperty(SettableBeanProperty newProp)",
        "public BeanPropertyMap assignIndexes()",
        "public BeanPropertyMap renameAll(NameTransformer transformer)",
        "public BeanPropertyMap withoutProperties(Collection<String> toExclude)",
        "public void replace(SettableBeanProperty newProp)",
        "private List<SettableBeanProperty> properties()",
        "public Iterator<SettableBeanProperty> iterator()",
        "public SettableBeanProperty[] getPropertiesInInsertionOrder()",
        "protected final String getPropertyName(SettableBeanProperty prop)",
        "public SettableBeanProperty find(int index)",
        "public SettableBeanProperty find(String key)",
        "private final SettableBeanProperty _find2(String key, int slot, Object match)",
        "public int size()",
        "public void remove(SettableBeanProperty propToRm)",
        "public boolean findDeserializeAndSet(JsonParser p, DeserializationContext ctxt, Object bean, String key) throws IOException",
        "public String toString()",
        "protected SettableBeanProperty _rename(SettableBeanProperty prop, NameTransformer xf)",
        "protected void wrapAndThrow(Throwable t, Object bean, String fieldName, DeserializationContext ctxt) throws IOException",
        "private final int _findIndexInHash(String key)",
        "private final int _findFromOrdered(SettableBeanProperty prop)",
        "private final int _hashCode(String key)"
      ],
      "fixed_signatures": [
        "protected BeanPropertyMap(BeanPropertyMap base, boolean caseInsensitive)",
        "public BeanPropertyMap withCaseInsensitivity(boolean state)",
        "protected void init(Collection<SettableBeanProperty> props)",
        "private final static int findSize(int size)",
        "public static BeanPropertyMap construct(Collection<SettableBeanProperty> props, boolean caseInsensitive)",
        "public BeanPropertyMap withProperty(SettableBeanProperty newProp)",
        "public BeanPropertyMap assignIndexes()",
        "public BeanPropertyMap renameAll(NameTransformer transformer)",
        "public BeanPropertyMap withoutProperties(Collection<String> toExclude)",
        "public void replace(SettableBeanProperty newProp)",
        "private List<SettableBeanProperty> properties()",
        "public Iterator<SettableBeanProperty> iterator()",
        "public SettableBeanProperty[] getPropertiesInInsertionOrder()",
        "protected final String getPropertyName(SettableBeanProperty prop)",
        "public SettableBeanProperty find(int index)",
        "public SettableBeanProperty find(String key)",
        "private final SettableBeanProperty _find2(String key, int slot, Object match)",
        "public int size()",
        "public void remove(SettableBeanProperty propToRm)",
        "public boolean findDeserializeAndSet(JsonParser p, DeserializationContext ctxt, Object bean, String key) throws IOException",
        "public String toString()",
        "protected SettableBeanProperty _rename(SettableBeanProperty prop, NameTransformer xf)",
        "protected void wrapAndThrow(Throwable t, Object bean, String fieldName, DeserializationContext ctxt) throws IOException",
        "private final int _findIndexInHash(String key)",
        "private final int _findFromOrdered(SettableBeanProperty prop)",
        "private final int _hashCode(String key)"
      ],
      "methods": [
        {
          "buggy_method": "  public void remove(SettableBeanProperty propToRm) {\n  ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(_size);\n  String key = getPropertyName(propToRm);\n  boolean found = false;\n\n  for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n  SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n  if (prop == null) {\n  continue;\n  }\n  if (!found) {\n  \n  \n  found = key.equals(prop.getName());\n  if (found) {\n  \n  _propsInOrder[_findFromOrdered(prop)] = null;\n  continue;\n  }\n  }\n  props.add(prop);\n  }\n  if (!found) {\n  throw new NoSuchElementException(\"No entry '\"+propToRm.getName()+\"' found, can't remove\");\n  }\n  init(props);\n  }",
          "fixed_method": "  public void remove(SettableBeanProperty propToRm) {\n  ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(_size);\n  String key = getPropertyName(propToRm);\n  boolean found = false;\n\n  for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n  SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n  if (prop == null) {\n  continue;\n  }\n  if (!found) {\n  \n  \n  found = key.equals(_hashArea[i-1]);\n  if (found) {\n  \n  _propsInOrder[_findFromOrdered(prop)] = null;\n  continue;\n  }\n  }\n  props.add(prop);\n  }\n  if (!found) {\n  throw new NoSuchElementException(\"No entry '\"+propToRm.getName()+\"' found, can't remove\");\n  }\n  init(props);\n  }",
          "diff": [
            "@@ -437,7 +437,7 @@",
            "             if (!found) {\n",
            "                 // 09-Jan-2017, tatu: Important: must check name slot and NOT property name,\n",
            "                 //   as only former is lower-case in case-insensitive case\n",
            "-                found = key.equals(prop.getName());\n",
            "+                found = key.equals(_hashArea[i-1]);\n",
            "                 if (found) {\n",
            "                     // need to leave a hole here\n",
            "                     _propsInOrder[_findFromOrdered(prop)] = null;\n"
          ],
          "changed_lines": 2
        }
      ]
    }
  ]
}
