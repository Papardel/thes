{
  "bug_id": "73",
  "failed_tests": {
    "org.apache.commons.math.analysis.solvers.BrentSolverTest": [
      {
        "methodName": "testBadEndpoints",
        "error": "junit.framework.AssertionFailedError",
        "message": "Expecting IllegalArgumentException - non-bracketing",
        "fail_line": "            fail(\"Expecting IllegalArgumentException - non-bracketing\");",
        "test_source": "  public void testBadEndpoints() throws Exception {\n  UnivariateRealFunction f = new SinFunction();\n  UnivariateRealSolver solver = new BrentSolver();\n  try {  // bad interval\n  solver.solve(f, 1, -1);\n  fail(\"Expecting IllegalArgumentException - bad interval\");\n  } catch (IllegalArgumentException ex) {\n  // expected\n  }\n  try {  // no bracket\n  solver.solve(f, 1, 1.5);\n  fail(\"Expecting IllegalArgumentException - non-bracketing\");\n  } catch (IllegalArgumentException ex) {\n  // expected\n  }\n  try {  // no bracket\n  solver.solve(f, 1, 1.5, 1.2);\n  fail(\"Expecting IllegalArgumentException - non-bracketing\");\n  } catch (IllegalArgumentException ex) {\n  // expected\n  }\n  }",
        "stack": [
          "BrentSolverTest.testBadEndpoints line 334"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/math/analysis/solvers/BrentSolver.java",
      "buggy_full_code": "\npackage org.apache.commons.math.analysis.solvers;\n\n\nimport org.apache.commons.math.FunctionEvaluationException;\nimport org.apache.commons.math.MathRuntimeException;\nimport org.apache.commons.math.MaxIterationsExceededException;\nimport org.apache.commons.math.analysis.UnivariateRealFunction;\n\n\npublic class BrentSolver extends UnivariateRealSolverImpl { private static final String NON_BRACKETING_MESSAGE = \"function values at endpoints do not have different signs. \" + \"Endpoints: [{0}, {1}], Values: [{2}, {3}]\"; private static final long serialVersionUID = 7694577816772532779L; @Deprecated public BrentSolver(UnivariateRealFunction f) {\n        super(f, 100, 1E-6);\n    }\n\n    \n    public BrentSolver() {\n        super(100, 1E-6);\n    }\n\n    \n    @Deprecated\n    public double solve(double min, double max) throws MaxIterationsExceededException, FunctionEvaluationException {\n        return solve(f, min, max);\n    }\n\n    \n    @Deprecated\n    public double solve(double min, double max, double initial) throws MaxIterationsExceededException, FunctionEvaluationException {\n        return solve(f, min, max, initial);\n    }\n\n    \n    public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial) throws MaxIterationsExceededException, FunctionEvaluationException {\n\n        clearResult();\n        verifySequence(min, initial, max);\n\n        \n        double yInitial = f.value(initial);\n        if (Math.abs(yInitial) <= functionValueAccuracy) {\n            setResult(initial, 0);\n            return result;\n        }\n\n        \n        double yMin = f.value(min);\n        if (Math.abs(yMin) <= functionValueAccuracy) {\n            setResult(yMin, 0);\n            return result;\n        }\n\n        \n        if (yInitial * yMin < 0) {\n            return solve(f, min, yMin, initial, yInitial, min, yMin);\n        }\n\n        \n        double yMax = f.value(max);\n        if (Math.abs(yMax) <= functionValueAccuracy) {\n            setResult(yMax, 0);\n            return result;\n        }\n\n        \n        if (yInitial * yMax < 0) {\n            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n        }\n\n\n        \n        return solve(f, min, yMin, max, yMax, initial, yInitial);\n\n    }\n\n    \n    public double solve(final UnivariateRealFunction f, final double min, final double max) throws MaxIterationsExceededException, FunctionEvaluationException {\n\n        clearResult();\n        verifyInterval(min, max);\n\n        double ret = Double.NaN;\n\n        double yMin = f.value(min);\n        double yMax = f.value(max);\n\n        \n        double sign = yMin * yMax;\n        if (sign > 0) {\n            \n            if (Math.abs(yMin) <= functionValueAccuracy) {\n                setResult(min, 0);\n                ret = min;\n            } else if (Math.abs(yMax) <= functionValueAccuracy) {\n                setResult(max, 0);\n                ret = max;\n            } else {\n                \n                throw MathRuntimeException.createIllegalArgumentException(\n                        NON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n            }\n        } else if (sign < 0){\n            \n            ret = solve(f, min, yMin, max, yMax, min, yMin);\n        } else {\n            \n            if (yMin == 0.0) {\n                ret = min;\n            } else {\n                ret = max;\n            }\n        }\n\n        return ret;\n    }\n\n    \n    private double solve(final UnivariateRealFunction f, double x0, double y0, double x1, double y1, double x2, double y2) throws MaxIterationsExceededException, FunctionEvaluationException {\n\n        double delta = x1 - x0;\n        double oldDelta = delta;\n\n        int i = 0;\n        while (i < maximalIterationCount) {\n            if (Math.abs(y2) < Math.abs(y1)) {\n                \n                x0 = x1;\n                x1 = x2;\n                x2 = x0;\n                y0 = y1;\n                y1 = y2;\n                y2 = y0;\n            }\n            if (Math.abs(y1) <= functionValueAccuracy) {\n                \n                \n                \n                setResult(x1, i);\n                return result;\n            }\n            double dx = x2 - x1;\n            double tolerance =\n                Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy);\n            if (Math.abs(dx) <= tolerance) {\n                setResult(x1, i);\n                return result;\n            }\n            if ((Math.abs(oldDelta) < tolerance) ||\n                    (Math.abs(y0) <= Math.abs(y1))) {\n                \n                delta = 0.5 * dx;\n                oldDelta = delta;\n            } else {\n                double r3 = y1 / y0;\n                double p;\n                double p1;\n                \n                \n                \n                if (x0 == x2) {\n                    \n                    p = dx * r3;\n                    p1 = 1.0 - r3;\n                } else {\n                    \n                    double r1 = y0 / y2;\n                    double r2 = y1 / y2;\n                    p = r3 * (dx * r1 * (r1 - r2) - (x1 - x0) * (r2 - 1.0));\n                    p1 = (r1 - 1.0) * (r2 - 1.0) * (r3 - 1.0);\n                }\n                if (p > 0.0) {\n                    p1 = -p1;\n                } else {\n                    p = -p;\n                }\n                if (2.0 * p >= 1.5 * dx * p1 - Math.abs(tolerance * p1) ||\n                        p >= Math.abs(0.5 * oldDelta * p1)) {\n                    \n                    \n                    \n                    delta = 0.5 * dx;\n                    oldDelta = delta;\n                } else {\n                    oldDelta = delta;\n                    delta = p / p1;\n                }\n            }\n            \n            x0 = x1;\n            y0 = y1;\n            \n            if (Math.abs(delta) > tolerance) {\n                x1 = x1 + delta;\n            } else if (dx > 0.0) {\n                x1 = x1 + 0.5 * tolerance;\n            } else if (dx <= 0.0) {\n                x1 = x1 - 0.5 * tolerance;\n            }\n            y1 = f.value(x1);\n            if ((y1 > 0) == (y2 > 0)) {\n                x2 = x0;\n                y2 = y0;\n                delta = x1 - x0;\n                oldDelta = delta;\n            }\n            i++;\n        }\n        throw new MaxIterationsExceededException(maximalIterationCount);\n    }\n}\n",
      "fixed_full_code": "\npackage org.apache.commons.math.analysis.solvers;\n\n\nimport org.apache.commons.math.FunctionEvaluationException;\nimport org.apache.commons.math.MathRuntimeException;\nimport org.apache.commons.math.MaxIterationsExceededException;\nimport org.apache.commons.math.analysis.UnivariateRealFunction;\n\n\npublic class BrentSolver extends UnivariateRealSolverImpl { private static final String NON_BRACKETING_MESSAGE = \"function values at endpoints do not have different signs. \" + \"Endpoints: [{0}, {1}], Values: [{2}, {3}]\"; private static final long serialVersionUID = 7694577816772532779L; @Deprecated public BrentSolver(UnivariateRealFunction f) {\n        super(f, 100, 1E-6);\n    }\n\n    \n    public BrentSolver() {\n        super(100, 1E-6);\n    }\n\n    \n    @Deprecated\n    public double solve(double min, double max) throws MaxIterationsExceededException, FunctionEvaluationException {\n        return solve(f, min, max);\n    }\n\n    \n    @Deprecated\n    public double solve(double min, double max, double initial) throws MaxIterationsExceededException, FunctionEvaluationException {\n        return solve(f, min, max, initial);\n    }\n\n    \n    public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial) throws MaxIterationsExceededException, FunctionEvaluationException {\n\n        clearResult();\n        verifySequence(min, initial, max);\n\n        \n        double yInitial = f.value(initial);\n        if (Math.abs(yInitial) <= functionValueAccuracy) {\n            setResult(initial, 0);\n            return result;\n        }\n\n        \n        double yMin = f.value(min);\n        if (Math.abs(yMin) <= functionValueAccuracy) {\n            setResult(yMin, 0);\n            return result;\n        }\n\n        \n        if (yInitial * yMin < 0) {\n            return solve(f, min, yMin, initial, yInitial, min, yMin);\n        }\n\n        \n        double yMax = f.value(max);\n        if (Math.abs(yMax) <= functionValueAccuracy) {\n            setResult(yMax, 0);\n            return result;\n        }\n\n        \n        if (yInitial * yMax < 0) {\n            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n        }\n\n        if (yMin * yMax > 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  NON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n        }\n\n        \n        return solve(f, min, yMin, max, yMax, initial, yInitial);\n\n    }\n\n    \n    public double solve(final UnivariateRealFunction f, final double min, final double max) throws MaxIterationsExceededException, FunctionEvaluationException {\n\n        clearResult();\n        verifyInterval(min, max);\n\n        double ret = Double.NaN;\n\n        double yMin = f.value(min);\n        double yMax = f.value(max);\n\n        \n        double sign = yMin * yMax;\n        if (sign > 0) {\n            \n            if (Math.abs(yMin) <= functionValueAccuracy) {\n                setResult(min, 0);\n                ret = min;\n            } else if (Math.abs(yMax) <= functionValueAccuracy) {\n                setResult(max, 0);\n                ret = max;\n            } else {\n                \n                throw MathRuntimeException.createIllegalArgumentException(\n                        NON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n            }\n        } else if (sign < 0){\n            \n            ret = solve(f, min, yMin, max, yMax, min, yMin);\n        } else {\n            \n            if (yMin == 0.0) {\n                ret = min;\n            } else {\n                ret = max;\n            }\n        }\n\n        return ret;\n    }\n\n    \n    private double solve(final UnivariateRealFunction f, double x0, double y0, double x1, double y1, double x2, double y2) throws MaxIterationsExceededException, FunctionEvaluationException {\n\n        double delta = x1 - x0;\n        double oldDelta = delta;\n\n        int i = 0;\n        while (i < maximalIterationCount) {\n            if (Math.abs(y2) < Math.abs(y1)) {\n                \n                x0 = x1;\n                x1 = x2;\n                x2 = x0;\n                y0 = y1;\n                y1 = y2;\n                y2 = y0;\n            }\n            if (Math.abs(y1) <= functionValueAccuracy) {\n                \n                \n                \n                setResult(x1, i);\n                return result;\n            }\n            double dx = x2 - x1;\n            double tolerance =\n                Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy);\n            if (Math.abs(dx) <= tolerance) {\n                setResult(x1, i);\n                return result;\n            }\n            if ((Math.abs(oldDelta) < tolerance) ||\n                    (Math.abs(y0) <= Math.abs(y1))) {\n                \n                delta = 0.5 * dx;\n                oldDelta = delta;\n            } else {\n                double r3 = y1 / y0;\n                double p;\n                double p1;\n                \n                \n                \n                if (x0 == x2) {\n                    \n                    p = dx * r3;\n                    p1 = 1.0 - r3;\n                } else {\n                    \n                    double r1 = y0 / y2;\n                    double r2 = y1 / y2;\n                    p = r3 * (dx * r1 * (r1 - r2) - (x1 - x0) * (r2 - 1.0));\n                    p1 = (r1 - 1.0) * (r2 - 1.0) * (r3 - 1.0);\n                }\n                if (p > 0.0) {\n                    p1 = -p1;\n                } else {\n                    p = -p;\n                }\n                if (2.0 * p >= 1.5 * dx * p1 - Math.abs(tolerance * p1) ||\n                        p >= Math.abs(0.5 * oldDelta * p1)) {\n                    \n                    \n                    \n                    delta = 0.5 * dx;\n                    oldDelta = delta;\n                } else {\n                    oldDelta = delta;\n                    delta = p / p1;\n                }\n            }\n            \n            x0 = x1;\n            y0 = y1;\n            \n            if (Math.abs(delta) > tolerance) {\n                x1 = x1 + delta;\n            } else if (dx > 0.0) {\n                x1 = x1 + 0.5 * tolerance;\n            } else if (dx <= 0.0) {\n                x1 = x1 - 0.5 * tolerance;\n            }\n            y1 = f.value(x1);\n            if ((y1 > 0) == (y2 > 0)) {\n                x2 = x0;\n                y2 = y0;\n                delta = x1 - x0;\n                oldDelta = delta;\n            }\n            i++;\n        }\n        throw new MaxIterationsExceededException(maximalIterationCount);\n    }\n}\n",
      "buggy_signatures": [
        "public BrentSolver()",
        "public double solve(double min, double max) throws MaxIterationsExceededException, FunctionEvaluationException",
        "public double solve(double min, double max, double initial) throws MaxIterationsExceededException, FunctionEvaluationException",
        "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial) throws MaxIterationsExceededException, FunctionEvaluationException",
        "public double solve(final UnivariateRealFunction f, final double min, final double max) throws MaxIterationsExceededException, FunctionEvaluationException",
        "private double solve(final UnivariateRealFunction f, double x0, double y0, double x1, double y1, double x2, double y2) throws MaxIterationsExceededException, FunctionEvaluationException"
      ],
      "fixed_signatures": [
        "public BrentSolver()",
        "public double solve(double min, double max) throws MaxIterationsExceededException, FunctionEvaluationException",
        "public double solve(double min, double max, double initial) throws MaxIterationsExceededException, FunctionEvaluationException",
        "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial) throws MaxIterationsExceededException, FunctionEvaluationException",
        "public double solve(final UnivariateRealFunction f, final double min, final double max) throws MaxIterationsExceededException, FunctionEvaluationException",
        "private double solve(final UnivariateRealFunction f, double x0, double y0, double x1, double y1, double x2, double y2) throws MaxIterationsExceededException, FunctionEvaluationException"
      ],
      "methods": [
        {
          "buggy_method": "  public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial) throws MaxIterationsExceededException, FunctionEvaluationException {\n\n  clearResult();\n  verifySequence(min, initial, max);\n\n  \n  double yInitial = f.value(initial);\n  if (Math.abs(yInitial) <= functionValueAccuracy) {\n  setResult(initial, 0);\n  return result;\n  }\n\n  \n  double yMin = f.value(min);\n  if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin, 0);\n  return result;\n  }\n\n  \n  if (yInitial * yMin < 0) {\n  return solve(f, min, yMin, initial, yInitial, min, yMin);\n  }\n\n  \n  double yMax = f.value(max);\n  if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(yMax, 0);\n  return result;\n  }\n\n  \n  if (yInitial * yMax < 0) {\n  return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n  }\n\n\n  \n  return solve(f, min, yMin, max, yMax, initial, yInitial);\n\n  }",
          "fixed_method": "  public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial) throws MaxIterationsExceededException, FunctionEvaluationException {\n\n  clearResult();\n  verifySequence(min, initial, max);\n\n  \n  double yInitial = f.value(initial);\n  if (Math.abs(yInitial) <= functionValueAccuracy) {\n  setResult(initial, 0);\n  return result;\n  }\n\n  \n  double yMin = f.value(min);\n  if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin, 0);\n  return result;\n  }\n\n  \n  if (yInitial * yMin < 0) {\n  return solve(f, min, yMin, initial, yInitial, min, yMin);\n  }\n\n  \n  double yMax = f.value(max);\n  if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(yMax, 0);\n  return result;\n  }\n\n  \n  if (yInitial * yMax < 0) {\n  return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n  }\n\n  if (yMin * yMax > 0) {\n  throw MathRuntimeException.createIllegalArgumentException(\n  NON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n  }\n\n  \n  return solve(f, min, yMin, max, yMax, initial, yInitial);\n\n  }",
          "diff": [
            "@@ -133,6 +133,10 @@",
            "             return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n",
            "         }\n",
            " \n",
            "+        if (yMin * yMax > 0) {\n",
            "+            throw MathRuntimeException.createIllegalArgumentException(\n",
            "+                  NON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n",
            "+        }\n",
            " \n",
            "         // full Brent algorithm starting with provided initial guess\n",
            "         return solve(f, min, yMin, max, yMax, initial, yInitial);\n"
          ],
          "changed_lines": 4
        }
      ]
    }
  ]
}
