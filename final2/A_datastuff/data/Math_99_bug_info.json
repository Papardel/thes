{
  "bug_id": "99",
  "failed_tests": {
    "org.apache.commons.math.util.MathUtilsTest": [
      {
        "methodName": "testGcd",
        "error": "junit.framework.AssertionFailedError",
        "message": "expecting ArithmeticException",
        "fail_line": "            fail(\"expecting ArithmeticException\");",
        "test_source": "  public void testGcd() {\n  int a = 30;\n  int b = 50;\n  int c = 77;\n\n  assertEquals(0, MathUtils.gcd(0, 0));\n\n  assertEquals(b, MathUtils.gcd(0, b));\n  assertEquals(a, MathUtils.gcd(a, 0));\n  assertEquals(b, MathUtils.gcd(0, -b));\n  assertEquals(a, MathUtils.gcd(-a, 0));\n\n  assertEquals(10, MathUtils.gcd(a, b));\n  assertEquals(10, MathUtils.gcd(-a, b));\n  assertEquals(10, MathUtils.gcd(a, -b));\n  assertEquals(10, MathUtils.gcd(-a, -b));\n\n  assertEquals(1, MathUtils.gcd(a, c));\n  assertEquals(1, MathUtils.gcd(-a, c));\n  assertEquals(1, MathUtils.gcd(a, -c));\n  assertEquals(1, MathUtils.gcd(-a, -c));\n\n  assertEquals(3 * (1<<15), MathUtils.gcd(3 * (1<<20), 9 * (1<<15)));\n\n  assertEquals(Integer.MAX_VALUE, MathUtils.gcd(Integer.MAX_VALUE, 0));\n  assertEquals(Integer.MAX_VALUE, MathUtils.gcd(-Integer.MAX_VALUE, 0));\n  assertEquals(1<<30, MathUtils.gcd(1<<30, -Integer.MIN_VALUE));\n  try {\n  // gcd(Integer.MIN_VALUE, 0) > Integer.MAX_VALUE\n  MathUtils.gcd(Integer.MIN_VALUE, 0);\n  fail(\"expecting ArithmeticException\");\n  } catch (ArithmeticException expected) {\n  // expected\n  }\n  try {\n  // gcd(0, Integer.MIN_VALUE) > Integer.MAX_VALUE\n  MathUtils.gcd(0, Integer.MIN_VALUE);\n  fail(\"expecting ArithmeticException\");\n  } catch (ArithmeticException expected) {\n  // expected\n  }\n  try {\n  // gcd(Integer.MIN_VALUE, Integer.MIN_VALUE) > Integer.MAX_VALUE\n  MathUtils.gcd(Integer.MIN_VALUE, Integer.MIN_VALUE);\n  fail(\"expecting ArithmeticException\");\n  } catch (ArithmeticException expected) {\n  // expected\n  }\n  }",
        "stack": [
          "MathUtilsTest.testGcd line 437"
        ]
      },
      {
        "methodName": "testLcm",
        "error": "junit.framework.AssertionFailedError",
        "message": "Expecting ArithmeticException",
        "fail_line": "            fail(\"Expecting ArithmeticException\");",
        "test_source": "  public void testLcm() {\n  int a = 30;\n  int b = 50;\n  int c = 77;\n\n  assertEquals(0, MathUtils.lcm(0, b));\n  assertEquals(0, MathUtils.lcm(a, 0));\n  assertEquals(b, MathUtils.lcm(1, b));\n  assertEquals(a, MathUtils.lcm(a, 1));\n  assertEquals(150, MathUtils.lcm(a, b));\n  assertEquals(150, MathUtils.lcm(-a, b));\n  assertEquals(150, MathUtils.lcm(a, -b));\n  assertEquals(150, MathUtils.lcm(-a, -b));\n  assertEquals(2310, MathUtils.lcm(a, c));\n\n  // Assert that no intermediate value overflows:\n  // The naive implementation of lcm(a,b) would be (a*b)/gcd(a,b)\n  assertEquals((1<<20)*15, MathUtils.lcm((1<<20)*3, (1<<20)*5));\n\n  // Special case\n  assertEquals(0, MathUtils.lcm(0, 0));\n\n  try {\n  // lcm == abs(MIN_VALUE) cannot be represented as a nonnegative int\n  MathUtils.lcm(Integer.MIN_VALUE, 1);\n  fail(\"Expecting ArithmeticException\");\n  } catch (ArithmeticException ex) {\n  // expected\n  }\n  \n  try {\n  // lcm == abs(MIN_VALUE) cannot be represented as a nonnegative int\n  MathUtils.lcm(Integer.MIN_VALUE, 1<<20);\n  fail(\"Expecting ArithmeticException\");\n  } catch (ArithmeticException ex) {\n  // expected\n  }\n\n  try {\n  MathUtils.lcm(Integer.MAX_VALUE, Integer.MAX_VALUE - 1);\n  fail(\"Expecting ArithmeticException\");\n  } catch (ArithmeticException ex) {\n  // expected\n  }\n  }",
        "stack": [
          "MathUtilsTest.testLcm line 590"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/math/util/MathUtils.java",
      "buggy_full_code": "\n\npackage org.apache.commons.math.util;\n\nimport java.math.BigDecimal;\nimport java.util.Arrays;\n\nimport org.apache.commons.math.MathException;\nimport org.apache.commons.math.MathRuntimeException;\n\n\npublic final class MathUtils { public static final double EPSILON = 0x1.0p-53; public static final double SAFE_MIN = 0x1.0p-1022; private static final byte NB = (byte)-1; private static final short NS = (short)-1; private static final byte PB = (byte)1; private static final short PS = (short)1; private static final byte ZB = (byte)0; private static final short ZS = (short)0; private static final double TWO_PI = 2 * Math.PI; private MathUtils() {\n        super();\n    }\n\n    \n    public static int addAndCheck(int x, int y) {\n        long s = (long)x + (long)y;\n        if (s < Integer.MIN_VALUE || s > Integer.MAX_VALUE) {\n            throw new ArithmeticException(\"overflow: add\");\n        }\n        return (int)s;\n    }\n\n    \n    public static long addAndCheck(long a, long b) {\n        return addAndCheck(a, b, \"overflow: add\");\n    }\n    \n    \n    private static long addAndCheck(long a, long b, String msg) {\n        long ret;\n        if (a > b) {\n            \n            ret = addAndCheck(b, a, msg);\n        } else {\n            \n            \n            if (a < 0) {\n                if (b < 0) {\n                    \n                    if (Long.MIN_VALUE - b <= a) {\n                        ret = a + b;\n                    } else {\n                        throw new ArithmeticException(msg);\n                    }\n                } else {\n                    \n                    ret = a + b;\n                }\n            } else {\n                \n                \n\n                \n                if (a <= Long.MAX_VALUE - b) {\n                    ret = a + b;\n                } else {\n                    throw new ArithmeticException(msg);\n                }\n            }\n        }\n        return ret;\n    }\n    \n    \n    public static long binomialCoefficient(final int n, final int k) {\n        if (n < k) {\n            throw new IllegalArgumentException(\n                \"must have n >= k for binomial coefficient (n,k)\");\n        }\n        if (n < 0) {\n            throw new IllegalArgumentException(\n                \"must have n >= 0 for binomial coefficient (n,k)\");\n        }\n        if ((n == k) || (k == 0)) {\n            return 1;\n        }\n        if ((k == 1) || (k == n - 1)) {\n            return n;\n        }\n        \n        if (k > n / 2)\n            return binomialCoefficient(n, n - k);\n        \n        \n        \n        \n        \n        \n        long result = 1;\n        if (n <= 61) {\n            \n            for (int j = 1, i = n - k + 1; j <= k; i++, j++) {\n                result = result * i / j;\n            }\n        } else if (n <= 66) {\n            \n            \n            for (int j = 1, i = n - k + 1; j <= k; i++, j++) {\n                \n                \n                \n                \n                \n                \n                long d = gcd(i, j);\n                result = (result / (j / d)) * (i / d);\n            }\n        } else {\n            \n            \n            \n            for (int j = 1, i = n - k + 1; j <= k; i++, j++) {\n                long d = gcd(i, j);\n                result = mulAndCheck((result / (j / d)), (i / d));\n            }\n        }\n        return result;\n    }\n\n    \n    public static double binomialCoefficientDouble(final int n, final int k) {\n        if (n < k) {\n            throw new IllegalArgumentException(\n                \"must have n >= k for binomial coefficient (n,k)\");\n        }\n        if (n < 0) {\n            throw new IllegalArgumentException(\n                \"must have n >= 0 for binomial coefficient (n,k)\");\n        }\n        if ((n == k) || (k == 0)) {\n            return 1d;\n        }\n        if ((k == 1) || (k == n - 1)) {\n            return n;\n        }\n        if (k > n/2) {\n            return binomialCoefficientDouble(n, n - k);\n        }\n        if (n < 67) {\n            return binomialCoefficient(n,k);\n        }\n        \n        double result = 1d;\n        for (int i = 1; i <= k; i++) {\n             result *= (double)(n - k + i) / (double)i;\n        }\n  \n        return Math.floor(result + 0.5);\n    }\n    \n    \n    public static double binomialCoefficientLog(final int n, final int k) {\n        if (n < k) {\n            throw new IllegalArgumentException(\n                \"must have n >= k for binomial coefficient (n,k)\");\n        }\n        if (n < 0) {\n            throw new IllegalArgumentException(\n                \"must have n >= 0 for binomial coefficient (n,k)\");\n        }\n        if ((n == k) || (k == 0)) {\n            return 0;\n        }\n        if ((k == 1) || (k == n - 1)) {\n            return Math.log((double) n);\n        }\n        \n        \n        if (n < 67) {  \n            return Math.log(binomialCoefficient(n,k));\n        }\n        \n        \n        if (n < 1030) { \n            return Math.log(binomialCoefficientDouble(n, k));\n        } \n\n        if (k > n / 2) {\n            return binomialCoefficientLog(n, n - k);\n        }\n\n        \n        double logSum = 0;\n\n        \n        for (int i = n - k + 1; i <= n; i++) {\n            logSum += Math.log((double) i);\n        }\n\n        \n        for (int i = 2; i <= k; i++) {\n            logSum -= Math.log((double) i);\n        }\n\n        return logSum;      \n    }\n    \n    \n    public static double cosh(double x) {\n        return (Math.exp(x) + Math.exp(-x)) / 2.0;\n    }\n    \n    \n    public static boolean equals(double x, double y) {\n        return ((Double.isNaN(x) && Double.isNaN(y)) || x == y);\n    }\n\n    \n    public static boolean equals(double x, double y, double eps) {\n      return x == y || (x < y && (x + eps) >= y) || (x > y && x <= (y + eps));\n    }\n    \n    \n    public static boolean equals(double[] x, double[] y) {\n        if ((x == null) || (y == null)) {\n            return !((x == null) ^ (y == null));\n        }\n        if (x.length != y.length) {\n            return false;\n        }\n        for (int i = 0; i < x.length; ++i) {\n            if (!equals(x[i], y[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    \n    private static final long[] factorials = new long[] {1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800, 39916800, 479001600, 6227020800l, 87178291200l, 1307674368000l, 20922789888000l, 355687428096000l, 6402373705728000l, 121645100408832000l, 2432902008176640000l}; public static long factorial(final int n) {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"must have n >= 0 for n!\");\n        }\n        if (n > 20) {\n            throw new ArithmeticException(\n                    \"factorial value is too large to fit in a long\");\n        }\n        return factorials[n];\n    }\n\n    \n    public static double factorialDouble(final int n) {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"must have n >= 0 for n!\");\n        }\n        if (n < 21) {\n            return factorial(n);\n        }\n        return Math.floor(Math.exp(factorialLog(n)) + 0.5);\n    }\n\n    \n    public static double factorialLog(final int n) {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"must have n > 0 for n!\");\n        }\n        if (n < 21) {\n            return Math.log(factorial(n));\n        }\n        double logSum = 0;\n        for (int i = 2; i <= n; i++) {\n            logSum += Math.log((double)i);\n        }\n        return logSum;\n    }\n\n    \n    public static int gcd(final int p, final int q) {\n        int u = p;\n        int v = q;\n        if ((u == 0) || (v == 0)) {\n            return (Math.abs(u) + Math.abs(v));\n        }\n        \n        \n        \n        \n        \n        if (u > 0) {\n            u = -u;\n        } \n        if (v > 0) {\n            v = -v;\n        } \n        \n        int k = 0;\n        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { \n                                                            \n            u /= 2;\n            v /= 2;\n            k++; \n        }\n        if (k == 31) {\n            throw MathRuntimeException.createArithmeticException(\n                    \"overflow: gcd({0}, {1}) is 2^31\",\n                    new Object[] { p, q });\n        }\n        \n        \n        int t = ((u & 1) == 1) ? v : -(u / 2);\n        \n        \n        do {\n            \n            \n            while ((t & 1) == 0) { \n                t /= 2; \n            }\n            \n            if (t > 0) {\n                u = -t;\n            } else {\n                v = t;\n            }\n            \n            t = (v - u) / 2;\n            \n            \n        } while (t != 0);\n        return -u * (1 << k); \n    }\n\n    \n    public static int hash(double value) {\n        return new Double(value).hashCode();\n    }\n\n    \n    public static int hash(double[] value) {\n        return Arrays.hashCode(value);\n    }\n\n    \n    public static byte indicator(final byte x) {\n        return (x >= ZB) ? PB : NB;\n    }\n\n    \n    public static double indicator(final double x) {\n        if (Double.isNaN(x)) {\n            return Double.NaN;\n        }\n        return (x >= 0.0) ? 1.0 : -1.0;\n    }\n\n    \n    public static float indicator(final float x) {\n        if (Float.isNaN(x)) {\n            return Float.NaN;\n        }\n        return (x >= 0.0F) ? 1.0F : -1.0F;\n    }\n\n    \n    public static int indicator(final int x) {\n        return (x >= 0) ? 1 : -1;\n    }\n\n    \n    public static long indicator(final long x) {\n        return (x >= 0L) ? 1L : -1L;\n    }\n\n    \n    public static short indicator(final short x) {\n        return (x >= ZS) ? PS : NS;\n    }\n\n    \n    public static int lcm(int a, int b) {\n        if (a==0 || b==0){\n            return 0;\n        }\n        int lcm = Math.abs(mulAndCheck(a / gcd(a, b), b));\n        return lcm;\n    }\n\n     \n    public static double log(double base, double x) {\n        return Math.log(x)/Math.log(base);\n    }\n\n    \n    public static int mulAndCheck(int x, int y) {\n        long m = ((long)x) * ((long)y);\n        if (m < Integer.MIN_VALUE || m > Integer.MAX_VALUE) {\n            throw new ArithmeticException(\"overflow: mul\");\n        }\n        return (int)m;\n    }\n\n    \n    public static long mulAndCheck(long a, long b) {\n        long ret;\n        String msg = \"overflow: multiply\";\n        if (a > b) {\n            \n            ret = mulAndCheck(b, a);\n        } else {\n            if (a < 0) {\n                if (b < 0) {\n                    \n                    if (a >= Long.MAX_VALUE / b) {\n                        ret = a * b;\n                    } else {\n                        throw new ArithmeticException(msg);\n                    }\n                } else if (b > 0) {\n                    \n                    if (Long.MIN_VALUE / b <= a) {\n                        ret = a * b;\n                    } else {\n                        throw new ArithmeticException(msg);\n                        \n                    }\n                } else {\n                    \n                    ret = 0;\n                }\n            } else if (a > 0) {\n                \n                \n                \n                \n                if (a <= Long.MAX_VALUE / b) {\n                    ret = a * b;\n                } else {\n                    throw new ArithmeticException(msg);\n                }\n            } else {\n                \n                ret = 0;\n            }\n        }\n        return ret;\n    }\n\n    \n    public static double nextAfter(double d, double direction) {\n\n        \n        if (Double.isNaN(d) || Double.isInfinite(d)) {\n                return d;\n        } else if (d == 0) {\n                return (direction < 0) ? -Double.MIN_VALUE : Double.MIN_VALUE;\n        }\n        \n        \n\n        \n        long bits     = Double.doubleToLongBits(d);\n        long sign     = bits & 0x8000000000000000L;\n        long exponent = bits & 0x7ff0000000000000L;\n        long mantissa = bits & 0x000fffffffffffffL;\n\n        if (d * (direction - d) >= 0) {\n                \n                if (mantissa == 0x000fffffffffffffL) {\n                        return Double.longBitsToDouble(sign |\n                                        (exponent + 0x0010000000000000L));\n                } else {\n                        return Double.longBitsToDouble(sign |\n                                        exponent | (mantissa + 1));\n                }\n        } else {\n                \n                if (mantissa == 0L) {\n                        return Double.longBitsToDouble(sign |\n                                        (exponent - 0x0010000000000000L) |\n                                        0x000fffffffffffffL);\n                } else {\n                        return Double.longBitsToDouble(sign |\n                                        exponent | (mantissa - 1));\n                }\n        }\n\n    }\n\n    \n    public static double scalb(final double d, final int scaleFactor) {\n\n        \n        if ((d == 0) || Double.isNaN(d) || Double.isInfinite(d)) {\n            return d;\n        }\n\n        \n        final long bits     = Double.doubleToLongBits(d);\n        final long exponent = bits & 0x7ff0000000000000L;\n        final long rest     = bits & 0x800fffffffffffffL;\n\n        \n        final long newBits = rest | (exponent + (((long) scaleFactor) << 52));\n        return Double.longBitsToDouble(newBits);\n\n    }\n\n    \n     public static double normalizeAngle(double a, double center) {\n         return a - TWO_PI * Math.floor((a + Math.PI - center) / TWO_PI);\n     }\n\n    \n    public static double round(double x, int scale) {\n        return round(x, scale, BigDecimal.ROUND_HALF_UP);\n    }\n\n    \n    public static double round(double x, int scale, int roundingMethod) {\n        try {\n            return (new BigDecimal\n                   (Double.toString(x))\n                   .setScale(scale, roundingMethod))\n                   .doubleValue();\n        } catch (NumberFormatException ex) {\n            if (Double.isInfinite(x)) {\n                return x;          \n            } else {\n                return Double.NaN;\n            }\n        }\n    }\n\n    \n    public static float round(float x, int scale) {\n        return round(x, scale, BigDecimal.ROUND_HALF_UP);\n    }\n\n    \n    public static float round(float x, int scale, int roundingMethod) {\n        float sign = indicator(x);\n        float factor = (float)Math.pow(10.0f, scale) * sign;\n        return (float)roundUnscaled(x * factor, sign, roundingMethod) / factor;\n    }\n\n    \n    private static double roundUnscaled(double unscaled, double sign, int roundingMethod) {\n        switch (roundingMethod) {\n        case BigDecimal.ROUND_CEILING :\n            if (sign == -1) {\n                unscaled = Math.floor(nextAfter(unscaled, Double.NEGATIVE_INFINITY));\n            } else {\n                unscaled = Math.ceil(nextAfter(unscaled, Double.POSITIVE_INFINITY));\n            }\n            break;\n        case BigDecimal.ROUND_DOWN :\n            unscaled = Math.floor(nextAfter(unscaled, Double.NEGATIVE_INFINITY));\n            break;\n        case BigDecimal.ROUND_FLOOR :\n            if (sign == -1) {\n                unscaled = Math.ceil(nextAfter(unscaled, Double.POSITIVE_INFINITY));\n            } else {\n                unscaled = Math.floor(nextAfter(unscaled, Double.NEGATIVE_INFINITY));\n            }\n            break;\n        case BigDecimal.ROUND_HALF_DOWN : {\n            unscaled = nextAfter(unscaled, Double.NEGATIVE_INFINITY);\n            double fraction = unscaled - Math.floor(unscaled);\n            if (fraction > 0.5) {\n                unscaled = Math.ceil(unscaled);\n            } else {\n                unscaled = Math.floor(unscaled);\n            }\n            break;\n        }\n        case BigDecimal.ROUND_HALF_EVEN : {\n            double fraction = unscaled - Math.floor(unscaled);\n            if (fraction > 0.5) {\n                unscaled = Math.ceil(unscaled);\n            } else if (fraction < 0.5) {\n                unscaled = Math.floor(unscaled);\n            } else {\n                \n                if (Math.floor(unscaled) / 2.0 == Math.floor(Math\n                    .floor(unscaled) / 2.0)) { \n                    unscaled = Math.floor(unscaled);\n                } else { \n                    unscaled = Math.ceil(unscaled);\n                }\n            }\n            break;\n        }\n        case BigDecimal.ROUND_HALF_UP : {\n            unscaled = nextAfter(unscaled, Double.POSITIVE_INFINITY);\n            double fraction = unscaled - Math.floor(unscaled);\n            if (fraction >= 0.5) {\n                unscaled = Math.ceil(unscaled);\n            } else {\n                unscaled = Math.floor(unscaled);\n            }\n            break;\n        }\n        case BigDecimal.ROUND_UNNECESSARY :\n            if (unscaled != Math.floor(unscaled)) {\n                throw new ArithmeticException(\"Inexact result from rounding\");\n            }\n            break;\n        case BigDecimal.ROUND_UP :\n            unscaled = Math.ceil(nextAfter(unscaled,  Double.POSITIVE_INFINITY));\n            break;\n        default :\n            throw new IllegalArgumentException(\"Invalid rounding method.\");\n        }\n        return unscaled;\n    }\n\n    \n    public static byte sign(final byte x) {\n        return (x == ZB) ? ZB : (x > ZB) ? PB : NB;\n    }\n\n    \n    public static double sign(final double x) {\n        if (Double.isNaN(x)) {\n            return Double.NaN;\n        }\n        return (x == 0.0) ? 0.0 : (x > 0.0) ? 1.0 : -1.0;\n    }\n\n    \n    public static float sign(final float x) {\n        if (Float.isNaN(x)) {\n            return Float.NaN;\n        }\n        return (x == 0.0F) ? 0.0F : (x > 0.0F) ? 1.0F : -1.0F;\n    }\n\n    \n    public static int sign(final int x) {\n        return (x == 0) ? 0 : (x > 0) ? 1 : -1;\n    }\n\n    \n    public static long sign(final long x) {\n        return (x == 0L) ? 0L : (x > 0L) ? 1L : -1L;\n    }\n\n    \n    public static short sign(final short x) {\n        return (x == ZS) ? ZS : (x > ZS) ? PS : NS;\n    }\n\n    \n    public static double sinh(double x) {\n        return (Math.exp(x) - Math.exp(-x)) / 2.0;\n    }\n\n    \n    public static int subAndCheck(int x, int y) {\n        long s = (long)x - (long)y;\n        if (s < Integer.MIN_VALUE || s > Integer.MAX_VALUE) {\n            throw new ArithmeticException(\"overflow: subtract\");\n        }\n        return (int)s;\n    }\n\n    \n    public static long subAndCheck(long a, long b) {\n        long ret;\n        String msg = \"overflow: subtract\";\n        if (b == Long.MIN_VALUE) {\n            if (a < 0) {\n                ret = a - b;\n            } else {\n                throw new ArithmeticException(msg);\n            }\n        } else {\n            \n            ret = addAndCheck(a, -b, msg);\n        }\n        return ret;\n    }\n\n}\n",
      "fixed_full_code": "\n\npackage org.apache.commons.math.util;\n\nimport java.math.BigDecimal;\nimport java.util.Arrays;\n\nimport org.apache.commons.math.MathException;\nimport org.apache.commons.math.MathRuntimeException;\n\n\npublic final class MathUtils { public static final double EPSILON = 0x1.0p-53; public static final double SAFE_MIN = 0x1.0p-1022; private static final byte NB = (byte)-1; private static final short NS = (short)-1; private static final byte PB = (byte)1; private static final short PS = (short)1; private static final byte ZB = (byte)0; private static final short ZS = (short)0; private static final double TWO_PI = 2 * Math.PI; private MathUtils() {\n        super();\n    }\n\n    \n    public static int addAndCheck(int x, int y) {\n        long s = (long)x + (long)y;\n        if (s < Integer.MIN_VALUE || s > Integer.MAX_VALUE) {\n            throw new ArithmeticException(\"overflow: add\");\n        }\n        return (int)s;\n    }\n\n    \n    public static long addAndCheck(long a, long b) {\n        return addAndCheck(a, b, \"overflow: add\");\n    }\n    \n    \n    private static long addAndCheck(long a, long b, String msg) {\n        long ret;\n        if (a > b) {\n            \n            ret = addAndCheck(b, a, msg);\n        } else {\n            \n            \n            if (a < 0) {\n                if (b < 0) {\n                    \n                    if (Long.MIN_VALUE - b <= a) {\n                        ret = a + b;\n                    } else {\n                        throw new ArithmeticException(msg);\n                    }\n                } else {\n                    \n                    ret = a + b;\n                }\n            } else {\n                \n                \n\n                \n                if (a <= Long.MAX_VALUE - b) {\n                    ret = a + b;\n                } else {\n                    throw new ArithmeticException(msg);\n                }\n            }\n        }\n        return ret;\n    }\n    \n    \n    public static long binomialCoefficient(final int n, final int k) {\n        if (n < k) {\n            throw new IllegalArgumentException(\n                \"must have n >= k for binomial coefficient (n,k)\");\n        }\n        if (n < 0) {\n            throw new IllegalArgumentException(\n                \"must have n >= 0 for binomial coefficient (n,k)\");\n        }\n        if ((n == k) || (k == 0)) {\n            return 1;\n        }\n        if ((k == 1) || (k == n - 1)) {\n            return n;\n        }\n        \n        if (k > n / 2)\n            return binomialCoefficient(n, n - k);\n        \n        \n        \n        \n        \n        \n        long result = 1;\n        if (n <= 61) {\n            \n            for (int j = 1, i = n - k + 1; j <= k; i++, j++) {\n                result = result * i / j;\n            }\n        } else if (n <= 66) {\n            \n            \n            for (int j = 1, i = n - k + 1; j <= k; i++, j++) {\n                \n                \n                \n                \n                \n                \n                long d = gcd(i, j);\n                result = (result / (j / d)) * (i / d);\n            }\n        } else {\n            \n            \n            \n            for (int j = 1, i = n - k + 1; j <= k; i++, j++) {\n                long d = gcd(i, j);\n                result = mulAndCheck((result / (j / d)), (i / d));\n            }\n        }\n        return result;\n    }\n\n    \n    public static double binomialCoefficientDouble(final int n, final int k) {\n        if (n < k) {\n            throw new IllegalArgumentException(\n                \"must have n >= k for binomial coefficient (n,k)\");\n        }\n        if (n < 0) {\n            throw new IllegalArgumentException(\n                \"must have n >= 0 for binomial coefficient (n,k)\");\n        }\n        if ((n == k) || (k == 0)) {\n            return 1d;\n        }\n        if ((k == 1) || (k == n - 1)) {\n            return n;\n        }\n        if (k > n/2) {\n            return binomialCoefficientDouble(n, n - k);\n        }\n        if (n < 67) {\n            return binomialCoefficient(n,k);\n        }\n        \n        double result = 1d;\n        for (int i = 1; i <= k; i++) {\n             result *= (double)(n - k + i) / (double)i;\n        }\n  \n        return Math.floor(result + 0.5);\n    }\n    \n    \n    public static double binomialCoefficientLog(final int n, final int k) {\n        if (n < k) {\n            throw new IllegalArgumentException(\n                \"must have n >= k for binomial coefficient (n,k)\");\n        }\n        if (n < 0) {\n            throw new IllegalArgumentException(\n                \"must have n >= 0 for binomial coefficient (n,k)\");\n        }\n        if ((n == k) || (k == 0)) {\n            return 0;\n        }\n        if ((k == 1) || (k == n - 1)) {\n            return Math.log((double) n);\n        }\n        \n        \n        if (n < 67) {  \n            return Math.log(binomialCoefficient(n,k));\n        }\n        \n        \n        if (n < 1030) { \n            return Math.log(binomialCoefficientDouble(n, k));\n        } \n\n        if (k > n / 2) {\n            return binomialCoefficientLog(n, n - k);\n        }\n\n        \n        double logSum = 0;\n\n        \n        for (int i = n - k + 1; i <= n; i++) {\n            logSum += Math.log((double) i);\n        }\n\n        \n        for (int i = 2; i <= k; i++) {\n            logSum -= Math.log((double) i);\n        }\n\n        return logSum;      \n    }\n    \n    \n    public static double cosh(double x) {\n        return (Math.exp(x) + Math.exp(-x)) / 2.0;\n    }\n    \n    \n    public static boolean equals(double x, double y) {\n        return ((Double.isNaN(x) && Double.isNaN(y)) || x == y);\n    }\n\n    \n    public static boolean equals(double x, double y, double eps) {\n      return x == y || (x < y && (x + eps) >= y) || (x > y && x <= (y + eps));\n    }\n    \n    \n    public static boolean equals(double[] x, double[] y) {\n        if ((x == null) || (y == null)) {\n            return !((x == null) ^ (y == null));\n        }\n        if (x.length != y.length) {\n            return false;\n        }\n        for (int i = 0; i < x.length; ++i) {\n            if (!equals(x[i], y[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    \n    private static final long[] factorials = new long[] {1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800, 39916800, 479001600, 6227020800l, 87178291200l, 1307674368000l, 20922789888000l, 355687428096000l, 6402373705728000l, 121645100408832000l, 2432902008176640000l}; public static long factorial(final int n) {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"must have n >= 0 for n!\");\n        }\n        if (n > 20) {\n            throw new ArithmeticException(\n                    \"factorial value is too large to fit in a long\");\n        }\n        return factorials[n];\n    }\n\n    \n    public static double factorialDouble(final int n) {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"must have n >= 0 for n!\");\n        }\n        if (n < 21) {\n            return factorial(n);\n        }\n        return Math.floor(Math.exp(factorialLog(n)) + 0.5);\n    }\n\n    \n    public static double factorialLog(final int n) {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"must have n > 0 for n!\");\n        }\n        if (n < 21) {\n            return Math.log(factorial(n));\n        }\n        double logSum = 0;\n        for (int i = 2; i <= n; i++) {\n            logSum += Math.log((double)i);\n        }\n        return logSum;\n    }\n\n    \n    public static int gcd(final int p, final int q) {\n        int u = p;\n        int v = q;\n        if ((u == 0) || (v == 0)) {\n            if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) {\n                throw MathRuntimeException.createArithmeticException(\n                        \"overflow: gcd({0}, {1}) is 2^31\",\n                        new Object[] { p, q });\n            }\n            return (Math.abs(u) + Math.abs(v));\n        }\n        \n        \n        \n        \n        \n        if (u > 0) {\n            u = -u;\n        } \n        if (v > 0) {\n            v = -v;\n        } \n        \n        int k = 0;\n        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { \n                                                            \n            u /= 2;\n            v /= 2;\n            k++; \n        }\n        if (k == 31) {\n            throw MathRuntimeException.createArithmeticException(\n                    \"overflow: gcd({0}, {1}) is 2^31\",\n                    new Object[] { p, q });\n        }\n        \n        \n        int t = ((u & 1) == 1) ? v : -(u / 2);\n        \n        \n        do {\n            \n            \n            while ((t & 1) == 0) { \n                t /= 2; \n            }\n            \n            if (t > 0) {\n                u = -t;\n            } else {\n                v = t;\n            }\n            \n            t = (v - u) / 2;\n            \n            \n        } while (t != 0);\n        return -u * (1 << k); \n    }\n\n    \n    public static int hash(double value) {\n        return new Double(value).hashCode();\n    }\n\n    \n    public static int hash(double[] value) {\n        return Arrays.hashCode(value);\n    }\n\n    \n    public static byte indicator(final byte x) {\n        return (x >= ZB) ? PB : NB;\n    }\n\n    \n    public static double indicator(final double x) {\n        if (Double.isNaN(x)) {\n            return Double.NaN;\n        }\n        return (x >= 0.0) ? 1.0 : -1.0;\n    }\n\n    \n    public static float indicator(final float x) {\n        if (Float.isNaN(x)) {\n            return Float.NaN;\n        }\n        return (x >= 0.0F) ? 1.0F : -1.0F;\n    }\n\n    \n    public static int indicator(final int x) {\n        return (x >= 0) ? 1 : -1;\n    }\n\n    \n    public static long indicator(final long x) {\n        return (x >= 0L) ? 1L : -1L;\n    }\n\n    \n    public static short indicator(final short x) {\n        return (x >= ZS) ? PS : NS;\n    }\n\n    \n    public static int lcm(int a, int b) {\n        if (a==0 || b==0){\n            return 0;\n        }\n        int lcm = Math.abs(mulAndCheck(a / gcd(a, b), b));\n        if (lcm == Integer.MIN_VALUE){\n            throw new ArithmeticException(\"overflow: lcm is 2^31\");\n        }\n        return lcm;\n    }\n\n     \n    public static double log(double base, double x) {\n        return Math.log(x)/Math.log(base);\n    }\n\n    \n    public static int mulAndCheck(int x, int y) {\n        long m = ((long)x) * ((long)y);\n        if (m < Integer.MIN_VALUE || m > Integer.MAX_VALUE) {\n            throw new ArithmeticException(\"overflow: mul\");\n        }\n        return (int)m;\n    }\n\n    \n    public static long mulAndCheck(long a, long b) {\n        long ret;\n        String msg = \"overflow: multiply\";\n        if (a > b) {\n            \n            ret = mulAndCheck(b, a);\n        } else {\n            if (a < 0) {\n                if (b < 0) {\n                    \n                    if (a >= Long.MAX_VALUE / b) {\n                        ret = a * b;\n                    } else {\n                        throw new ArithmeticException(msg);\n                    }\n                } else if (b > 0) {\n                    \n                    if (Long.MIN_VALUE / b <= a) {\n                        ret = a * b;\n                    } else {\n                        throw new ArithmeticException(msg);\n                        \n                    }\n                } else {\n                    \n                    ret = 0;\n                }\n            } else if (a > 0) {\n                \n                \n                \n                \n                if (a <= Long.MAX_VALUE / b) {\n                    ret = a * b;\n                } else {\n                    throw new ArithmeticException(msg);\n                }\n            } else {\n                \n                ret = 0;\n            }\n        }\n        return ret;\n    }\n\n    \n    public static double nextAfter(double d, double direction) {\n\n        \n        if (Double.isNaN(d) || Double.isInfinite(d)) {\n                return d;\n        } else if (d == 0) {\n                return (direction < 0) ? -Double.MIN_VALUE : Double.MIN_VALUE;\n        }\n        \n        \n\n        \n        long bits     = Double.doubleToLongBits(d);\n        long sign     = bits & 0x8000000000000000L;\n        long exponent = bits & 0x7ff0000000000000L;\n        long mantissa = bits & 0x000fffffffffffffL;\n\n        if (d * (direction - d) >= 0) {\n                \n                if (mantissa == 0x000fffffffffffffL) {\n                        return Double.longBitsToDouble(sign |\n                                        (exponent + 0x0010000000000000L));\n                } else {\n                        return Double.longBitsToDouble(sign |\n                                        exponent | (mantissa + 1));\n                }\n        } else {\n                \n                if (mantissa == 0L) {\n                        return Double.longBitsToDouble(sign |\n                                        (exponent - 0x0010000000000000L) |\n                                        0x000fffffffffffffL);\n                } else {\n                        return Double.longBitsToDouble(sign |\n                                        exponent | (mantissa - 1));\n                }\n        }\n\n    }\n\n    \n    public static double scalb(final double d, final int scaleFactor) {\n\n        \n        if ((d == 0) || Double.isNaN(d) || Double.isInfinite(d)) {\n            return d;\n        }\n\n        \n        final long bits     = Double.doubleToLongBits(d);\n        final long exponent = bits & 0x7ff0000000000000L;\n        final long rest     = bits & 0x800fffffffffffffL;\n\n        \n        final long newBits = rest | (exponent + (((long) scaleFactor) << 52));\n        return Double.longBitsToDouble(newBits);\n\n    }\n\n    \n     public static double normalizeAngle(double a, double center) {\n         return a - TWO_PI * Math.floor((a + Math.PI - center) / TWO_PI);\n     }\n\n    \n    public static double round(double x, int scale) {\n        return round(x, scale, BigDecimal.ROUND_HALF_UP);\n    }\n\n    \n    public static double round(double x, int scale, int roundingMethod) {\n        try {\n            return (new BigDecimal\n                   (Double.toString(x))\n                   .setScale(scale, roundingMethod))\n                   .doubleValue();\n        } catch (NumberFormatException ex) {\n            if (Double.isInfinite(x)) {\n                return x;          \n            } else {\n                return Double.NaN;\n            }\n        }\n    }\n\n    \n    public static float round(float x, int scale) {\n        return round(x, scale, BigDecimal.ROUND_HALF_UP);\n    }\n\n    \n    public static float round(float x, int scale, int roundingMethod) {\n        float sign = indicator(x);\n        float factor = (float)Math.pow(10.0f, scale) * sign;\n        return (float)roundUnscaled(x * factor, sign, roundingMethod) / factor;\n    }\n\n    \n    private static double roundUnscaled(double unscaled, double sign, int roundingMethod) {\n        switch (roundingMethod) {\n        case BigDecimal.ROUND_CEILING :\n            if (sign == -1) {\n                unscaled = Math.floor(nextAfter(unscaled, Double.NEGATIVE_INFINITY));\n            } else {\n                unscaled = Math.ceil(nextAfter(unscaled, Double.POSITIVE_INFINITY));\n            }\n            break;\n        case BigDecimal.ROUND_DOWN :\n            unscaled = Math.floor(nextAfter(unscaled, Double.NEGATIVE_INFINITY));\n            break;\n        case BigDecimal.ROUND_FLOOR :\n            if (sign == -1) {\n                unscaled = Math.ceil(nextAfter(unscaled, Double.POSITIVE_INFINITY));\n            } else {\n                unscaled = Math.floor(nextAfter(unscaled, Double.NEGATIVE_INFINITY));\n            }\n            break;\n        case BigDecimal.ROUND_HALF_DOWN : {\n            unscaled = nextAfter(unscaled, Double.NEGATIVE_INFINITY);\n            double fraction = unscaled - Math.floor(unscaled);\n            if (fraction > 0.5) {\n                unscaled = Math.ceil(unscaled);\n            } else {\n                unscaled = Math.floor(unscaled);\n            }\n            break;\n        }\n        case BigDecimal.ROUND_HALF_EVEN : {\n            double fraction = unscaled - Math.floor(unscaled);\n            if (fraction > 0.5) {\n                unscaled = Math.ceil(unscaled);\n            } else if (fraction < 0.5) {\n                unscaled = Math.floor(unscaled);\n            } else {\n                \n                if (Math.floor(unscaled) / 2.0 == Math.floor(Math\n                    .floor(unscaled) / 2.0)) { \n                    unscaled = Math.floor(unscaled);\n                } else { \n                    unscaled = Math.ceil(unscaled);\n                }\n            }\n            break;\n        }\n        case BigDecimal.ROUND_HALF_UP : {\n            unscaled = nextAfter(unscaled, Double.POSITIVE_INFINITY);\n            double fraction = unscaled - Math.floor(unscaled);\n            if (fraction >= 0.5) {\n                unscaled = Math.ceil(unscaled);\n            } else {\n                unscaled = Math.floor(unscaled);\n            }\n            break;\n        }\n        case BigDecimal.ROUND_UNNECESSARY :\n            if (unscaled != Math.floor(unscaled)) {\n                throw new ArithmeticException(\"Inexact result from rounding\");\n            }\n            break;\n        case BigDecimal.ROUND_UP :\n            unscaled = Math.ceil(nextAfter(unscaled,  Double.POSITIVE_INFINITY));\n            break;\n        default :\n            throw new IllegalArgumentException(\"Invalid rounding method.\");\n        }\n        return unscaled;\n    }\n\n    \n    public static byte sign(final byte x) {\n        return (x == ZB) ? ZB : (x > ZB) ? PB : NB;\n    }\n\n    \n    public static double sign(final double x) {\n        if (Double.isNaN(x)) {\n            return Double.NaN;\n        }\n        return (x == 0.0) ? 0.0 : (x > 0.0) ? 1.0 : -1.0;\n    }\n\n    \n    public static float sign(final float x) {\n        if (Float.isNaN(x)) {\n            return Float.NaN;\n        }\n        return (x == 0.0F) ? 0.0F : (x > 0.0F) ? 1.0F : -1.0F;\n    }\n\n    \n    public static int sign(final int x) {\n        return (x == 0) ? 0 : (x > 0) ? 1 : -1;\n    }\n\n    \n    public static long sign(final long x) {\n        return (x == 0L) ? 0L : (x > 0L) ? 1L : -1L;\n    }\n\n    \n    public static short sign(final short x) {\n        return (x == ZS) ? ZS : (x > ZS) ? PS : NS;\n    }\n\n    \n    public static double sinh(double x) {\n        return (Math.exp(x) - Math.exp(-x)) / 2.0;\n    }\n\n    \n    public static int subAndCheck(int x, int y) {\n        long s = (long)x - (long)y;\n        if (s < Integer.MIN_VALUE || s > Integer.MAX_VALUE) {\n            throw new ArithmeticException(\"overflow: subtract\");\n        }\n        return (int)s;\n    }\n\n    \n    public static long subAndCheck(long a, long b) {\n        long ret;\n        String msg = \"overflow: subtract\";\n        if (b == Long.MIN_VALUE) {\n            if (a < 0) {\n                ret = a - b;\n            } else {\n                throw new ArithmeticException(msg);\n            }\n        } else {\n            \n            ret = addAndCheck(a, -b, msg);\n        }\n        return ret;\n    }\n\n}\n",
      "buggy_signatures": [
        "public static int addAndCheck(int x, int y)",
        "public static long addAndCheck(long a, long b)",
        "private static long addAndCheck(long a, long b, String msg)",
        "public static long binomialCoefficient(final int n, final int k)",
        "public static double binomialCoefficientDouble(final int n, final int k)",
        "public static double binomialCoefficientLog(final int n, final int k)",
        "public static double cosh(double x)",
        "public static boolean equals(double x, double y)",
        "public static boolean equals(double x, double y, double eps)",
        "public static boolean equals(double[] x, double[] y)",
        "public static double factorialDouble(final int n)",
        "public static double factorialLog(final int n)",
        "public static int gcd(final int p, final int q)",
        "public static int hash(double value)",
        "public static int hash(double[] value)",
        "public static byte indicator(final byte x)",
        "public static double indicator(final double x)",
        "public static float indicator(final float x)",
        "public static int indicator(final int x)",
        "public static long indicator(final long x)",
        "public static short indicator(final short x)",
        "public static int lcm(int a, int b)",
        "public static double log(double base, double x)",
        "public static int mulAndCheck(int x, int y)",
        "public static long mulAndCheck(long a, long b)",
        "public static double nextAfter(double d, double direction)",
        "public static double scalb(final double d, final int scaleFactor)",
        "public static double normalizeAngle(double a, double center)",
        "public static double round(double x, int scale)",
        "public static double round(double x, int scale, int roundingMethod)",
        "public static float round(float x, int scale)",
        "public static float round(float x, int scale, int roundingMethod)",
        "private static double roundUnscaled(double unscaled, double sign, int roundingMethod)",
        "public static byte sign(final byte x)",
        "public static double sign(final double x)",
        "public static float sign(final float x)",
        "public static int sign(final int x)",
        "public static long sign(final long x)",
        "public static short sign(final short x)",
        "public static double sinh(double x)",
        "public static int subAndCheck(int x, int y)",
        "public static long subAndCheck(long a, long b)"
      ],
      "fixed_signatures": [
        "public static int addAndCheck(int x, int y)",
        "public static long addAndCheck(long a, long b)",
        "private static long addAndCheck(long a, long b, String msg)",
        "public static long binomialCoefficient(final int n, final int k)",
        "public static double binomialCoefficientDouble(final int n, final int k)",
        "public static double binomialCoefficientLog(final int n, final int k)",
        "public static double cosh(double x)",
        "public static boolean equals(double x, double y)",
        "public static boolean equals(double x, double y, double eps)",
        "public static boolean equals(double[] x, double[] y)",
        "public static double factorialDouble(final int n)",
        "public static double factorialLog(final int n)",
        "public static int gcd(final int p, final int q)",
        "public static int hash(double value)",
        "public static int hash(double[] value)",
        "public static byte indicator(final byte x)",
        "public static double indicator(final double x)",
        "public static float indicator(final float x)",
        "public static int indicator(final int x)",
        "public static long indicator(final long x)",
        "public static short indicator(final short x)",
        "public static int lcm(int a, int b)",
        "public static double log(double base, double x)",
        "public static int mulAndCheck(int x, int y)",
        "public static long mulAndCheck(long a, long b)",
        "public static double nextAfter(double d, double direction)",
        "public static double scalb(final double d, final int scaleFactor)",
        "public static double normalizeAngle(double a, double center)",
        "public static double round(double x, int scale)",
        "public static double round(double x, int scale, int roundingMethod)",
        "public static float round(float x, int scale)",
        "public static float round(float x, int scale, int roundingMethod)",
        "private static double roundUnscaled(double unscaled, double sign, int roundingMethod)",
        "public static byte sign(final byte x)",
        "public static double sign(final double x)",
        "public static float sign(final float x)",
        "public static int sign(final int x)",
        "public static long sign(final long x)",
        "public static short sign(final short x)",
        "public static double sinh(double x)",
        "public static int subAndCheck(int x, int y)",
        "public static long subAndCheck(long a, long b)"
      ],
      "methods": [
        {
          "buggy_method": "  public static int gcd(final int p, final int q) {\n  int u = p;\n  int v = q;\n  if ((u == 0) || (v == 0)) {\n  return (Math.abs(u) + Math.abs(v));\n  }\n  \n  \n  \n  \n  \n  if (u > 0) {\n  u = -u;\n  } \n  if (v > 0) {\n  v = -v;\n  } \n  \n  int k = 0;\n  while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { \n  \n  u /= 2;\n  v /= 2;\n  k++; \n  }\n  if (k == 31) {\n  throw MathRuntimeException.createArithmeticException(\n  \"overflow: gcd({0}, {1}) is 2^31\",\n  new Object[] { p, q });\n  }\n  \n  \n  int t = ((u & 1) == 1) ? v : -(u / 2);\n  \n  \n  do {\n  \n  \n  while ((t & 1) == 0) { \n  t /= 2; \n  }\n  \n  if (t > 0) {\n  u = -t;\n  } else {\n  v = t;\n  }\n  \n  t = (v - u) / 2;\n  \n  \n  } while (t != 0);\n  return -u * (1 << k); \n  }",
          "fixed_method": "  public static int gcd(final int p, final int q) {\n  int u = p;\n  int v = q;\n  if ((u == 0) || (v == 0)) {\n  if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) {\n  throw MathRuntimeException.createArithmeticException(\n  \"overflow: gcd({0}, {1}) is 2^31\",\n  new Object[] { p, q });\n  }\n  return (Math.abs(u) + Math.abs(v));\n  }\n  \n  \n  \n  \n  \n  if (u > 0) {\n  u = -u;\n  } \n  if (v > 0) {\n  v = -v;\n  } \n  \n  int k = 0;\n  while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { \n  \n  u /= 2;\n  v /= 2;\n  k++; \n  }\n  if (k == 31) {\n  throw MathRuntimeException.createArithmeticException(\n  \"overflow: gcd({0}, {1}) is 2^31\",\n  new Object[] { p, q });\n  }\n  \n  \n  int t = ((u & 1) == 1) ? v : -(u / 2);\n  \n  \n  do {\n  \n  \n  while ((t & 1) == 0) { \n  t /= 2; \n  }\n  \n  if (t > 0) {\n  u = -t;\n  } else {\n  v = t;\n  }\n  \n  t = (v - u) / 2;\n  \n  \n  } while (t != 0);\n  return -u * (1 << k); \n  }",
          "diff": [
            "@@ -540,6 +540,11 @@",
            "         int u = p;\n",
            "         int v = q;\n",
            "         if ((u == 0) || (v == 0)) {\n",
            "+            if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) {\n",
            "+                throw MathRuntimeException.createArithmeticException(\n",
            "+                        \"overflow: gcd({0}, {1}) is 2^31\",\n",
            "+                        new Object[] { p, q });\n",
            "+            }\n",
            "             return (Math.abs(u) + Math.abs(v));\n",
            "         }\n",
            "         // keep u and v negative, as negative integers range down to\n"
          ],
          "changed_lines": 5
        },
        {
          "buggy_method": "  public static int lcm(int a, int b) {\n  if (a==0 || b==0){\n  return 0;\n  }\n  int lcm = Math.abs(mulAndCheck(a / gcd(a, b), b));\n  return lcm;\n  }",
          "fixed_method": "  public static int lcm(int a, int b) {\n  if (a==0 || b==0){\n  return 0;\n  }\n  int lcm = Math.abs(mulAndCheck(a / gcd(a, b), b));\n  if (lcm == Integer.MIN_VALUE){\n  throw new ArithmeticException(\"overflow: lcm is 2^31\");\n  }\n  return lcm;\n  }",
          "diff": [
            "@@ -711,6 +716,9 @@",
            "             return 0;\n",
            "         }\n",
            "         int lcm = Math.abs(mulAndCheck(a / gcd(a, b), b));\n",
            "+        if (lcm == Integer.MIN_VALUE){\n",
            "+            throw new ArithmeticException(\"overflow: lcm is 2^31\");\n",
            "+        }\n",
            "         return lcm;\n",
            "     }\n",
            " \n"
          ],
          "changed_lines": 3
        }
      ]
    }
  ]
}
