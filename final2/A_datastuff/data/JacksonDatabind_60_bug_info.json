{
  "bug_id": "60",
  "failed_tests": {
    "com.fasterxml.jackson.databind.jsontype.TestDefaultWithCreators": [
      {
        "methodName": "testWithCreatorAndJsonValue",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<class com.fasterxml.jackson.databind.jsontype.TestDefaultWithCreators$Bean1385> but was:<class [B>",
        "fail_line": "        assertEquals(Bean1385.class, result.value.getClass());",
        "test_source": "  public void testWithCreatorAndJsonValue() throws Exception {\n  final byte[] BYTES = new byte[] { 1, 2, 3, 4, 5 };\n  ObjectMapper mapper = new ObjectMapper();\n  mapper.enableDefaultTyping();\n  String json = mapper.writeValueAsString(new Bean1385Wrapper(\n  new Bean1385(BYTES)\n  ));\n  Bean1385Wrapper result = mapper.readValue(json, Bean1385Wrapper.class);\n  assertNotNull(result);\n  assertNotNull(result.value);\n  assertEquals(Bean1385.class, result.value.getClass());\n  Bean1385 b = (Bean1385) result.value;\n  Assert.assertArrayEquals(BYTES, b.raw);\n  }",
        "stack": [
          "TestDefaultWithCreators.testWithCreatorAndJsonValue line 94"
        ]
      }
    ],
    "com.fasterxml.jackson.databind.jsontype.ext.ExternalTypeIdTest": [
      {
        "methodName": "testWithAsValue",
        "error": "junit.framework.ComparisonFailure",
        "message": "expected:<...alue\":12345,\"type\":\"[thingy]\"}> but was:<...alue\":12345,\"type\":\"[date]\"}>",
        "fail_line": "        assertEquals(\"{\\\"value\\\":12345,\\\"type\\\":\\\"thingy\\\"}\", json);",
        "test_source": "  public void testWithAsValue() throws Exception {\n  ExternalTypeWithNonPOJO input = new ExternalTypeWithNonPOJO(new AsValueThingy(12345L));\n  String json = MAPPER.writeValueAsString(input);\n  assertNotNull(json);\n  assertEquals(\"{\\\"value\\\":12345,\\\"type\\\":\\\"thingy\\\"}\", json);\n\n  // and get it back too:\n  ExternalTypeWithNonPOJO result = MAPPER.readValue(json, ExternalTypeWithNonPOJO.class);\n  assertNotNull(result);\n  assertNotNull(result.value);\n  assertEquals(AsValueThingy.class, result.value.getClass());\n  assertEquals(12345L, ((AsValueThingy) result.value).rawDate);\n  }",
        "stack": [
          "ExternalTypeIdTest.testWithAsValue line 476"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "com/fasterxml/jackson/databind/ser/std/JsonValueSerializer.java",
      "buggy_full_code": "package com.fasterxml.jackson.databind.ser.std;\n\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Type;\nimport java.util.LinkedHashSet;\nimport java.util.Set;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\nimport com.fasterxml.jackson.databind.introspect.AnnotatedMethod;\nimport com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitable;\nimport com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\nimport com.fasterxml.jackson.databind.jsonFormatVisitors.JsonStringFormatVisitor;\nimport com.fasterxml.jackson.databind.jsonschema.SchemaAware;\nimport com.fasterxml.jackson.databind.jsontype.TypeSerializer;\nimport com.fasterxml.jackson.databind.ser.BeanSerializer;\nimport com.fasterxml.jackson.databind.ser.ContextualSerializer;\n\n\n@SuppressWarnings(\"serial\")\n@JacksonStdImpl\npublic class JsonValueSerializer extends StdSerializer<Object> implements ContextualSerializer, JsonFormatVisitable, SchemaAware { protected final AnnotatedMethod _accessorMethod; protected final JsonSerializer<Object> _valueSerializer; protected final BeanProperty _property; protected final boolean _forceTypeInformation; @SuppressWarnings(\"unchecked\") public JsonValueSerializer(AnnotatedMethod valueMethod, JsonSerializer<?> ser) {\n        super(valueMethod.getType());\n        _accessorMethod = valueMethod;\n        _valueSerializer = (JsonSerializer<Object>) ser;\n        _property = null;\n        _forceTypeInformation = true; \n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public JsonValueSerializer(JsonValueSerializer src, BeanProperty property, JsonSerializer<?> ser, boolean forceTypeInfo) {\n        super(_notNullClass(src.handledType()));\n        _accessorMethod = src._accessorMethod;\n        _valueSerializer = (JsonSerializer<Object>) ser;\n        _property = property;\n        _forceTypeInformation = forceTypeInfo;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private final static Class<Object> _notNullClass(Class<?> cls) {\n        return (cls == null) ? Object.class : (Class<Object>) cls;\n    }\n    \n    public JsonValueSerializer withResolved(BeanProperty property, JsonSerializer<?> ser, boolean forceTypeInfo) {\n        if (_property == property && _valueSerializer == ser\n                && forceTypeInfo == _forceTypeInformation) {\n            return this;\n        }\n        return new JsonValueSerializer(this, property, ser, forceTypeInfo);\n    }\n    \n    \n\n    \n    @Override\n    public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException {\n        JsonSerializer<?> ser = _valueSerializer;\n        if (ser == null) {\n            \n            \n            JavaType t = _accessorMethod.getType();\n            if (provider.isEnabled(MapperFeature.USE_STATIC_TYPING) || t.isFinal()) {\n                \n                \n                \n                ser = provider.findPrimaryPropertySerializer(t, property);\n                \n                boolean forceTypeInformation = isNaturalTypeWithStdHandling(t.getRawClass(), ser);\n                return withResolved(property, ser, forceTypeInformation);\n            }\n        } else {\n            \n            ser = provider.handlePrimaryContextualization(ser, property);\n            return withResolved(property, ser, _forceTypeInformation);\n        }\n        return this;\n    }\n    \n    \n    \n    @Override\n    public void serialize(Object bean, JsonGenerator gen, SerializerProvider prov) throws IOException {\n        try {\n            Object value = _accessorMethod.getValue(bean);\n            if (value == null) {\n                prov.defaultSerializeNull(gen);\n                return;\n            }\n            JsonSerializer<Object> ser = _valueSerializer;\n            if (ser == null) {\n                Class<?> c = value.getClass();\n                \n                \n                ser = prov.findTypedValueSerializer(c, true, _property);\n            }\n            ser.serialize(value, gen, prov);\n        } catch (IOException ioe) {\n            throw ioe;\n        } catch (Exception e) {\n            Throwable t = e;\n            \n            while (t instanceof InvocationTargetException && t.getCause() != null) {\n                t = t.getCause();\n            }\n            \n            if (t instanceof Error) {\n                throw (Error) t;\n            }\n            \n            throw JsonMappingException.wrapWithPath(t, bean, _accessorMethod.getName() + \"()\");\n        }\n    }\n\n    @Override\n    public void serializeWithType(Object bean, JsonGenerator gen, SerializerProvider provider, TypeSerializer typeSer0) throws IOException {\n        \n        Object value = null;\n        try {\n            value = _accessorMethod.getValue(bean);\n            \n            if (value == null) {\n                provider.defaultSerializeNull(gen);\n                return;\n            }\n            JsonSerializer<Object> ser = _valueSerializer;\n            if (ser == null) { \n\n                ser = provider.findValueSerializer(value.getClass(), _property);\n            } else {\n                \n                if (_forceTypeInformation) {\n                    typeSer0.writeTypePrefixForScalar(bean, gen);\n                    ser.serialize(value, gen, provider);\n                    typeSer0.writeTypeSuffixForScalar(bean, gen);\n                    return;\n                }\n            }\n            \n            \n            \n            ser.serializeWithType(value, gen, provider, typeSer0);\n        } catch (IOException ioe) {\n            throw ioe;\n        } catch (Exception e) {\n            Throwable t = e;\n            \n            while (t instanceof InvocationTargetException && t.getCause() != null) {\n                t = t.getCause();\n            }\n            \n            if (t instanceof Error) {\n                throw (Error) t;\n            }\n            \n            throw JsonMappingException.wrapWithPath(t, bean, _accessorMethod.getName() + \"()\");\n        }\n    }\n    \n    @SuppressWarnings(\"deprecation\")\n    @Override\n    public JsonNode getSchema(SerializerProvider provider, Type typeHint) throws JsonMappingException {\n        if (_valueSerializer instanceof SchemaAware) {\n            return ((SchemaAware)_valueSerializer).getSchema(provider, null);\n        }\n        return com.fasterxml.jackson.databind.jsonschema.JsonSchema.getDefaultSchemaNode();\n    }\n\n    @Override\n    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n        \n        final JavaType type = _accessorMethod.getType();\n        Class<?> declaring = _accessorMethod.getDeclaringClass();\n        if ((declaring != null) && declaring.isEnum()) {\n            if (_acceptJsonFormatVisitorForEnum(visitor, typeHint, declaring)) {\n                return;\n            }\n        }\n        JsonSerializer<Object> ser = _valueSerializer;\n        if (ser == null) {\n            ser = visitor.getProvider().findTypedValueSerializer(type, false, _property);\n            if (ser == null) { \n                visitor.expectAnyFormat(typeHint);\n                return;\n            }\n        }\n        ser.acceptJsonFormatVisitor(visitor, null); \n    }\n\n    \n    protected boolean _acceptJsonFormatVisitorForEnum(JsonFormatVisitorWrapper visitor, JavaType typeHint, Class<?> enumType) throws JsonMappingException {\n        \n        JsonStringFormatVisitor stringVisitor = visitor.expectStringFormat(typeHint);\n        if (stringVisitor != null) {\n            Set<String> enums = new LinkedHashSet<String>();\n            for (Object en : enumType.getEnumConstants()) {\n                try {\n                    \n                    \n                    \n                    enums.add(String.valueOf(_accessorMethod.callOn(en)));\n                } catch (Exception e) {\n                    Throwable t = e;\n                    while (t instanceof InvocationTargetException && t.getCause() != null) {\n                        t = t.getCause();\n                    }\n                    if (t instanceof Error) {\n                        throw (Error) t;\n                    }\n                    throw JsonMappingException.wrapWithPath(t, en, _accessorMethod.getName() + \"()\");\n                }\n            }\n            stringVisitor.enumTypes(enums);\n        }\n        return true;\n    }\n\n    protected boolean isNaturalTypeWithStdHandling(Class<?> rawType, JsonSerializer<?> ser) {\n        \n        if (rawType.isPrimitive()) {\n            if (rawType != Integer.TYPE && rawType != Boolean.TYPE && rawType != Double.TYPE) {\n                return false;\n            }\n        } else {\n            if (rawType != String.class &&\n                    rawType != Integer.class && rawType != Boolean.class && rawType != Double.class) {\n                return false;\n            }\n        }\n        return isDefaultSerializer(ser);\n    }\n\n    \n\n    @Override\n    public String toString() {\n        return \"(@JsonValue serializer for method \" + _accessorMethod.getDeclaringClass() + \"#\" + _accessorMethod.getName() + \")\";\n    }\n\n    \n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n        \n\n\n\n\n\n}\n",
      "fixed_full_code": "package com.fasterxml.jackson.databind.ser.std;\n\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Type;\nimport java.util.LinkedHashSet;\nimport java.util.Set;\n\nimport com.fasterxml.jackson.annotation.JsonTypeInfo.As;\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\nimport com.fasterxml.jackson.databind.introspect.AnnotatedMethod;\nimport com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitable;\nimport com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\nimport com.fasterxml.jackson.databind.jsonFormatVisitors.JsonStringFormatVisitor;\nimport com.fasterxml.jackson.databind.jsonschema.SchemaAware;\nimport com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\nimport com.fasterxml.jackson.databind.jsontype.TypeSerializer;\nimport com.fasterxml.jackson.databind.ser.BeanSerializer;\nimport com.fasterxml.jackson.databind.ser.ContextualSerializer;\n\n\n@SuppressWarnings(\"serial\")\n@JacksonStdImpl\npublic class JsonValueSerializer extends StdSerializer<Object> implements ContextualSerializer, JsonFormatVisitable, SchemaAware { protected final AnnotatedMethod _accessorMethod; protected final JsonSerializer<Object> _valueSerializer; protected final BeanProperty _property; protected final boolean _forceTypeInformation; @SuppressWarnings(\"unchecked\") public JsonValueSerializer(AnnotatedMethod valueMethod, JsonSerializer<?> ser) {\n        super(valueMethod.getType());\n        _accessorMethod = valueMethod;\n        _valueSerializer = (JsonSerializer<Object>) ser;\n        _property = null;\n        _forceTypeInformation = true; \n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public JsonValueSerializer(JsonValueSerializer src, BeanProperty property, JsonSerializer<?> ser, boolean forceTypeInfo) {\n        super(_notNullClass(src.handledType()));\n        _accessorMethod = src._accessorMethod;\n        _valueSerializer = (JsonSerializer<Object>) ser;\n        _property = property;\n        _forceTypeInformation = forceTypeInfo;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private final static Class<Object> _notNullClass(Class<?> cls) {\n        return (cls == null) ? Object.class : (Class<Object>) cls;\n    }\n    \n    public JsonValueSerializer withResolved(BeanProperty property, JsonSerializer<?> ser, boolean forceTypeInfo) {\n        if (_property == property && _valueSerializer == ser\n                && forceTypeInfo == _forceTypeInformation) {\n            return this;\n        }\n        return new JsonValueSerializer(this, property, ser, forceTypeInfo);\n    }\n    \n    \n\n    \n    @Override\n    public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException {\n        JsonSerializer<?> ser = _valueSerializer;\n        if (ser == null) {\n            \n            \n            JavaType t = _accessorMethod.getType();\n            if (provider.isEnabled(MapperFeature.USE_STATIC_TYPING) || t.isFinal()) {\n                \n                \n                \n                ser = provider.findPrimaryPropertySerializer(t, property);\n                \n                boolean forceTypeInformation = isNaturalTypeWithStdHandling(t.getRawClass(), ser);\n                return withResolved(property, ser, forceTypeInformation);\n            }\n        } else {\n            \n            ser = provider.handlePrimaryContextualization(ser, property);\n            return withResolved(property, ser, _forceTypeInformation);\n        }\n        return this;\n    }\n    \n    \n    \n    @Override\n    public void serialize(Object bean, JsonGenerator gen, SerializerProvider prov) throws IOException {\n        try {\n            Object value = _accessorMethod.getValue(bean);\n            if (value == null) {\n                prov.defaultSerializeNull(gen);\n                return;\n            }\n            JsonSerializer<Object> ser = _valueSerializer;\n            if (ser == null) {\n                Class<?> c = value.getClass();\n                \n                \n                ser = prov.findTypedValueSerializer(c, true, _property);\n            }\n            ser.serialize(value, gen, prov);\n        } catch (IOException ioe) {\n            throw ioe;\n        } catch (Exception e) {\n            Throwable t = e;\n            \n            while (t instanceof InvocationTargetException && t.getCause() != null) {\n                t = t.getCause();\n            }\n            \n            if (t instanceof Error) {\n                throw (Error) t;\n            }\n            \n            throw JsonMappingException.wrapWithPath(t, bean, _accessorMethod.getName() + \"()\");\n        }\n    }\n\n    @Override\n    public void serializeWithType(Object bean, JsonGenerator gen, SerializerProvider provider, TypeSerializer typeSer0) throws IOException {\n        \n        Object value = null;\n        try {\n            value = _accessorMethod.getValue(bean);\n            \n            if (value == null) {\n                provider.defaultSerializeNull(gen);\n                return;\n            }\n            JsonSerializer<Object> ser = _valueSerializer;\n            if (ser == null) { \n\n                ser = provider.findValueSerializer(value.getClass(), _property);\n            } else {\n                \n                if (_forceTypeInformation) {\n                    typeSer0.writeTypePrefixForScalar(bean, gen);\n                    ser.serialize(value, gen, provider);\n                    typeSer0.writeTypeSuffixForScalar(bean, gen);\n                    return;\n                }\n            }\n            \n            \n            \n            TypeSerializerRerouter rr = new TypeSerializerRerouter(typeSer0, bean);\n            ser.serializeWithType(value, gen, provider, rr);\n        } catch (IOException ioe) {\n            throw ioe;\n        } catch (Exception e) {\n            Throwable t = e;\n            \n            while (t instanceof InvocationTargetException && t.getCause() != null) {\n                t = t.getCause();\n            }\n            \n            if (t instanceof Error) {\n                throw (Error) t;\n            }\n            \n            throw JsonMappingException.wrapWithPath(t, bean, _accessorMethod.getName() + \"()\");\n        }\n    }\n    \n    @SuppressWarnings(\"deprecation\")\n    @Override\n    public JsonNode getSchema(SerializerProvider provider, Type typeHint) throws JsonMappingException {\n        if (_valueSerializer instanceof SchemaAware) {\n            return ((SchemaAware)_valueSerializer).getSchema(provider, null);\n        }\n        return com.fasterxml.jackson.databind.jsonschema.JsonSchema.getDefaultSchemaNode();\n    }\n\n    @Override\n    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n        \n        final JavaType type = _accessorMethod.getType();\n        Class<?> declaring = _accessorMethod.getDeclaringClass();\n        if ((declaring != null) && declaring.isEnum()) {\n            if (_acceptJsonFormatVisitorForEnum(visitor, typeHint, declaring)) {\n                return;\n            }\n        }\n        JsonSerializer<Object> ser = _valueSerializer;\n        if (ser == null) {\n            ser = visitor.getProvider().findTypedValueSerializer(type, false, _property);\n            if (ser == null) { \n                visitor.expectAnyFormat(typeHint);\n                return;\n            }\n        }\n        ser.acceptJsonFormatVisitor(visitor, null); \n    }\n\n    \n    protected boolean _acceptJsonFormatVisitorForEnum(JsonFormatVisitorWrapper visitor, JavaType typeHint, Class<?> enumType) throws JsonMappingException {\n        \n        JsonStringFormatVisitor stringVisitor = visitor.expectStringFormat(typeHint);\n        if (stringVisitor != null) {\n            Set<String> enums = new LinkedHashSet<String>();\n            for (Object en : enumType.getEnumConstants()) {\n                try {\n                    \n                    \n                    \n                    enums.add(String.valueOf(_accessorMethod.callOn(en)));\n                } catch (Exception e) {\n                    Throwable t = e;\n                    while (t instanceof InvocationTargetException && t.getCause() != null) {\n                        t = t.getCause();\n                    }\n                    if (t instanceof Error) {\n                        throw (Error) t;\n                    }\n                    throw JsonMappingException.wrapWithPath(t, en, _accessorMethod.getName() + \"()\");\n                }\n            }\n            stringVisitor.enumTypes(enums);\n        }\n        return true;\n    }\n\n    protected boolean isNaturalTypeWithStdHandling(Class<?> rawType, JsonSerializer<?> ser) {\n        \n        if (rawType.isPrimitive()) {\n            if (rawType != Integer.TYPE && rawType != Boolean.TYPE && rawType != Double.TYPE) {\n                return false;\n            }\n        } else {\n            if (rawType != String.class &&\n                    rawType != Integer.class && rawType != Boolean.class && rawType != Double.class) {\n                return false;\n            }\n        }\n        return isDefaultSerializer(ser);\n    }\n\n    \n\n    @Override\n    public String toString() {\n        return \"(@JsonValue serializer for method \" + _accessorMethod.getDeclaringClass() + \"#\" + _accessorMethod.getName() + \")\";\n    }\n\n    \n\n    \n    static class TypeSerializerRerouter extends TypeSerializer { protected final TypeSerializer _typeSerializer; protected final Object _forObject; public TypeSerializerRerouter(TypeSerializer ts, Object ob) {\n            _typeSerializer = ts;\n            _forObject = ob;\n        }\n\n        @Override\n        public TypeSerializer forProperty(BeanProperty prop) { \n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public As getTypeInclusion() {\n            return _typeSerializer.getTypeInclusion();\n        }\n\n        @Override\n        public String getPropertyName() {\n            return _typeSerializer.getPropertyName();\n        }\n\n        @Override\n        public TypeIdResolver getTypeIdResolver() {\n            return _typeSerializer.getTypeIdResolver();\n        }\n\n        @Override\n        public void writeTypePrefixForScalar(Object value, JsonGenerator gen) throws IOException {\n            _typeSerializer.writeTypePrefixForScalar(_forObject, gen);\n        }\n\n        @Override\n        public void writeTypePrefixForObject(Object value, JsonGenerator gen) throws IOException {\n            _typeSerializer.writeTypePrefixForObject(_forObject, gen);\n        }\n\n        @Override\n        public void writeTypePrefixForArray(Object value, JsonGenerator gen) throws IOException {\n            _typeSerializer.writeTypePrefixForArray(_forObject, gen);\n        }\n\n        @Override\n        public void writeTypeSuffixForScalar(Object value, JsonGenerator gen) throws IOException {\n            _typeSerializer.writeTypeSuffixForScalar(_forObject, gen);\n        }\n\n        @Override\n        public void writeTypeSuffixForObject(Object value, JsonGenerator gen) throws IOException {\n            _typeSerializer.writeTypeSuffixForObject(_forObject, gen);\n        }\n\n        @Override\n        public void writeTypeSuffixForArray(Object value, JsonGenerator gen) throws IOException {\n            _typeSerializer.writeTypeSuffixForArray(_forObject, gen);\n        }\n\n        public void writeTypePrefixForScalar(Object value, JsonGenerator gen, Class<?> type) throws IOException {\n            _typeSerializer.writeTypePrefixForScalar(_forObject, gen, type);\n        }\n\n        public void writeTypePrefixForObject(Object value, JsonGenerator gen, Class<?> type) throws IOException {\n            _typeSerializer.writeTypePrefixForObject(_forObject, gen, type);\n        }\n\n        public void writeTypePrefixForArray(Object value, JsonGenerator gen, Class<?> type) throws IOException {\n            _typeSerializer.writeTypePrefixForArray(_forObject, gen, type);\n        }\n        \n        @Override\n        public void writeCustomTypePrefixForScalar(Object value, JsonGenerator gen, String typeId) throws IOException {\n            _typeSerializer.writeCustomTypePrefixForScalar(_forObject, gen, typeId);\n        }\n\n        @Override\n        public void writeCustomTypePrefixForObject(Object value, JsonGenerator gen, String typeId) throws IOException {\n            _typeSerializer.writeCustomTypePrefixForObject(_forObject, gen, typeId);\n        }\n\n        @Override\n        public void writeCustomTypePrefixForArray(Object value, JsonGenerator gen, String typeId) throws IOException {\n            _typeSerializer.writeCustomTypePrefixForArray(_forObject, gen, typeId);\n        }\n\n        @Override\n        public void writeCustomTypeSuffixForScalar(Object value, JsonGenerator gen, String typeId) throws IOException {\n            _typeSerializer.writeCustomTypeSuffixForScalar(_forObject, gen, typeId);\n        }\n\n        @Override\n        public void writeCustomTypeSuffixForObject(Object value, JsonGenerator gen, String typeId) throws IOException {\n            _typeSerializer.writeCustomTypeSuffixForObject(_forObject, gen, typeId);\n        }\n\n        @Override\n        public void writeCustomTypeSuffixForArray(Object value, JsonGenerator gen, String typeId) throws IOException {\n            _typeSerializer.writeCustomTypeSuffixForArray(_forObject, gen, typeId);\n        }\n    }\n}\n",
      "buggy_signatures": [
        "public class JsonValueSerializer extends StdSerializer<Object> implements ContextualSerializer, JsonFormatVisitable, SchemaAware { protected final AnnotatedMethod _accessorMethod; protected final JsonSerializer<Object> _valueSerializer; protected final BeanProperty _property; protected final boolean _forceTypeInformation; @SuppressWarnings(\"unchecked\") public JsonValueSerializer(AnnotatedMethod valueMethod, JsonSerializer<?> ser)",
        "public JsonValueSerializer(JsonValueSerializer src, BeanProperty property, JsonSerializer<?> ser, boolean forceTypeInfo)",
        "private final static Class<Object> _notNullClass(Class<?> cls)",
        "public JsonValueSerializer withResolved(BeanProperty property, JsonSerializer<?> ser, boolean forceTypeInfo)",
        "public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException",
        "public void serialize(Object bean, JsonGenerator gen, SerializerProvider prov) throws IOException",
        "public void serializeWithType(Object bean, JsonGenerator gen, SerializerProvider provider, TypeSerializer typeSer0) throws IOException",
        "public JsonNode getSchema(SerializerProvider provider, Type typeHint) throws JsonMappingException",
        "public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException",
        "protected boolean _acceptJsonFormatVisitorForEnum(JsonFormatVisitorWrapper visitor, JavaType typeHint, Class<?> enumType) throws JsonMappingException",
        "protected boolean isNaturalTypeWithStdHandling(Class<?> rawType, JsonSerializer<?> ser)",
        "public String toString()"
      ],
      "fixed_signatures": [
        "public class JsonValueSerializer extends StdSerializer<Object> implements ContextualSerializer, JsonFormatVisitable, SchemaAware { protected final AnnotatedMethod _accessorMethod; protected final JsonSerializer<Object> _valueSerializer; protected final BeanProperty _property; protected final boolean _forceTypeInformation; @SuppressWarnings(\"unchecked\") public JsonValueSerializer(AnnotatedMethod valueMethod, JsonSerializer<?> ser)",
        "public JsonValueSerializer(JsonValueSerializer src, BeanProperty property, JsonSerializer<?> ser, boolean forceTypeInfo)",
        "private final static Class<Object> _notNullClass(Class<?> cls)",
        "public JsonValueSerializer withResolved(BeanProperty property, JsonSerializer<?> ser, boolean forceTypeInfo)",
        "public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException",
        "public void serialize(Object bean, JsonGenerator gen, SerializerProvider prov) throws IOException",
        "public void serializeWithType(Object bean, JsonGenerator gen, SerializerProvider provider, TypeSerializer typeSer0) throws IOException",
        "public JsonNode getSchema(SerializerProvider provider, Type typeHint) throws JsonMappingException",
        "public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException",
        "protected boolean _acceptJsonFormatVisitorForEnum(JsonFormatVisitorWrapper visitor, JavaType typeHint, Class<?> enumType) throws JsonMappingException",
        "protected boolean isNaturalTypeWithStdHandling(Class<?> rawType, JsonSerializer<?> ser)",
        "public String toString()",
        "static class TypeSerializerRerouter extends TypeSerializer { protected final TypeSerializer _typeSerializer; protected final Object _forObject; public TypeSerializerRerouter(TypeSerializer ts, Object ob)",
        "public TypeSerializer forProperty(BeanProperty prop)",
        "public As getTypeInclusion()",
        "public String getPropertyName()",
        "public TypeIdResolver getTypeIdResolver()",
        "public void writeTypePrefixForScalar(Object value, JsonGenerator gen) throws IOException",
        "public void writeTypePrefixForObject(Object value, JsonGenerator gen) throws IOException",
        "public void writeTypePrefixForArray(Object value, JsonGenerator gen) throws IOException",
        "public void writeTypeSuffixForScalar(Object value, JsonGenerator gen) throws IOException",
        "public void writeTypeSuffixForObject(Object value, JsonGenerator gen) throws IOException",
        "public void writeTypeSuffixForArray(Object value, JsonGenerator gen) throws IOException",
        "public void writeTypePrefixForScalar(Object value, JsonGenerator gen, Class<?> type) throws IOException",
        "public void writeTypePrefixForObject(Object value, JsonGenerator gen, Class<?> type) throws IOException",
        "public void writeTypePrefixForArray(Object value, JsonGenerator gen, Class<?> type) throws IOException",
        "public void writeCustomTypePrefixForScalar(Object value, JsonGenerator gen, String typeId) throws IOException",
        "public void writeCustomTypePrefixForObject(Object value, JsonGenerator gen, String typeId) throws IOException",
        "public void writeCustomTypePrefixForArray(Object value, JsonGenerator gen, String typeId) throws IOException",
        "public void writeCustomTypeSuffixForScalar(Object value, JsonGenerator gen, String typeId) throws IOException",
        "public void writeCustomTypeSuffixForObject(Object value, JsonGenerator gen, String typeId) throws IOException",
        "public void writeCustomTypeSuffixForArray(Object value, JsonGenerator gen, String typeId) throws IOException"
      ],
      "methods": [
        {
          "buggy_method": "",
          "fixed_method": "",
          "diff": [
            "@@ -6,6 +6,7 @@",
            " import java.util.LinkedHashSet;\n",
            " import java.util.Set;\n",
            " \n",
            "+import com.fasterxml.jackson.annotation.JsonTypeInfo.As;\n",
            " import com.fasterxml.jackson.core.*;\n",
            " import com.fasterxml.jackson.databind.*;\n",
            " import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n"
          ],
          "changed_lines": 1
        },
        {
          "buggy_method": "",
          "fixed_method": "",
          "diff": [
            "@@ -14,6 +15,7 @@",
            " import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n",
            " import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonStringFormatVisitor;\n",
            " import com.fasterxml.jackson.databind.jsonschema.SchemaAware;\n",
            "+import com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\n",
            " import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n",
            " import com.fasterxml.jackson.databind.ser.BeanSerializer;\n",
            " import com.fasterxml.jackson.databind.ser.ContextualSerializer;\n"
          ],
          "changed_lines": 1
        },
        {
          "buggy_method": "  public void serializeWithType(Object bean, JsonGenerator gen, SerializerProvider provider, TypeSerializer typeSer0) throws IOException {\n  \n  Object value = null;\n  try {\n  value = _accessorMethod.getValue(bean);\n  \n  if (value == null) {\n  provider.defaultSerializeNull(gen);\n  return;\n  }\n  JsonSerializer<Object> ser = _valueSerializer;\n  if (ser == null) { \n\n  ser = provider.findValueSerializer(value.getClass(), _property);\n  } else {\n  \n  if (_forceTypeInformation) {\n  typeSer0.writeTypePrefixForScalar(bean, gen);\n  ser.serialize(value, gen, provider);\n  typeSer0.writeTypeSuffixForScalar(bean, gen);\n  return;\n  }\n  }\n  \n  \n  \n  ser.serializeWithType(value, gen, provider, typeSer0);\n  } catch (IOException ioe) {\n  throw ioe;\n  } catch (Exception e) {\n  Throwable t = e;\n  \n  while (t instanceof InvocationTargetException && t.getCause() != null) {\n  t = t.getCause();\n  }\n  \n  if (t instanceof Error) {\n  throw (Error) t;\n  }\n  \n  throw JsonMappingException.wrapWithPath(t, bean, _accessorMethod.getName() + \"()\");\n  }\n  }",
          "fixed_method": "  public void serializeWithType(Object bean, JsonGenerator gen, SerializerProvider provider, TypeSerializer typeSer0) throws IOException {\n  \n  Object value = null;\n  try {\n  value = _accessorMethod.getValue(bean);\n  \n  if (value == null) {\n  provider.defaultSerializeNull(gen);\n  return;\n  }\n  JsonSerializer<Object> ser = _valueSerializer;\n  if (ser == null) { \n\n  ser = provider.findValueSerializer(value.getClass(), _property);\n  } else {\n  \n  if (_forceTypeInformation) {\n  typeSer0.writeTypePrefixForScalar(bean, gen);\n  ser.serialize(value, gen, provider);\n  typeSer0.writeTypeSuffixForScalar(bean, gen);\n  return;\n  }\n  }\n  \n  \n  \n  TypeSerializerRerouter rr = new TypeSerializerRerouter(typeSer0, bean);\n  ser.serializeWithType(value, gen, provider, rr);\n  } catch (IOException ioe) {\n  throw ioe;\n  } catch (Exception e) {\n  Throwable t = e;\n  \n  while (t instanceof InvocationTargetException && t.getCause() != null) {\n  t = t.getCause();\n  }\n  \n  if (t instanceof Error) {\n  throw (Error) t;\n  }\n  \n  throw JsonMappingException.wrapWithPath(t, bean, _accessorMethod.getName() + \"()\");\n  }\n  }",
          "diff": [
            "@@ -223,7 +225,8 @@",
            "             // 28-Sep-2016, tatu: As per [databind#1385], we do need to do some juggling\n",
            "             //    to use different Object for type id (logical type) and actual serialization\n",
            "             //    (delegat type).\n",
            "-            ser.serializeWithType(value, gen, provider, typeSer0);\n",
            "+            TypeSerializerRerouter rr = new TypeSerializerRerouter(typeSer0, bean);\n",
            "+            ser.serializeWithType(value, gen, provider, rr);\n",
            "         } catch (IOException ioe) {\n",
            "             throw ioe;\n",
            "         } catch (Exception e) {\n"
          ],
          "changed_lines": 3
        },
        {
          "buggy_method": "  public String toString() {\n  return \"(@JsonValue serializer for method \" + _accessorMethod.getDeclaringClass() + \"#\" + _accessorMethod.getName() + \")\";\n  }",
          "fixed_method": "  public String toString() {\n  return \"(@JsonValue serializer for method \" + _accessorMethod.getDeclaringClass() + \"#\" + _accessorMethod.getName() + \")\";\n  }",
          "diff": [
            "@@ -360,24 +363,108 @@",
            "      * override Object to use for type id (logical type) even when asking serialization\n",
            "      * of something else (delegate type)\n",
            "      */\n",
            "-\n",
            "-\n",
            "-\n",
            "-\n",
            "-\n",
            "-\n",
            "-\n",
            "-\n",
            "-\n",
            "-\n",
            "-\n",
            "-\n",
            "-\n",
            "-\n",
            "+    static class TypeSerializerRerouter\n",
            "+        extends TypeSerializer\n",
            "+    {\n",
            "+        protected final TypeSerializer _typeSerializer;\n",
            "+        protected final Object _forObject;\n",
            "+\n",
            "+        public TypeSerializerRerouter(TypeSerializer ts, Object ob) {\n",
            "+            _typeSerializer = ts;\n",
            "+            _forObject = ob;\n",
            "+        }\n",
            "+\n",
            "+        @Override\n",
            "+        public TypeSerializer forProperty(BeanProperty prop) { // should never get called\n",
            "+            throw new UnsupportedOperationException();\n",
            "+        }\n",
            "+\n",
            "+        @Override\n",
            "+        public As getTypeInclusion() {\n",
            "+            return _typeSerializer.getTypeInclusion();\n",
            "+        }\n",
            "+\n",
            "+        @Override\n",
            "+        public String getPropertyName() {\n",
            "+            return _typeSerializer.getPropertyName();\n",
            "+        }\n",
            "+\n",
            "+        @Override\n",
            "+        public TypeIdResolver getTypeIdResolver() {\n",
            "+            return _typeSerializer.getTypeIdResolver();\n",
            "+        }\n",
            "+\n",
            "+        @Override\n",
            "+        public void writeTypePrefixForScalar(Object value, JsonGenerator gen) throws IOException {\n",
            "+            _typeSerializer.writeTypePrefixForScalar(_forObject, gen);\n",
            "+        }\n",
            "+\n",
            "+        @Override\n",
            "+        public void writeTypePrefixForObject(Object value, JsonGenerator gen) throws IOException {\n",
            "+            _typeSerializer.writeTypePrefixForObject(_forObject, gen);\n",
            "+        }\n",
            "+\n",
            "+        @Override\n",
            "+        public void writeTypePrefixForArray(Object value, JsonGenerator gen) throws IOException {\n",
            "+            _typeSerializer.writeTypePrefixForArray(_forObject, gen);\n",
            "+        }\n",
            "+\n",
            "+        @Override\n",
            "+        public void writeTypeSuffixForScalar(Object value, JsonGenerator gen) throws IOException {\n",
            "+            _typeSerializer.writeTypeSuffixForScalar(_forObject, gen);\n",
            "+        }\n",
            "+\n",
            "+        @Override\n",
            "+        public void writeTypeSuffixForObject(Object value, JsonGenerator gen) throws IOException {\n",
            "+            _typeSerializer.writeTypeSuffixForObject(_forObject, gen);\n",
            "+        }\n",
            "+\n",
            "+        @Override\n",
            "+        public void writeTypeSuffixForArray(Object value, JsonGenerator gen) throws IOException {\n",
            "+            _typeSerializer.writeTypeSuffixForArray(_forObject, gen);\n",
            "+        }\n",
            "+\n",
            "+        public void writeTypePrefixForScalar(Object value, JsonGenerator gen, Class<?> type) throws IOException {\n",
            "+            _typeSerializer.writeTypePrefixForScalar(_forObject, gen, type);\n",
            "+        }\n",
            "+\n",
            "+        public void writeTypePrefixForObject(Object value, JsonGenerator gen, Class<?> type) throws IOException {\n",
            "+            _typeSerializer.writeTypePrefixForObject(_forObject, gen, type);\n",
            "+        }\n",
            "+\n",
            "+        public void writeTypePrefixForArray(Object value, JsonGenerator gen, Class<?> type) throws IOException {\n",
            "+            _typeSerializer.writeTypePrefixForArray(_forObject, gen, type);\n",
            "+        }\n",
            "         \n",
            "-\n",
            "-\n",
            "-\n",
            "-\n",
            "-\n",
            "+        @Override\n",
            "+        public void writeCustomTypePrefixForScalar(Object value, JsonGenerator gen, String typeId)\n",
            "+                throws IOException {\n",
            "+            _typeSerializer.writeCustomTypePrefixForScalar(_forObject, gen, typeId);\n",
            "+        }\n",
            "+\n",
            "+        @Override\n",
            "+        public void writeCustomTypePrefixForObject(Object value, JsonGenerator gen, String typeId) throws IOException {\n",
            "+            _typeSerializer.writeCustomTypePrefixForObject(_forObject, gen, typeId);\n",
            "+        }\n",
            "+\n",
            "+        @Override\n",
            "+        public void writeCustomTypePrefixForArray(Object value, JsonGenerator gen, String typeId) throws IOException {\n",
            "+            _typeSerializer.writeCustomTypePrefixForArray(_forObject, gen, typeId);\n",
            "+        }\n",
            "+\n",
            "+        @Override\n",
            "+        public void writeCustomTypeSuffixForScalar(Object value, JsonGenerator gen, String typeId) throws IOException {\n",
            "+            _typeSerializer.writeCustomTypeSuffixForScalar(_forObject, gen, typeId);\n",
            "+        }\n",
            "+\n",
            "+        @Override\n",
            "+        public void writeCustomTypeSuffixForObject(Object value, JsonGenerator gen, String typeId) throws IOException {\n",
            "+            _typeSerializer.writeCustomTypeSuffixForObject(_forObject, gen, typeId);\n",
            "+        }\n",
            "+\n",
            "+        @Override\n",
            "+        public void writeCustomTypeSuffixForArray(Object value, JsonGenerator gen, String typeId) throws IOException {\n",
            "+            _typeSerializer.writeCustomTypeSuffixForArray(_forObject, gen, typeId);\n",
            "+        }\n",
            "+    }\n",
            " }\n"
          ],
          "changed_lines": 122
        }
      ]
    }
  ]
}
