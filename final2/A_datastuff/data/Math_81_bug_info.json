{
  "bug_id": "81",
  "failed_tests": {
    "org.apache.commons.math.linear.EigenDecompositionImplTest": [
      {
        "methodName": "testMath308",
        "error": "java.lang.ArrayIndexOutOfBoundsException",
        "message": "Index -1 out of bounds for length 30",
        "fail_line": "        EigenDecomposition decomposition =",
        "test_source": "  public void testMath308() {\n\n  double[] mainTridiagonal = {\n  22.330154644539597, 46.65485522478641, 17.393672330044705, 54.46687435351116, 80.17800767709437\n  };\n  double[] secondaryTridiagonal = {\n  13.04450406501361, -5.977590941539671, 2.9040909856707517, 7.1570352792841225\n  };\n\n  // the reference values have been computed using routine DSTEMR\n  // from the fortran library LAPACK version 3.2.1\n  double[] refEigenValues = {\n  82.044413207204002, 53.456697699894512, 52.536278520113882, 18.847969733754262, 14.138204224043099\n  };\n  RealVector[] refEigenVectors = {\n  new ArrayRealVector(new double[] { -0.000462690386766, -0.002118073109055,  0.011530080757413,  0.252322434584915,  0.967572088232592 }),\n  new ArrayRealVector(new double[] {  0.314647769490148,  0.750806415553905, -0.167700312025760, -0.537092972407375,  0.143854968127780 }),\n  new ArrayRealVector(new double[] {  0.222368839324646,  0.514921891363332, -0.021377019336614,  0.801196801016305, -0.207446991247740 }),\n  new ArrayRealVector(new double[] {  0.713933751051495, -0.190582113553930,  0.671410443368332, -0.056056055955050,  0.006541576993581 }),\n  new ArrayRealVector(new double[] {  0.584677060845929, -0.367177264979103, -0.721453187784497,  0.052971054621812, -0.005740715188257 })\n  };\n\n  EigenDecomposition decomposition =\n  new EigenDecompositionImpl(mainTridiagonal, secondaryTridiagonal, MathUtils.SAFE_MIN);\n\n  double[] eigenValues = decomposition.getRealEigenvalues();\n  for (int i = 0; i < refEigenValues.length; ++i) {\n  assertEquals(refEigenValues[i], eigenValues[i], 1.0e-5);\n  assertEquals(0, refEigenVectors[i].subtract(decomposition.getEigenvector(i)).getNorm(), 2.0e-7);\n  }\n\n  }",
        "stack": [
          "EigenDecompositionImpl.computeShiftIncrement line 1544, EigenDecompositionImpl.goodStep line 1071, EigenDecompositionImpl.processGeneralBlock line 893, EigenDecompositionImpl.findEigenvalues line 657, EigenDecompositionImpl.decompose line 246, EigenDecompositionImpl.<init> line 205, EigenDecompositionImplTest.testMath308 line 134"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/math/linear/EigenDecompositionImpl.java",
      "buggy_full_code": "\n\npackage org.apache.commons.math.linear;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\nimport org.apache.commons.math.MathRuntimeException;\nimport org.apache.commons.math.MaxIterationsExceededException;\nimport org.apache.commons.math.util.MathUtils;\n\n\npublic class EigenDecompositionImpl implements EigenDecomposition { private static final double TOLERANCE = 100 * MathUtils.EPSILON; private static final double TOLERANCE_2 = TOLERANCE * TOLERANCE; private double splitTolerance; private double[] main; private double[] secondary; private double[] squaredSecondary; private TriDiagonalTransformer transformer; private double lowerSpectra; private double upperSpectra; private double minPivot; private double sigma; private double sigmaLow; private double tau; private double[] work; private int pingPong; private double qMax; private double eMin; private int tType; private double dMin; private double dMin1; private double dMin2; private double dN; private double dN1; private double dN2; private double g; private double[] realEigenvalues; private double[] imagEigenvalues; private ArrayRealVector[] eigenvectors; private RealMatrix cachedV; private RealMatrix cachedD; private RealMatrix cachedVt; public EigenDecompositionImpl(final RealMatrix matrix, final double splitTolerance) throws InvalidMatrixException {\n        if (isSymmetric(matrix)) {\n            this.splitTolerance = splitTolerance;\n            transformToTridiagonal(matrix);\n            decompose();\n        } else {\n            \n            \n            throw new InvalidMatrixException(\"eigen decomposition of assymetric matrices not supported yet\");\n        }\n    }\n\n    \n    public EigenDecompositionImpl(final double[] main, double[] secondary, final double splitTolerance) throws InvalidMatrixException {\n\n        this.main      = main.clone();\n        this.secondary = secondary.clone();\n        transformer    = null;\n\n        \n        squaredSecondary = new double[secondary.length];\n        for (int i = 0; i < squaredSecondary.length; ++i) {\n            final double s = secondary[i];\n            squaredSecondary[i] = s * s;\n        }\n\n        this.splitTolerance = splitTolerance;\n        decompose();\n\n    }\n\n    \n    private boolean isSymmetric(final RealMatrix matrix) {\n        final int rows    = matrix.getRowDimension();\n        final int columns = matrix.getColumnDimension();\n        final double eps  = 10 * rows * columns * MathUtils.EPSILON;\n        for (int i = 0; i < rows; ++i) {\n            for (int j = i + 1; j < columns; ++j) {\n                final double mij = matrix.getEntry(i, j);\n                final double mji = matrix.getEntry(j, i);\n                if (Math.abs(mij - mji) > (Math.max(Math.abs(mij), Math.abs(mji)) * eps)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    \n    private void decompose() {\n\n        cachedV  = null;\n        cachedD  = null;\n        cachedVt = null;\n        work     = new double[6 * main.length];\n\n        \n        computeGershgorinCircles();\n\n        \n        findEigenvalues();\n\n        \n        eigenvectors = null;\n\n    }\n\n    \n    public RealMatrix getV() throws InvalidMatrixException {\n\n        if (cachedV == null) {\n\n            if (eigenvectors == null) {\n                findEigenVectors();\n            }\n\n            final int m = eigenvectors.length;\n            cachedV = MatrixUtils.createRealMatrix(m, m);\n            for (int k = 0; k < m; ++k) {\n                cachedV.setColumnVector(k, eigenvectors[k]);\n            }\n\n        }\n\n        \n        return cachedV;\n\n    }\n\n    \n    public RealMatrix getD() throws InvalidMatrixException {\n        if (cachedD == null) {\n            \n            cachedD = MatrixUtils.createRealDiagonalMatrix(realEigenvalues);\n        }\n        return cachedD;\n    }\n\n    \n    public RealMatrix getVT() throws InvalidMatrixException {\n\n        if (cachedVt == null) {\n\n            if (eigenvectors == null) {\n                findEigenVectors();\n            }\n\n            final int m = eigenvectors.length;\n            cachedVt = MatrixUtils.createRealMatrix(m, m);\n            for (int k = 0; k < m; ++k) {\n                cachedVt.setRowVector(k, eigenvectors[k]);\n            }\n\n        }\n\n        \n        return cachedVt;\n\n    }\n\n    \n    public double[] getRealEigenvalues() throws InvalidMatrixException {\n        return realEigenvalues.clone();\n    }\n\n    \n    public double getRealEigenvalue(final int i) throws InvalidMatrixException, ArrayIndexOutOfBoundsException {\n        return realEigenvalues[i];\n    }\n\n    \n    public double[] getImagEigenvalues() throws InvalidMatrixException {\n        return imagEigenvalues.clone();\n    }\n\n    \n    public double getImagEigenvalue(final int i) throws InvalidMatrixException, ArrayIndexOutOfBoundsException {\n        return imagEigenvalues[i];\n    }\n\n    \n    public RealVector getEigenvector(final int i) throws InvalidMatrixException, ArrayIndexOutOfBoundsException {\n        if (eigenvectors == null) {\n            findEigenVectors();\n        }\n        return eigenvectors[i].copy();\n    }\n\n    \n    public double getDeterminant() {\n        double determinant = 1;\n        for (double lambda : realEigenvalues) {\n            determinant *= lambda;\n        }\n        return determinant;\n    }\n\n    \n    public DecompositionSolver getSolver() {\n        if (eigenvectors == null) {\n            findEigenVectors();\n        }\n        return new Solver(realEigenvalues, imagEigenvalues, eigenvectors);\n    }\n\n    \n    private static class Solver implements DecompositionSolver { private double[] realEigenvalues; private double[] imagEigenvalues; private final ArrayRealVector[] eigenvectors; private Solver(final double[] realEigenvalues, final double[] imagEigenvalues, final ArrayRealVector[] eigenvectors) {\n            this.realEigenvalues = realEigenvalues;\n            this.imagEigenvalues = imagEigenvalues;\n            this.eigenvectors    = eigenvectors;\n        }\n\n        \n        public double[] solve(final double[] b) throws IllegalArgumentException, InvalidMatrixException {\n\n            if (!isNonSingular()) {\n                throw new SingularMatrixException();\n            }\n\n            final int m = realEigenvalues.length;\n            if (b.length != m) {\n                throw MathRuntimeException.createIllegalArgumentException(\n                        \"vector length mismatch: got {0} but expected {1}\",\n                        b.length, m);\n            }\n\n            final double[] bp = new double[m];\n            for (int i = 0; i < m; ++i) {\n                final ArrayRealVector v = eigenvectors[i];\n                final double[] vData = v.getDataRef();\n                final double s = v.dotProduct(b) / realEigenvalues[i];\n                for (int j = 0; j < m; ++j) {\n                    bp[j] += s * vData[j];\n                }\n            }\n\n            return bp;\n\n        }\n\n        \n        public RealVector solve(final RealVector b) throws IllegalArgumentException, InvalidMatrixException {\n\n            if (!isNonSingular()) {\n                throw new SingularMatrixException();\n            }\n\n            final int m = realEigenvalues.length;\n            if (b.getDimension() != m) {\n                throw MathRuntimeException.createIllegalArgumentException(\n                        \"vector length mismatch: got {0} but expected {1}\",\n                        b.getDimension(), m);\n            }\n\n            final double[] bp = new double[m];\n            for (int i = 0; i < m; ++i) {\n                final ArrayRealVector v = eigenvectors[i];\n                final double[] vData = v.getDataRef();\n                final double s = v.dotProduct(b) / realEigenvalues[i];\n                for (int j = 0; j < m; ++j) {\n                    bp[j] += s * vData[j];\n                }\n            }\n\n            return new ArrayRealVector(bp, false);\n\n        }\n\n        \n        public RealMatrix solve(final RealMatrix b) throws IllegalArgumentException, InvalidMatrixException {\n\n            if (!isNonSingular()) {\n                throw new SingularMatrixException();\n            }\n\n            final int m = realEigenvalues.length;\n            if (b.getRowDimension() != m) {\n                throw MathRuntimeException.createIllegalArgumentException(\n                        \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n                        b.getRowDimension(), b.getColumnDimension(), m, \"n\");\n            }\n\n            final int nColB = b.getColumnDimension();\n            final double[][] bp = new double[m][nColB];\n            for (int k = 0; k < nColB; ++k) {\n                for (int i = 0; i < m; ++i) {\n                    final ArrayRealVector v = eigenvectors[i];\n                    final double[] vData = v.getDataRef();\n                    double s = 0;\n                    for (int j = 0; j < m; ++j) {\n                        s += v.getEntry(j) * b.getEntry(j, k);\n                    }\n                    s /= realEigenvalues[i];\n                    for (int j = 0; j < m; ++j) {\n                        bp[j][k] += s * vData[j];\n                    }\n                }\n            }\n\n            return MatrixUtils.createRealMatrix(bp);\n\n        }\n\n        \n        public boolean isNonSingular() {\n            for (int i = 0; i < realEigenvalues.length; ++i) {\n                if ((realEigenvalues[i] == 0) && (imagEigenvalues[i] == 0)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        \n        public RealMatrix getInverse() throws InvalidMatrixException {\n\n            if (!isNonSingular()) {\n                throw new SingularMatrixException();\n            }\n\n            final int m = realEigenvalues.length;\n            final double[][] invData = new double[m][m];\n\n            for (int i = 0; i < m; ++i) {\n                final double[] invI = invData[i];\n                for (int j = 0; j < m; ++j) {\n                    double invIJ = 0;\n                    for (int k = 0; k < m; ++k) {\n                        final double[] vK = eigenvectors[k].getDataRef();\n                        invIJ += vK[i] * vK[j] / realEigenvalues[k];\n                    }\n                    invI[j] = invIJ;\n                }\n            }\n            return MatrixUtils.createRealMatrix(invData);\n\n        }\n\n    }\n\n    \n    private void transformToTridiagonal(final RealMatrix matrix) {\n\n        \n        transformer = new TriDiagonalTransformer(matrix);\n        main      = transformer.getMainDiagonalRef();\n        secondary = transformer.getSecondaryDiagonalRef();\n\n        \n        squaredSecondary = new double[secondary.length];\n        for (int i = 0; i < squaredSecondary.length; ++i) {\n            final double s = secondary[i];\n            squaredSecondary[i] = s * s;\n        }\n\n    }\n\n    \n    private void computeGershgorinCircles() {\n\n        final int m     = main.length;\n        final int lowerStart = 4 * m;\n        final int upperStart = 5 * m;\n        lowerSpectra = Double.POSITIVE_INFINITY;\n        upperSpectra = Double.NEGATIVE_INFINITY;\n        double eMax = 0;\n\n        double eCurrent = 0;\n        for (int i = 0; i < m - 1; ++i) {\n\n            final double dCurrent = main[i];\n            final double ePrevious = eCurrent;\n            eCurrent = Math.abs(secondary[i]);\n            eMax = Math.max(eMax, eCurrent);\n            final double radius = ePrevious + eCurrent;\n\n            final double lower = dCurrent - radius;\n            work[lowerStart + i] = lower;\n            lowerSpectra = Math.min(lowerSpectra, lower);\n\n            final double upper = dCurrent + radius;\n            work[upperStart + i] = upper;\n            upperSpectra = Math.max(upperSpectra, upper);\n\n        }\n\n        final double dCurrent = main[m - 1];\n        final double lower = dCurrent - eCurrent;\n        work[lowerStart + m - 1] = lower;\n        lowerSpectra = Math.min(lowerSpectra, lower);\n        final double upper = dCurrent + eCurrent;\n        work[upperStart + m - 1] = upper;\n        minPivot = MathUtils.SAFE_MIN * Math.max(1.0, eMax * eMax);\n\n    }\n\n    \n    private void findEigenvalues() throws InvalidMatrixException {\n\n        \n        List<Integer> splitIndices = computeSplits();\n\n        \n        realEigenvalues = new double[main.length];\n        imagEigenvalues = new double[main.length];\n        int begin = 0;\n        for (final int end : splitIndices) {\n            final int n = end - begin;\n            switch (n) {\n\n            case 1:\n                \n                process1RowBlock(begin);\n                break;\n\n            case 2:\n                \n                process2RowsBlock(begin);\n                break;\n\n            case 3:\n                \n                process3RowsBlock(begin);\n                break;\n\n            default:\n\n                \n                final double[] range       = eigenvaluesRange(begin, n);\n                final double oneFourth     = 0.25 * (3 * range[0] + range[1]);\n                final int oneFourthCount   = countEigenValues(oneFourth, begin, n);\n                final double threeFourth   = 0.25 * (range[0] + 3 * range[1]);\n                final int threeFourthCount = countEigenValues(threeFourth, begin, n);\n                final boolean chooseLeft   = (oneFourthCount - 1) >= (n - threeFourthCount);\n                final double lambda        = chooseLeft ? range[0] : range[1];\n\n                tau = (range[1] - range[0]) * MathUtils.EPSILON * n + 2 * minPivot;\n\n                \n                ldlTDecomposition(lambda, begin, n);\n\n                \n                processGeneralBlock(n);\n\n                \n                if (chooseLeft) {\n                    for (int i = 0; i < n; ++i) {\n                        realEigenvalues[begin + i] = lambda + work[4 * i];\n                    }\n                } else {\n                    for (int i = 0; i < n; ++i) {\n                        realEigenvalues[begin + i] = lambda - work[4 * i];\n                    }\n                }\n\n            }\n            begin = end;\n        }\n\n        \n        Arrays.sort(realEigenvalues);\n        int j = realEigenvalues.length - 1;\n        for (int i = 0; i < j; ++i) {\n            final double tmp = realEigenvalues[i];\n            realEigenvalues[i] = realEigenvalues[j];\n            realEigenvalues[j] = tmp;\n            --j;\n        }\n\n    }\n\n    \n    private List<Integer> computeSplits() {\n\n        final List<Integer> list = new ArrayList<Integer>();\n\n        \n        double absDCurrent = Math.abs(main[0]);\n        for (int i = 0; i < secondary.length; ++i) {\n            final double absDPrevious = absDCurrent;\n            absDCurrent = Math.abs(main[i + 1]);\n            final double max = splitTolerance * Math.sqrt(absDPrevious * absDCurrent);\n            if (Math.abs(secondary[i]) <= max) {\n                list.add(i + 1);\n                secondary[i] = 0;\n                squaredSecondary[i] = 0;\n            }\n        }\n\n        list.add(secondary.length + 1);\n        return list;\n\n    }\n\n    \n    private void process1RowBlock(final int index) {\n        realEigenvalues[index] = main[index];\n    }\n\n    \n    private void process2RowsBlock(final int index) throws InvalidMatrixException {\n\n        \n        \n        final double q0   = main[index];\n        final double q1   = main[index + 1];\n        final double e12  = squaredSecondary[index];\n\n        final double s     = q0 + q1;\n        final double p     = q0 * q1 - e12;\n        final double delta = s * s - 4 * p;\n        if (delta < 0) {\n            throw new InvalidMatrixException(\"cannot solve degree {0} equation\", 2);\n        }\n\n        final double largestRoot = 0.5 * (s + Math.sqrt(delta));\n        realEigenvalues[index]     = largestRoot;\n        realEigenvalues[index + 1] = p / largestRoot;\n\n    }\n\n    \n    private void process3RowsBlock(final int index) throws InvalidMatrixException {\n\n        \n        \n        final double q0       = main[index];\n        final double q1       = main[index + 1];\n        final double q2       = main[index + 2];\n        final double e12      = squaredSecondary[index];\n        final double q1q2Me22 = q1 * q2 - squaredSecondary[index + 1];\n\n        \n        final double b        = -(q0 + q1 + q2);\n        final double c        = q0 * q1 + q0 * q2 + q1q2Me22 - e12;\n        final double d        = q2 * e12 - q0 * q1q2Me22;\n\n        \n        final double b2       = b * b;\n        final double q        = (3 * c - b2) / 9;\n        final double r        = ((9 * c - 2 * b2) * b - 27 * d) / 54;\n        final double delta    = q * q * q + r * r;\n        if (delta >= 0) {\n            \n            \n            \n            throw new InvalidMatrixException(\"cannot solve degree {0} equation\", 3);\n        }\n        final double sqrtMq = Math.sqrt(-q);\n        final double theta  = Math.acos(r / (-q * sqrtMq));\n        final double alpha  = 2 * sqrtMq;\n        final double beta   = b / 3;\n\n        double z0 = alpha * Math.cos(theta / 3) - beta;\n        double z1 = alpha * Math.cos((theta + 2 * Math.PI) / 3) - beta;\n        double z2 = alpha * Math.cos((theta + 4 * Math.PI) / 3) - beta;\n        if (z0 < z1) {\n            final double t = z0;\n            z0 = z1;\n            z1 = t;\n        }\n        if (z1 < z2) {\n            final double t = z1;\n            z1 = z2;\n            z2 = t;\n        }\n        if (z0 < z1) {\n            final double t = z0;\n            z0 = z1;\n            z1 = t;\n        }\n        realEigenvalues[index]     = z0;\n        realEigenvalues[index + 1] = z1;\n        realEigenvalues[index + 2] = z2;\n\n    }\n\n    \n    private void processGeneralBlock(final int n) throws InvalidMatrixException {\n\n        \n        double sumOffDiag = 0;\n        for (int i = 0; i < n - 1; ++i) {\n            final int fourI = 4 * i;\n            final double ei = work[fourI + 2];\n            sumOffDiag += ei;\n        }\n\n        if (sumOffDiag == 0) {\n            \n            return;\n        }\n\n        \n        flipIfWarranted(n, 2);\n\n        \n        initialSplits(n);\n\n        \n        tType = 0;\n        dMin1 = 0;\n        dMin2 = 0;\n        dN    = 0;\n        dN1   = 0;\n        dN2   = 0;\n        tau   = 0;\n\n        \n        int i0 = 0;\n        int n0 = n;\n        while (n0 > 0) {\n\n            \n            sigma    = (n0 == n) ? 0 : -work[4 * n0 - 2];\n            sigmaLow = 0;\n\n            \n            double offDiagMin = (i0 == n0) ? 0 : work[4 * n0 - 6];\n            double offDiagMax = 0;\n            double diagMax    = work[4 * n0 - 4];\n            double diagMin    = diagMax;\n            i0 = 0;\n            for (int i = 4 * (n0 - 2); i >= 0; i -= 4) {\n                if (work[i + 2] <= 0) {\n                    i0 = 1 + i / 4;\n                    break;\n                }\n                if (diagMin >= 4 * offDiagMax) {\n                    diagMin    = Math.min(diagMin, work[i + 4]);\n                    offDiagMax = Math.max(offDiagMax, work[i + 2]);\n                }\n                diagMax    = Math.max(diagMax, work[i] + work[i + 2]);\n                offDiagMin = Math.min(offDiagMin, work[i + 2]);\n            }\n            work[4 * n0 - 2] = offDiagMin;\n\n            \n            dMin = -Math.max(0, diagMin - 2 * Math.sqrt(diagMin * offDiagMax));\n\n            pingPong = 0;\n            int maxIter = 30 * (n0 - i0);\n            for (int k = 0; i0 < n0; ++k) {\n                if (k >= maxIter) {\n                    throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));\n                }\n\n                \n                n0 = goodStep(i0, n0);\n                pingPong = 1 - pingPong;\n\n                \n                \n                if ((pingPong == 0) && (n0 - i0 > 3) &&\n                    (work[4 * n0 - 1] <= TOLERANCE_2 * diagMax) &&\n                    (work[4 * n0 - 2] <= TOLERANCE_2 * sigma)) {\n                    int split  = i0 - 1;\n                    diagMax    = work[4 * i0];\n                    offDiagMin = work[4 * i0 + 2];\n                    double previousEMin = work[4 * i0 + 3];\n                    for (int i = 4 * i0; i < 4 * n0 - 11; i += 4) {\n                        if ((work[i + 3] <= TOLERANCE_2 * work[i]) &&\n                            (work[i + 2] <= TOLERANCE_2 * sigma)) {\n                            \n                            work[i + 2]  = -sigma;\n                            split        = i / 4;\n                            diagMax      = 0;\n                            offDiagMin   = work[i + 6];\n                            previousEMin = work[i + 7];\n                        } else {\n                            diagMax      = Math.max(diagMax, work[i + 4]);\n                            offDiagMin   = Math.min(offDiagMin, work[i + 2]);\n                            previousEMin = Math.min(previousEMin, work[i + 3]);\n                        }\n                    }\n                    work[4 * n0 - 2] = offDiagMin;\n                    work[4 * n0 - 1] = previousEMin;\n                    i0 = split + 1;\n                }\n            }\n\n        }\n\n    }\n\n    \n    private void initialSplits(final int n) {\n\n        pingPong = 0;\n        for (int k = 0; k < 2; ++k) {\n\n            \n            double d = work[4 * (n - 1) + pingPong];\n            for (int i = 4 * (n - 2) + pingPong; i >= 0; i -= 4) {\n                if (work[i + 2] <= TOLERANCE_2 * d) {\n                    work[i + 2] = -0.0;\n                    d = work[i];\n                } else {\n                    d *= work[i] / (d + work[i + 2]);\n                }\n            }\n\n            \n            d = work[pingPong];\n            for (int i = 2 + pingPong; i < 4 * n - 2; i += 4) {\n                final int j = i - 2 * pingPong - 1;\n                work[j] = d + work[i];\n                if (work[i] <= TOLERANCE_2 * d) {\n                    work[i]     = -0.0;\n                    work[j]     = d;\n                    work[j + 2] = 0.0;\n                    d = work[i + 2];\n                } else if ((MathUtils.SAFE_MIN * work[i + 2] < work[j]) &&\n                           (MathUtils.SAFE_MIN * work[j] < work[i + 2])) {\n                    final double tmp = work[i + 2] / work[j];\n                    work[j + 2] = work[i] * tmp;\n                    d *= tmp;\n                } else {\n                    work[j + 2] = work[i + 2] * (work[i] / work[j]);\n                    d *= work[i + 2] / work[j];\n               }\n            }\n            work[4 * n - 3 - pingPong] = d;\n\n            \n            pingPong = 1 - pingPong;\n\n        }\n\n    }\n\n    \n    private int goodStep(final int start, final int end) {\n\n        g = 0.0;\n\n        \n        int deflatedEnd = end;\n        for (boolean deflating = true; deflating;) {\n\n            if (start >= deflatedEnd) {\n                \n                return deflatedEnd;\n            }\n\n            final int k = 4 * deflatedEnd + pingPong - 1;\n\n            if ((start == deflatedEnd - 1) ||\n                ((start != deflatedEnd - 2) &&\n                 ((work[k - 5] <= TOLERANCE_2 * (sigma + work[k - 3])) ||\n                  (work[k - 2 * pingPong - 4] <= TOLERANCE_2 * work[k - 7])))) {\n\n                \n                work[4 * deflatedEnd - 4] = sigma + work[4 * deflatedEnd - 4 + pingPong];\n                deflatedEnd -= 1;\n\n            } else if ((start == deflatedEnd - 2) ||\n                (work[k - 9] <= TOLERANCE_2 * sigma) ||\n                (work[k - 2 * pingPong - 8] <= TOLERANCE_2 * work[k - 11])) {\n\n                \n                if (work[k - 3] > work[k - 7]) {\n                    final double tmp = work[k - 3];\n                    work[k - 3] = work[k - 7];\n                    work[k - 7] = tmp;\n                }\n\n                if (work[k - 5] > TOLERANCE_2 * work[k - 3]) {\n                    double t = 0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5]);\n                    double s = work[k - 3] * (work[k - 5] / t);\n                    if (s <= t) {\n                        s = work[k - 3] * work[k - 5] / (t * (1 + Math.sqrt(1 + s / t)));\n                    } else {\n                        s = work[k - 3] * work[k - 5] / (t + Math.sqrt(t * (t + s)));\n                    }\n                    t = work[k - 7] + (s + work[k - 5]);\n                    work[k - 3] *= work[k - 7] / t;\n                    work[k - 7]  = t;\n                }\n                work[4 * deflatedEnd - 8] = sigma + work[k - 7];\n                work[4 * deflatedEnd - 4] = sigma + work[k - 3];\n                deflatedEnd -= 2;\n            } else {\n\n                \n                deflating = false;\n\n            }\n\n        }\n\n        final int l = 4 * deflatedEnd + pingPong - 1;\n\n        \n        if ((dMin <= 0) || (deflatedEnd < end)) {\n            if (flipIfWarranted(deflatedEnd, 1)) {\n                dMin2 = Math.min(dMin2, work[l - 1]);\n                work[l - 1] =\n                    Math.min(work[l - 1],\n                             Math.min(work[3 + pingPong], work[7 + pingPong]));\n                work[l - 2 * pingPong] =\n                    Math.min(work[l - 2 * pingPong],\n                             Math.min(work[6 + pingPong], work[6 + pingPong]));\n                qMax  = Math.max(qMax, Math.max(work[3 + pingPong], work[7 + pingPong]));\n                dMin  = -0.0;\n            }\n        }\n\n        if ((dMin < 0) ||\n            (MathUtils.SAFE_MIN * qMax < Math.min(work[l - 1],\n                                                  Math.min(work[l - 9],\n                                                           dMin2 + work[l - 2 * pingPong])))) {\n            \n            computeShiftIncrement(start, deflatedEnd, end - deflatedEnd);\n\n            \n            for (boolean loop = true; loop;) {\n\n                \n                dqds(start, deflatedEnd);\n\n                \n                if ((dMin >= 0) && (dMin1 > 0)) {\n                    \n                    updateSigma(tau);\n                    return deflatedEnd;\n                } else if ((dMin < 0.0) &&\n                           (dMin1 > 0.0) &&\n                           (work[4 * deflatedEnd - 5 - pingPong] < TOLERANCE * (sigma + dN1)) &&\n                           (Math.abs(dN) < TOLERANCE * sigma)) {\n                   \n                    work[4 * deflatedEnd - 3 - pingPong] = 0.0;\n                    dMin = 0.0;\n                    updateSigma(tau);\n                    return deflatedEnd;\n                } else if (dMin < 0.0) {\n                    \n                    if (tType < -22) {\n                        \n                        tau = 0.0;\n                    } else if (dMin1 > 0.0) {\n                        \n                        tau = (tau + dMin) * (1.0 - 2.0 * MathUtils.EPSILON);\n                        tType -= 11;\n                    } else {\n                        \n                        tau *= 0.25;\n                        tType -= 12;\n                    }\n                } else if (Double.isNaN(dMin)) {\n                    tau = 0.0;\n                } else {\n                    \n                    loop = false;\n                }\n            }\n\n        }\n\n        \n        dqd(start, deflatedEnd);\n\n        return deflatedEnd;\n\n    }\n\n    \n    private boolean flipIfWarranted(final int n, final int step) {\n        if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n            \n            int j = 4 * n - 1;\n            for (int i = 0; i < j; i += 4) {\n                for (int k = 0; k < 4; k += step) {\n                    final double tmp = work[i + k];\n                    work[i + k] = work[j - k];\n                    work[j - k] = tmp;\n                }\n                j -= 4;\n            }\n            return true;\n        }\n        return false;\n    }\n\n    \n    private double[] eigenvaluesRange(final int index, final int n) {\n\n        \n        final int lowerStart = 4 * main.length;\n        final int upperStart = 5 * main.length;\n        double lower = Double.POSITIVE_INFINITY;\n        double upper = Double.NEGATIVE_INFINITY;\n        for (int i = 0; i < n; ++i) {\n            lower = Math.min(lower, work[lowerStart + index +i]);\n            upper = Math.max(upper, work[upperStart + index +i]);\n        }\n\n        \n        final double tNorm = Math.max(Math.abs(lower), Math.abs(upper));\n        final double relativeTolerance = Math.sqrt(MathUtils.EPSILON);\n        final double absoluteTolerance = 4 * minPivot;\n        final int maxIter =\n            2 + (int) ((Math.log(tNorm + minPivot) - Math.log(minPivot)) / Math.log(2.0));\n        final double margin = 2 * (tNorm * MathUtils.EPSILON * n + 2 * minPivot);\n\n        \n        double left  = lower - margin;\n        double right = upper + margin;\n        for (int i = 0; i < maxIter; ++i) {\n\n            final double range = right - left;\n            if ((range < absoluteTolerance) ||\n                (range < relativeTolerance * Math.max(Math.abs(left), Math.abs(right)))) {\n                \n                break;\n            }\n\n            final double middle = 0.5 * (left + right);\n            if (countEigenValues(middle, index, n) >= 1) {\n                right = middle;\n            } else {\n                left = middle;\n            }\n\n        }\n        lower = Math.max(lower, left - 100 * MathUtils.EPSILON * Math.abs(left));\n\n        \n        left  = lower - margin;\n        right = upper + margin;\n        for (int i = 0; i < maxIter; ++i) {\n\n            final double range = right - left;\n            if ((range < absoluteTolerance) ||\n                (range < relativeTolerance * Math.max(Math.abs(left), Math.abs(right)))) {\n                \n                break;\n            }\n\n            final double middle = 0.5 * (left + right);\n            if (countEigenValues(middle, index, n) >= n) {\n                right = middle;\n            } else {\n                left = middle;\n            }\n\n        }\n        upper = Math.min(upper, right + 100 * MathUtils.EPSILON * Math.abs(right));\n\n        return new double[] { lower, upper };\n\n    }\n\n    \n    private int countEigenValues(final double t, final int index, final int n) {\n        double ratio = main[index] - t;\n        int count = (ratio > 0) ? 0 : 1;\n        for (int i = 1; i < n; ++i) {\n            ratio = main[index + i] - squaredSecondary[index + i - 1] / ratio - t;\n            if (ratio <= 0) {\n                ++count;\n            }\n        }\n        return count;\n    }\n\n    \n    private void ldlTDecomposition(final double lambda, final int index, final int n) {\n        double di = main[index] - lambda;\n        work[0] = Math.abs(di);\n        for (int i = 1; i < n; ++i) {\n            final int    fourI = 4 * i;\n            final double eiM1  = secondary[index + i - 1];\n            final double ratio = eiM1 / di;\n            work[fourI - 2] = ratio * ratio * Math.abs(di);\n            di = (main[index + i] - lambda) - eiM1 * ratio;\n            work[fourI] = Math.abs(di);\n        }\n    }\n\n    \n    private void dqds(final int start, final int end) {\n\n        eMin = work[4 * start + pingPong + 4];\n        double d = work[4 * start + pingPong] - tau;\n        dMin = d;\n        dMin1 = -work[4 * start + pingPong];\n\n        if (pingPong == 0) {\n            for (int j4 = 4 * start + 3; j4 <= 4 * (end - 3); j4 += 4) {\n                work[j4 - 2] = d + work[j4 - 1];\n                final double tmp = work[j4 + 1] / work[j4 - 2];\n                d = d * tmp - tau;\n                dMin = Math.min(dMin, d);\n                work[j4] = work[j4 - 1] * tmp;\n                eMin = Math.min(work[j4], eMin);\n            }\n        } else {\n            for (int j4 = 4 * start + 3; j4 <= 4 * (end - 3); j4 += 4) {\n                work[j4 - 3] = d + work[j4];\n                final double tmp = work[j4 + 2] / work[j4 - 3];\n                d = d * tmp - tau;\n                dMin = Math.min(dMin, d);\n                work[j4 - 1] = work[j4] * tmp;\n                eMin = Math.min(work[j4 - 1], eMin);\n            }\n        }\n\n        \n        dN2 = d;\n        dMin2 = dMin;\n        int j4 = 4 * (end - 2) - pingPong - 1;\n        int j4p2 = j4 + 2 * pingPong - 1;\n        work[j4 - 2] = dN2 + work[j4p2];\n        work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);\n        dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]) - tau;\n        dMin = Math.min(dMin, dN1);\n\n        dMin1 = dMin;\n        j4 = j4 + 4;\n        j4p2 = j4 + 2 * pingPong - 1;\n        work[j4 - 2] = dN1 + work[j4p2];\n        work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);\n        dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]) - tau;\n        dMin = Math.min(dMin, dN);\n\n        work[j4 + 2] = dN;\n        work[4 * end - pingPong - 1] = eMin;\n\n    }\n\n\n    \n    private void dqd(final int start, final int end) {\n\n        eMin = work[4 * start + pingPong + 4];\n        double d = work[4 * start + pingPong];\n        dMin = d;\n\n        if (pingPong == 0) {\n            for (int j4 = 4 * start + 3; j4 < 4 * (end - 3); j4 += 4) {\n                work[j4 - 2] = d + work[j4 - 1];\n                if (work[j4 - 2] == 0.0) {\n                    work[j4] = 0.0;\n                    d = work[j4 + 1];\n                    dMin = d;\n                    eMin = 0.0;\n                } else if ((MathUtils.SAFE_MIN * work[j4 + 1] < work[j4 - 2]) &&\n                           (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4 + 1])) {\n                    final double tmp = work[j4 + 1] / work[j4 - 2];\n                    work[j4] = work[j4 - 1] * tmp;\n                    d *= tmp;\n                } else {\n                    work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]);\n                    d *= work[j4 + 1] / work[j4 - 2];\n                }\n                dMin = Math.min(dMin, d);\n                eMin = Math.min(eMin, work[j4]);\n            }\n        } else {\n            for (int j4 = 4 * start + 3; j4 < 4 * (end - 3); j4 += 4) {\n                work[j4 - 3] = d + work[j4];\n                if (work[j4 - 3] == 0.0) {\n                    work[j4 - 1] = 0.0;\n                    d = work[j4 + 2];\n                    dMin = d;\n                    eMin = 0.0;\n                } else if ((MathUtils.SAFE_MIN * work[j4 + 2] < work[j4 - 3]) &&\n                           (MathUtils.SAFE_MIN * work[j4 - 3] < work[j4 + 2])) {\n                    final double tmp = work[j4 + 2] / work[j4 - 3];\n                    work[j4 - 1] = work[j4] * tmp;\n                    d *= tmp;\n                } else {\n                    work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]);\n                    d *= work[j4 + 2] / work[j4 - 3];\n                }\n                dMin = Math.min(dMin, d);\n                eMin = Math.min(eMin, work[j4 - 1]);\n            }\n        }\n\n        \n        dN2   = d;\n        dMin2 = dMin;\n        int j4 = 4 * (end - 2) - pingPong - 1;\n        int j4p2 = j4 + 2 * pingPong - 1;\n        work[j4 - 2] = dN2 + work[j4p2];\n        if (work[j4 - 2] == 0.0) {\n            work[j4] = 0.0;\n            dN1  = work[j4p2 + 2];\n            dMin = dN1;\n            eMin = 0.0;\n        } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&\n                   (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {\n            final double tmp = work[j4p2 + 2] / work[j4 - 2];\n            work[j4] = work[j4p2] * tmp;\n            dN1 = dN2 * tmp;\n        } else {\n            work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);\n            dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);\n        }\n        dMin = Math.min(dMin, dN1);\n\n        dMin1 = dMin;\n        j4 = j4 + 4;\n        j4p2 = j4 + 2 * pingPong - 1;\n        work[j4 - 2] = dN1 + work[j4p2];\n        if (work[j4 - 2] == 0.0) {\n            work[j4] = 0.0;\n            dN   = work[j4p2 + 2];\n            dMin = dN;\n            eMin = 0.0;\n        } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&\n                   (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {\n            final double tmp = work[j4p2 + 2] / work[j4 - 2];\n            work[j4] = work[j4p2] * tmp;\n            dN = dN1 * tmp;\n        } else {\n            work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);\n            dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);\n        }\n        dMin = Math.min(dMin, dN);\n\n        work[j4 + 2] = dN;\n        work[4 * end - pingPong - 1] = eMin;\n\n    }\n\n    \n    private void computeShiftIncrement(final int start, final int end, final int deflated) {\n\n        final double cnst1 = 0.563;\n        final double cnst2 = 1.010;\n        final double cnst3 = 1.05;\n\n        \n        \n        if (dMin <= 0.0) {\n            tau = -dMin;\n            tType = -1;\n            return;\n        }\n\n        int nn = 4 * end + pingPong - 1;\n        switch (deflated) {\n\n        case 0 : \n            if (dMin == dN || dMin == dN1) {\n\n                double b1 = Math.sqrt(work[nn - 3]) * Math.sqrt(work[nn - 5]);\n                double b2 = Math.sqrt(work[nn - 7]) * Math.sqrt(work[nn - 9]);\n                double a2 = work[nn - 7] + work[nn - 5];\n\n                if (dMin == dN && dMin1 == dN1) {\n                    \n                    final double gap2 = dMin2 - a2 - dMin2 * 0.25;\n                    final double gap1 = a2 - dN - ((gap2 > 0.0 && gap2 > b2) ? (b2 / gap2) * b2 : (b1 + b2));\n                    if (gap1 > 0.0 && gap1 > b1) {\n                        tau   = Math.max(dN - (b1 / gap1) * b1, 0.5 * dMin);\n                        tType = -2;\n                    } else {\n                        double s = 0.0;\n                        if (dN > b1) {\n                            s = dN - b1;\n                        }\n                        if (a2 > (b1 + b2)) {\n                            s = Math.min(s, a2 - (b1 + b2));\n                        }\n                        tau   = Math.max(s, 0.333 * dMin);\n                        tType = -3;\n                    }\n                } else {\n                    \n                    tType = -4;\n                    double s = 0.25 * dMin;\n                    double gam;\n                    int np;\n                    if (dMin == dN) {\n                        gam = dN;\n                        a2 = 0.0;\n                        if (work[nn - 5]  >  work[nn - 7]) {\n                            return;\n                        }\n                        b2 = work[nn - 5] / work[nn - 7];\n                        np = nn - 9;\n                    } else {\n                        np = nn - 2 * pingPong;\n                        b2 = work[np - 2];\n                        gam = dN1;\n                        if (work[np - 4]  >  work[np - 2]) {\n                            return;\n                        }\n                        a2 = work[np - 4] / work[np - 2];\n                        if (work[nn - 9]  >  work[nn - 11]) {\n                            return;\n                        }\n                        b2 = work[nn - 9] / work[nn - 11];\n                        np = nn - 13;\n                    }\n\n                    \n                    a2 = a2 + b2;\n                    for (int i4 = np; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        if(b2 == 0.0) {\n                            break;\n                        }\n                        b1 = b2;\n                        if (work[i4]  >  work[i4 - 2]) {\n                            return;\n                        }\n                        b2 = b2 * (work[i4] / work[i4 - 2]);\n                        a2 = a2 + b2;\n                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2) {\n                            break;\n                        }\n                    }\n                    a2 = cnst3 * a2;\n\n                    \n                    if (a2 < cnst1) {\n                        s = gam * (1 - Math.sqrt(a2)) / (1 + a2);\n                    }\n                    tau = s;\n\n                }\n            } else if (dMin == dN2) {\n\n                \n                tType = -5;\n                double s = 0.25 * dMin;\n\n                \n                final int np = nn - 2 * pingPong;\n                double b1 = work[np - 2];\n                double b2 = work[np - 6];\n                final double gam = dN2;\n                if (work[np - 8] > b2 || work[np - 4] > b1) {\n                    return;\n                }\n                double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);\n\n                \n                if (end - start > 2) {\n                    b2 = work[nn - 13] / work[nn - 15];\n                    a2 = a2 + b2;\n                    for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        if (b2 == 0.0) {\n                            break;\n                        }\n                        b1 = b2;\n                        if (work[i4]  >  work[i4 - 2]) {\n                            return;\n                        }\n                        b2 = b2 * (work[i4] / work[i4 - 2]);\n                        a2 = a2 + b2;\n                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2)  {\n                            break;\n                        }\n                    }\n                    a2 = cnst3 * a2;\n                }\n\n                if (a2 < cnst1) {\n                    tau = gam * (1 - Math.sqrt(a2)) / (1 + a2);\n                } else {\n                    tau = s;\n                }\n\n            } else {\n\n                \n                if (tType == -6) {\n                    g += 0.333 * (1 - g);\n                } else if (tType == -18) {\n                    g = 0.25 * 0.333;\n                } else {\n                    g = 0.25;\n                }\n                tau   = g * dMin;\n                tType = -6;\n\n            }\n            break;\n\n        case 1 : \n            if (dMin1 == dN1 && dMin2 == dN2) {\n\n                \n                tType = -7;\n                double s = 0.333 * dMin1;\n                if (work[nn - 5] > work[nn - 7]) {\n                    return;\n                }\n                double b1 = work[nn - 5] / work[nn - 7];\n                double b2 = b1;\n                if (b2 != 0.0) {\n                    for (int i4 = 4 * end - 10 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        final double oldB1 = b1;\n                        if (work[i4] > work[i4 - 2]) {\n                            return;\n                        }\n                        b1 = b1 * (work[i4] / work[i4 - 2]);\n                        b2 = b2 + b1;\n                        if (100 * Math.max(b1, oldB1) < b2) {\n                            break;\n                        }\n                    }\n                }\n                b2 = Math.sqrt(cnst3 * b2);\n                final double a2 = dMin1 / (1 + b2 * b2);\n                final double gap2 = 0.5 * dMin2 - a2;\n                if (gap2 > 0.0 && gap2 > b2 * a2) {\n                    tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));\n                } else {\n                    tau = Math.max(s, a2 * (1 - cnst2 * b2));\n                    tType = -8;\n                }\n            } else {\n\n                \n                tau = 0.25 * dMin1;\n                if (dMin1 == dN1) {\n                    tau = 0.5 * dMin1;\n                }\n                tType = -9;\n            }\n            break;\n\n        case 2 : \n\n            \n            if (dMin2 == dN2 && 2 * work[nn - 5] < work[nn - 7]) {\n                tType = -10;\n                final double s = 0.333 * dMin2;\n                if (work[nn - 5] > work[nn - 7]) {\n                    return;\n                }\n                double b1 = work[nn - 5] / work[nn - 7];\n                double b2 = b1;\n                if (b2 != 0.0){\n                    for (int i4 = 4 * end - 9 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        if (work[i4] > work[i4 - 2]) {\n                            return;\n                        }\n                        b1 *= work[i4] / work[i4 - 2];\n                        b2 += b1;\n                        if (100 * b1 < b2) {\n                            break;\n                        }\n                    }\n                }\n                b2 = Math.sqrt(cnst3 * b2);\n                final double a2 = dMin2 / (1 + b2 * b2);\n                final double gap2 = work[nn - 7] + work[nn - 9] -\n                Math.sqrt(work[nn - 11]) * Math.sqrt(work[nn - 9]) - a2;\n                if (gap2 > 0.0 && gap2 > b2 * a2) {\n                    tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));\n                } else {\n                    tau = Math.max(s, a2 * (1 - cnst2 * b2));\n                }\n            } else {\n                tau   = 0.25 * dMin2;\n                tType = -11;\n            }\n            break;\n\n        default : \n            tau   = 0.0;\n            tType = -12;\n        }\n\n    }\n\n    \n    private void updateSigma(final double shift) {\n        \n        \n        \n        if (shift < sigma) {\n            sigmaLow += shift;\n            final double t = sigma + sigmaLow;\n            sigmaLow -= t - sigma;\n            sigma = t;\n        } else {\n            final double t = sigma + shift;\n            sigmaLow += sigma - (t - shift);\n            sigma = t;\n        }\n    }\n\n    \n    private void findEigenVectors() {\n\n        final int m = main.length;\n        eigenvectors = new ArrayRealVector[m];\n\n        \n        final double[] d = new double[m];\n        final double[] l = new double[m - 1];\n        \n        final double mu = realEigenvalues[m-1] <= 0 && realEigenvalues[0] > 0 ? 0.5-realEigenvalues[m-1] : 0;\n        double di = main[0]+mu;\n        d[0] = di;\n        for (int i = 1; i < m; ++i) {\n            final double eiM1  = secondary[i - 1];\n            final double ratio = eiM1 / di;\n            di       = main[i] - eiM1 * ratio + mu;\n            l[i - 1] = ratio;\n            d[i]     = di;\n        }\n\n        \n        for (int i = 0; i < m; ++i) {\n            eigenvectors[i] = findEigenvector(realEigenvalues[i]+mu, d, l);\n        }\n\n    }\n\n    \n    private ArrayRealVector findEigenvector(final double eigenvalue, final double[] d, final double[] l) {\n\n        \n        \n        final int m = main.length;\n        stationaryQuotientDifferenceWithShift(d, l, eigenvalue);\n        progressiveQuotientDifferenceWithShift(d, l, eigenvalue);\n\n        \n        \n        int r = m - 1;\n        double minG = Math.abs(work[6 * r] + work[6 * r + 3] + eigenvalue);\n        int sixI = 0;\n        for (int i = 0; i < m - 1; ++i) {\n            final double absG = Math.abs(work[sixI] + d[i] * work[sixI + 9] / work[sixI + 10]);\n            if (absG < minG) {\n                r = i;\n                minG = absG;\n            }\n            sixI += 6;\n        }\n\n        \n        \n        double[] eigenvector = new double[m];\n        double n2 = 1;\n        eigenvector[r] = 1;\n        double z = 1;\n        for (int i = r - 1; i >= 0; --i) {\n            z *= -work[6 * i + 2];\n            eigenvector[i] = z;\n            n2 += z * z;\n        }\n        z = 1;\n        for (int i = r + 1; i < m; ++i) {\n            z *= -work[6 * i - 1];\n            eigenvector[i] = z;\n            n2 += z * z;\n        }\n\n        \n        final double inv = 1.0 / Math.sqrt(n2);\n        for (int i = 0; i < m; ++i) {\n            eigenvector[i] *= inv;\n        }\n\n        return (transformer == null) ?\n               new ArrayRealVector(eigenvector, false) :\n               new ArrayRealVector(transformer.getQ().operate(eigenvector), false);\n\n    }\n\n    \n    private void stationaryQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) {\n        final int nM1 = d.length - 1;\n        double si = -lambda;\n        int sixI = 0;\n        for (int i = 0; i < nM1; ++i) {\n            final double di   = d[i];\n            final double li   = l[i];\n            final double diP1 = di + si;\n            final double liP1 = li * di / diP1;\n            work[sixI]        = si;\n            work[sixI + 1]    = diP1;\n            work[sixI + 2]    = liP1;\n            si = li * liP1 * si - lambda;\n            sixI += 6;\n        }\n        work[6 * nM1 + 1] = d[nM1] + si;\n        work[6 * nM1]     = si;\n    }\n\n    \n    private void progressiveQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) {\n        final int nM1 = d.length - 1;\n        double pi = d[nM1] - lambda;\n        int sixI = 6 * (nM1 - 1);\n        for (int i = nM1 - 1; i >= 0; --i) {\n            final double di   = d[i];\n            final double li   = l[i];\n            final double diP1 = di * li * li + pi;\n            final double t    = di / diP1;\n            work[sixI +  9]   = pi;\n            work[sixI + 10]   = diP1;\n            work[sixI +  5]   = li * t;\n            pi = pi * t - lambda;\n            sixI -= 6;\n        }\n        work[3] = pi;\n        work[4] = pi;\n    }\n\n}\n",
      "fixed_full_code": "\n\npackage org.apache.commons.math.linear;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\nimport org.apache.commons.math.MathRuntimeException;\nimport org.apache.commons.math.MaxIterationsExceededException;\nimport org.apache.commons.math.util.MathUtils;\n\n\npublic class EigenDecompositionImpl implements EigenDecomposition { private static final double TOLERANCE = 100 * MathUtils.EPSILON; private static final double TOLERANCE_2 = TOLERANCE * TOLERANCE; private double splitTolerance; private double[] main; private double[] secondary; private double[] squaredSecondary; private TriDiagonalTransformer transformer; private double lowerSpectra; private double upperSpectra; private double minPivot; private double sigma; private double sigmaLow; private double tau; private double[] work; private int pingPong; private double qMax; private double eMin; private int tType; private double dMin; private double dMin1; private double dMin2; private double dN; private double dN1; private double dN2; private double g; private double[] realEigenvalues; private double[] imagEigenvalues; private ArrayRealVector[] eigenvectors; private RealMatrix cachedV; private RealMatrix cachedD; private RealMatrix cachedVt; public EigenDecompositionImpl(final RealMatrix matrix, final double splitTolerance) throws InvalidMatrixException {\n        if (isSymmetric(matrix)) {\n            this.splitTolerance = splitTolerance;\n            transformToTridiagonal(matrix);\n            decompose();\n        } else {\n            \n            \n            throw new InvalidMatrixException(\"eigen decomposition of assymetric matrices not supported yet\");\n        }\n    }\n\n    \n    public EigenDecompositionImpl(final double[] main, double[] secondary, final double splitTolerance) throws InvalidMatrixException {\n\n        this.main      = main.clone();\n        this.secondary = secondary.clone();\n        transformer    = null;\n\n        \n        squaredSecondary = new double[secondary.length];\n        for (int i = 0; i < squaredSecondary.length; ++i) {\n            final double s = secondary[i];\n            squaredSecondary[i] = s * s;\n        }\n\n        this.splitTolerance = splitTolerance;\n        decompose();\n\n    }\n\n    \n    private boolean isSymmetric(final RealMatrix matrix) {\n        final int rows    = matrix.getRowDimension();\n        final int columns = matrix.getColumnDimension();\n        final double eps  = 10 * rows * columns * MathUtils.EPSILON;\n        for (int i = 0; i < rows; ++i) {\n            for (int j = i + 1; j < columns; ++j) {\n                final double mij = matrix.getEntry(i, j);\n                final double mji = matrix.getEntry(j, i);\n                if (Math.abs(mij - mji) > (Math.max(Math.abs(mij), Math.abs(mji)) * eps)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    \n    private void decompose() {\n\n        cachedV  = null;\n        cachedD  = null;\n        cachedVt = null;\n        work     = new double[6 * main.length];\n\n        \n        computeGershgorinCircles();\n\n        \n        findEigenvalues();\n\n        \n        eigenvectors = null;\n\n    }\n\n    \n    public RealMatrix getV() throws InvalidMatrixException {\n\n        if (cachedV == null) {\n\n            if (eigenvectors == null) {\n                findEigenVectors();\n            }\n\n            final int m = eigenvectors.length;\n            cachedV = MatrixUtils.createRealMatrix(m, m);\n            for (int k = 0; k < m; ++k) {\n                cachedV.setColumnVector(k, eigenvectors[k]);\n            }\n\n        }\n\n        \n        return cachedV;\n\n    }\n\n    \n    public RealMatrix getD() throws InvalidMatrixException {\n        if (cachedD == null) {\n            \n            cachedD = MatrixUtils.createRealDiagonalMatrix(realEigenvalues);\n        }\n        return cachedD;\n    }\n\n    \n    public RealMatrix getVT() throws InvalidMatrixException {\n\n        if (cachedVt == null) {\n\n            if (eigenvectors == null) {\n                findEigenVectors();\n            }\n\n            final int m = eigenvectors.length;\n            cachedVt = MatrixUtils.createRealMatrix(m, m);\n            for (int k = 0; k < m; ++k) {\n                cachedVt.setRowVector(k, eigenvectors[k]);\n            }\n\n        }\n\n        \n        return cachedVt;\n\n    }\n\n    \n    public double[] getRealEigenvalues() throws InvalidMatrixException {\n        return realEigenvalues.clone();\n    }\n\n    \n    public double getRealEigenvalue(final int i) throws InvalidMatrixException, ArrayIndexOutOfBoundsException {\n        return realEigenvalues[i];\n    }\n\n    \n    public double[] getImagEigenvalues() throws InvalidMatrixException {\n        return imagEigenvalues.clone();\n    }\n\n    \n    public double getImagEigenvalue(final int i) throws InvalidMatrixException, ArrayIndexOutOfBoundsException {\n        return imagEigenvalues[i];\n    }\n\n    \n    public RealVector getEigenvector(final int i) throws InvalidMatrixException, ArrayIndexOutOfBoundsException {\n        if (eigenvectors == null) {\n            findEigenVectors();\n        }\n        return eigenvectors[i].copy();\n    }\n\n    \n    public double getDeterminant() {\n        double determinant = 1;\n        for (double lambda : realEigenvalues) {\n            determinant *= lambda;\n        }\n        return determinant;\n    }\n\n    \n    public DecompositionSolver getSolver() {\n        if (eigenvectors == null) {\n            findEigenVectors();\n        }\n        return new Solver(realEigenvalues, imagEigenvalues, eigenvectors);\n    }\n\n    \n    private static class Solver implements DecompositionSolver { private double[] realEigenvalues; private double[] imagEigenvalues; private final ArrayRealVector[] eigenvectors; private Solver(final double[] realEigenvalues, final double[] imagEigenvalues, final ArrayRealVector[] eigenvectors) {\n            this.realEigenvalues = realEigenvalues;\n            this.imagEigenvalues = imagEigenvalues;\n            this.eigenvectors    = eigenvectors;\n        }\n\n        \n        public double[] solve(final double[] b) throws IllegalArgumentException, InvalidMatrixException {\n\n            if (!isNonSingular()) {\n                throw new SingularMatrixException();\n            }\n\n            final int m = realEigenvalues.length;\n            if (b.length != m) {\n                throw MathRuntimeException.createIllegalArgumentException(\n                        \"vector length mismatch: got {0} but expected {1}\",\n                        b.length, m);\n            }\n\n            final double[] bp = new double[m];\n            for (int i = 0; i < m; ++i) {\n                final ArrayRealVector v = eigenvectors[i];\n                final double[] vData = v.getDataRef();\n                final double s = v.dotProduct(b) / realEigenvalues[i];\n                for (int j = 0; j < m; ++j) {\n                    bp[j] += s * vData[j];\n                }\n            }\n\n            return bp;\n\n        }\n\n        \n        public RealVector solve(final RealVector b) throws IllegalArgumentException, InvalidMatrixException {\n\n            if (!isNonSingular()) {\n                throw new SingularMatrixException();\n            }\n\n            final int m = realEigenvalues.length;\n            if (b.getDimension() != m) {\n                throw MathRuntimeException.createIllegalArgumentException(\n                        \"vector length mismatch: got {0} but expected {1}\",\n                        b.getDimension(), m);\n            }\n\n            final double[] bp = new double[m];\n            for (int i = 0; i < m; ++i) {\n                final ArrayRealVector v = eigenvectors[i];\n                final double[] vData = v.getDataRef();\n                final double s = v.dotProduct(b) / realEigenvalues[i];\n                for (int j = 0; j < m; ++j) {\n                    bp[j] += s * vData[j];\n                }\n            }\n\n            return new ArrayRealVector(bp, false);\n\n        }\n\n        \n        public RealMatrix solve(final RealMatrix b) throws IllegalArgumentException, InvalidMatrixException {\n\n            if (!isNonSingular()) {\n                throw new SingularMatrixException();\n            }\n\n            final int m = realEigenvalues.length;\n            if (b.getRowDimension() != m) {\n                throw MathRuntimeException.createIllegalArgumentException(\n                        \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n                        b.getRowDimension(), b.getColumnDimension(), m, \"n\");\n            }\n\n            final int nColB = b.getColumnDimension();\n            final double[][] bp = new double[m][nColB];\n            for (int k = 0; k < nColB; ++k) {\n                for (int i = 0; i < m; ++i) {\n                    final ArrayRealVector v = eigenvectors[i];\n                    final double[] vData = v.getDataRef();\n                    double s = 0;\n                    for (int j = 0; j < m; ++j) {\n                        s += v.getEntry(j) * b.getEntry(j, k);\n                    }\n                    s /= realEigenvalues[i];\n                    for (int j = 0; j < m; ++j) {\n                        bp[j][k] += s * vData[j];\n                    }\n                }\n            }\n\n            return MatrixUtils.createRealMatrix(bp);\n\n        }\n\n        \n        public boolean isNonSingular() {\n            for (int i = 0; i < realEigenvalues.length; ++i) {\n                if ((realEigenvalues[i] == 0) && (imagEigenvalues[i] == 0)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        \n        public RealMatrix getInverse() throws InvalidMatrixException {\n\n            if (!isNonSingular()) {\n                throw new SingularMatrixException();\n            }\n\n            final int m = realEigenvalues.length;\n            final double[][] invData = new double[m][m];\n\n            for (int i = 0; i < m; ++i) {\n                final double[] invI = invData[i];\n                for (int j = 0; j < m; ++j) {\n                    double invIJ = 0;\n                    for (int k = 0; k < m; ++k) {\n                        final double[] vK = eigenvectors[k].getDataRef();\n                        invIJ += vK[i] * vK[j] / realEigenvalues[k];\n                    }\n                    invI[j] = invIJ;\n                }\n            }\n            return MatrixUtils.createRealMatrix(invData);\n\n        }\n\n    }\n\n    \n    private void transformToTridiagonal(final RealMatrix matrix) {\n\n        \n        transformer = new TriDiagonalTransformer(matrix);\n        main      = transformer.getMainDiagonalRef();\n        secondary = transformer.getSecondaryDiagonalRef();\n\n        \n        squaredSecondary = new double[secondary.length];\n        for (int i = 0; i < squaredSecondary.length; ++i) {\n            final double s = secondary[i];\n            squaredSecondary[i] = s * s;\n        }\n\n    }\n\n    \n    private void computeGershgorinCircles() {\n\n        final int m     = main.length;\n        final int lowerStart = 4 * m;\n        final int upperStart = 5 * m;\n        lowerSpectra = Double.POSITIVE_INFINITY;\n        upperSpectra = Double.NEGATIVE_INFINITY;\n        double eMax = 0;\n\n        double eCurrent = 0;\n        for (int i = 0; i < m - 1; ++i) {\n\n            final double dCurrent = main[i];\n            final double ePrevious = eCurrent;\n            eCurrent = Math.abs(secondary[i]);\n            eMax = Math.max(eMax, eCurrent);\n            final double radius = ePrevious + eCurrent;\n\n            final double lower = dCurrent - radius;\n            work[lowerStart + i] = lower;\n            lowerSpectra = Math.min(lowerSpectra, lower);\n\n            final double upper = dCurrent + radius;\n            work[upperStart + i] = upper;\n            upperSpectra = Math.max(upperSpectra, upper);\n\n        }\n\n        final double dCurrent = main[m - 1];\n        final double lower = dCurrent - eCurrent;\n        work[lowerStart + m - 1] = lower;\n        lowerSpectra = Math.min(lowerSpectra, lower);\n        final double upper = dCurrent + eCurrent;\n        work[upperStart + m - 1] = upper;\n        upperSpectra = Math.max(upperSpectra, upper);\n        minPivot = MathUtils.SAFE_MIN * Math.max(1.0, eMax * eMax);\n\n    }\n\n    \n    private void findEigenvalues() throws InvalidMatrixException {\n\n        \n        List<Integer> splitIndices = computeSplits();\n\n        \n        realEigenvalues = new double[main.length];\n        imagEigenvalues = new double[main.length];\n        int begin = 0;\n        for (final int end : splitIndices) {\n            final int n = end - begin;\n            switch (n) {\n\n            case 1:\n                \n                process1RowBlock(begin);\n                break;\n\n            case 2:\n                \n                process2RowsBlock(begin);\n                break;\n\n            case 3:\n                \n                process3RowsBlock(begin);\n                break;\n\n            default:\n\n                \n                final double[] range       = eigenvaluesRange(begin, n);\n                final double oneFourth     = 0.25 * (3 * range[0] + range[1]);\n                final int oneFourthCount   = countEigenValues(oneFourth, begin, n);\n                final double threeFourth   = 0.25 * (range[0] + 3 * range[1]);\n                final int threeFourthCount = countEigenValues(threeFourth, begin, n);\n                final boolean chooseLeft   = (oneFourthCount - 1) >= (n - threeFourthCount);\n                final double lambda        = chooseLeft ? range[0] : range[1];\n\n                tau = (range[1] - range[0]) * MathUtils.EPSILON * n + 2 * minPivot;\n\n                \n                ldlTDecomposition(lambda, begin, n);\n\n                \n                processGeneralBlock(n);\n\n                \n                if (chooseLeft) {\n                    for (int i = 0; i < n; ++i) {\n                        realEigenvalues[begin + i] = lambda + work[4 * i];\n                    }\n                } else {\n                    for (int i = 0; i < n; ++i) {\n                        realEigenvalues[begin + i] = lambda - work[4 * i];\n                    }\n                }\n\n            }\n            begin = end;\n        }\n\n        \n        Arrays.sort(realEigenvalues);\n        int j = realEigenvalues.length - 1;\n        for (int i = 0; i < j; ++i) {\n            final double tmp = realEigenvalues[i];\n            realEigenvalues[i] = realEigenvalues[j];\n            realEigenvalues[j] = tmp;\n            --j;\n        }\n\n    }\n\n    \n    private List<Integer> computeSplits() {\n\n        final List<Integer> list = new ArrayList<Integer>();\n\n        \n        double absDCurrent = Math.abs(main[0]);\n        for (int i = 0; i < secondary.length; ++i) {\n            final double absDPrevious = absDCurrent;\n            absDCurrent = Math.abs(main[i + 1]);\n            final double max = splitTolerance * Math.sqrt(absDPrevious * absDCurrent);\n            if (Math.abs(secondary[i]) <= max) {\n                list.add(i + 1);\n                secondary[i] = 0;\n                squaredSecondary[i] = 0;\n            }\n        }\n\n        list.add(secondary.length + 1);\n        return list;\n\n    }\n\n    \n    private void process1RowBlock(final int index) {\n        realEigenvalues[index] = main[index];\n    }\n\n    \n    private void process2RowsBlock(final int index) throws InvalidMatrixException {\n\n        \n        \n        final double q0   = main[index];\n        final double q1   = main[index + 1];\n        final double e12  = squaredSecondary[index];\n\n        final double s     = q0 + q1;\n        final double p     = q0 * q1 - e12;\n        final double delta = s * s - 4 * p;\n        if (delta < 0) {\n            throw new InvalidMatrixException(\"cannot solve degree {0} equation\", 2);\n        }\n\n        final double largestRoot = 0.5 * (s + Math.sqrt(delta));\n        realEigenvalues[index]     = largestRoot;\n        realEigenvalues[index + 1] = p / largestRoot;\n\n    }\n\n    \n    private void process3RowsBlock(final int index) throws InvalidMatrixException {\n\n        \n        \n        final double q0       = main[index];\n        final double q1       = main[index + 1];\n        final double q2       = main[index + 2];\n        final double e12      = squaredSecondary[index];\n        final double q1q2Me22 = q1 * q2 - squaredSecondary[index + 1];\n\n        \n        final double b        = -(q0 + q1 + q2);\n        final double c        = q0 * q1 + q0 * q2 + q1q2Me22 - e12;\n        final double d        = q2 * e12 - q0 * q1q2Me22;\n\n        \n        final double b2       = b * b;\n        final double q        = (3 * c - b2) / 9;\n        final double r        = ((9 * c - 2 * b2) * b - 27 * d) / 54;\n        final double delta    = q * q * q + r * r;\n        if (delta >= 0) {\n            \n            \n            \n            throw new InvalidMatrixException(\"cannot solve degree {0} equation\", 3);\n        }\n        final double sqrtMq = Math.sqrt(-q);\n        final double theta  = Math.acos(r / (-q * sqrtMq));\n        final double alpha  = 2 * sqrtMq;\n        final double beta   = b / 3;\n\n        double z0 = alpha * Math.cos(theta / 3) - beta;\n        double z1 = alpha * Math.cos((theta + 2 * Math.PI) / 3) - beta;\n        double z2 = alpha * Math.cos((theta + 4 * Math.PI) / 3) - beta;\n        if (z0 < z1) {\n            final double t = z0;\n            z0 = z1;\n            z1 = t;\n        }\n        if (z1 < z2) {\n            final double t = z1;\n            z1 = z2;\n            z2 = t;\n        }\n        if (z0 < z1) {\n            final double t = z0;\n            z0 = z1;\n            z1 = t;\n        }\n        realEigenvalues[index]     = z0;\n        realEigenvalues[index + 1] = z1;\n        realEigenvalues[index + 2] = z2;\n\n    }\n\n    \n    private void processGeneralBlock(final int n) throws InvalidMatrixException {\n\n        \n        double sumOffDiag = 0;\n        for (int i = 0; i < n - 1; ++i) {\n            final int fourI = 4 * i;\n            final double ei = work[fourI + 2];\n            sumOffDiag += ei;\n        }\n\n        if (sumOffDiag == 0) {\n            \n            return;\n        }\n\n        \n        flipIfWarranted(n, 2);\n\n        \n        initialSplits(n);\n\n        \n        tType = 0;\n        dMin1 = 0;\n        dMin2 = 0;\n        dN    = 0;\n        dN1   = 0;\n        dN2   = 0;\n        tau   = 0;\n\n        \n        int i0 = 0;\n        int n0 = n;\n        while (n0 > 0) {\n\n            \n            sigma    = (n0 == n) ? 0 : -work[4 * n0 - 2];\n            sigmaLow = 0;\n\n            \n            double offDiagMin = (i0 == n0) ? 0 : work[4 * n0 - 6];\n            double offDiagMax = 0;\n            double diagMax    = work[4 * n0 - 4];\n            double diagMin    = diagMax;\n            i0 = 0;\n            for (int i = 4 * (n0 - 2); i >= 0; i -= 4) {\n                if (work[i + 2] <= 0) {\n                    i0 = 1 + i / 4;\n                    break;\n                }\n                if (diagMin >= 4 * offDiagMax) {\n                    diagMin    = Math.min(diagMin, work[i + 4]);\n                    offDiagMax = Math.max(offDiagMax, work[i + 2]);\n                }\n                diagMax    = Math.max(diagMax, work[i] + work[i + 2]);\n                offDiagMin = Math.min(offDiagMin, work[i + 2]);\n            }\n            work[4 * n0 - 2] = offDiagMin;\n\n            \n            dMin = -Math.max(0, diagMin - 2 * Math.sqrt(diagMin * offDiagMax));\n\n            pingPong = 0;\n            int maxIter = 30 * (n0 - i0);\n            for (int k = 0; i0 < n0; ++k) {\n                if (k >= maxIter) {\n                    throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));\n                }\n\n                \n                n0 = goodStep(i0, n0);\n                pingPong = 1 - pingPong;\n\n                \n                \n                if ((pingPong == 0) && (n0 - i0 > 3) &&\n                    (work[4 * n0 - 1] <= TOLERANCE_2 * diagMax) &&\n                    (work[4 * n0 - 2] <= TOLERANCE_2 * sigma)) {\n                    int split  = i0 - 1;\n                    diagMax    = work[4 * i0];\n                    offDiagMin = work[4 * i0 + 2];\n                    double previousEMin = work[4 * i0 + 3];\n                    for (int i = 4 * i0; i < 4 * n0 - 16; i += 4) {\n                        if ((work[i + 3] <= TOLERANCE_2 * work[i]) ||\n                            (work[i + 2] <= TOLERANCE_2 * sigma)) {\n                            \n                            work[i + 2]  = -sigma;\n                            split        = i / 4;\n                            diagMax      = 0;\n                            offDiagMin   = work[i + 6];\n                            previousEMin = work[i + 7];\n                        } else {\n                            diagMax      = Math.max(diagMax, work[i + 4]);\n                            offDiagMin   = Math.min(offDiagMin, work[i + 2]);\n                            previousEMin = Math.min(previousEMin, work[i + 3]);\n                        }\n                    }\n                    work[4 * n0 - 2] = offDiagMin;\n                    work[4 * n0 - 1] = previousEMin;\n                    i0 = split + 1;\n                }\n            }\n\n        }\n\n    }\n\n    \n    private void initialSplits(final int n) {\n\n        pingPong = 0;\n        for (int k = 0; k < 2; ++k) {\n\n            \n            double d = work[4 * (n - 1) + pingPong];\n            for (int i = 4 * (n - 2) + pingPong; i >= 0; i -= 4) {\n                if (work[i + 2] <= TOLERANCE_2 * d) {\n                    work[i + 2] = -0.0;\n                    d = work[i];\n                } else {\n                    d *= work[i] / (d + work[i + 2]);\n                }\n            }\n\n            \n            d = work[pingPong];\n            for (int i = 2 + pingPong; i < 4 * n - 2; i += 4) {\n                final int j = i - 2 * pingPong - 1;\n                work[j] = d + work[i];\n                if (work[i] <= TOLERANCE_2 * d) {\n                    work[i]     = -0.0;\n                    work[j]     = d;\n                    work[j + 2] = 0.0;\n                    d = work[i + 2];\n                } else if ((MathUtils.SAFE_MIN * work[i + 2] < work[j]) &&\n                           (MathUtils.SAFE_MIN * work[j] < work[i + 2])) {\n                    final double tmp = work[i + 2] / work[j];\n                    work[j + 2] = work[i] * tmp;\n                    d *= tmp;\n                } else {\n                    work[j + 2] = work[i + 2] * (work[i] / work[j]);\n                    d *= work[i + 2] / work[j];\n               }\n            }\n            work[4 * n - 3 - pingPong] = d;\n\n            \n            pingPong = 1 - pingPong;\n\n        }\n\n    }\n\n    \n    private int goodStep(final int start, final int end) {\n\n        g = 0.0;\n\n        \n        int deflatedEnd = end;\n        for (boolean deflating = true; deflating;) {\n\n            if (start >= deflatedEnd) {\n                \n                return deflatedEnd;\n            }\n\n            final int k = 4 * deflatedEnd + pingPong - 1;\n\n            if ((start == deflatedEnd - 1) ||\n                ((start != deflatedEnd - 2) &&\n                 ((work[k - 5] <= TOLERANCE_2 * (sigma + work[k - 3])) ||\n                  (work[k - 2 * pingPong - 4] <= TOLERANCE_2 * work[k - 7])))) {\n\n                \n                work[4 * deflatedEnd - 4] = sigma + work[4 * deflatedEnd - 4 + pingPong];\n                deflatedEnd -= 1;\n\n            } else if ((start == deflatedEnd - 2) ||\n                (work[k - 9] <= TOLERANCE_2 * sigma) ||\n                (work[k - 2 * pingPong - 8] <= TOLERANCE_2 * work[k - 11])) {\n\n                \n                if (work[k - 3] > work[k - 7]) {\n                    final double tmp = work[k - 3];\n                    work[k - 3] = work[k - 7];\n                    work[k - 7] = tmp;\n                }\n\n                if (work[k - 5] > TOLERANCE_2 * work[k - 3]) {\n                    double t = 0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5]);\n                    double s = work[k - 3] * (work[k - 5] / t);\n                    if (s <= t) {\n                        s = work[k - 3] * work[k - 5] / (t * (1 + Math.sqrt(1 + s / t)));\n                    } else {\n                        s = work[k - 3] * work[k - 5] / (t + Math.sqrt(t * (t + s)));\n                    }\n                    t = work[k - 7] + (s + work[k - 5]);\n                    work[k - 3] *= work[k - 7] / t;\n                    work[k - 7]  = t;\n                }\n                work[4 * deflatedEnd - 8] = sigma + work[k - 7];\n                work[4 * deflatedEnd - 4] = sigma + work[k - 3];\n                deflatedEnd -= 2;\n            } else {\n\n                \n                deflating = false;\n\n            }\n\n        }\n\n        final int l = 4 * deflatedEnd + pingPong - 1;\n\n        \n        if ((dMin <= 0) || (deflatedEnd < end)) {\n            if (flipIfWarranted(deflatedEnd, 1)) {\n                dMin2 = Math.min(dMin2, work[l - 1]);\n                work[l - 1] =\n                    Math.min(work[l - 1],\n                             Math.min(work[3 + pingPong], work[7 + pingPong]));\n                work[l - 2 * pingPong] =\n                    Math.min(work[l - 2 * pingPong],\n                             Math.min(work[6 + pingPong], work[6 + pingPong]));\n                qMax  = Math.max(qMax, Math.max(work[3 + pingPong], work[7 + pingPong]));\n                dMin  = -0.0;\n            }\n        }\n\n        if ((dMin < 0) ||\n            (MathUtils.SAFE_MIN * qMax < Math.min(work[l - 1],\n                                                  Math.min(work[l - 9],\n                                                           dMin2 + work[l - 2 * pingPong])))) {\n            \n            computeShiftIncrement(start, deflatedEnd, end - deflatedEnd);\n\n            \n            for (boolean loop = true; loop;) {\n\n                \n                dqds(start, deflatedEnd);\n\n                \n                if ((dMin >= 0) && (dMin1 > 0)) {\n                    \n                    updateSigma(tau);\n                    return deflatedEnd;\n                } else if ((dMin < 0.0) &&\n                           (dMin1 > 0.0) &&\n                           (work[4 * deflatedEnd - 5 - pingPong] < TOLERANCE * (sigma + dN1)) &&\n                           (Math.abs(dN) < TOLERANCE * sigma)) {\n                   \n                    work[4 * deflatedEnd - 3 - pingPong] = 0.0;\n                    dMin = 0.0;\n                    updateSigma(tau);\n                    return deflatedEnd;\n                } else if (dMin < 0.0) {\n                    \n                    if (tType < -22) {\n                        \n                        tau = 0.0;\n                    } else if (dMin1 > 0.0) {\n                        \n                        tau = (tau + dMin) * (1.0 - 2.0 * MathUtils.EPSILON);\n                        tType -= 11;\n                    } else {\n                        \n                        tau *= 0.25;\n                        tType -= 12;\n                    }\n                } else if (Double.isNaN(dMin)) {\n                    tau = 0.0;\n                } else {\n                    \n                    loop = false;\n                }\n            }\n\n        }\n\n        \n        dqd(start, deflatedEnd);\n\n        return deflatedEnd;\n\n    }\n\n    \n    private boolean flipIfWarranted(final int n, final int step) {\n        if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n            \n            int j = 4 * n - 1;\n            for (int i = 0; i < j; i += 4) {\n                for (int k = 0; k < 4; k += step) {\n                    final double tmp = work[i + k];\n                    work[i + k] = work[j - k];\n                    work[j - k] = tmp;\n                }\n                j -= 4;\n            }\n            return true;\n        }\n        return false;\n    }\n\n    \n    private double[] eigenvaluesRange(final int index, final int n) {\n\n        \n        final int lowerStart = 4 * main.length;\n        final int upperStart = 5 * main.length;\n        double lower = Double.POSITIVE_INFINITY;\n        double upper = Double.NEGATIVE_INFINITY;\n        for (int i = 0; i < n; ++i) {\n            lower = Math.min(lower, work[lowerStart + index +i]);\n            upper = Math.max(upper, work[upperStart + index +i]);\n        }\n\n        \n        final double tNorm = Math.max(Math.abs(lower), Math.abs(upper));\n        final double relativeTolerance = Math.sqrt(MathUtils.EPSILON);\n        final double absoluteTolerance = 4 * minPivot;\n        final int maxIter =\n            2 + (int) ((Math.log(tNorm + minPivot) - Math.log(minPivot)) / Math.log(2.0));\n        final double margin = 2 * (tNorm * MathUtils.EPSILON * n + 2 * minPivot);\n\n        \n        double left  = lower - margin;\n        double right = upper + margin;\n        for (int i = 0; i < maxIter; ++i) {\n\n            final double range = right - left;\n            if ((range < absoluteTolerance) ||\n                (range < relativeTolerance * Math.max(Math.abs(left), Math.abs(right)))) {\n                \n                break;\n            }\n\n            final double middle = 0.5 * (left + right);\n            if (countEigenValues(middle, index, n) >= 1) {\n                right = middle;\n            } else {\n                left = middle;\n            }\n\n        }\n        lower = Math.max(lower, left - 100 * MathUtils.EPSILON * Math.abs(left));\n\n        \n        left  = lower - margin;\n        right = upper + margin;\n        for (int i = 0; i < maxIter; ++i) {\n\n            final double range = right - left;\n            if ((range < absoluteTolerance) ||\n                (range < relativeTolerance * Math.max(Math.abs(left), Math.abs(right)))) {\n                \n                break;\n            }\n\n            final double middle = 0.5 * (left + right);\n            if (countEigenValues(middle, index, n) >= n) {\n                right = middle;\n            } else {\n                left = middle;\n            }\n\n        }\n        upper = Math.min(upper, right + 100 * MathUtils.EPSILON * Math.abs(right));\n\n        return new double[] { lower, upper };\n\n    }\n\n    \n    private int countEigenValues(final double t, final int index, final int n) {\n        double ratio = main[index] - t;\n        int count = (ratio > 0) ? 0 : 1;\n        for (int i = 1; i < n; ++i) {\n            ratio = main[index + i] - squaredSecondary[index + i - 1] / ratio - t;\n            if (ratio <= 0) {\n                ++count;\n            }\n        }\n        return count;\n    }\n\n    \n    private void ldlTDecomposition(final double lambda, final int index, final int n) {\n        double di = main[index] - lambda;\n        work[0] = Math.abs(di);\n        for (int i = 1; i < n; ++i) {\n            final int    fourI = 4 * i;\n            final double eiM1  = secondary[index + i - 1];\n            final double ratio = eiM1 / di;\n            work[fourI - 2] = ratio * ratio * Math.abs(di);\n            di = (main[index + i] - lambda) - eiM1 * ratio;\n            work[fourI] = Math.abs(di);\n        }\n    }\n\n    \n    private void dqds(final int start, final int end) {\n\n        eMin = work[4 * start + pingPong + 4];\n        double d = work[4 * start + pingPong] - tau;\n        dMin = d;\n        dMin1 = -work[4 * start + pingPong];\n\n        if (pingPong == 0) {\n            for (int j4 = 4 * start + 3; j4 <= 4 * (end - 3); j4 += 4) {\n                work[j4 - 2] = d + work[j4 - 1];\n                final double tmp = work[j4 + 1] / work[j4 - 2];\n                d = d * tmp - tau;\n                dMin = Math.min(dMin, d);\n                work[j4] = work[j4 - 1] * tmp;\n                eMin = Math.min(work[j4], eMin);\n            }\n        } else {\n            for (int j4 = 4 * start + 3; j4 <= 4 * (end - 3); j4 += 4) {\n                work[j4 - 3] = d + work[j4];\n                final double tmp = work[j4 + 2] / work[j4 - 3];\n                d = d * tmp - tau;\n                dMin = Math.min(dMin, d);\n                work[j4 - 1] = work[j4] * tmp;\n                eMin = Math.min(work[j4 - 1], eMin);\n            }\n        }\n\n        \n        dN2 = d;\n        dMin2 = dMin;\n        int j4 = 4 * (end - 2) - pingPong - 1;\n        int j4p2 = j4 + 2 * pingPong - 1;\n        work[j4 - 2] = dN2 + work[j4p2];\n        work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);\n        dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]) - tau;\n        dMin = Math.min(dMin, dN1);\n\n        dMin1 = dMin;\n        j4 = j4 + 4;\n        j4p2 = j4 + 2 * pingPong - 1;\n        work[j4 - 2] = dN1 + work[j4p2];\n        work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);\n        dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]) - tau;\n        dMin = Math.min(dMin, dN);\n\n        work[j4 + 2] = dN;\n        work[4 * end - pingPong - 1] = eMin;\n\n    }\n\n\n    \n    private void dqd(final int start, final int end) {\n\n        eMin = work[4 * start + pingPong + 4];\n        double d = work[4 * start + pingPong];\n        dMin = d;\n\n        if (pingPong == 0) {\n            for (int j4 = 4 * start + 3; j4 < 4 * (end - 3); j4 += 4) {\n                work[j4 - 2] = d + work[j4 - 1];\n                if (work[j4 - 2] == 0.0) {\n                    work[j4] = 0.0;\n                    d = work[j4 + 1];\n                    dMin = d;\n                    eMin = 0.0;\n                } else if ((MathUtils.SAFE_MIN * work[j4 + 1] < work[j4 - 2]) &&\n                           (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4 + 1])) {\n                    final double tmp = work[j4 + 1] / work[j4 - 2];\n                    work[j4] = work[j4 - 1] * tmp;\n                    d *= tmp;\n                } else {\n                    work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]);\n                    d *= work[j4 + 1] / work[j4 - 2];\n                }\n                dMin = Math.min(dMin, d);\n                eMin = Math.min(eMin, work[j4]);\n            }\n        } else {\n            for (int j4 = 4 * start + 3; j4 < 4 * (end - 3); j4 += 4) {\n                work[j4 - 3] = d + work[j4];\n                if (work[j4 - 3] == 0.0) {\n                    work[j4 - 1] = 0.0;\n                    d = work[j4 + 2];\n                    dMin = d;\n                    eMin = 0.0;\n                } else if ((MathUtils.SAFE_MIN * work[j4 + 2] < work[j4 - 3]) &&\n                           (MathUtils.SAFE_MIN * work[j4 - 3] < work[j4 + 2])) {\n                    final double tmp = work[j4 + 2] / work[j4 - 3];\n                    work[j4 - 1] = work[j4] * tmp;\n                    d *= tmp;\n                } else {\n                    work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]);\n                    d *= work[j4 + 2] / work[j4 - 3];\n                }\n                dMin = Math.min(dMin, d);\n                eMin = Math.min(eMin, work[j4 - 1]);\n            }\n        }\n\n        \n        dN2   = d;\n        dMin2 = dMin;\n        int j4 = 4 * (end - 2) - pingPong - 1;\n        int j4p2 = j4 + 2 * pingPong - 1;\n        work[j4 - 2] = dN2 + work[j4p2];\n        if (work[j4 - 2] == 0.0) {\n            work[j4] = 0.0;\n            dN1  = work[j4p2 + 2];\n            dMin = dN1;\n            eMin = 0.0;\n        } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&\n                   (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {\n            final double tmp = work[j4p2 + 2] / work[j4 - 2];\n            work[j4] = work[j4p2] * tmp;\n            dN1 = dN2 * tmp;\n        } else {\n            work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);\n            dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);\n        }\n        dMin = Math.min(dMin, dN1);\n\n        dMin1 = dMin;\n        j4 = j4 + 4;\n        j4p2 = j4 + 2 * pingPong - 1;\n        work[j4 - 2] = dN1 + work[j4p2];\n        if (work[j4 - 2] == 0.0) {\n            work[j4] = 0.0;\n            dN   = work[j4p2 + 2];\n            dMin = dN;\n            eMin = 0.0;\n        } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&\n                   (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {\n            final double tmp = work[j4p2 + 2] / work[j4 - 2];\n            work[j4] = work[j4p2] * tmp;\n            dN = dN1 * tmp;\n        } else {\n            work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);\n            dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);\n        }\n        dMin = Math.min(dMin, dN);\n\n        work[j4 + 2] = dN;\n        work[4 * end - pingPong - 1] = eMin;\n\n    }\n\n    \n    private void computeShiftIncrement(final int start, final int end, final int deflated) {\n\n        final double cnst1 = 0.563;\n        final double cnst2 = 1.010;\n        final double cnst3 = 1.05;\n\n        \n        \n        if (dMin <= 0.0) {\n            tau = -dMin;\n            tType = -1;\n            return;\n        }\n\n        int nn = 4 * end + pingPong - 1;\n        switch (deflated) {\n\n        case 0 : \n            if (dMin == dN || dMin == dN1) {\n\n                double b1 = Math.sqrt(work[nn - 3]) * Math.sqrt(work[nn - 5]);\n                double b2 = Math.sqrt(work[nn - 7]) * Math.sqrt(work[nn - 9]);\n                double a2 = work[nn - 7] + work[nn - 5];\n\n                if (dMin == dN && dMin1 == dN1) {\n                    \n                    final double gap2 = dMin2 - a2 - dMin2 * 0.25;\n                    final double gap1 = a2 - dN - ((gap2 > 0.0 && gap2 > b2) ? (b2 / gap2) * b2 : (b1 + b2));\n                    if (gap1 > 0.0 && gap1 > b1) {\n                        tau   = Math.max(dN - (b1 / gap1) * b1, 0.5 * dMin);\n                        tType = -2;\n                    } else {\n                        double s = 0.0;\n                        if (dN > b1) {\n                            s = dN - b1;\n                        }\n                        if (a2 > (b1 + b2)) {\n                            s = Math.min(s, a2 - (b1 + b2));\n                        }\n                        tau   = Math.max(s, 0.333 * dMin);\n                        tType = -3;\n                    }\n                } else {\n                    \n                    tType = -4;\n                    double s = 0.25 * dMin;\n                    double gam;\n                    int np;\n                    if (dMin == dN) {\n                        gam = dN;\n                        a2 = 0.0;\n                        if (work[nn - 5]  >  work[nn - 7]) {\n                            return;\n                        }\n                        b2 = work[nn - 5] / work[nn - 7];\n                        np = nn - 9;\n                    } else {\n                        np = nn - 2 * pingPong;\n                        b2 = work[np - 2];\n                        gam = dN1;\n                        if (work[np - 4]  >  work[np - 2]) {\n                            return;\n                        }\n                        a2 = work[np - 4] / work[np - 2];\n                        if (work[nn - 9]  >  work[nn - 11]) {\n                            return;\n                        }\n                        b2 = work[nn - 9] / work[nn - 11];\n                        np = nn - 13;\n                    }\n\n                    \n                    a2 = a2 + b2;\n                    for (int i4 = np; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        if(b2 == 0.0) {\n                            break;\n                        }\n                        b1 = b2;\n                        if (work[i4]  >  work[i4 - 2]) {\n                            return;\n                        }\n                        b2 = b2 * (work[i4] / work[i4 - 2]);\n                        a2 = a2 + b2;\n                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2) {\n                            break;\n                        }\n                    }\n                    a2 = cnst3 * a2;\n\n                    \n                    if (a2 < cnst1) {\n                        s = gam * (1 - Math.sqrt(a2)) / (1 + a2);\n                    }\n                    tau = s;\n\n                }\n            } else if (dMin == dN2) {\n\n                \n                tType = -5;\n                double s = 0.25 * dMin;\n\n                \n                final int np = nn - 2 * pingPong;\n                double b1 = work[np - 2];\n                double b2 = work[np - 6];\n                final double gam = dN2;\n                if (work[np - 8] > b2 || work[np - 4] > b1) {\n                    return;\n                }\n                double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);\n\n                \n                if (end - start > 3) {\n                    b2 = work[nn - 13] / work[nn - 15];\n                    a2 = a2 + b2;\n                    for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        if (b2 == 0.0) {\n                            break;\n                        }\n                        b1 = b2;\n                        if (work[i4]  >  work[i4 - 2]) {\n                            return;\n                        }\n                        b2 = b2 * (work[i4] / work[i4 - 2]);\n                        a2 = a2 + b2;\n                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2)  {\n                            break;\n                        }\n                    }\n                    a2 = cnst3 * a2;\n                }\n\n                if (a2 < cnst1) {\n                    tau = gam * (1 - Math.sqrt(a2)) / (1 + a2);\n                } else {\n                    tau = s;\n                }\n\n            } else {\n\n                \n                if (tType == -6) {\n                    g += 0.333 * (1 - g);\n                } else if (tType == -18) {\n                    g = 0.25 * 0.333;\n                } else {\n                    g = 0.25;\n                }\n                tau   = g * dMin;\n                tType = -6;\n\n            }\n            break;\n\n        case 1 : \n            if (dMin1 == dN1 && dMin2 == dN2) {\n\n                \n                tType = -7;\n                double s = 0.333 * dMin1;\n                if (work[nn - 5] > work[nn - 7]) {\n                    return;\n                }\n                double b1 = work[nn - 5] / work[nn - 7];\n                double b2 = b1;\n                if (b2 != 0.0) {\n                    for (int i4 = 4 * end - 10 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        final double oldB1 = b1;\n                        if (work[i4] > work[i4 - 2]) {\n                            return;\n                        }\n                        b1 = b1 * (work[i4] / work[i4 - 2]);\n                        b2 = b2 + b1;\n                        if (100 * Math.max(b1, oldB1) < b2) {\n                            break;\n                        }\n                    }\n                }\n                b2 = Math.sqrt(cnst3 * b2);\n                final double a2 = dMin1 / (1 + b2 * b2);\n                final double gap2 = 0.5 * dMin2 - a2;\n                if (gap2 > 0.0 && gap2 > b2 * a2) {\n                    tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));\n                } else {\n                    tau = Math.max(s, a2 * (1 - cnst2 * b2));\n                    tType = -8;\n                }\n            } else {\n\n                \n                tau = 0.25 * dMin1;\n                if (dMin1 == dN1) {\n                    tau = 0.5 * dMin1;\n                }\n                tType = -9;\n            }\n            break;\n\n        case 2 : \n\n            \n            if (dMin2 == dN2 && 2 * work[nn - 5] < work[nn - 7]) {\n                tType = -10;\n                final double s = 0.333 * dMin2;\n                if (work[nn - 5] > work[nn - 7]) {\n                    return;\n                }\n                double b1 = work[nn - 5] / work[nn - 7];\n                double b2 = b1;\n                if (b2 != 0.0){\n                    for (int i4 = 4 * end - 9 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        if (work[i4] > work[i4 - 2]) {\n                            return;\n                        }\n                        b1 *= work[i4] / work[i4 - 2];\n                        b2 += b1;\n                        if (100 * b1 < b2) {\n                            break;\n                        }\n                    }\n                }\n                b2 = Math.sqrt(cnst3 * b2);\n                final double a2 = dMin2 / (1 + b2 * b2);\n                final double gap2 = work[nn - 7] + work[nn - 9] -\n                Math.sqrt(work[nn - 11]) * Math.sqrt(work[nn - 9]) - a2;\n                if (gap2 > 0.0 && gap2 > b2 * a2) {\n                    tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));\n                } else {\n                    tau = Math.max(s, a2 * (1 - cnst2 * b2));\n                }\n            } else {\n                tau   = 0.25 * dMin2;\n                tType = -11;\n            }\n            break;\n\n        default : \n            tau   = 0.0;\n            tType = -12;\n        }\n\n    }\n\n    \n    private void updateSigma(final double shift) {\n        \n        \n        \n        if (shift < sigma) {\n            sigmaLow += shift;\n            final double t = sigma + sigmaLow;\n            sigmaLow -= t - sigma;\n            sigma = t;\n        } else {\n            final double t = sigma + shift;\n            sigmaLow += sigma - (t - shift);\n            sigma = t;\n        }\n    }\n\n    \n    private void findEigenVectors() {\n\n        final int m = main.length;\n        eigenvectors = new ArrayRealVector[m];\n\n        \n        final double[] d = new double[m];\n        final double[] l = new double[m - 1];\n        \n        final double mu = realEigenvalues[m-1] <= 0 && realEigenvalues[0] > 0 ? 0.5-realEigenvalues[m-1] : 0;\n        double di = main[0]+mu;\n        d[0] = di;\n        for (int i = 1; i < m; ++i) {\n            final double eiM1  = secondary[i - 1];\n            final double ratio = eiM1 / di;\n            di       = main[i] - eiM1 * ratio + mu;\n            l[i - 1] = ratio;\n            d[i]     = di;\n        }\n\n        \n        for (int i = 0; i < m; ++i) {\n            eigenvectors[i] = findEigenvector(realEigenvalues[i]+mu, d, l);\n        }\n\n    }\n\n    \n    private ArrayRealVector findEigenvector(final double eigenvalue, final double[] d, final double[] l) {\n\n        \n        \n        final int m = main.length;\n        stationaryQuotientDifferenceWithShift(d, l, eigenvalue);\n        progressiveQuotientDifferenceWithShift(d, l, eigenvalue);\n\n        \n        \n        int r = m - 1;\n        double minG = Math.abs(work[6 * r] + work[6 * r + 3] + eigenvalue);\n        int sixI = 0;\n        for (int i = 0; i < m - 1; ++i) {\n            final double absG = Math.abs(work[sixI] + d[i] * work[sixI + 9] / work[sixI + 10]);\n            if (absG < minG) {\n                r = i;\n                minG = absG;\n            }\n            sixI += 6;\n        }\n\n        \n        \n        double[] eigenvector = new double[m];\n        double n2 = 1;\n        eigenvector[r] = 1;\n        double z = 1;\n        for (int i = r - 1; i >= 0; --i) {\n            z *= -work[6 * i + 2];\n            eigenvector[i] = z;\n            n2 += z * z;\n        }\n        z = 1;\n        for (int i = r + 1; i < m; ++i) {\n            z *= -work[6 * i - 1];\n            eigenvector[i] = z;\n            n2 += z * z;\n        }\n\n        \n        final double inv = 1.0 / Math.sqrt(n2);\n        for (int i = 0; i < m; ++i) {\n            eigenvector[i] *= inv;\n        }\n\n        return (transformer == null) ?\n               new ArrayRealVector(eigenvector, false) :\n               new ArrayRealVector(transformer.getQ().operate(eigenvector), false);\n\n    }\n\n    \n    private void stationaryQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) {\n        final int nM1 = d.length - 1;\n        double si = -lambda;\n        int sixI = 0;\n        for (int i = 0; i < nM1; ++i) {\n            final double di   = d[i];\n            final double li   = l[i];\n            final double diP1 = di + si;\n            final double liP1 = li * di / diP1;\n            work[sixI]        = si;\n            work[sixI + 1]    = diP1;\n            work[sixI + 2]    = liP1;\n            si = li * liP1 * si - lambda;\n            sixI += 6;\n        }\n        work[6 * nM1 + 1] = d[nM1] + si;\n        work[6 * nM1]     = si;\n    }\n\n    \n    private void progressiveQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) {\n        final int nM1 = d.length - 1;\n        double pi = d[nM1] - lambda;\n        int sixI = 6 * (nM1 - 1);\n        for (int i = nM1 - 1; i >= 0; --i) {\n            final double di   = d[i];\n            final double li   = l[i];\n            final double diP1 = di * li * li + pi;\n            final double t    = di / diP1;\n            work[sixI +  9]   = pi;\n            work[sixI + 10]   = diP1;\n            work[sixI +  5]   = li * t;\n            pi = pi * t - lambda;\n            sixI -= 6;\n        }\n        work[3] = pi;\n        work[4] = pi;\n    }\n\n}\n",
      "buggy_signatures": [
        "public EigenDecompositionImpl(final double[] main, double[] secondary, final double splitTolerance) throws InvalidMatrixException",
        "private boolean isSymmetric(final RealMatrix matrix)",
        "private void decompose()",
        "public RealMatrix getV() throws InvalidMatrixException",
        "public RealMatrix getD() throws InvalidMatrixException",
        "public RealMatrix getVT() throws InvalidMatrixException",
        "public double[] getRealEigenvalues() throws InvalidMatrixException",
        "public double getRealEigenvalue(final int i) throws InvalidMatrixException, ArrayIndexOutOfBoundsException",
        "public double[] getImagEigenvalues() throws InvalidMatrixException",
        "public double getImagEigenvalue(final int i) throws InvalidMatrixException, ArrayIndexOutOfBoundsException",
        "public RealVector getEigenvector(final int i) throws InvalidMatrixException, ArrayIndexOutOfBoundsException",
        "public double getDeterminant()",
        "public DecompositionSolver getSolver()",
        "private static class Solver implements DecompositionSolver { private double[] realEigenvalues; private double[] imagEigenvalues; private final ArrayRealVector[] eigenvectors; private Solver(final double[] realEigenvalues, final double[] imagEigenvalues, final ArrayRealVector[] eigenvectors)",
        "public double[] solve(final double[] b) throws IllegalArgumentException, InvalidMatrixException",
        "public RealVector solve(final RealVector b) throws IllegalArgumentException, InvalidMatrixException",
        "public RealMatrix solve(final RealMatrix b) throws IllegalArgumentException, InvalidMatrixException",
        "public boolean isNonSingular()",
        "public RealMatrix getInverse() throws InvalidMatrixException",
        "private void transformToTridiagonal(final RealMatrix matrix)",
        "private void computeGershgorinCircles()",
        "private void findEigenvalues() throws InvalidMatrixException",
        "private List<Integer> computeSplits()",
        "private void process1RowBlock(final int index)",
        "private void process2RowsBlock(final int index) throws InvalidMatrixException",
        "private void process3RowsBlock(final int index) throws InvalidMatrixException",
        "private void processGeneralBlock(final int n) throws InvalidMatrixException",
        "private void initialSplits(final int n)",
        "private int goodStep(final int start, final int end)",
        "private boolean flipIfWarranted(final int n, final int step)",
        "private double[] eigenvaluesRange(final int index, final int n)",
        "private int countEigenValues(final double t, final int index, final int n)",
        "private void ldlTDecomposition(final double lambda, final int index, final int n)",
        "private void dqds(final int start, final int end)",
        "private void dqd(final int start, final int end)",
        "private void computeShiftIncrement(final int start, final int end, final int deflated)",
        "private void updateSigma(final double shift)",
        "private void findEigenVectors()",
        "private ArrayRealVector findEigenvector(final double eigenvalue, final double[] d, final double[] l)",
        "private void stationaryQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda)",
        "private void progressiveQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda)"
      ],
      "fixed_signatures": [
        "public EigenDecompositionImpl(final double[] main, double[] secondary, final double splitTolerance) throws InvalidMatrixException",
        "private boolean isSymmetric(final RealMatrix matrix)",
        "private void decompose()",
        "public RealMatrix getV() throws InvalidMatrixException",
        "public RealMatrix getD() throws InvalidMatrixException",
        "public RealMatrix getVT() throws InvalidMatrixException",
        "public double[] getRealEigenvalues() throws InvalidMatrixException",
        "public double getRealEigenvalue(final int i) throws InvalidMatrixException, ArrayIndexOutOfBoundsException",
        "public double[] getImagEigenvalues() throws InvalidMatrixException",
        "public double getImagEigenvalue(final int i) throws InvalidMatrixException, ArrayIndexOutOfBoundsException",
        "public RealVector getEigenvector(final int i) throws InvalidMatrixException, ArrayIndexOutOfBoundsException",
        "public double getDeterminant()",
        "public DecompositionSolver getSolver()",
        "private static class Solver implements DecompositionSolver { private double[] realEigenvalues; private double[] imagEigenvalues; private final ArrayRealVector[] eigenvectors; private Solver(final double[] realEigenvalues, final double[] imagEigenvalues, final ArrayRealVector[] eigenvectors)",
        "public double[] solve(final double[] b) throws IllegalArgumentException, InvalidMatrixException",
        "public RealVector solve(final RealVector b) throws IllegalArgumentException, InvalidMatrixException",
        "public RealMatrix solve(final RealMatrix b) throws IllegalArgumentException, InvalidMatrixException",
        "public boolean isNonSingular()",
        "public RealMatrix getInverse() throws InvalidMatrixException",
        "private void transformToTridiagonal(final RealMatrix matrix)",
        "private void computeGershgorinCircles()",
        "private void findEigenvalues() throws InvalidMatrixException",
        "private List<Integer> computeSplits()",
        "private void process1RowBlock(final int index)",
        "private void process2RowsBlock(final int index) throws InvalidMatrixException",
        "private void process3RowsBlock(final int index) throws InvalidMatrixException",
        "private void processGeneralBlock(final int n) throws InvalidMatrixException",
        "private void initialSplits(final int n)",
        "private int goodStep(final int start, final int end)",
        "private boolean flipIfWarranted(final int n, final int step)",
        "private double[] eigenvaluesRange(final int index, final int n)",
        "private int countEigenValues(final double t, final int index, final int n)",
        "private void ldlTDecomposition(final double lambda, final int index, final int n)",
        "private void dqds(final int start, final int end)",
        "private void dqd(final int start, final int end)",
        "private void computeShiftIncrement(final int start, final int end, final int deflated)",
        "private void updateSigma(final double shift)",
        "private void findEigenVectors()",
        "private ArrayRealVector findEigenvector(final double eigenvalue, final double[] d, final double[] l)",
        "private void stationaryQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda)",
        "private void progressiveQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda)"
      ],
      "methods": [
        {
          "buggy_method": "  private void computeGershgorinCircles() {\n\n  final int m  = main.length;\n  final int lowerStart = 4 * m;\n  final int upperStart = 5 * m;\n  lowerSpectra = Double.POSITIVE_INFINITY;\n  upperSpectra = Double.NEGATIVE_INFINITY;\n  double eMax = 0;\n\n  double eCurrent = 0;\n  for (int i = 0; i < m - 1; ++i) {\n\n  final double dCurrent = main[i];\n  final double ePrevious = eCurrent;\n  eCurrent = Math.abs(secondary[i]);\n  eMax = Math.max(eMax, eCurrent);\n  final double radius = ePrevious + eCurrent;\n\n  final double lower = dCurrent - radius;\n  work[lowerStart + i] = lower;\n  lowerSpectra = Math.min(lowerSpectra, lower);\n\n  final double upper = dCurrent + radius;\n  work[upperStart + i] = upper;\n  upperSpectra = Math.max(upperSpectra, upper);\n\n  }\n\n  final double dCurrent = main[m - 1];\n  final double lower = dCurrent - eCurrent;\n  work[lowerStart + m - 1] = lower;\n  lowerSpectra = Math.min(lowerSpectra, lower);\n  final double upper = dCurrent + eCurrent;\n  work[upperStart + m - 1] = upper;\n  minPivot = MathUtils.SAFE_MIN * Math.max(1.0, eMax * eMax);\n\n  }",
          "fixed_method": "  private void computeGershgorinCircles() {\n\n  final int m  = main.length;\n  final int lowerStart = 4 * m;\n  final int upperStart = 5 * m;\n  lowerSpectra = Double.POSITIVE_INFINITY;\n  upperSpectra = Double.NEGATIVE_INFINITY;\n  double eMax = 0;\n\n  double eCurrent = 0;\n  for (int i = 0; i < m - 1; ++i) {\n\n  final double dCurrent = main[i];\n  final double ePrevious = eCurrent;\n  eCurrent = Math.abs(secondary[i]);\n  eMax = Math.max(eMax, eCurrent);\n  final double radius = ePrevious + eCurrent;\n\n  final double lower = dCurrent - radius;\n  work[lowerStart + i] = lower;\n  lowerSpectra = Math.min(lowerSpectra, lower);\n\n  final double upper = dCurrent + radius;\n  work[upperStart + i] = upper;\n  upperSpectra = Math.max(upperSpectra, upper);\n\n  }\n\n  final double dCurrent = main[m - 1];\n  final double lower = dCurrent - eCurrent;\n  work[lowerStart + m - 1] = lower;\n  lowerSpectra = Math.min(lowerSpectra, lower);\n  final double upper = dCurrent + eCurrent;\n  work[upperStart + m - 1] = upper;\n  upperSpectra = Math.max(upperSpectra, upper);\n  minPivot = MathUtils.SAFE_MIN * Math.max(1.0, eMax * eMax);\n\n  }",
          "diff": [
            "@@ -600,6 +600,7 @@",
            "         lowerSpectra = Math.min(lowerSpectra, lower);\n",
            "         final double upper = dCurrent + eCurrent;\n",
            "         work[upperStart + m - 1] = upper;\n",
            "+        upperSpectra = Math.max(upperSpectra, upper);\n",
            "         minPivot = MathUtils.SAFE_MIN * Math.max(1.0, eMax * eMax);\n",
            " \n",
            "     }\n"
          ],
          "changed_lines": 1
        },
        {
          "buggy_method": "  private void processGeneralBlock(final int n) throws InvalidMatrixException {\n\n  \n  double sumOffDiag = 0;\n  for (int i = 0; i < n - 1; ++i) {\n  final int fourI = 4 * i;\n  final double ei = work[fourI + 2];\n  sumOffDiag += ei;\n  }\n\n  if (sumOffDiag == 0) {\n  \n  return;\n  }\n\n  \n  flipIfWarranted(n, 2);\n\n  \n  initialSplits(n);\n\n  \n  tType = 0;\n  dMin1 = 0;\n  dMin2 = 0;\n  dN  = 0;\n  dN1  = 0;\n  dN2  = 0;\n  tau  = 0;\n\n  \n  int i0 = 0;\n  int n0 = n;\n  while (n0 > 0) {\n\n  \n  sigma  = (n0 == n) ? 0 : -work[4 * n0 - 2];\n  sigmaLow = 0;\n\n  \n  double offDiagMin = (i0 == n0) ? 0 : work[4 * n0 - 6];\n  double offDiagMax = 0;\n  double diagMax  = work[4 * n0 - 4];\n  double diagMin  = diagMax;\n  i0 = 0;\n  for (int i = 4 * (n0 - 2); i >= 0; i -= 4) {\n  if (work[i + 2] <= 0) {\n  i0 = 1 + i / 4;\n  break;\n  }\n  if (diagMin >= 4 * offDiagMax) {\n  diagMin  = Math.min(diagMin, work[i + 4]);\n  offDiagMax = Math.max(offDiagMax, work[i + 2]);\n  }\n  diagMax  = Math.max(diagMax, work[i] + work[i + 2]);\n  offDiagMin = Math.min(offDiagMin, work[i + 2]);\n  }\n  work[4 * n0 - 2] = offDiagMin;\n\n  \n  dMin = -Math.max(0, diagMin - 2 * Math.sqrt(diagMin * offDiagMax));\n\n  pingPong = 0;\n  int maxIter = 30 * (n0 - i0);\n  for (int k = 0; i0 < n0; ++k) {\n  if (k >= maxIter) {\n  throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));\n  }\n\n  \n  n0 = goodStep(i0, n0);\n  pingPong = 1 - pingPong;\n\n  \n  \n  if ((pingPong == 0) && (n0 - i0 > 3) &&\n  (work[4 * n0 - 1] <= TOLERANCE_2 * diagMax) &&\n  (work[4 * n0 - 2] <= TOLERANCE_2 * sigma)) {\n  int split  = i0 - 1;\n  diagMax  = work[4 * i0];\n  offDiagMin = work[4 * i0 + 2];\n  double previousEMin = work[4 * i0 + 3];\n  for (int i = 4 * i0; i < 4 * n0 - 11; i += 4) {\n  if ((work[i + 3] <= TOLERANCE_2 * work[i]) &&\n  (work[i + 2] <= TOLERANCE_2 * sigma)) {\n  \n  work[i + 2]  = -sigma;\n  split  = i / 4;\n  diagMax  = 0;\n  offDiagMin  = work[i + 6];\n  previousEMin = work[i + 7];\n  } else {\n  diagMax  = Math.max(diagMax, work[i + 4]);\n  offDiagMin  = Math.min(offDiagMin, work[i + 2]);\n  previousEMin = Math.min(previousEMin, work[i + 3]);\n  }\n  }\n  work[4 * n0 - 2] = offDiagMin;\n  work[4 * n0 - 1] = previousEMin;\n  i0 = split + 1;\n  }\n  }\n\n  }\n\n  }",
          "fixed_method": "  private void processGeneralBlock(final int n) throws InvalidMatrixException {\n\n  \n  double sumOffDiag = 0;\n  for (int i = 0; i < n - 1; ++i) {\n  final int fourI = 4 * i;\n  final double ei = work[fourI + 2];\n  sumOffDiag += ei;\n  }\n\n  if (sumOffDiag == 0) {\n  \n  return;\n  }\n\n  \n  flipIfWarranted(n, 2);\n\n  \n  initialSplits(n);\n\n  \n  tType = 0;\n  dMin1 = 0;\n  dMin2 = 0;\n  dN  = 0;\n  dN1  = 0;\n  dN2  = 0;\n  tau  = 0;\n\n  \n  int i0 = 0;\n  int n0 = n;\n  while (n0 > 0) {\n\n  \n  sigma  = (n0 == n) ? 0 : -work[4 * n0 - 2];\n  sigmaLow = 0;\n\n  \n  double offDiagMin = (i0 == n0) ? 0 : work[4 * n0 - 6];\n  double offDiagMax = 0;\n  double diagMax  = work[4 * n0 - 4];\n  double diagMin  = diagMax;\n  i0 = 0;\n  for (int i = 4 * (n0 - 2); i >= 0; i -= 4) {\n  if (work[i + 2] <= 0) {\n  i0 = 1 + i / 4;\n  break;\n  }\n  if (diagMin >= 4 * offDiagMax) {\n  diagMin  = Math.min(diagMin, work[i + 4]);\n  offDiagMax = Math.max(offDiagMax, work[i + 2]);\n  }\n  diagMax  = Math.max(diagMax, work[i] + work[i + 2]);\n  offDiagMin = Math.min(offDiagMin, work[i + 2]);\n  }\n  work[4 * n0 - 2] = offDiagMin;\n\n  \n  dMin = -Math.max(0, diagMin - 2 * Math.sqrt(diagMin * offDiagMax));\n\n  pingPong = 0;\n  int maxIter = 30 * (n0 - i0);\n  for (int k = 0; i0 < n0; ++k) {\n  if (k >= maxIter) {\n  throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));\n  }\n\n  \n  n0 = goodStep(i0, n0);\n  pingPong = 1 - pingPong;\n\n  \n  \n  if ((pingPong == 0) && (n0 - i0 > 3) &&\n  (work[4 * n0 - 1] <= TOLERANCE_2 * diagMax) &&\n  (work[4 * n0 - 2] <= TOLERANCE_2 * sigma)) {\n  int split  = i0 - 1;\n  diagMax  = work[4 * i0];\n  offDiagMin = work[4 * i0 + 2];\n  double previousEMin = work[4 * i0 + 3];\n  for (int i = 4 * i0; i < 4 * n0 - 16; i += 4) {\n  if ((work[i + 3] <= TOLERANCE_2 * work[i]) ||\n  (work[i + 2] <= TOLERANCE_2 * sigma)) {\n  \n  work[i + 2]  = -sigma;\n  split  = i / 4;\n  diagMax  = 0;\n  offDiagMin  = work[i + 6];\n  previousEMin = work[i + 7];\n  } else {\n  diagMax  = Math.max(diagMax, work[i + 4]);\n  offDiagMin  = Math.min(offDiagMin, work[i + 2]);\n  previousEMin = Math.min(previousEMin, work[i + 3]);\n  }\n  }\n  work[4 * n0 - 2] = offDiagMin;\n  work[4 * n0 - 1] = previousEMin;\n  i0 = split + 1;\n  }\n  }\n\n  }\n\n  }",
          "diff": [
            "@@ -902,8 +903,8 @@",
            "                     diagMax    = work[4 * i0];\n",
            "                     offDiagMin = work[4 * i0 + 2];\n",
            "                     double previousEMin = work[4 * i0 + 3];\n",
            "-                    for (int i = 4 * i0; i < 4 * n0 - 11; i += 4) {\n",
            "-                        if ((work[i + 3] <= TOLERANCE_2 * work[i]) &&\n",
            "+                    for (int i = 4 * i0; i < 4 * n0 - 16; i += 4) {\n",
            "+                        if ((work[i + 3] <= TOLERANCE_2 * work[i]) ||\n",
            "                             (work[i + 2] <= TOLERANCE_2 * sigma)) {\n",
            "                             // insert a split\n",
            "                             work[i + 2]  = -sigma;\n"
          ],
          "changed_lines": 4
        },
        {
          "buggy_method": "  private void computeShiftIncrement(final int start, final int end, final int deflated) {\n\n  final double cnst1 = 0.563;\n  final double cnst2 = 1.010;\n  final double cnst3 = 1.05;\n\n  \n  \n  if (dMin <= 0.0) {\n  tau = -dMin;\n  tType = -1;\n  return;\n  }\n\n  int nn = 4 * end + pingPong - 1;\n  switch (deflated) {\n\n  case 0 : \n  if (dMin == dN || dMin == dN1) {\n\n  double b1 = Math.sqrt(work[nn - 3]) * Math.sqrt(work[nn - 5]);\n  double b2 = Math.sqrt(work[nn - 7]) * Math.sqrt(work[nn - 9]);\n  double a2 = work[nn - 7] + work[nn - 5];\n\n  if (dMin == dN && dMin1 == dN1) {\n  \n  final double gap2 = dMin2 - a2 - dMin2 * 0.25;\n  final double gap1 = a2 - dN - ((gap2 > 0.0 && gap2 > b2) ? (b2 / gap2) * b2 : (b1 + b2));\n  if (gap1 > 0.0 && gap1 > b1) {\n  tau  = Math.max(dN - (b1 / gap1) * b1, 0.5 * dMin);\n  tType = -2;\n  } else {\n  double s = 0.0;\n  if (dN > b1) {\n  s = dN - b1;\n  }\n  if (a2 > (b1 + b2)) {\n  s = Math.min(s, a2 - (b1 + b2));\n  }\n  tau  = Math.max(s, 0.333 * dMin);\n  tType = -3;\n  }\n  } else {\n  \n  tType = -4;\n  double s = 0.25 * dMin;\n  double gam;\n  int np;\n  if (dMin == dN) {\n  gam = dN;\n  a2 = 0.0;\n  if (work[nn - 5]  >  work[nn - 7]) {\n  return;\n  }\n  b2 = work[nn - 5] / work[nn - 7];\n  np = nn - 9;\n  } else {\n  np = nn - 2 * pingPong;\n  b2 = work[np - 2];\n  gam = dN1;\n  if (work[np - 4]  >  work[np - 2]) {\n  return;\n  }\n  a2 = work[np - 4] / work[np - 2];\n  if (work[nn - 9]  >  work[nn - 11]) {\n  return;\n  }\n  b2 = work[nn - 9] / work[nn - 11];\n  np = nn - 13;\n  }\n\n  \n  a2 = a2 + b2;\n  for (int i4 = np; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n  if(b2 == 0.0) {\n  break;\n  }\n  b1 = b2;\n  if (work[i4]  >  work[i4 - 2]) {\n  return;\n  }\n  b2 = b2 * (work[i4] / work[i4 - 2]);\n  a2 = a2 + b2;\n  if (100 * Math.max(b2, b1) < a2 || cnst1 < a2) {\n  break;\n  }\n  }\n  a2 = cnst3 * a2;\n\n  \n  if (a2 < cnst1) {\n  s = gam * (1 - Math.sqrt(a2)) / (1 + a2);\n  }\n  tau = s;\n\n  }\n  } else if (dMin == dN2) {\n\n  \n  tType = -5;\n  double s = 0.25 * dMin;\n\n  \n  final int np = nn - 2 * pingPong;\n  double b1 = work[np - 2];\n  double b2 = work[np - 6];\n  final double gam = dN2;\n  if (work[np - 8] > b2 || work[np - 4] > b1) {\n  return;\n  }\n  double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);\n\n  \n  if (end - start > 2) {\n  b2 = work[nn - 13] / work[nn - 15];\n  a2 = a2 + b2;\n  for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n  if (b2 == 0.0) {\n  break;\n  }\n  b1 = b2;\n  if (work[i4]  >  work[i4 - 2]) {\n  return;\n  }\n  b2 = b2 * (work[i4] / work[i4 - 2]);\n  a2 = a2 + b2;\n  if (100 * Math.max(b2, b1) < a2 || cnst1 < a2)  {\n  break;\n  }\n  }\n  a2 = cnst3 * a2;\n  }\n\n  if (a2 < cnst1) {\n  tau = gam * (1 - Math.sqrt(a2)) / (1 + a2);\n  } else {\n  tau = s;\n  }\n\n  } else {\n\n  \n  if (tType == -6) {\n  g += 0.333 * (1 - g);\n  } else if (tType == -18) {\n  g = 0.25 * 0.333;\n  } else {\n  g = 0.25;\n  }\n  tau  = g * dMin;\n  tType = -6;\n\n  }\n  break;\n\n  case 1 : \n  if (dMin1 == dN1 && dMin2 == dN2) {\n\n  \n  tType = -7;\n  double s = 0.333 * dMin1;\n  if (work[nn - 5] > work[nn - 7]) {\n  return;\n  }\n  double b1 = work[nn - 5] / work[nn - 7];\n  double b2 = b1;\n  if (b2 != 0.0) {\n  for (int i4 = 4 * end - 10 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n  final double oldB1 = b1;\n  if (work[i4] > work[i4 - 2]) {\n  return;\n  }\n  b1 = b1 * (work[i4] / work[i4 - 2]);\n  b2 = b2 + b1;\n  if (100 * Math.max(b1, oldB1) < b2) {\n  break;\n  }\n  }\n  }\n  b2 = Math.sqrt(cnst3 * b2);\n  final double a2 = dMin1 / (1 + b2 * b2);\n  final double gap2 = 0.5 * dMin2 - a2;\n  if (gap2 > 0.0 && gap2 > b2 * a2) {\n  tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));\n  } else {\n  tau = Math.max(s, a2 * (1 - cnst2 * b2));\n  tType = -8;\n  }\n  } else {\n\n  \n  tau = 0.25 * dMin1;\n  if (dMin1 == dN1) {\n  tau = 0.5 * dMin1;\n  }\n  tType = -9;\n  }\n  break;\n\n  case 2 : \n\n  \n  if (dMin2 == dN2 && 2 * work[nn - 5] < work[nn - 7]) {\n  tType = -10;\n  final double s = 0.333 * dMin2;\n  if (work[nn - 5] > work[nn - 7]) {\n  return;\n  }\n  double b1 = work[nn - 5] / work[nn - 7];\n  double b2 = b1;\n  if (b2 != 0.0){\n  for (int i4 = 4 * end - 9 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n  if (work[i4] > work[i4 - 2]) {\n  return;\n  }\n  b1 *= work[i4] / work[i4 - 2];\n  b2 += b1;\n  if (100 * b1 < b2) {\n  break;\n  }\n  }\n  }\n  b2 = Math.sqrt(cnst3 * b2);\n  final double a2 = dMin2 / (1 + b2 * b2);\n  final double gap2 = work[nn - 7] + work[nn - 9] -\n  Math.sqrt(work[nn - 11]) * Math.sqrt(work[nn - 9]) - a2;\n  if (gap2 > 0.0 && gap2 > b2 * a2) {\n  tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));\n  } else {\n  tau = Math.max(s, a2 * (1 - cnst2 * b2));\n  }\n  } else {\n  tau  = 0.25 * dMin2;\n  tType = -11;\n  }\n  break;\n\n  default : \n  tau  = 0.0;\n  tType = -12;\n  }\n\n  }",
          "fixed_method": "  private void computeShiftIncrement(final int start, final int end, final int deflated) {\n\n  final double cnst1 = 0.563;\n  final double cnst2 = 1.010;\n  final double cnst3 = 1.05;\n\n  \n  \n  if (dMin <= 0.0) {\n  tau = -dMin;\n  tType = -1;\n  return;\n  }\n\n  int nn = 4 * end + pingPong - 1;\n  switch (deflated) {\n\n  case 0 : \n  if (dMin == dN || dMin == dN1) {\n\n  double b1 = Math.sqrt(work[nn - 3]) * Math.sqrt(work[nn - 5]);\n  double b2 = Math.sqrt(work[nn - 7]) * Math.sqrt(work[nn - 9]);\n  double a2 = work[nn - 7] + work[nn - 5];\n\n  if (dMin == dN && dMin1 == dN1) {\n  \n  final double gap2 = dMin2 - a2 - dMin2 * 0.25;\n  final double gap1 = a2 - dN - ((gap2 > 0.0 && gap2 > b2) ? (b2 / gap2) * b2 : (b1 + b2));\n  if (gap1 > 0.0 && gap1 > b1) {\n  tau  = Math.max(dN - (b1 / gap1) * b1, 0.5 * dMin);\n  tType = -2;\n  } else {\n  double s = 0.0;\n  if (dN > b1) {\n  s = dN - b1;\n  }\n  if (a2 > (b1 + b2)) {\n  s = Math.min(s, a2 - (b1 + b2));\n  }\n  tau  = Math.max(s, 0.333 * dMin);\n  tType = -3;\n  }\n  } else {\n  \n  tType = -4;\n  double s = 0.25 * dMin;\n  double gam;\n  int np;\n  if (dMin == dN) {\n  gam = dN;\n  a2 = 0.0;\n  if (work[nn - 5]  >  work[nn - 7]) {\n  return;\n  }\n  b2 = work[nn - 5] / work[nn - 7];\n  np = nn - 9;\n  } else {\n  np = nn - 2 * pingPong;\n  b2 = work[np - 2];\n  gam = dN1;\n  if (work[np - 4]  >  work[np - 2]) {\n  return;\n  }\n  a2 = work[np - 4] / work[np - 2];\n  if (work[nn - 9]  >  work[nn - 11]) {\n  return;\n  }\n  b2 = work[nn - 9] / work[nn - 11];\n  np = nn - 13;\n  }\n\n  \n  a2 = a2 + b2;\n  for (int i4 = np; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n  if(b2 == 0.0) {\n  break;\n  }\n  b1 = b2;\n  if (work[i4]  >  work[i4 - 2]) {\n  return;\n  }\n  b2 = b2 * (work[i4] / work[i4 - 2]);\n  a2 = a2 + b2;\n  if (100 * Math.max(b2, b1) < a2 || cnst1 < a2) {\n  break;\n  }\n  }\n  a2 = cnst3 * a2;\n\n  \n  if (a2 < cnst1) {\n  s = gam * (1 - Math.sqrt(a2)) / (1 + a2);\n  }\n  tau = s;\n\n  }\n  } else if (dMin == dN2) {\n\n  \n  tType = -5;\n  double s = 0.25 * dMin;\n\n  \n  final int np = nn - 2 * pingPong;\n  double b1 = work[np - 2];\n  double b2 = work[np - 6];\n  final double gam = dN2;\n  if (work[np - 8] > b2 || work[np - 4] > b1) {\n  return;\n  }\n  double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);\n\n  \n  if (end - start > 3) {\n  b2 = work[nn - 13] / work[nn - 15];\n  a2 = a2 + b2;\n  for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n  if (b2 == 0.0) {\n  break;\n  }\n  b1 = b2;\n  if (work[i4]  >  work[i4 - 2]) {\n  return;\n  }\n  b2 = b2 * (work[i4] / work[i4 - 2]);\n  a2 = a2 + b2;\n  if (100 * Math.max(b2, b1) < a2 || cnst1 < a2)  {\n  break;\n  }\n  }\n  a2 = cnst3 * a2;\n  }\n\n  if (a2 < cnst1) {\n  tau = gam * (1 - Math.sqrt(a2)) / (1 + a2);\n  } else {\n  tau = s;\n  }\n\n  } else {\n\n  \n  if (tType == -6) {\n  g += 0.333 * (1 - g);\n  } else if (tType == -18) {\n  g = 0.25 * 0.333;\n  } else {\n  g = 0.25;\n  }\n  tau  = g * dMin;\n  tType = -6;\n\n  }\n  break;\n\n  case 1 : \n  if (dMin1 == dN1 && dMin2 == dN2) {\n\n  \n  tType = -7;\n  double s = 0.333 * dMin1;\n  if (work[nn - 5] > work[nn - 7]) {\n  return;\n  }\n  double b1 = work[nn - 5] / work[nn - 7];\n  double b2 = b1;\n  if (b2 != 0.0) {\n  for (int i4 = 4 * end - 10 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n  final double oldB1 = b1;\n  if (work[i4] > work[i4 - 2]) {\n  return;\n  }\n  b1 = b1 * (work[i4] / work[i4 - 2]);\n  b2 = b2 + b1;\n  if (100 * Math.max(b1, oldB1) < b2) {\n  break;\n  }\n  }\n  }\n  b2 = Math.sqrt(cnst3 * b2);\n  final double a2 = dMin1 / (1 + b2 * b2);\n  final double gap2 = 0.5 * dMin2 - a2;\n  if (gap2 > 0.0 && gap2 > b2 * a2) {\n  tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));\n  } else {\n  tau = Math.max(s, a2 * (1 - cnst2 * b2));\n  tType = -8;\n  }\n  } else {\n\n  \n  tau = 0.25 * dMin1;\n  if (dMin1 == dN1) {\n  tau = 0.5 * dMin1;\n  }\n  tType = -9;\n  }\n  break;\n\n  case 2 : \n\n  \n  if (dMin2 == dN2 && 2 * work[nn - 5] < work[nn - 7]) {\n  tType = -10;\n  final double s = 0.333 * dMin2;\n  if (work[nn - 5] > work[nn - 7]) {\n  return;\n  }\n  double b1 = work[nn - 5] / work[nn - 7];\n  double b2 = b1;\n  if (b2 != 0.0){\n  for (int i4 = 4 * end - 9 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n  if (work[i4] > work[i4 - 2]) {\n  return;\n  }\n  b1 *= work[i4] / work[i4 - 2];\n  b2 += b1;\n  if (100 * b1 < b2) {\n  break;\n  }\n  }\n  }\n  b2 = Math.sqrt(cnst3 * b2);\n  final double a2 = dMin2 / (1 + b2 * b2);\n  final double gap2 = work[nn - 7] + work[nn - 9] -\n  Math.sqrt(work[nn - 11]) * Math.sqrt(work[nn - 9]) - a2;\n  if (gap2 > 0.0 && gap2 > b2 * a2) {\n  tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));\n  } else {\n  tau = Math.max(s, a2 * (1 - cnst2 * b2));\n  }\n  } else {\n  tau  = 0.25 * dMin2;\n  tType = -11;\n  }\n  break;\n\n  default : \n  tau  = 0.0;\n  tType = -12;\n  }\n\n  }",
          "diff": [
            "@@ -1540,7 +1541,7 @@",
            "                 double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);\n",
            " \n",
            "                 // approximate contribution to norm squared from i < nn-2.\n",
            "-                if (end - start > 2) {\n",
            "+                if (end - start > 3) {\n",
            "                     b2 = work[nn - 13] / work[nn - 15];\n",
            "                     a2 = a2 + b2;\n",
            "                     for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n"
          ],
          "changed_lines": 2
        }
      ]
    }
  ]
}
