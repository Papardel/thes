{
  "bug_id": "14",
  "failed_tests": {
    "org.mockitousage.bugs.VerifyingWithAnExtraCallToADifferentMockTest": [
      {
        "methodName": "shouldAllowVerifyingWhenOtherMockCallIsInTheSameLine",
        "error": "junit.framework.AssertionFailedError:",
        "message": "",
        "fail_line": "        verify(mockTwo).simpleMethod(mock.otherMethod());",
        "test_source": "  public void shouldAllowVerifyingWhenOtherMockCallIsInTheSameLine() {\n  //given\n  when(mock.otherMethod()).thenReturn(\"foo\");\n  \n  //when\n  mockTwo.simpleMethod(\"foo\");\n  \n  //then\n  verify(mockTwo).simpleMethod(mock.otherMethod());\n  }",
        "stack": [
          "Reporter.wantedButNotInvoked line 257, MissingInvocationChecker.check line 41, Times.verify line 35, MockHandler.handle line 77, MethodInterceptorFilter.intercept line 47, VerifyingWithAnExtraCallToADifferentMockTest.shouldAllowVerifyingWhenOtherMockCallIsInTheSameLine line 29"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/mockito/internal/MockHandler.java",
      "buggy_full_code": "\npackage org.mockito.internal;\n\nimport java.util.List;\n\nimport org.mockito.internal.creation.MockSettingsImpl;\nimport org.mockito.internal.invocation.Invocation;\nimport org.mockito.internal.invocation.InvocationMatcher;\nimport org.mockito.internal.invocation.MatchersBinder;\nimport org.mockito.internal.progress.MockingProgress;\nimport org.mockito.internal.progress.ThreadSafeMockingProgress;\nimport org.mockito.internal.stubbing.InvocationContainer;\nimport org.mockito.internal.stubbing.InvocationContainerImpl;\nimport org.mockito.internal.stubbing.OngoingStubbingImpl;\nimport org.mockito.internal.stubbing.StubbedInvocationMatcher;\nimport org.mockito.internal.stubbing.VoidMethodStubbableImpl;\nimport org.mockito.internal.verification.VerificationDataImpl;\nimport org.mockito.stubbing.Answer;\nimport org.mockito.stubbing.VoidMethodStubbable;\nimport org.mockito.verification.VerificationMode;\n\n\npublic class MockHandler<T> implements MockitoInvocationHandler, MockHandlerInterface<T> { private static final long serialVersionUID = -2917871070982574165L; InvocationContainerImpl invocationContainerImpl; MatchersBinder matchersBinder = new MatchersBinder(); MockingProgress mockingProgress = new ThreadSafeMockingProgress(); private final MockSettingsImpl mockSettings; public MockHandler(MockSettingsImpl mockSettings) {\n        this.mockSettings = mockSettings;\n        this.mockingProgress = new ThreadSafeMockingProgress();\n        this.matchersBinder = new MatchersBinder();\n        this.invocationContainerImpl = new InvocationContainerImpl(mockingProgress);\n    }\n\n    \n    MockHandler() {\n        this(new MockSettingsImpl());\n    }\n\n    public MockHandler(MockHandlerInterface<T> oldMockHandler) {\n        this(oldMockHandler.getMockSettings());\n    }\n\n    public Object handle(Invocation invocation) throws Throwable {\n        if (invocationContainerImpl.hasAnswersForStubbing()) {\n            \n            InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress\n                            .getArgumentMatcherStorage(), invocation);\n            invocationContainerImpl.setMethodForStubbing(invocationMatcher);\n            return null;\n        }\n        VerificationMode verificationMode = mockingProgress.pullVerificationMode();\n\n        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(),\n                        invocation);\n\n        mockingProgress.validateState();\n\n        \n        if (verificationMode != null) {\n            \n            \n                VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl.getInvocations(), invocationMatcher);            \n                verificationMode.verify(data);\n                return null;\n        }\n        \n        invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);\n        OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);\n        mockingProgress.reportOngoingStubbing(ongoingStubbing);\n\n        StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);\n\n        if (stubbedInvocation != null) {\n            stubbedInvocation.captureArgumentsFrom(invocation);\n            return stubbedInvocation.answer(invocation);\n        } else {\n            Object ret = mockSettings.getDefaultAnswer().answer(invocation);\n\n            \n            \n            \n            \n            \n            invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);\n            return ret;\n        }\n    }\n\n    public VoidMethodStubbable<T> voidMethodStubbable(T mock) {\n        return new VoidMethodStubbableImpl<T>(mock, invocationContainerImpl);\n    }\n\n    public MockSettingsImpl getMockSettings() {\n        return mockSettings;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public void setAnswersForStubbing(List<Answer> answers) {\n        invocationContainerImpl.setAnswersForStubbing(answers);\n    }\n\n    public InvocationContainer getInvocationContainer() {\n        return invocationContainerImpl;\n    }\n}",
      "fixed_full_code": "\npackage org.mockito.internal;\n\nimport java.util.List;\n\nimport org.mockito.internal.creation.MockSettingsImpl;\nimport org.mockito.internal.invocation.Invocation;\nimport org.mockito.internal.invocation.InvocationMatcher;\nimport org.mockito.internal.invocation.MatchersBinder;\nimport org.mockito.internal.progress.MockingProgress;\nimport org.mockito.internal.progress.ThreadSafeMockingProgress;\nimport org.mockito.internal.stubbing.InvocationContainer;\nimport org.mockito.internal.stubbing.InvocationContainerImpl;\nimport org.mockito.internal.stubbing.OngoingStubbingImpl;\nimport org.mockito.internal.stubbing.StubbedInvocationMatcher;\nimport org.mockito.internal.stubbing.VoidMethodStubbableImpl;\nimport org.mockito.internal.verification.MockAwareVerificationMode;\nimport org.mockito.internal.verification.VerificationDataImpl;\nimport org.mockito.stubbing.Answer;\nimport org.mockito.stubbing.VoidMethodStubbable;\nimport org.mockito.verification.VerificationMode;\n\n\npublic class MockHandler<T> implements MockitoInvocationHandler, MockHandlerInterface<T> { private static final long serialVersionUID = -2917871070982574165L; InvocationContainerImpl invocationContainerImpl; MatchersBinder matchersBinder = new MatchersBinder(); MockingProgress mockingProgress = new ThreadSafeMockingProgress(); private final MockSettingsImpl mockSettings; public MockHandler(MockSettingsImpl mockSettings) {\n        this.mockSettings = mockSettings;\n        this.mockingProgress = new ThreadSafeMockingProgress();\n        this.matchersBinder = new MatchersBinder();\n        this.invocationContainerImpl = new InvocationContainerImpl(mockingProgress);\n    }\n\n    \n    MockHandler() {\n        this(new MockSettingsImpl());\n    }\n\n    public MockHandler(MockHandlerInterface<T> oldMockHandler) {\n        this(oldMockHandler.getMockSettings());\n    }\n\n    public Object handle(Invocation invocation) throws Throwable {\n        if (invocationContainerImpl.hasAnswersForStubbing()) {\n            \n            InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress\n                            .getArgumentMatcherStorage(), invocation);\n            invocationContainerImpl.setMethodForStubbing(invocationMatcher);\n            return null;\n        }\n        VerificationMode verificationMode = mockingProgress.pullVerificationMode();\n\n        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(),\n                        invocation);\n\n        mockingProgress.validateState();\n\n        \n        if (verificationMode != null) {\n            \n            \n            if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {\n                VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl.getInvocations(), invocationMatcher);            \n                verificationMode.verify(data);\n                return null;\n            }\n        }\n        \n        invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);\n        OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);\n        mockingProgress.reportOngoingStubbing(ongoingStubbing);\n\n        StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);\n\n        if (stubbedInvocation != null) {\n            stubbedInvocation.captureArgumentsFrom(invocation);\n            return stubbedInvocation.answer(invocation);\n        } else {\n            Object ret = mockSettings.getDefaultAnswer().answer(invocation);\n\n            \n            \n            \n            \n            \n            invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);\n            return ret;\n        }\n    }\n\n    public VoidMethodStubbable<T> voidMethodStubbable(T mock) {\n        return new VoidMethodStubbableImpl<T>(mock, invocationContainerImpl);\n    }\n\n    public MockSettingsImpl getMockSettings() {\n        return mockSettings;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public void setAnswersForStubbing(List<Answer> answers) {\n        invocationContainerImpl.setAnswersForStubbing(answers);\n    }\n\n    public InvocationContainer getInvocationContainer() {\n        return invocationContainerImpl;\n    }\n}",
      "buggy_signatures": [
        "public MockHandler(MockHandlerInterface<T> oldMockHandler)",
        "public Object handle(Invocation invocation) throws Throwable",
        "public VoidMethodStubbable<T> voidMethodStubbable(T mock)",
        "public MockSettingsImpl getMockSettings()",
        "public void setAnswersForStubbing(List<Answer> answers)",
        "public InvocationContainer getInvocationContainer()"
      ],
      "fixed_signatures": [
        "public MockHandler(MockHandlerInterface<T> oldMockHandler)",
        "public Object handle(Invocation invocation) throws Throwable",
        "public VoidMethodStubbable<T> voidMethodStubbable(T mock)",
        "public MockSettingsImpl getMockSettings()",
        "public void setAnswersForStubbing(List<Answer> answers)",
        "public InvocationContainer getInvocationContainer()"
      ],
      "methods": [
        {
          "buggy_method": "",
          "fixed_method": "",
          "diff": [
            "@@ -17,6 +17,7 @@",
            " import org.mockito.internal.stubbing.OngoingStubbingImpl;\n",
            " import org.mockito.internal.stubbing.StubbedInvocationMatcher;\n",
            " import org.mockito.internal.stubbing.VoidMethodStubbableImpl;\n",
            "+import org.mockito.internal.verification.MockAwareVerificationMode;\n",
            " import org.mockito.internal.verification.VerificationDataImpl;\n",
            " import org.mockito.stubbing.Answer;\n",
            " import org.mockito.stubbing.VoidMethodStubbable;\n"
          ],
          "changed_lines": 1
        },
        {
          "buggy_method": "  public Object handle(Invocation invocation) throws Throwable {\n  if (invocationContainerImpl.hasAnswersForStubbing()) {\n  \n  InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress\n  .getArgumentMatcherStorage(), invocation);\n  invocationContainerImpl.setMethodForStubbing(invocationMatcher);\n  return null;\n  }\n  VerificationMode verificationMode = mockingProgress.pullVerificationMode();\n\n  InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(),\n  invocation);\n\n  mockingProgress.validateState();\n\n  \n  if (verificationMode != null) {\n  \n  \n  VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl.getInvocations(), invocationMatcher);  \n  verificationMode.verify(data);\n  return null;\n  }\n  \n  invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);\n  OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);\n  mockingProgress.reportOngoingStubbing(ongoingStubbing);\n\n  StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);\n\n  if (stubbedInvocation != null) {\n  stubbedInvocation.captureArgumentsFrom(invocation);\n  return stubbedInvocation.answer(invocation);\n  } else {\n  Object ret = mockSettings.getDefaultAnswer().answer(invocation);\n\n  \n  \n  \n  \n  \n  invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);\n  return ret;\n  }\n  }",
          "fixed_method": "  public Object handle(Invocation invocation) throws Throwable {\n  if (invocationContainerImpl.hasAnswersForStubbing()) {\n  \n  InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress\n  .getArgumentMatcherStorage(), invocation);\n  invocationContainerImpl.setMethodForStubbing(invocationMatcher);\n  return null;\n  }\n  VerificationMode verificationMode = mockingProgress.pullVerificationMode();\n\n  InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(),\n  invocation);\n\n  mockingProgress.validateState();\n\n  \n  if (verificationMode != null) {\n  \n  \n  if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {\n  VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl.getInvocations(), invocationMatcher);  \n  verificationMode.verify(data);\n  return null;\n  }\n  }\n  \n  invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);\n  OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);\n  mockingProgress.reportOngoingStubbing(ongoingStubbing);\n\n  StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);\n\n  if (stubbedInvocation != null) {\n  stubbedInvocation.captureArgumentsFrom(invocation);\n  return stubbedInvocation.answer(invocation);\n  } else {\n  Object ret = mockSettings.getDefaultAnswer().answer(invocation);\n\n  \n  \n  \n  \n  \n  invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);\n  return ret;\n  }\n  }",
          "diff": [
            "@@ -73,9 +74,11 @@",
            "         if (verificationMode != null) {\n",
            "             //We need to check if verification was started on the correct mock \n",
            "             // - see VerifyingWithAnExtraCallToADifferentMockTest\n",
            "+            if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {\n",
            "                 VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl.getInvocations(), invocationMatcher);            \n",
            "                 verificationMode.verify(data);\n",
            "                 return null;\n",
            "+            }\n",
            "         }\n",
            "         \n",
            "         invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);\n"
          ],
          "changed_lines": 2
        }
      ]
    },
    {
      "name": "org/mockito/internal/MockitoCore.java",
      "buggy_full_code": "\npackage org.mockito.internal;\n\nimport java.util.Arrays;\nimport java.util.List;\n\nimport org.mockito.InOrder;\nimport org.mockito.MockSettings;\nimport org.mockito.exceptions.Reporter;\nimport org.mockito.exceptions.misusing.NotAMockException;\nimport org.mockito.internal.creation.MockSettingsImpl;\nimport org.mockito.internal.invocation.AllInvocationsFinder;\nimport org.mockito.internal.invocation.Invocation;\nimport org.mockito.internal.progress.IOngoingStubbing;\nimport org.mockito.internal.progress.MockingProgress;\nimport org.mockito.internal.progress.ThreadSafeMockingProgress;\nimport org.mockito.internal.stubbing.OngoingStubbingImpl;\nimport org.mockito.internal.stubbing.StubberImpl;\nimport org.mockito.internal.util.MockUtil;\nimport org.mockito.internal.verification.VerificationDataImpl;\nimport org.mockito.internal.verification.VerificationModeFactory;\nimport org.mockito.internal.verification.api.InOrderContext;\nimport org.mockito.internal.verification.api.VerificationDataInOrder;\nimport org.mockito.internal.verification.api.VerificationDataInOrderImpl;\nimport org.mockito.stubbing.Answer;\nimport org.mockito.stubbing.DeprecatedOngoingStubbing;\nimport org.mockito.stubbing.OngoingStubbing;\nimport org.mockito.stubbing.Stubber;\nimport org.mockito.stubbing.VoidMethodStubbable;\nimport org.mockito.verification.VerificationMode;\n\n@SuppressWarnings(\"unchecked\")\npublic class MockitoCore { private final Reporter reporter = new Reporter(); private final MockUtil mockUtil = new MockUtil(); private final MockingProgress mockingProgress = new ThreadSafeMockingProgress(); public <T> T mock(Class<T> classToMock, MockSettings mockSettings) {\n        T mock = mockUtil.createMock(classToMock, (MockSettingsImpl) mockSettings);\n        mockingProgress.mockingStarted(mock, classToMock, mockSettings);\n        return mock;\n    }\n    \n    public IOngoingStubbing stub() {\n        IOngoingStubbing stubbing = mockingProgress.pullOngoingStubbing();\n        if (stubbing == null) {\n            mockingProgress.reset();\n            reporter.missingMethodInvocation();\n        }\n        return stubbing;\n    }\n\n    public <T> DeprecatedOngoingStubbing<T> stub(T methodCall) {\n        mockingProgress.stubbingStarted();\n        return (DeprecatedOngoingStubbing) stub();\n    }\n\n    public <T> OngoingStubbing<T> when(T methodCall) {\n        mockingProgress.stubbingStarted();\n        return (OngoingStubbing) stub();\n    }\n    \n    public <T> T verify(T mock, VerificationMode mode) {\n        if (mock == null) {\n            reporter.nullPassedToVerify();\n        } else if (!mockUtil.isMock(mock)) {\n            reporter.notAMockPassedToVerify();\n        }\n        mockingProgress.verificationStarted(mode);\n        return mock;\n    }\n    \n    public <T> void reset(T ... mocks) {\n        mockingProgress.validateState();\n        mockingProgress.reset();\n        mockingProgress.resetOngoingStubbing();\n        \n        for (T m : mocks) {\n            mockUtil.resetMock(m);\n        }\n    }\n    \n    public void verifyNoMoreInteractions(Object... mocks) {\n        assertMocksNotEmpty(mocks);\n        mockingProgress.validateState();\n        for (Object mock : mocks) {\n            try {\n                if (mock == null) {\n                    reporter.nullPassedToVerifyNoMoreInteractions();\n                }\n                List<Invocation> invocations = mockUtil.getMockHandler(mock).getInvocationContainer().getInvocations();\n                VerificationDataImpl data = new VerificationDataImpl(invocations, null);\n                VerificationModeFactory.noMoreInteractions().verify(data);\n            } catch (NotAMockException e) {\n                reporter.notAMockPassedToVerifyNoMoreInteractions();\n            }\n        }\n    }\n\n    public void verifyNoMoreInteractionsInOrder(List<Object> mocks, InOrderContext inOrderContext) {\n        mockingProgress.validateState();\n        AllInvocationsFinder finder = new AllInvocationsFinder();\n        VerificationDataInOrder data = new VerificationDataInOrderImpl(inOrderContext, finder.find(mocks), null);\n        VerificationModeFactory.noMoreInteractions().verifyInOrder(data);\n    }    \n    \n    private void assertMocksNotEmpty(Object[] mocks) {\n        if (mocks == null || mocks.length == 0) {\n            reporter.mocksHaveToBePassedToVerifyNoMoreInteractions();\n        }\n    }\n    \n    public InOrder inOrder(Object... mocks) {\n        if (mocks == null || mocks.length == 0) {\n            reporter.mocksHaveToBePassedWhenCreatingInOrder();\n        }\n        for (Object mock : mocks) {\n            if (mock == null) {\n                reporter.nullPassedWhenCreatingInOrder();\n            } else if (!mockUtil.isMock(mock)) {\n                reporter.notAMockPassedWhenCreatingInOrder();\n            }\n        }\n        return new InOrderImpl(Arrays.asList(mocks));\n    }\n    \n    public Stubber doAnswer(Answer answer) {\n        mockingProgress.stubbingStarted();\n        mockingProgress.resetOngoingStubbing();\n        return new StubberImpl().doAnswer(answer);\n    }\n    \n    public <T> VoidMethodStubbable<T> stubVoid(T mock) {\n        MockHandlerInterface<T> handler = mockUtil.getMockHandler(mock);\n        mockingProgress.stubbingStarted();\n        return handler.voidMethodStubbable(mock);\n    }\n\n    public void validateMockitoUsage() {\n        mockingProgress.validateState();\n    }\n\n    \n    public Invocation getLastInvocation() {\n        OngoingStubbingImpl ongoingStubbing = ((OngoingStubbingImpl) mockingProgress.pullOngoingStubbing());\n        List<Invocation> allInvocations = ongoingStubbing.getRegisteredInvocations();\n        return allInvocations.get(allInvocations.size()-1);\n    }\n}",
      "fixed_full_code": "\npackage org.mockito.internal;\n\nimport java.util.Arrays;\nimport java.util.List;\n\nimport org.mockito.InOrder;\nimport org.mockito.MockSettings;\nimport org.mockito.exceptions.Reporter;\nimport org.mockito.exceptions.misusing.NotAMockException;\nimport org.mockito.internal.creation.MockSettingsImpl;\nimport org.mockito.internal.invocation.AllInvocationsFinder;\nimport org.mockito.internal.invocation.Invocation;\nimport org.mockito.internal.progress.IOngoingStubbing;\nimport org.mockito.internal.progress.MockingProgress;\nimport org.mockito.internal.progress.ThreadSafeMockingProgress;\nimport org.mockito.internal.stubbing.OngoingStubbingImpl;\nimport org.mockito.internal.stubbing.StubberImpl;\nimport org.mockito.internal.util.MockUtil;\nimport org.mockito.internal.verification.MockAwareVerificationMode;\nimport org.mockito.internal.verification.VerificationDataImpl;\nimport org.mockito.internal.verification.VerificationModeFactory;\nimport org.mockito.internal.verification.api.InOrderContext;\nimport org.mockito.internal.verification.api.VerificationDataInOrder;\nimport org.mockito.internal.verification.api.VerificationDataInOrderImpl;\nimport org.mockito.stubbing.Answer;\nimport org.mockito.stubbing.DeprecatedOngoingStubbing;\nimport org.mockito.stubbing.OngoingStubbing;\nimport org.mockito.stubbing.Stubber;\nimport org.mockito.stubbing.VoidMethodStubbable;\nimport org.mockito.verification.VerificationMode;\n\n@SuppressWarnings(\"unchecked\")\npublic class MockitoCore { private final Reporter reporter = new Reporter(); private final MockUtil mockUtil = new MockUtil(); private final MockingProgress mockingProgress = new ThreadSafeMockingProgress(); public <T> T mock(Class<T> classToMock, MockSettings mockSettings) {\n        T mock = mockUtil.createMock(classToMock, (MockSettingsImpl) mockSettings);\n        mockingProgress.mockingStarted(mock, classToMock, mockSettings);\n        return mock;\n    }\n    \n    public IOngoingStubbing stub() {\n        IOngoingStubbing stubbing = mockingProgress.pullOngoingStubbing();\n        if (stubbing == null) {\n            mockingProgress.reset();\n            reporter.missingMethodInvocation();\n        }\n        return stubbing;\n    }\n\n    public <T> DeprecatedOngoingStubbing<T> stub(T methodCall) {\n        mockingProgress.stubbingStarted();\n        return (DeprecatedOngoingStubbing) stub();\n    }\n\n    public <T> OngoingStubbing<T> when(T methodCall) {\n        mockingProgress.stubbingStarted();\n        return (OngoingStubbing) stub();\n    }\n    \n    public <T> T verify(T mock, VerificationMode mode) {\n        if (mock == null) {\n            reporter.nullPassedToVerify();\n        } else if (!mockUtil.isMock(mock)) {\n            reporter.notAMockPassedToVerify();\n        }\n        mockingProgress.verificationStarted(new MockAwareVerificationMode(mock, mode));\n        return mock;\n    }\n    \n    public <T> void reset(T ... mocks) {\n        mockingProgress.validateState();\n        mockingProgress.reset();\n        mockingProgress.resetOngoingStubbing();\n        \n        for (T m : mocks) {\n            mockUtil.resetMock(m);\n        }\n    }\n    \n    public void verifyNoMoreInteractions(Object... mocks) {\n        assertMocksNotEmpty(mocks);\n        mockingProgress.validateState();\n        for (Object mock : mocks) {\n            try {\n                if (mock == null) {\n                    reporter.nullPassedToVerifyNoMoreInteractions();\n                }\n                List<Invocation> invocations = mockUtil.getMockHandler(mock).getInvocationContainer().getInvocations();\n                VerificationDataImpl data = new VerificationDataImpl(invocations, null);\n                VerificationModeFactory.noMoreInteractions().verify(data);\n            } catch (NotAMockException e) {\n                reporter.notAMockPassedToVerifyNoMoreInteractions();\n            }\n        }\n    }\n\n    public void verifyNoMoreInteractionsInOrder(List<Object> mocks, InOrderContext inOrderContext) {\n        mockingProgress.validateState();\n        AllInvocationsFinder finder = new AllInvocationsFinder();\n        VerificationDataInOrder data = new VerificationDataInOrderImpl(inOrderContext, finder.find(mocks), null);\n        VerificationModeFactory.noMoreInteractions().verifyInOrder(data);\n    }    \n    \n    private void assertMocksNotEmpty(Object[] mocks) {\n        if (mocks == null || mocks.length == 0) {\n            reporter.mocksHaveToBePassedToVerifyNoMoreInteractions();\n        }\n    }\n    \n    public InOrder inOrder(Object... mocks) {\n        if (mocks == null || mocks.length == 0) {\n            reporter.mocksHaveToBePassedWhenCreatingInOrder();\n        }\n        for (Object mock : mocks) {\n            if (mock == null) {\n                reporter.nullPassedWhenCreatingInOrder();\n            } else if (!mockUtil.isMock(mock)) {\n                reporter.notAMockPassedWhenCreatingInOrder();\n            }\n        }\n        return new InOrderImpl(Arrays.asList(mocks));\n    }\n    \n    public Stubber doAnswer(Answer answer) {\n        mockingProgress.stubbingStarted();\n        mockingProgress.resetOngoingStubbing();\n        return new StubberImpl().doAnswer(answer);\n    }\n    \n    public <T> VoidMethodStubbable<T> stubVoid(T mock) {\n        MockHandlerInterface<T> handler = mockUtil.getMockHandler(mock);\n        mockingProgress.stubbingStarted();\n        return handler.voidMethodStubbable(mock);\n    }\n\n    public void validateMockitoUsage() {\n        mockingProgress.validateState();\n    }\n\n    \n    public Invocation getLastInvocation() {\n        OngoingStubbingImpl ongoingStubbing = ((OngoingStubbingImpl) mockingProgress.pullOngoingStubbing());\n        List<Invocation> allInvocations = ongoingStubbing.getRegisteredInvocations();\n        return allInvocations.get(allInvocations.size()-1);\n    }\n}",
      "buggy_signatures": [
        "public IOngoingStubbing stub()",
        "public <T> DeprecatedOngoingStubbing<T> stub(T methodCall)",
        "public <T> OngoingStubbing<T> when(T methodCall)",
        "public <T> T verify(T mock, VerificationMode mode)",
        "public <T> void reset(T ... mocks)",
        "public void verifyNoMoreInteractions(Object... mocks)",
        "public void verifyNoMoreInteractionsInOrder(List<Object> mocks, InOrderContext inOrderContext)",
        "private void assertMocksNotEmpty(Object[] mocks)",
        "public InOrder inOrder(Object... mocks)",
        "public Stubber doAnswer(Answer answer)",
        "public <T> VoidMethodStubbable<T> stubVoid(T mock)",
        "public void validateMockitoUsage()",
        "public Invocation getLastInvocation()"
      ],
      "fixed_signatures": [
        "public IOngoingStubbing stub()",
        "public <T> DeprecatedOngoingStubbing<T> stub(T methodCall)",
        "public <T> OngoingStubbing<T> when(T methodCall)",
        "public <T> T verify(T mock, VerificationMode mode)",
        "public <T> void reset(T ... mocks)",
        "public void verifyNoMoreInteractions(Object... mocks)",
        "public void verifyNoMoreInteractionsInOrder(List<Object> mocks, InOrderContext inOrderContext)",
        "private void assertMocksNotEmpty(Object[] mocks)",
        "public InOrder inOrder(Object... mocks)",
        "public Stubber doAnswer(Answer answer)",
        "public <T> VoidMethodStubbable<T> stubVoid(T mock)",
        "public void validateMockitoUsage()",
        "public Invocation getLastInvocation()"
      ],
      "methods": [
        {
          "buggy_method": "",
          "fixed_method": "",
          "diff": [
            "@@ -20,6 +20,7 @@",
            " import org.mockito.internal.stubbing.OngoingStubbingImpl;\n",
            " import org.mockito.internal.stubbing.StubberImpl;\n",
            " import org.mockito.internal.util.MockUtil;\n",
            "+import org.mockito.internal.verification.MockAwareVerificationMode;\n",
            " import org.mockito.internal.verification.VerificationDataImpl;\n",
            " import org.mockito.internal.verification.VerificationModeFactory;\n",
            " import org.mockito.internal.verification.api.InOrderContext;\n"
          ],
          "changed_lines": 1
        },
        {
          "buggy_method": "  public <T> T verify(T mock, VerificationMode mode) {\n  if (mock == null) {\n  reporter.nullPassedToVerify();\n  } else if (!mockUtil.isMock(mock)) {\n  reporter.notAMockPassedToVerify();\n  }\n  mockingProgress.verificationStarted(mode);\n  return mock;\n  }",
          "fixed_method": "  public <T> T verify(T mock, VerificationMode mode) {\n  if (mock == null) {\n  reporter.nullPassedToVerify();\n  } else if (!mockUtil.isMock(mock)) {\n  reporter.notAMockPassedToVerify();\n  }\n  mockingProgress.verificationStarted(new MockAwareVerificationMode(mock, mode));\n  return mock;\n  }",
          "diff": [
            "@@ -70,7 +71,7 @@",
            "         } else if (!mockUtil.isMock(mock)) {\n",
            "             reporter.notAMockPassedToVerify();\n",
            "         }\n",
            "-        mockingProgress.verificationStarted(mode);\n",
            "+        mockingProgress.verificationStarted(new MockAwareVerificationMode(mock, mode));\n",
            "         return mock;\n",
            "     }\n",
            "     \n"
          ],
          "changed_lines": 2
        }
      ]
    }
  ]
}
