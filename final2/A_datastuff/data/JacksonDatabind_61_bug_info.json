{
  "bug_id": "61",
  "failed_tests": {
    "com.fasterxml.jackson.databind.jsontype.DefaultTypingWithPrimitivesTest": [
      {
        "methodName": "testDefaultTypingWithLong",
        "error": "com.fasterxml.jackson.databind.JsonMappingException",
        "message": "Class java.lang.Long not subtype of [simple type, class long] (through reference chain: java.util.HashMap[\"longAsField\"]->com.fasterxml.jackson.databind.jsontype.Data[\"key\"])",
        "fail_line": "        Map<?,?> result = mapper.readValue(json, Map.class);",
        "test_source": "  public void testDefaultTypingWithLong() throws Exception {\n  Data data = new Data();\n  data.key = 1L;\n  Map<String, Object> mapData = new HashMap<String, Object>();\n  mapData.put(\"longInMap\", 2L);\n  mapData.put(\"longAsField\", data);\n\n  // Configure Jackson to preserve types\n  ObjectMapper mapper = new ObjectMapper();\n  StdTypeResolverBuilder resolver = new StdTypeResolverBuilder();\n  resolver.init(JsonTypeInfo.Id.CLASS, null);\n  resolver.inclusion(JsonTypeInfo.As.PROPERTY);\n  resolver.typeProperty(\"__t\");\n  mapper.setDefaultTyping(resolver);\n  mapper.enable(SerializationFeature.INDENT_OUTPUT);\n\n  // Serialize\n  String json = mapper.writeValueAsString(mapData);\n\n  // Deserialize\n  Map<?,?> result = mapper.readValue(json, Map.class);\n  assertNotNull(result);\n  assertEquals(2, result.size());\n  }",
        "stack": [
          "JsonMappingException.wrapWithPath line 379, JsonMappingException.wrapWithPath line 339, BeanDeserializerBase.wrapAndThrow line 1591, BeanDeserializer.vanillaDeserialize line 278, BeanDeserializer._deserializeOther line 178, BeanDeserializer.deserialize line 150, AsPropertyTypeDeserializer._deserializeTypedForId line 129, AsPropertyTypeDeserializer.deserializeTypedFromObject line 97, AsPropertyTypeDeserializer.deserializeTypedFromAny line 174, UntypedObjectDeserializer$Vanilla.deserializeWithType line 554, MapDeserializer._readAndBindStringKeyMap line 509, MapDeserializer.deserialize line 352, MapDeserializer.deserialize line 27, AsPropertyTypeDeserializer._deserializeTypedForId line 129, AsPropertyTypeDeserializer.deserializeTypedFromObject line 97, MapDeserializer.deserializeWithType line 387, TypeWrappedDeserializer.deserialize line 63, ObjectMapper._readMapAndClose line 3795, ObjectMapper.readValue line 2839, DefaultTypingWithPrimitivesTest.testDefaultTypingWithLong line 38, TypeFactory.constructSpecializedType line 359, ClassNameIdResolver._typeFromId line 72, ClassNameIdResolver.typeFromId line 42, TypeDeserializerBase._findDeserializer line 150, AsArrayTypeDeserializer._deserialize line 97, AsArrayTypeDeserializer.deserializeTypedFromScalar line 66, StdScalarDeserializer.deserializeWithType line 26, SettableBeanProperty.deserialize line 497, FieldProperty.deserializeAndSet line 108, BeanDeserializer.vanillaDeserialize line 276"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "com/fasterxml/jackson/databind/ObjectMapper.java",
      "buggy_full_code": "package com.fasterxml.jackson.databind;\n\nimport java.io.*;\nimport java.lang.reflect.Type;\nimport java.net.URL;\nimport java.text.DateFormat;\nimport java.util.*;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport com.fasterxml.jackson.annotation.*;\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.io.CharacterEscapes;\nimport com.fasterxml.jackson.core.io.SegmentedStringWriter;\nimport com.fasterxml.jackson.core.type.ResolvedType;\nimport com.fasterxml.jackson.core.type.TypeReference;\nimport com.fasterxml.jackson.core.util.*;\nimport com.fasterxml.jackson.databind.cfg.BaseSettings;\nimport com.fasterxml.jackson.databind.cfg.ContextAttributes;\nimport com.fasterxml.jackson.databind.cfg.HandlerInstantiator;\nimport com.fasterxml.jackson.databind.cfg.MapperConfig;\nimport com.fasterxml.jackson.databind.cfg.MutableConfigOverride;\nimport com.fasterxml.jackson.databind.cfg.ConfigOverrides;\nimport com.fasterxml.jackson.databind.deser.*;\nimport com.fasterxml.jackson.databind.introspect.*;\nimport com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\nimport com.fasterxml.jackson.databind.jsontype.*;\nimport com.fasterxml.jackson.databind.jsontype.impl.StdSubtypeResolver;\nimport com.fasterxml.jackson.databind.jsontype.impl.StdTypeResolverBuilder;\nimport com.fasterxml.jackson.databind.node.*;\nimport com.fasterxml.jackson.databind.ser.*;\nimport com.fasterxml.jackson.databind.type.*;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\nimport com.fasterxml.jackson.databind.util.RootNameLookup;\nimport com.fasterxml.jackson.databind.util.StdDateFormat;\nimport com.fasterxml.jackson.databind.util.TokenBuffer;\n\n\npublic class ObjectMapper extends ObjectCodec implements Versioned, java.io.Serializable { private static final long serialVersionUID = 1L; public enum DefaultTyping { JAVA_LANG_OBJECT, OBJECT_AND_NON_CONCRETE, NON_CONCRETE_AND_ARRAYS, NON_FINAL } public static class DefaultTypeResolverBuilder extends StdTypeResolverBuilder implements java.io.Serializable { private static final long serialVersionUID = 1L; protected final DefaultTyping _appliesFor; public DefaultTypeResolverBuilder(DefaultTyping t) {\n            _appliesFor = t;\n        }\n\n        @Override\n        public TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes) {\n            return useForType(baseType) ? super.buildTypeDeserializer(config, baseType, subtypes) : null;\n        }\n\n        @Override\n        public TypeSerializer buildTypeSerializer(SerializationConfig config, JavaType baseType, Collection<NamedType> subtypes) {\n            return useForType(baseType) ? super.buildTypeSerializer(config, baseType, subtypes) : null;            \n        }\n\n        \n        public boolean useForType(JavaType t) {\n            \n            \n\n            switch (_appliesFor) {\n            case NON_CONCRETE_AND_ARRAYS:\n                while (t.isArrayType()) {\n                    t = t.getContentType();\n                }\n                \n            case OBJECT_AND_NON_CONCRETE:\n                \n                while (t.isReferenceType()) {\n                    t = t.getReferencedType();\n                }\n                return t.isJavaLangObject()\n                        || (!t.isConcrete()\n                                \n                                && !TreeNode.class.isAssignableFrom(t.getRawClass()));\n\n            case NON_FINAL:\n                while (t.isArrayType()) {\n                    t = t.getContentType();\n                }\n                \n                while (t.isReferenceType()) {\n                    t = t.getReferencedType();\n                }\n                \n                return !t.isFinal() && !TreeNode.class.isAssignableFrom(t.getRawClass());\n            default:\n            \n                return t.isJavaLangObject();\n            }\n        }\n    }\n\n    \n    \n    \n    \n    \n    private final static JavaType JSON_NODE_TYPE = SimpleType.constructUnsafe(JsonNode.class); protected final static AnnotationIntrospector DEFAULT_ANNOTATION_INTROSPECTOR = new JacksonAnnotationIntrospector(); protected final static VisibilityChecker<?> STD_VISIBILITY_CHECKER = VisibilityChecker.Std.defaultInstance(); protected final static BaseSettings DEFAULT_BASE = new BaseSettings( null, DEFAULT_ANNOTATION_INTROSPECTOR, STD_VISIBILITY_CHECKER, null, TypeFactory.defaultInstance(), null, StdDateFormat.instance, null, Locale.getDefault(), null, Base64Variants.getDefaultVariant() ); protected final JsonFactory _jsonFactory; protected TypeFactory _typeFactory; protected InjectableValues _injectableValues; protected SubtypeResolver _subtypeResolver; protected ConfigOverrides _propertyOverrides; protected SimpleMixInResolver _mixIns; protected SerializationConfig _serializationConfig; protected DefaultSerializerProvider _serializerProvider; protected SerializerFactory _serializerFactory; protected DeserializationConfig _deserializationConfig; protected DefaultDeserializationContext _deserializationContext; protected Set<Object> _registeredModuleTypes; final protected ConcurrentHashMap<JavaType, JsonDeserializer<Object>> _rootDeserializers = new ConcurrentHashMap<JavaType, JsonDeserializer<Object>>(64, 0.6f, 2); public ObjectMapper() {\n        this(null, null, null);\n    }\n\n    \n    public ObjectMapper(JsonFactory jf) {\n        this(jf, null, null);\n    }\n\n    \n    protected ObjectMapper(ObjectMapper src) {\n        _jsonFactory = src._jsonFactory.copy();\n        _jsonFactory.setCodec(this);\n        _subtypeResolver = src._subtypeResolver;\n        _typeFactory = src._typeFactory;\n        _injectableValues = src._injectableValues;\n        _propertyOverrides = src._propertyOverrides.copy();\n        _mixIns = src._mixIns.copy();\n\n        RootNameLookup rootNames = new RootNameLookup();\n        _serializationConfig = new SerializationConfig(src._serializationConfig, _mixIns, rootNames, _propertyOverrides);\n        _deserializationConfig = new DeserializationConfig(src._deserializationConfig, _mixIns, rootNames, _propertyOverrides);\n        _serializerProvider = src._serializerProvider.copy();\n        _deserializationContext = src._deserializationContext.copy();\n\n        \n        _serializerFactory = src._serializerFactory;\n\n        \n        Set<Object> reg = src._registeredModuleTypes;\n        if (reg == null) {\n            _registeredModuleTypes = null;\n        } else {\n            _registeredModuleTypes = new LinkedHashSet<Object>(reg);\n        }\n    }\n\n    \n    public ObjectMapper(JsonFactory jf, DefaultSerializerProvider sp, DefaultDeserializationContext dc) {\n        \n        if (jf == null) {\n            _jsonFactory = new MappingJsonFactory(this);\n        } else {\n            _jsonFactory = jf;\n            if (jf.getCodec() == null) { \n                _jsonFactory.setCodec(this);\n            }\n        }\n        _subtypeResolver = new StdSubtypeResolver();\n        RootNameLookup rootNames = new RootNameLookup();\n        \n        _typeFactory = TypeFactory.defaultInstance();\n\n        SimpleMixInResolver mixins = new SimpleMixInResolver(null);\n        _mixIns = mixins;\n        BaseSettings base = DEFAULT_BASE.withClassIntrospector(defaultClassIntrospector());\n        ConfigOverrides propOverrides = new ConfigOverrides();\n        _propertyOverrides = propOverrides;\n        _serializationConfig = new SerializationConfig(base,\n                    _subtypeResolver, mixins, rootNames, propOverrides);\n        _deserializationConfig = new DeserializationConfig(base,\n                    _subtypeResolver, mixins, rootNames, propOverrides);\n\n        \n        final boolean needOrder = _jsonFactory.requiresPropertyOrdering();\n        if (needOrder ^ _serializationConfig.isEnabled(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY)) {\n            configure(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY, needOrder);\n        }\n        \n        _serializerProvider = (sp == null) ? new DefaultSerializerProvider.Impl() : sp;\n        _deserializationContext = (dc == null) ?\n                new DefaultDeserializationContext.Impl(BeanDeserializerFactory.instance) : dc;\n\n        \n        _serializerFactory = BeanSerializerFactory.instance;\n    }\n\n    \n    protected ClassIntrospector defaultClassIntrospector() {\n        return new BasicClassIntrospector();\n    }\n\n    \n    \n    \n    public ObjectMapper copy() {\n        _checkInvalidCopy(ObjectMapper.class);\n        return new ObjectMapper(this);\n    }\n\n    \n    protected void _checkInvalidCopy(Class<?> exp) {\n        if (getClass() != exp) {\n            throw new IllegalStateException(\"Failed copy(): \"+getClass().getName()\n                    +\" (version: \"+version()+\") does not override copy(); it has to\");\n        }\n    }\n\n    \n    \n    \n    protected ObjectReader _newReader(DeserializationConfig config) {\n        return new ObjectReader(this, config);\n    }\n\n    \n    protected ObjectReader _newReader(DeserializationConfig config, JavaType valueType, Object valueToUpdate, FormatSchema schema, InjectableValues injectableValues) {\n        return new ObjectReader(this, config, valueType, valueToUpdate, schema, injectableValues);\n    }\n\n    \n    protected ObjectWriter _newWriter(SerializationConfig config) {\n        return new ObjectWriter(this, config);\n    }\n\n    \n    protected ObjectWriter _newWriter(SerializationConfig config, FormatSchema schema) {\n        return new ObjectWriter(this, config, schema);\n    }\n    \n    \n    protected ObjectWriter _newWriter(SerializationConfig config, JavaType rootType, PrettyPrinter pp) {\n        return new ObjectWriter(this, config, rootType, pp);\n    }\n\n    \n    \n    \n    @Override\n    public Version version() {\n        return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION;\n    }\n\n    \n\n    \n    public ObjectMapper registerModule(Module module) {\n        if (isEnabled(MapperFeature.IGNORE_DUPLICATE_MODULE_REGISTRATIONS)) {\n            Object typeId = module.getTypeId();\n            if (typeId != null) {\n                if (_registeredModuleTypes == null) {\n                    \n                    \n                    _registeredModuleTypes = new LinkedHashSet<Object>();\n                }\n                \n                if (!_registeredModuleTypes.add(typeId)) {\n                    return this;\n                }\n            }\n        }\n        \n        \n        String name = module.getModuleName();\n        if (name == null) {\n            throw new IllegalArgumentException(\"Module without defined name\");\n        }\n        Version version = module.version();\n        if (version == null) {\n            throw new IllegalArgumentException(\"Module without defined version\");\n        }\n\n        final ObjectMapper mapper = this;\n        \n        \n        module.setupModule(new Module.SetupContext()\n        {\n            \n\n            @Override\n            public Version getMapperVersion() {\n                return version();\n            }\n\n            @SuppressWarnings(\"unchecked\")\n            @Override\n            public <C extends ObjectCodec> C getOwner() {\n                \n                return (C) mapper;\n            }\n\n            @Override\n            public TypeFactory getTypeFactory() {\n                return _typeFactory;\n            }\n            \n            @Override\n            public boolean isEnabled(MapperFeature f) {\n                return mapper.isEnabled(f);\n            }\n\n            @Override\n            public boolean isEnabled(DeserializationFeature f) {\n                return mapper.isEnabled(f);\n            }\n            \n            @Override\n            public boolean isEnabled(SerializationFeature f) {\n                return mapper.isEnabled(f);\n            }\n\n            @Override\n            public boolean isEnabled(JsonFactory.Feature f) {\n                return mapper.isEnabled(f);\n            }\n\n            @Override\n            public boolean isEnabled(JsonParser.Feature f) {\n                return mapper.isEnabled(f);\n            }\n\n            @Override\n            public boolean isEnabled(JsonGenerator.Feature f) {\n                return mapper.isEnabled(f);\n            }\n\n            \n\n            @Override\n            public MutableConfigOverride configOverride(Class<?> type) {\n                return mapper.configOverride(type);\n            }\n\n            \n\n            @Override\n            public void addDeserializers(Deserializers d) {\n                DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalDeserializers(d);\n                mapper._deserializationContext = mapper._deserializationContext.with(df);\n            }\n\n            @Override\n            public void addKeyDeserializers(KeyDeserializers d) {\n                DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalKeyDeserializers(d);\n                mapper._deserializationContext = mapper._deserializationContext.with(df);\n            }\n\n            @Override\n            public void addBeanDeserializerModifier(BeanDeserializerModifier modifier) {\n                DeserializerFactory df = mapper._deserializationContext._factory.withDeserializerModifier(modifier);\n                mapper._deserializationContext = mapper._deserializationContext.with(df);\n            }\n            \n            \n            \n            @Override\n            public void addSerializers(Serializers s) {\n                mapper._serializerFactory = mapper._serializerFactory.withAdditionalSerializers(s);\n            }\n\n            @Override\n            public void addKeySerializers(Serializers s) {\n                mapper._serializerFactory = mapper._serializerFactory.withAdditionalKeySerializers(s);\n            }\n            \n            @Override\n            public void addBeanSerializerModifier(BeanSerializerModifier modifier) {\n                mapper._serializerFactory = mapper._serializerFactory.withSerializerModifier(modifier);\n            }\n\n            \n            \n            @Override\n            public void addAbstractTypeResolver(AbstractTypeResolver resolver) {\n                DeserializerFactory df = mapper._deserializationContext._factory.withAbstractTypeResolver(resolver);\n                mapper._deserializationContext = mapper._deserializationContext.with(df);\n            }\n\n            @Override\n            public void addTypeModifier(TypeModifier modifier) {\n                TypeFactory f = mapper._typeFactory;\n                f = f.withModifier(modifier);\n                mapper.setTypeFactory(f);\n            }\n\n            @Override\n            public void addValueInstantiators(ValueInstantiators instantiators) {\n                DeserializerFactory df = mapper._deserializationContext._factory.withValueInstantiators(instantiators);\n                mapper._deserializationContext = mapper._deserializationContext.with(df);\n            }\n\n            @Override\n            public void setClassIntrospector(ClassIntrospector ci) {\n                mapper._deserializationConfig = mapper._deserializationConfig.with(ci);\n                mapper._serializationConfig = mapper._serializationConfig.with(ci);\n            }\n\n            @Override\n            public void insertAnnotationIntrospector(AnnotationIntrospector ai) {\n                mapper._deserializationConfig = mapper._deserializationConfig.withInsertedAnnotationIntrospector(ai);\n                mapper._serializationConfig = mapper._serializationConfig.withInsertedAnnotationIntrospector(ai);\n            }\n            \n            @Override\n            public void appendAnnotationIntrospector(AnnotationIntrospector ai) {\n                mapper._deserializationConfig = mapper._deserializationConfig.withAppendedAnnotationIntrospector(ai);\n                mapper._serializationConfig = mapper._serializationConfig.withAppendedAnnotationIntrospector(ai);\n            }\n\n            @Override\n            public void registerSubtypes(Class<?>... subtypes) {\n                mapper.registerSubtypes(subtypes);\n            }\n\n            @Override\n            public void registerSubtypes(NamedType... subtypes) {\n                mapper.registerSubtypes(subtypes);\n            }\n            \n            @Override\n            public void setMixInAnnotations(Class<?> target, Class<?> mixinSource) {\n                mapper.addMixIn(target, mixinSource);\n            }\n            \n            @Override\n            public void addDeserializationProblemHandler(DeserializationProblemHandler handler) {\n                mapper.addHandler(handler);\n            }\n\n            @Override\n            public void setNamingStrategy(PropertyNamingStrategy naming) {\n                mapper.setPropertyNamingStrategy(naming);\n            }\n        });\n        return this;\n    }\n\n    \n    public ObjectMapper registerModules(Module... modules) {\n        for (Module module : modules) {\n            registerModule(module);\n        }\n        return this;\n    }\n\n    \n    public ObjectMapper registerModules(Iterable<com.fasterxml.jackson.databind.Module> modules) {\n        for (Module module : modules) {\n            registerModule(module);\n        }\n        return this;\n    }\n    \n    \n    public static List<com.fasterxml.jackson.databind.Module> findModules() {\n        return findModules(null);\n    }\n\n    \n    public static List<com.fasterxml.jackson.databind.Module> findModules(ClassLoader classLoader) {\n        ArrayList<com.fasterxml.jackson.databind.Module> modules = new ArrayList<Module>();\n        ServiceLoader<com.fasterxml.jackson.databind.Module> loader = (classLoader == null) ?\n                ServiceLoader.load(Module.class) : ServiceLoader.load(Module.class, classLoader);\n        for (Module module : loader) {\n            modules.add(module);\n        }\n        return modules;\n    }\n\n    \n    public ObjectMapper findAndRegisterModules() {\n        return registerModules(findModules());\n    }\n\n    \n\n    \n    public SerializationConfig getSerializationConfig() {\n        return _serializationConfig;\n    }\n\n    \n    public DeserializationConfig getDeserializationConfig() {\n        return _deserializationConfig;\n    }\n    \n    \n    public DeserializationContext getDeserializationContext() {\n        return _deserializationContext;\n    }\n\n    \n    \n    \n    public ObjectMapper setSerializerFactory(SerializerFactory f) {\n        _serializerFactory = f;\n        return this;\n    }\n\n    \n    public SerializerFactory getSerializerFactory() {\n        return _serializerFactory;\n    }\n\n    \n    public ObjectMapper setSerializerProvider(DefaultSerializerProvider p) {\n        _serializerProvider = p;\n        return this;\n    }\n\n    \n    public SerializerProvider getSerializerProvider() {\n        return _serializerProvider;\n    }\n\n    \n    public SerializerProvider getSerializerProviderInstance() {\n        return _serializerProvider(_serializationConfig);\n    }\n\n    \n\n    \n    public ObjectMapper setMixIns(Map<Class<?>, Class<?>> sourceMixins) {\n        \n        _mixIns.setLocalDefinitions(sourceMixins);\n        return this;\n    }\n\n    \n    public ObjectMapper addMixIn(Class<?> target, Class<?> mixinSource) {\n        _mixIns.addLocalDefinition(target, mixinSource);\n        return this;\n    }\n\n    \n    public ObjectMapper setMixInResolver(ClassIntrospector.MixInResolver resolver) {\n        SimpleMixInResolver r = _mixIns.withOverrides(resolver);\n        if (r != _mixIns) {\n            _mixIns = r;\n            _deserializationConfig = new DeserializationConfig(_deserializationConfig, r);\n            _serializationConfig = new SerializationConfig(_serializationConfig, r);\n        }\n        return this;\n    }\n    \n    public Class<?> findMixInClassFor(Class<?> cls) {\n        return _mixIns.findMixInClassFor(cls);\n    }\n\n    \n    public int mixInCount() {\n        return _mixIns.localSize();\n    }\n\n    \n    @Deprecated\n    public void setMixInAnnotations(Map<Class<?>, Class<?>> sourceMixins) {\n        setMixIns(sourceMixins);\n    }\n\n    \n    @Deprecated\n    public final void addMixInAnnotations(Class<?> target, Class<?> mixinSource) {\n        addMixIn(target, mixinSource);\n    }\n    \n    \n\n    \n    public VisibilityChecker<?> getVisibilityChecker() {\n        return _serializationConfig.getDefaultVisibilityChecker();\n    }\n\n    \n    @Deprecated\n    public void setVisibilityChecker(VisibilityChecker<?> vc) {\n        setVisibility(vc);\n    }\n\n    \n    public ObjectMapper setVisibility(VisibilityChecker<?> vc) {\n        _deserializationConfig = _deserializationConfig.with(vc);\n        _serializationConfig = _serializationConfig.with(vc);\n        return this;\n    }\n    \n    \n    public ObjectMapper setVisibility(PropertyAccessor forMethod, JsonAutoDetect.Visibility visibility) {\n        _deserializationConfig = _deserializationConfig.withVisibility(forMethod, visibility);\n        _serializationConfig = _serializationConfig.withVisibility(forMethod, visibility);\n        return this;\n    }\n    \n    \n    public SubtypeResolver getSubtypeResolver() {\n        return _subtypeResolver;\n    }\n\n    \n    public ObjectMapper setSubtypeResolver(SubtypeResolver str) {\n        _subtypeResolver = str;\n        _deserializationConfig = _deserializationConfig.with(str);\n        _serializationConfig = _serializationConfig.with(str);\n        return this;\n    }\n\n    \n    public ObjectMapper setAnnotationIntrospector(AnnotationIntrospector ai) {\n        _serializationConfig = _serializationConfig.with(ai);\n        _deserializationConfig = _deserializationConfig.with(ai);\n        return this;\n    }\n\n    \n    public ObjectMapper setAnnotationIntrospectors(AnnotationIntrospector serializerAI, AnnotationIntrospector deserializerAI) {\n        _serializationConfig = _serializationConfig.with(serializerAI);\n        _deserializationConfig = _deserializationConfig.with(deserializerAI);\n        return this;\n    }\n    \n    \n    public ObjectMapper setPropertyNamingStrategy(PropertyNamingStrategy s) {\n        _serializationConfig = _serializationConfig.with(s);\n        _deserializationConfig = _deserializationConfig.with(s);\n        return this;\n    }\n\n    \n    public PropertyNamingStrategy getPropertyNamingStrategy() {\n        \n        return _serializationConfig.getPropertyNamingStrategy();\n    }\n\n    \n    public ObjectMapper setSerializationInclusion(JsonInclude.Include incl) {\n        setPropertyInclusion(JsonInclude.Value.construct(incl, JsonInclude.Include.USE_DEFAULTS));\n        return this;\n    }\n\n    \n    public ObjectMapper setPropertyInclusion(JsonInclude.Value incl) {\n        _serializationConfig = _serializationConfig.withPropertyInclusion(incl);\n        return this;\n    }\n\n    \n    public ObjectMapper setDefaultPrettyPrinter(PrettyPrinter pp) {\n        _serializationConfig = _serializationConfig.withDefaultPrettyPrinter(pp);\n        return this;\n    }\n\n    \n\n    \n    public ObjectMapper enableDefaultTyping() {\n        return enableDefaultTyping(DefaultTyping.OBJECT_AND_NON_CONCRETE);\n    }\n\n    \n    public ObjectMapper enableDefaultTyping(DefaultTyping dti) {\n        return enableDefaultTyping(dti, JsonTypeInfo.As.WRAPPER_ARRAY);\n    }\n\n    \n    public ObjectMapper enableDefaultTyping(DefaultTyping applicability, JsonTypeInfo.As includeAs) {\n        \n        if (includeAs == JsonTypeInfo.As.EXTERNAL_PROPERTY) {\n            throw new IllegalArgumentException(\"Can not use includeAs of \"+includeAs);\n        }\n        \n        TypeResolverBuilder<?> typer = new DefaultTypeResolverBuilder(applicability);\n        \n        typer = typer.init(JsonTypeInfo.Id.CLASS, null);\n        typer = typer.inclusion(includeAs);\n        return setDefaultTyping(typer);\n    }\n\n    \n    public ObjectMapper enableDefaultTypingAsProperty(DefaultTyping applicability, String propertyName) {\n        TypeResolverBuilder<?> typer = new DefaultTypeResolverBuilder(applicability);\n        \n        typer = typer.init(JsonTypeInfo.Id.CLASS, null);\n        typer = typer.inclusion(JsonTypeInfo.As.PROPERTY);\n        typer = typer.typeProperty(propertyName);\n        return setDefaultTyping(typer);\n    }\n    \n    \n    public ObjectMapper disableDefaultTyping() {\n        return setDefaultTyping(null);\n    }\n\n    \n    public ObjectMapper setDefaultTyping(TypeResolverBuilder<?> typer) {\n        _deserializationConfig = _deserializationConfig.with(typer);\n        _serializationConfig = _serializationConfig.with(typer);\n        return this;\n    }\n\n    \n    public void registerSubtypes(Class<?>... classes) {\n        getSubtypeResolver().registerSubtypes(classes);\n    }\n\n    \n    public void registerSubtypes(NamedType... types) {\n        getSubtypeResolver().registerSubtypes(types);\n    }\n\n    \n\n    \n    public MutableConfigOverride configOverride(Class<?> type) {\n        return _propertyOverrides.findOrCreateOverride(type);\n    }\n\n    \n\n    \n    public TypeFactory getTypeFactory() {\n        return _typeFactory;\n    }\n\n    \n    public ObjectMapper setTypeFactory(TypeFactory f) {\n        _typeFactory = f;\n        _deserializationConfig = _deserializationConfig.with(f);\n        _serializationConfig = _serializationConfig.with(f);\n        return this;\n    }\n    \n    \n    public JavaType constructType(Type t) {\n        return _typeFactory.constructType(t);\n    }\n    \n    \n\n    \n    public JsonNodeFactory getNodeFactory() {\n        return _deserializationConfig.getNodeFactory();\n    }\n    \n    \n    public ObjectMapper setNodeFactory(JsonNodeFactory f) {\n        _deserializationConfig = _deserializationConfig.with(f);\n        return this;\n    }\n\n    \n    public ObjectMapper addHandler(DeserializationProblemHandler h) {\n        _deserializationConfig = _deserializationConfig.withHandler(h);\n        return this;\n    }\n\n    \n    public ObjectMapper clearProblemHandlers() {\n        _deserializationConfig = _deserializationConfig.withNoProblemHandlers();\n        return this;\n    }\n\n    \n    public ObjectMapper setConfig(DeserializationConfig config) {\n        _deserializationConfig = config;\n        return this;\n    }\n\n    \n\n    \n    @Deprecated\n    public void setFilters(FilterProvider filterProvider) {\n        _serializationConfig = _serializationConfig.withFilters(filterProvider);\n    }\n\n    \n    public ObjectMapper setFilterProvider(FilterProvider filterProvider) {\n        _serializationConfig = _serializationConfig.withFilters(filterProvider);\n        return this;\n    }\n\n    \n    public ObjectMapper setBase64Variant(Base64Variant v) {\n        _serializationConfig = _serializationConfig.with(v);\n        _deserializationConfig = _deserializationConfig.with(v);\n        return this;\n    }\n\n    \n    public ObjectMapper setConfig(SerializationConfig config) {\n        _serializationConfig = config;\n        return this;\n    }\n    \n    \n\n    \n    @Override\n    public JsonFactory getFactory() { return _jsonFactory; }\n    \n    \n    @Deprecated\n    @Override\n    public JsonFactory getJsonFactory() { return getFactory(); }\n\n    \n    public ObjectMapper setDateFormat(DateFormat dateFormat) {\n        _deserializationConfig = _deserializationConfig.with(dateFormat);\n        _serializationConfig = _serializationConfig.with(dateFormat);\n        return this;\n    }\n\n    \n    public DateFormat getDateFormat() {\n        \n        return _serializationConfig.getDateFormat();\n    }\n    \n    \n    public Object setHandlerInstantiator(HandlerInstantiator hi) {\n        _deserializationConfig = _deserializationConfig.with(hi);\n        _serializationConfig = _serializationConfig.with(hi);\n        return this;\n    }\n    \n    \n    public ObjectMapper setInjectableValues(InjectableValues injectableValues) {\n        _injectableValues = injectableValues;\n        return this;\n    }\n\n    \n    public InjectableValues getInjectableValues() {\n        return _injectableValues;\n    }\n\n    \n    public ObjectMapper setLocale(Locale l) {\n        _deserializationConfig = _deserializationConfig.with(l);\n        _serializationConfig = _serializationConfig.with(l);\n        return this;\n    }\n\n    \n    public ObjectMapper setTimeZone(TimeZone tz) {\n        _deserializationConfig = _deserializationConfig.with(tz);\n        _serializationConfig = _serializationConfig.with(tz);\n        return this;\n    }\n    \n    \n\n    \n    public boolean isEnabled(MapperFeature f) {\n        \n        return _serializationConfig.isEnabled(f);\n    }\n    \n    \n    public ObjectMapper configure(MapperFeature f, boolean state) {\n        _serializationConfig = state ?\n                _serializationConfig.with(f) : _serializationConfig.without(f);\n        _deserializationConfig = state ?\n                _deserializationConfig.with(f) : _deserializationConfig.without(f);\n        return this;\n    }\n\n    \n    public ObjectMapper enable(MapperFeature... f) {\n        _deserializationConfig = _deserializationConfig.with(f);\n        _serializationConfig = _serializationConfig.with(f);\n        return this;\n    }\n\n    \n    public ObjectMapper disable(MapperFeature... f) {\n        _deserializationConfig = _deserializationConfig.without(f);\n        _serializationConfig = _serializationConfig.without(f);\n        return this;\n    }\n    \n    \n\n    \n    public boolean isEnabled(SerializationFeature f) {\n        return _serializationConfig.isEnabled(f);\n    }\n\n    \n    public ObjectMapper configure(SerializationFeature f, boolean state) {\n        _serializationConfig = state ?\n                _serializationConfig.with(f) : _serializationConfig.without(f);\n        return this;\n    }\n\n    \n    public ObjectMapper enable(SerializationFeature f) {\n        _serializationConfig = _serializationConfig.with(f);\n        return this;\n    }\n\n    \n    public ObjectMapper enable(SerializationFeature first, SerializationFeature... f) {\n        _serializationConfig = _serializationConfig.with(first, f);\n        return this;\n    }\n    \n    \n    public ObjectMapper disable(SerializationFeature f) {\n        _serializationConfig = _serializationConfig.without(f);\n        return this;\n    }\n\n    \n    public ObjectMapper disable(SerializationFeature first, SerializationFeature... f) {\n        _serializationConfig = _serializationConfig.without(first, f);\n        return this;\n    }\n    \n    \n\n    \n    public boolean isEnabled(DeserializationFeature f) {\n        return _deserializationConfig.isEnabled(f);\n    }\n\n    \n    public ObjectMapper configure(DeserializationFeature f, boolean state) {\n        _deserializationConfig = state ?\n                _deserializationConfig.with(f) : _deserializationConfig.without(f);\n        return this;\n    }\n\n    \n    public ObjectMapper enable(DeserializationFeature feature) {\n        _deserializationConfig = _deserializationConfig.with(feature);\n        return this;\n    }\n\n    \n    public ObjectMapper enable(DeserializationFeature first, DeserializationFeature... f) {\n        _deserializationConfig = _deserializationConfig.with(first, f);\n        return this;\n    }\n    \n    \n    public ObjectMapper disable(DeserializationFeature feature) {\n        _deserializationConfig = _deserializationConfig.without(feature);\n        return this;\n    }\n\n    \n    public ObjectMapper disable(DeserializationFeature first, DeserializationFeature... f) {\n        _deserializationConfig = _deserializationConfig.without(first, f);\n        return this;\n    }\n    \n    \n\n    public boolean isEnabled(JsonParser.Feature f) {\n        return _deserializationConfig.isEnabled(f, _jsonFactory);\n    }\n\n    \n    public ObjectMapper configure(JsonParser.Feature f, boolean state) {\n        _jsonFactory.configure(f, state);\n        return this;\n    }\n\n    \n    public ObjectMapper enable(JsonParser.Feature... features) {\n        for (JsonParser.Feature f : features) {\n            _jsonFactory.enable(f);\n        }\n        return this;\n    }\n    \n    \n    public ObjectMapper disable(JsonParser.Feature... features) {\n        for (JsonParser.Feature f : features) {\n            _jsonFactory.disable(f);\n        }\n        return this;\n    }\n    \n    \n\n    public boolean isEnabled(JsonGenerator.Feature f) {\n        return _serializationConfig.isEnabled(f, _jsonFactory);\n    }\n\n    \n    public ObjectMapper configure(JsonGenerator.Feature f, boolean state) {\n        _jsonFactory.configure(f,  state);\n        return this;\n    }\n\n    \n    public ObjectMapper enable(JsonGenerator.Feature... features) {\n        for (JsonGenerator.Feature f : features) {\n            _jsonFactory.enable(f);\n        }\n        return this;\n    }\n\n    \n    public ObjectMapper disable(JsonGenerator.Feature... features) {\n        for (JsonGenerator.Feature f : features) {\n            _jsonFactory.disable(f);\n        }\n        return this;\n    }\n\n    \n    \n    \n    public boolean isEnabled(JsonFactory.Feature f) {\n        return _jsonFactory.isEnabled(f);\n    }\n\n    \n\n    \n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(JsonParser p, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readValue(getDeserializationConfig(), p, _typeFactory.constructType(valueType));\n    } \n\n    \n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(JsonParser p, TypeReference<?> valueTypeRef) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readValue(getDeserializationConfig(), p, _typeFactory.constructType(valueTypeRef));\n    }\n\n    \n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public final <T> T readValue(JsonParser p, ResolvedType valueType) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readValue(getDeserializationConfig(), p, (JavaType) valueType);\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(JsonParser p, JavaType valueType) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readValue(getDeserializationConfig(), p, valueType);\n    }\n    \n    \n    @Override\n    public <T extends TreeNode> T readTree(JsonParser p) throws IOException, JsonProcessingException {\n        \n        \n        DeserializationConfig cfg = getDeserializationConfig();\n        JsonToken t = p.getCurrentToken();\n        if (t == null) {\n            t = p.nextToken();\n            if (t == null) {\n                return null;\n            }\n        }\n        JsonNode n = (JsonNode) _readValue(cfg, p, JSON_NODE_TYPE);\n        if (n == null) {\n            n = getNodeFactory().nullNode();\n        }\n        @SuppressWarnings(\"unchecked\")\n        T result = (T) n;\n        return result;\n    }\n\n    \n    @Override\n    public <T> MappingIterator<T> readValues(JsonParser p, ResolvedType valueType) throws IOException, JsonProcessingException {\n        return readValues(p, (JavaType) valueType);\n    }\n\n    \n    public <T> MappingIterator<T> readValues(JsonParser p, JavaType valueType) throws IOException, JsonProcessingException {\n        DeserializationConfig config = getDeserializationConfig();\n        DeserializationContext ctxt = createDeserializationContext(p, config);\n        JsonDeserializer<?> deser = _findRootDeserializer(ctxt, valueType);\n        \n        return new MappingIterator<T>(valueType, p, ctxt, deser,\n                false, null);\n    }\n\n    \n    @Override\n    public <T> MappingIterator<T> readValues(JsonParser p, Class<T> valueType) throws IOException, JsonProcessingException {\n        return readValues(p, _typeFactory.constructType(valueType));\n    }\n\n    \n    @Override\n    public <T> MappingIterator<T> readValues(JsonParser p, TypeReference<?> valueTypeRef) throws IOException, JsonProcessingException {\n        return readValues(p, _typeFactory.constructType(valueTypeRef));\n    }\n    \n    \n\n    \n    public JsonNode readTree(InputStream in) throws IOException, JsonProcessingException {\n        JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(in), JSON_NODE_TYPE);\n        return (n == null) ? NullNode.instance : n;\n    }\n\n    \n    public JsonNode readTree(Reader r) throws IOException, JsonProcessingException {\n        JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(r), JSON_NODE_TYPE);\n        return (n == null) ? NullNode.instance : n;\n    }\n\n    \n    public JsonNode readTree(String content) throws IOException, JsonProcessingException {\n        JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(content), JSON_NODE_TYPE);\n        return (n == null) ? NullNode.instance : n;\n    }\n\n    \n    public JsonNode readTree(byte[] content) throws IOException, JsonProcessingException {\n        JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(content), JSON_NODE_TYPE);\n        return (n == null) ? NullNode.instance : n;\n    }\n    \n    \n    public JsonNode readTree(File file) throws IOException, JsonProcessingException {\n        JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(file), JSON_NODE_TYPE);\n        return (n == null) ? NullNode.instance : n;\n    }\n\n    \n    public JsonNode readTree(URL source) throws IOException, JsonProcessingException {\n        JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(source), JSON_NODE_TYPE);\n        return (n == null) ? NullNode.instance : n;\n    }\n\n    \n\n    \n    @Override\n    public void writeValue(JsonGenerator g, Object value) throws IOException, JsonGenerationException, JsonMappingException {\n        SerializationConfig config = getSerializationConfig();\n\n        \n        \n        if (config.isEnabled(SerializationFeature.INDENT_OUTPUT)) {\n            if (g.getPrettyPrinter() == null) {\n                g.setPrettyPrinter(config.constructDefaultPrettyPrinter());\n            }\n        }\n        if (config.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) {\n            _writeCloseableValue(g, value, config);\n        } else {\n            _serializerProvider(config).serializeValue(g, value);\n            if (config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) {\n                g.flush();\n            }\n        }\n    }\n\n    \n\n    @Override\n    public void writeTree(JsonGenerator jgen, TreeNode rootNode) throws IOException, JsonProcessingException {\n        SerializationConfig config = getSerializationConfig();\n        _serializerProvider(config).serializeValue(jgen, rootNode);\n        if (config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) {\n            jgen.flush();\n        }\n    }\n    \n    \n    public void writeTree(JsonGenerator jgen, JsonNode rootNode) throws IOException, JsonProcessingException {\n        SerializationConfig config = getSerializationConfig();\n        _serializerProvider(config).serializeValue(jgen, rootNode);\n        if (config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) {\n            jgen.flush();\n        }\n    }\n    \n    \n    @Override    \n    public ObjectNode createObjectNode() {\n        return _deserializationConfig.getNodeFactory().objectNode();\n    }\n\n    \n    @Override\n    public ArrayNode createArrayNode() {\n        return _deserializationConfig.getNodeFactory().arrayNode();\n    }\n\n    \n    @Override\n    public JsonParser treeAsTokens(TreeNode n) {\n        return new TreeTraversingParser((JsonNode) n, this);\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public <T> T treeToValue(TreeNode n, Class<T> valueType) throws JsonProcessingException {\n        try {\n            \n            \n            if (valueType != Object.class && valueType.isAssignableFrom(n.getClass())) {\n                return (T) n;\n            }\n            \n            \n            if (n.asToken() == JsonToken.VALUE_EMBEDDED_OBJECT) {\n                if (n instanceof POJONode) {\n                    Object ob = ((POJONode) n).getPojo();\n                    if ((ob == null) || valueType.isInstance(ob)) {\n                        return (T) ob;\n                    }\n                }\n            }\n            return readValue(treeAsTokens(n), valueType);\n        } catch (JsonProcessingException e) {\n            throw e;\n        } catch (IOException e) { \n            throw new IllegalArgumentException(e.getMessage(), e);\n        }\n    }\n\n    \n    @SuppressWarnings({ \"unchecked\", \"resource\" })\n    public <T extends JsonNode> T valueToTree(Object fromValue) throws IllegalArgumentException {\n        if (fromValue == null) return null;\n        TokenBuffer buf = new TokenBuffer(this, false);\n        if (isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n            buf = buf.forceUseOfBigDecimal(true);\n        }\n        JsonNode result;\n        try {\n            writeValue(buf, fromValue);\n            JsonParser p = buf.asParser();\n            result = readTree(p);\n            p.close();\n        } catch (IOException e) { \n            throw new IllegalArgumentException(e.getMessage(), e);\n        }\n        return (T) result;\n    } \n    \n    \n\n    \n    public boolean canSerialize(Class<?> type) {\n        return _serializerProvider(getSerializationConfig()).hasSerializerFor(type, null);\n    }\n\n    \n    public boolean canSerialize(Class<?> type, AtomicReference<Throwable> cause) {\n        return _serializerProvider(getSerializationConfig()).hasSerializerFor(type, cause);\n    }\n    \n    \n    public boolean canDeserialize(JavaType type) {\n        return createDeserializationContext(null,\n                getDeserializationConfig()).hasValueDeserializerFor(type, null);\n    }\n\n    \n    public boolean canDeserialize(JavaType type, AtomicReference<Throwable> cause) {\n        return createDeserializationContext(null,\n                getDeserializationConfig()).hasValueDeserializerFor(type, cause);\n    }\n    \n    \n\n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(File src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueType));\n    } \n\n    \n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(File src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueTypeRef));\n    } \n\n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(File src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType);\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(URL src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueType));\n    } \n\n    \n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(URL src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueTypeRef));\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(URL src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType);\n    } \n\n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(String content, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(content), _typeFactory.constructType(valueType));\n    } \n\n    \n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(String content, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(content), _typeFactory.constructType(valueTypeRef));\n    } \n\n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(String content, JavaType valueType) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(content), valueType);\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(Reader src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueType));\n    } \n\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(Reader src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueTypeRef));\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(Reader src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType);\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(InputStream src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueType));\n    } \n\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(InputStream src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueTypeRef));\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(InputStream src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType);\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(byte[] src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueType));\n    } \n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(byte[] src, int offset, int len, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src, offset, len), _typeFactory.constructType(valueType));\n    } \n\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(byte[] src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueTypeRef));\n    } \n    \n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(byte[] src, int offset, int len, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src, offset, len), _typeFactory.constructType(valueTypeRef));\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(byte[] src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType);\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(byte[] src, int offset, int len, JavaType valueType) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src, offset, len), valueType);\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(DataInput src, Class<T> valueType) throws IOException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src),\n                _typeFactory.constructType(valueType));\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(DataInput src, JavaType valueType) throws IOException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType);\n    }\n\n    \n\n    \n    public void writeValue(File resultFile, Object value) throws IOException, JsonGenerationException, JsonMappingException {\n        _configAndWriteValue(_jsonFactory.createGenerator(resultFile, JsonEncoding.UTF8), value);\n    }\n\n    \n    public void writeValue(OutputStream out, Object value) throws IOException, JsonGenerationException, JsonMappingException {\n        _configAndWriteValue(_jsonFactory.createGenerator(out, JsonEncoding.UTF8), value);\n    }\n\n    \n    public void writeValue(DataOutput out, Object value) throws IOException {\n        _configAndWriteValue(_jsonFactory.createGenerator(out, JsonEncoding.UTF8), value);\n    }\n\n    \n    public void writeValue(Writer w, Object value) throws IOException, JsonGenerationException, JsonMappingException {\n        _configAndWriteValue(_jsonFactory.createGenerator(w), value);\n    }\n\n    \n    @SuppressWarnings(\"resource\")\n    public String writeValueAsString(Object value) throws JsonProcessingException {\n        \n        SegmentedStringWriter sw = new SegmentedStringWriter(_jsonFactory._getBufferRecycler());\n        try {\n            _configAndWriteValue(_jsonFactory.createGenerator(sw), value);\n        } catch (JsonProcessingException e) { \n            throw e;\n        } catch (IOException e) { \n            throw JsonMappingException.fromUnexpectedIOE(e);\n        }\n        return sw.getAndClear();\n    }\n    \n    \n    @SuppressWarnings(\"resource\")\n    public byte[] writeValueAsBytes(Object value) throws JsonProcessingException {\n        ByteArrayBuilder bb = new ByteArrayBuilder(_jsonFactory._getBufferRecycler());\n        try {\n            _configAndWriteValue(_jsonFactory.createGenerator(bb, JsonEncoding.UTF8), value);\n        } catch (JsonProcessingException e) { \n            throw e;\n        } catch (IOException e) { \n            throw JsonMappingException.fromUnexpectedIOE(e);\n        }\n        byte[] result = bb.toByteArray();\n        bb.release();\n        return result;\n    }\n\n    \n\n    \n    public ObjectWriter writer() {\n        return _newWriter(getSerializationConfig());\n    }\n\n    \n    public ObjectWriter writer(SerializationFeature feature) {\n        return _newWriter(getSerializationConfig().with(feature));\n    }\n\n    \n    public ObjectWriter writer(SerializationFeature first, SerializationFeature... other) {\n        return _newWriter(getSerializationConfig().with(first, other));\n    }\n    \n    \n    public ObjectWriter writer(DateFormat df) {\n        return _newWriter(getSerializationConfig().with(df));\n    }\n    \n    \n    public ObjectWriter writerWithView(Class<?> serializationView) {\n        return _newWriter(getSerializationConfig().withView(serializationView));\n    }\n    \n    \n    public ObjectWriter writerFor(Class<?> rootType) {\n        return _newWriter(getSerializationConfig(),\n                ((rootType == null) ? null :_typeFactory.constructType(rootType)),\n                null);\n    }\n\n    \n    public ObjectWriter writerFor(TypeReference<?> rootType) {\n        return _newWriter(getSerializationConfig(),\n                ((rootType == null) ? null : _typeFactory.constructType(rootType)),\n                null);\n    }\n\n    \n    public ObjectWriter writerFor(JavaType rootType) {\n        return _newWriter(getSerializationConfig(), rootType, null);\n    }\n\n    \n    public ObjectWriter writer(PrettyPrinter pp) {\n        if (pp == null) { \n            pp = ObjectWriter.NULL_PRETTY_PRINTER;\n        }\n        return _newWriter(getSerializationConfig(),  null, pp);\n    }\n    \n    \n    public ObjectWriter writerWithDefaultPrettyPrinter() {\n        SerializationConfig config = getSerializationConfig();\n        return _newWriter(config,\n                 null, config.getDefaultPrettyPrinter());\n    }\n    \n    \n    public ObjectWriter writer(FilterProvider filterProvider) {\n        return _newWriter(getSerializationConfig().withFilters(filterProvider));\n    }\n    \n    \n    public ObjectWriter writer(FormatSchema schema) {\n        _verifySchemaType(schema);\n        return _newWriter(getSerializationConfig(), schema);\n    }\n\n    \n    public ObjectWriter writer(Base64Variant defaultBase64) {\n        return _newWriter(getSerializationConfig().with(defaultBase64));\n    }\n\n    \n    public ObjectWriter writer(CharacterEscapes escapes) {\n        return _newWriter(getSerializationConfig()).with(escapes);\n    }\n\n    \n    public ObjectWriter writer(ContextAttributes attrs) {\n        return _newWriter(getSerializationConfig().with(attrs));\n    }\n\n    \n    @Deprecated\n    public ObjectWriter writerWithType(Class<?> rootType) {\n        return _newWriter(getSerializationConfig(),\n                \n                ((rootType == null) ? null :_typeFactory.constructType(rootType)),\n                null);\n    }\n\n    \n    @Deprecated\n    public ObjectWriter writerWithType(TypeReference<?> rootType) {\n        return _newWriter(getSerializationConfig(),\n                \n                ((rootType == null) ? null : _typeFactory.constructType(rootType)),\n                null);\n    }\n\n    \n    @Deprecated\n    public ObjectWriter writerWithType(JavaType rootType) {\n        return _newWriter(getSerializationConfig(), rootType, null);\n    }\n    \n    \n\n    \n    public ObjectReader reader() {\n        return _newReader(getDeserializationConfig()).with(_injectableValues);\n    }\n\n    \n    public ObjectReader reader(DeserializationFeature feature) {\n        return _newReader(getDeserializationConfig().with(feature));\n    }\n\n    \n    public ObjectReader reader(DeserializationFeature first, DeserializationFeature... other) {\n        return _newReader(getDeserializationConfig().with(first, other));\n    }\n    \n    \n    public ObjectReader readerForUpdating(Object valueToUpdate) {\n        JavaType t = _typeFactory.constructType(valueToUpdate.getClass());\n        return _newReader(getDeserializationConfig(), t, valueToUpdate,\n                null, _injectableValues);\n    }\n\n    \n    public ObjectReader readerFor(JavaType type) {\n        return _newReader(getDeserializationConfig(), type, null,\n                null, _injectableValues);\n    }\n\n    \n    public ObjectReader readerFor(Class<?> type) {\n        return _newReader(getDeserializationConfig(), _typeFactory.constructType(type), null,\n                null, _injectableValues);\n    }\n\n    \n    public ObjectReader readerFor(TypeReference<?> type) {\n        return _newReader(getDeserializationConfig(), _typeFactory.constructType(type), null,\n                null, _injectableValues);\n    }\n\n    \n    public ObjectReader reader(JsonNodeFactory f) {\n        return _newReader(getDeserializationConfig()).with(f);\n    }\n\n    \n    public ObjectReader reader(FormatSchema schema) {\n        _verifySchemaType(schema);\n        return _newReader(getDeserializationConfig(), null, null,\n                schema, _injectableValues);\n    }\n\n    \n    public ObjectReader reader(InjectableValues injectableValues) {\n        return _newReader(getDeserializationConfig(), null, null,\n                null, injectableValues);\n    }\n\n    \n    public ObjectReader readerWithView(Class<?> view) {\n        return _newReader(getDeserializationConfig().withView(view));\n    }\n\n    \n    public ObjectReader reader(Base64Variant defaultBase64) {\n        return _newReader(getDeserializationConfig().with(defaultBase64));\n    }\n\n    \n    public ObjectReader reader(ContextAttributes attrs) {\n        return _newReader(getDeserializationConfig().with(attrs));\n    }\n\n    \n    @Deprecated\n    public ObjectReader reader(JavaType type) {\n        return _newReader(getDeserializationConfig(), type, null,\n                null, _injectableValues);\n    }\n\n    \n    @Deprecated\n    public ObjectReader reader(Class<?> type) {\n        return _newReader(getDeserializationConfig(), _typeFactory.constructType(type), null,\n                null, _injectableValues);\n    }\n\n    \n    @Deprecated\n    public ObjectReader reader(TypeReference<?> type) {\n        return _newReader(getDeserializationConfig(), _typeFactory.constructType(type), null,\n                null, _injectableValues);\n    }\n\n    \n\n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T convertValue(Object fromValue, Class<T> toValueType) throws IllegalArgumentException {\n        \n        if (fromValue == null) return null;\n        return (T) _convert(fromValue, _typeFactory.constructType(toValueType));\n    } \n\n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T convertValue(Object fromValue, TypeReference<?> toValueTypeRef) throws IllegalArgumentException {\n        return (T) convertValue(fromValue, _typeFactory.constructType(toValueTypeRef));\n    } \n\n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T convertValue(Object fromValue, JavaType toValueType) throws IllegalArgumentException {\n        \n        if (fromValue == null) return null;\n        return (T) _convert(fromValue, toValueType);\n    } \n\n    \n    @SuppressWarnings(\"resource\")\n    protected Object _convert(Object fromValue, JavaType toValueType) throws IllegalArgumentException {        \n        \n        \n        Class<?> targetType = toValueType.getRawClass();\n        if (targetType != Object.class\n                && !toValueType.hasGenericTypes()\n                && targetType.isAssignableFrom(fromValue.getClass())) {\n            return fromValue;\n        }\n        \n        \n        TokenBuffer buf = new TokenBuffer(this, false);\n        if (isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n            buf = buf.forceUseOfBigDecimal(true);\n        }\n        try {\n            \n            \n            SerializationConfig config = getSerializationConfig().without(SerializationFeature.WRAP_ROOT_VALUE);\n            \n            _serializerProvider(config).serializeValue(buf, fromValue);\n\n            \n            final JsonParser p = buf.asParser();\n            Object result;\n            \n            final DeserializationConfig deserConfig = getDeserializationConfig();\n            JsonToken t = _initForReading(p);\n            if (t == JsonToken.VALUE_NULL) {\n                DeserializationContext ctxt = createDeserializationContext(p, deserConfig);\n                result = _findRootDeserializer(ctxt, toValueType).getNullValue(ctxt);\n            } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {\n                result = null;\n            } else { \n                DeserializationContext ctxt = createDeserializationContext(p, deserConfig);\n                JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, toValueType);\n                \n                result = deser.deserialize(p, ctxt);\n            }\n            p.close();\n            return result;\n        } catch (IOException e) { \n            throw new IllegalArgumentException(e.getMessage(), e);\n        }\n    }\n\n    \n\n    \n    @Deprecated\n    public com.fasterxml.jackson.databind.jsonschema.JsonSchema generateJsonSchema(Class<?> t) throws JsonMappingException {\n        return _serializerProvider(getSerializationConfig()).generateJsonSchema(t);\n    }\n\n    \n    public void acceptJsonFormatVisitor(Class<?> type, JsonFormatVisitorWrapper visitor) throws JsonMappingException {\n        acceptJsonFormatVisitor(_typeFactory.constructType(type), visitor);\n    }\n    \n    \n    public void acceptJsonFormatVisitor(JavaType type, JsonFormatVisitorWrapper visitor) throws JsonMappingException {\n        if (type == null) {\n            throw new IllegalArgumentException(\"type must be provided\");\n        }\n        _serializerProvider(getSerializationConfig()).acceptJsonFormatVisitor(type, visitor);\n    }\n    \n    \n\n    \n    protected DefaultSerializerProvider _serializerProvider(SerializationConfig config) {\n        return _serializerProvider.createInstance(config, _serializerFactory);\n    }\n\n    \n    protected final void _configAndWriteValue(JsonGenerator g, Object value) throws IOException {\n        SerializationConfig cfg = getSerializationConfig();\n        cfg.initialize(g); \n        if (cfg.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) {\n            _configAndWriteCloseable(g, value, cfg);\n            return;\n        }\n        try {\n            _serializerProvider(cfg).serializeValue(g, value);\n        } catch (Exception e) {\n            ClassUtil.closeOnFailAndThrowAsIAE(g, e);\n            return;\n        }\n        g.close();\n    }\n\n    \n    private final void _configAndWriteCloseable(JsonGenerator g, Object value, SerializationConfig cfg) throws IOException {\n        Closeable toClose = (Closeable) value;\n        try {\n            _serializerProvider(cfg).serializeValue(g, value);\n            Closeable tmpToClose = toClose;\n            toClose = null;\n            tmpToClose.close();\n        } catch (Exception e) {\n            ClassUtil.closeOnFailAndThrowAsIAE(g, toClose, e);\n            return;\n        }\n        g.close();\n    }\n\n    \n    private final void _writeCloseableValue(JsonGenerator g, Object value, SerializationConfig cfg) throws IOException {\n        Closeable toClose = (Closeable) value;\n        try {\n            _serializerProvider(cfg).serializeValue(g, value);\n            if (cfg.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) {\n                g.flush();\n            }\n        } catch (Exception e) {\n            ClassUtil.closeOnFailAndThrowAsIAE(null, toClose, e);\n            return;\n        }\n        toClose.close();\n    }\n\n    \n\n    \n    protected DefaultDeserializationContext createDeserializationContext(JsonParser p, DeserializationConfig cfg) {\n        return _deserializationContext.createInstance(cfg, p, _injectableValues);\n    }\n    \n    \n    protected Object _readValue(DeserializationConfig cfg, JsonParser p, JavaType valueType) throws IOException {\n        \n        Object result;\n        JsonToken t = _initForReading(p);\n        if (t == JsonToken.VALUE_NULL) {\n            \n            DeserializationContext ctxt = createDeserializationContext(p, cfg);\n            result = _findRootDeserializer(ctxt, valueType).getNullValue(ctxt);\n        } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {\n            result = null;\n        } else { \n            DeserializationContext ctxt = createDeserializationContext(p, cfg);\n            JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, valueType);\n            \n            if (cfg.useRootWrapping()) {\n                result = _unwrapAndDeserialize(p, ctxt, cfg, valueType, deser);\n            } else {\n                result = deser.deserialize(p, ctxt);\n            }\n        }\n        \n        p.clearCurrentToken();\n        return result;\n    }\n    \n    protected Object _readMapAndClose(JsonParser p0, JavaType valueType) throws IOException {\n        try (JsonParser p = p0) {\n            Object result;\n            JsonToken t = _initForReading(p);\n            if (t == JsonToken.VALUE_NULL) {\n                \n                DeserializationContext ctxt = createDeserializationContext(p,\n                        getDeserializationConfig());\n                result = _findRootDeserializer(ctxt, valueType).getNullValue(ctxt);\n            } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {\n                result = null;\n            } else {\n                DeserializationConfig cfg = getDeserializationConfig();\n                DeserializationContext ctxt = createDeserializationContext(p, cfg);\n                JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, valueType);\n                if (cfg.useRootWrapping()) {\n                    result = _unwrapAndDeserialize(p, ctxt, cfg, valueType, deser);\n                } else {\n                    result = deser.deserialize(p, ctxt);\n                }\n                ctxt.checkUnresolvedObjectId();\n            }\n            \n            p.clearCurrentToken();\n            return result;\n        }\n    }\n\n    \n    protected JsonToken _initForReading(JsonParser p) throws IOException {\n        _deserializationConfig.initialize(p); \n\n        \n        JsonToken t = p.getCurrentToken();\n        if (t == null) {\n            \n            t = p.nextToken();\n            if (t == null) {\n                \n                \n                throw JsonMappingException.from(p, \"No content to map due to end-of-input\");\n            }\n        }\n        return t;\n    }\n\n    protected Object _unwrapAndDeserialize(JsonParser p, DeserializationContext ctxt, DeserializationConfig config, JavaType rootType, JsonDeserializer<Object> deser) throws IOException {\n        PropertyName expRootName = config.findRootName(rootType);\n        \n        String expSimpleName = expRootName.getSimpleName();\n        if (p.getCurrentToken() != JsonToken.START_OBJECT) {\n            ctxt.reportWrongTokenException(p, JsonToken.START_OBJECT,\n                    \"Current token not START_OBJECT (needed to unwrap root name '%s'), but %s\",\n                    expSimpleName, p.getCurrentToken());\n            \n        }\n        if (p.nextToken() != JsonToken.FIELD_NAME) {\n            ctxt.reportWrongTokenException(p, JsonToken.FIELD_NAME,\n                    \"Current token not FIELD_NAME (to contain expected root name '\"\n                    +expSimpleName+\"'), but \"+p.getCurrentToken());\n        }\n        String actualName = p.getCurrentName();\n        if (!expSimpleName.equals(actualName)) {\n            ctxt.reportMappingException(\"Root name '%s' does not match expected ('%s') for type %s\",\n                    actualName, expSimpleName, rootType);\n        }\n        \n        p.nextToken();\n        Object result = deser.deserialize(p, ctxt);\n        \n        if (p.nextToken() != JsonToken.END_OBJECT) {\n            ctxt.reportWrongTokenException(p, JsonToken.END_OBJECT,\n                    \"Current token not END_OBJECT (to match wrapper object with root name '%s'), but %s\",\n                    expSimpleName, p.getCurrentToken());\n        }\n        return result;\n    }\n    \n    \n\n    \n    protected JsonDeserializer<Object> _findRootDeserializer(DeserializationContext ctxt, JavaType valueType) throws JsonMappingException {\n        \n        JsonDeserializer<Object> deser = _rootDeserializers.get(valueType);\n        if (deser != null) {\n            return deser;\n        }\n        \n        deser = ctxt.findRootValueDeserializer(valueType);\n        if (deser == null) { \n            throw JsonMappingException.from(ctxt,\n                    \"Can not find a deserializer for type \"+valueType);\n        }\n        _rootDeserializers.put(valueType, deser);\n        return deser;\n    }\n\n    \n    protected void _verifySchemaType(FormatSchema schema) {\n        if (schema != null) {\n            if (!_jsonFactory.canUseSchema(schema)) {\n                    throw new IllegalArgumentException(\"Can not use FormatSchema of type \"+schema.getClass().getName()\n                            +\" for format \"+_jsonFactory.getFormatName());\n            }\n        }\n    }\n}\n",
      "fixed_full_code": "package com.fasterxml.jackson.databind;\n\nimport java.io.*;\nimport java.lang.reflect.Type;\nimport java.net.URL;\nimport java.text.DateFormat;\nimport java.util.*;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport com.fasterxml.jackson.annotation.*;\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.io.CharacterEscapes;\nimport com.fasterxml.jackson.core.io.SegmentedStringWriter;\nimport com.fasterxml.jackson.core.type.ResolvedType;\nimport com.fasterxml.jackson.core.type.TypeReference;\nimport com.fasterxml.jackson.core.util.*;\nimport com.fasterxml.jackson.databind.cfg.BaseSettings;\nimport com.fasterxml.jackson.databind.cfg.ContextAttributes;\nimport com.fasterxml.jackson.databind.cfg.HandlerInstantiator;\nimport com.fasterxml.jackson.databind.cfg.MapperConfig;\nimport com.fasterxml.jackson.databind.cfg.MutableConfigOverride;\nimport com.fasterxml.jackson.databind.cfg.ConfigOverrides;\nimport com.fasterxml.jackson.databind.deser.*;\nimport com.fasterxml.jackson.databind.introspect.*;\nimport com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\nimport com.fasterxml.jackson.databind.jsontype.*;\nimport com.fasterxml.jackson.databind.jsontype.impl.StdSubtypeResolver;\nimport com.fasterxml.jackson.databind.jsontype.impl.StdTypeResolverBuilder;\nimport com.fasterxml.jackson.databind.node.*;\nimport com.fasterxml.jackson.databind.ser.*;\nimport com.fasterxml.jackson.databind.type.*;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\nimport com.fasterxml.jackson.databind.util.RootNameLookup;\nimport com.fasterxml.jackson.databind.util.StdDateFormat;\nimport com.fasterxml.jackson.databind.util.TokenBuffer;\n\n\npublic class ObjectMapper extends ObjectCodec implements Versioned, java.io.Serializable { private static final long serialVersionUID = 1L; public enum DefaultTyping { JAVA_LANG_OBJECT, OBJECT_AND_NON_CONCRETE, NON_CONCRETE_AND_ARRAYS, NON_FINAL } public static class DefaultTypeResolverBuilder extends StdTypeResolverBuilder implements java.io.Serializable { private static final long serialVersionUID = 1L; protected final DefaultTyping _appliesFor; public DefaultTypeResolverBuilder(DefaultTyping t) {\n            _appliesFor = t;\n        }\n\n        @Override\n        public TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes) {\n            return useForType(baseType) ? super.buildTypeDeserializer(config, baseType, subtypes) : null;\n        }\n\n        @Override\n        public TypeSerializer buildTypeSerializer(SerializationConfig config, JavaType baseType, Collection<NamedType> subtypes) {\n            return useForType(baseType) ? super.buildTypeSerializer(config, baseType, subtypes) : null;            \n        }\n\n        \n        public boolean useForType(JavaType t) {\n            \n            \n            if (t.isPrimitive()) {\n                return false;\n            }\n\n            switch (_appliesFor) {\n            case NON_CONCRETE_AND_ARRAYS:\n                while (t.isArrayType()) {\n                    t = t.getContentType();\n                }\n                \n            case OBJECT_AND_NON_CONCRETE:\n                \n                while (t.isReferenceType()) {\n                    t = t.getReferencedType();\n                }\n                return t.isJavaLangObject()\n                        || (!t.isConcrete()\n                                \n                                && !TreeNode.class.isAssignableFrom(t.getRawClass()));\n\n            case NON_FINAL:\n                while (t.isArrayType()) {\n                    t = t.getContentType();\n                }\n                \n                while (t.isReferenceType()) {\n                    t = t.getReferencedType();\n                }\n                \n                return !t.isFinal() && !TreeNode.class.isAssignableFrom(t.getRawClass());\n            default:\n            \n                return t.isJavaLangObject();\n            }\n        }\n    }\n\n    \n    \n    \n    \n    \n    private final static JavaType JSON_NODE_TYPE = SimpleType.constructUnsafe(JsonNode.class); protected final static AnnotationIntrospector DEFAULT_ANNOTATION_INTROSPECTOR = new JacksonAnnotationIntrospector(); protected final static VisibilityChecker<?> STD_VISIBILITY_CHECKER = VisibilityChecker.Std.defaultInstance(); protected final static BaseSettings DEFAULT_BASE = new BaseSettings( null, DEFAULT_ANNOTATION_INTROSPECTOR, STD_VISIBILITY_CHECKER, null, TypeFactory.defaultInstance(), null, StdDateFormat.instance, null, Locale.getDefault(), null, Base64Variants.getDefaultVariant() ); protected final JsonFactory _jsonFactory; protected TypeFactory _typeFactory; protected InjectableValues _injectableValues; protected SubtypeResolver _subtypeResolver; protected ConfigOverrides _propertyOverrides; protected SimpleMixInResolver _mixIns; protected SerializationConfig _serializationConfig; protected DefaultSerializerProvider _serializerProvider; protected SerializerFactory _serializerFactory; protected DeserializationConfig _deserializationConfig; protected DefaultDeserializationContext _deserializationContext; protected Set<Object> _registeredModuleTypes; final protected ConcurrentHashMap<JavaType, JsonDeserializer<Object>> _rootDeserializers = new ConcurrentHashMap<JavaType, JsonDeserializer<Object>>(64, 0.6f, 2); public ObjectMapper() {\n        this(null, null, null);\n    }\n\n    \n    public ObjectMapper(JsonFactory jf) {\n        this(jf, null, null);\n    }\n\n    \n    protected ObjectMapper(ObjectMapper src) {\n        _jsonFactory = src._jsonFactory.copy();\n        _jsonFactory.setCodec(this);\n        _subtypeResolver = src._subtypeResolver;\n        _typeFactory = src._typeFactory;\n        _injectableValues = src._injectableValues;\n        _propertyOverrides = src._propertyOverrides.copy();\n        _mixIns = src._mixIns.copy();\n\n        RootNameLookup rootNames = new RootNameLookup();\n        _serializationConfig = new SerializationConfig(src._serializationConfig, _mixIns, rootNames, _propertyOverrides);\n        _deserializationConfig = new DeserializationConfig(src._deserializationConfig, _mixIns, rootNames, _propertyOverrides);\n        _serializerProvider = src._serializerProvider.copy();\n        _deserializationContext = src._deserializationContext.copy();\n\n        \n        _serializerFactory = src._serializerFactory;\n\n        \n        Set<Object> reg = src._registeredModuleTypes;\n        if (reg == null) {\n            _registeredModuleTypes = null;\n        } else {\n            _registeredModuleTypes = new LinkedHashSet<Object>(reg);\n        }\n    }\n\n    \n    public ObjectMapper(JsonFactory jf, DefaultSerializerProvider sp, DefaultDeserializationContext dc) {\n        \n        if (jf == null) {\n            _jsonFactory = new MappingJsonFactory(this);\n        } else {\n            _jsonFactory = jf;\n            if (jf.getCodec() == null) { \n                _jsonFactory.setCodec(this);\n            }\n        }\n        _subtypeResolver = new StdSubtypeResolver();\n        RootNameLookup rootNames = new RootNameLookup();\n        \n        _typeFactory = TypeFactory.defaultInstance();\n\n        SimpleMixInResolver mixins = new SimpleMixInResolver(null);\n        _mixIns = mixins;\n        BaseSettings base = DEFAULT_BASE.withClassIntrospector(defaultClassIntrospector());\n        ConfigOverrides propOverrides = new ConfigOverrides();\n        _propertyOverrides = propOverrides;\n        _serializationConfig = new SerializationConfig(base,\n                    _subtypeResolver, mixins, rootNames, propOverrides);\n        _deserializationConfig = new DeserializationConfig(base,\n                    _subtypeResolver, mixins, rootNames, propOverrides);\n\n        \n        final boolean needOrder = _jsonFactory.requiresPropertyOrdering();\n        if (needOrder ^ _serializationConfig.isEnabled(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY)) {\n            configure(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY, needOrder);\n        }\n        \n        _serializerProvider = (sp == null) ? new DefaultSerializerProvider.Impl() : sp;\n        _deserializationContext = (dc == null) ?\n                new DefaultDeserializationContext.Impl(BeanDeserializerFactory.instance) : dc;\n\n        \n        _serializerFactory = BeanSerializerFactory.instance;\n    }\n\n    \n    protected ClassIntrospector defaultClassIntrospector() {\n        return new BasicClassIntrospector();\n    }\n\n    \n    \n    \n    public ObjectMapper copy() {\n        _checkInvalidCopy(ObjectMapper.class);\n        return new ObjectMapper(this);\n    }\n\n    \n    protected void _checkInvalidCopy(Class<?> exp) {\n        if (getClass() != exp) {\n            throw new IllegalStateException(\"Failed copy(): \"+getClass().getName()\n                    +\" (version: \"+version()+\") does not override copy(); it has to\");\n        }\n    }\n\n    \n    \n    \n    protected ObjectReader _newReader(DeserializationConfig config) {\n        return new ObjectReader(this, config);\n    }\n\n    \n    protected ObjectReader _newReader(DeserializationConfig config, JavaType valueType, Object valueToUpdate, FormatSchema schema, InjectableValues injectableValues) {\n        return new ObjectReader(this, config, valueType, valueToUpdate, schema, injectableValues);\n    }\n\n    \n    protected ObjectWriter _newWriter(SerializationConfig config) {\n        return new ObjectWriter(this, config);\n    }\n\n    \n    protected ObjectWriter _newWriter(SerializationConfig config, FormatSchema schema) {\n        return new ObjectWriter(this, config, schema);\n    }\n    \n    \n    protected ObjectWriter _newWriter(SerializationConfig config, JavaType rootType, PrettyPrinter pp) {\n        return new ObjectWriter(this, config, rootType, pp);\n    }\n\n    \n    \n    \n    @Override\n    public Version version() {\n        return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION;\n    }\n\n    \n\n    \n    public ObjectMapper registerModule(Module module) {\n        if (isEnabled(MapperFeature.IGNORE_DUPLICATE_MODULE_REGISTRATIONS)) {\n            Object typeId = module.getTypeId();\n            if (typeId != null) {\n                if (_registeredModuleTypes == null) {\n                    \n                    \n                    _registeredModuleTypes = new LinkedHashSet<Object>();\n                }\n                \n                if (!_registeredModuleTypes.add(typeId)) {\n                    return this;\n                }\n            }\n        }\n        \n        \n        String name = module.getModuleName();\n        if (name == null) {\n            throw new IllegalArgumentException(\"Module without defined name\");\n        }\n        Version version = module.version();\n        if (version == null) {\n            throw new IllegalArgumentException(\"Module without defined version\");\n        }\n\n        final ObjectMapper mapper = this;\n        \n        \n        module.setupModule(new Module.SetupContext()\n        {\n            \n\n            @Override\n            public Version getMapperVersion() {\n                return version();\n            }\n\n            @SuppressWarnings(\"unchecked\")\n            @Override\n            public <C extends ObjectCodec> C getOwner() {\n                \n                return (C) mapper;\n            }\n\n            @Override\n            public TypeFactory getTypeFactory() {\n                return _typeFactory;\n            }\n            \n            @Override\n            public boolean isEnabled(MapperFeature f) {\n                return mapper.isEnabled(f);\n            }\n\n            @Override\n            public boolean isEnabled(DeserializationFeature f) {\n                return mapper.isEnabled(f);\n            }\n            \n            @Override\n            public boolean isEnabled(SerializationFeature f) {\n                return mapper.isEnabled(f);\n            }\n\n            @Override\n            public boolean isEnabled(JsonFactory.Feature f) {\n                return mapper.isEnabled(f);\n            }\n\n            @Override\n            public boolean isEnabled(JsonParser.Feature f) {\n                return mapper.isEnabled(f);\n            }\n\n            @Override\n            public boolean isEnabled(JsonGenerator.Feature f) {\n                return mapper.isEnabled(f);\n            }\n\n            \n\n            @Override\n            public MutableConfigOverride configOverride(Class<?> type) {\n                return mapper.configOverride(type);\n            }\n\n            \n\n            @Override\n            public void addDeserializers(Deserializers d) {\n                DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalDeserializers(d);\n                mapper._deserializationContext = mapper._deserializationContext.with(df);\n            }\n\n            @Override\n            public void addKeyDeserializers(KeyDeserializers d) {\n                DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalKeyDeserializers(d);\n                mapper._deserializationContext = mapper._deserializationContext.with(df);\n            }\n\n            @Override\n            public void addBeanDeserializerModifier(BeanDeserializerModifier modifier) {\n                DeserializerFactory df = mapper._deserializationContext._factory.withDeserializerModifier(modifier);\n                mapper._deserializationContext = mapper._deserializationContext.with(df);\n            }\n            \n            \n            \n            @Override\n            public void addSerializers(Serializers s) {\n                mapper._serializerFactory = mapper._serializerFactory.withAdditionalSerializers(s);\n            }\n\n            @Override\n            public void addKeySerializers(Serializers s) {\n                mapper._serializerFactory = mapper._serializerFactory.withAdditionalKeySerializers(s);\n            }\n            \n            @Override\n            public void addBeanSerializerModifier(BeanSerializerModifier modifier) {\n                mapper._serializerFactory = mapper._serializerFactory.withSerializerModifier(modifier);\n            }\n\n            \n            \n            @Override\n            public void addAbstractTypeResolver(AbstractTypeResolver resolver) {\n                DeserializerFactory df = mapper._deserializationContext._factory.withAbstractTypeResolver(resolver);\n                mapper._deserializationContext = mapper._deserializationContext.with(df);\n            }\n\n            @Override\n            public void addTypeModifier(TypeModifier modifier) {\n                TypeFactory f = mapper._typeFactory;\n                f = f.withModifier(modifier);\n                mapper.setTypeFactory(f);\n            }\n\n            @Override\n            public void addValueInstantiators(ValueInstantiators instantiators) {\n                DeserializerFactory df = mapper._deserializationContext._factory.withValueInstantiators(instantiators);\n                mapper._deserializationContext = mapper._deserializationContext.with(df);\n            }\n\n            @Override\n            public void setClassIntrospector(ClassIntrospector ci) {\n                mapper._deserializationConfig = mapper._deserializationConfig.with(ci);\n                mapper._serializationConfig = mapper._serializationConfig.with(ci);\n            }\n\n            @Override\n            public void insertAnnotationIntrospector(AnnotationIntrospector ai) {\n                mapper._deserializationConfig = mapper._deserializationConfig.withInsertedAnnotationIntrospector(ai);\n                mapper._serializationConfig = mapper._serializationConfig.withInsertedAnnotationIntrospector(ai);\n            }\n            \n            @Override\n            public void appendAnnotationIntrospector(AnnotationIntrospector ai) {\n                mapper._deserializationConfig = mapper._deserializationConfig.withAppendedAnnotationIntrospector(ai);\n                mapper._serializationConfig = mapper._serializationConfig.withAppendedAnnotationIntrospector(ai);\n            }\n\n            @Override\n            public void registerSubtypes(Class<?>... subtypes) {\n                mapper.registerSubtypes(subtypes);\n            }\n\n            @Override\n            public void registerSubtypes(NamedType... subtypes) {\n                mapper.registerSubtypes(subtypes);\n            }\n            \n            @Override\n            public void setMixInAnnotations(Class<?> target, Class<?> mixinSource) {\n                mapper.addMixIn(target, mixinSource);\n            }\n            \n            @Override\n            public void addDeserializationProblemHandler(DeserializationProblemHandler handler) {\n                mapper.addHandler(handler);\n            }\n\n            @Override\n            public void setNamingStrategy(PropertyNamingStrategy naming) {\n                mapper.setPropertyNamingStrategy(naming);\n            }\n        });\n        return this;\n    }\n\n    \n    public ObjectMapper registerModules(Module... modules) {\n        for (Module module : modules) {\n            registerModule(module);\n        }\n        return this;\n    }\n\n    \n    public ObjectMapper registerModules(Iterable<com.fasterxml.jackson.databind.Module> modules) {\n        for (Module module : modules) {\n            registerModule(module);\n        }\n        return this;\n    }\n    \n    \n    public static List<com.fasterxml.jackson.databind.Module> findModules() {\n        return findModules(null);\n    }\n\n    \n    public static List<com.fasterxml.jackson.databind.Module> findModules(ClassLoader classLoader) {\n        ArrayList<com.fasterxml.jackson.databind.Module> modules = new ArrayList<Module>();\n        ServiceLoader<com.fasterxml.jackson.databind.Module> loader = (classLoader == null) ?\n                ServiceLoader.load(Module.class) : ServiceLoader.load(Module.class, classLoader);\n        for (Module module : loader) {\n            modules.add(module);\n        }\n        return modules;\n    }\n\n    \n    public ObjectMapper findAndRegisterModules() {\n        return registerModules(findModules());\n    }\n\n    \n\n    \n    public SerializationConfig getSerializationConfig() {\n        return _serializationConfig;\n    }\n\n    \n    public DeserializationConfig getDeserializationConfig() {\n        return _deserializationConfig;\n    }\n    \n    \n    public DeserializationContext getDeserializationContext() {\n        return _deserializationContext;\n    }\n\n    \n    \n    \n    public ObjectMapper setSerializerFactory(SerializerFactory f) {\n        _serializerFactory = f;\n        return this;\n    }\n\n    \n    public SerializerFactory getSerializerFactory() {\n        return _serializerFactory;\n    }\n\n    \n    public ObjectMapper setSerializerProvider(DefaultSerializerProvider p) {\n        _serializerProvider = p;\n        return this;\n    }\n\n    \n    public SerializerProvider getSerializerProvider() {\n        return _serializerProvider;\n    }\n\n    \n    public SerializerProvider getSerializerProviderInstance() {\n        return _serializerProvider(_serializationConfig);\n    }\n\n    \n\n    \n    public ObjectMapper setMixIns(Map<Class<?>, Class<?>> sourceMixins) {\n        \n        _mixIns.setLocalDefinitions(sourceMixins);\n        return this;\n    }\n\n    \n    public ObjectMapper addMixIn(Class<?> target, Class<?> mixinSource) {\n        _mixIns.addLocalDefinition(target, mixinSource);\n        return this;\n    }\n\n    \n    public ObjectMapper setMixInResolver(ClassIntrospector.MixInResolver resolver) {\n        SimpleMixInResolver r = _mixIns.withOverrides(resolver);\n        if (r != _mixIns) {\n            _mixIns = r;\n            _deserializationConfig = new DeserializationConfig(_deserializationConfig, r);\n            _serializationConfig = new SerializationConfig(_serializationConfig, r);\n        }\n        return this;\n    }\n    \n    public Class<?> findMixInClassFor(Class<?> cls) {\n        return _mixIns.findMixInClassFor(cls);\n    }\n\n    \n    public int mixInCount() {\n        return _mixIns.localSize();\n    }\n\n    \n    @Deprecated\n    public void setMixInAnnotations(Map<Class<?>, Class<?>> sourceMixins) {\n        setMixIns(sourceMixins);\n    }\n\n    \n    @Deprecated\n    public final void addMixInAnnotations(Class<?> target, Class<?> mixinSource) {\n        addMixIn(target, mixinSource);\n    }\n    \n    \n\n    \n    public VisibilityChecker<?> getVisibilityChecker() {\n        return _serializationConfig.getDefaultVisibilityChecker();\n    }\n\n    \n    @Deprecated\n    public void setVisibilityChecker(VisibilityChecker<?> vc) {\n        setVisibility(vc);\n    }\n\n    \n    public ObjectMapper setVisibility(VisibilityChecker<?> vc) {\n        _deserializationConfig = _deserializationConfig.with(vc);\n        _serializationConfig = _serializationConfig.with(vc);\n        return this;\n    }\n    \n    \n    public ObjectMapper setVisibility(PropertyAccessor forMethod, JsonAutoDetect.Visibility visibility) {\n        _deserializationConfig = _deserializationConfig.withVisibility(forMethod, visibility);\n        _serializationConfig = _serializationConfig.withVisibility(forMethod, visibility);\n        return this;\n    }\n    \n    \n    public SubtypeResolver getSubtypeResolver() {\n        return _subtypeResolver;\n    }\n\n    \n    public ObjectMapper setSubtypeResolver(SubtypeResolver str) {\n        _subtypeResolver = str;\n        _deserializationConfig = _deserializationConfig.with(str);\n        _serializationConfig = _serializationConfig.with(str);\n        return this;\n    }\n\n    \n    public ObjectMapper setAnnotationIntrospector(AnnotationIntrospector ai) {\n        _serializationConfig = _serializationConfig.with(ai);\n        _deserializationConfig = _deserializationConfig.with(ai);\n        return this;\n    }\n\n    \n    public ObjectMapper setAnnotationIntrospectors(AnnotationIntrospector serializerAI, AnnotationIntrospector deserializerAI) {\n        _serializationConfig = _serializationConfig.with(serializerAI);\n        _deserializationConfig = _deserializationConfig.with(deserializerAI);\n        return this;\n    }\n    \n    \n    public ObjectMapper setPropertyNamingStrategy(PropertyNamingStrategy s) {\n        _serializationConfig = _serializationConfig.with(s);\n        _deserializationConfig = _deserializationConfig.with(s);\n        return this;\n    }\n\n    \n    public PropertyNamingStrategy getPropertyNamingStrategy() {\n        \n        return _serializationConfig.getPropertyNamingStrategy();\n    }\n\n    \n    public ObjectMapper setSerializationInclusion(JsonInclude.Include incl) {\n        setPropertyInclusion(JsonInclude.Value.construct(incl, JsonInclude.Include.USE_DEFAULTS));\n        return this;\n    }\n\n    \n    public ObjectMapper setPropertyInclusion(JsonInclude.Value incl) {\n        _serializationConfig = _serializationConfig.withPropertyInclusion(incl);\n        return this;\n    }\n\n    \n    public ObjectMapper setDefaultPrettyPrinter(PrettyPrinter pp) {\n        _serializationConfig = _serializationConfig.withDefaultPrettyPrinter(pp);\n        return this;\n    }\n\n    \n\n    \n    public ObjectMapper enableDefaultTyping() {\n        return enableDefaultTyping(DefaultTyping.OBJECT_AND_NON_CONCRETE);\n    }\n\n    \n    public ObjectMapper enableDefaultTyping(DefaultTyping dti) {\n        return enableDefaultTyping(dti, JsonTypeInfo.As.WRAPPER_ARRAY);\n    }\n\n    \n    public ObjectMapper enableDefaultTyping(DefaultTyping applicability, JsonTypeInfo.As includeAs) {\n        \n        if (includeAs == JsonTypeInfo.As.EXTERNAL_PROPERTY) {\n            throw new IllegalArgumentException(\"Can not use includeAs of \"+includeAs);\n        }\n        \n        TypeResolverBuilder<?> typer = new DefaultTypeResolverBuilder(applicability);\n        \n        typer = typer.init(JsonTypeInfo.Id.CLASS, null);\n        typer = typer.inclusion(includeAs);\n        return setDefaultTyping(typer);\n    }\n\n    \n    public ObjectMapper enableDefaultTypingAsProperty(DefaultTyping applicability, String propertyName) {\n        TypeResolverBuilder<?> typer = new DefaultTypeResolverBuilder(applicability);\n        \n        typer = typer.init(JsonTypeInfo.Id.CLASS, null);\n        typer = typer.inclusion(JsonTypeInfo.As.PROPERTY);\n        typer = typer.typeProperty(propertyName);\n        return setDefaultTyping(typer);\n    }\n    \n    \n    public ObjectMapper disableDefaultTyping() {\n        return setDefaultTyping(null);\n    }\n\n    \n    public ObjectMapper setDefaultTyping(TypeResolverBuilder<?> typer) {\n        _deserializationConfig = _deserializationConfig.with(typer);\n        _serializationConfig = _serializationConfig.with(typer);\n        return this;\n    }\n\n    \n    public void registerSubtypes(Class<?>... classes) {\n        getSubtypeResolver().registerSubtypes(classes);\n    }\n\n    \n    public void registerSubtypes(NamedType... types) {\n        getSubtypeResolver().registerSubtypes(types);\n    }\n\n    \n\n    \n    public MutableConfigOverride configOverride(Class<?> type) {\n        return _propertyOverrides.findOrCreateOverride(type);\n    }\n\n    \n\n    \n    public TypeFactory getTypeFactory() {\n        return _typeFactory;\n    }\n\n    \n    public ObjectMapper setTypeFactory(TypeFactory f) {\n        _typeFactory = f;\n        _deserializationConfig = _deserializationConfig.with(f);\n        _serializationConfig = _serializationConfig.with(f);\n        return this;\n    }\n    \n    \n    public JavaType constructType(Type t) {\n        return _typeFactory.constructType(t);\n    }\n    \n    \n\n    \n    public JsonNodeFactory getNodeFactory() {\n        return _deserializationConfig.getNodeFactory();\n    }\n    \n    \n    public ObjectMapper setNodeFactory(JsonNodeFactory f) {\n        _deserializationConfig = _deserializationConfig.with(f);\n        return this;\n    }\n\n    \n    public ObjectMapper addHandler(DeserializationProblemHandler h) {\n        _deserializationConfig = _deserializationConfig.withHandler(h);\n        return this;\n    }\n\n    \n    public ObjectMapper clearProblemHandlers() {\n        _deserializationConfig = _deserializationConfig.withNoProblemHandlers();\n        return this;\n    }\n\n    \n    public ObjectMapper setConfig(DeserializationConfig config) {\n        _deserializationConfig = config;\n        return this;\n    }\n\n    \n\n    \n    @Deprecated\n    public void setFilters(FilterProvider filterProvider) {\n        _serializationConfig = _serializationConfig.withFilters(filterProvider);\n    }\n\n    \n    public ObjectMapper setFilterProvider(FilterProvider filterProvider) {\n        _serializationConfig = _serializationConfig.withFilters(filterProvider);\n        return this;\n    }\n\n    \n    public ObjectMapper setBase64Variant(Base64Variant v) {\n        _serializationConfig = _serializationConfig.with(v);\n        _deserializationConfig = _deserializationConfig.with(v);\n        return this;\n    }\n\n    \n    public ObjectMapper setConfig(SerializationConfig config) {\n        _serializationConfig = config;\n        return this;\n    }\n    \n    \n\n    \n    @Override\n    public JsonFactory getFactory() { return _jsonFactory; }\n    \n    \n    @Deprecated\n    @Override\n    public JsonFactory getJsonFactory() { return getFactory(); }\n\n    \n    public ObjectMapper setDateFormat(DateFormat dateFormat) {\n        _deserializationConfig = _deserializationConfig.with(dateFormat);\n        _serializationConfig = _serializationConfig.with(dateFormat);\n        return this;\n    }\n\n    \n    public DateFormat getDateFormat() {\n        \n        return _serializationConfig.getDateFormat();\n    }\n    \n    \n    public Object setHandlerInstantiator(HandlerInstantiator hi) {\n        _deserializationConfig = _deserializationConfig.with(hi);\n        _serializationConfig = _serializationConfig.with(hi);\n        return this;\n    }\n    \n    \n    public ObjectMapper setInjectableValues(InjectableValues injectableValues) {\n        _injectableValues = injectableValues;\n        return this;\n    }\n\n    \n    public InjectableValues getInjectableValues() {\n        return _injectableValues;\n    }\n\n    \n    public ObjectMapper setLocale(Locale l) {\n        _deserializationConfig = _deserializationConfig.with(l);\n        _serializationConfig = _serializationConfig.with(l);\n        return this;\n    }\n\n    \n    public ObjectMapper setTimeZone(TimeZone tz) {\n        _deserializationConfig = _deserializationConfig.with(tz);\n        _serializationConfig = _serializationConfig.with(tz);\n        return this;\n    }\n    \n    \n\n    \n    public boolean isEnabled(MapperFeature f) {\n        \n        return _serializationConfig.isEnabled(f);\n    }\n    \n    \n    public ObjectMapper configure(MapperFeature f, boolean state) {\n        _serializationConfig = state ?\n                _serializationConfig.with(f) : _serializationConfig.without(f);\n        _deserializationConfig = state ?\n                _deserializationConfig.with(f) : _deserializationConfig.without(f);\n        return this;\n    }\n\n    \n    public ObjectMapper enable(MapperFeature... f) {\n        _deserializationConfig = _deserializationConfig.with(f);\n        _serializationConfig = _serializationConfig.with(f);\n        return this;\n    }\n\n    \n    public ObjectMapper disable(MapperFeature... f) {\n        _deserializationConfig = _deserializationConfig.without(f);\n        _serializationConfig = _serializationConfig.without(f);\n        return this;\n    }\n    \n    \n\n    \n    public boolean isEnabled(SerializationFeature f) {\n        return _serializationConfig.isEnabled(f);\n    }\n\n    \n    public ObjectMapper configure(SerializationFeature f, boolean state) {\n        _serializationConfig = state ?\n                _serializationConfig.with(f) : _serializationConfig.without(f);\n        return this;\n    }\n\n    \n    public ObjectMapper enable(SerializationFeature f) {\n        _serializationConfig = _serializationConfig.with(f);\n        return this;\n    }\n\n    \n    public ObjectMapper enable(SerializationFeature first, SerializationFeature... f) {\n        _serializationConfig = _serializationConfig.with(first, f);\n        return this;\n    }\n    \n    \n    public ObjectMapper disable(SerializationFeature f) {\n        _serializationConfig = _serializationConfig.without(f);\n        return this;\n    }\n\n    \n    public ObjectMapper disable(SerializationFeature first, SerializationFeature... f) {\n        _serializationConfig = _serializationConfig.without(first, f);\n        return this;\n    }\n    \n    \n\n    \n    public boolean isEnabled(DeserializationFeature f) {\n        return _deserializationConfig.isEnabled(f);\n    }\n\n    \n    public ObjectMapper configure(DeserializationFeature f, boolean state) {\n        _deserializationConfig = state ?\n                _deserializationConfig.with(f) : _deserializationConfig.without(f);\n        return this;\n    }\n\n    \n    public ObjectMapper enable(DeserializationFeature feature) {\n        _deserializationConfig = _deserializationConfig.with(feature);\n        return this;\n    }\n\n    \n    public ObjectMapper enable(DeserializationFeature first, DeserializationFeature... f) {\n        _deserializationConfig = _deserializationConfig.with(first, f);\n        return this;\n    }\n    \n    \n    public ObjectMapper disable(DeserializationFeature feature) {\n        _deserializationConfig = _deserializationConfig.without(feature);\n        return this;\n    }\n\n    \n    public ObjectMapper disable(DeserializationFeature first, DeserializationFeature... f) {\n        _deserializationConfig = _deserializationConfig.without(first, f);\n        return this;\n    }\n    \n    \n\n    public boolean isEnabled(JsonParser.Feature f) {\n        return _deserializationConfig.isEnabled(f, _jsonFactory);\n    }\n\n    \n    public ObjectMapper configure(JsonParser.Feature f, boolean state) {\n        _jsonFactory.configure(f, state);\n        return this;\n    }\n\n    \n    public ObjectMapper enable(JsonParser.Feature... features) {\n        for (JsonParser.Feature f : features) {\n            _jsonFactory.enable(f);\n        }\n        return this;\n    }\n    \n    \n    public ObjectMapper disable(JsonParser.Feature... features) {\n        for (JsonParser.Feature f : features) {\n            _jsonFactory.disable(f);\n        }\n        return this;\n    }\n    \n    \n\n    public boolean isEnabled(JsonGenerator.Feature f) {\n        return _serializationConfig.isEnabled(f, _jsonFactory);\n    }\n\n    \n    public ObjectMapper configure(JsonGenerator.Feature f, boolean state) {\n        _jsonFactory.configure(f,  state);\n        return this;\n    }\n\n    \n    public ObjectMapper enable(JsonGenerator.Feature... features) {\n        for (JsonGenerator.Feature f : features) {\n            _jsonFactory.enable(f);\n        }\n        return this;\n    }\n\n    \n    public ObjectMapper disable(JsonGenerator.Feature... features) {\n        for (JsonGenerator.Feature f : features) {\n            _jsonFactory.disable(f);\n        }\n        return this;\n    }\n\n    \n    \n    \n    public boolean isEnabled(JsonFactory.Feature f) {\n        return _jsonFactory.isEnabled(f);\n    }\n\n    \n\n    \n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(JsonParser p, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readValue(getDeserializationConfig(), p, _typeFactory.constructType(valueType));\n    } \n\n    \n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(JsonParser p, TypeReference<?> valueTypeRef) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readValue(getDeserializationConfig(), p, _typeFactory.constructType(valueTypeRef));\n    }\n\n    \n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public final <T> T readValue(JsonParser p, ResolvedType valueType) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readValue(getDeserializationConfig(), p, (JavaType) valueType);\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(JsonParser p, JavaType valueType) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readValue(getDeserializationConfig(), p, valueType);\n    }\n    \n    \n    @Override\n    public <T extends TreeNode> T readTree(JsonParser p) throws IOException, JsonProcessingException {\n        \n        \n        DeserializationConfig cfg = getDeserializationConfig();\n        JsonToken t = p.getCurrentToken();\n        if (t == null) {\n            t = p.nextToken();\n            if (t == null) {\n                return null;\n            }\n        }\n        JsonNode n = (JsonNode) _readValue(cfg, p, JSON_NODE_TYPE);\n        if (n == null) {\n            n = getNodeFactory().nullNode();\n        }\n        @SuppressWarnings(\"unchecked\")\n        T result = (T) n;\n        return result;\n    }\n\n    \n    @Override\n    public <T> MappingIterator<T> readValues(JsonParser p, ResolvedType valueType) throws IOException, JsonProcessingException {\n        return readValues(p, (JavaType) valueType);\n    }\n\n    \n    public <T> MappingIterator<T> readValues(JsonParser p, JavaType valueType) throws IOException, JsonProcessingException {\n        DeserializationConfig config = getDeserializationConfig();\n        DeserializationContext ctxt = createDeserializationContext(p, config);\n        JsonDeserializer<?> deser = _findRootDeserializer(ctxt, valueType);\n        \n        return new MappingIterator<T>(valueType, p, ctxt, deser,\n                false, null);\n    }\n\n    \n    @Override\n    public <T> MappingIterator<T> readValues(JsonParser p, Class<T> valueType) throws IOException, JsonProcessingException {\n        return readValues(p, _typeFactory.constructType(valueType));\n    }\n\n    \n    @Override\n    public <T> MappingIterator<T> readValues(JsonParser p, TypeReference<?> valueTypeRef) throws IOException, JsonProcessingException {\n        return readValues(p, _typeFactory.constructType(valueTypeRef));\n    }\n    \n    \n\n    \n    public JsonNode readTree(InputStream in) throws IOException, JsonProcessingException {\n        JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(in), JSON_NODE_TYPE);\n        return (n == null) ? NullNode.instance : n;\n    }\n\n    \n    public JsonNode readTree(Reader r) throws IOException, JsonProcessingException {\n        JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(r), JSON_NODE_TYPE);\n        return (n == null) ? NullNode.instance : n;\n    }\n\n    \n    public JsonNode readTree(String content) throws IOException, JsonProcessingException {\n        JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(content), JSON_NODE_TYPE);\n        return (n == null) ? NullNode.instance : n;\n    }\n\n    \n    public JsonNode readTree(byte[] content) throws IOException, JsonProcessingException {\n        JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(content), JSON_NODE_TYPE);\n        return (n == null) ? NullNode.instance : n;\n    }\n    \n    \n    public JsonNode readTree(File file) throws IOException, JsonProcessingException {\n        JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(file), JSON_NODE_TYPE);\n        return (n == null) ? NullNode.instance : n;\n    }\n\n    \n    public JsonNode readTree(URL source) throws IOException, JsonProcessingException {\n        JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(source), JSON_NODE_TYPE);\n        return (n == null) ? NullNode.instance : n;\n    }\n\n    \n\n    \n    @Override\n    public void writeValue(JsonGenerator g, Object value) throws IOException, JsonGenerationException, JsonMappingException {\n        SerializationConfig config = getSerializationConfig();\n\n        \n        \n        if (config.isEnabled(SerializationFeature.INDENT_OUTPUT)) {\n            if (g.getPrettyPrinter() == null) {\n                g.setPrettyPrinter(config.constructDefaultPrettyPrinter());\n            }\n        }\n        if (config.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) {\n            _writeCloseableValue(g, value, config);\n        } else {\n            _serializerProvider(config).serializeValue(g, value);\n            if (config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) {\n                g.flush();\n            }\n        }\n    }\n\n    \n\n    @Override\n    public void writeTree(JsonGenerator jgen, TreeNode rootNode) throws IOException, JsonProcessingException {\n        SerializationConfig config = getSerializationConfig();\n        _serializerProvider(config).serializeValue(jgen, rootNode);\n        if (config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) {\n            jgen.flush();\n        }\n    }\n    \n    \n    public void writeTree(JsonGenerator jgen, JsonNode rootNode) throws IOException, JsonProcessingException {\n        SerializationConfig config = getSerializationConfig();\n        _serializerProvider(config).serializeValue(jgen, rootNode);\n        if (config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) {\n            jgen.flush();\n        }\n    }\n    \n    \n    @Override    \n    public ObjectNode createObjectNode() {\n        return _deserializationConfig.getNodeFactory().objectNode();\n    }\n\n    \n    @Override\n    public ArrayNode createArrayNode() {\n        return _deserializationConfig.getNodeFactory().arrayNode();\n    }\n\n    \n    @Override\n    public JsonParser treeAsTokens(TreeNode n) {\n        return new TreeTraversingParser((JsonNode) n, this);\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public <T> T treeToValue(TreeNode n, Class<T> valueType) throws JsonProcessingException {\n        try {\n            \n            \n            if (valueType != Object.class && valueType.isAssignableFrom(n.getClass())) {\n                return (T) n;\n            }\n            \n            \n            if (n.asToken() == JsonToken.VALUE_EMBEDDED_OBJECT) {\n                if (n instanceof POJONode) {\n                    Object ob = ((POJONode) n).getPojo();\n                    if ((ob == null) || valueType.isInstance(ob)) {\n                        return (T) ob;\n                    }\n                }\n            }\n            return readValue(treeAsTokens(n), valueType);\n        } catch (JsonProcessingException e) {\n            throw e;\n        } catch (IOException e) { \n            throw new IllegalArgumentException(e.getMessage(), e);\n        }\n    }\n\n    \n    @SuppressWarnings({ \"unchecked\", \"resource\" })\n    public <T extends JsonNode> T valueToTree(Object fromValue) throws IllegalArgumentException {\n        if (fromValue == null) return null;\n        TokenBuffer buf = new TokenBuffer(this, false);\n        if (isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n            buf = buf.forceUseOfBigDecimal(true);\n        }\n        JsonNode result;\n        try {\n            writeValue(buf, fromValue);\n            JsonParser p = buf.asParser();\n            result = readTree(p);\n            p.close();\n        } catch (IOException e) { \n            throw new IllegalArgumentException(e.getMessage(), e);\n        }\n        return (T) result;\n    } \n    \n    \n\n    \n    public boolean canSerialize(Class<?> type) {\n        return _serializerProvider(getSerializationConfig()).hasSerializerFor(type, null);\n    }\n\n    \n    public boolean canSerialize(Class<?> type, AtomicReference<Throwable> cause) {\n        return _serializerProvider(getSerializationConfig()).hasSerializerFor(type, cause);\n    }\n    \n    \n    public boolean canDeserialize(JavaType type) {\n        return createDeserializationContext(null,\n                getDeserializationConfig()).hasValueDeserializerFor(type, null);\n    }\n\n    \n    public boolean canDeserialize(JavaType type, AtomicReference<Throwable> cause) {\n        return createDeserializationContext(null,\n                getDeserializationConfig()).hasValueDeserializerFor(type, cause);\n    }\n    \n    \n\n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(File src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueType));\n    } \n\n    \n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(File src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueTypeRef));\n    } \n\n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(File src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType);\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(URL src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueType));\n    } \n\n    \n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(URL src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueTypeRef));\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(URL src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType);\n    } \n\n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(String content, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(content), _typeFactory.constructType(valueType));\n    } \n\n    \n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(String content, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(content), _typeFactory.constructType(valueTypeRef));\n    } \n\n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(String content, JavaType valueType) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(content), valueType);\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(Reader src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueType));\n    } \n\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(Reader src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueTypeRef));\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(Reader src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType);\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(InputStream src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueType));\n    } \n\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(InputStream src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueTypeRef));\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(InputStream src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType);\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(byte[] src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueType));\n    } \n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(byte[] src, int offset, int len, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src, offset, len), _typeFactory.constructType(valueType));\n    } \n\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(byte[] src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueTypeRef));\n    } \n    \n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(byte[] src, int offset, int len, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src, offset, len), _typeFactory.constructType(valueTypeRef));\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(byte[] src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType);\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(byte[] src, int offset, int len, JavaType valueType) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src, offset, len), valueType);\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(DataInput src, Class<T> valueType) throws IOException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src),\n                _typeFactory.constructType(valueType));\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(DataInput src, JavaType valueType) throws IOException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType);\n    }\n\n    \n\n    \n    public void writeValue(File resultFile, Object value) throws IOException, JsonGenerationException, JsonMappingException {\n        _configAndWriteValue(_jsonFactory.createGenerator(resultFile, JsonEncoding.UTF8), value);\n    }\n\n    \n    public void writeValue(OutputStream out, Object value) throws IOException, JsonGenerationException, JsonMappingException {\n        _configAndWriteValue(_jsonFactory.createGenerator(out, JsonEncoding.UTF8), value);\n    }\n\n    \n    public void writeValue(DataOutput out, Object value) throws IOException {\n        _configAndWriteValue(_jsonFactory.createGenerator(out, JsonEncoding.UTF8), value);\n    }\n\n    \n    public void writeValue(Writer w, Object value) throws IOException, JsonGenerationException, JsonMappingException {\n        _configAndWriteValue(_jsonFactory.createGenerator(w), value);\n    }\n\n    \n    @SuppressWarnings(\"resource\")\n    public String writeValueAsString(Object value) throws JsonProcessingException {\n        \n        SegmentedStringWriter sw = new SegmentedStringWriter(_jsonFactory._getBufferRecycler());\n        try {\n            _configAndWriteValue(_jsonFactory.createGenerator(sw), value);\n        } catch (JsonProcessingException e) { \n            throw e;\n        } catch (IOException e) { \n            throw JsonMappingException.fromUnexpectedIOE(e);\n        }\n        return sw.getAndClear();\n    }\n    \n    \n    @SuppressWarnings(\"resource\")\n    public byte[] writeValueAsBytes(Object value) throws JsonProcessingException {\n        ByteArrayBuilder bb = new ByteArrayBuilder(_jsonFactory._getBufferRecycler());\n        try {\n            _configAndWriteValue(_jsonFactory.createGenerator(bb, JsonEncoding.UTF8), value);\n        } catch (JsonProcessingException e) { \n            throw e;\n        } catch (IOException e) { \n            throw JsonMappingException.fromUnexpectedIOE(e);\n        }\n        byte[] result = bb.toByteArray();\n        bb.release();\n        return result;\n    }\n\n    \n\n    \n    public ObjectWriter writer() {\n        return _newWriter(getSerializationConfig());\n    }\n\n    \n    public ObjectWriter writer(SerializationFeature feature) {\n        return _newWriter(getSerializationConfig().with(feature));\n    }\n\n    \n    public ObjectWriter writer(SerializationFeature first, SerializationFeature... other) {\n        return _newWriter(getSerializationConfig().with(first, other));\n    }\n    \n    \n    public ObjectWriter writer(DateFormat df) {\n        return _newWriter(getSerializationConfig().with(df));\n    }\n    \n    \n    public ObjectWriter writerWithView(Class<?> serializationView) {\n        return _newWriter(getSerializationConfig().withView(serializationView));\n    }\n    \n    \n    public ObjectWriter writerFor(Class<?> rootType) {\n        return _newWriter(getSerializationConfig(),\n                ((rootType == null) ? null :_typeFactory.constructType(rootType)),\n                null);\n    }\n\n    \n    public ObjectWriter writerFor(TypeReference<?> rootType) {\n        return _newWriter(getSerializationConfig(),\n                ((rootType == null) ? null : _typeFactory.constructType(rootType)),\n                null);\n    }\n\n    \n    public ObjectWriter writerFor(JavaType rootType) {\n        return _newWriter(getSerializationConfig(), rootType, null);\n    }\n\n    \n    public ObjectWriter writer(PrettyPrinter pp) {\n        if (pp == null) { \n            pp = ObjectWriter.NULL_PRETTY_PRINTER;\n        }\n        return _newWriter(getSerializationConfig(),  null, pp);\n    }\n    \n    \n    public ObjectWriter writerWithDefaultPrettyPrinter() {\n        SerializationConfig config = getSerializationConfig();\n        return _newWriter(config,\n                 null, config.getDefaultPrettyPrinter());\n    }\n    \n    \n    public ObjectWriter writer(FilterProvider filterProvider) {\n        return _newWriter(getSerializationConfig().withFilters(filterProvider));\n    }\n    \n    \n    public ObjectWriter writer(FormatSchema schema) {\n        _verifySchemaType(schema);\n        return _newWriter(getSerializationConfig(), schema);\n    }\n\n    \n    public ObjectWriter writer(Base64Variant defaultBase64) {\n        return _newWriter(getSerializationConfig().with(defaultBase64));\n    }\n\n    \n    public ObjectWriter writer(CharacterEscapes escapes) {\n        return _newWriter(getSerializationConfig()).with(escapes);\n    }\n\n    \n    public ObjectWriter writer(ContextAttributes attrs) {\n        return _newWriter(getSerializationConfig().with(attrs));\n    }\n\n    \n    @Deprecated\n    public ObjectWriter writerWithType(Class<?> rootType) {\n        return _newWriter(getSerializationConfig(),\n                \n                ((rootType == null) ? null :_typeFactory.constructType(rootType)),\n                null);\n    }\n\n    \n    @Deprecated\n    public ObjectWriter writerWithType(TypeReference<?> rootType) {\n        return _newWriter(getSerializationConfig(),\n                \n                ((rootType == null) ? null : _typeFactory.constructType(rootType)),\n                null);\n    }\n\n    \n    @Deprecated\n    public ObjectWriter writerWithType(JavaType rootType) {\n        return _newWriter(getSerializationConfig(), rootType, null);\n    }\n    \n    \n\n    \n    public ObjectReader reader() {\n        return _newReader(getDeserializationConfig()).with(_injectableValues);\n    }\n\n    \n    public ObjectReader reader(DeserializationFeature feature) {\n        return _newReader(getDeserializationConfig().with(feature));\n    }\n\n    \n    public ObjectReader reader(DeserializationFeature first, DeserializationFeature... other) {\n        return _newReader(getDeserializationConfig().with(first, other));\n    }\n    \n    \n    public ObjectReader readerForUpdating(Object valueToUpdate) {\n        JavaType t = _typeFactory.constructType(valueToUpdate.getClass());\n        return _newReader(getDeserializationConfig(), t, valueToUpdate,\n                null, _injectableValues);\n    }\n\n    \n    public ObjectReader readerFor(JavaType type) {\n        return _newReader(getDeserializationConfig(), type, null,\n                null, _injectableValues);\n    }\n\n    \n    public ObjectReader readerFor(Class<?> type) {\n        return _newReader(getDeserializationConfig(), _typeFactory.constructType(type), null,\n                null, _injectableValues);\n    }\n\n    \n    public ObjectReader readerFor(TypeReference<?> type) {\n        return _newReader(getDeserializationConfig(), _typeFactory.constructType(type), null,\n                null, _injectableValues);\n    }\n\n    \n    public ObjectReader reader(JsonNodeFactory f) {\n        return _newReader(getDeserializationConfig()).with(f);\n    }\n\n    \n    public ObjectReader reader(FormatSchema schema) {\n        _verifySchemaType(schema);\n        return _newReader(getDeserializationConfig(), null, null,\n                schema, _injectableValues);\n    }\n\n    \n    public ObjectReader reader(InjectableValues injectableValues) {\n        return _newReader(getDeserializationConfig(), null, null,\n                null, injectableValues);\n    }\n\n    \n    public ObjectReader readerWithView(Class<?> view) {\n        return _newReader(getDeserializationConfig().withView(view));\n    }\n\n    \n    public ObjectReader reader(Base64Variant defaultBase64) {\n        return _newReader(getDeserializationConfig().with(defaultBase64));\n    }\n\n    \n    public ObjectReader reader(ContextAttributes attrs) {\n        return _newReader(getDeserializationConfig().with(attrs));\n    }\n\n    \n    @Deprecated\n    public ObjectReader reader(JavaType type) {\n        return _newReader(getDeserializationConfig(), type, null,\n                null, _injectableValues);\n    }\n\n    \n    @Deprecated\n    public ObjectReader reader(Class<?> type) {\n        return _newReader(getDeserializationConfig(), _typeFactory.constructType(type), null,\n                null, _injectableValues);\n    }\n\n    \n    @Deprecated\n    public ObjectReader reader(TypeReference<?> type) {\n        return _newReader(getDeserializationConfig(), _typeFactory.constructType(type), null,\n                null, _injectableValues);\n    }\n\n    \n\n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T convertValue(Object fromValue, Class<T> toValueType) throws IllegalArgumentException {\n        \n        if (fromValue == null) return null;\n        return (T) _convert(fromValue, _typeFactory.constructType(toValueType));\n    } \n\n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T convertValue(Object fromValue, TypeReference<?> toValueTypeRef) throws IllegalArgumentException {\n        return (T) convertValue(fromValue, _typeFactory.constructType(toValueTypeRef));\n    } \n\n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T convertValue(Object fromValue, JavaType toValueType) throws IllegalArgumentException {\n        \n        if (fromValue == null) return null;\n        return (T) _convert(fromValue, toValueType);\n    } \n\n    \n    @SuppressWarnings(\"resource\")\n    protected Object _convert(Object fromValue, JavaType toValueType) throws IllegalArgumentException {        \n        \n        \n        Class<?> targetType = toValueType.getRawClass();\n        if (targetType != Object.class\n                && !toValueType.hasGenericTypes()\n                && targetType.isAssignableFrom(fromValue.getClass())) {\n            return fromValue;\n        }\n        \n        \n        TokenBuffer buf = new TokenBuffer(this, false);\n        if (isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n            buf = buf.forceUseOfBigDecimal(true);\n        }\n        try {\n            \n            \n            SerializationConfig config = getSerializationConfig().without(SerializationFeature.WRAP_ROOT_VALUE);\n            \n            _serializerProvider(config).serializeValue(buf, fromValue);\n\n            \n            final JsonParser p = buf.asParser();\n            Object result;\n            \n            final DeserializationConfig deserConfig = getDeserializationConfig();\n            JsonToken t = _initForReading(p);\n            if (t == JsonToken.VALUE_NULL) {\n                DeserializationContext ctxt = createDeserializationContext(p, deserConfig);\n                result = _findRootDeserializer(ctxt, toValueType).getNullValue(ctxt);\n            } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {\n                result = null;\n            } else { \n                DeserializationContext ctxt = createDeserializationContext(p, deserConfig);\n                JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, toValueType);\n                \n                result = deser.deserialize(p, ctxt);\n            }\n            p.close();\n            return result;\n        } catch (IOException e) { \n            throw new IllegalArgumentException(e.getMessage(), e);\n        }\n    }\n\n    \n\n    \n    @Deprecated\n    public com.fasterxml.jackson.databind.jsonschema.JsonSchema generateJsonSchema(Class<?> t) throws JsonMappingException {\n        return _serializerProvider(getSerializationConfig()).generateJsonSchema(t);\n    }\n\n    \n    public void acceptJsonFormatVisitor(Class<?> type, JsonFormatVisitorWrapper visitor) throws JsonMappingException {\n        acceptJsonFormatVisitor(_typeFactory.constructType(type), visitor);\n    }\n    \n    \n    public void acceptJsonFormatVisitor(JavaType type, JsonFormatVisitorWrapper visitor) throws JsonMappingException {\n        if (type == null) {\n            throw new IllegalArgumentException(\"type must be provided\");\n        }\n        _serializerProvider(getSerializationConfig()).acceptJsonFormatVisitor(type, visitor);\n    }\n    \n    \n\n    \n    protected DefaultSerializerProvider _serializerProvider(SerializationConfig config) {\n        return _serializerProvider.createInstance(config, _serializerFactory);\n    }\n\n    \n    protected final void _configAndWriteValue(JsonGenerator g, Object value) throws IOException {\n        SerializationConfig cfg = getSerializationConfig();\n        cfg.initialize(g); \n        if (cfg.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) {\n            _configAndWriteCloseable(g, value, cfg);\n            return;\n        }\n        try {\n            _serializerProvider(cfg).serializeValue(g, value);\n        } catch (Exception e) {\n            ClassUtil.closeOnFailAndThrowAsIAE(g, e);\n            return;\n        }\n        g.close();\n    }\n\n    \n    private final void _configAndWriteCloseable(JsonGenerator g, Object value, SerializationConfig cfg) throws IOException {\n        Closeable toClose = (Closeable) value;\n        try {\n            _serializerProvider(cfg).serializeValue(g, value);\n            Closeable tmpToClose = toClose;\n            toClose = null;\n            tmpToClose.close();\n        } catch (Exception e) {\n            ClassUtil.closeOnFailAndThrowAsIAE(g, toClose, e);\n            return;\n        }\n        g.close();\n    }\n\n    \n    private final void _writeCloseableValue(JsonGenerator g, Object value, SerializationConfig cfg) throws IOException {\n        Closeable toClose = (Closeable) value;\n        try {\n            _serializerProvider(cfg).serializeValue(g, value);\n            if (cfg.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) {\n                g.flush();\n            }\n        } catch (Exception e) {\n            ClassUtil.closeOnFailAndThrowAsIAE(null, toClose, e);\n            return;\n        }\n        toClose.close();\n    }\n\n    \n\n    \n    protected DefaultDeserializationContext createDeserializationContext(JsonParser p, DeserializationConfig cfg) {\n        return _deserializationContext.createInstance(cfg, p, _injectableValues);\n    }\n    \n    \n    protected Object _readValue(DeserializationConfig cfg, JsonParser p, JavaType valueType) throws IOException {\n        \n        Object result;\n        JsonToken t = _initForReading(p);\n        if (t == JsonToken.VALUE_NULL) {\n            \n            DeserializationContext ctxt = createDeserializationContext(p, cfg);\n            result = _findRootDeserializer(ctxt, valueType).getNullValue(ctxt);\n        } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {\n            result = null;\n        } else { \n            DeserializationContext ctxt = createDeserializationContext(p, cfg);\n            JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, valueType);\n            \n            if (cfg.useRootWrapping()) {\n                result = _unwrapAndDeserialize(p, ctxt, cfg, valueType, deser);\n            } else {\n                result = deser.deserialize(p, ctxt);\n            }\n        }\n        \n        p.clearCurrentToken();\n        return result;\n    }\n    \n    protected Object _readMapAndClose(JsonParser p0, JavaType valueType) throws IOException {\n        try (JsonParser p = p0) {\n            Object result;\n            JsonToken t = _initForReading(p);\n            if (t == JsonToken.VALUE_NULL) {\n                \n                DeserializationContext ctxt = createDeserializationContext(p,\n                        getDeserializationConfig());\n                result = _findRootDeserializer(ctxt, valueType).getNullValue(ctxt);\n            } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {\n                result = null;\n            } else {\n                DeserializationConfig cfg = getDeserializationConfig();\n                DeserializationContext ctxt = createDeserializationContext(p, cfg);\n                JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, valueType);\n                if (cfg.useRootWrapping()) {\n                    result = _unwrapAndDeserialize(p, ctxt, cfg, valueType, deser);\n                } else {\n                    result = deser.deserialize(p, ctxt);\n                }\n                ctxt.checkUnresolvedObjectId();\n            }\n            \n            p.clearCurrentToken();\n            return result;\n        }\n    }\n\n    \n    protected JsonToken _initForReading(JsonParser p) throws IOException {\n        _deserializationConfig.initialize(p); \n\n        \n        JsonToken t = p.getCurrentToken();\n        if (t == null) {\n            \n            t = p.nextToken();\n            if (t == null) {\n                \n                \n                throw JsonMappingException.from(p, \"No content to map due to end-of-input\");\n            }\n        }\n        return t;\n    }\n\n    protected Object _unwrapAndDeserialize(JsonParser p, DeserializationContext ctxt, DeserializationConfig config, JavaType rootType, JsonDeserializer<Object> deser) throws IOException {\n        PropertyName expRootName = config.findRootName(rootType);\n        \n        String expSimpleName = expRootName.getSimpleName();\n        if (p.getCurrentToken() != JsonToken.START_OBJECT) {\n            ctxt.reportWrongTokenException(p, JsonToken.START_OBJECT,\n                    \"Current token not START_OBJECT (needed to unwrap root name '%s'), but %s\",\n                    expSimpleName, p.getCurrentToken());\n            \n        }\n        if (p.nextToken() != JsonToken.FIELD_NAME) {\n            ctxt.reportWrongTokenException(p, JsonToken.FIELD_NAME,\n                    \"Current token not FIELD_NAME (to contain expected root name '\"\n                    +expSimpleName+\"'), but \"+p.getCurrentToken());\n        }\n        String actualName = p.getCurrentName();\n        if (!expSimpleName.equals(actualName)) {\n            ctxt.reportMappingException(\"Root name '%s' does not match expected ('%s') for type %s\",\n                    actualName, expSimpleName, rootType);\n        }\n        \n        p.nextToken();\n        Object result = deser.deserialize(p, ctxt);\n        \n        if (p.nextToken() != JsonToken.END_OBJECT) {\n            ctxt.reportWrongTokenException(p, JsonToken.END_OBJECT,\n                    \"Current token not END_OBJECT (to match wrapper object with root name '%s'), but %s\",\n                    expSimpleName, p.getCurrentToken());\n        }\n        return result;\n    }\n    \n    \n\n    \n    protected JsonDeserializer<Object> _findRootDeserializer(DeserializationContext ctxt, JavaType valueType) throws JsonMappingException {\n        \n        JsonDeserializer<Object> deser = _rootDeserializers.get(valueType);\n        if (deser != null) {\n            return deser;\n        }\n        \n        deser = ctxt.findRootValueDeserializer(valueType);\n        if (deser == null) { \n            throw JsonMappingException.from(ctxt,\n                    \"Can not find a deserializer for type \"+valueType);\n        }\n        _rootDeserializers.put(valueType, deser);\n        return deser;\n    }\n\n    \n    protected void _verifySchemaType(FormatSchema schema) {\n        if (schema != null) {\n            if (!_jsonFactory.canUseSchema(schema)) {\n                    throw new IllegalArgumentException(\"Can not use FormatSchema of type \"+schema.getClass().getName()\n                            +\" for format \"+_jsonFactory.getFormatName());\n            }\n        }\n    }\n}\n",
      "buggy_signatures": [
        "public TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes)",
        "public TypeSerializer buildTypeSerializer(SerializationConfig config, JavaType baseType, Collection<NamedType> subtypes)",
        "public boolean useForType(JavaType t)",
        "public ObjectMapper(JsonFactory jf)",
        "protected ObjectMapper(ObjectMapper src)",
        "public ObjectMapper(JsonFactory jf, DefaultSerializerProvider sp, DefaultDeserializationContext dc)",
        "protected ClassIntrospector defaultClassIntrospector()",
        "public ObjectMapper copy()",
        "protected void _checkInvalidCopy(Class<?> exp)",
        "protected ObjectReader _newReader(DeserializationConfig config)",
        "protected ObjectReader _newReader(DeserializationConfig config, JavaType valueType, Object valueToUpdate, FormatSchema schema, InjectableValues injectableValues)",
        "protected ObjectWriter _newWriter(SerializationConfig config)",
        "protected ObjectWriter _newWriter(SerializationConfig config, FormatSchema schema)",
        "protected ObjectWriter _newWriter(SerializationConfig config, JavaType rootType, PrettyPrinter pp)",
        "public Version version()",
        "public ObjectMapper registerModule(Module module)",
        "public Version getMapperVersion()",
        "public <C extends ObjectCodec> C getOwner()",
        "public TypeFactory getTypeFactory()",
        "public boolean isEnabled(MapperFeature f)",
        "public boolean isEnabled(DeserializationFeature f)",
        "public boolean isEnabled(SerializationFeature f)",
        "public boolean isEnabled(JsonFactory.Feature f)",
        "public boolean isEnabled(JsonParser.Feature f)",
        "public boolean isEnabled(JsonGenerator.Feature f)",
        "public MutableConfigOverride configOverride(Class<?> type)",
        "public void addDeserializers(Deserializers d)",
        "public void addKeyDeserializers(KeyDeserializers d)",
        "public void addBeanDeserializerModifier(BeanDeserializerModifier modifier)",
        "public void addSerializers(Serializers s)",
        "public void addKeySerializers(Serializers s)",
        "public void addBeanSerializerModifier(BeanSerializerModifier modifier)",
        "public void addAbstractTypeResolver(AbstractTypeResolver resolver)",
        "public void addTypeModifier(TypeModifier modifier)",
        "public void addValueInstantiators(ValueInstantiators instantiators)",
        "public void setClassIntrospector(ClassIntrospector ci)",
        "public void insertAnnotationIntrospector(AnnotationIntrospector ai)",
        "public void appendAnnotationIntrospector(AnnotationIntrospector ai)",
        "public void registerSubtypes(Class<?>... subtypes)",
        "public void registerSubtypes(NamedType... subtypes)",
        "public void setMixInAnnotations(Class<?> target, Class<?> mixinSource)",
        "public void addDeserializationProblemHandler(DeserializationProblemHandler handler)",
        "public void setNamingStrategy(PropertyNamingStrategy naming)",
        "public ObjectMapper registerModules(Module... modules)",
        "public ObjectMapper registerModules(Iterable<com.fasterxml.jackson.databind.Module> modules)",
        "public static List<com.fasterxml.jackson.databind.Module> findModules()",
        "public static List<com.fasterxml.jackson.databind.Module> findModules(ClassLoader classLoader)",
        "public ObjectMapper findAndRegisterModules()",
        "public SerializationConfig getSerializationConfig()",
        "public DeserializationConfig getDeserializationConfig()",
        "public DeserializationContext getDeserializationContext()",
        "public ObjectMapper setSerializerFactory(SerializerFactory f)",
        "public SerializerFactory getSerializerFactory()",
        "public ObjectMapper setSerializerProvider(DefaultSerializerProvider p)",
        "public SerializerProvider getSerializerProvider()",
        "public SerializerProvider getSerializerProviderInstance()",
        "public ObjectMapper setMixIns(Map<Class<?>, Class<?>> sourceMixins)",
        "public ObjectMapper addMixIn(Class<?> target, Class<?> mixinSource)",
        "public ObjectMapper setMixInResolver(ClassIntrospector.MixInResolver resolver)",
        "public Class<?> findMixInClassFor(Class<?> cls)",
        "public int mixInCount()",
        "public void setMixInAnnotations(Map<Class<?>, Class<?>> sourceMixins)",
        "public final void addMixInAnnotations(Class<?> target, Class<?> mixinSource)",
        "public VisibilityChecker<?> getVisibilityChecker()",
        "public void setVisibilityChecker(VisibilityChecker<?> vc)",
        "public ObjectMapper setVisibility(VisibilityChecker<?> vc)",
        "public ObjectMapper setVisibility(PropertyAccessor forMethod, JsonAutoDetect.Visibility visibility)",
        "public SubtypeResolver getSubtypeResolver()",
        "public ObjectMapper setSubtypeResolver(SubtypeResolver str)",
        "public ObjectMapper setAnnotationIntrospector(AnnotationIntrospector ai)",
        "public ObjectMapper setAnnotationIntrospectors(AnnotationIntrospector serializerAI, AnnotationIntrospector deserializerAI)",
        "public ObjectMapper setPropertyNamingStrategy(PropertyNamingStrategy s)",
        "public PropertyNamingStrategy getPropertyNamingStrategy()",
        "public ObjectMapper setSerializationInclusion(JsonInclude.Include incl)",
        "public ObjectMapper setPropertyInclusion(JsonInclude.Value incl)",
        "public ObjectMapper setDefaultPrettyPrinter(PrettyPrinter pp)",
        "public ObjectMapper enableDefaultTyping()",
        "public ObjectMapper enableDefaultTyping(DefaultTyping dti)",
        "public ObjectMapper enableDefaultTyping(DefaultTyping applicability, JsonTypeInfo.As includeAs)",
        "public ObjectMapper enableDefaultTypingAsProperty(DefaultTyping applicability, String propertyName)",
        "public ObjectMapper disableDefaultTyping()",
        "public ObjectMapper setDefaultTyping(TypeResolverBuilder<?> typer)",
        "public void registerSubtypes(Class<?>... classes)",
        "public void registerSubtypes(NamedType... types)",
        "public MutableConfigOverride configOverride(Class<?> type)",
        "public TypeFactory getTypeFactory()",
        "public ObjectMapper setTypeFactory(TypeFactory f)",
        "public JavaType constructType(Type t)",
        "public JsonNodeFactory getNodeFactory()",
        "public ObjectMapper setNodeFactory(JsonNodeFactory f)",
        "public ObjectMapper addHandler(DeserializationProblemHandler h)",
        "public ObjectMapper clearProblemHandlers()",
        "public ObjectMapper setConfig(DeserializationConfig config)",
        "public void setFilters(FilterProvider filterProvider)",
        "public ObjectMapper setFilterProvider(FilterProvider filterProvider)",
        "public ObjectMapper setBase64Variant(Base64Variant v)",
        "public ObjectMapper setConfig(SerializationConfig config)",
        "public JsonFactory getFactory()",
        "public JsonFactory getJsonFactory()",
        "public ObjectMapper setDateFormat(DateFormat dateFormat)",
        "public DateFormat getDateFormat()",
        "public Object setHandlerInstantiator(HandlerInstantiator hi)",
        "public ObjectMapper setInjectableValues(InjectableValues injectableValues)",
        "public InjectableValues getInjectableValues()",
        "public ObjectMapper setLocale(Locale l)",
        "public ObjectMapper setTimeZone(TimeZone tz)",
        "public boolean isEnabled(MapperFeature f)",
        "public ObjectMapper configure(MapperFeature f, boolean state)",
        "public ObjectMapper enable(MapperFeature... f)",
        "public ObjectMapper disable(MapperFeature... f)",
        "public boolean isEnabled(SerializationFeature f)",
        "public ObjectMapper configure(SerializationFeature f, boolean state)",
        "public ObjectMapper enable(SerializationFeature f)",
        "public ObjectMapper enable(SerializationFeature first, SerializationFeature... f)",
        "public ObjectMapper disable(SerializationFeature f)",
        "public ObjectMapper disable(SerializationFeature first, SerializationFeature... f)",
        "public boolean isEnabled(DeserializationFeature f)",
        "public ObjectMapper configure(DeserializationFeature f, boolean state)",
        "public ObjectMapper enable(DeserializationFeature feature)",
        "public ObjectMapper enable(DeserializationFeature first, DeserializationFeature... f)",
        "public ObjectMapper disable(DeserializationFeature feature)",
        "public ObjectMapper disable(DeserializationFeature first, DeserializationFeature... f)",
        "public boolean isEnabled(JsonParser.Feature f)",
        "public ObjectMapper configure(JsonParser.Feature f, boolean state)",
        "public ObjectMapper enable(JsonParser.Feature... features)",
        "public ObjectMapper disable(JsonParser.Feature... features)",
        "public boolean isEnabled(JsonGenerator.Feature f)",
        "public ObjectMapper configure(JsonGenerator.Feature f, boolean state)",
        "public ObjectMapper enable(JsonGenerator.Feature... features)",
        "public ObjectMapper disable(JsonGenerator.Feature... features)",
        "public boolean isEnabled(JsonFactory.Feature f)",
        "public <T> T readValue(JsonParser p, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(JsonParser p, TypeReference<?> valueTypeRef) throws IOException, JsonParseException, JsonMappingException",
        "public final <T> T readValue(JsonParser p, ResolvedType valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(JsonParser p, JavaType valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T extends TreeNode> T readTree(JsonParser p) throws IOException, JsonProcessingException",
        "public <T> MappingIterator<T> readValues(JsonParser p, ResolvedType valueType) throws IOException, JsonProcessingException",
        "public <T> MappingIterator<T> readValues(JsonParser p, JavaType valueType) throws IOException, JsonProcessingException",
        "public <T> MappingIterator<T> readValues(JsonParser p, Class<T> valueType) throws IOException, JsonProcessingException",
        "public <T> MappingIterator<T> readValues(JsonParser p, TypeReference<?> valueTypeRef) throws IOException, JsonProcessingException",
        "public JsonNode readTree(InputStream in) throws IOException, JsonProcessingException",
        "public JsonNode readTree(Reader r) throws IOException, JsonProcessingException",
        "public JsonNode readTree(String content) throws IOException, JsonProcessingException",
        "public JsonNode readTree(byte[] content) throws IOException, JsonProcessingException",
        "public JsonNode readTree(File file) throws IOException, JsonProcessingException",
        "public JsonNode readTree(URL source) throws IOException, JsonProcessingException",
        "public void writeValue(JsonGenerator g, Object value) throws IOException, JsonGenerationException, JsonMappingException",
        "public void writeTree(JsonGenerator jgen, TreeNode rootNode) throws IOException, JsonProcessingException",
        "public void writeTree(JsonGenerator jgen, JsonNode rootNode) throws IOException, JsonProcessingException",
        "public ObjectNode createObjectNode()",
        "public ArrayNode createArrayNode()",
        "public JsonParser treeAsTokens(TreeNode n)",
        "public <T> T treeToValue(TreeNode n, Class<T> valueType) throws JsonProcessingException",
        "public <T extends JsonNode> T valueToTree(Object fromValue) throws IllegalArgumentException",
        "public boolean canSerialize(Class<?> type)",
        "public boolean canSerialize(Class<?> type, AtomicReference<Throwable> cause)",
        "public boolean canDeserialize(JavaType type)",
        "public boolean canDeserialize(JavaType type, AtomicReference<Throwable> cause)",
        "public <T> T readValue(File src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(File src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(File src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(URL src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(URL src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(URL src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(String content, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(String content, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(String content, JavaType valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(Reader src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(Reader src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(Reader src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(InputStream src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(InputStream src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(InputStream src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(byte[] src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(byte[] src, int offset, int len, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(byte[] src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(byte[] src, int offset, int len, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(byte[] src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(byte[] src, int offset, int len, JavaType valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(DataInput src, Class<T> valueType) throws IOException",
        "public <T> T readValue(DataInput src, JavaType valueType) throws IOException",
        "public void writeValue(File resultFile, Object value) throws IOException, JsonGenerationException, JsonMappingException",
        "public void writeValue(OutputStream out, Object value) throws IOException, JsonGenerationException, JsonMappingException",
        "public void writeValue(DataOutput out, Object value) throws IOException",
        "public void writeValue(Writer w, Object value) throws IOException, JsonGenerationException, JsonMappingException",
        "public String writeValueAsString(Object value) throws JsonProcessingException",
        "public byte[] writeValueAsBytes(Object value) throws JsonProcessingException",
        "public ObjectWriter writer()",
        "public ObjectWriter writer(SerializationFeature feature)",
        "public ObjectWriter writer(SerializationFeature first, SerializationFeature... other)",
        "public ObjectWriter writer(DateFormat df)",
        "public ObjectWriter writerWithView(Class<?> serializationView)",
        "public ObjectWriter writerFor(Class<?> rootType)",
        "public ObjectWriter writerFor(TypeReference<?> rootType)",
        "public ObjectWriter writerFor(JavaType rootType)",
        "public ObjectWriter writer(PrettyPrinter pp)",
        "public ObjectWriter writerWithDefaultPrettyPrinter()",
        "public ObjectWriter writer(FilterProvider filterProvider)",
        "public ObjectWriter writer(FormatSchema schema)",
        "public ObjectWriter writer(Base64Variant defaultBase64)",
        "public ObjectWriter writer(CharacterEscapes escapes)",
        "public ObjectWriter writer(ContextAttributes attrs)",
        "public ObjectWriter writerWithType(Class<?> rootType)",
        "public ObjectWriter writerWithType(TypeReference<?> rootType)",
        "public ObjectWriter writerWithType(JavaType rootType)",
        "public ObjectReader reader()",
        "public ObjectReader reader(DeserializationFeature feature)",
        "public ObjectReader reader(DeserializationFeature first, DeserializationFeature... other)",
        "public ObjectReader readerForUpdating(Object valueToUpdate)",
        "public ObjectReader readerFor(JavaType type)",
        "public ObjectReader readerFor(Class<?> type)",
        "public ObjectReader readerFor(TypeReference<?> type)",
        "public ObjectReader reader(JsonNodeFactory f)",
        "public ObjectReader reader(FormatSchema schema)",
        "public ObjectReader reader(InjectableValues injectableValues)",
        "public ObjectReader readerWithView(Class<?> view)",
        "public ObjectReader reader(Base64Variant defaultBase64)",
        "public ObjectReader reader(ContextAttributes attrs)",
        "public ObjectReader reader(JavaType type)",
        "public ObjectReader reader(Class<?> type)",
        "public ObjectReader reader(TypeReference<?> type)",
        "public <T> T convertValue(Object fromValue, Class<T> toValueType) throws IllegalArgumentException",
        "public <T> T convertValue(Object fromValue, TypeReference<?> toValueTypeRef) throws IllegalArgumentException",
        "public <T> T convertValue(Object fromValue, JavaType toValueType) throws IllegalArgumentException",
        "protected Object _convert(Object fromValue, JavaType toValueType) throws IllegalArgumentException",
        "public com.fasterxml.jackson.databind.jsonschema.JsonSchema generateJsonSchema(Class<?> t) throws JsonMappingException",
        "public void acceptJsonFormatVisitor(Class<?> type, JsonFormatVisitorWrapper visitor) throws JsonMappingException",
        "public void acceptJsonFormatVisitor(JavaType type, JsonFormatVisitorWrapper visitor) throws JsonMappingException",
        "protected DefaultSerializerProvider _serializerProvider(SerializationConfig config)",
        "protected final void _configAndWriteValue(JsonGenerator g, Object value) throws IOException",
        "private final void _configAndWriteCloseable(JsonGenerator g, Object value, SerializationConfig cfg) throws IOException",
        "private final void _writeCloseableValue(JsonGenerator g, Object value, SerializationConfig cfg) throws IOException",
        "protected DefaultDeserializationContext createDeserializationContext(JsonParser p, DeserializationConfig cfg)",
        "protected Object _readValue(DeserializationConfig cfg, JsonParser p, JavaType valueType) throws IOException",
        "protected Object _readMapAndClose(JsonParser p0, JavaType valueType) throws IOException",
        "protected JsonToken _initForReading(JsonParser p) throws IOException",
        "protected Object _unwrapAndDeserialize(JsonParser p, DeserializationContext ctxt, DeserializationConfig config, JavaType rootType, JsonDeserializer<Object> deser) throws IOException",
        "protected JsonDeserializer<Object> _findRootDeserializer(DeserializationContext ctxt, JavaType valueType) throws JsonMappingException",
        "protected void _verifySchemaType(FormatSchema schema)"
      ],
      "fixed_signatures": [
        "public TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes)",
        "public TypeSerializer buildTypeSerializer(SerializationConfig config, JavaType baseType, Collection<NamedType> subtypes)",
        "public boolean useForType(JavaType t)",
        "public ObjectMapper(JsonFactory jf)",
        "protected ObjectMapper(ObjectMapper src)",
        "public ObjectMapper(JsonFactory jf, DefaultSerializerProvider sp, DefaultDeserializationContext dc)",
        "protected ClassIntrospector defaultClassIntrospector()",
        "public ObjectMapper copy()",
        "protected void _checkInvalidCopy(Class<?> exp)",
        "protected ObjectReader _newReader(DeserializationConfig config)",
        "protected ObjectReader _newReader(DeserializationConfig config, JavaType valueType, Object valueToUpdate, FormatSchema schema, InjectableValues injectableValues)",
        "protected ObjectWriter _newWriter(SerializationConfig config)",
        "protected ObjectWriter _newWriter(SerializationConfig config, FormatSchema schema)",
        "protected ObjectWriter _newWriter(SerializationConfig config, JavaType rootType, PrettyPrinter pp)",
        "public Version version()",
        "public ObjectMapper registerModule(Module module)",
        "public Version getMapperVersion()",
        "public <C extends ObjectCodec> C getOwner()",
        "public TypeFactory getTypeFactory()",
        "public boolean isEnabled(MapperFeature f)",
        "public boolean isEnabled(DeserializationFeature f)",
        "public boolean isEnabled(SerializationFeature f)",
        "public boolean isEnabled(JsonFactory.Feature f)",
        "public boolean isEnabled(JsonParser.Feature f)",
        "public boolean isEnabled(JsonGenerator.Feature f)",
        "public MutableConfigOverride configOverride(Class<?> type)",
        "public void addDeserializers(Deserializers d)",
        "public void addKeyDeserializers(KeyDeserializers d)",
        "public void addBeanDeserializerModifier(BeanDeserializerModifier modifier)",
        "public void addSerializers(Serializers s)",
        "public void addKeySerializers(Serializers s)",
        "public void addBeanSerializerModifier(BeanSerializerModifier modifier)",
        "public void addAbstractTypeResolver(AbstractTypeResolver resolver)",
        "public void addTypeModifier(TypeModifier modifier)",
        "public void addValueInstantiators(ValueInstantiators instantiators)",
        "public void setClassIntrospector(ClassIntrospector ci)",
        "public void insertAnnotationIntrospector(AnnotationIntrospector ai)",
        "public void appendAnnotationIntrospector(AnnotationIntrospector ai)",
        "public void registerSubtypes(Class<?>... subtypes)",
        "public void registerSubtypes(NamedType... subtypes)",
        "public void setMixInAnnotations(Class<?> target, Class<?> mixinSource)",
        "public void addDeserializationProblemHandler(DeserializationProblemHandler handler)",
        "public void setNamingStrategy(PropertyNamingStrategy naming)",
        "public ObjectMapper registerModules(Module... modules)",
        "public ObjectMapper registerModules(Iterable<com.fasterxml.jackson.databind.Module> modules)",
        "public static List<com.fasterxml.jackson.databind.Module> findModules()",
        "public static List<com.fasterxml.jackson.databind.Module> findModules(ClassLoader classLoader)",
        "public ObjectMapper findAndRegisterModules()",
        "public SerializationConfig getSerializationConfig()",
        "public DeserializationConfig getDeserializationConfig()",
        "public DeserializationContext getDeserializationContext()",
        "public ObjectMapper setSerializerFactory(SerializerFactory f)",
        "public SerializerFactory getSerializerFactory()",
        "public ObjectMapper setSerializerProvider(DefaultSerializerProvider p)",
        "public SerializerProvider getSerializerProvider()",
        "public SerializerProvider getSerializerProviderInstance()",
        "public ObjectMapper setMixIns(Map<Class<?>, Class<?>> sourceMixins)",
        "public ObjectMapper addMixIn(Class<?> target, Class<?> mixinSource)",
        "public ObjectMapper setMixInResolver(ClassIntrospector.MixInResolver resolver)",
        "public Class<?> findMixInClassFor(Class<?> cls)",
        "public int mixInCount()",
        "public void setMixInAnnotations(Map<Class<?>, Class<?>> sourceMixins)",
        "public final void addMixInAnnotations(Class<?> target, Class<?> mixinSource)",
        "public VisibilityChecker<?> getVisibilityChecker()",
        "public void setVisibilityChecker(VisibilityChecker<?> vc)",
        "public ObjectMapper setVisibility(VisibilityChecker<?> vc)",
        "public ObjectMapper setVisibility(PropertyAccessor forMethod, JsonAutoDetect.Visibility visibility)",
        "public SubtypeResolver getSubtypeResolver()",
        "public ObjectMapper setSubtypeResolver(SubtypeResolver str)",
        "public ObjectMapper setAnnotationIntrospector(AnnotationIntrospector ai)",
        "public ObjectMapper setAnnotationIntrospectors(AnnotationIntrospector serializerAI, AnnotationIntrospector deserializerAI)",
        "public ObjectMapper setPropertyNamingStrategy(PropertyNamingStrategy s)",
        "public PropertyNamingStrategy getPropertyNamingStrategy()",
        "public ObjectMapper setSerializationInclusion(JsonInclude.Include incl)",
        "public ObjectMapper setPropertyInclusion(JsonInclude.Value incl)",
        "public ObjectMapper setDefaultPrettyPrinter(PrettyPrinter pp)",
        "public ObjectMapper enableDefaultTyping()",
        "public ObjectMapper enableDefaultTyping(DefaultTyping dti)",
        "public ObjectMapper enableDefaultTyping(DefaultTyping applicability, JsonTypeInfo.As includeAs)",
        "public ObjectMapper enableDefaultTypingAsProperty(DefaultTyping applicability, String propertyName)",
        "public ObjectMapper disableDefaultTyping()",
        "public ObjectMapper setDefaultTyping(TypeResolverBuilder<?> typer)",
        "public void registerSubtypes(Class<?>... classes)",
        "public void registerSubtypes(NamedType... types)",
        "public MutableConfigOverride configOverride(Class<?> type)",
        "public TypeFactory getTypeFactory()",
        "public ObjectMapper setTypeFactory(TypeFactory f)",
        "public JavaType constructType(Type t)",
        "public JsonNodeFactory getNodeFactory()",
        "public ObjectMapper setNodeFactory(JsonNodeFactory f)",
        "public ObjectMapper addHandler(DeserializationProblemHandler h)",
        "public ObjectMapper clearProblemHandlers()",
        "public ObjectMapper setConfig(DeserializationConfig config)",
        "public void setFilters(FilterProvider filterProvider)",
        "public ObjectMapper setFilterProvider(FilterProvider filterProvider)",
        "public ObjectMapper setBase64Variant(Base64Variant v)",
        "public ObjectMapper setConfig(SerializationConfig config)",
        "public JsonFactory getFactory()",
        "public JsonFactory getJsonFactory()",
        "public ObjectMapper setDateFormat(DateFormat dateFormat)",
        "public DateFormat getDateFormat()",
        "public Object setHandlerInstantiator(HandlerInstantiator hi)",
        "public ObjectMapper setInjectableValues(InjectableValues injectableValues)",
        "public InjectableValues getInjectableValues()",
        "public ObjectMapper setLocale(Locale l)",
        "public ObjectMapper setTimeZone(TimeZone tz)",
        "public boolean isEnabled(MapperFeature f)",
        "public ObjectMapper configure(MapperFeature f, boolean state)",
        "public ObjectMapper enable(MapperFeature... f)",
        "public ObjectMapper disable(MapperFeature... f)",
        "public boolean isEnabled(SerializationFeature f)",
        "public ObjectMapper configure(SerializationFeature f, boolean state)",
        "public ObjectMapper enable(SerializationFeature f)",
        "public ObjectMapper enable(SerializationFeature first, SerializationFeature... f)",
        "public ObjectMapper disable(SerializationFeature f)",
        "public ObjectMapper disable(SerializationFeature first, SerializationFeature... f)",
        "public boolean isEnabled(DeserializationFeature f)",
        "public ObjectMapper configure(DeserializationFeature f, boolean state)",
        "public ObjectMapper enable(DeserializationFeature feature)",
        "public ObjectMapper enable(DeserializationFeature first, DeserializationFeature... f)",
        "public ObjectMapper disable(DeserializationFeature feature)",
        "public ObjectMapper disable(DeserializationFeature first, DeserializationFeature... f)",
        "public boolean isEnabled(JsonParser.Feature f)",
        "public ObjectMapper configure(JsonParser.Feature f, boolean state)",
        "public ObjectMapper enable(JsonParser.Feature... features)",
        "public ObjectMapper disable(JsonParser.Feature... features)",
        "public boolean isEnabled(JsonGenerator.Feature f)",
        "public ObjectMapper configure(JsonGenerator.Feature f, boolean state)",
        "public ObjectMapper enable(JsonGenerator.Feature... features)",
        "public ObjectMapper disable(JsonGenerator.Feature... features)",
        "public boolean isEnabled(JsonFactory.Feature f)",
        "public <T> T readValue(JsonParser p, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(JsonParser p, TypeReference<?> valueTypeRef) throws IOException, JsonParseException, JsonMappingException",
        "public final <T> T readValue(JsonParser p, ResolvedType valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(JsonParser p, JavaType valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T extends TreeNode> T readTree(JsonParser p) throws IOException, JsonProcessingException",
        "public <T> MappingIterator<T> readValues(JsonParser p, ResolvedType valueType) throws IOException, JsonProcessingException",
        "public <T> MappingIterator<T> readValues(JsonParser p, JavaType valueType) throws IOException, JsonProcessingException",
        "public <T> MappingIterator<T> readValues(JsonParser p, Class<T> valueType) throws IOException, JsonProcessingException",
        "public <T> MappingIterator<T> readValues(JsonParser p, TypeReference<?> valueTypeRef) throws IOException, JsonProcessingException",
        "public JsonNode readTree(InputStream in) throws IOException, JsonProcessingException",
        "public JsonNode readTree(Reader r) throws IOException, JsonProcessingException",
        "public JsonNode readTree(String content) throws IOException, JsonProcessingException",
        "public JsonNode readTree(byte[] content) throws IOException, JsonProcessingException",
        "public JsonNode readTree(File file) throws IOException, JsonProcessingException",
        "public JsonNode readTree(URL source) throws IOException, JsonProcessingException",
        "public void writeValue(JsonGenerator g, Object value) throws IOException, JsonGenerationException, JsonMappingException",
        "public void writeTree(JsonGenerator jgen, TreeNode rootNode) throws IOException, JsonProcessingException",
        "public void writeTree(JsonGenerator jgen, JsonNode rootNode) throws IOException, JsonProcessingException",
        "public ObjectNode createObjectNode()",
        "public ArrayNode createArrayNode()",
        "public JsonParser treeAsTokens(TreeNode n)",
        "public <T> T treeToValue(TreeNode n, Class<T> valueType) throws JsonProcessingException",
        "public <T extends JsonNode> T valueToTree(Object fromValue) throws IllegalArgumentException",
        "public boolean canSerialize(Class<?> type)",
        "public boolean canSerialize(Class<?> type, AtomicReference<Throwable> cause)",
        "public boolean canDeserialize(JavaType type)",
        "public boolean canDeserialize(JavaType type, AtomicReference<Throwable> cause)",
        "public <T> T readValue(File src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(File src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(File src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(URL src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(URL src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(URL src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(String content, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(String content, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(String content, JavaType valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(Reader src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(Reader src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(Reader src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(InputStream src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(InputStream src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(InputStream src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(byte[] src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(byte[] src, int offset, int len, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(byte[] src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(byte[] src, int offset, int len, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(byte[] src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(byte[] src, int offset, int len, JavaType valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(DataInput src, Class<T> valueType) throws IOException",
        "public <T> T readValue(DataInput src, JavaType valueType) throws IOException",
        "public void writeValue(File resultFile, Object value) throws IOException, JsonGenerationException, JsonMappingException",
        "public void writeValue(OutputStream out, Object value) throws IOException, JsonGenerationException, JsonMappingException",
        "public void writeValue(DataOutput out, Object value) throws IOException",
        "public void writeValue(Writer w, Object value) throws IOException, JsonGenerationException, JsonMappingException",
        "public String writeValueAsString(Object value) throws JsonProcessingException",
        "public byte[] writeValueAsBytes(Object value) throws JsonProcessingException",
        "public ObjectWriter writer()",
        "public ObjectWriter writer(SerializationFeature feature)",
        "public ObjectWriter writer(SerializationFeature first, SerializationFeature... other)",
        "public ObjectWriter writer(DateFormat df)",
        "public ObjectWriter writerWithView(Class<?> serializationView)",
        "public ObjectWriter writerFor(Class<?> rootType)",
        "public ObjectWriter writerFor(TypeReference<?> rootType)",
        "public ObjectWriter writerFor(JavaType rootType)",
        "public ObjectWriter writer(PrettyPrinter pp)",
        "public ObjectWriter writerWithDefaultPrettyPrinter()",
        "public ObjectWriter writer(FilterProvider filterProvider)",
        "public ObjectWriter writer(FormatSchema schema)",
        "public ObjectWriter writer(Base64Variant defaultBase64)",
        "public ObjectWriter writer(CharacterEscapes escapes)",
        "public ObjectWriter writer(ContextAttributes attrs)",
        "public ObjectWriter writerWithType(Class<?> rootType)",
        "public ObjectWriter writerWithType(TypeReference<?> rootType)",
        "public ObjectWriter writerWithType(JavaType rootType)",
        "public ObjectReader reader()",
        "public ObjectReader reader(DeserializationFeature feature)",
        "public ObjectReader reader(DeserializationFeature first, DeserializationFeature... other)",
        "public ObjectReader readerForUpdating(Object valueToUpdate)",
        "public ObjectReader readerFor(JavaType type)",
        "public ObjectReader readerFor(Class<?> type)",
        "public ObjectReader readerFor(TypeReference<?> type)",
        "public ObjectReader reader(JsonNodeFactory f)",
        "public ObjectReader reader(FormatSchema schema)",
        "public ObjectReader reader(InjectableValues injectableValues)",
        "public ObjectReader readerWithView(Class<?> view)",
        "public ObjectReader reader(Base64Variant defaultBase64)",
        "public ObjectReader reader(ContextAttributes attrs)",
        "public ObjectReader reader(JavaType type)",
        "public ObjectReader reader(Class<?> type)",
        "public ObjectReader reader(TypeReference<?> type)",
        "public <T> T convertValue(Object fromValue, Class<T> toValueType) throws IllegalArgumentException",
        "public <T> T convertValue(Object fromValue, TypeReference<?> toValueTypeRef) throws IllegalArgumentException",
        "public <T> T convertValue(Object fromValue, JavaType toValueType) throws IllegalArgumentException",
        "protected Object _convert(Object fromValue, JavaType toValueType) throws IllegalArgumentException",
        "public com.fasterxml.jackson.databind.jsonschema.JsonSchema generateJsonSchema(Class<?> t) throws JsonMappingException",
        "public void acceptJsonFormatVisitor(Class<?> type, JsonFormatVisitorWrapper visitor) throws JsonMappingException",
        "public void acceptJsonFormatVisitor(JavaType type, JsonFormatVisitorWrapper visitor) throws JsonMappingException",
        "protected DefaultSerializerProvider _serializerProvider(SerializationConfig config)",
        "protected final void _configAndWriteValue(JsonGenerator g, Object value) throws IOException",
        "private final void _configAndWriteCloseable(JsonGenerator g, Object value, SerializationConfig cfg) throws IOException",
        "private final void _writeCloseableValue(JsonGenerator g, Object value, SerializationConfig cfg) throws IOException",
        "protected DefaultDeserializationContext createDeserializationContext(JsonParser p, DeserializationConfig cfg)",
        "protected Object _readValue(DeserializationConfig cfg, JsonParser p, JavaType valueType) throws IOException",
        "protected Object _readMapAndClose(JsonParser p0, JavaType valueType) throws IOException",
        "protected JsonToken _initForReading(JsonParser p) throws IOException",
        "protected Object _unwrapAndDeserialize(JsonParser p, DeserializationContext ctxt, DeserializationConfig config, JavaType rootType, JsonDeserializer<Object> deser) throws IOException",
        "protected JsonDeserializer<Object> _findRootDeserializer(DeserializationContext ctxt, JavaType valueType) throws JsonMappingException",
        "protected void _verifySchemaType(FormatSchema schema)"
      ],
      "methods": [
        {
          "buggy_method": "  public boolean useForType(JavaType t) {\n  \n  \n\n  switch (_appliesFor) {\n  case NON_CONCRETE_AND_ARRAYS:\n  while (t.isArrayType()) {\n  t = t.getContentType();\n  }\n  \n  case OBJECT_AND_NON_CONCRETE:\n  \n  while (t.isReferenceType()) {\n  t = t.getReferencedType();\n  }\n  return t.isJavaLangObject()\n  || (!t.isConcrete()\n  \n  && !TreeNode.class.isAssignableFrom(t.getRawClass()));\n\n  case NON_FINAL:\n  while (t.isArrayType()) {\n  t = t.getContentType();\n  }\n  \n  while (t.isReferenceType()) {\n  t = t.getReferencedType();\n  }\n  \n  return !t.isFinal() && !TreeNode.class.isAssignableFrom(t.getRawClass());\n  default:\n  \n  return t.isJavaLangObject();\n  }\n  }",
          "fixed_method": "  public boolean useForType(JavaType t) {\n  \n  \n  if (t.isPrimitive()) {\n  return false;\n  }\n\n  switch (_appliesFor) {\n  case NON_CONCRETE_AND_ARRAYS:\n  while (t.isArrayType()) {\n  t = t.getContentType();\n  }\n  \n  case OBJECT_AND_NON_CONCRETE:\n  \n  while (t.isReferenceType()) {\n  t = t.getReferencedType();\n  }\n  return t.isJavaLangObject()\n  || (!t.isConcrete()\n  \n  && !TreeNode.class.isAssignableFrom(t.getRawClass()));\n\n  case NON_FINAL:\n  while (t.isArrayType()) {\n  t = t.getContentType();\n  }\n  \n  while (t.isReferenceType()) {\n  t = t.getReferencedType();\n  }\n  \n  return !t.isFinal() && !TreeNode.class.isAssignableFrom(t.getRawClass());\n  default:\n  \n  return t.isJavaLangObject();\n  }\n  }",
          "diff": [
            "@@ -229,6 +229,9 @@",
            "         {\n",
            "             // 03-Oct-2016, tatu: As per [databind#1395], need to skip\n",
            "             //  primitive types too, regardless\n",
            "+            if (t.isPrimitive()) {\n",
            "+                return false;\n",
            "+            }\n",
            " \n",
            "             switch (_appliesFor) {\n",
            "             case NON_CONCRETE_AND_ARRAYS:\n"
          ],
          "changed_lines": 3
        }
      ]
    },
    {
      "name": "com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java",
      "buggy_full_code": "package com.fasterxml.jackson.databind.jsontype.impl;\n\nimport java.util.Collection;\n\nimport com.fasterxml.jackson.annotation.JsonTypeInfo;\n\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.annotation.NoClass;\nimport com.fasterxml.jackson.databind.cfg.MapperConfig;\nimport com.fasterxml.jackson.databind.jsontype.*;\n\n\npublic class StdTypeResolverBuilder implements TypeResolverBuilder<StdTypeResolverBuilder> { protected JsonTypeInfo.Id _idType; protected JsonTypeInfo.As _includeAs; protected String _typeProperty; protected boolean _typeIdVisible = false; protected Class<?> _defaultImpl; protected TypeIdResolver _customIdResolver; public StdTypeResolverBuilder() { }\n\n    public static StdTypeResolverBuilder noTypeInfoBuilder() {\n        return new StdTypeResolverBuilder().init(JsonTypeInfo.Id.NONE, null);\n    }\n\n    @Override\n    public StdTypeResolverBuilder init(JsonTypeInfo.Id idType, TypeIdResolver idRes) {\n        \n        if (idType == null) {\n            throw new IllegalArgumentException(\"idType can not be null\");\n        }\n        _idType = idType;\n        _customIdResolver = idRes;\n        \n        _typeProperty = idType.getDefaultPropertyName();\n        return this;\n    }\n\n    @Override\n    public TypeSerializer buildTypeSerializer(SerializationConfig config, JavaType baseType, Collection<NamedType> subtypes) {\n        if (_idType == JsonTypeInfo.Id.NONE) { return null; }\n        \n        \n        TypeIdResolver idRes = idResolver(config, baseType, subtypes, true, false);\n        switch (_includeAs) {\n        case WRAPPER_ARRAY:\n            return new AsArrayTypeSerializer(idRes, null);\n        case PROPERTY:\n            return new AsPropertyTypeSerializer(idRes, null, _typeProperty);\n        case WRAPPER_OBJECT:\n            return new AsWrapperTypeSerializer(idRes, null);\n        case EXTERNAL_PROPERTY:\n            return new AsExternalTypeSerializer(idRes, null, _typeProperty);\n        case EXISTING_PROPERTY:\n        \t\n        \treturn new AsExistingPropertyTypeSerializer(idRes, null, _typeProperty);\n        }\n        throw new IllegalStateException(\"Do not know how to construct standard type serializer for inclusion type: \"+_includeAs);\n    }\n\n    \n    \n    \n    \n    \n\n    @Override\n    public TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes) {\n        if (_idType == JsonTypeInfo.Id.NONE) { return null; }\n        \n        \n\n        TypeIdResolver idRes = idResolver(config, baseType, subtypes, false, true);\n\n        JavaType defaultImpl;\n\n        if (_defaultImpl == null) {\n            defaultImpl = null;\n        } else {\n            \n            \n            \n            \n            \n            \n            if ((_defaultImpl == Void.class)\n                     || (_defaultImpl == NoClass.class)) {\n                defaultImpl = config.getTypeFactory().constructType(_defaultImpl);\n            } else {\n                defaultImpl = config.getTypeFactory()\n                    .constructSpecializedType(baseType, _defaultImpl);\n            }\n        }\n\n        \n        switch (_includeAs) {\n        case WRAPPER_ARRAY:\n            return new AsArrayTypeDeserializer(baseType, idRes,\n                    _typeProperty, _typeIdVisible, defaultImpl);\n        case PROPERTY:\n        case EXISTING_PROPERTY: \n            return new AsPropertyTypeDeserializer(baseType, idRes,\n                    _typeProperty, _typeIdVisible, defaultImpl, _includeAs);\n        case WRAPPER_OBJECT:\n            return new AsWrapperTypeDeserializer(baseType, idRes,\n                    _typeProperty, _typeIdVisible, defaultImpl);\n        case EXTERNAL_PROPERTY:\n            return new AsExternalTypeDeserializer(baseType, idRes,\n                    _typeProperty, _typeIdVisible, defaultImpl);\n        }\n        throw new IllegalStateException(\"Do not know how to construct standard type serializer for inclusion type: \"+_includeAs);\n    }\n\n    \n\n    @Override\n    public StdTypeResolverBuilder inclusion(JsonTypeInfo.As includeAs) {\n        if (includeAs == null) {\n            throw new IllegalArgumentException(\"includeAs can not be null\");\n        }\n        _includeAs = includeAs;\n        return this;\n    }\n\n    \n    @Override\n    public StdTypeResolverBuilder typeProperty(String typeIdPropName) {\n        \n        if (typeIdPropName == null || typeIdPropName.length() == 0) {\n            typeIdPropName = _idType.getDefaultPropertyName();\n        }\n        _typeProperty = typeIdPropName;\n        return this;\n    }\n\n    @Override\n    public StdTypeResolverBuilder defaultImpl(Class<?> defaultImpl) {\n        _defaultImpl = defaultImpl;\n        return this;\n    }\n\n    @Override\n    public StdTypeResolverBuilder typeIdVisibility(boolean isVisible) {\n        _typeIdVisible = isVisible;\n        return this;\n    }\n    \n    \n\n    @Override public Class<?> getDefaultImpl() { return _defaultImpl; }\n\n    public String getTypeProperty() { return _typeProperty; }\n    public boolean isTypeIdVisible() { return _typeIdVisible; }\n    \n    \n    \n    \n    protected TypeIdResolver idResolver(MapperConfig<?> config, JavaType baseType, Collection<NamedType> subtypes, boolean forSer, boolean forDeser) {\n        \n        if (_customIdResolver != null) { return _customIdResolver; }\n        if (_idType == null) throw new IllegalStateException(\"Can not build, 'init()' not yet called\");\n        switch (_idType) {\n        case CLASS:\n            return new ClassNameIdResolver(baseType, config.getTypeFactory());\n        case MINIMAL_CLASS:\n            return new MinimalClassNameIdResolver(baseType, config.getTypeFactory());\n        case NAME:\n            return TypeNameIdResolver.construct(config, baseType, subtypes, forSer, forDeser);\n        case NONE: \n            return null;\n        case CUSTOM: \n        }\n        throw new IllegalStateException(\"Do not know how to construct standard type id resolver for idType: \"+_idType);\n    }\n}\n",
      "fixed_full_code": "package com.fasterxml.jackson.databind.jsontype.impl;\n\nimport java.util.Collection;\n\nimport com.fasterxml.jackson.annotation.JsonTypeInfo;\n\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.annotation.NoClass;\nimport com.fasterxml.jackson.databind.cfg.MapperConfig;\nimport com.fasterxml.jackson.databind.jsontype.*;\n\n\npublic class StdTypeResolverBuilder implements TypeResolverBuilder<StdTypeResolverBuilder> { protected JsonTypeInfo.Id _idType; protected JsonTypeInfo.As _includeAs; protected String _typeProperty; protected boolean _typeIdVisible = false; protected Class<?> _defaultImpl; protected TypeIdResolver _customIdResolver; public StdTypeResolverBuilder() { }\n\n    public static StdTypeResolverBuilder noTypeInfoBuilder() {\n        return new StdTypeResolverBuilder().init(JsonTypeInfo.Id.NONE, null);\n    }\n\n    @Override\n    public StdTypeResolverBuilder init(JsonTypeInfo.Id idType, TypeIdResolver idRes) {\n        \n        if (idType == null) {\n            throw new IllegalArgumentException(\"idType can not be null\");\n        }\n        _idType = idType;\n        _customIdResolver = idRes;\n        \n        _typeProperty = idType.getDefaultPropertyName();\n        return this;\n    }\n\n    @Override\n    public TypeSerializer buildTypeSerializer(SerializationConfig config, JavaType baseType, Collection<NamedType> subtypes) {\n        if (_idType == JsonTypeInfo.Id.NONE) { return null; }\n        \n        \n        if (baseType.isPrimitive()) {\n            return null;\n        }\n        TypeIdResolver idRes = idResolver(config, baseType, subtypes, true, false);\n        switch (_includeAs) {\n        case WRAPPER_ARRAY:\n            return new AsArrayTypeSerializer(idRes, null);\n        case PROPERTY:\n            return new AsPropertyTypeSerializer(idRes, null, _typeProperty);\n        case WRAPPER_OBJECT:\n            return new AsWrapperTypeSerializer(idRes, null);\n        case EXTERNAL_PROPERTY:\n            return new AsExternalTypeSerializer(idRes, null, _typeProperty);\n        case EXISTING_PROPERTY:\n        \t\n        \treturn new AsExistingPropertyTypeSerializer(idRes, null, _typeProperty);\n        }\n        throw new IllegalStateException(\"Do not know how to construct standard type serializer for inclusion type: \"+_includeAs);\n    }\n\n    \n    \n    \n    \n    \n\n    @Override\n    public TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes) {\n        if (_idType == JsonTypeInfo.Id.NONE) { return null; }\n        \n        \n        if (baseType.isPrimitive()) {\n            return null;\n        }\n\n        TypeIdResolver idRes = idResolver(config, baseType, subtypes, false, true);\n\n        JavaType defaultImpl;\n\n        if (_defaultImpl == null) {\n            defaultImpl = null;\n        } else {\n            \n            \n            \n            \n            \n            \n            if ((_defaultImpl == Void.class)\n                     || (_defaultImpl == NoClass.class)) {\n                defaultImpl = config.getTypeFactory().constructType(_defaultImpl);\n            } else {\n                defaultImpl = config.getTypeFactory()\n                    .constructSpecializedType(baseType, _defaultImpl);\n            }\n        }\n\n        \n        switch (_includeAs) {\n        case WRAPPER_ARRAY:\n            return new AsArrayTypeDeserializer(baseType, idRes,\n                    _typeProperty, _typeIdVisible, defaultImpl);\n        case PROPERTY:\n        case EXISTING_PROPERTY: \n            return new AsPropertyTypeDeserializer(baseType, idRes,\n                    _typeProperty, _typeIdVisible, defaultImpl, _includeAs);\n        case WRAPPER_OBJECT:\n            return new AsWrapperTypeDeserializer(baseType, idRes,\n                    _typeProperty, _typeIdVisible, defaultImpl);\n        case EXTERNAL_PROPERTY:\n            return new AsExternalTypeDeserializer(baseType, idRes,\n                    _typeProperty, _typeIdVisible, defaultImpl);\n        }\n        throw new IllegalStateException(\"Do not know how to construct standard type serializer for inclusion type: \"+_includeAs);\n    }\n\n    \n\n    @Override\n    public StdTypeResolverBuilder inclusion(JsonTypeInfo.As includeAs) {\n        if (includeAs == null) {\n            throw new IllegalArgumentException(\"includeAs can not be null\");\n        }\n        _includeAs = includeAs;\n        return this;\n    }\n\n    \n    @Override\n    public StdTypeResolverBuilder typeProperty(String typeIdPropName) {\n        \n        if (typeIdPropName == null || typeIdPropName.length() == 0) {\n            typeIdPropName = _idType.getDefaultPropertyName();\n        }\n        _typeProperty = typeIdPropName;\n        return this;\n    }\n\n    @Override\n    public StdTypeResolverBuilder defaultImpl(Class<?> defaultImpl) {\n        _defaultImpl = defaultImpl;\n        return this;\n    }\n\n    @Override\n    public StdTypeResolverBuilder typeIdVisibility(boolean isVisible) {\n        _typeIdVisible = isVisible;\n        return this;\n    }\n    \n    \n\n    @Override public Class<?> getDefaultImpl() { return _defaultImpl; }\n\n    public String getTypeProperty() { return _typeProperty; }\n    public boolean isTypeIdVisible() { return _typeIdVisible; }\n    \n    \n    \n    \n    protected TypeIdResolver idResolver(MapperConfig<?> config, JavaType baseType, Collection<NamedType> subtypes, boolean forSer, boolean forDeser) {\n        \n        if (_customIdResolver != null) { return _customIdResolver; }\n        if (_idType == null) throw new IllegalStateException(\"Can not build, 'init()' not yet called\");\n        switch (_idType) {\n        case CLASS:\n            return new ClassNameIdResolver(baseType, config.getTypeFactory());\n        case MINIMAL_CLASS:\n            return new MinimalClassNameIdResolver(baseType, config.getTypeFactory());\n        case NAME:\n            return TypeNameIdResolver.construct(config, baseType, subtypes, forSer, forDeser);\n        case NONE: \n            return null;\n        case CUSTOM: \n        }\n        throw new IllegalStateException(\"Do not know how to construct standard type id resolver for idType: \"+_idType);\n    }\n}\n",
      "buggy_signatures": [
        "public static StdTypeResolverBuilder noTypeInfoBuilder()",
        "public StdTypeResolverBuilder init(JsonTypeInfo.Id idType, TypeIdResolver idRes)",
        "public TypeSerializer buildTypeSerializer(SerializationConfig config, JavaType baseType, Collection<NamedType> subtypes)",
        "public TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes)",
        "public StdTypeResolverBuilder inclusion(JsonTypeInfo.As includeAs)",
        "public StdTypeResolverBuilder typeProperty(String typeIdPropName)",
        "public StdTypeResolverBuilder defaultImpl(Class<?> defaultImpl)",
        "public StdTypeResolverBuilder typeIdVisibility(boolean isVisible)",
        "public Class<?> getDefaultImpl()",
        "public String getTypeProperty()",
        "public boolean isTypeIdVisible()",
        "protected TypeIdResolver idResolver(MapperConfig<?> config, JavaType baseType, Collection<NamedType> subtypes, boolean forSer, boolean forDeser)"
      ],
      "fixed_signatures": [
        "public static StdTypeResolverBuilder noTypeInfoBuilder()",
        "public StdTypeResolverBuilder init(JsonTypeInfo.Id idType, TypeIdResolver idRes)",
        "public TypeSerializer buildTypeSerializer(SerializationConfig config, JavaType baseType, Collection<NamedType> subtypes)",
        "public TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes)",
        "public StdTypeResolverBuilder inclusion(JsonTypeInfo.As includeAs)",
        "public StdTypeResolverBuilder typeProperty(String typeIdPropName)",
        "public StdTypeResolverBuilder defaultImpl(Class<?> defaultImpl)",
        "public StdTypeResolverBuilder typeIdVisibility(boolean isVisible)",
        "public Class<?> getDefaultImpl()",
        "public String getTypeProperty()",
        "public boolean isTypeIdVisible()",
        "protected TypeIdResolver idResolver(MapperConfig<?> config, JavaType baseType, Collection<NamedType> subtypes, boolean forSer, boolean forDeser)"
      ],
      "methods": [
        {
          "buggy_method": "  public TypeSerializer buildTypeSerializer(SerializationConfig config, JavaType baseType, Collection<NamedType> subtypes) {\n  if (_idType == JsonTypeInfo.Id.NONE) { return null; }\n  \n  \n  TypeIdResolver idRes = idResolver(config, baseType, subtypes, true, false);\n  switch (_includeAs) {\n  case WRAPPER_ARRAY:\n  return new AsArrayTypeSerializer(idRes, null);\n  case PROPERTY:\n  return new AsPropertyTypeSerializer(idRes, null, _typeProperty);\n  case WRAPPER_OBJECT:\n  return new AsWrapperTypeSerializer(idRes, null);\n  case EXTERNAL_PROPERTY:\n  return new AsExternalTypeSerializer(idRes, null, _typeProperty);\n  case EXISTING_PROPERTY:\n  \t\n  \treturn new AsExistingPropertyTypeSerializer(idRes, null, _typeProperty);\n  }\n  throw new IllegalStateException(\"Do not know how to construct standard type serializer for inclusion type: \"+_includeAs);\n  }",
          "fixed_method": "  public TypeSerializer buildTypeSerializer(SerializationConfig config, JavaType baseType, Collection<NamedType> subtypes) {\n  if (_idType == JsonTypeInfo.Id.NONE) { return null; }\n  \n  \n  if (baseType.isPrimitive()) {\n  return null;\n  }\n  TypeIdResolver idRes = idResolver(config, baseType, subtypes, true, false);\n  switch (_includeAs) {\n  case WRAPPER_ARRAY:\n  return new AsArrayTypeSerializer(idRes, null);\n  case PROPERTY:\n  return new AsPropertyTypeSerializer(idRes, null, _typeProperty);\n  case WRAPPER_OBJECT:\n  return new AsWrapperTypeSerializer(idRes, null);\n  case EXTERNAL_PROPERTY:\n  return new AsExternalTypeSerializer(idRes, null, _typeProperty);\n  case EXISTING_PROPERTY:\n  \t\n  \treturn new AsExistingPropertyTypeSerializer(idRes, null, _typeProperty);\n  }\n  throw new IllegalStateException(\"Do not know how to construct standard type serializer for inclusion type: \"+_includeAs);\n  }",
          "diff": [
            "@@ -71,6 +71,9 @@",
            "         if (_idType == JsonTypeInfo.Id.NONE) { return null; }\n",
            "         // 03-Oct-2016, tatu: As per [databind#1395] better prevent use for primitives,\n",
            "         //    regardless of setting\n",
            "+        if (baseType.isPrimitive()) {\n",
            "+            return null;\n",
            "+        }\n",
            "         TypeIdResolver idRes = idResolver(config, baseType, subtypes, true, false);\n",
            "         switch (_includeAs) {\n",
            "         case WRAPPER_ARRAY:\n"
          ],
          "changed_lines": 3
        },
        {
          "buggy_method": "  public TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes) {\n  if (_idType == JsonTypeInfo.Id.NONE) { return null; }\n  \n  \n\n  TypeIdResolver idRes = idResolver(config, baseType, subtypes, false, true);\n\n  JavaType defaultImpl;\n\n  if (_defaultImpl == null) {\n  defaultImpl = null;\n  } else {\n  \n  \n  \n  \n  \n  \n  if ((_defaultImpl == Void.class)\n  || (_defaultImpl == NoClass.class)) {\n  defaultImpl = config.getTypeFactory().constructType(_defaultImpl);\n  } else {\n  defaultImpl = config.getTypeFactory()\n  .constructSpecializedType(baseType, _defaultImpl);\n  }\n  }\n\n  \n  switch (_includeAs) {\n  case WRAPPER_ARRAY:\n  return new AsArrayTypeDeserializer(baseType, idRes,\n  _typeProperty, _typeIdVisible, defaultImpl);\n  case PROPERTY:\n  case EXISTING_PROPERTY: \n  return new AsPropertyTypeDeserializer(baseType, idRes,\n  _typeProperty, _typeIdVisible, defaultImpl, _includeAs);\n  case WRAPPER_OBJECT:\n  return new AsWrapperTypeDeserializer(baseType, idRes,\n  _typeProperty, _typeIdVisible, defaultImpl);\n  case EXTERNAL_PROPERTY:\n  return new AsExternalTypeDeserializer(baseType, idRes,\n  _typeProperty, _typeIdVisible, defaultImpl);\n  }\n  throw new IllegalStateException(\"Do not know how to construct standard type serializer for inclusion type: \"+_includeAs);\n  }",
          "fixed_method": "  public TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes) {\n  if (_idType == JsonTypeInfo.Id.NONE) { return null; }\n  \n  \n  if (baseType.isPrimitive()) {\n  return null;\n  }\n\n  TypeIdResolver idRes = idResolver(config, baseType, subtypes, false, true);\n\n  JavaType defaultImpl;\n\n  if (_defaultImpl == null) {\n  defaultImpl = null;\n  } else {\n  \n  \n  \n  \n  \n  \n  if ((_defaultImpl == Void.class)\n  || (_defaultImpl == NoClass.class)) {\n  defaultImpl = config.getTypeFactory().constructType(_defaultImpl);\n  } else {\n  defaultImpl = config.getTypeFactory()\n  .constructSpecializedType(baseType, _defaultImpl);\n  }\n  }\n\n  \n  switch (_includeAs) {\n  case WRAPPER_ARRAY:\n  return new AsArrayTypeDeserializer(baseType, idRes,\n  _typeProperty, _typeIdVisible, defaultImpl);\n  case PROPERTY:\n  case EXISTING_PROPERTY: \n  return new AsPropertyTypeDeserializer(baseType, idRes,\n  _typeProperty, _typeIdVisible, defaultImpl, _includeAs);\n  case WRAPPER_OBJECT:\n  return new AsWrapperTypeDeserializer(baseType, idRes,\n  _typeProperty, _typeIdVisible, defaultImpl);\n  case EXTERNAL_PROPERTY:\n  return new AsExternalTypeDeserializer(baseType, idRes,\n  _typeProperty, _typeIdVisible, defaultImpl);\n  }\n  throw new IllegalStateException(\"Do not know how to construct standard type serializer for inclusion type: \"+_includeAs);\n  }",
          "diff": [
            "@@ -101,6 +104,9 @@",
            "         if (_idType == JsonTypeInfo.Id.NONE) { return null; }\n",
            "         // 03-Oct-2016, tatu: As per [databind#1395] better prevent use for primitives,\n",
            "         //    regardless of setting\n",
            "+        if (baseType.isPrimitive()) {\n",
            "+            return null;\n",
            "+        }\n",
            " \n",
            "         TypeIdResolver idRes = idResolver(config, baseType, subtypes, false, true);\n",
            " \n"
          ],
          "changed_lines": 3
        }
      ]
    }
  ]
}
