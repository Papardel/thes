{
  "bug_id": "26",
  "failed_tests": {
    "org.joda.time.TestDateTimeZoneCutover": [
      {
        "methodName": "testWithSecondOfMinuteInDstChange",
        "error": "junit.framework.ComparisonFailure",
        "message": "expected:<...10-31T02:30:00.123+0[2]:00> but was:<...10-31T02:30:00.123+0[1]:00>",
        "fail_line": "        assertEquals(\"2010-10-31T02:30:00.123+02:00\", test.toString());",
        "test_source": "  public void testWithSecondOfMinuteInDstChange() {\n  DateTime dateTime = new DateTime(\"2010-10-31T02:30:10.123+02:00\", ZONE_PARIS);\n  assertEquals(\"2010-10-31T02:30:10.123+02:00\", dateTime.toString());\n  DateTime test = dateTime.withSecondOfMinute(0);\n  assertEquals(\"2010-10-31T02:30:00.123+02:00\", test.toString());\n  }",
        "stack": [
          "TestDateTimeZoneCutover.testWithSecondOfMinuteInDstChange line 1101"
        ]
      },
      {
        "methodName": "testWithMinuteOfHourInDstChange",
        "error": "junit.framework.ComparisonFailure",
        "message": "expected:<...10-31T02:00:10.123+0[2]:00> but was:<...10-31T02:00:10.123+0[1]:00>",
        "fail_line": "        assertEquals(\"2010-10-31T02:00:10.123+02:00\", test.toString());",
        "test_source": "  public void testWithMinuteOfHourInDstChange() {\n  DateTime dateTime = new DateTime(\"2010-10-31T02:30:10.123+02:00\", ZONE_PARIS);\n  assertEquals(\"2010-10-31T02:30:10.123+02:00\", dateTime.toString());\n  DateTime test = dateTime.withMinuteOfHour(0);\n  assertEquals(\"2010-10-31T02:00:10.123+02:00\", test.toString());\n  }",
        "stack": [
          "TestDateTimeZoneCutover.testWithMinuteOfHourInDstChange line 1094"
        ]
      },
      {
        "methodName": "testWithMinuteOfHourInDstChange_mockZone",
        "error": "junit.framework.ComparisonFailure",
        "message": "expected:<...10-31T01:30:00.000+0[1:0]0> but was:<...10-31T01:30:00.000+0[0:3]0>",
        "fail_line": "        assertEquals(\"2010-10-31T01:30:00.000+01:00\", testPre1.toString());  // retain offset",
        "test_source": "  public void testWithMinuteOfHourInDstChange_mockZone() {\n  DateTime cutover = new DateTime(2010, 10, 31, 1, 15, DateTimeZone.forOffsetHoursMinutes(0, 30));\n  assertEquals(\"2010-10-31T01:15:00.000+00:30\", cutover.toString());\n  DateTimeZone halfHourZone = new MockZone(cutover.getMillis(), 3600000, -1800);\n  DateTime pre = new DateTime(2010, 10, 31, 1, 0, halfHourZone);\n  assertEquals(\"2010-10-31T01:00:00.000+01:00\", pre.toString());\n  DateTime post = new DateTime(2010, 10, 31, 1, 59, halfHourZone);\n  assertEquals(\"2010-10-31T01:59:00.000+00:30\", post.toString());\n  \n  DateTime testPre1 = pre.withMinuteOfHour(30);\n  assertEquals(\"2010-10-31T01:30:00.000+01:00\", testPre1.toString());  // retain offset\n  DateTime testPre2 = pre.withMinuteOfHour(50);\n  assertEquals(\"2010-10-31T01:50:00.000+00:30\", testPre2.toString());\n  \n  DateTime testPost1 = post.withMinuteOfHour(30);\n  assertEquals(\"2010-10-31T01:30:00.000+00:30\", testPost1.toString());  // retain offset\n  DateTime testPost2 = post.withMinuteOfHour(10);\n  assertEquals(\"2010-10-31T01:10:00.000+01:00\", testPost2.toString());\n  }",
        "stack": [
          "TestDateTimeZoneCutover.testWithMinuteOfHourInDstChange_mockZone line 1073"
        ]
      },
      {
        "methodName": "testBug2182444_usCentral",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<2008-11-02T01:00:00.000-06:00> but was:<2008-11-02T01:00:00.000-05:00>",
        "fail_line": "        assertEquals(usCentralStandardInUSCentral, usCentralStandardInUSCentral.withHourOfDay(1));",
        "test_source": "  public void testBug2182444_usCentral() {\n  Chronology chronUSCentral = GregorianChronology.getInstance(DateTimeZone.forID(\"US/Central\"));\n  Chronology chronUTC = GregorianChronology.getInstance(DateTimeZone.UTC);\n  DateTime usCentralStandardInUTC = new DateTime(2008, 11, 2, 7, 0, 0, 0, chronUTC);\n  DateTime usCentralDaylightInUTC = new DateTime(2008, 11, 2, 6, 0, 0, 0, chronUTC);\n  assertTrue(\"Should be standard time\", chronUSCentral.getZone().isStandardOffset(usCentralStandardInUTC.getMillis()));\n  assertFalse(\"Should be daylight time\", chronUSCentral.getZone().isStandardOffset(usCentralDaylightInUTC.getMillis()));\n  \n  DateTime usCentralStandardInUSCentral = usCentralStandardInUTC.toDateTime(chronUSCentral);\n  DateTime usCentralDaylightInUSCentral = usCentralDaylightInUTC.toDateTime(chronUSCentral);\n  assertEquals(1, usCentralStandardInUSCentral.getHourOfDay());\n  assertEquals(usCentralStandardInUSCentral.getHourOfDay(), usCentralDaylightInUSCentral.getHourOfDay());\n  assertTrue(usCentralStandardInUSCentral.getMillis() != usCentralDaylightInUSCentral.getMillis());\n  assertEquals(usCentralStandardInUSCentral, usCentralStandardInUSCentral.withHourOfDay(1));\n  assertEquals(usCentralStandardInUSCentral.getMillis() + 3, usCentralStandardInUSCentral.withMillisOfSecond(3).getMillis());\n  assertEquals(usCentralDaylightInUSCentral, usCentralDaylightInUSCentral.withHourOfDay(1));\n  assertEquals(usCentralDaylightInUSCentral.getMillis() + 3, usCentralDaylightInUSCentral.withMillisOfSecond(3).getMillis());\n  }",
        "stack": [
          "TestDateTimeZoneCutover.testBug2182444_usCentral line 1166"
        ]
      },
      {
        "methodName": "testWithMillisOfSecondInDstChange_Paris_summer",
        "error": "junit.framework.ComparisonFailure",
        "message": "expected:<...10-31T02:30:10.000+0[2]:00> but was:<...10-31T02:30:10.000+0[1]:00>",
        "fail_line": "        assertEquals(\"2010-10-31T02:30:10.000+02:00\", test.toString());",
        "test_source": "  public void testWithMillisOfSecondInDstChange_Paris_summer() {\n  DateTime dateTime = new DateTime(\"2010-10-31T02:30:10.123+02:00\", ZONE_PARIS);\n  assertEquals(\"2010-10-31T02:30:10.123+02:00\", dateTime.toString());\n  DateTime test = dateTime.withMillisOfSecond(0);\n  assertEquals(\"2010-10-31T02:30:10.000+02:00\", test.toString());\n  }",
        "stack": [
          "TestDateTimeZoneCutover.testWithMillisOfSecondInDstChange_Paris_summer line 1108"
        ]
      },
      {
        "methodName": "testWithHourOfDayInDstChange",
        "error": "junit.framework.ComparisonFailure",
        "message": "expected:<...10-31T02:30:10.123+0[2]:00> but was:<...10-31T02:30:10.123+0[1]:00>",
        "fail_line": "        assertEquals(\"2010-10-31T02:30:10.123+02:00\", test.toString());",
        "test_source": "  public void testWithHourOfDayInDstChange() {\n  DateTime dateTime = new DateTime(\"2010-10-31T02:30:10.123+02:00\", ZONE_PARIS);\n  assertEquals(\"2010-10-31T02:30:10.123+02:00\", dateTime.toString());\n  DateTime test = dateTime.withHourOfDay(2);\n  assertEquals(\"2010-10-31T02:30:10.123+02:00\", test.toString());\n  }",
        "stack": [
          "TestDateTimeZoneCutover.testWithHourOfDayInDstChange line 1087"
        ]
      },
      {
        "methodName": "testWithMillisOfSecondInDstChange_NewYork_winter",
        "error": "junit.framework.ComparisonFailure",
        "message": "expected:<...11-04T01:30:00.000-0[5]:00> but was:<...11-04T01:30:00.000-0[4]:00>",
        "fail_line": "        assertEquals(\"2007-11-04T01:30:00.000-05:00\", test.toString());",
        "test_source": "  public void testWithMillisOfSecondInDstChange_NewYork_winter() {\n  DateTime dateTime = new DateTime(\"2007-11-04T01:30:00.123-05:00\", ZONE_NEW_YORK);\n  assertEquals(\"2007-11-04T01:30:00.123-05:00\", dateTime.toString());\n  DateTime test = dateTime.withMillisOfSecond(0);\n  assertEquals(\"2007-11-04T01:30:00.000-05:00\", test.toString());\n  }",
        "stack": [
          "TestDateTimeZoneCutover.testWithMillisOfSecondInDstChange_NewYork_winter line 1129"
        ]
      },
      {
        "methodName": "testBug2182444_ausNSW",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<2008-04-06T02:00:00.000+11:00> but was:<2008-04-06T02:00:00.000+10:00>",
        "fail_line": "        assertEquals(australiaNSWDaylightInAusraliaNSW, australiaNSWDaylightInAusraliaNSW.withHourOfDay(2));",
        "test_source": "  public void testBug2182444_ausNSW() {\n  Chronology chronAusNSW = GregorianChronology.getInstance(DateTimeZone.forID(\"Australia/NSW\"));\n  Chronology chronUTC = GregorianChronology.getInstance(DateTimeZone.UTC);\n  DateTime australiaNSWStandardInUTC = new DateTime(2008, 4, 5, 16, 0, 0, 0, chronUTC);\n  DateTime australiaNSWDaylightInUTC = new DateTime(2008, 4, 5, 15, 0, 0, 0, chronUTC);\n  assertTrue(\"Should be standard time\", chronAusNSW.getZone().isStandardOffset(australiaNSWStandardInUTC.getMillis()));\n  assertFalse(\"Should be daylight time\", chronAusNSW.getZone().isStandardOffset(australiaNSWDaylightInUTC.getMillis()));\n  \n  DateTime australiaNSWStandardInAustraliaNSW = australiaNSWStandardInUTC.toDateTime(chronAusNSW);\n  DateTime australiaNSWDaylightInAusraliaNSW = australiaNSWDaylightInUTC.toDateTime(chronAusNSW);\n  assertEquals(2, australiaNSWStandardInAustraliaNSW.getHourOfDay());\n  assertEquals(australiaNSWStandardInAustraliaNSW.getHourOfDay(), australiaNSWDaylightInAusraliaNSW.getHourOfDay());\n  assertTrue(australiaNSWStandardInAustraliaNSW.getMillis() != australiaNSWDaylightInAusraliaNSW.getMillis());\n  assertEquals(australiaNSWStandardInAustraliaNSW, australiaNSWStandardInAustraliaNSW.withHourOfDay(2));\n  assertEquals(australiaNSWStandardInAustraliaNSW.getMillis() + 3, australiaNSWStandardInAustraliaNSW.withMillisOfSecond(3).getMillis());\n  assertEquals(australiaNSWDaylightInAusraliaNSW, australiaNSWDaylightInAusraliaNSW.withHourOfDay(2));\n  assertEquals(australiaNSWDaylightInAusraliaNSW.getMillis() + 3, australiaNSWDaylightInAusraliaNSW.withMillisOfSecond(3).getMillis());\n  }",
        "stack": [
          "TestDateTimeZoneCutover.testBug2182444_ausNSW line 1187"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/joda/time/chrono/ZonedChronology.java",
      "buggy_full_code": "\npackage org.joda.time.chrono;\n\nimport java.util.HashMap;\nimport java.util.Locale;\n\nimport org.joda.time.Chronology;\nimport org.joda.time.DateTimeConstants;\nimport org.joda.time.DateTimeField;\nimport org.joda.time.DateTimeZone;\nimport org.joda.time.DurationField;\nimport org.joda.time.IllegalFieldValueException;\nimport org.joda.time.Instant;\nimport org.joda.time.ReadablePartial;\nimport org.joda.time.field.BaseDateTimeField;\nimport org.joda.time.field.BaseDurationField;\nimport org.joda.time.format.DateTimeFormat;\n\n\npublic final class ZonedChronology extends AssembledChronology { private static final long serialVersionUID = -1079258847191166848L; public static ZonedChronology getInstance(Chronology base, DateTimeZone zone) {\n        if (base == null) {\n            throw new IllegalArgumentException(\"Must supply a chronology\");\n        }\n        base = base.withUTC();\n        if (base == null) {\n            throw new IllegalArgumentException(\"UTC chronology must not be null\");\n        }\n        if (zone == null) {\n            throw new IllegalArgumentException(\"DateTimeZone must not be null\");\n        }\n        return new ZonedChronology(base, zone);\n    }\n\n    static boolean useTimeArithmetic(DurationField field) {\n        \n        \n        return field != null && field.getUnitMillis() < DateTimeConstants.MILLIS_PER_HOUR * 12;\n    }\n\n    \n    private ZonedChronology(Chronology base, DateTimeZone zone) {\n        super(base, zone);\n    }\n\n    public DateTimeZone getZone() {\n        return (DateTimeZone)getParam();\n    }\n\n    public Chronology withUTC() {\n        return getBase();\n    }\n\n    public Chronology withZone(DateTimeZone zone) {\n        if (zone == null) {\n            zone = DateTimeZone.getDefault();\n        }\n        if (zone == getParam()) {\n            return this;\n        }\n        if (zone == DateTimeZone.UTC) {\n            return getBase();\n        }\n        return new ZonedChronology(getBase(), zone);\n    }\n\n    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int millisOfDay) throws IllegalArgumentException {\n        return localToUTC(getBase().getDateTimeMillis\n                          (year, monthOfYear, dayOfMonth, millisOfDay));\n    }\n\n    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException {\n        return localToUTC(getBase().getDateTimeMillis\n                          (year, monthOfYear, dayOfMonth, \n                           hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond));\n    }\n\n    public long getDateTimeMillis(long instant, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException {\n        return localToUTC(getBase().getDateTimeMillis\n                          (instant + getZone().getOffset(instant),\n                           hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond));\n    }\n\n    \n    private long localToUTC(long instant) {\n        DateTimeZone zone = getZone();\n        int offset = zone.getOffsetFromLocal(instant);\n        instant -= offset;\n        if (offset != zone.getOffset(instant)) {\n            throw new IllegalArgumentException\n                (\"Illegal instant due to time zone offset transition: \" +\n                    DateTimeFormat.forPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSS\").print(new Instant(instant)));\n        }\n        return instant;\n    }\n\n    protected void assemble(Fields fields) {\n        \n        \n        HashMap<Object, Object> converted = new HashMap<Object, Object>();\n\n        \n\n        fields.eras = convertField(fields.eras, converted);\n        fields.centuries = convertField(fields.centuries, converted);\n        fields.years = convertField(fields.years, converted);\n        fields.months = convertField(fields.months, converted);\n        fields.weekyears = convertField(fields.weekyears, converted);\n        fields.weeks = convertField(fields.weeks, converted);\n        fields.days = convertField(fields.days, converted);\n\n        fields.halfdays = convertField(fields.halfdays, converted);\n        fields.hours = convertField(fields.hours, converted);\n        fields.minutes = convertField(fields.minutes, converted);\n        fields.seconds = convertField(fields.seconds, converted);\n        fields.millis = convertField(fields.millis, converted);\n\n        \n\n        fields.year = convertField(fields.year, converted);\n        fields.yearOfEra = convertField(fields.yearOfEra, converted);\n        fields.yearOfCentury = convertField(fields.yearOfCentury, converted);\n        fields.centuryOfEra = convertField(fields.centuryOfEra, converted);\n        fields.era = convertField(fields.era, converted);\n        fields.dayOfWeek = convertField(fields.dayOfWeek, converted);\n        fields.dayOfMonth = convertField(fields.dayOfMonth, converted);\n        fields.dayOfYear = convertField(fields.dayOfYear, converted);\n        fields.monthOfYear = convertField(fields.monthOfYear, converted);\n        fields.weekOfWeekyear = convertField(fields.weekOfWeekyear, converted);\n        fields.weekyear = convertField(fields.weekyear, converted);\n        fields.weekyearOfCentury = convertField(fields.weekyearOfCentury, converted);\n\n        fields.millisOfSecond = convertField(fields.millisOfSecond, converted);\n        fields.millisOfDay = convertField(fields.millisOfDay, converted);\n        fields.secondOfMinute = convertField(fields.secondOfMinute, converted);\n        fields.secondOfDay = convertField(fields.secondOfDay, converted);\n        fields.minuteOfHour = convertField(fields.minuteOfHour, converted);\n        fields.minuteOfDay = convertField(fields.minuteOfDay, converted);\n        fields.hourOfDay = convertField(fields.hourOfDay, converted);\n        fields.hourOfHalfday = convertField(fields.hourOfHalfday, converted);\n        fields.clockhourOfDay = convertField(fields.clockhourOfDay, converted);\n        fields.clockhourOfHalfday = convertField(fields.clockhourOfHalfday, converted);\n        fields.halfdayOfDay = convertField(fields.halfdayOfDay, converted);\n    }\n\n    private DurationField convertField(DurationField field, HashMap<Object, Object> converted) {\n        if (field == null || !field.isSupported()) {\n            return field;\n        }\n        if (converted.containsKey(field)) {\n            return (DurationField)converted.get(field);\n        }\n        ZonedDurationField zonedField = new ZonedDurationField(field, getZone());\n        converted.put(field, zonedField);\n        return zonedField;\n    }\n\n    private DateTimeField convertField(DateTimeField field, HashMap<Object, Object> converted) {\n        if (field == null || !field.isSupported()) {\n            return field;\n        }\n        if (converted.containsKey(field)) {\n            return (DateTimeField)converted.get(field);\n        }\n        ZonedDateTimeField zonedField =\n            new ZonedDateTimeField(field, getZone(),\n                                   convertField(field.getDurationField(), converted),\n                                   convertField(field.getRangeDurationField(), converted),\n                                   convertField(field.getLeapDurationField(), converted));\n        converted.put(field, zonedField);\n        return zonedField;\n    }\n\n    \n    \n    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj instanceof ZonedChronology == false) {\n            return false;\n        }\n        ZonedChronology chrono = (ZonedChronology) obj;\n        return\n            getBase().equals(chrono.getBase()) &&\n            getZone().equals(chrono.getZone());\n    }\n\n    \n    public int hashCode() {\n        return 326565 + getZone().hashCode() * 11 + getBase().hashCode() * 7;\n    }\n\n    \n    public String toString() {\n        return \"ZonedChronology[\" + getBase() + \", \" + getZone().getID() + ']';\n    }\n\n    \n    \n    static class ZonedDurationField extends BaseDurationField { private static final long serialVersionUID = -485345310999208286L; final DurationField iField; final boolean iTimeField; final DateTimeZone iZone; ZonedDurationField(DurationField field, DateTimeZone zone) {\n            super(field.getType());\n            if (!field.isSupported()) {\n                throw new IllegalArgumentException();\n            }\n            iField = field;\n            iTimeField = useTimeArithmetic(field);\n            iZone = zone;\n        }\n\n        public boolean isPrecise() {\n            return iTimeField ? iField.isPrecise() : iField.isPrecise() && this.iZone.isFixed();\n        }\n\n        public long getUnitMillis() {\n            return iField.getUnitMillis();\n        }\n\n        public int getValue(long duration, long instant) {\n            return iField.getValue(duration, addOffset(instant));\n        }\n\n        public long getValueAsLong(long duration, long instant) {\n            return iField.getValueAsLong(duration, addOffset(instant));\n        }\n\n        public long getMillis(int value, long instant) {\n            return iField.getMillis(value, addOffset(instant));\n        }\n\n        public long getMillis(long value, long instant) {\n            return iField.getMillis(value, addOffset(instant));\n        }\n\n        public long add(long instant, int value) {\n            int offset = getOffsetToAdd(instant);\n            instant = iField.add(instant + offset, value);\n            return instant - (iTimeField ? offset : getOffsetFromLocalToSubtract(instant));\n        }\n\n        public long add(long instant, long value) {\n            int offset = getOffsetToAdd(instant);\n            instant = iField.add(instant + offset, value);\n            return instant - (iTimeField ? offset : getOffsetFromLocalToSubtract(instant));\n        }\n\n        public int getDifference(long minuendInstant, long subtrahendInstant) {\n            int offset = getOffsetToAdd(subtrahendInstant);\n            return iField.getDifference\n                (minuendInstant + (iTimeField ? offset : getOffsetToAdd(minuendInstant)),\n                 subtrahendInstant + offset);\n        }\n\n        public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n            int offset = getOffsetToAdd(subtrahendInstant);\n            return iField.getDifferenceAsLong\n                (minuendInstant + (iTimeField ? offset : getOffsetToAdd(minuendInstant)),\n                 subtrahendInstant + offset);\n        }\n\n        private int getOffsetToAdd(long instant) {\n            int offset = this.iZone.getOffset(instant);\n            long sum = instant + offset;\n            \n            if ((instant ^ sum) < 0 && (instant ^ offset) >= 0) {\n                throw new ArithmeticException(\"Adding time zone offset caused overflow\");\n            }\n            return offset;\n        }\n\n        private int getOffsetFromLocalToSubtract(long instant) {\n            int offset = this.iZone.getOffsetFromLocal(instant);\n            long diff = instant - offset;\n            \n            if ((instant ^ diff) < 0 && (instant ^ offset) < 0) {\n                throw new ArithmeticException(\"Subtracting time zone offset caused overflow\");\n            }\n            return offset;\n        }\n\n        private long addOffset(long instant) {\n            return iZone.convertUTCToLocal(instant);\n        }\n    }\n\n    \n    static final class ZonedDateTimeField extends BaseDateTimeField { private static final long serialVersionUID = -3968986277775529794L; final DateTimeField iField; final DateTimeZone iZone; final DurationField iDurationField; final boolean iTimeField; final DurationField iRangeDurationField; final DurationField iLeapDurationField; ZonedDateTimeField(DateTimeField field, DateTimeZone zone, DurationField durationField, DurationField rangeDurationField, DurationField leapDurationField) {\n            super(field.getType());\n            if (!field.isSupported()) {\n                throw new IllegalArgumentException();\n            }\n            iField = field;\n            iZone = zone;\n            iDurationField = durationField;\n            iTimeField = useTimeArithmetic(durationField);\n            iRangeDurationField = rangeDurationField;\n            iLeapDurationField = leapDurationField;\n        }\n\n        public boolean isLenient() {\n            return iField.isLenient();\n        }\n\n        public int get(long instant) {\n            long localInstant = iZone.convertUTCToLocal(instant);\n            return iField.get(localInstant);\n        }\n\n        public String getAsText(long instant, Locale locale) {\n            long localInstant = iZone.convertUTCToLocal(instant);\n            return iField.getAsText(localInstant, locale);\n        }\n\n        public String getAsShortText(long instant, Locale locale) {\n            long localInstant = iZone.convertUTCToLocal(instant);\n            return iField.getAsShortText(localInstant, locale);\n        }\n\n        public String getAsText(int fieldValue, Locale locale) {\n            return iField.getAsText(fieldValue, locale);\n        }\n\n        public String getAsShortText(int fieldValue, Locale locale) {\n            return iField.getAsShortText(fieldValue, locale);\n        }\n\n        public long add(long instant, int value) {\n            if (iTimeField) {\n                int offset = getOffsetToAdd(instant);\n                long localInstant = iField.add(instant + offset, value);\n                return localInstant - offset;\n            } else {\n               long localInstant = iZone.convertUTCToLocal(instant);\n               localInstant = iField.add(localInstant, value);\n               return iZone.convertLocalToUTC(localInstant, false);\n            }\n        }\n\n        public long add(long instant, long value) {\n            if (iTimeField) {\n                int offset = getOffsetToAdd(instant);\n                long localInstant = iField.add(instant + offset, value);\n                return localInstant - offset;\n            } else {\n               long localInstant = iZone.convertUTCToLocal(instant);\n               localInstant = iField.add(localInstant, value);\n               return iZone.convertLocalToUTC(localInstant, false);\n            }\n        }\n\n        public long addWrapField(long instant, int value) {\n            if (iTimeField) {\n                int offset = getOffsetToAdd(instant);\n                long localInstant = iField.addWrapField(instant + offset, value);\n                return localInstant - offset;\n            } else {\n                long localInstant = iZone.convertUTCToLocal(instant);\n                localInstant = iField.addWrapField(localInstant, value);\n                return iZone.convertLocalToUTC(localInstant, false);\n            }\n        }\n\n        public long set(long instant, int value) {\n            long localInstant = iZone.convertUTCToLocal(instant);\n            localInstant = iField.set(localInstant, value);\n            long result = iZone.convertLocalToUTC(localInstant, false);\n            if (get(result) != value) {\n                throw new IllegalFieldValueException(iField.getType(), new Integer(value),\n                    \"Illegal instant due to time zone offset transition: \" +\n                    DateTimeFormat.forPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSS\").print(new Instant(localInstant)) +\n                    \" (\" + iZone.getID() + \")\");\n            }\n            return result;\n        }\n\n        public long set(long instant, String text, Locale locale) {\n            \n            long localInstant = iZone.convertUTCToLocal(instant);\n            localInstant = iField.set(localInstant, text, locale);\n            return iZone.convertLocalToUTC(localInstant, false);\n        }\n\n        public int getDifference(long minuendInstant, long subtrahendInstant) {\n            int offset = getOffsetToAdd(subtrahendInstant);\n            return iField.getDifference\n                (minuendInstant + (iTimeField ? offset : getOffsetToAdd(minuendInstant)),\n                 subtrahendInstant + offset);\n        }\n\n        public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n            int offset = getOffsetToAdd(subtrahendInstant);\n            return iField.getDifferenceAsLong\n                (minuendInstant + (iTimeField ? offset : getOffsetToAdd(minuendInstant)),\n                 subtrahendInstant + offset);\n        }\n\n        public final DurationField getDurationField() {\n            return iDurationField;\n        }\n\n        public final DurationField getRangeDurationField() {\n            return iRangeDurationField;\n        }\n\n        public boolean isLeap(long instant) {\n            long localInstant = iZone.convertUTCToLocal(instant);\n            return iField.isLeap(localInstant);\n        }\n\n        public int getLeapAmount(long instant) {\n            long localInstant = iZone.convertUTCToLocal(instant);\n            return iField.getLeapAmount(localInstant);\n        }\n\n        public final DurationField getLeapDurationField() {\n            return iLeapDurationField;\n        }\n\n        public long roundFloor(long instant) {\n            if (iTimeField) {\n                int offset = getOffsetToAdd(instant);\n                instant = iField.roundFloor(instant + offset);\n                return instant - offset;\n            } else {\n                long localInstant = iZone.convertUTCToLocal(instant);\n                localInstant = iField.roundFloor(localInstant);\n                return iZone.convertLocalToUTC(localInstant, false);\n            }\n        }\n\n        public long roundCeiling(long instant) {\n            if (iTimeField) {\n                int offset = getOffsetToAdd(instant);\n                instant = iField.roundCeiling(instant + offset);\n                return instant - offset;\n            } else {\n                long localInstant = iZone.convertUTCToLocal(instant);\n                localInstant = iField.roundCeiling(localInstant);\n                return iZone.convertLocalToUTC(localInstant, false);\n            }\n        }\n\n        public long remainder(long instant) {\n            long localInstant = iZone.convertUTCToLocal(instant);\n            return iField.remainder(localInstant);\n        }\n\n        public int getMinimumValue() {\n            return iField.getMinimumValue();\n        }\n\n        public int getMinimumValue(long instant) {\n            long localInstant = iZone.convertUTCToLocal(instant);\n            return iField.getMinimumValue(localInstant);\n        }\n\n        public int getMinimumValue(ReadablePartial instant) {\n            return iField.getMinimumValue(instant);\n        }\n\n        public int getMinimumValue(ReadablePartial instant, int[] values) {\n            return iField.getMinimumValue(instant, values);\n        }\n\n        public int getMaximumValue() {\n            return iField.getMaximumValue();\n        }\n\n        public int getMaximumValue(long instant) {\n            long localInstant = iZone.convertUTCToLocal(instant);\n            return iField.getMaximumValue(localInstant);\n        }\n\n        public int getMaximumValue(ReadablePartial instant) {\n            return iField.getMaximumValue(instant);\n        }\n\n        public int getMaximumValue(ReadablePartial instant, int[] values) {\n            return iField.getMaximumValue(instant, values);\n        }\n\n        public int getMaximumTextLength(Locale locale) {\n            return iField.getMaximumTextLength(locale);\n        }\n\n        public int getMaximumShortTextLength(Locale locale) {\n            return iField.getMaximumShortTextLength(locale);\n        }\n\n        private int getOffsetToAdd(long instant) {\n            int offset = this.iZone.getOffset(instant);\n            long sum = instant + offset;\n            \n            if ((instant ^ sum) < 0 && (instant ^ offset) >= 0) {\n                throw new ArithmeticException(\"Adding time zone offset caused overflow\");\n            }\n            return offset;\n        }\n    }\n\n}\n",
      "fixed_full_code": "\npackage org.joda.time.chrono;\n\nimport java.util.HashMap;\nimport java.util.Locale;\n\nimport org.joda.time.Chronology;\nimport org.joda.time.DateTimeConstants;\nimport org.joda.time.DateTimeField;\nimport org.joda.time.DateTimeZone;\nimport org.joda.time.DurationField;\nimport org.joda.time.IllegalFieldValueException;\nimport org.joda.time.Instant;\nimport org.joda.time.ReadablePartial;\nimport org.joda.time.field.BaseDateTimeField;\nimport org.joda.time.field.BaseDurationField;\nimport org.joda.time.format.DateTimeFormat;\n\n\npublic final class ZonedChronology extends AssembledChronology { private static final long serialVersionUID = -1079258847191166848L; public static ZonedChronology getInstance(Chronology base, DateTimeZone zone) {\n        if (base == null) {\n            throw new IllegalArgumentException(\"Must supply a chronology\");\n        }\n        base = base.withUTC();\n        if (base == null) {\n            throw new IllegalArgumentException(\"UTC chronology must not be null\");\n        }\n        if (zone == null) {\n            throw new IllegalArgumentException(\"DateTimeZone must not be null\");\n        }\n        return new ZonedChronology(base, zone);\n    }\n\n    static boolean useTimeArithmetic(DurationField field) {\n        \n        \n        return field != null && field.getUnitMillis() < DateTimeConstants.MILLIS_PER_HOUR * 12;\n    }\n\n    \n    private ZonedChronology(Chronology base, DateTimeZone zone) {\n        super(base, zone);\n    }\n\n    public DateTimeZone getZone() {\n        return (DateTimeZone)getParam();\n    }\n\n    public Chronology withUTC() {\n        return getBase();\n    }\n\n    public Chronology withZone(DateTimeZone zone) {\n        if (zone == null) {\n            zone = DateTimeZone.getDefault();\n        }\n        if (zone == getParam()) {\n            return this;\n        }\n        if (zone == DateTimeZone.UTC) {\n            return getBase();\n        }\n        return new ZonedChronology(getBase(), zone);\n    }\n\n    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int millisOfDay) throws IllegalArgumentException {\n        return localToUTC(getBase().getDateTimeMillis\n                          (year, monthOfYear, dayOfMonth, millisOfDay));\n    }\n\n    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException {\n        return localToUTC(getBase().getDateTimeMillis\n                          (year, monthOfYear, dayOfMonth, \n                           hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond));\n    }\n\n    public long getDateTimeMillis(long instant, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException {\n        return localToUTC(getBase().getDateTimeMillis\n                          (instant + getZone().getOffset(instant),\n                           hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond));\n    }\n\n    \n    private long localToUTC(long instant) {\n        DateTimeZone zone = getZone();\n        int offset = zone.getOffsetFromLocal(instant);\n        instant -= offset;\n        if (offset != zone.getOffset(instant)) {\n            throw new IllegalArgumentException\n                (\"Illegal instant due to time zone offset transition: \" +\n                    DateTimeFormat.forPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSS\").print(new Instant(instant)));\n        }\n        return instant;\n    }\n\n    protected void assemble(Fields fields) {\n        \n        \n        HashMap<Object, Object> converted = new HashMap<Object, Object>();\n\n        \n\n        fields.eras = convertField(fields.eras, converted);\n        fields.centuries = convertField(fields.centuries, converted);\n        fields.years = convertField(fields.years, converted);\n        fields.months = convertField(fields.months, converted);\n        fields.weekyears = convertField(fields.weekyears, converted);\n        fields.weeks = convertField(fields.weeks, converted);\n        fields.days = convertField(fields.days, converted);\n\n        fields.halfdays = convertField(fields.halfdays, converted);\n        fields.hours = convertField(fields.hours, converted);\n        fields.minutes = convertField(fields.minutes, converted);\n        fields.seconds = convertField(fields.seconds, converted);\n        fields.millis = convertField(fields.millis, converted);\n\n        \n\n        fields.year = convertField(fields.year, converted);\n        fields.yearOfEra = convertField(fields.yearOfEra, converted);\n        fields.yearOfCentury = convertField(fields.yearOfCentury, converted);\n        fields.centuryOfEra = convertField(fields.centuryOfEra, converted);\n        fields.era = convertField(fields.era, converted);\n        fields.dayOfWeek = convertField(fields.dayOfWeek, converted);\n        fields.dayOfMonth = convertField(fields.dayOfMonth, converted);\n        fields.dayOfYear = convertField(fields.dayOfYear, converted);\n        fields.monthOfYear = convertField(fields.monthOfYear, converted);\n        fields.weekOfWeekyear = convertField(fields.weekOfWeekyear, converted);\n        fields.weekyear = convertField(fields.weekyear, converted);\n        fields.weekyearOfCentury = convertField(fields.weekyearOfCentury, converted);\n\n        fields.millisOfSecond = convertField(fields.millisOfSecond, converted);\n        fields.millisOfDay = convertField(fields.millisOfDay, converted);\n        fields.secondOfMinute = convertField(fields.secondOfMinute, converted);\n        fields.secondOfDay = convertField(fields.secondOfDay, converted);\n        fields.minuteOfHour = convertField(fields.minuteOfHour, converted);\n        fields.minuteOfDay = convertField(fields.minuteOfDay, converted);\n        fields.hourOfDay = convertField(fields.hourOfDay, converted);\n        fields.hourOfHalfday = convertField(fields.hourOfHalfday, converted);\n        fields.clockhourOfDay = convertField(fields.clockhourOfDay, converted);\n        fields.clockhourOfHalfday = convertField(fields.clockhourOfHalfday, converted);\n        fields.halfdayOfDay = convertField(fields.halfdayOfDay, converted);\n    }\n\n    private DurationField convertField(DurationField field, HashMap<Object, Object> converted) {\n        if (field == null || !field.isSupported()) {\n            return field;\n        }\n        if (converted.containsKey(field)) {\n            return (DurationField)converted.get(field);\n        }\n        ZonedDurationField zonedField = new ZonedDurationField(field, getZone());\n        converted.put(field, zonedField);\n        return zonedField;\n    }\n\n    private DateTimeField convertField(DateTimeField field, HashMap<Object, Object> converted) {\n        if (field == null || !field.isSupported()) {\n            return field;\n        }\n        if (converted.containsKey(field)) {\n            return (DateTimeField)converted.get(field);\n        }\n        ZonedDateTimeField zonedField =\n            new ZonedDateTimeField(field, getZone(),\n                                   convertField(field.getDurationField(), converted),\n                                   convertField(field.getRangeDurationField(), converted),\n                                   convertField(field.getLeapDurationField(), converted));\n        converted.put(field, zonedField);\n        return zonedField;\n    }\n\n    \n    \n    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj instanceof ZonedChronology == false) {\n            return false;\n        }\n        ZonedChronology chrono = (ZonedChronology) obj;\n        return\n            getBase().equals(chrono.getBase()) &&\n            getZone().equals(chrono.getZone());\n    }\n\n    \n    public int hashCode() {\n        return 326565 + getZone().hashCode() * 11 + getBase().hashCode() * 7;\n    }\n\n    \n    public String toString() {\n        return \"ZonedChronology[\" + getBase() + \", \" + getZone().getID() + ']';\n    }\n\n    \n    \n    static class ZonedDurationField extends BaseDurationField { private static final long serialVersionUID = -485345310999208286L; final DurationField iField; final boolean iTimeField; final DateTimeZone iZone; ZonedDurationField(DurationField field, DateTimeZone zone) {\n            super(field.getType());\n            if (!field.isSupported()) {\n                throw new IllegalArgumentException();\n            }\n            iField = field;\n            iTimeField = useTimeArithmetic(field);\n            iZone = zone;\n        }\n\n        public boolean isPrecise() {\n            return iTimeField ? iField.isPrecise() : iField.isPrecise() && this.iZone.isFixed();\n        }\n\n        public long getUnitMillis() {\n            return iField.getUnitMillis();\n        }\n\n        public int getValue(long duration, long instant) {\n            return iField.getValue(duration, addOffset(instant));\n        }\n\n        public long getValueAsLong(long duration, long instant) {\n            return iField.getValueAsLong(duration, addOffset(instant));\n        }\n\n        public long getMillis(int value, long instant) {\n            return iField.getMillis(value, addOffset(instant));\n        }\n\n        public long getMillis(long value, long instant) {\n            return iField.getMillis(value, addOffset(instant));\n        }\n\n        public long add(long instant, int value) {\n            int offset = getOffsetToAdd(instant);\n            instant = iField.add(instant + offset, value);\n            return instant - (iTimeField ? offset : getOffsetFromLocalToSubtract(instant));\n        }\n\n        public long add(long instant, long value) {\n            int offset = getOffsetToAdd(instant);\n            instant = iField.add(instant + offset, value);\n            return instant - (iTimeField ? offset : getOffsetFromLocalToSubtract(instant));\n        }\n\n        public int getDifference(long minuendInstant, long subtrahendInstant) {\n            int offset = getOffsetToAdd(subtrahendInstant);\n            return iField.getDifference\n                (minuendInstant + (iTimeField ? offset : getOffsetToAdd(minuendInstant)),\n                 subtrahendInstant + offset);\n        }\n\n        public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n            int offset = getOffsetToAdd(subtrahendInstant);\n            return iField.getDifferenceAsLong\n                (minuendInstant + (iTimeField ? offset : getOffsetToAdd(minuendInstant)),\n                 subtrahendInstant + offset);\n        }\n\n        private int getOffsetToAdd(long instant) {\n            int offset = this.iZone.getOffset(instant);\n            long sum = instant + offset;\n            \n            if ((instant ^ sum) < 0 && (instant ^ offset) >= 0) {\n                throw new ArithmeticException(\"Adding time zone offset caused overflow\");\n            }\n            return offset;\n        }\n\n        private int getOffsetFromLocalToSubtract(long instant) {\n            int offset = this.iZone.getOffsetFromLocal(instant);\n            long diff = instant - offset;\n            \n            if ((instant ^ diff) < 0 && (instant ^ offset) < 0) {\n                throw new ArithmeticException(\"Subtracting time zone offset caused overflow\");\n            }\n            return offset;\n        }\n\n        private long addOffset(long instant) {\n            return iZone.convertUTCToLocal(instant);\n        }\n    }\n\n    \n    static final class ZonedDateTimeField extends BaseDateTimeField { private static final long serialVersionUID = -3968986277775529794L; final DateTimeField iField; final DateTimeZone iZone; final DurationField iDurationField; final boolean iTimeField; final DurationField iRangeDurationField; final DurationField iLeapDurationField; ZonedDateTimeField(DateTimeField field, DateTimeZone zone, DurationField durationField, DurationField rangeDurationField, DurationField leapDurationField) {\n            super(field.getType());\n            if (!field.isSupported()) {\n                throw new IllegalArgumentException();\n            }\n            iField = field;\n            iZone = zone;\n            iDurationField = durationField;\n            iTimeField = useTimeArithmetic(durationField);\n            iRangeDurationField = rangeDurationField;\n            iLeapDurationField = leapDurationField;\n        }\n\n        public boolean isLenient() {\n            return iField.isLenient();\n        }\n\n        public int get(long instant) {\n            long localInstant = iZone.convertUTCToLocal(instant);\n            return iField.get(localInstant);\n        }\n\n        public String getAsText(long instant, Locale locale) {\n            long localInstant = iZone.convertUTCToLocal(instant);\n            return iField.getAsText(localInstant, locale);\n        }\n\n        public String getAsShortText(long instant, Locale locale) {\n            long localInstant = iZone.convertUTCToLocal(instant);\n            return iField.getAsShortText(localInstant, locale);\n        }\n\n        public String getAsText(int fieldValue, Locale locale) {\n            return iField.getAsText(fieldValue, locale);\n        }\n\n        public String getAsShortText(int fieldValue, Locale locale) {\n            return iField.getAsShortText(fieldValue, locale);\n        }\n\n        public long add(long instant, int value) {\n            if (iTimeField) {\n                int offset = getOffsetToAdd(instant);\n                long localInstant = iField.add(instant + offset, value);\n                return localInstant - offset;\n            } else {\n               long localInstant = iZone.convertUTCToLocal(instant);\n               localInstant = iField.add(localInstant, value);\n               return iZone.convertLocalToUTC(localInstant, false, instant);\n            }\n        }\n\n        public long add(long instant, long value) {\n            if (iTimeField) {\n                int offset = getOffsetToAdd(instant);\n                long localInstant = iField.add(instant + offset, value);\n                return localInstant - offset;\n            } else {\n               long localInstant = iZone.convertUTCToLocal(instant);\n               localInstant = iField.add(localInstant, value);\n               return iZone.convertLocalToUTC(localInstant, false, instant);\n            }\n        }\n\n        public long addWrapField(long instant, int value) {\n            if (iTimeField) {\n                int offset = getOffsetToAdd(instant);\n                long localInstant = iField.addWrapField(instant + offset, value);\n                return localInstant - offset;\n            } else {\n                long localInstant = iZone.convertUTCToLocal(instant);\n                localInstant = iField.addWrapField(localInstant, value);\n                return iZone.convertLocalToUTC(localInstant, false, instant);\n            }\n        }\n\n        public long set(long instant, int value) {\n            long localInstant = iZone.convertUTCToLocal(instant);\n            localInstant = iField.set(localInstant, value);\n            long result = iZone.convertLocalToUTC(localInstant, false, instant);\n            if (get(result) != value) {\n                throw new IllegalFieldValueException(iField.getType(), new Integer(value),\n                    \"Illegal instant due to time zone offset transition: \" +\n                    DateTimeFormat.forPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSS\").print(new Instant(localInstant)) +\n                    \" (\" + iZone.getID() + \")\");\n            }\n            return result;\n        }\n\n        public long set(long instant, String text, Locale locale) {\n            \n            long localInstant = iZone.convertUTCToLocal(instant);\n            localInstant = iField.set(localInstant, text, locale);\n            return iZone.convertLocalToUTC(localInstant, false, instant);\n        }\n\n        public int getDifference(long minuendInstant, long subtrahendInstant) {\n            int offset = getOffsetToAdd(subtrahendInstant);\n            return iField.getDifference\n                (minuendInstant + (iTimeField ? offset : getOffsetToAdd(minuendInstant)),\n                 subtrahendInstant + offset);\n        }\n\n        public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n            int offset = getOffsetToAdd(subtrahendInstant);\n            return iField.getDifferenceAsLong\n                (minuendInstant + (iTimeField ? offset : getOffsetToAdd(minuendInstant)),\n                 subtrahendInstant + offset);\n        }\n\n        public final DurationField getDurationField() {\n            return iDurationField;\n        }\n\n        public final DurationField getRangeDurationField() {\n            return iRangeDurationField;\n        }\n\n        public boolean isLeap(long instant) {\n            long localInstant = iZone.convertUTCToLocal(instant);\n            return iField.isLeap(localInstant);\n        }\n\n        public int getLeapAmount(long instant) {\n            long localInstant = iZone.convertUTCToLocal(instant);\n            return iField.getLeapAmount(localInstant);\n        }\n\n        public final DurationField getLeapDurationField() {\n            return iLeapDurationField;\n        }\n\n        public long roundFloor(long instant) {\n            if (iTimeField) {\n                int offset = getOffsetToAdd(instant);\n                instant = iField.roundFloor(instant + offset);\n                return instant - offset;\n            } else {\n                long localInstant = iZone.convertUTCToLocal(instant);\n                localInstant = iField.roundFloor(localInstant);\n                return iZone.convertLocalToUTC(localInstant, false, instant);\n            }\n        }\n\n        public long roundCeiling(long instant) {\n            if (iTimeField) {\n                int offset = getOffsetToAdd(instant);\n                instant = iField.roundCeiling(instant + offset);\n                return instant - offset;\n            } else {\n                long localInstant = iZone.convertUTCToLocal(instant);\n                localInstant = iField.roundCeiling(localInstant);\n                return iZone.convertLocalToUTC(localInstant, false, instant);\n            }\n        }\n\n        public long remainder(long instant) {\n            long localInstant = iZone.convertUTCToLocal(instant);\n            return iField.remainder(localInstant);\n        }\n\n        public int getMinimumValue() {\n            return iField.getMinimumValue();\n        }\n\n        public int getMinimumValue(long instant) {\n            long localInstant = iZone.convertUTCToLocal(instant);\n            return iField.getMinimumValue(localInstant);\n        }\n\n        public int getMinimumValue(ReadablePartial instant) {\n            return iField.getMinimumValue(instant);\n        }\n\n        public int getMinimumValue(ReadablePartial instant, int[] values) {\n            return iField.getMinimumValue(instant, values);\n        }\n\n        public int getMaximumValue() {\n            return iField.getMaximumValue();\n        }\n\n        public int getMaximumValue(long instant) {\n            long localInstant = iZone.convertUTCToLocal(instant);\n            return iField.getMaximumValue(localInstant);\n        }\n\n        public int getMaximumValue(ReadablePartial instant) {\n            return iField.getMaximumValue(instant);\n        }\n\n        public int getMaximumValue(ReadablePartial instant, int[] values) {\n            return iField.getMaximumValue(instant, values);\n        }\n\n        public int getMaximumTextLength(Locale locale) {\n            return iField.getMaximumTextLength(locale);\n        }\n\n        public int getMaximumShortTextLength(Locale locale) {\n            return iField.getMaximumShortTextLength(locale);\n        }\n\n        private int getOffsetToAdd(long instant) {\n            int offset = this.iZone.getOffset(instant);\n            long sum = instant + offset;\n            \n            if ((instant ^ sum) < 0 && (instant ^ offset) >= 0) {\n                throw new ArithmeticException(\"Adding time zone offset caused overflow\");\n            }\n            return offset;\n        }\n    }\n\n}\n",
      "buggy_signatures": [
        "static boolean useTimeArithmetic(DurationField field)",
        "private ZonedChronology(Chronology base, DateTimeZone zone)",
        "public DateTimeZone getZone()",
        "public Chronology withUTC()",
        "public Chronology withZone(DateTimeZone zone)",
        "public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int millisOfDay) throws IllegalArgumentException",
        "public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException",
        "public long getDateTimeMillis(long instant, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException",
        "private long localToUTC(long instant)",
        "protected void assemble(Fields fields)",
        "private DurationField convertField(DurationField field, HashMap<Object, Object> converted)",
        "private DateTimeField convertField(DateTimeField field, HashMap<Object, Object> converted)",
        "public boolean equals(Object obj)",
        "public int hashCode()",
        "public String toString()",
        "public boolean isPrecise()",
        "public long getUnitMillis()",
        "public int getValue(long duration, long instant)",
        "public long getValueAsLong(long duration, long instant)",
        "public long getMillis(int value, long instant)",
        "public long getMillis(long value, long instant)",
        "public long add(long instant, int value)",
        "public long add(long instant, long value)",
        "public int getDifference(long minuendInstant, long subtrahendInstant)",
        "public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant)",
        "private int getOffsetToAdd(long instant)",
        "private int getOffsetFromLocalToSubtract(long instant)",
        "private long addOffset(long instant)",
        "public boolean isLenient()",
        "public int get(long instant)",
        "public String getAsText(long instant, Locale locale)",
        "public String getAsShortText(long instant, Locale locale)",
        "public String getAsText(int fieldValue, Locale locale)",
        "public String getAsShortText(int fieldValue, Locale locale)",
        "public long add(long instant, int value)",
        "public long add(long instant, long value)",
        "public long addWrapField(long instant, int value)",
        "public long set(long instant, int value)",
        "public long set(long instant, String text, Locale locale)",
        "public int getDifference(long minuendInstant, long subtrahendInstant)",
        "public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant)",
        "public final DurationField getDurationField()",
        "public final DurationField getRangeDurationField()",
        "public boolean isLeap(long instant)",
        "public int getLeapAmount(long instant)",
        "public final DurationField getLeapDurationField()",
        "public long roundFloor(long instant)",
        "public long roundCeiling(long instant)",
        "public long remainder(long instant)",
        "public int getMinimumValue()",
        "public int getMinimumValue(long instant)",
        "public int getMinimumValue(ReadablePartial instant)",
        "public int getMinimumValue(ReadablePartial instant, int[] values)",
        "public int getMaximumValue()",
        "public int getMaximumValue(long instant)",
        "public int getMaximumValue(ReadablePartial instant)",
        "public int getMaximumValue(ReadablePartial instant, int[] values)",
        "public int getMaximumTextLength(Locale locale)",
        "public int getMaximumShortTextLength(Locale locale)",
        "private int getOffsetToAdd(long instant)"
      ],
      "fixed_signatures": [
        "static boolean useTimeArithmetic(DurationField field)",
        "private ZonedChronology(Chronology base, DateTimeZone zone)",
        "public DateTimeZone getZone()",
        "public Chronology withUTC()",
        "public Chronology withZone(DateTimeZone zone)",
        "public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int millisOfDay) throws IllegalArgumentException",
        "public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException",
        "public long getDateTimeMillis(long instant, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException",
        "private long localToUTC(long instant)",
        "protected void assemble(Fields fields)",
        "private DurationField convertField(DurationField field, HashMap<Object, Object> converted)",
        "private DateTimeField convertField(DateTimeField field, HashMap<Object, Object> converted)",
        "public boolean equals(Object obj)",
        "public int hashCode()",
        "public String toString()",
        "public boolean isPrecise()",
        "public long getUnitMillis()",
        "public int getValue(long duration, long instant)",
        "public long getValueAsLong(long duration, long instant)",
        "public long getMillis(int value, long instant)",
        "public long getMillis(long value, long instant)",
        "public long add(long instant, int value)",
        "public long add(long instant, long value)",
        "public int getDifference(long minuendInstant, long subtrahendInstant)",
        "public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant)",
        "private int getOffsetToAdd(long instant)",
        "private int getOffsetFromLocalToSubtract(long instant)",
        "private long addOffset(long instant)",
        "public boolean isLenient()",
        "public int get(long instant)",
        "public String getAsText(long instant, Locale locale)",
        "public String getAsShortText(long instant, Locale locale)",
        "public String getAsText(int fieldValue, Locale locale)",
        "public String getAsShortText(int fieldValue, Locale locale)",
        "public long add(long instant, int value)",
        "public long add(long instant, long value)",
        "public long addWrapField(long instant, int value)",
        "public long set(long instant, int value)",
        "public long set(long instant, String text, Locale locale)",
        "public int getDifference(long minuendInstant, long subtrahendInstant)",
        "public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant)",
        "public final DurationField getDurationField()",
        "public final DurationField getRangeDurationField()",
        "public boolean isLeap(long instant)",
        "public int getLeapAmount(long instant)",
        "public final DurationField getLeapDurationField()",
        "public long roundFloor(long instant)",
        "public long roundCeiling(long instant)",
        "public long remainder(long instant)",
        "public int getMinimumValue()",
        "public int getMinimumValue(long instant)",
        "public int getMinimumValue(ReadablePartial instant)",
        "public int getMinimumValue(ReadablePartial instant, int[] values)",
        "public int getMaximumValue()",
        "public int getMaximumValue(long instant)",
        "public int getMaximumValue(ReadablePartial instant)",
        "public int getMaximumValue(ReadablePartial instant, int[] values)",
        "public int getMaximumTextLength(Locale locale)",
        "public int getMaximumShortTextLength(Locale locale)",
        "private int getOffsetToAdd(long instant)"
      ],
      "methods": [
        {
          "buggy_method": "  public long add(long instant, int value) {\n  if (iTimeField) {\n  int offset = getOffsetToAdd(instant);\n  long localInstant = iField.add(instant + offset, value);\n  return localInstant - offset;\n  } else {\n  long localInstant = iZone.convertUTCToLocal(instant);\n  localInstant = iField.add(localInstant, value);\n  return iZone.convertLocalToUTC(localInstant, false);\n  }\n  }",
          "fixed_method": "  public long add(long instant, int value) {\n  if (iTimeField) {\n  int offset = getOffsetToAdd(instant);\n  long localInstant = iField.add(instant + offset, value);\n  return localInstant - offset;\n  } else {\n  long localInstant = iZone.convertUTCToLocal(instant);\n  localInstant = iField.add(localInstant, value);\n  return iZone.convertLocalToUTC(localInstant, false, instant);\n  }\n  }",
          "diff": [
            "@@ -433,7 +433,7 @@",
            "             } else {\n",
            "                long localInstant = iZone.convertUTCToLocal(instant);\n",
            "                localInstant = iField.add(localInstant, value);\n",
            "-               return iZone.convertLocalToUTC(localInstant, false);\n",
            "+               return iZone.convertLocalToUTC(localInstant, false, instant);\n",
            "             }\n",
            "         }\n",
            " \n"
          ],
          "changed_lines": 2
        },
        {
          "buggy_method": "  public long add(long instant, long value) {\n  if (iTimeField) {\n  int offset = getOffsetToAdd(instant);\n  long localInstant = iField.add(instant + offset, value);\n  return localInstant - offset;\n  } else {\n  long localInstant = iZone.convertUTCToLocal(instant);\n  localInstant = iField.add(localInstant, value);\n  return iZone.convertLocalToUTC(localInstant, false);\n  }\n  }",
          "fixed_method": "  public long add(long instant, long value) {\n  if (iTimeField) {\n  int offset = getOffsetToAdd(instant);\n  long localInstant = iField.add(instant + offset, value);\n  return localInstant - offset;\n  } else {\n  long localInstant = iZone.convertUTCToLocal(instant);\n  localInstant = iField.add(localInstant, value);\n  return iZone.convertLocalToUTC(localInstant, false, instant);\n  }\n  }",
          "diff": [
            "@@ -445,7 +445,7 @@",
            "             } else {\n",
            "                long localInstant = iZone.convertUTCToLocal(instant);\n",
            "                localInstant = iField.add(localInstant, value);\n",
            "-               return iZone.convertLocalToUTC(localInstant, false);\n",
            "+               return iZone.convertLocalToUTC(localInstant, false, instant);\n",
            "             }\n",
            "         }\n",
            " \n"
          ],
          "changed_lines": 2
        },
        {
          "buggy_method": "  public long set(long instant, int value) {\n  long localInstant = iZone.convertUTCToLocal(instant);\n  localInstant = iField.set(localInstant, value);\n  long result = iZone.convertLocalToUTC(localInstant, false);\n  if (get(result) != value) {\n  throw new IllegalFieldValueException(iField.getType(), new Integer(value),\n  \"Illegal instant due to time zone offset transition: \" +\n  DateTimeFormat.forPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSS\").print(new Instant(localInstant)) +\n  \" (\" + iZone.getID() + \")\");\n  }\n  return result;\n  }",
          "fixed_method": "  public long set(long instant, int value) {\n  long localInstant = iZone.convertUTCToLocal(instant);\n  localInstant = iField.set(localInstant, value);\n  long result = iZone.convertLocalToUTC(localInstant, false, instant);\n  if (get(result) != value) {\n  throw new IllegalFieldValueException(iField.getType(), new Integer(value),\n  \"Illegal instant due to time zone offset transition: \" +\n  DateTimeFormat.forPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSS\").print(new Instant(localInstant)) +\n  \" (\" + iZone.getID() + \")\");\n  }\n  return result;\n  }",
          "diff": [
            "@@ -457,14 +457,14 @@",
            "             } else {\n",
            "                 long localInstant = iZone.convertUTCToLocal(instant);\n",
            "                 localInstant = iField.addWrapField(localInstant, value);\n",
            "-                return iZone.convertLocalToUTC(localInstant, false);\n",
            "+                return iZone.convertLocalToUTC(localInstant, false, instant);\n",
            "             }\n",
            "         }\n",
            " \n",
            "         public long set(long instant, int value) {\n",
            "             long localInstant = iZone.convertUTCToLocal(instant);\n",
            "             localInstant = iField.set(localInstant, value);\n",
            "-            long result = iZone.convertLocalToUTC(localInstant, false);\n",
            "+            long result = iZone.convertLocalToUTC(localInstant, false, instant);\n",
            "             if (get(result) != value) {\n",
            "                 throw new IllegalFieldValueException(iField.getType(), new Integer(value),\n",
            "                     \"Illegal instant due to time zone offset transition: \" +\n"
          ],
          "changed_lines": 4
        },
        {
          "buggy_method": "  public int getDifference(long minuendInstant, long subtrahendInstant) {\n  int offset = getOffsetToAdd(subtrahendInstant);\n  return iField.getDifference\n  (minuendInstant + (iTimeField ? offset : getOffsetToAdd(minuendInstant)),\n  subtrahendInstant + offset);\n  }",
          "fixed_method": "  public int getDifference(long minuendInstant, long subtrahendInstant) {\n  int offset = getOffsetToAdd(subtrahendInstant);\n  return iField.getDifference\n  (minuendInstant + (iTimeField ? offset : getOffsetToAdd(minuendInstant)),\n  subtrahendInstant + offset);\n  }",
          "diff": [
            "@@ -478,7 +478,7 @@",
            "             // cannot verify that new value stuck because set may be lenient\n",
            "             long localInstant = iZone.convertUTCToLocal(instant);\n",
            "             localInstant = iField.set(localInstant, text, locale);\n",
            "-            return iZone.convertLocalToUTC(localInstant, false);\n",
            "+            return iZone.convertLocalToUTC(localInstant, false, instant);\n",
            "         }\n",
            " \n",
            "         public int getDifference(long minuendInstant, long subtrahendInstant) {\n"
          ],
          "changed_lines": 2
        },
        {
          "buggy_method": "  public long roundFloor(long instant) {\n  if (iTimeField) {\n  int offset = getOffsetToAdd(instant);\n  instant = iField.roundFloor(instant + offset);\n  return instant - offset;\n  } else {\n  long localInstant = iZone.convertUTCToLocal(instant);\n  localInstant = iField.roundFloor(localInstant);\n  return iZone.convertLocalToUTC(localInstant, false);\n  }\n  }",
          "fixed_method": "  public long roundFloor(long instant) {\n  if (iTimeField) {\n  int offset = getOffsetToAdd(instant);\n  instant = iField.roundFloor(instant + offset);\n  return instant - offset;\n  } else {\n  long localInstant = iZone.convertUTCToLocal(instant);\n  localInstant = iField.roundFloor(localInstant);\n  return iZone.convertLocalToUTC(localInstant, false, instant);\n  }\n  }",
          "diff": [
            "@@ -525,7 +525,7 @@",
            "             } else {\n",
            "                 long localInstant = iZone.convertUTCToLocal(instant);\n",
            "                 localInstant = iField.roundFloor(localInstant);\n",
            "-                return iZone.convertLocalToUTC(localInstant, false);\n",
            "+                return iZone.convertLocalToUTC(localInstant, false, instant);\n",
            "             }\n",
            "         }\n",
            " \n"
          ],
          "changed_lines": 2
        },
        {
          "buggy_method": "  public long roundCeiling(long instant) {\n  if (iTimeField) {\n  int offset = getOffsetToAdd(instant);\n  instant = iField.roundCeiling(instant + offset);\n  return instant - offset;\n  } else {\n  long localInstant = iZone.convertUTCToLocal(instant);\n  localInstant = iField.roundCeiling(localInstant);\n  return iZone.convertLocalToUTC(localInstant, false);\n  }\n  }",
          "fixed_method": "  public long roundCeiling(long instant) {\n  if (iTimeField) {\n  int offset = getOffsetToAdd(instant);\n  instant = iField.roundCeiling(instant + offset);\n  return instant - offset;\n  } else {\n  long localInstant = iZone.convertUTCToLocal(instant);\n  localInstant = iField.roundCeiling(localInstant);\n  return iZone.convertLocalToUTC(localInstant, false, instant);\n  }\n  }",
          "diff": [
            "@@ -537,7 +537,7 @@",
            "             } else {\n",
            "                 long localInstant = iZone.convertUTCToLocal(instant);\n",
            "                 localInstant = iField.roundCeiling(localInstant);\n",
            "-                return iZone.convertLocalToUTC(localInstant, false);\n",
            "+                return iZone.convertLocalToUTC(localInstant, false, instant);\n",
            "             }\n",
            "         }\n",
            " \n"
          ],
          "changed_lines": 2
        }
      ]
    },
    {
      "name": "org/joda/time/DateTimeZone.java",
      "buggy_full_code": "\npackage org.joda.time;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.ObjectStreamException;\nimport java.io.Serializable;\nimport java.lang.ref.Reference;\nimport java.lang.ref.SoftReference;\nimport java.util.HashMap;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TimeZone;\n\nimport org.joda.convert.FromString;\nimport org.joda.convert.ToString;\nimport org.joda.time.chrono.BaseChronology;\nimport org.joda.time.field.FieldUtils;\nimport org.joda.time.format.DateTimeFormat;\nimport org.joda.time.format.DateTimeFormatter;\nimport org.joda.time.format.DateTimeFormatterBuilder;\nimport org.joda.time.format.FormatUtils;\nimport org.joda.time.tz.DefaultNameProvider;\nimport org.joda.time.tz.FixedDateTimeZone;\nimport org.joda.time.tz.NameProvider;\nimport org.joda.time.tz.Provider;\nimport org.joda.time.tz.UTCProvider;\nimport org.joda.time.tz.ZoneInfoProvider;\n\n\npublic abstract class DateTimeZone implements Serializable { private static final long serialVersionUID = 5546345482340108586L; public static final DateTimeZone UTC = new FixedDateTimeZone(\"UTC\", \"UTC\", 0, 0); private static Provider cProvider; private static NameProvider cNameProvider; private static Set<String> cAvailableIDs; private static volatile DateTimeZone cDefault; private static DateTimeFormatter cOffsetFormatter; private static Map<String, SoftReference<DateTimeZone>> iFixedOffsetCache; private static Map<String, String> cZoneIdConversion; static {\n        setProvider0(null);\n        setNameProvider0(null);\n    }\n\n    \n    \n    public static DateTimeZone getDefault() {\n        DateTimeZone zone = cDefault;\n        if (zone == null) {\n            synchronized(DateTimeZone.class) {\n                zone = cDefault;\n                if (zone == null) {\n                    DateTimeZone temp = null;\n                    try {\n                        try {\n                            String id = System.getProperty(\"user.timezone\");\n                            if (id != null) {  \n                                temp = forID(id);\n                            }\n                        } catch (RuntimeException ex) {\n                            \n                        }\n                        if (temp == null) {\n                            temp = forTimeZone(TimeZone.getDefault());\n                        }\n                    } catch (IllegalArgumentException ex) {\n                        \n                    }\n                    if (temp == null) {\n                        temp = UTC;\n                    }\n                    cDefault = zone = temp;\n                }\n            }\n        }\n        return zone;\n    }\n\n    \n    public static void setDefault(DateTimeZone zone) throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setDefault\"));\n        }\n        if (zone == null) {\n            throw new IllegalArgumentException(\"The datetime zone must not be null\");\n        }\n        synchronized(DateTimeZone.class) {\n            cDefault = zone;\n        }\n    }\n\n    \n    \n    @FromString\n    public static DateTimeZone forID(String id) {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        DateTimeZone zone = cProvider.getZone(id);\n        if (zone != null) {\n            return zone;\n        }\n        if (id.startsWith(\"+\") || id.startsWith(\"-\")) {\n            int offset = parseOffset(id);\n            if (offset == 0L) {\n                return DateTimeZone.UTC;\n            } else {\n                id = printOffset(offset);\n                return fixedOffsetZone(id, offset);\n            }\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }\n\n    \n    public static DateTimeZone forOffsetHours(int hoursOffset) throws IllegalArgumentException {\n        return forOffsetHoursMinutes(hoursOffset, 0);\n    }\n\n    \n    public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException {\n        if (hoursOffset == 0 && minutesOffset == 0) {\n            return DateTimeZone.UTC;\n        }\n        if (minutesOffset < 0 || minutesOffset > 59) {\n            throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n        }\n        int offset = 0;\n        try {\n            int hoursInMinutes = FieldUtils.safeMultiply(hoursOffset, 60);\n            if (hoursInMinutes < 0) {\n                minutesOffset = FieldUtils.safeAdd(hoursInMinutes, -minutesOffset);\n            } else {\n                minutesOffset = FieldUtils.safeAdd(hoursInMinutes, minutesOffset);\n            }\n            offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);\n        } catch (ArithmeticException ex) {\n            throw new IllegalArgumentException(\"Offset is too large\");\n        }\n        return forOffsetMillis(offset);\n    }\n\n    \n    public static DateTimeZone forOffsetMillis(int millisOffset) {\n        String id = printOffset(millisOffset);\n        return fixedOffsetZone(id, millisOffset);\n    }\n\n    \n    public static DateTimeZone forTimeZone(TimeZone zone) {\n        if (zone == null) {\n            return getDefault();\n        }\n        final String id = zone.getID();\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n\n        \n        DateTimeZone dtz = null;\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) {\n            dtz = cProvider.getZone(id);\n        }\n        if (dtz != null) {\n            return dtz;\n        }\n\n        \n        if (convId == null) {\n            convId = zone.getDisplayName();\n            if (convId.startsWith(\"GMT+\") || convId.startsWith(\"GMT-\")) {\n                convId = convId.substring(3);\n                int offset = parseOffset(convId);\n                if (offset == 0L) {\n                    return DateTimeZone.UTC;\n                } else {\n                    convId = printOffset(offset);\n                    return fixedOffsetZone(convId, offset);\n                }\n            }\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }\n\n    \n    \n    private static synchronized DateTimeZone fixedOffsetZone(String id, int offset) {\n        if (offset == 0) {\n            return DateTimeZone.UTC;\n        }\n        if (iFixedOffsetCache == null) {\n            iFixedOffsetCache = new HashMap<String, SoftReference<DateTimeZone>>();\n        }\n        DateTimeZone zone;\n        Reference<DateTimeZone> ref = iFixedOffsetCache.get(id);\n        if (ref != null) {\n            zone = ref.get();\n            if (zone != null) {\n                return zone;\n            }\n        }\n        zone = new FixedDateTimeZone(id, null, offset, offset);\n        iFixedOffsetCache.put(id, new SoftReference<DateTimeZone>(zone));\n        return zone;\n    }\n\n    \n    public static Set<String> getAvailableIDs() {\n        return cAvailableIDs;\n    }\n\n    \n    \n    public static Provider getProvider() {\n        return cProvider;\n    }\n\n    \n    public static void setProvider(Provider provider) throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setProvider\"));\n        }\n        setProvider0(provider);\n    }\n\n    \n    private static void setProvider0(Provider provider) {\n        if (provider == null) {\n            provider = getDefaultProvider();\n        }\n        Set<String> ids = provider.getAvailableIDs();\n        if (ids == null || ids.size() == 0) {\n            throw new IllegalArgumentException\n                (\"The provider doesn't have any available ids\");\n        }\n        if (!ids.contains(\"UTC\")) {\n            throw new IllegalArgumentException(\"The provider doesn't support UTC\");\n        }\n        if (!UTC.equals(provider.getZone(\"UTC\"))) {\n            throw new IllegalArgumentException(\"Invalid UTC zone provided\");\n        }\n        cProvider = provider;\n        cAvailableIDs = ids;\n    }\n\n    \n    private static Provider getDefaultProvider() {\n        Provider provider = null;\n\n        try {\n            String providerClass =\n                System.getProperty(\"org.joda.time.DateTimeZone.Provider\");\n            if (providerClass != null) {\n                try {\n                    provider = (Provider) Class.forName(providerClass).newInstance();\n                } catch (Exception ex) {\n                    Thread thread = Thread.currentThread();\n                    thread.getThreadGroup().uncaughtException(thread, ex);\n                }\n            }\n        } catch (SecurityException ex) {\n            \n        }\n\n        if (provider == null) {\n            try {\n                provider = new ZoneInfoProvider(\"org/joda/time/tz/data\");\n            } catch (Exception ex) {\n                Thread thread = Thread.currentThread();\n                thread.getThreadGroup().uncaughtException(thread, ex);\n            }\n        }\n\n        if (provider == null) {\n            provider = new UTCProvider();\n        }\n\n        return provider;\n    }\n\n    \n    \n    public static NameProvider getNameProvider() {\n        return cNameProvider;\n    }\n\n    \n    public static void setNameProvider(NameProvider nameProvider) throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setNameProvider\"));\n        }\n        setNameProvider0(nameProvider);\n    }\n\n    \n    private static void setNameProvider0(NameProvider nameProvider) {\n        if (nameProvider == null) {\n            nameProvider = getDefaultNameProvider();\n        }\n        cNameProvider = nameProvider;\n    }\n\n    \n    private static NameProvider getDefaultNameProvider() {\n        NameProvider nameProvider = null;\n        try {\n            String providerClass = System.getProperty(\"org.joda.time.DateTimeZone.NameProvider\");\n            if (providerClass != null) {\n                try {\n                    nameProvider = (NameProvider) Class.forName(providerClass).newInstance();\n                } catch (Exception ex) {\n                    Thread thread = Thread.currentThread();\n                    thread.getThreadGroup().uncaughtException(thread, ex);\n                }\n            }\n        } catch (SecurityException ex) {\n            \n        }\n\n        if (nameProvider == null) {\n            nameProvider = new DefaultNameProvider();\n        }\n\n        return nameProvider;\n    }\n\n    \n    \n    private static synchronized String getConvertedId(String id) {\n        Map<String, String> map = cZoneIdConversion;\n        if (map == null) {\n            \n            map = new HashMap<String, String>();\n            map.put(\"GMT\", \"UTC\");\n            map.put(\"MIT\", \"Pacific/Apia\");\n            map.put(\"HST\", \"Pacific/Honolulu\");\n            map.put(\"AST\", \"America/Anchorage\");\n            map.put(\"PST\", \"America/Los_Angeles\");\n            map.put(\"MST\", \"America/Denver\");\n            map.put(\"PNT\", \"America/Phoenix\");\n            map.put(\"CST\", \"America/Chicago\");\n            map.put(\"EST\", \"America/New_York\");\n            map.put(\"IET\", \"America/Indianapolis\");\n            map.put(\"PRT\", \"America/Puerto_Rico\");\n            map.put(\"CNT\", \"America/St_Johns\");\n            map.put(\"AGT\", \"America/Buenos_Aires\");\n            map.put(\"BET\", \"America/Sao_Paulo\");\n            map.put(\"WET\", \"Europe/London\");\n            map.put(\"ECT\", \"Europe/Paris\");\n            map.put(\"ART\", \"Africa/Cairo\");\n            map.put(\"CAT\", \"Africa/Harare\");\n            map.put(\"EET\", \"Europe/Bucharest\");\n            map.put(\"EAT\", \"Africa/Addis_Ababa\");\n            map.put(\"MET\", \"Asia/Tehran\");\n            map.put(\"NET\", \"Asia/Yerevan\");\n            map.put(\"PLT\", \"Asia/Karachi\");\n            map.put(\"IST\", \"Asia/Calcutta\");\n            map.put(\"BST\", \"Asia/Dhaka\");\n            map.put(\"VST\", \"Asia/Saigon\");\n            map.put(\"CTT\", \"Asia/Shanghai\");\n            map.put(\"JST\", \"Asia/Tokyo\");\n            map.put(\"ACT\", \"Australia/Darwin\");\n            map.put(\"AET\", \"Australia/Sydney\");\n            map.put(\"SST\", \"Pacific/Guadalcanal\");\n            map.put(\"NST\", \"Pacific/Auckland\");\n            cZoneIdConversion = map;\n        }\n        return map.get(id);\n    }\n\n    private static int parseOffset(String str) {\n        \n        \n        Chronology chrono = new BaseChronology() {\n            public DateTimeZone getZone() {\n                return null;\n            }\n            public Chronology withUTC() {\n                return this;\n            }\n            public Chronology withZone(DateTimeZone zone) {\n                return this;\n            }\n            public String toString() {\n                return getClass().getName();\n            }\n        };\n        return -(int) offsetFormatter().withChronology(chrono).parseMillis(str);\n    }\n\n    \n    private static String printOffset(int offset) {\n        StringBuffer buf = new StringBuffer();\n        if (offset >= 0) {\n            buf.append('+');\n        } else {\n            buf.append('-');\n            offset = -offset;\n        }\n\n        int hours = offset / DateTimeConstants.MILLIS_PER_HOUR;\n        FormatUtils.appendPaddedInteger(buf, hours, 2);\n        offset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR;\n\n        int minutes = offset / DateTimeConstants.MILLIS_PER_MINUTE;\n        buf.append(':');\n        FormatUtils.appendPaddedInteger(buf, minutes, 2);\n        offset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n        if (offset == 0) {\n            return buf.toString();\n        }\n\n        int seconds = offset / DateTimeConstants.MILLIS_PER_SECOND;\n        buf.append(':');\n        FormatUtils.appendPaddedInteger(buf, seconds, 2);\n        offset -= seconds * DateTimeConstants.MILLIS_PER_SECOND;\n        if (offset == 0) {\n            return buf.toString();\n        }\n\n        buf.append('.');\n        FormatUtils.appendPaddedInteger(buf, offset, 3);\n        return buf.toString();\n    }\n\n    \n    private static synchronized DateTimeFormatter offsetFormatter() {\n        if (cOffsetFormatter == null) {\n            cOffsetFormatter = new DateTimeFormatterBuilder()\n                .appendTimeZoneOffset(null, true, 2, 4)\n                .toFormatter();\n        }\n        return cOffsetFormatter;\n    }\n\n    \n    \n\n    private final String iID; protected DateTimeZone(String id) {\n        if (id == null) {\n            throw new IllegalArgumentException(\"Id must not be null\");\n        }\n        iID = id;\n    }\n\n    \n    \n\n    \n    @ToString\n    public final String getID() {\n        return iID;\n    }\n\n    \n    public abstract String getNameKey(long instant); public final String getShortName(long instant) {\n        return getShortName(instant, null);\n    }\n\n    \n    public String getShortName(long instant, Locale locale) {\n        if (locale == null) {\n            locale = Locale.getDefault();\n        }\n        String nameKey = getNameKey(instant);\n        if (nameKey == null) {\n            return iID;\n        }\n        String name = cNameProvider.getShortName(locale, iID, nameKey);\n        if (name != null) {\n            return name;\n        }\n        return printOffset(getOffset(instant));\n    }\n\n    \n    public final String getName(long instant) {\n        return getName(instant, null);\n    }\n\n    \n    public String getName(long instant, Locale locale) {\n        if (locale == null) {\n            locale = Locale.getDefault();\n        }\n        String nameKey = getNameKey(instant);\n        if (nameKey == null) {\n            return iID;\n        }\n        String name = cNameProvider.getName(locale, iID, nameKey);\n        if (name != null) {\n            return name;\n        }\n        return printOffset(getOffset(instant));\n    }\n\n    \n    public abstract int getOffset(long instant); public final int getOffset(ReadableInstant instant) {\n        if (instant == null) {\n            return getOffset(DateTimeUtils.currentTimeMillis());\n        }\n        return getOffset(instant.getMillis());\n    }\n\n    \n    public abstract int getStandardOffset(long instant); public boolean isStandardOffset(long instant) {\n        return getOffset(instant) == getStandardOffset(instant);\n    }\n\n    \n    public int getOffsetFromLocal(long instantLocal) {\n        \n        int offsetLocal = getOffset(instantLocal);\n        \n        int offsetAdjusted = getOffset(instantLocal - offsetLocal);\n        \n        if (offsetLocal != offsetAdjusted) {\n            \n            \n            if ((offsetLocal - offsetAdjusted) < 0) {\n                \n                \n                \n                long nextLocal = nextTransition(instantLocal - offsetLocal);\n                long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n                if (nextLocal != nextAdjusted) {\n                    return offsetLocal;\n                }\n            }\n        }\n        return offsetAdjusted;\n    }\n\n    \n    public long convertUTCToLocal(long instantUTC) {\n        int offset = getOffset(instantUTC);\n        long instantLocal = instantUTC + offset;\n        \n        if ((instantUTC ^ instantLocal) < 0 && (instantUTC ^ offset) >= 0) {\n            throw new ArithmeticException(\"Adding time zone offset caused overflow\");\n        }\n        return instantLocal;\n    }\n\n    \n\n    \n    public long convertLocalToUTC(long instantLocal, boolean strict) {\n        \n        int offsetLocal = getOffset(instantLocal);\n        \n        int offset = getOffset(instantLocal - offsetLocal);\n        \n        if (offsetLocal != offset) {\n            \n            \n            \n            if (strict || offsetLocal < 0) {\n                \n                long nextLocal = nextTransition(instantLocal - offsetLocal);\n                if (nextLocal == (instantLocal - offsetLocal)) {\n                    nextLocal = Long.MAX_VALUE;\n                }\n                long nextAdjusted = nextTransition(instantLocal - offset);\n                if (nextAdjusted == (instantLocal - offset)) {\n                    nextAdjusted = Long.MAX_VALUE;\n                }\n                if (nextLocal != nextAdjusted) {\n                    \n                    if (strict) {\n                        \n                        throw new IllegalArgumentException(\"Illegal instant due to time zone offset transition: \" +\n                                DateTimeFormat.forPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSS\").print(new Instant(instantLocal)) +\n                                \" (\" + getID() + \")\");\n                    } else {\n                        \n                        \n                        \n                        offset = offsetLocal;\n                    }\n                }\n            }\n        }\n        \n        long instantUTC = instantLocal - offset;\n        \n        if ((instantLocal ^ instantUTC) < 0 && (instantLocal ^ offset) < 0) {\n            throw new ArithmeticException(\"Subtracting time zone offset caused overflow\");\n        }\n        return instantUTC;\n    }\n\n    \n    public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant) {\n        if (newZone == null) {\n            newZone = DateTimeZone.getDefault();\n        }\n        if (newZone == this) {\n            return oldInstant;\n        }\n        long instantLocal = oldInstant + getOffset(oldInstant);\n        return instantLocal - newZone.getOffsetFromLocal(instantLocal);\n    }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n        \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n    public boolean isLocalDateTimeGap(LocalDateTime localDateTime) {\n        if (isFixed()) {\n            return false;\n        }\n        try {\n            localDateTime.toDateTime(this);\n            return false;\n        } catch (IllegalArgumentException ex) {\n            return true;\n        }\n    }\n\n    \n    \n    public abstract boolean isFixed(); public abstract long nextTransition(long instant); public abstract long previousTransition(long instant); public java.util.TimeZone toTimeZone() {\n        return java.util.TimeZone.getTimeZone(iID);\n    }\n\n    \n    public abstract boolean equals(Object object); public int hashCode() {\n        return 57 + getID().hashCode();\n    }\n\n    \n    public String toString() {\n        return getID();\n    }\n\n    \n    protected Object writeReplace() throws ObjectStreamException {\n        return new Stub(iID);\n    }\n\n    \n    private static final class Stub implements Serializable { private static final long serialVersionUID = -6471952376487863581L; private transient String iID; Stub(String id) {\n            iID = id;\n        }\n\n        private void writeObject(ObjectOutputStream out) throws IOException {\n            out.writeUTF(iID);\n        }\n\n        private void readObject(ObjectInputStream in) throws IOException {\n            iID = in.readUTF();\n        }\n\n        private Object readResolve() throws ObjectStreamException {\n            return forID(iID);\n        }\n    }\n}\n",
      "fixed_full_code": "\npackage org.joda.time;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.ObjectStreamException;\nimport java.io.Serializable;\nimport java.lang.ref.Reference;\nimport java.lang.ref.SoftReference;\nimport java.util.HashMap;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TimeZone;\n\nimport org.joda.convert.FromString;\nimport org.joda.convert.ToString;\nimport org.joda.time.chrono.BaseChronology;\nimport org.joda.time.field.FieldUtils;\nimport org.joda.time.format.DateTimeFormat;\nimport org.joda.time.format.DateTimeFormatter;\nimport org.joda.time.format.DateTimeFormatterBuilder;\nimport org.joda.time.format.FormatUtils;\nimport org.joda.time.tz.DefaultNameProvider;\nimport org.joda.time.tz.FixedDateTimeZone;\nimport org.joda.time.tz.NameProvider;\nimport org.joda.time.tz.Provider;\nimport org.joda.time.tz.UTCProvider;\nimport org.joda.time.tz.ZoneInfoProvider;\n\n\npublic abstract class DateTimeZone implements Serializable { private static final long serialVersionUID = 5546345482340108586L; public static final DateTimeZone UTC = new FixedDateTimeZone(\"UTC\", \"UTC\", 0, 0); private static Provider cProvider; private static NameProvider cNameProvider; private static Set<String> cAvailableIDs; private static volatile DateTimeZone cDefault; private static DateTimeFormatter cOffsetFormatter; private static Map<String, SoftReference<DateTimeZone>> iFixedOffsetCache; private static Map<String, String> cZoneIdConversion; static {\n        setProvider0(null);\n        setNameProvider0(null);\n    }\n\n    \n    \n    public static DateTimeZone getDefault() {\n        DateTimeZone zone = cDefault;\n        if (zone == null) {\n            synchronized(DateTimeZone.class) {\n                zone = cDefault;\n                if (zone == null) {\n                    DateTimeZone temp = null;\n                    try {\n                        try {\n                            String id = System.getProperty(\"user.timezone\");\n                            if (id != null) {  \n                                temp = forID(id);\n                            }\n                        } catch (RuntimeException ex) {\n                            \n                        }\n                        if (temp == null) {\n                            temp = forTimeZone(TimeZone.getDefault());\n                        }\n                    } catch (IllegalArgumentException ex) {\n                        \n                    }\n                    if (temp == null) {\n                        temp = UTC;\n                    }\n                    cDefault = zone = temp;\n                }\n            }\n        }\n        return zone;\n    }\n\n    \n    public static void setDefault(DateTimeZone zone) throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setDefault\"));\n        }\n        if (zone == null) {\n            throw new IllegalArgumentException(\"The datetime zone must not be null\");\n        }\n        synchronized(DateTimeZone.class) {\n            cDefault = zone;\n        }\n    }\n\n    \n    \n    @FromString\n    public static DateTimeZone forID(String id) {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        DateTimeZone zone = cProvider.getZone(id);\n        if (zone != null) {\n            return zone;\n        }\n        if (id.startsWith(\"+\") || id.startsWith(\"-\")) {\n            int offset = parseOffset(id);\n            if (offset == 0L) {\n                return DateTimeZone.UTC;\n            } else {\n                id = printOffset(offset);\n                return fixedOffsetZone(id, offset);\n            }\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }\n\n    \n    public static DateTimeZone forOffsetHours(int hoursOffset) throws IllegalArgumentException {\n        return forOffsetHoursMinutes(hoursOffset, 0);\n    }\n\n    \n    public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException {\n        if (hoursOffset == 0 && minutesOffset == 0) {\n            return DateTimeZone.UTC;\n        }\n        if (minutesOffset < 0 || minutesOffset > 59) {\n            throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n        }\n        int offset = 0;\n        try {\n            int hoursInMinutes = FieldUtils.safeMultiply(hoursOffset, 60);\n            if (hoursInMinutes < 0) {\n                minutesOffset = FieldUtils.safeAdd(hoursInMinutes, -minutesOffset);\n            } else {\n                minutesOffset = FieldUtils.safeAdd(hoursInMinutes, minutesOffset);\n            }\n            offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);\n        } catch (ArithmeticException ex) {\n            throw new IllegalArgumentException(\"Offset is too large\");\n        }\n        return forOffsetMillis(offset);\n    }\n\n    \n    public static DateTimeZone forOffsetMillis(int millisOffset) {\n        String id = printOffset(millisOffset);\n        return fixedOffsetZone(id, millisOffset);\n    }\n\n    \n    public static DateTimeZone forTimeZone(TimeZone zone) {\n        if (zone == null) {\n            return getDefault();\n        }\n        final String id = zone.getID();\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n\n        \n        DateTimeZone dtz = null;\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) {\n            dtz = cProvider.getZone(id);\n        }\n        if (dtz != null) {\n            return dtz;\n        }\n\n        \n        if (convId == null) {\n            convId = zone.getDisplayName();\n            if (convId.startsWith(\"GMT+\") || convId.startsWith(\"GMT-\")) {\n                convId = convId.substring(3);\n                int offset = parseOffset(convId);\n                if (offset == 0L) {\n                    return DateTimeZone.UTC;\n                } else {\n                    convId = printOffset(offset);\n                    return fixedOffsetZone(convId, offset);\n                }\n            }\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }\n\n    \n    \n    private static synchronized DateTimeZone fixedOffsetZone(String id, int offset) {\n        if (offset == 0) {\n            return DateTimeZone.UTC;\n        }\n        if (iFixedOffsetCache == null) {\n            iFixedOffsetCache = new HashMap<String, SoftReference<DateTimeZone>>();\n        }\n        DateTimeZone zone;\n        Reference<DateTimeZone> ref = iFixedOffsetCache.get(id);\n        if (ref != null) {\n            zone = ref.get();\n            if (zone != null) {\n                return zone;\n            }\n        }\n        zone = new FixedDateTimeZone(id, null, offset, offset);\n        iFixedOffsetCache.put(id, new SoftReference<DateTimeZone>(zone));\n        return zone;\n    }\n\n    \n    public static Set<String> getAvailableIDs() {\n        return cAvailableIDs;\n    }\n\n    \n    \n    public static Provider getProvider() {\n        return cProvider;\n    }\n\n    \n    public static void setProvider(Provider provider) throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setProvider\"));\n        }\n        setProvider0(provider);\n    }\n\n    \n    private static void setProvider0(Provider provider) {\n        if (provider == null) {\n            provider = getDefaultProvider();\n        }\n        Set<String> ids = provider.getAvailableIDs();\n        if (ids == null || ids.size() == 0) {\n            throw new IllegalArgumentException\n                (\"The provider doesn't have any available ids\");\n        }\n        if (!ids.contains(\"UTC\")) {\n            throw new IllegalArgumentException(\"The provider doesn't support UTC\");\n        }\n        if (!UTC.equals(provider.getZone(\"UTC\"))) {\n            throw new IllegalArgumentException(\"Invalid UTC zone provided\");\n        }\n        cProvider = provider;\n        cAvailableIDs = ids;\n    }\n\n    \n    private static Provider getDefaultProvider() {\n        Provider provider = null;\n\n        try {\n            String providerClass =\n                System.getProperty(\"org.joda.time.DateTimeZone.Provider\");\n            if (providerClass != null) {\n                try {\n                    provider = (Provider) Class.forName(providerClass).newInstance();\n                } catch (Exception ex) {\n                    Thread thread = Thread.currentThread();\n                    thread.getThreadGroup().uncaughtException(thread, ex);\n                }\n            }\n        } catch (SecurityException ex) {\n            \n        }\n\n        if (provider == null) {\n            try {\n                provider = new ZoneInfoProvider(\"org/joda/time/tz/data\");\n            } catch (Exception ex) {\n                Thread thread = Thread.currentThread();\n                thread.getThreadGroup().uncaughtException(thread, ex);\n            }\n        }\n\n        if (provider == null) {\n            provider = new UTCProvider();\n        }\n\n        return provider;\n    }\n\n    \n    \n    public static NameProvider getNameProvider() {\n        return cNameProvider;\n    }\n\n    \n    public static void setNameProvider(NameProvider nameProvider) throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setNameProvider\"));\n        }\n        setNameProvider0(nameProvider);\n    }\n\n    \n    private static void setNameProvider0(NameProvider nameProvider) {\n        if (nameProvider == null) {\n            nameProvider = getDefaultNameProvider();\n        }\n        cNameProvider = nameProvider;\n    }\n\n    \n    private static NameProvider getDefaultNameProvider() {\n        NameProvider nameProvider = null;\n        try {\n            String providerClass = System.getProperty(\"org.joda.time.DateTimeZone.NameProvider\");\n            if (providerClass != null) {\n                try {\n                    nameProvider = (NameProvider) Class.forName(providerClass).newInstance();\n                } catch (Exception ex) {\n                    Thread thread = Thread.currentThread();\n                    thread.getThreadGroup().uncaughtException(thread, ex);\n                }\n            }\n        } catch (SecurityException ex) {\n            \n        }\n\n        if (nameProvider == null) {\n            nameProvider = new DefaultNameProvider();\n        }\n\n        return nameProvider;\n    }\n\n    \n    \n    private static synchronized String getConvertedId(String id) {\n        Map<String, String> map = cZoneIdConversion;\n        if (map == null) {\n            \n            map = new HashMap<String, String>();\n            map.put(\"GMT\", \"UTC\");\n            map.put(\"MIT\", \"Pacific/Apia\");\n            map.put(\"HST\", \"Pacific/Honolulu\");\n            map.put(\"AST\", \"America/Anchorage\");\n            map.put(\"PST\", \"America/Los_Angeles\");\n            map.put(\"MST\", \"America/Denver\");\n            map.put(\"PNT\", \"America/Phoenix\");\n            map.put(\"CST\", \"America/Chicago\");\n            map.put(\"EST\", \"America/New_York\");\n            map.put(\"IET\", \"America/Indianapolis\");\n            map.put(\"PRT\", \"America/Puerto_Rico\");\n            map.put(\"CNT\", \"America/St_Johns\");\n            map.put(\"AGT\", \"America/Buenos_Aires\");\n            map.put(\"BET\", \"America/Sao_Paulo\");\n            map.put(\"WET\", \"Europe/London\");\n            map.put(\"ECT\", \"Europe/Paris\");\n            map.put(\"ART\", \"Africa/Cairo\");\n            map.put(\"CAT\", \"Africa/Harare\");\n            map.put(\"EET\", \"Europe/Bucharest\");\n            map.put(\"EAT\", \"Africa/Addis_Ababa\");\n            map.put(\"MET\", \"Asia/Tehran\");\n            map.put(\"NET\", \"Asia/Yerevan\");\n            map.put(\"PLT\", \"Asia/Karachi\");\n            map.put(\"IST\", \"Asia/Calcutta\");\n            map.put(\"BST\", \"Asia/Dhaka\");\n            map.put(\"VST\", \"Asia/Saigon\");\n            map.put(\"CTT\", \"Asia/Shanghai\");\n            map.put(\"JST\", \"Asia/Tokyo\");\n            map.put(\"ACT\", \"Australia/Darwin\");\n            map.put(\"AET\", \"Australia/Sydney\");\n            map.put(\"SST\", \"Pacific/Guadalcanal\");\n            map.put(\"NST\", \"Pacific/Auckland\");\n            cZoneIdConversion = map;\n        }\n        return map.get(id);\n    }\n\n    private static int parseOffset(String str) {\n        \n        \n        Chronology chrono = new BaseChronology() {\n            public DateTimeZone getZone() {\n                return null;\n            }\n            public Chronology withUTC() {\n                return this;\n            }\n            public Chronology withZone(DateTimeZone zone) {\n                return this;\n            }\n            public String toString() {\n                return getClass().getName();\n            }\n        };\n        return -(int) offsetFormatter().withChronology(chrono).parseMillis(str);\n    }\n\n    \n    private static String printOffset(int offset) {\n        StringBuffer buf = new StringBuffer();\n        if (offset >= 0) {\n            buf.append('+');\n        } else {\n            buf.append('-');\n            offset = -offset;\n        }\n\n        int hours = offset / DateTimeConstants.MILLIS_PER_HOUR;\n        FormatUtils.appendPaddedInteger(buf, hours, 2);\n        offset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR;\n\n        int minutes = offset / DateTimeConstants.MILLIS_PER_MINUTE;\n        buf.append(':');\n        FormatUtils.appendPaddedInteger(buf, minutes, 2);\n        offset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n        if (offset == 0) {\n            return buf.toString();\n        }\n\n        int seconds = offset / DateTimeConstants.MILLIS_PER_SECOND;\n        buf.append(':');\n        FormatUtils.appendPaddedInteger(buf, seconds, 2);\n        offset -= seconds * DateTimeConstants.MILLIS_PER_SECOND;\n        if (offset == 0) {\n            return buf.toString();\n        }\n\n        buf.append('.');\n        FormatUtils.appendPaddedInteger(buf, offset, 3);\n        return buf.toString();\n    }\n\n    \n    private static synchronized DateTimeFormatter offsetFormatter() {\n        if (cOffsetFormatter == null) {\n            cOffsetFormatter = new DateTimeFormatterBuilder()\n                .appendTimeZoneOffset(null, true, 2, 4)\n                .toFormatter();\n        }\n        return cOffsetFormatter;\n    }\n\n    \n    \n\n    private final String iID; protected DateTimeZone(String id) {\n        if (id == null) {\n            throw new IllegalArgumentException(\"Id must not be null\");\n        }\n        iID = id;\n    }\n\n    \n    \n\n    \n    @ToString\n    public final String getID() {\n        return iID;\n    }\n\n    \n    public abstract String getNameKey(long instant); public final String getShortName(long instant) {\n        return getShortName(instant, null);\n    }\n\n    \n    public String getShortName(long instant, Locale locale) {\n        if (locale == null) {\n            locale = Locale.getDefault();\n        }\n        String nameKey = getNameKey(instant);\n        if (nameKey == null) {\n            return iID;\n        }\n        String name = cNameProvider.getShortName(locale, iID, nameKey);\n        if (name != null) {\n            return name;\n        }\n        return printOffset(getOffset(instant));\n    }\n\n    \n    public final String getName(long instant) {\n        return getName(instant, null);\n    }\n\n    \n    public String getName(long instant, Locale locale) {\n        if (locale == null) {\n            locale = Locale.getDefault();\n        }\n        String nameKey = getNameKey(instant);\n        if (nameKey == null) {\n            return iID;\n        }\n        String name = cNameProvider.getName(locale, iID, nameKey);\n        if (name != null) {\n            return name;\n        }\n        return printOffset(getOffset(instant));\n    }\n\n    \n    public abstract int getOffset(long instant); public final int getOffset(ReadableInstant instant) {\n        if (instant == null) {\n            return getOffset(DateTimeUtils.currentTimeMillis());\n        }\n        return getOffset(instant.getMillis());\n    }\n\n    \n    public abstract int getStandardOffset(long instant); public boolean isStandardOffset(long instant) {\n        return getOffset(instant) == getStandardOffset(instant);\n    }\n\n    \n    public int getOffsetFromLocal(long instantLocal) {\n        \n        int offsetLocal = getOffset(instantLocal);\n        \n        int offsetAdjusted = getOffset(instantLocal - offsetLocal);\n        \n        if (offsetLocal != offsetAdjusted) {\n            \n            \n            if ((offsetLocal - offsetAdjusted) < 0) {\n                \n                \n                \n                long nextLocal = nextTransition(instantLocal - offsetLocal);\n                long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n                if (nextLocal != nextAdjusted) {\n                    return offsetLocal;\n                }\n            }\n        }\n        return offsetAdjusted;\n    }\n\n    \n    public long convertUTCToLocal(long instantUTC) {\n        int offset = getOffset(instantUTC);\n        long instantLocal = instantUTC + offset;\n        \n        if ((instantUTC ^ instantLocal) < 0 && (instantUTC ^ offset) >= 0) {\n            throw new ArithmeticException(\"Adding time zone offset caused overflow\");\n        }\n        return instantLocal;\n    }\n\n    \n    public long convertLocalToUTC(long instantLocal, boolean strict, long originalInstantUTC) {\n        int offsetOriginal = getOffset(originalInstantUTC);\n        long instantUTC = instantLocal - offsetOriginal;\n        int offsetLocalFromOriginal = getOffset(instantUTC);\n        if (offsetLocalFromOriginal == offsetOriginal) {\n            return instantUTC;\n        }\n        return convertLocalToUTC(instantLocal, strict);\n    }\n\n    \n    public long convertLocalToUTC(long instantLocal, boolean strict) {\n        \n        int offsetLocal = getOffset(instantLocal);\n        \n        int offset = getOffset(instantLocal - offsetLocal);\n        \n        if (offsetLocal != offset) {\n            \n            \n            \n            if (strict || offsetLocal < 0) {\n                \n                long nextLocal = nextTransition(instantLocal - offsetLocal);\n                if (nextLocal == (instantLocal - offsetLocal)) {\n                    nextLocal = Long.MAX_VALUE;\n                }\n                long nextAdjusted = nextTransition(instantLocal - offset);\n                if (nextAdjusted == (instantLocal - offset)) {\n                    nextAdjusted = Long.MAX_VALUE;\n                }\n                if (nextLocal != nextAdjusted) {\n                    \n                    if (strict) {\n                        \n                        throw new IllegalArgumentException(\"Illegal instant due to time zone offset transition: \" +\n                                DateTimeFormat.forPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSS\").print(new Instant(instantLocal)) +\n                                \" (\" + getID() + \")\");\n                    } else {\n                        \n                        \n                        \n                        offset = offsetLocal;\n                    }\n                }\n            }\n        }\n        \n        long instantUTC = instantLocal - offset;\n        \n        if ((instantLocal ^ instantUTC) < 0 && (instantLocal ^ offset) < 0) {\n            throw new ArithmeticException(\"Subtracting time zone offset caused overflow\");\n        }\n        return instantUTC;\n    }\n\n    \n    public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant) {\n        if (newZone == null) {\n            newZone = DateTimeZone.getDefault();\n        }\n        if (newZone == this) {\n            return oldInstant;\n        }\n        long instantLocal = oldInstant + getOffset(oldInstant);\n        return instantLocal - newZone.getOffsetFromLocal(instantLocal);\n    }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n        \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n    public boolean isLocalDateTimeGap(LocalDateTime localDateTime) {\n        if (isFixed()) {\n            return false;\n        }\n        try {\n            localDateTime.toDateTime(this);\n            return false;\n        } catch (IllegalArgumentException ex) {\n            return true;\n        }\n    }\n\n    \n    \n    public abstract boolean isFixed(); public abstract long nextTransition(long instant); public abstract long previousTransition(long instant); public java.util.TimeZone toTimeZone() {\n        return java.util.TimeZone.getTimeZone(iID);\n    }\n\n    \n    public abstract boolean equals(Object object); public int hashCode() {\n        return 57 + getID().hashCode();\n    }\n\n    \n    public String toString() {\n        return getID();\n    }\n\n    \n    protected Object writeReplace() throws ObjectStreamException {\n        return new Stub(iID);\n    }\n\n    \n    private static final class Stub implements Serializable { private static final long serialVersionUID = -6471952376487863581L; private transient String iID; Stub(String id) {\n            iID = id;\n        }\n\n        private void writeObject(ObjectOutputStream out) throws IOException {\n            out.writeUTF(iID);\n        }\n\n        private void readObject(ObjectInputStream in) throws IOException {\n            iID = in.readUTF();\n        }\n\n        private Object readResolve() throws ObjectStreamException {\n            return forID(iID);\n        }\n    }\n}\n",
      "buggy_signatures": [
        "public static DateTimeZone getDefault()",
        "synchronized(DateTimeZone.class)",
        "public static void setDefault(DateTimeZone zone) throws SecurityException",
        "synchronized(DateTimeZone.class)",
        "public static DateTimeZone forID(String id)",
        "public static DateTimeZone forOffsetHours(int hoursOffset) throws IllegalArgumentException",
        "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException",
        "public static DateTimeZone forOffsetMillis(int millisOffset)",
        "public static DateTimeZone forTimeZone(TimeZone zone)",
        "private static synchronized DateTimeZone fixedOffsetZone(String id, int offset)",
        "public static Set<String> getAvailableIDs()",
        "public static Provider getProvider()",
        "public static void setProvider(Provider provider) throws SecurityException",
        "private static void setProvider0(Provider provider)",
        "private static Provider getDefaultProvider()",
        "public static NameProvider getNameProvider()",
        "public static void setNameProvider(NameProvider nameProvider) throws SecurityException",
        "private static void setNameProvider0(NameProvider nameProvider)",
        "private static NameProvider getDefaultNameProvider()",
        "private static synchronized String getConvertedId(String id)",
        "private static int parseOffset(String str)",
        "public DateTimeZone getZone()",
        "public Chronology withUTC()",
        "public Chronology withZone(DateTimeZone zone)",
        "public String toString()",
        "private static String printOffset(int offset)",
        "private static synchronized DateTimeFormatter offsetFormatter()",
        "private final String iID; protected DateTimeZone(String id)",
        "public final String getID()",
        "public abstract String getNameKey(long instant); public final String getShortName(long instant)",
        "public String getShortName(long instant, Locale locale)",
        "public final String getName(long instant)",
        "public String getName(long instant, Locale locale)",
        "public abstract int getOffset(long instant); public final int getOffset(ReadableInstant instant)",
        "public abstract int getStandardOffset(long instant); public boolean isStandardOffset(long instant)",
        "public int getOffsetFromLocal(long instantLocal)",
        "public long convertUTCToLocal(long instantUTC)",
        "public long convertLocalToUTC(long instantLocal, boolean strict)",
        "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)",
        "public boolean isLocalDateTimeGap(LocalDateTime localDateTime)",
        "public abstract boolean isFixed(); public abstract long nextTransition(long instant); public abstract long previousTransition(long instant); public java.util.TimeZone toTimeZone()",
        "public abstract boolean equals(Object object); public int hashCode()",
        "public String toString()",
        "protected Object writeReplace() throws ObjectStreamException",
        "private void writeObject(ObjectOutputStream out) throws IOException",
        "private void readObject(ObjectInputStream in) throws IOException",
        "private Object readResolve() throws ObjectStreamException"
      ],
      "fixed_signatures": [
        "public static DateTimeZone getDefault()",
        "synchronized(DateTimeZone.class)",
        "public static void setDefault(DateTimeZone zone) throws SecurityException",
        "synchronized(DateTimeZone.class)",
        "public static DateTimeZone forID(String id)",
        "public static DateTimeZone forOffsetHours(int hoursOffset) throws IllegalArgumentException",
        "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException",
        "public static DateTimeZone forOffsetMillis(int millisOffset)",
        "public static DateTimeZone forTimeZone(TimeZone zone)",
        "private static synchronized DateTimeZone fixedOffsetZone(String id, int offset)",
        "public static Set<String> getAvailableIDs()",
        "public static Provider getProvider()",
        "public static void setProvider(Provider provider) throws SecurityException",
        "private static void setProvider0(Provider provider)",
        "private static Provider getDefaultProvider()",
        "public static NameProvider getNameProvider()",
        "public static void setNameProvider(NameProvider nameProvider) throws SecurityException",
        "private static void setNameProvider0(NameProvider nameProvider)",
        "private static NameProvider getDefaultNameProvider()",
        "private static synchronized String getConvertedId(String id)",
        "private static int parseOffset(String str)",
        "public DateTimeZone getZone()",
        "public Chronology withUTC()",
        "public Chronology withZone(DateTimeZone zone)",
        "public String toString()",
        "private static String printOffset(int offset)",
        "private static synchronized DateTimeFormatter offsetFormatter()",
        "private final String iID; protected DateTimeZone(String id)",
        "public final String getID()",
        "public abstract String getNameKey(long instant); public final String getShortName(long instant)",
        "public String getShortName(long instant, Locale locale)",
        "public final String getName(long instant)",
        "public String getName(long instant, Locale locale)",
        "public abstract int getOffset(long instant); public final int getOffset(ReadableInstant instant)",
        "public abstract int getStandardOffset(long instant); public boolean isStandardOffset(long instant)",
        "public int getOffsetFromLocal(long instantLocal)",
        "public long convertUTCToLocal(long instantUTC)",
        "public long convertLocalToUTC(long instantLocal, boolean strict, long originalInstantUTC)",
        "public long convertLocalToUTC(long instantLocal, boolean strict)",
        "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)",
        "public boolean isLocalDateTimeGap(LocalDateTime localDateTime)",
        "public abstract boolean isFixed(); public abstract long nextTransition(long instant); public abstract long previousTransition(long instant); public java.util.TimeZone toTimeZone()",
        "public abstract boolean equals(Object object); public int hashCode()",
        "public String toString()",
        "protected Object writeReplace() throws ObjectStreamException",
        "private void writeObject(ObjectOutputStream out) throws IOException",
        "private void readObject(ObjectInputStream in) throws IOException",
        "private Object readResolve() throws ObjectStreamException"
      ],
      "methods": [
        {
          "buggy_method": "  public long convertUTCToLocal(long instantUTC) {\n  int offset = getOffset(instantUTC);\n  long instantLocal = instantUTC + offset;\n  \n  if ((instantUTC ^ instantLocal) < 0 && (instantUTC ^ offset) >= 0) {\n  throw new ArithmeticException(\"Adding time zone offset caused overflow\");\n  }\n  return instantLocal;\n  }",
          "fixed_method": "  public long convertLocalToUTC(long instantLocal, boolean strict, long originalInstantUTC) {\n  int offsetOriginal = getOffset(originalInstantUTC);\n  long instantUTC = instantLocal - offsetOriginal;\n  int offsetLocalFromOriginal = getOffset(instantUTC);\n  if (offsetLocalFromOriginal == offsetOriginal) {\n  return instantUTC;\n  }\n  return convertLocalToUTC(instantLocal, strict);\n  }",
          "diff": [
            "@@ -933,6 +933,15 @@",
            "      * @throws IllegalArgumentException if the zone has no equivalent local time\n",
            "      * @since 2.0\n",
            "      */\n",
            "+    public long convertLocalToUTC(long instantLocal, boolean strict, long originalInstantUTC) {\n",
            "+        int offsetOriginal = getOffset(originalInstantUTC);\n",
            "+        long instantUTC = instantLocal - offsetOriginal;\n",
            "+        int offsetLocalFromOriginal = getOffset(instantUTC);\n",
            "+        if (offsetLocalFromOriginal == offsetOriginal) {\n",
            "+            return instantUTC;\n",
            "+        }\n",
            "+        return convertLocalToUTC(instantLocal, strict);\n",
            "+    }\n",
            " \n",
            "     /**\n",
            "      * Converts a local instant to a standard UTC instant with the same\n"
          ],
          "changed_lines": 9
        }
      ]
    },
    {
      "name": "org/joda/time/field/LenientDateTimeField.java",
      "buggy_full_code": "\npackage org.joda.time.field;\n\nimport org.joda.time.Chronology;\nimport org.joda.time.DateTimeField;\n\n\npublic class LenientDateTimeField extends DelegatedDateTimeField { private static final long serialVersionUID = 8714085824173290599L; private final Chronology iBase; public static DateTimeField getInstance(DateTimeField field, Chronology base) {\n        if (field == null) {\n            return null;\n        }\n        if (field instanceof StrictDateTimeField) {\n            field = ((StrictDateTimeField)field).getWrappedField();\n        }\n        if (field.isLenient()) {\n            return field;\n        }\n        return new LenientDateTimeField(field, base);\n    }\n\n    protected LenientDateTimeField(DateTimeField field, Chronology base) {\n        super(field);\n        iBase = base;\n    }\n\n    public final boolean isLenient() {\n        return true;\n    }\n\n    \n    public long set(long instant, int value) {\n        \n        \n        long localInstant = iBase.getZone().convertUTCToLocal(instant);\n        long difference = FieldUtils.safeSubtract(value, get(instant));\n        localInstant = getType().getField(iBase.withUTC()).add(localInstant, difference);\n        return iBase.getZone().convertLocalToUTC(localInstant, false);\n    }\n}\n",
      "fixed_full_code": "\npackage org.joda.time.field;\n\nimport org.joda.time.Chronology;\nimport org.joda.time.DateTimeField;\n\n\npublic class LenientDateTimeField extends DelegatedDateTimeField { private static final long serialVersionUID = 8714085824173290599L; private final Chronology iBase; public static DateTimeField getInstance(DateTimeField field, Chronology base) {\n        if (field == null) {\n            return null;\n        }\n        if (field instanceof StrictDateTimeField) {\n            field = ((StrictDateTimeField)field).getWrappedField();\n        }\n        if (field.isLenient()) {\n            return field;\n        }\n        return new LenientDateTimeField(field, base);\n    }\n\n    protected LenientDateTimeField(DateTimeField field, Chronology base) {\n        super(field);\n        iBase = base;\n    }\n\n    public final boolean isLenient() {\n        return true;\n    }\n\n    \n    public long set(long instant, int value) {\n        \n        \n        long localInstant = iBase.getZone().convertUTCToLocal(instant);\n        long difference = FieldUtils.safeSubtract(value, get(instant));\n        localInstant = getType().getField(iBase.withUTC()).add(localInstant, difference);\n        return iBase.getZone().convertLocalToUTC(localInstant, false, instant);\n    }\n}\n",
      "buggy_signatures": [
        "protected LenientDateTimeField(DateTimeField field, Chronology base)",
        "public final boolean isLenient()",
        "public long set(long instant, int value)"
      ],
      "fixed_signatures": [
        "protected LenientDateTimeField(DateTimeField field, Chronology base)",
        "public final boolean isLenient()",
        "public long set(long instant, int value)"
      ],
      "methods": [
        {
          "buggy_method": "  public long set(long instant, int value) {\n  \n  \n  long localInstant = iBase.getZone().convertUTCToLocal(instant);\n  long difference = FieldUtils.safeSubtract(value, get(instant));\n  localInstant = getType().getField(iBase.withUTC()).add(localInstant, difference);\n  return iBase.getZone().convertLocalToUTC(localInstant, false);\n  }",
          "fixed_method": "  public long set(long instant, int value) {\n  \n  \n  long localInstant = iBase.getZone().convertUTCToLocal(instant);\n  long difference = FieldUtils.safeSubtract(value, get(instant));\n  localInstant = getType().getField(iBase.withUTC()).add(localInstant, difference);\n  return iBase.getZone().convertLocalToUTC(localInstant, false, instant);\n  }",
          "diff": [
            "@@ -72,6 +72,6 @@",
            "         long localInstant = iBase.getZone().convertUTCToLocal(instant);\n",
            "         long difference = FieldUtils.safeSubtract(value, get(instant));\n",
            "         localInstant = getType().getField(iBase.withUTC()).add(localInstant, difference);\n",
            "-        return iBase.getZone().convertLocalToUTC(localInstant, false);\n",
            "+        return iBase.getZone().convertLocalToUTC(localInstant, false, instant);\n",
            "     }\n",
            " }\n"
          ],
          "changed_lines": 2
        }
      ]
    }
  ]
}
