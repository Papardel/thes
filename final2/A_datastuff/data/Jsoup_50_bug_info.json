{
  "bug_id": "50",
  "failed_tests": {
    "org.jsoup.helper.DataUtilTest": [
      {
        "methodName": "supportsBOMinFiles",
        "error": "junit.framework.AssertionFailedError",
        "message": "",
        "fail_line": "        assertTrue(doc.title().contains(\"UTF-16BE\"));",
        "test_source": "  public void supportsBOMinFiles() throws IOException {\n  // test files from http://www.i18nl10n.com/korean/utftest/\n  File in = getFile(\"/bomtests/bom_utf16be.html\");\n  Document doc = Jsoup.parse(in, null, \"http://example.com\");\n  assertTrue(doc.title().contains(\"UTF-16BE\"));\n  assertTrue(doc.text().contains(\"가각갂갃간갅\"));\n\n  in = getFile(\"/bomtests/bom_utf16le.html\");\n  doc = Jsoup.parse(in, null, \"http://example.com\");\n  assertTrue(doc.title().contains(\"UTF-16LE\"));\n  assertTrue(doc.text().contains(\"가각갂갃간갅\"));\n\n  in = getFile(\"/bomtests/bom_utf32be.html\");\n  doc = Jsoup.parse(in, null, \"http://example.com\");\n  assertTrue(doc.title().contains(\"UTF-32BE\"));\n  assertTrue(doc.text().contains(\"가각갂갃간갅\"));\n\n  in = getFile(\"/bomtests/bom_utf32le.html\");\n  doc = Jsoup.parse(in, null, \"http://example.com\");\n  assertTrue(doc.title().contains(\"UTF-32LE\"));\n  assertTrue(doc.text().contains(\"가각갂갃간갅\"));\n  }",
        "stack": [
          "DataUtilTest.supportsBOMinFiles line 109"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/jsoup/helper/DataUtil.java",
      "buggy_full_code": "package org.jsoup.helper;\n\nimport org.jsoup.nodes.Document;\nimport org.jsoup.nodes.Element;\nimport org.jsoup.parser.Parser;\n\nimport java.io.*;\nimport java.nio.ByteBuffer;\nimport java.nio.charset.Charset;\nimport java.nio.charset.IllegalCharsetNameException;\nimport java.util.Locale;\nimport java.util.Random;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n\npublic final class DataUtil { private static final Pattern charsetPattern = Pattern.compile(\"(?i)\\\\bcharset=\\\\s*(?:\\\"|')?([^\\\\s,;\\\"']*)\"); static final String defaultCharset = \"UTF-8\"; private static final int bufferSize = 0x20000; private static final int UNICODE_BOM = 0xFEFF; private static final char[] mimeBoundaryChars = \"-_1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\".toCharArray(); static final int boundaryLength = 32; private DataUtil() {}\n\n    \n    public static Document load(File in, String charsetName, String baseUri) throws IOException {\n        ByteBuffer byteData = readFileToByteBuffer(in);\n        return parseByteData(byteData, charsetName, baseUri, Parser.htmlParser());\n    }\n\n    \n    public static Document load(InputStream in, String charsetName, String baseUri) throws IOException {\n        ByteBuffer byteData = readToByteBuffer(in);\n        return parseByteData(byteData, charsetName, baseUri, Parser.htmlParser());\n    }\n\n    \n    public static Document load(InputStream in, String charsetName, String baseUri, Parser parser) throws IOException {\n        ByteBuffer byteData = readToByteBuffer(in);\n        return parseByteData(byteData, charsetName, baseUri, parser);\n    }\n\n    \n    static void crossStreams(final InputStream in, final OutputStream out) throws IOException {\n        final byte[] buffer = new byte[bufferSize];\n        int len;\n        while ((len = in.read(buffer)) != -1) {\n            out.write(buffer, 0, len);\n        }\n    }\n\n    \n    \n    \n    static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n        String docData;\n        Document doc = null;\n\n        \n\n        if (charsetName == null) { \n            \n            docData = Charset.forName(defaultCharset).decode(byteData).toString();\n            doc = parser.parseInput(docData, baseUri);\n            Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n            if (meta != null) { \n                String foundCharset = null;\n                if (meta.hasAttr(\"http-equiv\")) {\n                    foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n                }\n                if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                    try {\n                        if (Charset.isSupported(meta.attr(\"charset\"))) {\n                            foundCharset = meta.attr(\"charset\");\n                        }\n                    } catch (IllegalCharsetNameException e) {\n                        foundCharset = null;\n                    }\n                }\n\n                if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) { \n                    foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                    charsetName = foundCharset;\n                    byteData.rewind();\n                    docData = Charset.forName(foundCharset).decode(byteData).toString();\n                    doc = null;\n                }\n            }\n        } else { \n            Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n            docData = Charset.forName(charsetName).decode(byteData).toString();\n        }\n        if (docData.length() > 0 && docData.charAt(0) == UNICODE_BOM) {\n            byteData.rewind();\n            docData = Charset.forName(defaultCharset).decode(byteData).toString();\n            docData = docData.substring(1);\n            charsetName = defaultCharset;\n            doc = null;\n        }\n        if (doc == null) {\n            doc = parser.parseInput(docData, baseUri);\n            doc.outputSettings().charset(charsetName);\n        }\n        return doc;\n    }\n\n    \n    static ByteBuffer readToByteBuffer(InputStream inStream, int maxSize) throws IOException {\n        Validate.isTrue(maxSize >= 0, \"maxSize must be 0 (unlimited) or larger\");\n        final boolean capped = maxSize > 0;\n        byte[] buffer = new byte[bufferSize];\n        ByteArrayOutputStream outStream = new ByteArrayOutputStream(bufferSize);\n        int read;\n        int remaining = maxSize;\n\n        while (true) {\n            read = inStream.read(buffer);\n            if (read == -1) break;\n            if (capped) {\n                if (read > remaining) {\n                    outStream.write(buffer, 0, remaining);\n                    break;\n                }\n                remaining -= read;\n            }\n            outStream.write(buffer, 0, read);\n        }\n        return ByteBuffer.wrap(outStream.toByteArray());\n    }\n\n    static ByteBuffer readToByteBuffer(InputStream inStream) throws IOException {\n        return readToByteBuffer(inStream, 0);\n    }\n\n    static ByteBuffer readFileToByteBuffer(File file) throws IOException {\n        RandomAccessFile randomAccessFile = null;\n        try {\n            randomAccessFile = new RandomAccessFile(file, \"r\");\n            byte[] bytes = new byte[(int) randomAccessFile.length()];\n            randomAccessFile.readFully(bytes);\n            return ByteBuffer.wrap(bytes);\n        } finally {\n            if (randomAccessFile != null)\n                randomAccessFile.close();\n        }\n    }\n\n    static ByteBuffer emptyByteBuffer() {\n        return ByteBuffer.allocate(0);\n    }\n\n    \n    static String getCharsetFromContentType(String contentType) {\n        if (contentType == null) return null;\n        Matcher m = charsetPattern.matcher(contentType);\n        if (m.find()) {\n            String charset = m.group(1).trim();\n            charset = charset.replace(\"charset=\", \"\");\n            if (charset.length() == 0) return null;\n            try {\n                if (Charset.isSupported(charset)) return charset;\n                charset = charset.toUpperCase(Locale.ENGLISH);\n                if (Charset.isSupported(charset)) return charset;\n            } catch (IllegalCharsetNameException e) {\n                \n                return null;\n            }\n        }\n        return null;\n    }\n\n    \n    static String mimeBoundary() {\n        final StringBuilder mime = new StringBuilder(boundaryLength);\n        final Random rand = new Random();\n        for (int i = 0; i < boundaryLength; i++) {\n            mime.append(mimeBoundaryChars[rand.nextInt(mimeBoundaryChars.length)]);\n        }\n        return mime.toString();\n    }\n}\n",
      "fixed_full_code": "package org.jsoup.helper;\n\nimport org.jsoup.nodes.Document;\nimport org.jsoup.nodes.Element;\nimport org.jsoup.parser.Parser;\n\nimport java.io.*;\nimport java.nio.ByteBuffer;\nimport java.nio.charset.Charset;\nimport java.nio.charset.IllegalCharsetNameException;\nimport java.util.Locale;\nimport java.util.Random;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n\npublic final class DataUtil { private static final Pattern charsetPattern = Pattern.compile(\"(?i)\\\\bcharset=\\\\s*(?:\\\"|')?([^\\\\s,;\\\"']*)\"); static final String defaultCharset = \"UTF-8\"; private static final int bufferSize = 0x20000; private static final int UNICODE_BOM = 0xFEFF; private static final char[] mimeBoundaryChars = \"-_1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\".toCharArray(); static final int boundaryLength = 32; private DataUtil() {}\n\n    \n    public static Document load(File in, String charsetName, String baseUri) throws IOException {\n        ByteBuffer byteData = readFileToByteBuffer(in);\n        return parseByteData(byteData, charsetName, baseUri, Parser.htmlParser());\n    }\n\n    \n    public static Document load(InputStream in, String charsetName, String baseUri) throws IOException {\n        ByteBuffer byteData = readToByteBuffer(in);\n        return parseByteData(byteData, charsetName, baseUri, Parser.htmlParser());\n    }\n\n    \n    public static Document load(InputStream in, String charsetName, String baseUri, Parser parser) throws IOException {\n        ByteBuffer byteData = readToByteBuffer(in);\n        return parseByteData(byteData, charsetName, baseUri, parser);\n    }\n\n    \n    static void crossStreams(final InputStream in, final OutputStream out) throws IOException {\n        final byte[] buffer = new byte[bufferSize];\n        int len;\n        while ((len = in.read(buffer)) != -1) {\n            out.write(buffer, 0, len);\n        }\n    }\n\n    \n    \n    \n    static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n        String docData;\n        Document doc = null;\n\n        \n        byteData.mark();\n        byte[] bom = new byte[4];\n        byteData.get(bom);\n        byteData.rewind();\n        if (bom[0] == 0x00 && bom[1] == 0x00 && bom[2] == (byte) 0xFE && bom[3] == (byte) 0xFF || \n                bom[0] == (byte) 0xFF && bom[1] == (byte) 0xFE && bom[2] == 0x00 && bom[3] == 0x00) { \n            charsetName = \"UTF-32\"; \n        } else if (bom[0] == (byte) 0xFE && bom[1] == (byte) 0xFF || \n                bom[0] == (byte) 0xFF && bom[1] == (byte) 0xFE) {\n            charsetName = \"UTF-16\"; \n        } else if (bom[0] == (byte) 0xEF && bom[1] == (byte) 0xBB && bom[2] == (byte) 0xBF) {\n            charsetName = \"UTF-8\"; \n            byteData.position(3); \n        }\n\n        if (charsetName == null) { \n            \n            docData = Charset.forName(defaultCharset).decode(byteData).toString();\n            doc = parser.parseInput(docData, baseUri);\n            Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n            if (meta != null) { \n                String foundCharset = null;\n                if (meta.hasAttr(\"http-equiv\")) {\n                    foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n                }\n                if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                    try {\n                        if (Charset.isSupported(meta.attr(\"charset\"))) {\n                            foundCharset = meta.attr(\"charset\");\n                        }\n                    } catch (IllegalCharsetNameException e) {\n                        foundCharset = null;\n                    }\n                }\n\n                if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) { \n                    foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                    charsetName = foundCharset;\n                    byteData.rewind();\n                    docData = Charset.forName(foundCharset).decode(byteData).toString();\n                    doc = null;\n                }\n            }\n        } else { \n            Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n            docData = Charset.forName(charsetName).decode(byteData).toString();\n        }\n        if (doc == null) {\n            doc = parser.parseInput(docData, baseUri);\n            doc.outputSettings().charset(charsetName);\n        }\n        return doc;\n    }\n\n    \n    static ByteBuffer readToByteBuffer(InputStream inStream, int maxSize) throws IOException {\n        Validate.isTrue(maxSize >= 0, \"maxSize must be 0 (unlimited) or larger\");\n        final boolean capped = maxSize > 0;\n        byte[] buffer = new byte[bufferSize];\n        ByteArrayOutputStream outStream = new ByteArrayOutputStream(bufferSize);\n        int read;\n        int remaining = maxSize;\n\n        while (true) {\n            read = inStream.read(buffer);\n            if (read == -1) break;\n            if (capped) {\n                if (read > remaining) {\n                    outStream.write(buffer, 0, remaining);\n                    break;\n                }\n                remaining -= read;\n            }\n            outStream.write(buffer, 0, read);\n        }\n        return ByteBuffer.wrap(outStream.toByteArray());\n    }\n\n    static ByteBuffer readToByteBuffer(InputStream inStream) throws IOException {\n        return readToByteBuffer(inStream, 0);\n    }\n\n    static ByteBuffer readFileToByteBuffer(File file) throws IOException {\n        RandomAccessFile randomAccessFile = null;\n        try {\n            randomAccessFile = new RandomAccessFile(file, \"r\");\n            byte[] bytes = new byte[(int) randomAccessFile.length()];\n            randomAccessFile.readFully(bytes);\n            return ByteBuffer.wrap(bytes);\n        } finally {\n            if (randomAccessFile != null)\n                randomAccessFile.close();\n        }\n    }\n\n    static ByteBuffer emptyByteBuffer() {\n        return ByteBuffer.allocate(0);\n    }\n\n    \n    static String getCharsetFromContentType(String contentType) {\n        if (contentType == null) return null;\n        Matcher m = charsetPattern.matcher(contentType);\n        if (m.find()) {\n            String charset = m.group(1).trim();\n            charset = charset.replace(\"charset=\", \"\");\n            if (charset.length() == 0) return null;\n            try {\n                if (Charset.isSupported(charset)) return charset;\n                charset = charset.toUpperCase(Locale.ENGLISH);\n                if (Charset.isSupported(charset)) return charset;\n            } catch (IllegalCharsetNameException e) {\n                \n                return null;\n            }\n        }\n        return null;\n    }\n\n    \n    static String mimeBoundary() {\n        final StringBuilder mime = new StringBuilder(boundaryLength);\n        final Random rand = new Random();\n        for (int i = 0; i < boundaryLength; i++) {\n            mime.append(mimeBoundaryChars[rand.nextInt(mimeBoundaryChars.length)]);\n        }\n        return mime.toString();\n    }\n}\n",
      "buggy_signatures": [
        "public static Document load(File in, String charsetName, String baseUri) throws IOException",
        "public static Document load(InputStream in, String charsetName, String baseUri) throws IOException",
        "public static Document load(InputStream in, String charsetName, String baseUri, Parser parser) throws IOException",
        "static void crossStreams(final InputStream in, final OutputStream out) throws IOException",
        "static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser)",
        "static ByteBuffer readToByteBuffer(InputStream inStream, int maxSize) throws IOException",
        "static ByteBuffer readToByteBuffer(InputStream inStream) throws IOException",
        "static ByteBuffer readFileToByteBuffer(File file) throws IOException",
        "static ByteBuffer emptyByteBuffer()",
        "static String getCharsetFromContentType(String contentType)",
        "static String mimeBoundary()"
      ],
      "fixed_signatures": [
        "public static Document load(File in, String charsetName, String baseUri) throws IOException",
        "public static Document load(InputStream in, String charsetName, String baseUri) throws IOException",
        "public static Document load(InputStream in, String charsetName, String baseUri, Parser parser) throws IOException",
        "static void crossStreams(final InputStream in, final OutputStream out) throws IOException",
        "static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser)",
        "static ByteBuffer readToByteBuffer(InputStream inStream, int maxSize) throws IOException",
        "static ByteBuffer readToByteBuffer(InputStream inStream) throws IOException",
        "static ByteBuffer readFileToByteBuffer(File file) throws IOException",
        "static ByteBuffer emptyByteBuffer()",
        "static String getCharsetFromContentType(String contentType)",
        "static String mimeBoundary()"
      ],
      "methods": [
        {
          "buggy_method": "  static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n  String docData;\n  Document doc = null;\n\n  \n\n  if (charsetName == null) { \n  \n  docData = Charset.forName(defaultCharset).decode(byteData).toString();\n  doc = parser.parseInput(docData, baseUri);\n  Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n  if (meta != null) { \n  String foundCharset = null;\n  if (meta.hasAttr(\"http-equiv\")) {\n  foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n  }\n  if (foundCharset == null && meta.hasAttr(\"charset\")) {\n  try {\n  if (Charset.isSupported(meta.attr(\"charset\"))) {\n  foundCharset = meta.attr(\"charset\");\n  }\n  } catch (IllegalCharsetNameException e) {\n  foundCharset = null;\n  }\n  }\n\n  if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) { \n  foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n  charsetName = foundCharset;\n  byteData.rewind();\n  docData = Charset.forName(foundCharset).decode(byteData).toString();\n  doc = null;\n  }\n  }\n  } else { \n  Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n  docData = Charset.forName(charsetName).decode(byteData).toString();\n  }\n  if (docData.length() > 0 && docData.charAt(0) == UNICODE_BOM) {\n  byteData.rewind();\n  docData = Charset.forName(defaultCharset).decode(byteData).toString();\n  docData = docData.substring(1);\n  charsetName = defaultCharset;\n  doc = null;\n  }\n  if (doc == null) {\n  doc = parser.parseInput(docData, baseUri);\n  doc.outputSettings().charset(charsetName);\n  }\n  return doc;\n  }",
          "fixed_method": "  static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n  String docData;\n  Document doc = null;\n\n  \n  byteData.mark();\n  byte[] bom = new byte[4];\n  byteData.get(bom);\n  byteData.rewind();\n  if (bom[0] == 0x00 && bom[1] == 0x00 && bom[2] == (byte) 0xFE && bom[3] == (byte) 0xFF || \n  bom[0] == (byte) 0xFF && bom[1] == (byte) 0xFE && bom[2] == 0x00 && bom[3] == 0x00) { \n  charsetName = \"UTF-32\"; \n  } else if (bom[0] == (byte) 0xFE && bom[1] == (byte) 0xFF || \n  bom[0] == (byte) 0xFF && bom[1] == (byte) 0xFE) {\n  charsetName = \"UTF-16\"; \n  } else if (bom[0] == (byte) 0xEF && bom[1] == (byte) 0xBB && bom[2] == (byte) 0xBF) {\n  charsetName = \"UTF-8\"; \n  byteData.position(3); \n  }\n\n  if (charsetName == null) { \n  \n  docData = Charset.forName(defaultCharset).decode(byteData).toString();\n  doc = parser.parseInput(docData, baseUri);\n  Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n  if (meta != null) { \n  String foundCharset = null;\n  if (meta.hasAttr(\"http-equiv\")) {\n  foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n  }\n  if (foundCharset == null && meta.hasAttr(\"charset\")) {\n  try {\n  if (Charset.isSupported(meta.attr(\"charset\"))) {\n  foundCharset = meta.attr(\"charset\");\n  }\n  } catch (IllegalCharsetNameException e) {\n  foundCharset = null;\n  }\n  }\n\n  if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) { \n  foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n  charsetName = foundCharset;\n  byteData.rewind();\n  docData = Charset.forName(foundCharset).decode(byteData).toString();\n  doc = null;\n  }\n  }\n  } else { \n  Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n  docData = Charset.forName(charsetName).decode(byteData).toString();\n  }\n  if (doc == null) {\n  doc = parser.parseInput(docData, baseUri);\n  doc.outputSettings().charset(charsetName);\n  }\n  return doc;\n  }",
          "diff": [
            "@@ -90,6 +90,20 @@",
            "         Document doc = null;\n",
            " \n",
            "         // look for BOM - overrides any other header or input\n",
            "+        byteData.mark();\n",
            "+        byte[] bom = new byte[4];\n",
            "+        byteData.get(bom);\n",
            "+        byteData.rewind();\n",
            "+        if (bom[0] == 0x00 && bom[1] == 0x00 && bom[2] == (byte) 0xFE && bom[3] == (byte) 0xFF || // BE\n",
            "+                bom[0] == (byte) 0xFF && bom[1] == (byte) 0xFE && bom[2] == 0x00 && bom[3] == 0x00) { // LE\n",
            "+            charsetName = \"UTF-32\"; // and I hope it's on your system\n",
            "+        } else if (bom[0] == (byte) 0xFE && bom[1] == (byte) 0xFF || // BE\n",
            "+                bom[0] == (byte) 0xFF && bom[1] == (byte) 0xFE) {\n",
            "+            charsetName = \"UTF-16\"; // in all Javas\n",
            "+        } else if (bom[0] == (byte) 0xEF && bom[1] == (byte) 0xBB && bom[2] == (byte) 0xBF) {\n",
            "+            charsetName = \"UTF-8\"; // in all Javas\n",
            "+            byteData.position(3); // 16 and 32 decoders consume the BOM to determine be/le; utf-8 should be consumed\n",
            "+        }\n",
            " \n",
            "         if (charsetName == null) { // determine from meta. safe parse as UTF-8\n",
            "             // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n",
            "@@ -122,13 +136,6 @@",
            "         } else { // specified by content type header (or by user on file load)\n",
            "             Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n",
            "             docData = Charset.forName(charsetName).decode(byteData).toString();\n",
            "-        }\n",
            "-        if (docData.length() > 0 && docData.charAt(0) == UNICODE_BOM) {\n",
            "-            byteData.rewind();\n",
            "-            docData = Charset.forName(defaultCharset).decode(byteData).toString();\n",
            "-            docData = docData.substring(1);\n",
            "-            charsetName = defaultCharset;\n",
            "-            doc = null;\n",
            "         }\n",
            "         if (doc == null) {\n",
            "             doc = parser.parseInput(docData, baseUri);\n"
          ],
          "changed_lines": 21
        }
      ]
    }
  ]
}
