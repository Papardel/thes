{
  "bug_id": "30",
  "failed_tests": {
    "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest": [
      {
        "methodName": "testContainsNone_CharArrayWithSupplementaryChars",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<true> but was:<false>",
        "fail_line": "        assertEquals(true, StringUtils.containsNone(CharU20000, CharU20001.toCharArray()));",
        "test_source": "  public void testContainsNone_CharArrayWithSupplementaryChars() {\n  assertEquals(false, StringUtils.containsNone(CharU20000 + CharU20001, CharU20000.toCharArray()));\n  assertEquals(false, StringUtils.containsNone(CharU20000 + CharU20001, CharU20001.toCharArray()));\n  assertEquals(false, StringUtils.containsNone(CharU20000, CharU20000.toCharArray()));\n  // Sanity check:\n  assertEquals(-1, CharU20000.indexOf(CharU20001));\n  assertEquals(0, CharU20000.indexOf(CharU20001.charAt(0)));\n  assertEquals(-1, CharU20000.indexOf(CharU20001.charAt(1)));\n  // Test:\n  assertEquals(true, StringUtils.containsNone(CharU20000, CharU20001.toCharArray()));\n  assertEquals(true, StringUtils.containsNone(CharU20001, CharU20000.toCharArray()));\n  }",
        "stack": [
          "StringUtilsEqualsIndexOfTest.testContainsNone_CharArrayWithSupplementaryChars line 327"
        ]
      },
      {
        "methodName": "testContainsNone_StringWithSupplementaryChars",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<true> but was:<false>",
        "fail_line": "        assertEquals(true, StringUtils.containsNone(CharU20000, CharU20001));",
        "test_source": "  public void testContainsNone_StringWithSupplementaryChars() {\n  assertEquals(false, StringUtils.containsNone(CharU20000 + CharU20001, CharU20000));\n  assertEquals(false, StringUtils.containsNone(CharU20000 + CharU20001, CharU20001));\n  assertEquals(false, StringUtils.containsNone(CharU20000, CharU20000));\n  // Sanity check:\n  assertEquals(-1, CharU20000.indexOf(CharU20001));\n  assertEquals(0, CharU20000.indexOf(CharU20001.charAt(0)));\n  assertEquals(-1, CharU20000.indexOf(CharU20001.charAt(1)));\n  // Test:\n  assertEquals(true, StringUtils.containsNone(CharU20000, CharU20001));\n  assertEquals(true, StringUtils.containsNone(CharU20001, CharU20000));\n  }",
        "stack": [
          "StringUtilsEqualsIndexOfTest.testContainsNone_StringWithSupplementaryChars line 381"
        ]
      },
      {
        "methodName": "testContainsAny_StringCharArrayWithBadSupplementaryChars",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<false> but was:<true>",
        "fail_line": "        assertEquals(false, StringUtils.containsAny(CharUSuppCharLow, CharU20001.toCharArray()));",
        "test_source": "  public void testContainsAny_StringCharArrayWithBadSupplementaryChars() {\n  // Test edge case: 1/2 of a (broken) supplementary char\n  assertEquals(false, StringUtils.containsAny(CharUSuppCharHigh, CharU20001.toCharArray()));\n  assertEquals(false, StringUtils.containsAny(\"abc\" + CharUSuppCharHigh + \"xyz\", CharU20001.toCharArray()));\n  assertEquals(-1, CharUSuppCharLow.indexOf(CharU20001));\n  assertEquals(false, StringUtils.containsAny(CharUSuppCharLow, CharU20001.toCharArray()));\n  assertEquals(false, StringUtils.containsAny(CharU20001, CharUSuppCharHigh.toCharArray()));\n  assertEquals(0, CharU20001.indexOf(CharUSuppCharLow));\n  assertEquals(true, StringUtils.containsAny(CharU20001, CharUSuppCharLow.toCharArray()));\n  }",
        "stack": [
          "StringUtilsEqualsIndexOfTest.testContainsAny_StringCharArrayWithBadSupplementaryChars line 138"
        ]
      },
      {
        "methodName": "testIndexOfAnyBut_StringStringWithSupplementaryChars",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<2> but was:<3>",
        "fail_line": "        assertEquals(2, StringUtils.indexOfAnyBut(CharU20000 + CharU20001, CharU20000));",
        "test_source": "  public void testIndexOfAnyBut_StringStringWithSupplementaryChars() {\n  assertEquals(2, StringUtils.indexOfAnyBut(CharU20000 + CharU20001, CharU20000));\n  assertEquals(0, StringUtils.indexOfAnyBut(CharU20000 + CharU20001, CharU20001));\n  assertEquals(-1, StringUtils.indexOfAnyBut(CharU20000, CharU20000));\n  assertEquals(0, StringUtils.indexOfAnyBut(CharU20000, CharU20001));  \n  }",
        "stack": [
          "StringUtilsEqualsIndexOfTest.testIndexOfAnyBut_StringStringWithSupplementaryChars line 616"
        ]
      },
      {
        "methodName": "testContainsAny_StringWithBadSupplementaryChars",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<false> but was:<true>",
        "fail_line": "        assertEquals(false, StringUtils.containsAny(CharUSuppCharLow, CharU20001));",
        "test_source": "  public void testContainsAny_StringWithBadSupplementaryChars() {\n  // Test edge case: 1/2 of a (broken) supplementary char\n  assertEquals(false, StringUtils.containsAny(CharUSuppCharHigh, CharU20001));\n  assertEquals(-1, CharUSuppCharLow.indexOf(CharU20001));\n  assertEquals(false, StringUtils.containsAny(CharUSuppCharLow, CharU20001));\n  assertEquals(false, StringUtils.containsAny(CharU20001, CharUSuppCharHigh));\n  assertEquals(0, CharU20001.indexOf(CharUSuppCharLow));\n  assertEquals(true, StringUtils.containsAny(CharU20001, CharUSuppCharLow));\n  }",
        "stack": [
          "StringUtilsEqualsIndexOfTest.testContainsAny_StringWithBadSupplementaryChars line 186"
        ]
      },
      {
        "methodName": "testIndexOfAny_StringCharArrayWithSupplementaryChars",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<2> but was:<0>",
        "fail_line": "        assertEquals(2, StringUtils.indexOfAny(CharU20000 + CharU20001, CharU20001.toCharArray()));",
        "test_source": "  public void testIndexOfAny_StringCharArrayWithSupplementaryChars() {\n  assertEquals(0, StringUtils.indexOfAny(CharU20000 + CharU20001, CharU20000.toCharArray()));\n  assertEquals(2, StringUtils.indexOfAny(CharU20000 + CharU20001, CharU20001.toCharArray()));\n  assertEquals(0, StringUtils.indexOfAny(CharU20000, CharU20000.toCharArray()));\n  assertEquals(-1, StringUtils.indexOfAny(CharU20000, CharU20001.toCharArray()));  \n  }",
        "stack": [
          "StringUtilsEqualsIndexOfTest.testIndexOfAny_StringCharArrayWithSupplementaryChars line 528"
        ]
      },
      {
        "methodName": "testIndexOfAnyBut_StringCharArrayWithSupplementaryChars",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<2> but was:<3>",
        "fail_line": "        assertEquals(2, StringUtils.indexOfAnyBut(CharU20000 + CharU20001, CharU20000.toCharArray()));",
        "test_source": "  public void testIndexOfAnyBut_StringCharArrayWithSupplementaryChars() {\n  assertEquals(2, StringUtils.indexOfAnyBut(CharU20000 + CharU20001, CharU20000.toCharArray()));\n  assertEquals(0, StringUtils.indexOfAnyBut(CharU20000 + CharU20001, CharU20001.toCharArray()));\n  assertEquals(-1, StringUtils.indexOfAnyBut(CharU20000, CharU20000.toCharArray()));\n  assertEquals(0, StringUtils.indexOfAnyBut(CharU20000, CharU20001.toCharArray()));  \n  }",
        "stack": [
          "StringUtilsEqualsIndexOfTest.testIndexOfAnyBut_StringCharArrayWithSupplementaryChars line 593"
        ]
      },
      {
        "methodName": "testContainsNone_StringWithBadSupplementaryChars",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<true> but was:<false>",
        "fail_line": "        assertEquals(true, StringUtils.containsNone(CharUSuppCharLow, CharU20001));",
        "test_source": "  public void testContainsNone_StringWithBadSupplementaryChars() {\n  // Test edge case: 1/2 of a (broken) supplementary char\n  assertEquals(true, StringUtils.containsNone(CharUSuppCharHigh, CharU20001));\n  assertEquals(-1, CharUSuppCharLow.indexOf(CharU20001));\n  assertEquals(true, StringUtils.containsNone(CharUSuppCharLow, CharU20001));\n  assertEquals(-1, CharU20001.indexOf(CharUSuppCharHigh));\n  assertEquals(true, StringUtils.containsNone(CharU20001, CharUSuppCharHigh));\n  assertEquals(0, CharU20001.indexOf(CharUSuppCharLow));\n  assertEquals(false, StringUtils.containsNone(CharU20001, CharUSuppCharLow));  \n  }",
        "stack": [
          "StringUtilsEqualsIndexOfTest.testContainsNone_StringWithBadSupplementaryChars line 362"
        ]
      },
      {
        "methodName": "testIndexOfAny_StringStringWithSupplementaryChars",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<2> but was:<0>",
        "fail_line": "        assertEquals(2, StringUtils.indexOfAny(CharU20000 + CharU20001, CharU20001));",
        "test_source": "  public void testIndexOfAny_StringStringWithSupplementaryChars() {\n  assertEquals(0, StringUtils.indexOfAny(CharU20000 + CharU20001, CharU20000));\n  assertEquals(2, StringUtils.indexOfAny(CharU20000 + CharU20001, CharU20001));\n  assertEquals(0, StringUtils.indexOfAny(CharU20000, CharU20000));\n  assertEquals(-1, StringUtils.indexOfAny(CharU20000, CharU20001));  \n  }",
        "stack": [
          "StringUtilsEqualsIndexOfTest.testIndexOfAny_StringStringWithSupplementaryChars line 571"
        ]
      },
      {
        "methodName": "testContainsNone_CharArrayWithBadSupplementaryChars",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<true> but was:<false>",
        "fail_line": "        assertEquals(true, StringUtils.containsNone(CharUSuppCharLow, CharU20001.toCharArray()));",
        "test_source": "  public void testContainsNone_CharArrayWithBadSupplementaryChars() {\n  // Test edge case: 1/2 of a (broken) supplementary char\n  assertEquals(true, StringUtils.containsNone(CharUSuppCharHigh, CharU20001.toCharArray()));\n  assertEquals(-1, CharUSuppCharLow.indexOf(CharU20001));\n  assertEquals(true, StringUtils.containsNone(CharUSuppCharLow, CharU20001.toCharArray()));\n  assertEquals(-1, CharU20001.indexOf(CharUSuppCharHigh));\n  assertEquals(true, StringUtils.containsNone(CharU20001, CharUSuppCharHigh.toCharArray()));\n  assertEquals(0, CharU20001.indexOf(CharUSuppCharLow));\n  assertEquals(false, StringUtils.containsNone(CharU20001, CharUSuppCharLow.toCharArray()));\n  }",
        "stack": [
          "StringUtilsEqualsIndexOfTest.testContainsNone_CharArrayWithBadSupplementaryChars line 308"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/lang3/StringUtils.java",
      "buggy_full_code": "\npackage org.apache.commons.lang3;\n\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Locale;\n\nimport org.apache.commons.lang3.text.WordUtils;\n\n\n\npublic class StringUtils { public static final String EMPTY = \"\"; public static final int INDEX_NOT_FOUND = -1; private static final int PAD_LIMIT = 8192; public StringUtils() {\n        super();\n    }\n\n    \n    \n    \n    public static boolean isEmpty(CharSequence cs) {\n        return cs == null || cs.length() == 0;\n    }\n\n    \n    public static boolean isNotEmpty(CharSequence cs) {\n        return !StringUtils.isEmpty(cs);\n    }\n\n    \n    public static boolean isBlank(CharSequence cs) {\n        int strLen;\n        if (cs == null || (strLen = cs.length()) == 0) {\n            return true;\n        }\n        for (int i = 0; i < strLen; i++) {\n            if ((Character.isWhitespace(cs.charAt(i)) == false)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public static boolean isNotBlank(CharSequence cs) {\n        return !StringUtils.isBlank(cs);\n    }\n\n    \n    \n    \n    public static String trim(String str) {\n        return str == null ? null : str.trim();\n    }\n\n    \n    public static String trimToNull(String str) {\n        String ts = trim(str);\n        return isEmpty(ts) ? null : ts;\n    }\n\n    \n    public static String trimToEmpty(String str) {\n        return str == null ? EMPTY : str.trim();\n    }\n\n    \n    \n    \n    public static String strip(String str) {\n        return strip(str, null);\n    }\n\n    \n    public static String stripToNull(String str) {\n        if (str == null) {\n            return null;\n        }\n        str = strip(str, null);\n        return str.length() == 0 ? null : str;\n    }\n\n    \n    public static String stripToEmpty(String str) {\n        return str == null ? EMPTY : strip(str, null);\n    }\n\n    \n    public static String strip(String str, String stripChars) {\n        if (isEmpty(str)) {\n            return str;\n        }\n        str = stripStart(str, stripChars);\n        return stripEnd(str, stripChars);\n    }\n\n    \n    public static String stripStart(String str, String stripChars) {\n        int strLen;\n        if (str == null || (strLen = str.length()) == 0) {\n            return str;\n        }\n        int start = 0;\n        if (stripChars == null) {\n            while ((start != strLen) && Character.isWhitespace(str.charAt(start))) {\n                start++;\n            }\n        } else if (stripChars.length() == 0) {\n            return str;\n        } else {\n            while ((start != strLen) && (stripChars.indexOf(str.charAt(start)) != INDEX_NOT_FOUND)) {\n                start++;\n            }\n        }\n        return str.substring(start);\n    }\n\n    \n    public static String stripEnd(String str, String stripChars) {\n        int end;\n        if (str == null || (end = str.length()) == 0) {\n            return str;\n        }\n\n        if (stripChars == null) {\n            while ((end != 0) && Character.isWhitespace(str.charAt(end - 1))) {\n                end--;\n            }\n        } else if (stripChars.length() == 0) {\n            return str;\n        } else {\n            while ((end != 0) && (stripChars.indexOf(str.charAt(end - 1)) != INDEX_NOT_FOUND)) {\n                end--;\n            }\n        }\n        return str.substring(0, end);\n    }\n\n    \n    \n    \n    public static String[] stripAll(String[] strs) {\n        return stripAll(strs, null);\n    }\n\n    \n    public static String[] stripAll(String[] strs, String stripChars) {\n        int strsLen;\n        if (strs == null || (strsLen = strs.length) == 0) {\n            return strs;\n        }\n        String[] newArr = new String[strsLen];\n        for (int i = 0; i < strsLen; i++) {\n            newArr[i] = strip(strs[i], stripChars);\n        }\n        return newArr;\n    }\n\n    \n    public static String stripAccents(String input) {\n        if(input == null) {\n            return null;\n        }\n        if(SystemUtils.isJavaVersionAtLeast(1.6f)) {\n\n            \n\n            \n            try {\n                \n                Class<?> normalizerFormClass = ClassUtils.getClass(\"java.text.Normalizer$Form\", false);\n\n                \n                Class<?> normalizerClass = ClassUtils.getClass(\"java.text.Normalizer\", false);\n\n                \n                java.lang.reflect.Method method = normalizerClass.getMethod(\"normalize\", CharSequence.class, normalizerFormClass );\n\n                \n                java.lang.reflect.Field nfd = normalizerFormClass.getField(\"NFD\");\n\n                \n                String decomposed = (String) method.invoke( null, input, nfd.get(null) );\n                \n\n                java.util.regex.Pattern accentPattern = java.util.regex.Pattern.compile(\"\\\\p{InCombiningDiacriticalMarks}+\");\n                return accentPattern.matcher(decomposed).replaceAll(\"\");\n            } catch(ClassNotFoundException cnfe) {\n                throw new RuntimeException(\"ClassNotFoundException occurred during 1.6 backcompat code\", cnfe);\n            } catch(NoSuchMethodException nsme) {\n                throw new RuntimeException(\"NoSuchMethodException occurred during 1.6 backcompat code\", nsme);\n            } catch(NoSuchFieldException nsfe) {\n                throw new RuntimeException(\"NoSuchFieldException occurred during 1.6 backcompat code\", nsfe);\n            } catch(IllegalAccessException iae) {\n                throw new RuntimeException(\"IllegalAccessException occurred during 1.6 backcompat code\", iae);\n            } catch(IllegalArgumentException iae) {\n                throw new RuntimeException(\"IllegalArgumentException occurred during 1.6 backcompat code\", iae);\n            } catch(java.lang.reflect.InvocationTargetException ite) {\n                throw new RuntimeException(\"InvocationTargetException occurred during 1.6 backcompat code\", ite);\n            } catch(SecurityException se) {\n                throw new RuntimeException(\"SecurityException occurred during 1.6 backcompat code\", se);\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The stripAccents(String) method is not supported until Java 1.6\");\n        }\n    }\n\n    \n    \n    \n    public static boolean equals(CharSequence cs1, CharSequence cs2) {\n        return cs1 == null ? cs2 == null : cs1.equals(cs2);\n    }\n\n    \n    public static boolean equalsIgnoreCase(String str1, String str2) {\n        return str1 == null ? str2 == null : str1.equalsIgnoreCase(str2);\n    }\n\n    \n    \n    \n    public static int indexOf(String str, char searchChar) {\n        if (isEmpty(str)) {\n            return INDEX_NOT_FOUND;\n        }\n        return str.indexOf(searchChar);\n    }\n\n    \n    public static int indexOf(String str, char searchChar, int startPos) {\n        if (isEmpty(str)) {\n            return INDEX_NOT_FOUND;\n        }\n        return str.indexOf(searchChar, startPos);\n    }\n\n    \n    public static int indexOf(String str, String searchStr) {\n        if (str == null || searchStr == null) {\n            return INDEX_NOT_FOUND;\n        }\n        return str.indexOf(searchStr);\n    }\n\n    \n    public static int indexOf(String str, String searchStr, int startPos) {\n        if (str == null || searchStr == null) {\n            return INDEX_NOT_FOUND;\n        }\n        return str.indexOf(searchStr, startPos);\n    }\n\n    \n    public static int ordinalIndexOf(String str, String searchStr, int ordinal) {\n        return ordinalIndexOf(str, searchStr, ordinal, false);\n    }\n\n    \n    \n    private static int ordinalIndexOf(String str, String searchStr, int ordinal, boolean lastIndex) {\n        if (str == null || searchStr == null || ordinal <= 0) {\n            return INDEX_NOT_FOUND;\n        }\n        if (searchStr.length() == 0) {\n            return lastIndex ? str.length() : 0;\n        }\n        int found = 0;\n        int index = lastIndex ? str.length() : INDEX_NOT_FOUND;\n        do {\n            if(lastIndex) {\n                index = str.lastIndexOf(searchStr, index - 1);\n            } else {\n                index = str.indexOf(searchStr, index + 1);\n            }\n            if (index < 0) {\n                return index;\n            }\n            found++;\n        } while (found < ordinal);\n        return index;\n    }\n\n    \n    public static int indexOfIgnoreCase(String str, String searchStr) {\n        return indexOfIgnoreCase(str, searchStr, 0);\n    }\n\n    \n    public static int indexOfIgnoreCase(String str, String searchStr, int startPos) {\n        if (str == null || searchStr == null) {\n            return INDEX_NOT_FOUND;\n        }\n        if (startPos < 0) {\n            startPos = 0;\n        }\n        int endLimit = (str.length() - searchStr.length()) + 1;\n        if (startPos > endLimit) {\n            return INDEX_NOT_FOUND;\n        }\n        if (searchStr.length() == 0) {\n            return startPos;\n        }\n        for (int i = startPos; i < endLimit; i++) {\n            if (str.regionMatches(true, i, searchStr, 0, searchStr.length())) {\n                return i;\n            }\n        }\n        return INDEX_NOT_FOUND;\n    }\n\n    \n    \n    \n    public static int lastIndexOf(String str, char searchChar) {\n        if (isEmpty(str)) {\n            return INDEX_NOT_FOUND;\n        }\n        return str.lastIndexOf(searchChar);\n    }\n\n    \n    public static int lastIndexOf(String str, char searchChar, int startPos) {\n        if (isEmpty(str)) {\n            return INDEX_NOT_FOUND;\n        }\n        return str.lastIndexOf(searchChar, startPos);\n    }\n\n    \n    public static int lastIndexOf(String str, String searchStr) {\n        if (str == null || searchStr == null) {\n            return INDEX_NOT_FOUND;\n        }\n        return str.lastIndexOf(searchStr);\n    }\n\n    \n    public static int lastOrdinalIndexOf(String str, String searchStr, int ordinal) {\n        return ordinalIndexOf(str, searchStr, ordinal, true);\n    }\n\n    \n    public static int lastIndexOf(String str, String searchStr, int startPos) {\n        if (str == null || searchStr == null) {\n            return INDEX_NOT_FOUND;\n        }\n        return str.lastIndexOf(searchStr, startPos);\n    }\n\n    \n    public static int lastIndexOfIgnoreCase(String str, String searchStr) {\n        if (str == null || searchStr == null) {\n            return INDEX_NOT_FOUND;\n        }\n        return lastIndexOfIgnoreCase(str, searchStr, str.length());\n    }\n\n    \n    public static int lastIndexOfIgnoreCase(String str, String searchStr, int startPos) {\n        if (str == null || searchStr == null) {\n            return INDEX_NOT_FOUND;\n        }\n        if (startPos > (str.length() - searchStr.length())) {\n            startPos = str.length() - searchStr.length();\n        }\n        if (startPos < 0) {\n            return INDEX_NOT_FOUND;\n        }\n        if (searchStr.length() == 0) {\n            return startPos;\n        }\n\n        for (int i = startPos; i >= 0; i--) {\n            if (str.regionMatches(true, i, searchStr, 0, searchStr.length())) {\n                return i;\n            }\n        }\n        return INDEX_NOT_FOUND;\n    }\n\n    \n    \n    \n    public static boolean contains(String str, char searchChar) {\n        if (isEmpty(str)) {\n            return false;\n        }\n        return str.indexOf(searchChar) >= 0;\n    }\n\n    \n    public static boolean contains(String str, String searchStr) {\n        if (str == null || searchStr == null) {\n            return false;\n        }\n        return str.indexOf(searchStr) >= 0;\n    }\n\n    \n    public static boolean containsIgnoreCase(String str, String searchStr) {\n        if (str == null || searchStr == null) {\n            return false;\n        }\n        int len = searchStr.length();\n        int max = str.length() - len;\n        for (int i = 0; i <= max; i++) {\n            if (str.regionMatches(true, i, searchStr, 0, len)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    \n    \n    \n    public static int indexOfAny(CharSequence cs, char[] searchChars) {\n        if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n            return INDEX_NOT_FOUND;\n        }\n        int csLen = cs.length();\n        int searchLen = searchChars.length;\n        for (int i = 0; i < csLen; i++) {\n            char ch = cs.charAt(i);\n            for (int j = 0; j < searchLen; j++) {\n                if (searchChars[j] == ch) {\n                        \n                        return i;\n                }\n            }\n        }\n        return INDEX_NOT_FOUND;\n    }\n\n    \n    public static int indexOfAny(CharSequence cs, String searchChars) {\n        if (isEmpty(cs) || isEmpty(searchChars)) {\n            return INDEX_NOT_FOUND;\n        }\n        return indexOfAny(cs, searchChars.toCharArray());\n    }\n\n    \n    \n    \n    public static boolean containsAny(CharSequence cs, char[] searchChars) {\n        if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n            return false;\n        }\n        int csLength = cs.length();\n        int searchLength = searchChars.length;\n        int csLast = csLength - 1;\n        int searchLast = searchLength - 1;\n        for (int i = 0; i < csLength; i++) {\n            char ch = cs.charAt(i);\n            for (int j = 0; j < searchLength; j++) {\n                if (searchChars[j] == ch) {\n                    if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n                            \n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\n    \n    public static boolean containsAny(CharSequence cs, String searchChars) {\n        if (searchChars == null) {\n            return false;\n        }\n        return containsAny(cs, searchChars.toCharArray());\n    }\n\n    \n    \n    \n    public static int indexOfAnyBut(CharSequence cs, char[] searchChars) {\n        if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n            return INDEX_NOT_FOUND;\n        }\n        int csLen = cs.length();\n        int searchLen = searchChars.length;\n        outer:\n        for (int i = 0; i < csLen; i++) {\n            char ch = cs.charAt(i);\n            for (int j = 0; j < searchLen; j++) {\n                if (searchChars[j] == ch) {\n                        continue outer;\n                }\n            }\n            return i;\n        }\n        return INDEX_NOT_FOUND;\n    }\n\n    \n    public static int indexOfAnyBut(String str, String searchChars) {\n        if (isEmpty(str) || isEmpty(searchChars)) {\n            return INDEX_NOT_FOUND;\n        }\n        int strLen = str.length();\n        for (int i = 0; i < strLen; i++) {\n            char ch = str.charAt(i);\n            if (searchChars.indexOf(ch) < 0) {\n                    return i;\n            }\n        }\n        return INDEX_NOT_FOUND;\n    }\n\n    \n    \n    \n    public static boolean containsOnly(CharSequence cs, char[] valid) {\n        \n        if (valid == null || cs == null) {\n            return false;\n        }\n        if (cs.length() == 0) {\n            return true;\n        }\n        if (valid.length == 0) {\n            return false;\n        }\n        return indexOfAnyBut(cs, valid) == INDEX_NOT_FOUND;\n    }\n\n    \n    public static boolean containsOnly(CharSequence cs, String validChars) {\n        if (cs == null || validChars == null) {\n            return false;\n        }\n        return containsOnly(cs, validChars.toCharArray());\n    }\n\n    \n    \n    \n    public static boolean containsNone(CharSequence cs, char[] searchChars) {\n        if (cs == null || searchChars == null) {\n            return true;\n        }\n        int csLen = cs.length();\n        int searchLen = searchChars.length;\n        for (int i = 0; i < csLen; i++) {\n            char ch = cs.charAt(i);\n            for (int j = 0; j < searchLen; j++) {\n                if (searchChars[j] == ch) {\n                            \n                        \n                        return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    \n    public static boolean containsNone(CharSequence cs, String invalidChars) {\n        if (cs == null || invalidChars == null) {\n            return true;\n        }\n        return containsNone(cs, invalidChars.toCharArray());\n    }\n\n    \n    \n    \n    public static int indexOfAny(String str, String[] searchStrs) {\n        if (str == null || searchStrs == null) {\n            return INDEX_NOT_FOUND;\n        }\n        int sz = searchStrs.length;\n\n        \n        int ret = Integer.MAX_VALUE;\n\n        int tmp = 0;\n        for (int i = 0; i < sz; i++) {\n            String search = searchStrs[i];\n            if (search == null) {\n                continue;\n            }\n            tmp = str.indexOf(search);\n            if (tmp == INDEX_NOT_FOUND) {\n                continue;\n            }\n\n            if (tmp < ret) {\n                ret = tmp;\n            }\n        }\n\n        return (ret == Integer.MAX_VALUE) ? INDEX_NOT_FOUND : ret;\n    }\n\n    \n    public static int lastIndexOfAny(String str, String[] searchStrs) {\n        if (str == null || searchStrs == null) {\n            return INDEX_NOT_FOUND;\n        }\n        int sz = searchStrs.length;\n        int ret = INDEX_NOT_FOUND;\n        int tmp = 0;\n        for (int i = 0; i < sz; i++) {\n            String search = searchStrs[i];\n            if (search == null) {\n                continue;\n            }\n            tmp = str.lastIndexOf(search);\n            if (tmp > ret) {\n                ret = tmp;\n            }\n        }\n        return ret;\n    }\n\n    \n    \n    \n    public static String substring(String str, int start) {\n        if (str == null) {\n            return null;\n        }\n\n        \n        if (start < 0) {\n            start = str.length() + start; \n        }\n\n        if (start < 0) {\n            start = 0;\n        }\n        if (start > str.length()) {\n            return EMPTY;\n        }\n\n        return str.substring(start);\n    }\n\n    \n    public static String substring(String str, int start, int end) {\n        if (str == null) {\n            return null;\n        }\n\n        \n        if (end < 0) {\n            end = str.length() + end; \n        }\n        if (start < 0) {\n            start = str.length() + start; \n        }\n\n        \n        if (end > str.length()) {\n            end = str.length();\n        }\n\n        \n        if (start > end) {\n            return EMPTY;\n        }\n\n        if (start < 0) {\n            start = 0;\n        }\n        if (end < 0) {\n            end = 0;\n        }\n\n        return str.substring(start, end);\n    }\n\n    \n    \n    \n    public static String left(String str, int len) {\n        if (str == null) {\n            return null;\n        }\n        if (len < 0) {\n            return EMPTY;\n        }\n        if (str.length() <= len) {\n            return str;\n        }\n        return str.substring(0, len);\n    }\n\n    \n    public static String right(String str, int len) {\n        if (str == null) {\n            return null;\n        }\n        if (len < 0) {\n            return EMPTY;\n        }\n        if (str.length() <= len) {\n            return str;\n        }\n        return str.substring(str.length() - len);\n    }\n\n    \n    public static String mid(String str, int pos, int len) {\n        if (str == null) {\n            return null;\n        }\n        if (len < 0 || pos > str.length()) {\n            return EMPTY;\n        }\n        if (pos < 0) {\n            pos = 0;\n        }\n        if (str.length() <= (pos + len)) {\n            return str.substring(pos);\n        }\n        return str.substring(pos, pos + len);\n    }\n\n    \n    \n    \n    public static String substringBefore(String str, String separator) {\n        if (isEmpty(str) || separator == null) {\n            return str;\n        }\n        if (separator.length() == 0) {\n            return EMPTY;\n        }\n        int pos = str.indexOf(separator);\n        if (pos == INDEX_NOT_FOUND) {\n            return str;\n        }\n        return str.substring(0, pos);\n    }\n\n    \n    public static String substringAfter(String str, String separator) {\n        if (isEmpty(str)) {\n            return str;\n        }\n        if (separator == null) {\n            return EMPTY;\n        }\n        int pos = str.indexOf(separator);\n        if (pos == INDEX_NOT_FOUND) {\n            return EMPTY;\n        }\n        return str.substring(pos + separator.length());\n    }\n\n    \n    public static String substringBeforeLast(String str, String separator) {\n        if (isEmpty(str) || isEmpty(separator)) {\n            return str;\n        }\n        int pos = str.lastIndexOf(separator);\n        if (pos == INDEX_NOT_FOUND) {\n            return str;\n        }\n        return str.substring(0, pos);\n    }\n\n    \n    public static String substringAfterLast(String str, String separator) {\n        if (isEmpty(str)) {\n            return str;\n        }\n        if (isEmpty(separator)) {\n            return EMPTY;\n        }\n        int pos = str.lastIndexOf(separator);\n        if (pos == INDEX_NOT_FOUND || pos == (str.length() - separator.length())) {\n            return EMPTY;\n        }\n        return str.substring(pos + separator.length());\n    }\n\n    \n    \n    \n    public static String substringBetween(String str, String tag) {\n        return substringBetween(str, tag, tag);\n    }\n\n    \n    public static String substringBetween(String str, String open, String close) {\n        if (str == null || open == null || close == null) {\n            return null;\n        }\n        int start = str.indexOf(open);\n        if (start != INDEX_NOT_FOUND) {\n            int end = str.indexOf(close, start + open.length());\n            if (end != INDEX_NOT_FOUND) {\n                return str.substring(start + open.length(), end);\n            }\n        }\n        return null;\n    }\n\n    \n    public static String[] substringsBetween(String str, String open, String close) {\n        if (str == null || isEmpty(open) || isEmpty(close)) {\n            return null;\n        }\n        int strLen = str.length();\n        if (strLen == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n        int closeLen = close.length();\n        int openLen = open.length();\n        List<String> list = new ArrayList<String>();\n        int pos = 0;\n        while (pos < (strLen - closeLen)) {\n            int start = str.indexOf(open, pos);\n            if (start < 0) {\n                break;\n            }\n            start += openLen;\n            int end = str.indexOf(close, start);\n            if (end < 0) {\n                break;\n            }\n            list.add(str.substring(start, end));\n            pos = end + closeLen;\n        }\n        if (list.isEmpty()) {\n            return null;\n        } \n        return list.toArray(new String [list.size()]);\n    }\n\n    \n    \n\n    \n    \n    \n    public static String[] split(String str) {\n        return split(str, null, -1);\n    }\n\n    \n    public static String[] split(String str, char separatorChar) {\n        return splitWorker(str, separatorChar, false);\n    }\n\n    \n    public static String[] split(String str, String separatorChars) {\n        return splitWorker(str, separatorChars, -1, false);\n    }\n\n    \n    public static String[] split(String str, String separatorChars, int max) {\n        return splitWorker(str, separatorChars, max, false);\n    }\n\n    \n    public static String[] splitByWholeSeparator(String str, String separator) {\n        return splitByWholeSeparatorWorker( str, separator, -1, false ) ;\n    }\n\n    \n    public static String[] splitByWholeSeparator( String str, String separator, int max ) {\n        return splitByWholeSeparatorWorker(str, separator, max, false);\n    }\n\n    \n    public static String[] splitByWholeSeparatorPreserveAllTokens(String str, String separator) {\n        return splitByWholeSeparatorWorker(str, separator, -1, true);\n    }\n\n    \n    public static String[] splitByWholeSeparatorPreserveAllTokens(String str, String separator, int max) {\n        return splitByWholeSeparatorWorker(str, separator, max, true);\n    }\n\n    \n    private static String[] splitByWholeSeparatorWorker(String str, String separator, int max, boolean preserveAllTokens) {\n        if (str == null) {\n            return null;\n        }\n\n        int len = str.length();\n\n        if (len == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n\n        if ((separator == null) || (EMPTY.equals(separator))) {\n            \n            return splitWorker(str, null, max, preserveAllTokens);\n        }\n\n        int separatorLength = separator.length();\n\n        ArrayList<String> substrings = new ArrayList<String>();\n        int numberOfSubstrings = 0;\n        int beg = 0;\n        int end = 0;\n        while (end < len) {\n            end = str.indexOf(separator, beg);\n\n            if (end > -1) {\n                if (end > beg) {\n                    numberOfSubstrings += 1;\n\n                    if (numberOfSubstrings == max) {\n                        end = len;\n                        substrings.add(str.substring(beg));\n                    } else {\n                        \n                        \n                        substrings.add(str.substring(beg, end));\n\n                        \n                        \n                        \n                        beg = end + separatorLength;\n                    }\n                } else {\n                    \n                    if (preserveAllTokens) {\n                        numberOfSubstrings += 1;\n                        if (numberOfSubstrings == max) {\n                            end = len;\n                            substrings.add(str.substring(beg));\n                        } else {\n                            substrings.add(EMPTY);\n                        }\n                    }\n                    beg = end + separatorLength;\n                }\n            } else {\n                \n                substrings.add(str.substring(beg));\n                end = len;\n            }\n        }\n\n        return substrings.toArray(new String[substrings.size()]);\n    }\n\n    \n    \n    public static String[] splitPreserveAllTokens(String str) {\n        return splitWorker(str, null, -1, true);\n    }\n\n    \n    public static String[] splitPreserveAllTokens(String str, char separatorChar) {\n        return splitWorker(str, separatorChar, true);\n    }\n\n    \n    private static String[] splitWorker(String str, char separatorChar, boolean preserveAllTokens) {\n        \n\n        if (str == null) {\n            return null;\n        }\n        int len = str.length();\n        if (len == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n        List<String> list = new ArrayList<String>();\n        int i = 0, start = 0;\n        boolean match = false;\n        boolean lastMatch = false;\n        while (i < len) {\n            if (str.charAt(i) == separatorChar) {\n                if (match || preserveAllTokens) {\n                    list.add(str.substring(start, i));\n                    match = false;\n                    lastMatch = true;\n                }\n                start = ++i;\n                continue;\n            }\n            lastMatch = false;\n            match = true;\n            i++;\n        }\n        if (match || (preserveAllTokens && lastMatch)) {\n            list.add(str.substring(start, i));\n        }\n        return list.toArray(new String[list.size()]);\n    }\n\n    \n    public static String[] splitPreserveAllTokens(String str, String separatorChars) {\n        return splitWorker(str, separatorChars, -1, true);\n    }\n\n    \n    public static String[] splitPreserveAllTokens(String str, String separatorChars, int max) {\n        return splitWorker(str, separatorChars, max, true);\n    }\n\n    \n    private static String[] splitWorker(String str, String separatorChars, int max, boolean preserveAllTokens) {\n        \n        \n        \n\n        if (str == null) {\n            return null;\n        }\n        int len = str.length();\n        if (len == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n        List<String> list = new ArrayList<String>();\n        int sizePlus1 = 1;\n        int i = 0, start = 0;\n        boolean match = false;\n        boolean lastMatch = false;\n        if (separatorChars == null) {\n            \n            while (i < len) {\n                if (Character.isWhitespace(str.charAt(i))) {\n                    if (match || preserveAllTokens) {\n                        lastMatch = true;\n                        if (sizePlus1++ == max) {\n                            i = len;\n                            lastMatch = false;\n                        }\n                        list.add(str.substring(start, i));\n                        match = false;\n                    }\n                    start = ++i;\n                    continue;\n                }\n                lastMatch = false;\n                match = true;\n                i++;\n            }\n        } else if (separatorChars.length() == 1) {\n            \n            char sep = separatorChars.charAt(0);\n            while (i < len) {\n                if (str.charAt(i) == sep) {\n                    if (match || preserveAllTokens) {\n                        lastMatch = true;\n                        if (sizePlus1++ == max) {\n                            i = len;\n                            lastMatch = false;\n                        }\n                        list.add(str.substring(start, i));\n                        match = false;\n                    }\n                    start = ++i;\n                    continue;\n                }\n                lastMatch = false;\n                match = true;\n                i++;\n            }\n        } else {\n            \n            while (i < len) {\n                if (separatorChars.indexOf(str.charAt(i)) >= 0) {\n                    if (match || preserveAllTokens) {\n                        lastMatch = true;\n                        if (sizePlus1++ == max) {\n                            i = len;\n                            lastMatch = false;\n                        }\n                        list.add(str.substring(start, i));\n                        match = false;\n                    }\n                    start = ++i;\n                    continue;\n                }\n                lastMatch = false;\n                match = true;\n                i++;\n            }\n        }\n        if (match || (preserveAllTokens && lastMatch)) {\n            list.add(str.substring(start, i));\n        }\n        return list.toArray(new String[list.size()]);\n    }\n\n    \n    public static String[] splitByCharacterType(String str) {\n        return splitByCharacterType(str, false);\n    }\n\n    \n    public static String[] splitByCharacterTypeCamelCase(String str) {\n        return splitByCharacterType(str, true);\n    }\n\n    \n    private static String[] splitByCharacterType(String str, boolean camelCase) {\n        if (str == null) {\n            return null;\n        }\n        if (str.length() == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n        char[] c = str.toCharArray();\n        List<String> list = new ArrayList<String>();\n        int tokenStart = 0;\n        int currentType = Character.getType(c[tokenStart]);\n        for (int pos = tokenStart + 1; pos < c.length; pos++) {\n            int type = Character.getType(c[pos]);\n            if (type == currentType) {\n                continue;\n            }\n            if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n                int newTokenStart = pos - 1;\n                if (newTokenStart != tokenStart) {\n                    list.add(new String(c, tokenStart, newTokenStart - tokenStart));\n                    tokenStart = newTokenStart;\n                }\n            } else {\n                list.add(new String(c, tokenStart, pos - tokenStart));\n                tokenStart = pos;\n            }\n            currentType = type;\n        }\n        list.add(new String(c, tokenStart, c.length - tokenStart));\n        return list.toArray(new String[list.size()]);\n    }\n\n    \n    \n    \n    public static String join(Object[] array) {\n        return join(array, null);\n    }\n\n    \n    public static String join(Object[] array, char separator) {\n        if (array == null) {\n            return null;\n        }\n\n        return join(array, separator, 0, array.length);\n    }\n\n    \n    public static String join(Object[] array, char separator, int startIndex, int endIndex) {\n        if (array == null) {\n            return null;\n        }\n        int bufSize = (endIndex - startIndex);\n        if (bufSize <= 0) {\n            return EMPTY;\n        }\n\n        bufSize *= ((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1);\n        StringBuilder buf = new StringBuilder(bufSize);\n\n        for (int i = startIndex; i < endIndex; i++) {\n            if (i > startIndex) {\n                buf.append(separator);\n            }\n            if (array[i] != null) {\n                buf.append(array[i]);\n            }\n        }\n        return buf.toString();\n    }\n\n\n    \n    public static String join(Object[] array, String separator) {\n        if (array == null) {\n            return null;\n        }\n        return join(array, separator, 0, array.length);\n    }\n\n    \n    public static String join(Object[] array, String separator, int startIndex, int endIndex) {\n        if (array == null) {\n            return null;\n        }\n        if (separator == null) {\n            separator = EMPTY;\n        }\n\n        \n        \n        int bufSize = (endIndex - startIndex);\n        if (bufSize <= 0) {\n            return EMPTY;\n        }\n\n        bufSize *= ((array[startIndex] == null ? 16 : array[startIndex].toString().length())\n                        + separator.length());\n\n        StringBuilder buf = new StringBuilder(bufSize);\n\n        for (int i = startIndex; i < endIndex; i++) {\n            if (i > startIndex) {\n                buf.append(separator);\n            }\n            if (array[i] != null) {\n                buf.append(array[i]);\n            }\n        }\n        return buf.toString();\n    }\n\n    \n    public static String join(Iterator<?> iterator, char separator) {\n\n        \n        if (iterator == null) {\n            return null;\n        }\n        if (!iterator.hasNext()) {\n            return EMPTY;\n        }\n        Object first = iterator.next();\n        if (!iterator.hasNext()) {\n            return ObjectUtils.toString(first);\n        }\n\n        \n        StringBuilder buf = new StringBuilder(256); \n        if (first != null) {\n            buf.append(first);\n        }\n\n        while (iterator.hasNext()) {\n            buf.append(separator);\n            Object obj = iterator.next();\n            if (obj != null) {\n                buf.append(obj);\n            }\n        }\n\n        return buf.toString();\n    }\n\n    \n    public static String join(Iterator<?> iterator, String separator) {\n\n        \n        if (iterator == null) {\n            return null;\n        }\n        if (!iterator.hasNext()) {\n            return EMPTY;\n        }\n        Object first = iterator.next();\n        if (!iterator.hasNext()) {\n            return ObjectUtils.toString(first);\n        }\n\n        \n        StringBuilder buf = new StringBuilder(256); \n        if (first != null) {\n            buf.append(first);\n        }\n\n        while (iterator.hasNext()) {\n            if (separator != null) {\n                buf.append(separator);\n            }\n            Object obj = iterator.next();\n            if (obj != null) {\n                buf.append(obj);\n            }\n        }\n        return buf.toString();\n    }\n\n    \n    public static String join(Iterable<?> iterable, char separator) {\n        if (iterable == null) {\n            return null;\n        }\n        return join(iterable.iterator(), separator);\n    }\n\n    \n    public static String join(Iterable<?> iterable, String separator) {\n        if (iterable == null) {\n            return null;\n        }\n        return join(iterable.iterator(), separator);\n    }\n\n    \n    \n    \n    public static String deleteWhitespace(String str) {\n        if (isEmpty(str)) {\n            return str;\n        }\n        int sz = str.length();\n        char[] chs = new char[sz];\n        int count = 0;\n        for (int i = 0; i < sz; i++) {\n            if (!Character.isWhitespace(str.charAt(i))) {\n                chs[count++] = str.charAt(i);\n            }\n        }\n        if (count == sz) {\n            return str;\n        }\n        return new String(chs, 0, count);\n    }\n\n    \n    \n    \n    public static String removeStart(String str, String remove) {\n        if (isEmpty(str) || isEmpty(remove)) {\n            return str;\n        }\n        if (str.startsWith(remove)){\n            return str.substring(remove.length());\n        }\n        return str;\n    }\n\n    \n    public static String removeStartIgnoreCase(String str, String remove) {\n        if (isEmpty(str) || isEmpty(remove)) {\n            return str;\n        }\n        if (startsWithIgnoreCase(str, remove)) {\n            return str.substring(remove.length());\n        }\n        return str;\n    }\n\n    \n    public static String removeEnd(String str, String remove) {\n        if (isEmpty(str) || isEmpty(remove)) {\n            return str;\n        }\n        if (str.endsWith(remove)) {\n            return str.substring(0, str.length() - remove.length());\n        }\n        return str;\n    }\n\n    \n    public static String removeEndIgnoreCase(String str, String remove) {\n        if (isEmpty(str) || isEmpty(remove)) {\n            return str;\n        }\n        if (endsWithIgnoreCase(str, remove)) {\n            return str.substring(0, str.length() - remove.length());\n        }\n        return str;\n    }\n\n    \n    public static String remove(String str, String remove) {\n        if (isEmpty(str) || isEmpty(remove)) {\n            return str;\n        }\n        return replace(str, remove, EMPTY, -1);\n    }\n\n    \n    public static String remove(String str, char remove) {\n        if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {\n            return str;\n        }\n        char[] chars = str.toCharArray();\n        int pos = 0;\n        for (int i = 0; i < chars.length; i++) {\n            if (chars[i] != remove) {\n                chars[pos++] = chars[i];\n            }\n        }\n        return new String(chars, 0, pos);\n    }\n\n    \n    \n    \n    public static String replaceOnce(String text, String searchString, String replacement) {\n        return replace(text, searchString, replacement, 1);\n    }\n\n    \n    public static String replace(String text, String searchString, String replacement) {\n        return replace(text, searchString, replacement, -1);\n    }\n\n    \n    public static String replace(String text, String searchString, String replacement, int max) {\n        if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {\n            return text;\n        }\n        int start = 0;\n        int end = text.indexOf(searchString, start);\n        if (end == INDEX_NOT_FOUND) {\n            return text;\n        }\n        int replLength = searchString.length();\n        int increase = replacement.length() - replLength;\n        increase = (increase < 0 ? 0 : increase);\n        increase *= (max < 0 ? 16 : (max > 64 ? 64 : max));\n        StringBuilder buf = new StringBuilder(text.length() + increase);\n        while (end != INDEX_NOT_FOUND) {\n            buf.append(text.substring(start, end)).append(replacement);\n            start = end + replLength;\n            if (--max == 0) {\n                break;\n            }\n            end = text.indexOf(searchString, start);\n        }\n        buf.append(text.substring(start));\n        return buf.toString();\n    }\n\n    \n    public static String replaceEach(String text, String[] searchList, String[] replacementList) {\n        return replaceEach(text, searchList, replacementList, false, 0);\n    }\n\n    \n    public static String replaceEachRepeatedly(String text, String[] searchList, String[] replacementList) {\n        \n        \n        int timeToLive = searchList == null ? 0 : searchList.length;\n        return replaceEach(text, searchList, replacementList, true, timeToLive);\n    }\n\n    \n    private static String replaceEach(String text, String[] searchList, String[] replacementList, boolean repeat, int timeToLive) {\n\n        \n        \n\n        if (text == null || text.length() == 0 || searchList == null || \n            searchList.length == 0 || replacementList == null || replacementList.length == 0) \n        {\n            return text;\n        }\n\n        \n        if (timeToLive < 0) {\n            throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n        }\n\n        int searchLength = searchList.length;\n        int replacementLength = replacementList.length;\n\n        \n        if (searchLength != replacementLength) {\n            throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n                + searchLength\n                + \" vs \"\n                + replacementLength);\n        }\n\n        \n        boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n\n        \n        int textIndex = -1;\n        int replaceIndex = -1;\n        int tempIndex = -1;\n\n        \n        \n        for (int i = 0; i < searchLength; i++) {\n            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n                searchList[i].length() == 0 || replacementList[i] == null) \n            {\n                continue;\n            }\n            tempIndex = text.indexOf(searchList[i]);\n\n            \n            if (tempIndex == -1) {\n                noMoreMatchesForReplIndex[i] = true;\n            } else {\n                if (textIndex == -1 || tempIndex < textIndex) {\n                    textIndex = tempIndex;\n                    replaceIndex = i;\n                }\n            }\n        }\n        \n\n        \n        if (textIndex == -1) {\n            return text;\n        }\n\n        int start = 0;\n\n        \n        int increase = 0;\n\n        \n        for (int i = 0; i < searchList.length; i++) {\n            if (searchList[i] == null || replacementList[i] == null) {\n                continue;\n            }\n            int greater = replacementList[i].length() - searchList[i].length();\n            if (greater > 0) {\n                increase += 3 * greater; \n            }\n        }\n        \n        increase = Math.min(increase, text.length() / 5);\n\n        StringBuilder buf = new StringBuilder(text.length() + increase);\n\n        while (textIndex != -1) {\n\n            for (int i = start; i < textIndex; i++) {\n                buf.append(text.charAt(i));\n            }\n            buf.append(replacementList[replaceIndex]);\n\n            start = textIndex + searchList[replaceIndex].length();\n\n            textIndex = -1;\n            replaceIndex = -1;\n            tempIndex = -1;\n            \n            \n            for (int i = 0; i < searchLength; i++) {\n                if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n                    searchList[i].length() == 0 || replacementList[i] == null) \n                {\n                    continue;\n                }\n                tempIndex = text.indexOf(searchList[i], start);\n\n                \n                if (tempIndex == -1) {\n                    noMoreMatchesForReplIndex[i] = true;\n                } else {\n                    if (textIndex == -1 || tempIndex < textIndex) {\n                        textIndex = tempIndex;\n                        replaceIndex = i;\n                    }\n                }\n            }\n            \n\n        }\n        int textLength = text.length();\n        for (int i = start; i < textLength; i++) {\n            buf.append(text.charAt(i));\n        }\n        String result = buf.toString();\n        if (!repeat) {\n            return result;\n        }\n\n        return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n    }\n\n    \n    \n    \n    public static String replaceChars(String str, char searchChar, char replaceChar) {\n        if (str == null) {\n            return null;\n        }\n        return str.replace(searchChar, replaceChar);\n    }\n\n    \n    public static String replaceChars(String str, String searchChars, String replaceChars) {\n        if (isEmpty(str) || isEmpty(searchChars)) {\n            return str;\n        }\n        if (replaceChars == null) {\n            replaceChars = EMPTY;\n        }\n        boolean modified = false;\n        int replaceCharsLength = replaceChars.length();\n        int strLength = str.length();\n        StringBuilder buf = new StringBuilder(strLength);\n        for (int i = 0; i < strLength; i++) {\n            char ch = str.charAt(i);\n            int index = searchChars.indexOf(ch);\n            if (index >= 0) {\n                modified = true;\n                if (index < replaceCharsLength) {\n                    buf.append(replaceChars.charAt(index));\n                }\n            } else {\n                buf.append(ch);\n            }\n        }\n        if (modified) {\n            return buf.toString();\n        }\n        return str;\n    }\n\n    \n    \n    \n    public static String overlay(String str, String overlay, int start, int end) {\n        if (str == null) {\n            return null;\n        }\n        if (overlay == null) {\n            overlay = EMPTY;\n        }\n        int len = str.length();\n        if (start < 0) {\n            start = 0;\n        }\n        if (start > len) {\n            start = len;\n        }\n        if (end < 0) {\n            end = 0;\n        }\n        if (end > len) {\n            end = len;\n        }\n        if (start > end) {\n            int temp = start;\n            start = end;\n            end = temp;\n        }\n        return new StringBuilder(len + start - end + overlay.length() + 1)\n            .append(str.substring(0, start))\n            .append(overlay)\n            .append(str.substring(end))\n            .toString();\n    }\n\n    \n    \n    \n    public static String chomp(String str) {\n        if (isEmpty(str)) {\n            return str;\n        }\n\n        if (str.length() == 1) {\n            char ch = str.charAt(0);\n            if (ch == CharUtils.CR || ch == CharUtils.LF) {\n                return EMPTY;\n            }\n            return str;\n        }\n\n        int lastIdx = str.length() - 1;\n        char last = str.charAt(lastIdx);\n\n        if (last == CharUtils.LF) {\n            if (str.charAt(lastIdx - 1) == CharUtils.CR) {\n                lastIdx--;\n            }\n        } else if (last != CharUtils.CR) {\n            lastIdx++;\n        }\n        return str.substring(0, lastIdx);\n    }\n\n    \n    public static String chomp(String str, String separator) {\n        if (isEmpty(str) || separator == null) {\n            return str;\n        }\n        if (str.endsWith(separator)) {\n            return str.substring(0, str.length() - separator.length());\n        }\n        return str;\n    }\n\n    \n    \n    \n    public static String chop(String str) {\n        if (str == null) {\n            return null;\n        }\n        int strLen = str.length();\n        if (strLen < 2) {\n            return EMPTY;\n        }\n        int lastIdx = strLen - 1;\n        String ret = str.substring(0, lastIdx);\n        char last = str.charAt(lastIdx);\n        if (last == CharUtils.LF) {\n            if (ret.charAt(lastIdx - 1) == CharUtils.CR) {\n                return ret.substring(0, lastIdx - 1);\n            }\n        }\n        return ret;\n    }\n\n    \n    \n\n    \n    \n    \n    public static String repeat(String str, int repeat) {\n        \n\n        if (str == null) {\n            return null;\n        }\n        if (repeat <= 0) {\n            return EMPTY;\n        }\n        int inputLength = str.length();\n        if (repeat == 1 || inputLength == 0) {\n            return str;\n        }\n        if (inputLength == 1 && repeat <= PAD_LIMIT) {\n            return padding(repeat, str.charAt(0));\n        }\n\n        int outputLength = inputLength * repeat;\n        switch (inputLength) {\n            case 1 :\n                char ch = str.charAt(0);\n                char[] output1 = new char[outputLength];\n                for (int i = repeat - 1; i >= 0; i--) {\n                    output1[i] = ch;\n                }\n                return new String(output1);\n            case 2 :\n                char ch0 = str.charAt(0);\n                char ch1 = str.charAt(1);\n                char[] output2 = new char[outputLength];\n                for (int i = repeat * 2 - 2; i >= 0; i--, i--) {\n                    output2[i] = ch0;\n                    output2[i + 1] = ch1;\n                }\n                return new String(output2);\n            default :\n                StringBuilder buf = new StringBuilder(outputLength);\n                for (int i = 0; i < repeat; i++) {\n                    buf.append(str);\n                }\n                return buf.toString();\n        }\n    }\n\n    \n    public static String repeat(String str, String separator, int repeat) {\n        if(str == null || separator == null) {\n            return repeat(str, repeat);\n        } else {\n            \n            String result = repeat(str + separator, repeat);\n            return removeEnd(result, separator);\n        }\n    }\n\n    \n    private static String padding(int repeat, char padChar) throws IndexOutOfBoundsException {\n        if (repeat < 0) {\n            throw new IndexOutOfBoundsException(\"Cannot pad a negative amount: \" + repeat);\n        }\n        final char[] buf = new char[repeat];\n        for (int i = 0; i < buf.length; i++) {\n            buf[i] = padChar;\n        }\n        return new String(buf);\n    }\n\n    \n    public static String rightPad(String str, int size) {\n        return rightPad(str, size, ' ');\n    }\n\n    \n    public static String rightPad(String str, int size, char padChar) {\n        if (str == null) {\n            return null;\n        }\n        int pads = size - str.length();\n        if (pads <= 0) {\n            return str; \n        }\n        if (pads > PAD_LIMIT) {\n            return rightPad(str, size, String.valueOf(padChar));\n        }\n        return str.concat(padding(pads, padChar));\n    }\n\n    \n    public static String rightPad(String str, int size, String padStr) {\n        if (str == null) {\n            return null;\n        }\n        if (isEmpty(padStr)) {\n            padStr = \" \";\n        }\n        int padLen = padStr.length();\n        int strLen = str.length();\n        int pads = size - strLen;\n        if (pads <= 0) {\n            return str; \n        }\n        if (padLen == 1 && pads <= PAD_LIMIT) {\n            return rightPad(str, size, padStr.charAt(0));\n        }\n\n        if (pads == padLen) {\n            return str.concat(padStr);\n        } else if (pads < padLen) {\n            return str.concat(padStr.substring(0, pads));\n        } else {\n            char[] padding = new char[pads];\n            char[] padChars = padStr.toCharArray();\n            for (int i = 0; i < pads; i++) {\n                padding[i] = padChars[i % padLen];\n            }\n            return str.concat(new String(padding));\n        }\n    }\n\n    \n    public static String leftPad(String str, int size) {\n        return leftPad(str, size, ' ');\n    }\n\n    \n    public static String leftPad(String str, int size, char padChar) {\n        if (str == null) {\n            return null;\n        }\n        int pads = size - str.length();\n        if (pads <= 0) {\n            return str; \n        }\n        if (pads > PAD_LIMIT) {\n            return leftPad(str, size, String.valueOf(padChar));\n        }\n        return padding(pads, padChar).concat(str);\n    }\n\n    \n    public static String leftPad(String str, int size, String padStr) {\n        if (str == null) {\n            return null;\n        }\n        if (isEmpty(padStr)) {\n            padStr = \" \";\n        }\n        int padLen = padStr.length();\n        int strLen = str.length();\n        int pads = size - strLen;\n        if (pads <= 0) {\n            return str; \n        }\n        if (padLen == 1 && pads <= PAD_LIMIT) {\n            return leftPad(str, size, padStr.charAt(0));\n        }\n\n        if (pads == padLen) {\n            return padStr.concat(str);\n        } else if (pads < padLen) {\n            return padStr.substring(0, pads).concat(str);\n        } else {\n            char[] padding = new char[pads];\n            char[] padChars = padStr.toCharArray();\n            for (int i = 0; i < pads; i++) {\n                padding[i] = padChars[i % padLen];\n            }\n            return new String(padding).concat(str);\n        }\n    }\n\n\t\n\tpublic static int length(CharSequence cs) {\n\t\treturn CharSequenceUtils.length(cs);\n\t}\n    \n    \n    \n    \n    public static String center(String str, int size) {\n        return center(str, size, ' ');\n    }\n\n    \n    public static String center(String str, int size, char padChar) {\n        if (str == null || size <= 0) {\n            return str;\n        }\n        int strLen = str.length();\n        int pads = size - strLen;\n        if (pads <= 0) {\n            return str;\n        }\n        str = leftPad(str, strLen + pads / 2, padChar);\n        str = rightPad(str, size, padChar);\n        return str;\n    }\n\n    \n    public static String center(String str, int size, String padStr) {\n        if (str == null || size <= 0) {\n            return str;\n        }\n        if (isEmpty(padStr)) {\n            padStr = \" \";\n        }\n        int strLen = str.length();\n        int pads = size - strLen;\n        if (pads <= 0) {\n            return str;\n        }\n        str = leftPad(str, strLen + pads / 2, padStr);\n        str = rightPad(str, size, padStr);\n        return str;\n    }\n\n    \n    \n    \n    public static String upperCase(String str) {\n        if (str == null) {\n            return null;\n        }\n        return str.toUpperCase();\n    }\n\n    \n    public static String upperCase(String str, Locale locale) {\n        if (str == null) {\n            return null;\n        }\n        return str.toUpperCase(locale);\n    }\n\n    \n    public static String lowerCase(String str) {\n        if (str == null) {\n            return null;\n        }\n        return str.toLowerCase();\n    }\n\n    \n    public static String lowerCase(String str, Locale locale) {\n        if (str == null) {\n            return null;\n        }\n        return str.toLowerCase(locale);\n    }\n\n    \n    public static String capitalize(CharSequence cs) {\n        if (cs == null ) {\n            return null;\n        }\n        int strLen;\n        if ((strLen = cs.length()) == 0) {\n            return cs.toString();\n        }\n        return new StringBuilder(strLen)\n            .append(Character.toTitleCase(cs.charAt(0)))\n            .append(CharSequenceUtils.subSequence(cs, 1))\n            .toString();\n    }\n\n    \n    public static String uncapitalize(CharSequence cs) {\n        if (cs == null ) {\n            return null;\n        }\n        int strLen;\n        if ((strLen = cs.length()) == 0) {\n            return cs.toString();\n        }\n        return new StringBuilder(strLen)\n            .append(Character.toLowerCase(cs.charAt(0)))\n            .append(CharSequenceUtils.subSequence(cs, 1))\n            .toString();\n    }\n\n    \n    public static String swapCase(String str) {\n        int strLen;\n        if (str == null || (strLen = str.length()) == 0) {\n            return str;\n        }\n        StringBuilder buffer = new StringBuilder(strLen);\n\n        char ch = 0;\n        for (int i = 0; i < strLen; i++) {\n            ch = str.charAt(i);\n            if (Character.isUpperCase(ch)) {\n                ch = Character.toLowerCase(ch);\n            } else if (Character.isTitleCase(ch)) {\n                ch = Character.toLowerCase(ch);\n            } else if (Character.isLowerCase(ch)) {\n                ch = Character.toUpperCase(ch);\n            }\n            buffer.append(ch);\n        }\n        return buffer.toString();\n    }\n\n    \n    \n    \n    public static int countMatches(String str, String sub) {\n        if (isEmpty(str) || isEmpty(sub)) {\n            return 0;\n        }\n        int count = 0;\n        int idx = 0;\n        while ((idx = str.indexOf(sub, idx)) != INDEX_NOT_FOUND) {\n            count++;\n            idx += sub.length();\n        }\n        return count;\n    }\n\n    \n    \n    \n    public static boolean isAlpha(CharSequence cs) {\n        if (cs == null) {\n            return false;\n        }\n        int sz = cs.length();\n        for (int i = 0; i < sz; i++) {\n            if (Character.isLetter(cs.charAt(i)) == false) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public static boolean isAlphaSpace(CharSequence cs) {\n        if (cs == null) {\n            return false;\n        }\n        int sz = cs.length();\n        for (int i = 0; i < sz; i++) {\n            if ((Character.isLetter(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public static boolean isAlphanumeric(CharSequence cs) {\n        if (cs == null) {\n            return false;\n        }\n        int sz = cs.length();\n        for (int i = 0; i < sz; i++) {\n            if (Character.isLetterOrDigit(cs.charAt(i)) == false) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public static boolean isAlphanumericSpace(CharSequence cs) {\n        if (cs == null) {\n            return false;\n        }\n        int sz = cs.length();\n        for (int i = 0; i < sz; i++) {\n            if ((Character.isLetterOrDigit(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public static boolean isAsciiPrintable(CharSequence cs) {\n        if (cs == null) {\n            return false;\n        }\n        int sz = cs.length();\n        for (int i = 0; i < sz; i++) {\n            if (CharUtils.isAsciiPrintable(cs.charAt(i)) == false) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public static boolean isNumeric(CharSequence cs) {\n        if (cs == null) {\n            return false;\n        }\n        int sz = cs.length();\n        for (int i = 0; i < sz; i++) {\n            if (Character.isDigit(cs.charAt(i)) == false) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public static boolean isNumericSpace(CharSequence cs) {\n        if (cs == null) {\n            return false;\n        }\n        int sz = cs.length();\n        for (int i = 0; i < sz; i++) {\n            if ((Character.isDigit(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public static boolean isWhitespace(CharSequence cs) {\n        if (cs == null) {\n            return false;\n        }\n        int sz = cs.length();\n        for (int i = 0; i < sz; i++) {\n            if ((Character.isWhitespace(cs.charAt(i)) == false)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public static boolean isAllLowerCase(CharSequence cs) {\n        if (cs == null || isEmpty(cs)) {\n            return false;\n        }\n        int sz = cs.length();\n        for (int i = 0; i < sz; i++) {\n            if (Character.isLowerCase(cs.charAt(i)) == false) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public static boolean isAllUpperCase(CharSequence cs) {\n        if (cs == null || isEmpty(cs)) {\n            return false;\n        }\n        int sz = cs.length();\n        for (int i = 0; i < sz; i++) {\n            if (Character.isUpperCase(cs.charAt(i)) == false) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    \n    \n    public static String defaultString(String str) {\n        return str == null ? EMPTY : str;\n    }\n\n    \n    public static String defaultString(String str, String defaultStr) {\n        return str == null ? defaultStr : str;\n    }\n\n    \n    public static <T extends CharSequence> T defaultIfEmpty(T str, T defaultStr) {\n        return StringUtils.isEmpty(str) ? defaultStr : str;\n    }\n\n    \n    \n    \n    public static String reverse(String str) {\n        if (str == null) {\n            return null;\n        }\n\t\treturn new StringBuilder(str).reverse().toString();\n    }\n\n    \n    public static String reverseDelimited(String str, char separatorChar) {\n        if (str == null) {\n            return null;\n        }\n        \n        \n        String[] strs = split(str, separatorChar);\n        ArrayUtils.reverse(strs);\n        return join(strs, separatorChar);\n    }\n\n    \n    \n    \n    public static String abbreviate(String str, int maxWidth) {\n        return abbreviate(str, 0, maxWidth);\n    }\n\n    \n    public static String abbreviate(String str, int offset, int maxWidth) {\n        if (str == null) {\n            return null;\n        }\n        if (maxWidth < 4) {\n            throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n        }\n        if (str.length() <= maxWidth) {\n            return str;\n        }\n        if (offset > str.length()) {\n            offset = str.length();\n        }\n        if ((str.length() - offset) < (maxWidth - 3)) {\n            offset = str.length() - (maxWidth - 3);\n        }\n        final String abrevMarker = \"...\";\n\t\tif (offset <= 4) {\n            return str.substring(0, maxWidth - 3) + abrevMarker;\n        }\n        if (maxWidth < 7) {\n            throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n        }\n        if ((offset + (maxWidth - 3)) < str.length()) {\n            return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n        }\n        return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n    }\n    \n    \n    public static String abbreviateMiddle(String str, String middle, int length) {\n        if (isEmpty(str) || isEmpty(middle)) {\n            return str;\n        }\n      \n        if (length >= str.length() || length < (middle.length()+2)) {\n            return str;\n        }\n\n        int targetSting = length-middle.length();\n        int startOffset = targetSting/2+targetSting%2;\n        int endOffset = str.length()-targetSting/2;\n        \n        StringBuilder builder = new StringBuilder(length);\n        builder.append(str.substring(0,startOffset));\n        builder.append(middle);\n        builder.append(str.substring(endOffset));\n        \n        return builder.toString();\n    }\n\n    \n    \n    \n    public static String difference(String str1, String str2) {\n        if (str1 == null) {\n            return str2;\n        }\n        if (str2 == null) {\n            return str1;\n        }\n        int at = indexOfDifference(str1, str2);\n        if (at == INDEX_NOT_FOUND) {\n            return EMPTY;\n        }\n        return str2.substring(at);\n    }\n\n    \n    public static int indexOfDifference(CharSequence cs1, CharSequence cs2) {\n        if (cs1 == cs2) {\n            return INDEX_NOT_FOUND;\n        }\n        if (cs1 == null || cs2 == null) {\n            return 0;\n        }\n        int i;\n        for (i = 0; i < cs1.length() && i < cs2.length(); ++i) {\n            if (cs1.charAt(i) != cs2.charAt(i)) {\n                break;\n            }\n        }\n        if (i < cs2.length() || i < cs1.length()) {\n            return i;\n        }\n        return INDEX_NOT_FOUND;\n    }\n\n    \n    public static int indexOfDifference(CharSequence[] css) {\n        if (css == null || css.length <= 1) {\n            return INDEX_NOT_FOUND;\n        }\n        boolean anyStringNull = false;\n        boolean allStringsNull = true;\n        int arrayLen = css.length;\n        int shortestStrLen = Integer.MAX_VALUE;\n        int longestStrLen = 0;\n\n        \n        \n        \n        for (int i = 0; i < arrayLen; i++) {\n            if (css[i] == null) {\n                anyStringNull = true;\n                shortestStrLen = 0;\n            } else {\n                allStringsNull = false;\n                shortestStrLen = Math.min(css[i].length(), shortestStrLen);\n                longestStrLen = Math.max(css[i].length(), longestStrLen);\n            }\n        }\n\n        \n        if (allStringsNull || (longestStrLen == 0 && !anyStringNull)) {\n            return INDEX_NOT_FOUND;\n        }\n\n        \n        if (shortestStrLen == 0) {\n            return 0;\n        }\n\n        \n        int firstDiff = -1;\n        for (int stringPos = 0; stringPos < shortestStrLen; stringPos++) {\n            char comparisonChar = css[0].charAt(stringPos);\n            for (int arrayPos = 1; arrayPos < arrayLen; arrayPos++) {\n                if (css[arrayPos].charAt(stringPos) != comparisonChar) {\n                    firstDiff = stringPos;\n                    break;\n                }\n            }\n            if (firstDiff != -1) {\n                break;\n            }\n        }\n\n        if (firstDiff == -1 && shortestStrLen != longestStrLen) {\n            \n            \n            \n            return shortestStrLen;\n        }\n        return firstDiff;\n    }\n    \n    \n    public static String getCommonPrefix(String[] strs) {\n        if (strs == null || strs.length == 0) {\n            return EMPTY;\n        }\n        int smallestIndexOfDiff = indexOfDifference(strs);\n        if (smallestIndexOfDiff == INDEX_NOT_FOUND) {\n            \n            if (strs[0] == null) {\n                return EMPTY;\n            }\n            return strs[0];\n        } else if (smallestIndexOfDiff == 0) {\n            \n            return EMPTY;\n        } else {\n            \n            return strs[0].substring(0, smallestIndexOfDiff);\n        }\n    }  \n    \n    \n    \n    \n    public static int getLevenshteinDistance(CharSequence s, CharSequence t) {\n        if (s == null || t == null) {\n            throw new IllegalArgumentException(\"Strings must not be null\");\n        }\n\n        \n\n        int n = s.length(); \n        int m = t.length(); \n\n        if (n == 0) {\n            return m;\n        } else if (m == 0) {\n            return n;\n        }\n\n        if (n > m) {\n            \n        \tCharSequence tmp = s;\n            s = t;\n            t = tmp;\n            n = m;\n            m = t.length();\n        }\n\n        int p[] = new int[n+1]; \n        int d[] = new int[n+1]; \n        int _d[]; \n\n        \n        int i; \n        int j; \n\n        char t_j; \n\n        int cost; \n\n        for (i = 0; i<=n; i++) {\n            p[i] = i;\n        }\n\n        for (j = 1; j<=m; j++) {\n            t_j = t.charAt(j-1);\n            d[0] = j;\n\n            for (i=1; i<=n; i++) {\n                cost = s.charAt(i-1)==t_j ? 0 : 1;\n                \n                d[i] = Math.min(Math.min(d[i-1]+1, p[i]+1),  p[i-1]+cost);\n            }\n\n            \n            _d = p;\n            p = d;\n            d = _d;\n        }\n\n        \n        \n        return p[n];\n    }\n\n    \n\n\n    \n    \n\n    \n    public static boolean startsWith(String str, String prefix) {\n        return startsWith(str, prefix, false);\n    }\n\n    \n    public static boolean startsWithIgnoreCase(String str, String prefix) {\n        return startsWith(str, prefix, true);\n    }\n\n    \n    private static boolean startsWith(String str, String prefix, boolean ignoreCase) {\n        if (str == null || prefix == null) {\n            return (str == null && prefix == null);\n        }\n        if (prefix.length() > str.length()) {\n            return false;\n        }\n        return str.regionMatches(ignoreCase, 0, prefix, 0, prefix.length());\n    }\n    \n    \n    public static boolean startsWithAny(String string, String[] searchStrings) {\n        if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) {\n            return false;\n        }\n        for (int i = 0; i < searchStrings.length; i++) {\n            String searchString = searchStrings[i];\n            if (StringUtils.startsWith(string, searchString)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    \n    \n\n    \n    public static boolean endsWith(String str, String suffix) {\n        return endsWith(str, suffix, false);\n    }\n\n    \n    public static boolean endsWithIgnoreCase(String str, String suffix) {\n        return endsWith(str, suffix, true);\n    }\n\n    \n    private static boolean endsWith(String str, String suffix, boolean ignoreCase) {\n        if (str == null || suffix == null) {\n            return str == null && suffix == null;\n        }\n        if (suffix.length() > str.length()) {\n            return false;\n        }\n        int strOffset = str.length() - suffix.length();\n        return str.regionMatches(ignoreCase, strOffset, suffix, 0, suffix.length());\n    }\n}\n",
      "fixed_full_code": "\npackage org.apache.commons.lang3;\n\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Locale;\n\nimport org.apache.commons.lang3.text.WordUtils;\n\n\n\npublic class StringUtils { public static final String EMPTY = \"\"; public static final int INDEX_NOT_FOUND = -1; private static final int PAD_LIMIT = 8192; public StringUtils() {\n        super();\n    }\n\n    \n    \n    \n    public static boolean isEmpty(CharSequence cs) {\n        return cs == null || cs.length() == 0;\n    }\n\n    \n    public static boolean isNotEmpty(CharSequence cs) {\n        return !StringUtils.isEmpty(cs);\n    }\n\n    \n    public static boolean isBlank(CharSequence cs) {\n        int strLen;\n        if (cs == null || (strLen = cs.length()) == 0) {\n            return true;\n        }\n        for (int i = 0; i < strLen; i++) {\n            if ((Character.isWhitespace(cs.charAt(i)) == false)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public static boolean isNotBlank(CharSequence cs) {\n        return !StringUtils.isBlank(cs);\n    }\n\n    \n    \n    \n    public static String trim(String str) {\n        return str == null ? null : str.trim();\n    }\n\n    \n    public static String trimToNull(String str) {\n        String ts = trim(str);\n        return isEmpty(ts) ? null : ts;\n    }\n\n    \n    public static String trimToEmpty(String str) {\n        return str == null ? EMPTY : str.trim();\n    }\n\n    \n    \n    \n    public static String strip(String str) {\n        return strip(str, null);\n    }\n\n    \n    public static String stripToNull(String str) {\n        if (str == null) {\n            return null;\n        }\n        str = strip(str, null);\n        return str.length() == 0 ? null : str;\n    }\n\n    \n    public static String stripToEmpty(String str) {\n        return str == null ? EMPTY : strip(str, null);\n    }\n\n    \n    public static String strip(String str, String stripChars) {\n        if (isEmpty(str)) {\n            return str;\n        }\n        str = stripStart(str, stripChars);\n        return stripEnd(str, stripChars);\n    }\n\n    \n    public static String stripStart(String str, String stripChars) {\n        int strLen;\n        if (str == null || (strLen = str.length()) == 0) {\n            return str;\n        }\n        int start = 0;\n        if (stripChars == null) {\n            while ((start != strLen) && Character.isWhitespace(str.charAt(start))) {\n                start++;\n            }\n        } else if (stripChars.length() == 0) {\n            return str;\n        } else {\n            while ((start != strLen) && (stripChars.indexOf(str.charAt(start)) != INDEX_NOT_FOUND)) {\n                start++;\n            }\n        }\n        return str.substring(start);\n    }\n\n    \n    public static String stripEnd(String str, String stripChars) {\n        int end;\n        if (str == null || (end = str.length()) == 0) {\n            return str;\n        }\n\n        if (stripChars == null) {\n            while ((end != 0) && Character.isWhitespace(str.charAt(end - 1))) {\n                end--;\n            }\n        } else if (stripChars.length() == 0) {\n            return str;\n        } else {\n            while ((end != 0) && (stripChars.indexOf(str.charAt(end - 1)) != INDEX_NOT_FOUND)) {\n                end--;\n            }\n        }\n        return str.substring(0, end);\n    }\n\n    \n    \n    \n    public static String[] stripAll(String[] strs) {\n        return stripAll(strs, null);\n    }\n\n    \n    public static String[] stripAll(String[] strs, String stripChars) {\n        int strsLen;\n        if (strs == null || (strsLen = strs.length) == 0) {\n            return strs;\n        }\n        String[] newArr = new String[strsLen];\n        for (int i = 0; i < strsLen; i++) {\n            newArr[i] = strip(strs[i], stripChars);\n        }\n        return newArr;\n    }\n\n    \n    public static String stripAccents(String input) {\n        if(input == null) {\n            return null;\n        }\n        if(SystemUtils.isJavaVersionAtLeast(1.6f)) {\n\n            \n\n            \n            try {\n                \n                Class<?> normalizerFormClass = ClassUtils.getClass(\"java.text.Normalizer$Form\", false);\n\n                \n                Class<?> normalizerClass = ClassUtils.getClass(\"java.text.Normalizer\", false);\n\n                \n                java.lang.reflect.Method method = normalizerClass.getMethod(\"normalize\", CharSequence.class, normalizerFormClass );\n\n                \n                java.lang.reflect.Field nfd = normalizerFormClass.getField(\"NFD\");\n\n                \n                String decomposed = (String) method.invoke( null, input, nfd.get(null) );\n                \n\n                java.util.regex.Pattern accentPattern = java.util.regex.Pattern.compile(\"\\\\p{InCombiningDiacriticalMarks}+\");\n                return accentPattern.matcher(decomposed).replaceAll(\"\");\n            } catch(ClassNotFoundException cnfe) {\n                throw new RuntimeException(\"ClassNotFoundException occurred during 1.6 backcompat code\", cnfe);\n            } catch(NoSuchMethodException nsme) {\n                throw new RuntimeException(\"NoSuchMethodException occurred during 1.6 backcompat code\", nsme);\n            } catch(NoSuchFieldException nsfe) {\n                throw new RuntimeException(\"NoSuchFieldException occurred during 1.6 backcompat code\", nsfe);\n            } catch(IllegalAccessException iae) {\n                throw new RuntimeException(\"IllegalAccessException occurred during 1.6 backcompat code\", iae);\n            } catch(IllegalArgumentException iae) {\n                throw new RuntimeException(\"IllegalArgumentException occurred during 1.6 backcompat code\", iae);\n            } catch(java.lang.reflect.InvocationTargetException ite) {\n                throw new RuntimeException(\"InvocationTargetException occurred during 1.6 backcompat code\", ite);\n            } catch(SecurityException se) {\n                throw new RuntimeException(\"SecurityException occurred during 1.6 backcompat code\", se);\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The stripAccents(String) method is not supported until Java 1.6\");\n        }\n    }\n\n    \n    \n    \n    public static boolean equals(CharSequence cs1, CharSequence cs2) {\n        return cs1 == null ? cs2 == null : cs1.equals(cs2);\n    }\n\n    \n    public static boolean equalsIgnoreCase(String str1, String str2) {\n        return str1 == null ? str2 == null : str1.equalsIgnoreCase(str2);\n    }\n\n    \n    \n    \n    public static int indexOf(String str, char searchChar) {\n        if (isEmpty(str)) {\n            return INDEX_NOT_FOUND;\n        }\n        return str.indexOf(searchChar);\n    }\n\n    \n    public static int indexOf(String str, char searchChar, int startPos) {\n        if (isEmpty(str)) {\n            return INDEX_NOT_FOUND;\n        }\n        return str.indexOf(searchChar, startPos);\n    }\n\n    \n    public static int indexOf(String str, String searchStr) {\n        if (str == null || searchStr == null) {\n            return INDEX_NOT_FOUND;\n        }\n        return str.indexOf(searchStr);\n    }\n\n    \n    public static int indexOf(String str, String searchStr, int startPos) {\n        if (str == null || searchStr == null) {\n            return INDEX_NOT_FOUND;\n        }\n        return str.indexOf(searchStr, startPos);\n    }\n\n    \n    public static int ordinalIndexOf(String str, String searchStr, int ordinal) {\n        return ordinalIndexOf(str, searchStr, ordinal, false);\n    }\n\n    \n    \n    private static int ordinalIndexOf(String str, String searchStr, int ordinal, boolean lastIndex) {\n        if (str == null || searchStr == null || ordinal <= 0) {\n            return INDEX_NOT_FOUND;\n        }\n        if (searchStr.length() == 0) {\n            return lastIndex ? str.length() : 0;\n        }\n        int found = 0;\n        int index = lastIndex ? str.length() : INDEX_NOT_FOUND;\n        do {\n            if(lastIndex) {\n                index = str.lastIndexOf(searchStr, index - 1);\n            } else {\n                index = str.indexOf(searchStr, index + 1);\n            }\n            if (index < 0) {\n                return index;\n            }\n            found++;\n        } while (found < ordinal);\n        return index;\n    }\n\n    \n    public static int indexOfIgnoreCase(String str, String searchStr) {\n        return indexOfIgnoreCase(str, searchStr, 0);\n    }\n\n    \n    public static int indexOfIgnoreCase(String str, String searchStr, int startPos) {\n        if (str == null || searchStr == null) {\n            return INDEX_NOT_FOUND;\n        }\n        if (startPos < 0) {\n            startPos = 0;\n        }\n        int endLimit = (str.length() - searchStr.length()) + 1;\n        if (startPos > endLimit) {\n            return INDEX_NOT_FOUND;\n        }\n        if (searchStr.length() == 0) {\n            return startPos;\n        }\n        for (int i = startPos; i < endLimit; i++) {\n            if (str.regionMatches(true, i, searchStr, 0, searchStr.length())) {\n                return i;\n            }\n        }\n        return INDEX_NOT_FOUND;\n    }\n\n    \n    \n    \n    public static int lastIndexOf(String str, char searchChar) {\n        if (isEmpty(str)) {\n            return INDEX_NOT_FOUND;\n        }\n        return str.lastIndexOf(searchChar);\n    }\n\n    \n    public static int lastIndexOf(String str, char searchChar, int startPos) {\n        if (isEmpty(str)) {\n            return INDEX_NOT_FOUND;\n        }\n        return str.lastIndexOf(searchChar, startPos);\n    }\n\n    \n    public static int lastIndexOf(String str, String searchStr) {\n        if (str == null || searchStr == null) {\n            return INDEX_NOT_FOUND;\n        }\n        return str.lastIndexOf(searchStr);\n    }\n\n    \n    public static int lastOrdinalIndexOf(String str, String searchStr, int ordinal) {\n        return ordinalIndexOf(str, searchStr, ordinal, true);\n    }\n\n    \n    public static int lastIndexOf(String str, String searchStr, int startPos) {\n        if (str == null || searchStr == null) {\n            return INDEX_NOT_FOUND;\n        }\n        return str.lastIndexOf(searchStr, startPos);\n    }\n\n    \n    public static int lastIndexOfIgnoreCase(String str, String searchStr) {\n        if (str == null || searchStr == null) {\n            return INDEX_NOT_FOUND;\n        }\n        return lastIndexOfIgnoreCase(str, searchStr, str.length());\n    }\n\n    \n    public static int lastIndexOfIgnoreCase(String str, String searchStr, int startPos) {\n        if (str == null || searchStr == null) {\n            return INDEX_NOT_FOUND;\n        }\n        if (startPos > (str.length() - searchStr.length())) {\n            startPos = str.length() - searchStr.length();\n        }\n        if (startPos < 0) {\n            return INDEX_NOT_FOUND;\n        }\n        if (searchStr.length() == 0) {\n            return startPos;\n        }\n\n        for (int i = startPos; i >= 0; i--) {\n            if (str.regionMatches(true, i, searchStr, 0, searchStr.length())) {\n                return i;\n            }\n        }\n        return INDEX_NOT_FOUND;\n    }\n\n    \n    \n    \n    public static boolean contains(String str, char searchChar) {\n        if (isEmpty(str)) {\n            return false;\n        }\n        return str.indexOf(searchChar) >= 0;\n    }\n\n    \n    public static boolean contains(String str, String searchStr) {\n        if (str == null || searchStr == null) {\n            return false;\n        }\n        return str.indexOf(searchStr) >= 0;\n    }\n\n    \n    public static boolean containsIgnoreCase(String str, String searchStr) {\n        if (str == null || searchStr == null) {\n            return false;\n        }\n        int len = searchStr.length();\n        int max = str.length() - len;\n        for (int i = 0; i <= max; i++) {\n            if (str.regionMatches(true, i, searchStr, 0, len)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    \n    \n    \n    public static int indexOfAny(CharSequence cs, char[] searchChars) {\n        if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n            return INDEX_NOT_FOUND;\n        }\n        int csLen = cs.length();\n        int csLast = csLen - 1;\n        int searchLen = searchChars.length;\n        int searchLast = searchLen - 1;\n        for (int i = 0; i < csLen; i++) {\n            char ch = cs.charAt(i);\n            for (int j = 0; j < searchLen; j++) {\n                if (searchChars[j] == ch) {\n                    if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) {\n                        \n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return i;\n                        }\n                    } else {\n                        return i;\n                    }\n                }\n            }\n        }\n        return INDEX_NOT_FOUND;\n    }\n\n    \n    public static int indexOfAny(CharSequence cs, String searchChars) {\n        if (isEmpty(cs) || isEmpty(searchChars)) {\n            return INDEX_NOT_FOUND;\n        }\n        return indexOfAny(cs, searchChars.toCharArray());\n    }\n\n    \n    \n    \n    public static boolean containsAny(String cs, char[] searchChars) {\n        if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n            return false;\n        }\n        int csLength = cs.length();\n        int searchLength = searchChars.length;\n        int csLast = csLength - 1;\n        int searchLast = searchLength - 1;\n        for (int i = 0; i < csLength; i++) {\n            char ch = cs.charAt(i);\n            for (int j = 0; j < searchLength; j++) {\n                if (searchChars[j] == ch) {\n                    if (Character.isHighSurrogate(ch)) {\n                        if (j == searchLast) {\n                            \n                            return true;\n                        }\n                        if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\n    \n    public static boolean containsAny(String cs, String searchChars) {\n        if (searchChars == null) {\n            return false;\n        }\n        return containsAny(cs, searchChars.toCharArray());\n    }\n\n    \n    \n    \n    public static int indexOfAnyBut(CharSequence cs, char[] searchChars) {\n        if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n            return INDEX_NOT_FOUND;\n        }\n        int csLen = cs.length();\n        int csLast = csLen - 1;\n        int searchLen = searchChars.length;\n        int searchLast = searchLen - 1;\n        outer:\n        for (int i = 0; i < csLen; i++) {\n            char ch = cs.charAt(i);\n            for (int j = 0; j < searchLen; j++) {\n                if (searchChars[j] == ch) {\n                    if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) {\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            continue outer;\n                        }\n                    } else {\n                        continue outer;\n                    }\n                }\n            }\n            return i;\n        }\n        return INDEX_NOT_FOUND;\n    }\n\n    \n    public static int indexOfAnyBut(String str, String searchChars) {\n        if (isEmpty(str) || isEmpty(searchChars)) {\n            return INDEX_NOT_FOUND;\n        }\n        int strLen = str.length();\n        for (int i = 0; i < strLen; i++) {\n            char ch = str.charAt(i);\n            boolean chFound = searchChars.indexOf(ch) >= 0;\n            if (i + 1 < strLen && Character.isHighSurrogate(ch)) {\n                char ch2 = str.charAt(i + 1);\n                if (chFound && searchChars.indexOf(ch2) < 0) {\n                    return i;\n                }\n            } else {\n                if (!chFound) {\n                    return i;\n                }\n            }\n        }\n        return INDEX_NOT_FOUND;\n    }\n\n    \n    \n    \n    public static boolean containsOnly(CharSequence cs, char[] valid) {\n        \n        if (valid == null || cs == null) {\n            return false;\n        }\n        if (cs.length() == 0) {\n            return true;\n        }\n        if (valid.length == 0) {\n            return false;\n        }\n        return indexOfAnyBut(cs, valid) == INDEX_NOT_FOUND;\n    }\n\n    \n    public static boolean containsOnly(CharSequence cs, String validChars) {\n        if (cs == null || validChars == null) {\n            return false;\n        }\n        return containsOnly(cs, validChars.toCharArray());\n    }\n\n    \n    \n    \n    public static boolean containsNone(CharSequence cs, char[] searchChars) {\n        if (cs == null || searchChars == null) {\n            return true;\n        }\n        int csLen = cs.length();\n        int csLast = csLen - 1;\n        int searchLen = searchChars.length;\n        int searchLast = searchLen - 1;\n        for (int i = 0; i < csLen; i++) {\n            char ch = cs.charAt(i);\n            for (int j = 0; j < searchLen; j++) {\n                if (searchChars[j] == ch) {\n                    if (Character.isHighSurrogate(ch)) {\n                        if (j == searchLast) {\n                            \n                            return false;\n                        }\n                        if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return false;\n                        }\n                    } else {\n                        \n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n\n    \n    public static boolean containsNone(CharSequence cs, String invalidChars) {\n        if (cs == null || invalidChars == null) {\n            return true;\n        }\n        return containsNone(cs, invalidChars.toCharArray());\n    }\n\n    \n    \n    \n    public static int indexOfAny(String str, String[] searchStrs) {\n        if (str == null || searchStrs == null) {\n            return INDEX_NOT_FOUND;\n        }\n        int sz = searchStrs.length;\n\n        \n        int ret = Integer.MAX_VALUE;\n\n        int tmp = 0;\n        for (int i = 0; i < sz; i++) {\n            String search = searchStrs[i];\n            if (search == null) {\n                continue;\n            }\n            tmp = str.indexOf(search);\n            if (tmp == INDEX_NOT_FOUND) {\n                continue;\n            }\n\n            if (tmp < ret) {\n                ret = tmp;\n            }\n        }\n\n        return (ret == Integer.MAX_VALUE) ? INDEX_NOT_FOUND : ret;\n    }\n\n    \n    public static int lastIndexOfAny(String str, String[] searchStrs) {\n        if (str == null || searchStrs == null) {\n            return INDEX_NOT_FOUND;\n        }\n        int sz = searchStrs.length;\n        int ret = INDEX_NOT_FOUND;\n        int tmp = 0;\n        for (int i = 0; i < sz; i++) {\n            String search = searchStrs[i];\n            if (search == null) {\n                continue;\n            }\n            tmp = str.lastIndexOf(search);\n            if (tmp > ret) {\n                ret = tmp;\n            }\n        }\n        return ret;\n    }\n\n    \n    \n    \n    public static String substring(String str, int start) {\n        if (str == null) {\n            return null;\n        }\n\n        \n        if (start < 0) {\n            start = str.length() + start; \n        }\n\n        if (start < 0) {\n            start = 0;\n        }\n        if (start > str.length()) {\n            return EMPTY;\n        }\n\n        return str.substring(start);\n    }\n\n    \n    public static String substring(String str, int start, int end) {\n        if (str == null) {\n            return null;\n        }\n\n        \n        if (end < 0) {\n            end = str.length() + end; \n        }\n        if (start < 0) {\n            start = str.length() + start; \n        }\n\n        \n        if (end > str.length()) {\n            end = str.length();\n        }\n\n        \n        if (start > end) {\n            return EMPTY;\n        }\n\n        if (start < 0) {\n            start = 0;\n        }\n        if (end < 0) {\n            end = 0;\n        }\n\n        return str.substring(start, end);\n    }\n\n    \n    \n    \n    public static String left(String str, int len) {\n        if (str == null) {\n            return null;\n        }\n        if (len < 0) {\n            return EMPTY;\n        }\n        if (str.length() <= len) {\n            return str;\n        }\n        return str.substring(0, len);\n    }\n\n    \n    public static String right(String str, int len) {\n        if (str == null) {\n            return null;\n        }\n        if (len < 0) {\n            return EMPTY;\n        }\n        if (str.length() <= len) {\n            return str;\n        }\n        return str.substring(str.length() - len);\n    }\n\n    \n    public static String mid(String str, int pos, int len) {\n        if (str == null) {\n            return null;\n        }\n        if (len < 0 || pos > str.length()) {\n            return EMPTY;\n        }\n        if (pos < 0) {\n            pos = 0;\n        }\n        if (str.length() <= (pos + len)) {\n            return str.substring(pos);\n        }\n        return str.substring(pos, pos + len);\n    }\n\n    \n    \n    \n    public static String substringBefore(String str, String separator) {\n        if (isEmpty(str) || separator == null) {\n            return str;\n        }\n        if (separator.length() == 0) {\n            return EMPTY;\n        }\n        int pos = str.indexOf(separator);\n        if (pos == INDEX_NOT_FOUND) {\n            return str;\n        }\n        return str.substring(0, pos);\n    }\n\n    \n    public static String substringAfter(String str, String separator) {\n        if (isEmpty(str)) {\n            return str;\n        }\n        if (separator == null) {\n            return EMPTY;\n        }\n        int pos = str.indexOf(separator);\n        if (pos == INDEX_NOT_FOUND) {\n            return EMPTY;\n        }\n        return str.substring(pos + separator.length());\n    }\n\n    \n    public static String substringBeforeLast(String str, String separator) {\n        if (isEmpty(str) || isEmpty(separator)) {\n            return str;\n        }\n        int pos = str.lastIndexOf(separator);\n        if (pos == INDEX_NOT_FOUND) {\n            return str;\n        }\n        return str.substring(0, pos);\n    }\n\n    \n    public static String substringAfterLast(String str, String separator) {\n        if (isEmpty(str)) {\n            return str;\n        }\n        if (isEmpty(separator)) {\n            return EMPTY;\n        }\n        int pos = str.lastIndexOf(separator);\n        if (pos == INDEX_NOT_FOUND || pos == (str.length() - separator.length())) {\n            return EMPTY;\n        }\n        return str.substring(pos + separator.length());\n    }\n\n    \n    \n    \n    public static String substringBetween(String str, String tag) {\n        return substringBetween(str, tag, tag);\n    }\n\n    \n    public static String substringBetween(String str, String open, String close) {\n        if (str == null || open == null || close == null) {\n            return null;\n        }\n        int start = str.indexOf(open);\n        if (start != INDEX_NOT_FOUND) {\n            int end = str.indexOf(close, start + open.length());\n            if (end != INDEX_NOT_FOUND) {\n                return str.substring(start + open.length(), end);\n            }\n        }\n        return null;\n    }\n\n    \n    public static String[] substringsBetween(String str, String open, String close) {\n        if (str == null || isEmpty(open) || isEmpty(close)) {\n            return null;\n        }\n        int strLen = str.length();\n        if (strLen == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n        int closeLen = close.length();\n        int openLen = open.length();\n        List<String> list = new ArrayList<String>();\n        int pos = 0;\n        while (pos < (strLen - closeLen)) {\n            int start = str.indexOf(open, pos);\n            if (start < 0) {\n                break;\n            }\n            start += openLen;\n            int end = str.indexOf(close, start);\n            if (end < 0) {\n                break;\n            }\n            list.add(str.substring(start, end));\n            pos = end + closeLen;\n        }\n        if (list.isEmpty()) {\n            return null;\n        } \n        return list.toArray(new String [list.size()]);\n    }\n\n    \n    \n\n    \n    \n    \n    public static String[] split(String str) {\n        return split(str, null, -1);\n    }\n\n    \n    public static String[] split(String str, char separatorChar) {\n        return splitWorker(str, separatorChar, false);\n    }\n\n    \n    public static String[] split(String str, String separatorChars) {\n        return splitWorker(str, separatorChars, -1, false);\n    }\n\n    \n    public static String[] split(String str, String separatorChars, int max) {\n        return splitWorker(str, separatorChars, max, false);\n    }\n\n    \n    public static String[] splitByWholeSeparator(String str, String separator) {\n        return splitByWholeSeparatorWorker( str, separator, -1, false ) ;\n    }\n\n    \n    public static String[] splitByWholeSeparator( String str, String separator, int max ) {\n        return splitByWholeSeparatorWorker(str, separator, max, false);\n    }\n\n    \n    public static String[] splitByWholeSeparatorPreserveAllTokens(String str, String separator) {\n        return splitByWholeSeparatorWorker(str, separator, -1, true);\n    }\n\n    \n    public static String[] splitByWholeSeparatorPreserveAllTokens(String str, String separator, int max) {\n        return splitByWholeSeparatorWorker(str, separator, max, true);\n    }\n\n    \n    private static String[] splitByWholeSeparatorWorker(String str, String separator, int max, boolean preserveAllTokens) {\n        if (str == null) {\n            return null;\n        }\n\n        int len = str.length();\n\n        if (len == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n\n        if ((separator == null) || (EMPTY.equals(separator))) {\n            \n            return splitWorker(str, null, max, preserveAllTokens);\n        }\n\n        int separatorLength = separator.length();\n\n        ArrayList<String> substrings = new ArrayList<String>();\n        int numberOfSubstrings = 0;\n        int beg = 0;\n        int end = 0;\n        while (end < len) {\n            end = str.indexOf(separator, beg);\n\n            if (end > -1) {\n                if (end > beg) {\n                    numberOfSubstrings += 1;\n\n                    if (numberOfSubstrings == max) {\n                        end = len;\n                        substrings.add(str.substring(beg));\n                    } else {\n                        \n                        \n                        substrings.add(str.substring(beg, end));\n\n                        \n                        \n                        \n                        beg = end + separatorLength;\n                    }\n                } else {\n                    \n                    if (preserveAllTokens) {\n                        numberOfSubstrings += 1;\n                        if (numberOfSubstrings == max) {\n                            end = len;\n                            substrings.add(str.substring(beg));\n                        } else {\n                            substrings.add(EMPTY);\n                        }\n                    }\n                    beg = end + separatorLength;\n                }\n            } else {\n                \n                substrings.add(str.substring(beg));\n                end = len;\n            }\n        }\n\n        return substrings.toArray(new String[substrings.size()]);\n    }\n\n    \n    \n    public static String[] splitPreserveAllTokens(String str) {\n        return splitWorker(str, null, -1, true);\n    }\n\n    \n    public static String[] splitPreserveAllTokens(String str, char separatorChar) {\n        return splitWorker(str, separatorChar, true);\n    }\n\n    \n    private static String[] splitWorker(String str, char separatorChar, boolean preserveAllTokens) {\n        \n\n        if (str == null) {\n            return null;\n        }\n        int len = str.length();\n        if (len == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n        List<String> list = new ArrayList<String>();\n        int i = 0, start = 0;\n        boolean match = false;\n        boolean lastMatch = false;\n        while (i < len) {\n            if (str.charAt(i) == separatorChar) {\n                if (match || preserveAllTokens) {\n                    list.add(str.substring(start, i));\n                    match = false;\n                    lastMatch = true;\n                }\n                start = ++i;\n                continue;\n            }\n            lastMatch = false;\n            match = true;\n            i++;\n        }\n        if (match || (preserveAllTokens && lastMatch)) {\n            list.add(str.substring(start, i));\n        }\n        return list.toArray(new String[list.size()]);\n    }\n\n    \n    public static String[] splitPreserveAllTokens(String str, String separatorChars) {\n        return splitWorker(str, separatorChars, -1, true);\n    }\n\n    \n    public static String[] splitPreserveAllTokens(String str, String separatorChars, int max) {\n        return splitWorker(str, separatorChars, max, true);\n    }\n\n    \n    private static String[] splitWorker(String str, String separatorChars, int max, boolean preserveAllTokens) {\n        \n        \n        \n\n        if (str == null) {\n            return null;\n        }\n        int len = str.length();\n        if (len == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n        List<String> list = new ArrayList<String>();\n        int sizePlus1 = 1;\n        int i = 0, start = 0;\n        boolean match = false;\n        boolean lastMatch = false;\n        if (separatorChars == null) {\n            \n            while (i < len) {\n                if (Character.isWhitespace(str.charAt(i))) {\n                    if (match || preserveAllTokens) {\n                        lastMatch = true;\n                        if (sizePlus1++ == max) {\n                            i = len;\n                            lastMatch = false;\n                        }\n                        list.add(str.substring(start, i));\n                        match = false;\n                    }\n                    start = ++i;\n                    continue;\n                }\n                lastMatch = false;\n                match = true;\n                i++;\n            }\n        } else if (separatorChars.length() == 1) {\n            \n            char sep = separatorChars.charAt(0);\n            while (i < len) {\n                if (str.charAt(i) == sep) {\n                    if (match || preserveAllTokens) {\n                        lastMatch = true;\n                        if (sizePlus1++ == max) {\n                            i = len;\n                            lastMatch = false;\n                        }\n                        list.add(str.substring(start, i));\n                        match = false;\n                    }\n                    start = ++i;\n                    continue;\n                }\n                lastMatch = false;\n                match = true;\n                i++;\n            }\n        } else {\n            \n            while (i < len) {\n                if (separatorChars.indexOf(str.charAt(i)) >= 0) {\n                    if (match || preserveAllTokens) {\n                        lastMatch = true;\n                        if (sizePlus1++ == max) {\n                            i = len;\n                            lastMatch = false;\n                        }\n                        list.add(str.substring(start, i));\n                        match = false;\n                    }\n                    start = ++i;\n                    continue;\n                }\n                lastMatch = false;\n                match = true;\n                i++;\n            }\n        }\n        if (match || (preserveAllTokens && lastMatch)) {\n            list.add(str.substring(start, i));\n        }\n        return list.toArray(new String[list.size()]);\n    }\n\n    \n    public static String[] splitByCharacterType(String str) {\n        return splitByCharacterType(str, false);\n    }\n\n    \n    public static String[] splitByCharacterTypeCamelCase(String str) {\n        return splitByCharacterType(str, true);\n    }\n\n    \n    private static String[] splitByCharacterType(String str, boolean camelCase) {\n        if (str == null) {\n            return null;\n        }\n        if (str.length() == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n        char[] c = str.toCharArray();\n        List<String> list = new ArrayList<String>();\n        int tokenStart = 0;\n        int currentType = Character.getType(c[tokenStart]);\n        for (int pos = tokenStart + 1; pos < c.length; pos++) {\n            int type = Character.getType(c[pos]);\n            if (type == currentType) {\n                continue;\n            }\n            if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n                int newTokenStart = pos - 1;\n                if (newTokenStart != tokenStart) {\n                    list.add(new String(c, tokenStart, newTokenStart - tokenStart));\n                    tokenStart = newTokenStart;\n                }\n            } else {\n                list.add(new String(c, tokenStart, pos - tokenStart));\n                tokenStart = pos;\n            }\n            currentType = type;\n        }\n        list.add(new String(c, tokenStart, c.length - tokenStart));\n        return list.toArray(new String[list.size()]);\n    }\n\n    \n    \n    \n    public static String join(Object[] array) {\n        return join(array, null);\n    }\n\n    \n    public static String join(Object[] array, char separator) {\n        if (array == null) {\n            return null;\n        }\n\n        return join(array, separator, 0, array.length);\n    }\n\n    \n    public static String join(Object[] array, char separator, int startIndex, int endIndex) {\n        if (array == null) {\n            return null;\n        }\n        int bufSize = (endIndex - startIndex);\n        if (bufSize <= 0) {\n            return EMPTY;\n        }\n\n        bufSize *= ((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1);\n        StringBuilder buf = new StringBuilder(bufSize);\n\n        for (int i = startIndex; i < endIndex; i++) {\n            if (i > startIndex) {\n                buf.append(separator);\n            }\n            if (array[i] != null) {\n                buf.append(array[i]);\n            }\n        }\n        return buf.toString();\n    }\n\n\n    \n    public static String join(Object[] array, String separator) {\n        if (array == null) {\n            return null;\n        }\n        return join(array, separator, 0, array.length);\n    }\n\n    \n    public static String join(Object[] array, String separator, int startIndex, int endIndex) {\n        if (array == null) {\n            return null;\n        }\n        if (separator == null) {\n            separator = EMPTY;\n        }\n\n        \n        \n        int bufSize = (endIndex - startIndex);\n        if (bufSize <= 0) {\n            return EMPTY;\n        }\n\n        bufSize *= ((array[startIndex] == null ? 16 : array[startIndex].toString().length())\n                        + separator.length());\n\n        StringBuilder buf = new StringBuilder(bufSize);\n\n        for (int i = startIndex; i < endIndex; i++) {\n            if (i > startIndex) {\n                buf.append(separator);\n            }\n            if (array[i] != null) {\n                buf.append(array[i]);\n            }\n        }\n        return buf.toString();\n    }\n\n    \n    public static String join(Iterator<?> iterator, char separator) {\n\n        \n        if (iterator == null) {\n            return null;\n        }\n        if (!iterator.hasNext()) {\n            return EMPTY;\n        }\n        Object first = iterator.next();\n        if (!iterator.hasNext()) {\n            return ObjectUtils.toString(first);\n        }\n\n        \n        StringBuilder buf = new StringBuilder(256); \n        if (first != null) {\n            buf.append(first);\n        }\n\n        while (iterator.hasNext()) {\n            buf.append(separator);\n            Object obj = iterator.next();\n            if (obj != null) {\n                buf.append(obj);\n            }\n        }\n\n        return buf.toString();\n    }\n\n    \n    public static String join(Iterator<?> iterator, String separator) {\n\n        \n        if (iterator == null) {\n            return null;\n        }\n        if (!iterator.hasNext()) {\n            return EMPTY;\n        }\n        Object first = iterator.next();\n        if (!iterator.hasNext()) {\n            return ObjectUtils.toString(first);\n        }\n\n        \n        StringBuilder buf = new StringBuilder(256); \n        if (first != null) {\n            buf.append(first);\n        }\n\n        while (iterator.hasNext()) {\n            if (separator != null) {\n                buf.append(separator);\n            }\n            Object obj = iterator.next();\n            if (obj != null) {\n                buf.append(obj);\n            }\n        }\n        return buf.toString();\n    }\n\n    \n    public static String join(Iterable<?> iterable, char separator) {\n        if (iterable == null) {\n            return null;\n        }\n        return join(iterable.iterator(), separator);\n    }\n\n    \n    public static String join(Iterable<?> iterable, String separator) {\n        if (iterable == null) {\n            return null;\n        }\n        return join(iterable.iterator(), separator);\n    }\n\n    \n    \n    \n    public static String deleteWhitespace(String str) {\n        if (isEmpty(str)) {\n            return str;\n        }\n        int sz = str.length();\n        char[] chs = new char[sz];\n        int count = 0;\n        for (int i = 0; i < sz; i++) {\n            if (!Character.isWhitespace(str.charAt(i))) {\n                chs[count++] = str.charAt(i);\n            }\n        }\n        if (count == sz) {\n            return str;\n        }\n        return new String(chs, 0, count);\n    }\n\n    \n    \n    \n    public static String removeStart(String str, String remove) {\n        if (isEmpty(str) || isEmpty(remove)) {\n            return str;\n        }\n        if (str.startsWith(remove)){\n            return str.substring(remove.length());\n        }\n        return str;\n    }\n\n    \n    public static String removeStartIgnoreCase(String str, String remove) {\n        if (isEmpty(str) || isEmpty(remove)) {\n            return str;\n        }\n        if (startsWithIgnoreCase(str, remove)) {\n            return str.substring(remove.length());\n        }\n        return str;\n    }\n\n    \n    public static String removeEnd(String str, String remove) {\n        if (isEmpty(str) || isEmpty(remove)) {\n            return str;\n        }\n        if (str.endsWith(remove)) {\n            return str.substring(0, str.length() - remove.length());\n        }\n        return str;\n    }\n\n    \n    public static String removeEndIgnoreCase(String str, String remove) {\n        if (isEmpty(str) || isEmpty(remove)) {\n            return str;\n        }\n        if (endsWithIgnoreCase(str, remove)) {\n            return str.substring(0, str.length() - remove.length());\n        }\n        return str;\n    }\n\n    \n    public static String remove(String str, String remove) {\n        if (isEmpty(str) || isEmpty(remove)) {\n            return str;\n        }\n        return replace(str, remove, EMPTY, -1);\n    }\n\n    \n    public static String remove(String str, char remove) {\n        if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {\n            return str;\n        }\n        char[] chars = str.toCharArray();\n        int pos = 0;\n        for (int i = 0; i < chars.length; i++) {\n            if (chars[i] != remove) {\n                chars[pos++] = chars[i];\n            }\n        }\n        return new String(chars, 0, pos);\n    }\n\n    \n    \n    \n    public static String replaceOnce(String text, String searchString, String replacement) {\n        return replace(text, searchString, replacement, 1);\n    }\n\n    \n    public static String replace(String text, String searchString, String replacement) {\n        return replace(text, searchString, replacement, -1);\n    }\n\n    \n    public static String replace(String text, String searchString, String replacement, int max) {\n        if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {\n            return text;\n        }\n        int start = 0;\n        int end = text.indexOf(searchString, start);\n        if (end == INDEX_NOT_FOUND) {\n            return text;\n        }\n        int replLength = searchString.length();\n        int increase = replacement.length() - replLength;\n        increase = (increase < 0 ? 0 : increase);\n        increase *= (max < 0 ? 16 : (max > 64 ? 64 : max));\n        StringBuilder buf = new StringBuilder(text.length() + increase);\n        while (end != INDEX_NOT_FOUND) {\n            buf.append(text.substring(start, end)).append(replacement);\n            start = end + replLength;\n            if (--max == 0) {\n                break;\n            }\n            end = text.indexOf(searchString, start);\n        }\n        buf.append(text.substring(start));\n        return buf.toString();\n    }\n\n    \n    public static String replaceEach(String text, String[] searchList, String[] replacementList) {\n        return replaceEach(text, searchList, replacementList, false, 0);\n    }\n\n    \n    public static String replaceEachRepeatedly(String text, String[] searchList, String[] replacementList) {\n        \n        \n        int timeToLive = searchList == null ? 0 : searchList.length;\n        return replaceEach(text, searchList, replacementList, true, timeToLive);\n    }\n\n    \n    private static String replaceEach(String text, String[] searchList, String[] replacementList, boolean repeat, int timeToLive) {\n\n        \n        \n\n        if (text == null || text.length() == 0 || searchList == null || \n            searchList.length == 0 || replacementList == null || replacementList.length == 0) \n        {\n            return text;\n        }\n\n        \n        if (timeToLive < 0) {\n            throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n        }\n\n        int searchLength = searchList.length;\n        int replacementLength = replacementList.length;\n\n        \n        if (searchLength != replacementLength) {\n            throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n                + searchLength\n                + \" vs \"\n                + replacementLength);\n        }\n\n        \n        boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n\n        \n        int textIndex = -1;\n        int replaceIndex = -1;\n        int tempIndex = -1;\n\n        \n        \n        for (int i = 0; i < searchLength; i++) {\n            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n                searchList[i].length() == 0 || replacementList[i] == null) \n            {\n                continue;\n            }\n            tempIndex = text.indexOf(searchList[i]);\n\n            \n            if (tempIndex == -1) {\n                noMoreMatchesForReplIndex[i] = true;\n            } else {\n                if (textIndex == -1 || tempIndex < textIndex) {\n                    textIndex = tempIndex;\n                    replaceIndex = i;\n                }\n            }\n        }\n        \n\n        \n        if (textIndex == -1) {\n            return text;\n        }\n\n        int start = 0;\n\n        \n        int increase = 0;\n\n        \n        for (int i = 0; i < searchList.length; i++) {\n            if (searchList[i] == null || replacementList[i] == null) {\n                continue;\n            }\n            int greater = replacementList[i].length() - searchList[i].length();\n            if (greater > 0) {\n                increase += 3 * greater; \n            }\n        }\n        \n        increase = Math.min(increase, text.length() / 5);\n\n        StringBuilder buf = new StringBuilder(text.length() + increase);\n\n        while (textIndex != -1) {\n\n            for (int i = start; i < textIndex; i++) {\n                buf.append(text.charAt(i));\n            }\n            buf.append(replacementList[replaceIndex]);\n\n            start = textIndex + searchList[replaceIndex].length();\n\n            textIndex = -1;\n            replaceIndex = -1;\n            tempIndex = -1;\n            \n            \n            for (int i = 0; i < searchLength; i++) {\n                if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n                    searchList[i].length() == 0 || replacementList[i] == null) \n                {\n                    continue;\n                }\n                tempIndex = text.indexOf(searchList[i], start);\n\n                \n                if (tempIndex == -1) {\n                    noMoreMatchesForReplIndex[i] = true;\n                } else {\n                    if (textIndex == -1 || tempIndex < textIndex) {\n                        textIndex = tempIndex;\n                        replaceIndex = i;\n                    }\n                }\n            }\n            \n\n        }\n        int textLength = text.length();\n        for (int i = start; i < textLength; i++) {\n            buf.append(text.charAt(i));\n        }\n        String result = buf.toString();\n        if (!repeat) {\n            return result;\n        }\n\n        return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n    }\n\n    \n    \n    \n    public static String replaceChars(String str, char searchChar, char replaceChar) {\n        if (str == null) {\n            return null;\n        }\n        return str.replace(searchChar, replaceChar);\n    }\n\n    \n    public static String replaceChars(String str, String searchChars, String replaceChars) {\n        if (isEmpty(str) || isEmpty(searchChars)) {\n            return str;\n        }\n        if (replaceChars == null) {\n            replaceChars = EMPTY;\n        }\n        boolean modified = false;\n        int replaceCharsLength = replaceChars.length();\n        int strLength = str.length();\n        StringBuilder buf = new StringBuilder(strLength);\n        for (int i = 0; i < strLength; i++) {\n            char ch = str.charAt(i);\n            int index = searchChars.indexOf(ch);\n            if (index >= 0) {\n                modified = true;\n                if (index < replaceCharsLength) {\n                    buf.append(replaceChars.charAt(index));\n                }\n            } else {\n                buf.append(ch);\n            }\n        }\n        if (modified) {\n            return buf.toString();\n        }\n        return str;\n    }\n\n    \n    \n    \n    public static String overlay(String str, String overlay, int start, int end) {\n        if (str == null) {\n            return null;\n        }\n        if (overlay == null) {\n            overlay = EMPTY;\n        }\n        int len = str.length();\n        if (start < 0) {\n            start = 0;\n        }\n        if (start > len) {\n            start = len;\n        }\n        if (end < 0) {\n            end = 0;\n        }\n        if (end > len) {\n            end = len;\n        }\n        if (start > end) {\n            int temp = start;\n            start = end;\n            end = temp;\n        }\n        return new StringBuilder(len + start - end + overlay.length() + 1)\n            .append(str.substring(0, start))\n            .append(overlay)\n            .append(str.substring(end))\n            .toString();\n    }\n\n    \n    \n    \n    public static String chomp(String str) {\n        if (isEmpty(str)) {\n            return str;\n        }\n\n        if (str.length() == 1) {\n            char ch = str.charAt(0);\n            if (ch == CharUtils.CR || ch == CharUtils.LF) {\n                return EMPTY;\n            }\n            return str;\n        }\n\n        int lastIdx = str.length() - 1;\n        char last = str.charAt(lastIdx);\n\n        if (last == CharUtils.LF) {\n            if (str.charAt(lastIdx - 1) == CharUtils.CR) {\n                lastIdx--;\n            }\n        } else if (last != CharUtils.CR) {\n            lastIdx++;\n        }\n        return str.substring(0, lastIdx);\n    }\n\n    \n    public static String chomp(String str, String separator) {\n        if (isEmpty(str) || separator == null) {\n            return str;\n        }\n        if (str.endsWith(separator)) {\n            return str.substring(0, str.length() - separator.length());\n        }\n        return str;\n    }\n\n    \n    \n    \n    public static String chop(String str) {\n        if (str == null) {\n            return null;\n        }\n        int strLen = str.length();\n        if (strLen < 2) {\n            return EMPTY;\n        }\n        int lastIdx = strLen - 1;\n        String ret = str.substring(0, lastIdx);\n        char last = str.charAt(lastIdx);\n        if (last == CharUtils.LF) {\n            if (ret.charAt(lastIdx - 1) == CharUtils.CR) {\n                return ret.substring(0, lastIdx - 1);\n            }\n        }\n        return ret;\n    }\n\n    \n    \n\n    \n    \n    \n    public static String repeat(String str, int repeat) {\n        \n\n        if (str == null) {\n            return null;\n        }\n        if (repeat <= 0) {\n            return EMPTY;\n        }\n        int inputLength = str.length();\n        if (repeat == 1 || inputLength == 0) {\n            return str;\n        }\n        if (inputLength == 1 && repeat <= PAD_LIMIT) {\n            return padding(repeat, str.charAt(0));\n        }\n\n        int outputLength = inputLength * repeat;\n        switch (inputLength) {\n            case 1 :\n                char ch = str.charAt(0);\n                char[] output1 = new char[outputLength];\n                for (int i = repeat - 1; i >= 0; i--) {\n                    output1[i] = ch;\n                }\n                return new String(output1);\n            case 2 :\n                char ch0 = str.charAt(0);\n                char ch1 = str.charAt(1);\n                char[] output2 = new char[outputLength];\n                for (int i = repeat * 2 - 2; i >= 0; i--, i--) {\n                    output2[i] = ch0;\n                    output2[i + 1] = ch1;\n                }\n                return new String(output2);\n            default :\n                StringBuilder buf = new StringBuilder(outputLength);\n                for (int i = 0; i < repeat; i++) {\n                    buf.append(str);\n                }\n                return buf.toString();\n        }\n    }\n\n    \n    public static String repeat(String str, String separator, int repeat) {\n        if(str == null || separator == null) {\n            return repeat(str, repeat);\n        } else {\n            \n            String result = repeat(str + separator, repeat);\n            return removeEnd(result, separator);\n        }\n    }\n\n    \n    private static String padding(int repeat, char padChar) throws IndexOutOfBoundsException {\n        if (repeat < 0) {\n            throw new IndexOutOfBoundsException(\"Cannot pad a negative amount: \" + repeat);\n        }\n        final char[] buf = new char[repeat];\n        for (int i = 0; i < buf.length; i++) {\n            buf[i] = padChar;\n        }\n        return new String(buf);\n    }\n\n    \n    public static String rightPad(String str, int size) {\n        return rightPad(str, size, ' ');\n    }\n\n    \n    public static String rightPad(String str, int size, char padChar) {\n        if (str == null) {\n            return null;\n        }\n        int pads = size - str.length();\n        if (pads <= 0) {\n            return str; \n        }\n        if (pads > PAD_LIMIT) {\n            return rightPad(str, size, String.valueOf(padChar));\n        }\n        return str.concat(padding(pads, padChar));\n    }\n\n    \n    public static String rightPad(String str, int size, String padStr) {\n        if (str == null) {\n            return null;\n        }\n        if (isEmpty(padStr)) {\n            padStr = \" \";\n        }\n        int padLen = padStr.length();\n        int strLen = str.length();\n        int pads = size - strLen;\n        if (pads <= 0) {\n            return str; \n        }\n        if (padLen == 1 && pads <= PAD_LIMIT) {\n            return rightPad(str, size, padStr.charAt(0));\n        }\n\n        if (pads == padLen) {\n            return str.concat(padStr);\n        } else if (pads < padLen) {\n            return str.concat(padStr.substring(0, pads));\n        } else {\n            char[] padding = new char[pads];\n            char[] padChars = padStr.toCharArray();\n            for (int i = 0; i < pads; i++) {\n                padding[i] = padChars[i % padLen];\n            }\n            return str.concat(new String(padding));\n        }\n    }\n\n    \n    public static String leftPad(String str, int size) {\n        return leftPad(str, size, ' ');\n    }\n\n    \n    public static String leftPad(String str, int size, char padChar) {\n        if (str == null) {\n            return null;\n        }\n        int pads = size - str.length();\n        if (pads <= 0) {\n            return str; \n        }\n        if (pads > PAD_LIMIT) {\n            return leftPad(str, size, String.valueOf(padChar));\n        }\n        return padding(pads, padChar).concat(str);\n    }\n\n    \n    public static String leftPad(String str, int size, String padStr) {\n        if (str == null) {\n            return null;\n        }\n        if (isEmpty(padStr)) {\n            padStr = \" \";\n        }\n        int padLen = padStr.length();\n        int strLen = str.length();\n        int pads = size - strLen;\n        if (pads <= 0) {\n            return str; \n        }\n        if (padLen == 1 && pads <= PAD_LIMIT) {\n            return leftPad(str, size, padStr.charAt(0));\n        }\n\n        if (pads == padLen) {\n            return padStr.concat(str);\n        } else if (pads < padLen) {\n            return padStr.substring(0, pads).concat(str);\n        } else {\n            char[] padding = new char[pads];\n            char[] padChars = padStr.toCharArray();\n            for (int i = 0; i < pads; i++) {\n                padding[i] = padChars[i % padLen];\n            }\n            return new String(padding).concat(str);\n        }\n    }\n\n\t\n\tpublic static int length(CharSequence cs) {\n\t\treturn CharSequenceUtils.length(cs);\n\t}\n    \n    \n    \n    \n    public static String center(String str, int size) {\n        return center(str, size, ' ');\n    }\n\n    \n    public static String center(String str, int size, char padChar) {\n        if (str == null || size <= 0) {\n            return str;\n        }\n        int strLen = str.length();\n        int pads = size - strLen;\n        if (pads <= 0) {\n            return str;\n        }\n        str = leftPad(str, strLen + pads / 2, padChar);\n        str = rightPad(str, size, padChar);\n        return str;\n    }\n\n    \n    public static String center(String str, int size, String padStr) {\n        if (str == null || size <= 0) {\n            return str;\n        }\n        if (isEmpty(padStr)) {\n            padStr = \" \";\n        }\n        int strLen = str.length();\n        int pads = size - strLen;\n        if (pads <= 0) {\n            return str;\n        }\n        str = leftPad(str, strLen + pads / 2, padStr);\n        str = rightPad(str, size, padStr);\n        return str;\n    }\n\n    \n    \n    \n    public static String upperCase(String str) {\n        if (str == null) {\n            return null;\n        }\n        return str.toUpperCase();\n    }\n\n    \n    public static String upperCase(String str, Locale locale) {\n        if (str == null) {\n            return null;\n        }\n        return str.toUpperCase(locale);\n    }\n\n    \n    public static String lowerCase(String str) {\n        if (str == null) {\n            return null;\n        }\n        return str.toLowerCase();\n    }\n\n    \n    public static String lowerCase(String str, Locale locale) {\n        if (str == null) {\n            return null;\n        }\n        return str.toLowerCase(locale);\n    }\n\n    \n    public static String capitalize(CharSequence cs) {\n        if (cs == null ) {\n            return null;\n        }\n        int strLen;\n        if ((strLen = cs.length()) == 0) {\n            return cs.toString();\n        }\n        return new StringBuilder(strLen)\n            .append(Character.toTitleCase(cs.charAt(0)))\n            .append(CharSequenceUtils.subSequence(cs, 1))\n            .toString();\n    }\n\n    \n    public static String uncapitalize(CharSequence cs) {\n        if (cs == null ) {\n            return null;\n        }\n        int strLen;\n        if ((strLen = cs.length()) == 0) {\n            return cs.toString();\n        }\n        return new StringBuilder(strLen)\n            .append(Character.toLowerCase(cs.charAt(0)))\n            .append(CharSequenceUtils.subSequence(cs, 1))\n            .toString();\n    }\n\n    \n    public static String swapCase(String str) {\n        int strLen;\n        if (str == null || (strLen = str.length()) == 0) {\n            return str;\n        }\n        StringBuilder buffer = new StringBuilder(strLen);\n\n        char ch = 0;\n        for (int i = 0; i < strLen; i++) {\n            ch = str.charAt(i);\n            if (Character.isUpperCase(ch)) {\n                ch = Character.toLowerCase(ch);\n            } else if (Character.isTitleCase(ch)) {\n                ch = Character.toLowerCase(ch);\n            } else if (Character.isLowerCase(ch)) {\n                ch = Character.toUpperCase(ch);\n            }\n            buffer.append(ch);\n        }\n        return buffer.toString();\n    }\n\n    \n    \n    \n    public static int countMatches(String str, String sub) {\n        if (isEmpty(str) || isEmpty(sub)) {\n            return 0;\n        }\n        int count = 0;\n        int idx = 0;\n        while ((idx = str.indexOf(sub, idx)) != INDEX_NOT_FOUND) {\n            count++;\n            idx += sub.length();\n        }\n        return count;\n    }\n\n    \n    \n    \n    public static boolean isAlpha(CharSequence cs) {\n        if (cs == null) {\n            return false;\n        }\n        int sz = cs.length();\n        for (int i = 0; i < sz; i++) {\n            if (Character.isLetter(cs.charAt(i)) == false) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public static boolean isAlphaSpace(CharSequence cs) {\n        if (cs == null) {\n            return false;\n        }\n        int sz = cs.length();\n        for (int i = 0; i < sz; i++) {\n            if ((Character.isLetter(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public static boolean isAlphanumeric(CharSequence cs) {\n        if (cs == null) {\n            return false;\n        }\n        int sz = cs.length();\n        for (int i = 0; i < sz; i++) {\n            if (Character.isLetterOrDigit(cs.charAt(i)) == false) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public static boolean isAlphanumericSpace(CharSequence cs) {\n        if (cs == null) {\n            return false;\n        }\n        int sz = cs.length();\n        for (int i = 0; i < sz; i++) {\n            if ((Character.isLetterOrDigit(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public static boolean isAsciiPrintable(CharSequence cs) {\n        if (cs == null) {\n            return false;\n        }\n        int sz = cs.length();\n        for (int i = 0; i < sz; i++) {\n            if (CharUtils.isAsciiPrintable(cs.charAt(i)) == false) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public static boolean isNumeric(CharSequence cs) {\n        if (cs == null) {\n            return false;\n        }\n        int sz = cs.length();\n        for (int i = 0; i < sz; i++) {\n            if (Character.isDigit(cs.charAt(i)) == false) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public static boolean isNumericSpace(CharSequence cs) {\n        if (cs == null) {\n            return false;\n        }\n        int sz = cs.length();\n        for (int i = 0; i < sz; i++) {\n            if ((Character.isDigit(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public static boolean isWhitespace(CharSequence cs) {\n        if (cs == null) {\n            return false;\n        }\n        int sz = cs.length();\n        for (int i = 0; i < sz; i++) {\n            if ((Character.isWhitespace(cs.charAt(i)) == false)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public static boolean isAllLowerCase(CharSequence cs) {\n        if (cs == null || isEmpty(cs)) {\n            return false;\n        }\n        int sz = cs.length();\n        for (int i = 0; i < sz; i++) {\n            if (Character.isLowerCase(cs.charAt(i)) == false) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public static boolean isAllUpperCase(CharSequence cs) {\n        if (cs == null || isEmpty(cs)) {\n            return false;\n        }\n        int sz = cs.length();\n        for (int i = 0; i < sz; i++) {\n            if (Character.isUpperCase(cs.charAt(i)) == false) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    \n    \n    public static String defaultString(String str) {\n        return str == null ? EMPTY : str;\n    }\n\n    \n    public static String defaultString(String str, String defaultStr) {\n        return str == null ? defaultStr : str;\n    }\n\n    \n    public static <T extends CharSequence> T defaultIfEmpty(T str, T defaultStr) {\n        return StringUtils.isEmpty(str) ? defaultStr : str;\n    }\n\n    \n    \n    \n    public static String reverse(String str) {\n        if (str == null) {\n            return null;\n        }\n\t\treturn new StringBuilder(str).reverse().toString();\n    }\n\n    \n    public static String reverseDelimited(String str, char separatorChar) {\n        if (str == null) {\n            return null;\n        }\n        \n        \n        String[] strs = split(str, separatorChar);\n        ArrayUtils.reverse(strs);\n        return join(strs, separatorChar);\n    }\n\n    \n    \n    \n    public static String abbreviate(String str, int maxWidth) {\n        return abbreviate(str, 0, maxWidth);\n    }\n\n    \n    public static String abbreviate(String str, int offset, int maxWidth) {\n        if (str == null) {\n            return null;\n        }\n        if (maxWidth < 4) {\n            throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n        }\n        if (str.length() <= maxWidth) {\n            return str;\n        }\n        if (offset > str.length()) {\n            offset = str.length();\n        }\n        if ((str.length() - offset) < (maxWidth - 3)) {\n            offset = str.length() - (maxWidth - 3);\n        }\n        final String abrevMarker = \"...\";\n\t\tif (offset <= 4) {\n            return str.substring(0, maxWidth - 3) + abrevMarker;\n        }\n        if (maxWidth < 7) {\n            throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n        }\n        if ((offset + (maxWidth - 3)) < str.length()) {\n            return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n        }\n        return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n    }\n    \n    \n    public static String abbreviateMiddle(String str, String middle, int length) {\n        if (isEmpty(str) || isEmpty(middle)) {\n            return str;\n        }\n      \n        if (length >= str.length() || length < (middle.length()+2)) {\n            return str;\n        }\n\n        int targetSting = length-middle.length();\n        int startOffset = targetSting/2+targetSting%2;\n        int endOffset = str.length()-targetSting/2;\n        \n        StringBuilder builder = new StringBuilder(length);\n        builder.append(str.substring(0,startOffset));\n        builder.append(middle);\n        builder.append(str.substring(endOffset));\n        \n        return builder.toString();\n    }\n\n    \n    \n    \n    public static String difference(String str1, String str2) {\n        if (str1 == null) {\n            return str2;\n        }\n        if (str2 == null) {\n            return str1;\n        }\n        int at = indexOfDifference(str1, str2);\n        if (at == INDEX_NOT_FOUND) {\n            return EMPTY;\n        }\n        return str2.substring(at);\n    }\n\n    \n    public static int indexOfDifference(CharSequence cs1, CharSequence cs2) {\n        if (cs1 == cs2) {\n            return INDEX_NOT_FOUND;\n        }\n        if (cs1 == null || cs2 == null) {\n            return 0;\n        }\n        int i;\n        for (i = 0; i < cs1.length() && i < cs2.length(); ++i) {\n            if (cs1.charAt(i) != cs2.charAt(i)) {\n                break;\n            }\n        }\n        if (i < cs2.length() || i < cs1.length()) {\n            return i;\n        }\n        return INDEX_NOT_FOUND;\n    }\n\n    \n    public static int indexOfDifference(CharSequence[] css) {\n        if (css == null || css.length <= 1) {\n            return INDEX_NOT_FOUND;\n        }\n        boolean anyStringNull = false;\n        boolean allStringsNull = true;\n        int arrayLen = css.length;\n        int shortestStrLen = Integer.MAX_VALUE;\n        int longestStrLen = 0;\n\n        \n        \n        \n        for (int i = 0; i < arrayLen; i++) {\n            if (css[i] == null) {\n                anyStringNull = true;\n                shortestStrLen = 0;\n            } else {\n                allStringsNull = false;\n                shortestStrLen = Math.min(css[i].length(), shortestStrLen);\n                longestStrLen = Math.max(css[i].length(), longestStrLen);\n            }\n        }\n\n        \n        if (allStringsNull || (longestStrLen == 0 && !anyStringNull)) {\n            return INDEX_NOT_FOUND;\n        }\n\n        \n        if (shortestStrLen == 0) {\n            return 0;\n        }\n\n        \n        int firstDiff = -1;\n        for (int stringPos = 0; stringPos < shortestStrLen; stringPos++) {\n            char comparisonChar = css[0].charAt(stringPos);\n            for (int arrayPos = 1; arrayPos < arrayLen; arrayPos++) {\n                if (css[arrayPos].charAt(stringPos) != comparisonChar) {\n                    firstDiff = stringPos;\n                    break;\n                }\n            }\n            if (firstDiff != -1) {\n                break;\n            }\n        }\n\n        if (firstDiff == -1 && shortestStrLen != longestStrLen) {\n            \n            \n            \n            return shortestStrLen;\n        }\n        return firstDiff;\n    }\n    \n    \n    public static String getCommonPrefix(String[] strs) {\n        if (strs == null || strs.length == 0) {\n            return EMPTY;\n        }\n        int smallestIndexOfDiff = indexOfDifference(strs);\n        if (smallestIndexOfDiff == INDEX_NOT_FOUND) {\n            \n            if (strs[0] == null) {\n                return EMPTY;\n            }\n            return strs[0];\n        } else if (smallestIndexOfDiff == 0) {\n            \n            return EMPTY;\n        } else {\n            \n            return strs[0].substring(0, smallestIndexOfDiff);\n        }\n    }  \n    \n    \n    \n    \n    public static int getLevenshteinDistance(CharSequence s, CharSequence t) {\n        if (s == null || t == null) {\n            throw new IllegalArgumentException(\"Strings must not be null\");\n        }\n\n        \n\n        int n = s.length(); \n        int m = t.length(); \n\n        if (n == 0) {\n            return m;\n        } else if (m == 0) {\n            return n;\n        }\n\n        if (n > m) {\n            \n        \tCharSequence tmp = s;\n            s = t;\n            t = tmp;\n            n = m;\n            m = t.length();\n        }\n\n        int p[] = new int[n+1]; \n        int d[] = new int[n+1]; \n        int _d[]; \n\n        \n        int i; \n        int j; \n\n        char t_j; \n\n        int cost; \n\n        for (i = 0; i<=n; i++) {\n            p[i] = i;\n        }\n\n        for (j = 1; j<=m; j++) {\n            t_j = t.charAt(j-1);\n            d[0] = j;\n\n            for (i=1; i<=n; i++) {\n                cost = s.charAt(i-1)==t_j ? 0 : 1;\n                \n                d[i] = Math.min(Math.min(d[i-1]+1, p[i]+1),  p[i-1]+cost);\n            }\n\n            \n            _d = p;\n            p = d;\n            d = _d;\n        }\n\n        \n        \n        return p[n];\n    }\n\n    \n\n\n    \n    \n\n    \n    public static boolean startsWith(String str, String prefix) {\n        return startsWith(str, prefix, false);\n    }\n\n    \n    public static boolean startsWithIgnoreCase(String str, String prefix) {\n        return startsWith(str, prefix, true);\n    }\n\n    \n    private static boolean startsWith(String str, String prefix, boolean ignoreCase) {\n        if (str == null || prefix == null) {\n            return (str == null && prefix == null);\n        }\n        if (prefix.length() > str.length()) {\n            return false;\n        }\n        return str.regionMatches(ignoreCase, 0, prefix, 0, prefix.length());\n    }\n    \n    \n    public static boolean startsWithAny(String string, String[] searchStrings) {\n        if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) {\n            return false;\n        }\n        for (int i = 0; i < searchStrings.length; i++) {\n            String searchString = searchStrings[i];\n            if (StringUtils.startsWith(string, searchString)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    \n    \n\n    \n    public static boolean endsWith(String str, String suffix) {\n        return endsWith(str, suffix, false);\n    }\n\n    \n    public static boolean endsWithIgnoreCase(String str, String suffix) {\n        return endsWith(str, suffix, true);\n    }\n\n    \n    private static boolean endsWith(String str, String suffix, boolean ignoreCase) {\n        if (str == null || suffix == null) {\n            return str == null && suffix == null;\n        }\n        if (suffix.length() > str.length()) {\n            return false;\n        }\n        int strOffset = str.length() - suffix.length();\n        return str.regionMatches(ignoreCase, strOffset, suffix, 0, suffix.length());\n    }\n}\n",
      "buggy_signatures": [
        "public static boolean isEmpty(CharSequence cs)",
        "public static boolean isNotEmpty(CharSequence cs)",
        "public static boolean isBlank(CharSequence cs)",
        "public static boolean isNotBlank(CharSequence cs)",
        "public static String trim(String str)",
        "public static String trimToNull(String str)",
        "public static String trimToEmpty(String str)",
        "public static String strip(String str)",
        "public static String stripToNull(String str)",
        "public static String stripToEmpty(String str)",
        "public static String strip(String str, String stripChars)",
        "public static String stripStart(String str, String stripChars)",
        "public static String stripEnd(String str, String stripChars)",
        "public static String[] stripAll(String[] strs)",
        "public static String[] stripAll(String[] strs, String stripChars)",
        "public static String stripAccents(String input)",
        "public static boolean equals(CharSequence cs1, CharSequence cs2)",
        "public static boolean equalsIgnoreCase(String str1, String str2)",
        "public static int indexOf(String str, char searchChar)",
        "public static int indexOf(String str, char searchChar, int startPos)",
        "public static int indexOf(String str, String searchStr)",
        "public static int indexOf(String str, String searchStr, int startPos)",
        "public static int ordinalIndexOf(String str, String searchStr, int ordinal)",
        "private static int ordinalIndexOf(String str, String searchStr, int ordinal, boolean lastIndex)",
        "public static int indexOfIgnoreCase(String str, String searchStr)",
        "public static int indexOfIgnoreCase(String str, String searchStr, int startPos)",
        "public static int lastIndexOf(String str, char searchChar)",
        "public static int lastIndexOf(String str, char searchChar, int startPos)",
        "public static int lastIndexOf(String str, String searchStr)",
        "public static int lastOrdinalIndexOf(String str, String searchStr, int ordinal)",
        "public static int lastIndexOf(String str, String searchStr, int startPos)",
        "public static int lastIndexOfIgnoreCase(String str, String searchStr)",
        "public static int lastIndexOfIgnoreCase(String str, String searchStr, int startPos)",
        "public static boolean contains(String str, char searchChar)",
        "public static boolean contains(String str, String searchStr)",
        "public static boolean containsIgnoreCase(String str, String searchStr)",
        "public static int indexOfAny(CharSequence cs, char[] searchChars)",
        "public static int indexOfAny(CharSequence cs, String searchChars)",
        "public static boolean containsAny(CharSequence cs, char[] searchChars)",
        "public static boolean containsAny(CharSequence cs, String searchChars)",
        "public static int indexOfAnyBut(CharSequence cs, char[] searchChars)",
        "public static int indexOfAnyBut(String str, String searchChars)",
        "public static boolean containsOnly(CharSequence cs, char[] valid)",
        "public static boolean containsOnly(CharSequence cs, String validChars)",
        "public static boolean containsNone(CharSequence cs, char[] searchChars)",
        "public static boolean containsNone(CharSequence cs, String invalidChars)",
        "public static int indexOfAny(String str, String[] searchStrs)",
        "public static int lastIndexOfAny(String str, String[] searchStrs)",
        "public static String substring(String str, int start)",
        "public static String substring(String str, int start, int end)",
        "public static String left(String str, int len)",
        "public static String right(String str, int len)",
        "public static String mid(String str, int pos, int len)",
        "public static String substringBefore(String str, String separator)",
        "public static String substringAfter(String str, String separator)",
        "public static String substringBeforeLast(String str, String separator)",
        "public static String substringAfterLast(String str, String separator)",
        "public static String substringBetween(String str, String tag)",
        "public static String substringBetween(String str, String open, String close)",
        "public static String[] substringsBetween(String str, String open, String close)",
        "public static String[] split(String str)",
        "public static String[] split(String str, char separatorChar)",
        "public static String[] split(String str, String separatorChars)",
        "public static String[] split(String str, String separatorChars, int max)",
        "public static String[] splitByWholeSeparator(String str, String separator)",
        "public static String[] splitByWholeSeparator( String str, String separator, int max )",
        "public static String[] splitByWholeSeparatorPreserveAllTokens(String str, String separator)",
        "public static String[] splitByWholeSeparatorPreserveAllTokens(String str, String separator, int max)",
        "private static String[] splitByWholeSeparatorWorker(String str, String separator, int max, boolean preserveAllTokens)",
        "public static String[] splitPreserveAllTokens(String str)",
        "public static String[] splitPreserveAllTokens(String str, char separatorChar)",
        "private static String[] splitWorker(String str, char separatorChar, boolean preserveAllTokens)",
        "public static String[] splitPreserveAllTokens(String str, String separatorChars)",
        "public static String[] splitPreserveAllTokens(String str, String separatorChars, int max)",
        "private static String[] splitWorker(String str, String separatorChars, int max, boolean preserveAllTokens)",
        "public static String[] splitByCharacterType(String str)",
        "public static String[] splitByCharacterTypeCamelCase(String str)",
        "private static String[] splitByCharacterType(String str, boolean camelCase)",
        "public static String join(Object[] array)",
        "public static String join(Object[] array, char separator)",
        "public static String join(Object[] array, char separator, int startIndex, int endIndex)",
        "public static String join(Object[] array, String separator)",
        "public static String join(Object[] array, String separator, int startIndex, int endIndex)",
        "public static String join(Iterator<?> iterator, char separator)",
        "public static String join(Iterator<?> iterator, String separator)",
        "public static String join(Iterable<?> iterable, char separator)",
        "public static String join(Iterable<?> iterable, String separator)",
        "public static String deleteWhitespace(String str)",
        "public static String removeStart(String str, String remove)",
        "public static String removeStartIgnoreCase(String str, String remove)",
        "public static String removeEnd(String str, String remove)",
        "public static String removeEndIgnoreCase(String str, String remove)",
        "public static String remove(String str, String remove)",
        "public static String remove(String str, char remove)",
        "public static String replaceOnce(String text, String searchString, String replacement)",
        "public static String replace(String text, String searchString, String replacement)",
        "public static String replace(String text, String searchString, String replacement, int max)",
        "public static String replaceEach(String text, String[] searchList, String[] replacementList)",
        "public static String replaceEachRepeatedly(String text, String[] searchList, String[] replacementList)",
        "private static String replaceEach(String text, String[] searchList, String[] replacementList, boolean repeat, int timeToLive)",
        "public static String replaceChars(String str, char searchChar, char replaceChar)",
        "public static String replaceChars(String str, String searchChars, String replaceChars)",
        "public static String overlay(String str, String overlay, int start, int end)",
        "public static String chomp(String str)",
        "public static String chomp(String str, String separator)",
        "public static String chop(String str)",
        "public static String repeat(String str, int repeat)",
        "public static String repeat(String str, String separator, int repeat)",
        "private static String padding(int repeat, char padChar) throws IndexOutOfBoundsException",
        "public static String rightPad(String str, int size)",
        "public static String rightPad(String str, int size, char padChar)",
        "public static String rightPad(String str, int size, String padStr)",
        "public static String leftPad(String str, int size)",
        "public static String leftPad(String str, int size, char padChar)",
        "public static String leftPad(String str, int size, String padStr)",
        "public static int length(CharSequence cs)",
        "public static String center(String str, int size)",
        "public static String center(String str, int size, char padChar)",
        "public static String center(String str, int size, String padStr)",
        "public static String upperCase(String str)",
        "public static String upperCase(String str, Locale locale)",
        "public static String lowerCase(String str)",
        "public static String lowerCase(String str, Locale locale)",
        "public static String capitalize(CharSequence cs)",
        "public static String uncapitalize(CharSequence cs)",
        "public static String swapCase(String str)",
        "public static int countMatches(String str, String sub)",
        "public static boolean isAlpha(CharSequence cs)",
        "public static boolean isAlphaSpace(CharSequence cs)",
        "public static boolean isAlphanumeric(CharSequence cs)",
        "public static boolean isAlphanumericSpace(CharSequence cs)",
        "public static boolean isAsciiPrintable(CharSequence cs)",
        "public static boolean isNumeric(CharSequence cs)",
        "public static boolean isNumericSpace(CharSequence cs)",
        "public static boolean isWhitespace(CharSequence cs)",
        "public static boolean isAllLowerCase(CharSequence cs)",
        "public static boolean isAllUpperCase(CharSequence cs)",
        "public static String defaultString(String str)",
        "public static String defaultString(String str, String defaultStr)",
        "public static <T extends CharSequence> T defaultIfEmpty(T str, T defaultStr)",
        "public static String reverse(String str)",
        "public static String reverseDelimited(String str, char separatorChar)",
        "public static String abbreviate(String str, int maxWidth)",
        "public static String abbreviate(String str, int offset, int maxWidth)",
        "public static String abbreviateMiddle(String str, String middle, int length)",
        "public static String difference(String str1, String str2)",
        "public static int indexOfDifference(CharSequence cs1, CharSequence cs2)",
        "public static int indexOfDifference(CharSequence[] css)",
        "public static String getCommonPrefix(String[] strs)",
        "public static int getLevenshteinDistance(CharSequence s, CharSequence t)",
        "public static boolean startsWith(String str, String prefix)",
        "public static boolean startsWithIgnoreCase(String str, String prefix)",
        "private static boolean startsWith(String str, String prefix, boolean ignoreCase)",
        "public static boolean startsWithAny(String string, String[] searchStrings)",
        "public static boolean endsWith(String str, String suffix)",
        "public static boolean endsWithIgnoreCase(String str, String suffix)",
        "private static boolean endsWith(String str, String suffix, boolean ignoreCase)"
      ],
      "fixed_signatures": [
        "public static boolean isEmpty(CharSequence cs)",
        "public static boolean isNotEmpty(CharSequence cs)",
        "public static boolean isBlank(CharSequence cs)",
        "public static boolean isNotBlank(CharSequence cs)",
        "public static String trim(String str)",
        "public static String trimToNull(String str)",
        "public static String trimToEmpty(String str)",
        "public static String strip(String str)",
        "public static String stripToNull(String str)",
        "public static String stripToEmpty(String str)",
        "public static String strip(String str, String stripChars)",
        "public static String stripStart(String str, String stripChars)",
        "public static String stripEnd(String str, String stripChars)",
        "public static String[] stripAll(String[] strs)",
        "public static String[] stripAll(String[] strs, String stripChars)",
        "public static String stripAccents(String input)",
        "public static boolean equals(CharSequence cs1, CharSequence cs2)",
        "public static boolean equalsIgnoreCase(String str1, String str2)",
        "public static int indexOf(String str, char searchChar)",
        "public static int indexOf(String str, char searchChar, int startPos)",
        "public static int indexOf(String str, String searchStr)",
        "public static int indexOf(String str, String searchStr, int startPos)",
        "public static int ordinalIndexOf(String str, String searchStr, int ordinal)",
        "private static int ordinalIndexOf(String str, String searchStr, int ordinal, boolean lastIndex)",
        "public static int indexOfIgnoreCase(String str, String searchStr)",
        "public static int indexOfIgnoreCase(String str, String searchStr, int startPos)",
        "public static int lastIndexOf(String str, char searchChar)",
        "public static int lastIndexOf(String str, char searchChar, int startPos)",
        "public static int lastIndexOf(String str, String searchStr)",
        "public static int lastOrdinalIndexOf(String str, String searchStr, int ordinal)",
        "public static int lastIndexOf(String str, String searchStr, int startPos)",
        "public static int lastIndexOfIgnoreCase(String str, String searchStr)",
        "public static int lastIndexOfIgnoreCase(String str, String searchStr, int startPos)",
        "public static boolean contains(String str, char searchChar)",
        "public static boolean contains(String str, String searchStr)",
        "public static boolean containsIgnoreCase(String str, String searchStr)",
        "public static int indexOfAny(CharSequence cs, char[] searchChars)",
        "public static int indexOfAny(CharSequence cs, String searchChars)",
        "public static boolean containsAny(String cs, char[] searchChars)",
        "public static boolean containsAny(String cs, String searchChars)",
        "public static int indexOfAnyBut(CharSequence cs, char[] searchChars)",
        "public static int indexOfAnyBut(String str, String searchChars)",
        "public static boolean containsOnly(CharSequence cs, char[] valid)",
        "public static boolean containsOnly(CharSequence cs, String validChars)",
        "public static boolean containsNone(CharSequence cs, char[] searchChars)",
        "public static boolean containsNone(CharSequence cs, String invalidChars)",
        "public static int indexOfAny(String str, String[] searchStrs)",
        "public static int lastIndexOfAny(String str, String[] searchStrs)",
        "public static String substring(String str, int start)",
        "public static String substring(String str, int start, int end)",
        "public static String left(String str, int len)",
        "public static String right(String str, int len)",
        "public static String mid(String str, int pos, int len)",
        "public static String substringBefore(String str, String separator)",
        "public static String substringAfter(String str, String separator)",
        "public static String substringBeforeLast(String str, String separator)",
        "public static String substringAfterLast(String str, String separator)",
        "public static String substringBetween(String str, String tag)",
        "public static String substringBetween(String str, String open, String close)",
        "public static String[] substringsBetween(String str, String open, String close)",
        "public static String[] split(String str)",
        "public static String[] split(String str, char separatorChar)",
        "public static String[] split(String str, String separatorChars)",
        "public static String[] split(String str, String separatorChars, int max)",
        "public static String[] splitByWholeSeparator(String str, String separator)",
        "public static String[] splitByWholeSeparator( String str, String separator, int max )",
        "public static String[] splitByWholeSeparatorPreserveAllTokens(String str, String separator)",
        "public static String[] splitByWholeSeparatorPreserveAllTokens(String str, String separator, int max)",
        "private static String[] splitByWholeSeparatorWorker(String str, String separator, int max, boolean preserveAllTokens)",
        "public static String[] splitPreserveAllTokens(String str)",
        "public static String[] splitPreserveAllTokens(String str, char separatorChar)",
        "private static String[] splitWorker(String str, char separatorChar, boolean preserveAllTokens)",
        "public static String[] splitPreserveAllTokens(String str, String separatorChars)",
        "public static String[] splitPreserveAllTokens(String str, String separatorChars, int max)",
        "private static String[] splitWorker(String str, String separatorChars, int max, boolean preserveAllTokens)",
        "public static String[] splitByCharacterType(String str)",
        "public static String[] splitByCharacterTypeCamelCase(String str)",
        "private static String[] splitByCharacterType(String str, boolean camelCase)",
        "public static String join(Object[] array)",
        "public static String join(Object[] array, char separator)",
        "public static String join(Object[] array, char separator, int startIndex, int endIndex)",
        "public static String join(Object[] array, String separator)",
        "public static String join(Object[] array, String separator, int startIndex, int endIndex)",
        "public static String join(Iterator<?> iterator, char separator)",
        "public static String join(Iterator<?> iterator, String separator)",
        "public static String join(Iterable<?> iterable, char separator)",
        "public static String join(Iterable<?> iterable, String separator)",
        "public static String deleteWhitespace(String str)",
        "public static String removeStart(String str, String remove)",
        "public static String removeStartIgnoreCase(String str, String remove)",
        "public static String removeEnd(String str, String remove)",
        "public static String removeEndIgnoreCase(String str, String remove)",
        "public static String remove(String str, String remove)",
        "public static String remove(String str, char remove)",
        "public static String replaceOnce(String text, String searchString, String replacement)",
        "public static String replace(String text, String searchString, String replacement)",
        "public static String replace(String text, String searchString, String replacement, int max)",
        "public static String replaceEach(String text, String[] searchList, String[] replacementList)",
        "public static String replaceEachRepeatedly(String text, String[] searchList, String[] replacementList)",
        "private static String replaceEach(String text, String[] searchList, String[] replacementList, boolean repeat, int timeToLive)",
        "public static String replaceChars(String str, char searchChar, char replaceChar)",
        "public static String replaceChars(String str, String searchChars, String replaceChars)",
        "public static String overlay(String str, String overlay, int start, int end)",
        "public static String chomp(String str)",
        "public static String chomp(String str, String separator)",
        "public static String chop(String str)",
        "public static String repeat(String str, int repeat)",
        "public static String repeat(String str, String separator, int repeat)",
        "private static String padding(int repeat, char padChar) throws IndexOutOfBoundsException",
        "public static String rightPad(String str, int size)",
        "public static String rightPad(String str, int size, char padChar)",
        "public static String rightPad(String str, int size, String padStr)",
        "public static String leftPad(String str, int size)",
        "public static String leftPad(String str, int size, char padChar)",
        "public static String leftPad(String str, int size, String padStr)",
        "public static int length(CharSequence cs)",
        "public static String center(String str, int size)",
        "public static String center(String str, int size, char padChar)",
        "public static String center(String str, int size, String padStr)",
        "public static String upperCase(String str)",
        "public static String upperCase(String str, Locale locale)",
        "public static String lowerCase(String str)",
        "public static String lowerCase(String str, Locale locale)",
        "public static String capitalize(CharSequence cs)",
        "public static String uncapitalize(CharSequence cs)",
        "public static String swapCase(String str)",
        "public static int countMatches(String str, String sub)",
        "public static boolean isAlpha(CharSequence cs)",
        "public static boolean isAlphaSpace(CharSequence cs)",
        "public static boolean isAlphanumeric(CharSequence cs)",
        "public static boolean isAlphanumericSpace(CharSequence cs)",
        "public static boolean isAsciiPrintable(CharSequence cs)",
        "public static boolean isNumeric(CharSequence cs)",
        "public static boolean isNumericSpace(CharSequence cs)",
        "public static boolean isWhitespace(CharSequence cs)",
        "public static boolean isAllLowerCase(CharSequence cs)",
        "public static boolean isAllUpperCase(CharSequence cs)",
        "public static String defaultString(String str)",
        "public static String defaultString(String str, String defaultStr)",
        "public static <T extends CharSequence> T defaultIfEmpty(T str, T defaultStr)",
        "public static String reverse(String str)",
        "public static String reverseDelimited(String str, char separatorChar)",
        "public static String abbreviate(String str, int maxWidth)",
        "public static String abbreviate(String str, int offset, int maxWidth)",
        "public static String abbreviateMiddle(String str, String middle, int length)",
        "public static String difference(String str1, String str2)",
        "public static int indexOfDifference(CharSequence cs1, CharSequence cs2)",
        "public static int indexOfDifference(CharSequence[] css)",
        "public static String getCommonPrefix(String[] strs)",
        "public static int getLevenshteinDistance(CharSequence s, CharSequence t)",
        "public static boolean startsWith(String str, String prefix)",
        "public static boolean startsWithIgnoreCase(String str, String prefix)",
        "private static boolean startsWith(String str, String prefix, boolean ignoreCase)",
        "public static boolean startsWithAny(String string, String[] searchStrings)",
        "public static boolean endsWith(String str, String suffix)",
        "public static boolean endsWithIgnoreCase(String str, String suffix)",
        "private static boolean endsWith(String str, String suffix, boolean ignoreCase)"
      ],
      "methods": [
        {
          "buggy_method": "  public static int indexOfAny(CharSequence cs, char[] searchChars) {\n  if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n  return INDEX_NOT_FOUND;\n  }\n  int csLen = cs.length();\n  int searchLen = searchChars.length;\n  for (int i = 0; i < csLen; i++) {\n  char ch = cs.charAt(i);\n  for (int j = 0; j < searchLen; j++) {\n  if (searchChars[j] == ch) {\n  \n  return i;\n  }\n  }\n  }\n  return INDEX_NOT_FOUND;\n  }",
          "fixed_method": "  public static int indexOfAny(CharSequence cs, char[] searchChars) {\n  if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n  return INDEX_NOT_FOUND;\n  }\n  int csLen = cs.length();\n  int csLast = csLen - 1;\n  int searchLen = searchChars.length;\n  int searchLast = searchLen - 1;\n  for (int i = 0; i < csLen; i++) {\n  char ch = cs.charAt(i);\n  for (int j = 0; j < searchLen; j++) {\n  if (searchChars[j] == ch) {\n  if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) {\n  \n  if (searchChars[j + 1] == cs.charAt(i + 1)) {\n  return i;\n  }\n  } else {\n  return i;\n  }\n  }\n  }\n  }\n  return INDEX_NOT_FOUND;\n  }",
          "diff": [
            "@@ -1373,13 +1373,21 @@",
            "             return INDEX_NOT_FOUND;\n",
            "         }\n",
            "         int csLen = cs.length();\n",
            "+        int csLast = csLen - 1;\n",
            "         int searchLen = searchChars.length;\n",
            "+        int searchLast = searchLen - 1;\n",
            "         for (int i = 0; i < csLen; i++) {\n",
            "             char ch = cs.charAt(i);\n",
            "             for (int j = 0; j < searchLen; j++) {\n",
            "                 if (searchChars[j] == ch) {\n",
            "+                    if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) {\n",
            "                         // ch is a supplementary character\n",
            "+                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n",
            "+                            return i;\n",
            "+                        }\n",
            "+                    } else {\n",
            "                         return i;\n",
            "+                    }\n",
            "                 }\n",
            "             }\n",
            "         }\n"
          ],
          "changed_lines": 8
        },
        {
          "buggy_method": "  public static boolean containsAny(CharSequence cs, char[] searchChars) {\n  if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n  return false;\n  }\n  int csLength = cs.length();\n  int searchLength = searchChars.length;\n  int csLast = csLength - 1;\n  int searchLast = searchLength - 1;\n  for (int i = 0; i < csLength; i++) {\n  char ch = cs.charAt(i);\n  for (int j = 0; j < searchLength; j++) {\n  if (searchChars[j] == ch) {\n  if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n  \n  if (searchChars[j + 1] == cs.charAt(i + 1)) {\n  return true;\n  }\n  } else {\n  \n  return true;\n  }\n  }\n  }\n  }\n  return false;\n  }",
          "fixed_method": "  public static boolean containsAny(String cs, char[] searchChars) {\n  if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n  return false;\n  }\n  int csLength = cs.length();\n  int searchLength = searchChars.length;\n  int csLast = csLength - 1;\n  int searchLast = searchLength - 1;\n  for (int i = 0; i < csLength; i++) {\n  char ch = cs.charAt(i);\n  for (int j = 0; j < searchLength; j++) {\n  if (searchChars[j] == ch) {\n  if (Character.isHighSurrogate(ch)) {\n  if (j == searchLast) {\n  \n  return true;\n  }\n  if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) {\n  return true;\n  }\n  } else {\n  \n  return true;\n  }\n  }\n  }\n  }\n  return false;\n  }",
          "diff": [
            "@@ -1440,7 +1448,7 @@",
            "      * <code>false</code> if no match or null input\n",
            "      * @since 2.4\n",
            "      */\n",
            "-    public static boolean containsAny(CharSequence cs, char[] searchChars) {\n",
            "+    public static boolean containsAny(String cs, char[] searchChars) {\n",
            "         if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n",
            "             return false;\n",
            "         }\n",
            "@@ -1452,9 +1460,12 @@",
            "             char ch = cs.charAt(i);\n",
            "             for (int j = 0; j < searchLength; j++) {\n",
            "                 if (searchChars[j] == ch) {\n",
            "-                    if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n",
            "+                    if (Character.isHighSurrogate(ch)) {\n",
            "+                        if (j == searchLast) {\n",
            "                             // missing low surrogate, fine, like String.indexOf(String)\n",
            "-                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n",
            "+                            return true;\n",
            "+                        }\n",
            "+                        if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) {\n",
            "                             return true;\n",
            "                         }\n",
            "                     } else {\n"
          ],
          "changed_lines": 9
        },
        {
          "buggy_method": "  public static boolean containsAny(CharSequence cs, String searchChars) {\n  if (searchChars == null) {\n  return false;\n  }\n  return containsAny(cs, searchChars.toCharArray());\n  }",
          "fixed_method": "  public static boolean containsAny(String cs, String searchChars) {\n  if (searchChars == null) {\n  return false;\n  }\n  return containsAny(cs, searchChars.toCharArray());\n  }",
          "diff": [
            "@@ -1494,7 +1505,7 @@",
            "      * @return the <code>true</code> if any of the chars are found, <code>false</code> if no match or null input\n",
            "      * @since 2.4\n",
            "      */\n",
            "-    public static boolean containsAny(CharSequence cs, String searchChars) {\n",
            "+    public static boolean containsAny(String cs, String searchChars) {\n",
            "         if (searchChars == null) {\n",
            "             return false;\n",
            "         }\n"
          ],
          "changed_lines": 2
        },
        {
          "buggy_method": "  public static int indexOfAnyBut(CharSequence cs, char[] searchChars) {\n  if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n  return INDEX_NOT_FOUND;\n  }\n  int csLen = cs.length();\n  int searchLen = searchChars.length;\n  outer:\n  for (int i = 0; i < csLen; i++) {\n  char ch = cs.charAt(i);\n  for (int j = 0; j < searchLen; j++) {\n  if (searchChars[j] == ch) {\n  continue outer;\n  }\n  }\n  return i;\n  }\n  return INDEX_NOT_FOUND;\n  }",
          "fixed_method": "  public static int indexOfAnyBut(CharSequence cs, char[] searchChars) {\n  if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n  return INDEX_NOT_FOUND;\n  }\n  int csLen = cs.length();\n  int csLast = csLen - 1;\n  int searchLen = searchChars.length;\n  int searchLast = searchLen - 1;\n  outer:\n  for (int i = 0; i < csLen; i++) {\n  char ch = cs.charAt(i);\n  for (int j = 0; j < searchLen; j++) {\n  if (searchChars[j] == ch) {\n  if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) {\n  if (searchChars[j + 1] == cs.charAt(i + 1)) {\n  continue outer;\n  }\n  } else {\n  continue outer;\n  }\n  }\n  }\n  return i;\n  }\n  return INDEX_NOT_FOUND;\n  }",
          "diff": [
            "@@ -1530,13 +1541,21 @@",
            "             return INDEX_NOT_FOUND;\n",
            "         }\n",
            "         int csLen = cs.length();\n",
            "+        int csLast = csLen - 1;\n",
            "         int searchLen = searchChars.length;\n",
            "+        int searchLast = searchLen - 1;\n",
            "         outer:\n",
            "         for (int i = 0; i < csLen; i++) {\n",
            "             char ch = cs.charAt(i);\n",
            "             for (int j = 0; j < searchLen; j++) {\n",
            "                 if (searchChars[j] == ch) {\n",
            "+                    if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) {\n",
            "+                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n",
            "+                            continue outer;\n",
            "+                        }\n",
            "+                    } else {\n",
            "                         continue outer;\n",
            "+                    }\n",
            "                 }\n",
            "             }\n",
            "             return i;\n"
          ],
          "changed_lines": 8
        },
        {
          "buggy_method": "  public static int indexOfAnyBut(String str, String searchChars) {\n  if (isEmpty(str) || isEmpty(searchChars)) {\n  return INDEX_NOT_FOUND;\n  }\n  int strLen = str.length();\n  for (int i = 0; i < strLen; i++) {\n  char ch = str.charAt(i);\n  if (searchChars.indexOf(ch) < 0) {\n  return i;\n  }\n  }\n  return INDEX_NOT_FOUND;\n  }",
          "fixed_method": "  public static int indexOfAnyBut(String str, String searchChars) {\n  if (isEmpty(str) || isEmpty(searchChars)) {\n  return INDEX_NOT_FOUND;\n  }\n  int strLen = str.length();\n  for (int i = 0; i < strLen; i++) {\n  char ch = str.charAt(i);\n  boolean chFound = searchChars.indexOf(ch) >= 0;\n  if (i + 1 < strLen && Character.isHighSurrogate(ch)) {\n  char ch2 = str.charAt(i + 1);\n  if (chFound && searchChars.indexOf(ch2) < 0) {\n  return i;\n  }\n  } else {\n  if (!chFound) {\n  return i;\n  }\n  }\n  }\n  return INDEX_NOT_FOUND;\n  }",
          "diff": [
            "@@ -1573,8 +1592,16 @@",
            "         int strLen = str.length();\n",
            "         for (int i = 0; i < strLen; i++) {\n",
            "             char ch = str.charAt(i);\n",
            "-            if (searchChars.indexOf(ch) < 0) {\n",
            "+            boolean chFound = searchChars.indexOf(ch) >= 0;\n",
            "+            if (i + 1 < strLen && Character.isHighSurrogate(ch)) {\n",
            "+                char ch2 = str.charAt(i + 1);\n",
            "+                if (chFound && searchChars.indexOf(ch2) < 0) {\n",
            "                     return i;\n",
            "+                }\n",
            "+            } else {\n",
            "+                if (!chFound) {\n",
            "+                    return i;\n",
            "+                }\n",
            "             }\n",
            "         }\n",
            "         return INDEX_NOT_FOUND;\n"
          ],
          "changed_lines": 10
        },
        {
          "buggy_method": "  public static boolean containsNone(CharSequence cs, char[] searchChars) {\n  if (cs == null || searchChars == null) {\n  return true;\n  }\n  int csLen = cs.length();\n  int searchLen = searchChars.length;\n  for (int i = 0; i < csLen; i++) {\n  char ch = cs.charAt(i);\n  for (int j = 0; j < searchLen; j++) {\n  if (searchChars[j] == ch) {\n  \n  \n  return false;\n  }\n  }\n  }\n  return true;\n  }",
          "fixed_method": "  public static boolean containsNone(CharSequence cs, char[] searchChars) {\n  if (cs == null || searchChars == null) {\n  return true;\n  }\n  int csLen = cs.length();\n  int csLast = csLen - 1;\n  int searchLen = searchChars.length;\n  int searchLast = searchLen - 1;\n  for (int i = 0; i < csLen; i++) {\n  char ch = cs.charAt(i);\n  for (int j = 0; j < searchLen; j++) {\n  if (searchChars[j] == ch) {\n  if (Character.isHighSurrogate(ch)) {\n  if (j == searchLast) {\n  \n  return false;\n  }\n  if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) {\n  return false;\n  }\n  } else {\n  \n  return false;\n  }\n  }\n  }\n  }\n  return true;\n  }",
          "diff": [
            "@@ -1675,14 +1702,25 @@",
            "             return true;\n",
            "         }\n",
            "         int csLen = cs.length();\n",
            "+        int csLast = csLen - 1;\n",
            "         int searchLen = searchChars.length;\n",
            "+        int searchLast = searchLen - 1;\n",
            "         for (int i = 0; i < csLen; i++) {\n",
            "             char ch = cs.charAt(i);\n",
            "             for (int j = 0; j < searchLen; j++) {\n",
            "                 if (searchChars[j] == ch) {\n",
            "+                    if (Character.isHighSurrogate(ch)) {\n",
            "+                        if (j == searchLast) {\n",
            "                             // missing low surrogate, fine, like String.indexOf(String)\n",
            "+                            return false;\n",
            "+                        }\n",
            "+                        if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) {\n",
            "+                            return false;\n",
            "+                        }\n",
            "+                    } else {\n",
            "                         // ch is in the Basic Multilingual Plane\n",
            "                         return false;\n",
            "+                    }\n",
            "                 }\n",
            "             }\n",
            "         }\n"
          ],
          "changed_lines": 11
        }
      ]
    }
  ]
}
