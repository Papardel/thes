{
  "bug_id": "3",
  "failed_tests": {
    "com.google.javascript.jscomp.FlowSensitiveInlineVariablesTest": [
      {
        "methodName": "testDoNotInlineCatchExpression1a",
        "error": "junit.framework.AssertionFailedError:",
        "message": "",
        "fail_line": "    noInline(",
        "test_source": "  public void testDoNotInlineCatchExpression1a() {\n  noInline(\n  \"var a;\\n\" +\n  \"try {\\n\" +\n  \"  throw Error(\\\"\\\");\\n\" +\n  \"}catch(err) {\" +\n  \"  a = err + 1;\\n\" +\n  \"}\\n\" +\n  \"return a.stack\\n\");\n  }",
        "stack": [
          "CompilerTestCase.test line 905, CompilerTestCase.test line 447, CompilerTestCase.test line 411, CompilerTestCase.test line 389, FlowSensitiveInlineVariablesTest.inline line 571, FlowSensitiveInlineVariablesTest.noInline line 567, FlowSensitiveInlineVariablesTest.testDoNotInlineCatchExpression1a line 157"
        ]
      },
      {
        "methodName": "testDoNotInlineCatchExpression1",
        "error": "junit.framework.AssertionFailedError:",
        "message": "",
        "fail_line": "    noInline(",
        "test_source": "  public void testDoNotInlineCatchExpression1() {\n  noInline(\n  \"var a;\\n\" +\n  \"try {\\n\" +\n  \"  throw Error(\\\"\\\");\\n\" +\n  \"}catch(err) {\" +\n  \"  a = err;\\n\" +\n  \"}\\n\" +\n  \"return a.stack\\n\");\n  }",
        "stack": [
          "CompilerTestCase.test line 905, CompilerTestCase.test line 447, CompilerTestCase.test line 411, CompilerTestCase.test line 389, FlowSensitiveInlineVariablesTest.inline line 571, FlowSensitiveInlineVariablesTest.noInline line 567, FlowSensitiveInlineVariablesTest.testDoNotInlineCatchExpression1 line 146"
        ]
      },
      {
        "methodName": "testDoNotInlineCatchExpression3",
        "error": "junit.framework.AssertionFailedError:",
        "message": "",
        "fail_line": "    noInline(",
        "test_source": "  public void testDoNotInlineCatchExpression3() {\n  noInline(\n  \"var a;\\n\" +\n  \"try {\\n\" +\n  \"  throw Error(\\\"\\\");\\n\" +\n  \"} catch(err) {\" +\n  \"  err = x;\\n\" +\n  \"  a = err;\\n\" +\n  \"}\\n\" +\n  \"return a.stack\\n\");\n  }",
        "stack": [
          "CompilerTestCase.test line 905, CompilerTestCase.test line 447, CompilerTestCase.test line 411, CompilerTestCase.test line 389, FlowSensitiveInlineVariablesTest.inline line 571, FlowSensitiveInlineVariablesTest.noInline line 567, FlowSensitiveInlineVariablesTest.testDoNotInlineCatchExpression3 line 179"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "com/google/javascript/jscomp/FlowSensitiveInlineVariables.java",
      "buggy_full_code": "\n\npackage com.google.javascript.jscomp;\n\nimport com.google.common.base.Preconditions;\nimport com.google.common.base.Predicate;\nimport com.google.common.base.Predicates;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Sets;\nimport com.google.javascript.jscomp.ControlFlowGraph.AbstractCfgNodeTraversalCallback;\nimport com.google.javascript.jscomp.ControlFlowGraph.Branch;\nimport com.google.javascript.jscomp.DataFlowAnalysis.FlowState;\nimport com.google.javascript.jscomp.MustBeReachingVariableDef.Definition;\nimport com.google.javascript.jscomp.MustBeReachingVariableDef.MustDef;\nimport com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\nimport com.google.javascript.jscomp.NodeTraversal.AbstractShallowCallback;\nimport com.google.javascript.jscomp.NodeTraversal.ScopedCallback;\nimport com.google.javascript.jscomp.Scope.Var;\nimport com.google.javascript.jscomp.graph.DiGraph.DiGraphEdge;\nimport com.google.javascript.jscomp.graph.DiGraph.DiGraphNode;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.Token;\n\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Set;\n\n\nclass FlowSensitiveInlineVariables extends AbstractPostOrderCallback\n    implements CompilerPass, ScopedCallback {\n\n  \n  private final AbstractCompiler compiler; private final Set<Var> inlinedNewDependencies = Sets.newHashSet(); private ControlFlowGraph<Node> cfg; private List<Candidate> candidates; private MustBeReachingVariableDef reachingDef; private MaybeReachingVariableUse reachingUses; private static final Predicate<Node> SIDE_EFFECT_PREDICATE = new Predicate<Node>() {\n      @Override\n      public boolean apply(Node n) {\n        \n        \n        if (n == null) {\n          return false;\n        }\n\n        \n        \n        \n        if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) {\n          return true;\n        }\n\n        if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) {\n          return true;\n        }\n\n        if (n.isDelProp()) {\n          return true;\n        }\n\n        for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n          if (!ControlFlowGraph.isEnteringNewCfgNode(c) && apply(c)) {\n            return true;\n          }\n        }\n        return false;\n      }\n  };\n\n  public FlowSensitiveInlineVariables(AbstractCompiler compiler) {\n    this.compiler = compiler;\n  }\n\n  @Override\n  public void enterScope(NodeTraversal t) {\n\n    if (t.inGlobalScope()) {\n      return; \n    }\n\n    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE <\n        t.getScope().getVarCount()) {\n      return;\n    }\n\n    \n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n    \n    Preconditions.checkState(t.getScopeRoot().isFunction());\n    cfa.process(null, t.getScopeRoot().getLastChild());\n    cfg = cfa.getCfg();\n    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n    reachingDef.analyze();\n    candidates = Lists.newLinkedList();\n\n    \n    \n    new NodeTraversal(compiler, new GatherCandiates()).traverse(\n        t.getScopeRoot().getLastChild());\n\n    \n    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n    reachingUses.analyze();\n    for (Candidate c : candidates) {\n      if (c.canInline()) {\n        c.inlineVariable();\n\n        \n        \n        \n        \n        \n        \n        \n        if (!c.defMetadata.depends.isEmpty()) {\n          inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n        }\n      }\n    }\n  }\n\n  @Override\n  public void exitScope(NodeTraversal t) {}\n\n  @Override\n  public void process(Node externs, Node root) {\n    (new NodeTraversal(compiler, this)).traverseRoots(externs, root);\n  }\n\n  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    \n    \n    \n    \n    \n  }\n\n  \n  private class GatherCandiates extends AbstractShallowCallback { @Override public void visit(NodeTraversal t, Node n, Node parent) {\n      DiGraphNode<Node, Branch> graphNode = cfg.getDirectedGraphNode(n);\n      if (graphNode == null) {\n        \n        return;\n      }\n      FlowState<MustDef> state = graphNode.getAnnotation();\n      final MustDef defs = state.getIn();\n      final Node cfgNode = n;\n      AbstractCfgNodeTraversalCallback gatherCb =\n          new AbstractCfgNodeTraversalCallback() {\n\n        @Override\n        public void visit(NodeTraversal t, Node n, Node parent) {\n          if (n.isName()) {\n\n            \n            \n            if (parent == null) {\n              return;\n            }\n\n            \n            if ((NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == n)\n                || parent.isVar() || parent.isInc() || parent.isDec() ||\n                parent.isParamList() || parent.isCatch()) {\n              return;\n            }\n\n            String name = n.getString();\n            if (compiler.getCodingConvention().isExported(name)) {\n              return;\n            }\n\n            Definition def = reachingDef.getDef(name, cfgNode);\n            \n            \n            if (def != null &&\n                !reachingDef.dependsOnOuterScopeVars(def)) {\n              candidates.add(new Candidate(name, def, n, cfgNode));\n            }\n          }\n        }\n      };\n\n      NodeTraversal.traverse(compiler, cfgNode, gatherCb);\n    }\n  }\n\n  \n  private class Candidate { private final String varName; private Node def; private final Definition defMetadata; private final Node use; private final Node useCfgNode; private int numUseWithinUseCfgNode; Candidate(String varName, Definition defMetadata, Node use, Node useCfgNode) {\n      Preconditions.checkArgument(use.isName());\n      this.varName = varName;\n      this.defMetadata = defMetadata;\n      this.use = use;\n      this.useCfgNode = useCfgNode;\n    }\n\n    private Node getDefCfgNode() {\n      return defMetadata.node;\n    }\n\n    private boolean canInline() {\n      \n      if (getDefCfgNode().isFunction()) {\n        return false;\n      }\n\n      \n      \n      \n      for (Var dependency : defMetadata.depends) {\n        if (inlinedNewDependencies.contains(dependency)) {\n          return false;\n        }\n      }\n\n      getDefinition(getDefCfgNode(), null);\n      getNumUseInUseCfgNode(useCfgNode, null);\n\n      \n      if (def == null) {\n        return false;\n      }\n\n      \n      \n      if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) {\n        return false;\n      }\n\n      \n      \n      \n      if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) {\n        return false;\n      }\n\n      \n      \n      \n      if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) {\n        return false;\n      }\n\n      \n      \n      \n      if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) {\n        return false;\n      }\n\n      \n\n      \n      \n      \n      if (numUseWithinUseCfgNode != 1) {\n        return false;\n      }\n\n      \n      if (NodeUtil.isWithinLoop(use)) {\n        return false;\n      }\n\n\n      Collection<Node> uses = reachingUses.getUses(varName, getDefCfgNode());\n\n      if (uses.size() != 1) {\n        return false;\n      }\n\n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      if (NodeUtil.has(def.getLastChild(),\n          new Predicate<Node>() {\n              @Override\n              public boolean apply(Node input) {\n                switch (input.getType()) {\n                  case Token.GETELEM:\n                  case Token.GETPROP:\n                  case Token.ARRAYLIT:\n                  case Token.OBJECTLIT:\n                  case Token.REGEXP:\n                  case Token.NEW:\n                    return true;\n                }\n                return false;\n              }\n          },\n          new Predicate<Node>() {\n              @Override\n              public boolean apply(Node input) {\n                \n                return !input.isFunction();\n              }\n          })) {\n        return false;\n      }\n\n      \n      \n      if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) &&\n          getDefCfgNode().getNext() != useCfgNode) {\n        \n        \n        \n        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>\n          pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(\n                 cfg,\n                 cfg.getDirectedGraphNode(getDefCfgNode()),\n                 cfg.getDirectedGraphNode(useCfgNode),\n                 SIDE_EFFECT_PREDICATE,\n                 Predicates.\n                     <DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(),\n                 false);\n        if (pathCheck.somePathsSatisfyPredicate()) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    \n    private void inlineVariable() {\n      Node defParent = def.getParent();\n      Node useParent = use.getParent();\n      if (def.isAssign()) {\n        Node rhs = def.getLastChild();\n        rhs.detachFromParent();\n        \n        Preconditions.checkState(defParent.isExprResult());\n        while (defParent.getParent().isLabel()) {\n          defParent = defParent.getParent();\n        }\n        defParent.detachFromParent();\n        useParent.replaceChild(use, rhs);\n      } else if (defParent.isVar()) {\n        Node rhs = def.getLastChild();\n        def.removeChild(rhs);\n        useParent.replaceChild(use, rhs);\n      } else {\n        Preconditions.checkState(false, \"No other definitions can be inlined.\");\n      }\n      compiler.reportCodeChange();\n    }\n\n    \n    private void getDefinition(Node n, Node parent) {\n      AbstractCfgNodeTraversalCallback gatherCb =\n        new AbstractCfgNodeTraversalCallback() {\n\n        @Override\n        public void visit(NodeTraversal t, Node n, Node parent) {\n          switch (n.getType()) {\n            case Token.NAME:\n              if (n.getString().equals(varName) && n.hasChildren()) {\n                def = n;\n              }\n              return;\n\n            case Token.ASSIGN:\n              Node lhs = n.getFirstChild();\n              if (lhs.isName() && lhs.getString().equals(varName)) {\n                def = n;\n              }\n              return;\n          }\n        }\n      };\n      NodeTraversal.traverse(compiler, n, gatherCb);\n    }\n\n    \n    private void getNumUseInUseCfgNode(Node n, Node parant) {\n\n      AbstractCfgNodeTraversalCallback gatherCb =\n          new AbstractCfgNodeTraversalCallback() {\n\n        @Override\n        public void visit(NodeTraversal t, Node n, Node parent) {\n          if (n.isName() && n.getString().equals(varName) &&\n              \n              !(parent.isAssign() &&\n               (parent.getFirstChild() == n))) {\n            numUseWithinUseCfgNode++;\n          }\n        }\n      };\n\n      NodeTraversal.traverse(compiler, n, gatherCb);\n    }\n  }\n\n  \n  private static boolean checkRightOf( Node n, Node expressionRoot, Predicate<Node> predicate) {\n    for (Node p = n; p != expressionRoot; p = p.getParent()) {\n      for (Node cur = p.getNext(); cur != null; cur = cur.getNext()) {\n        if (predicate.apply(cur)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  \n  private static boolean checkLeftOf( Node n, Node expressionRoot, Predicate<Node> predicate) {\n    for (Node p = n.getParent(); p != expressionRoot; p = p.getParent()) {\n      for (Node cur = p.getParent().getFirstChild(); cur != p;\n          cur = cur.getNext()) {\n        if (predicate.apply(cur)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n}\n",
      "fixed_full_code": "\n\npackage com.google.javascript.jscomp;\n\nimport com.google.common.base.Preconditions;\nimport com.google.common.base.Predicate;\nimport com.google.common.base.Predicates;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Sets;\nimport com.google.javascript.jscomp.ControlFlowGraph.AbstractCfgNodeTraversalCallback;\nimport com.google.javascript.jscomp.ControlFlowGraph.Branch;\nimport com.google.javascript.jscomp.DataFlowAnalysis.FlowState;\nimport com.google.javascript.jscomp.MustBeReachingVariableDef.Definition;\nimport com.google.javascript.jscomp.MustBeReachingVariableDef.MustDef;\nimport com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\nimport com.google.javascript.jscomp.NodeTraversal.AbstractShallowCallback;\nimport com.google.javascript.jscomp.NodeTraversal.ScopedCallback;\nimport com.google.javascript.jscomp.Scope.Var;\nimport com.google.javascript.jscomp.graph.DiGraph.DiGraphEdge;\nimport com.google.javascript.jscomp.graph.DiGraph.DiGraphNode;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.Token;\n\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Set;\n\n\nclass FlowSensitiveInlineVariables extends AbstractPostOrderCallback\n    implements CompilerPass, ScopedCallback {\n\n  \n  private final AbstractCompiler compiler; private final Set<Var> inlinedNewDependencies = Sets.newHashSet(); private ControlFlowGraph<Node> cfg; private List<Candidate> candidates; private MustBeReachingVariableDef reachingDef; private MaybeReachingVariableUse reachingUses; private static final Predicate<Node> SIDE_EFFECT_PREDICATE = new Predicate<Node>() {\n      @Override\n      public boolean apply(Node n) {\n        \n        \n        if (n == null) {\n          return false;\n        }\n\n        \n        \n        \n        if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) {\n          return true;\n        }\n\n        if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) {\n          return true;\n        }\n\n        if (n.isDelProp()) {\n          return true;\n        }\n\n        for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n          if (!ControlFlowGraph.isEnteringNewCfgNode(c) && apply(c)) {\n            return true;\n          }\n        }\n        return false;\n      }\n  };\n\n  public FlowSensitiveInlineVariables(AbstractCompiler compiler) {\n    this.compiler = compiler;\n  }\n\n  @Override\n  public void enterScope(NodeTraversal t) {\n\n    if (t.inGlobalScope()) {\n      return; \n    }\n\n    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE <\n        t.getScope().getVarCount()) {\n      return;\n    }\n\n    \n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n    \n    Preconditions.checkState(t.getScopeRoot().isFunction());\n    cfa.process(null, t.getScopeRoot().getLastChild());\n    cfg = cfa.getCfg();\n    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n    reachingDef.analyze();\n    candidates = Lists.newLinkedList();\n\n    \n    \n    new NodeTraversal(compiler, new GatherCandiates()).traverse(\n        t.getScopeRoot().getLastChild());\n\n    \n    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n    reachingUses.analyze();\n    for (Candidate c : candidates) {\n      if (c.canInline(t.getScope())) {\n        c.inlineVariable();\n\n        \n        \n        \n        \n        \n        \n        \n        if (!c.defMetadata.depends.isEmpty()) {\n          inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n        }\n      }\n    }\n  }\n\n  @Override\n  public void exitScope(NodeTraversal t) {}\n\n  @Override\n  public void process(Node externs, Node root) {\n    (new NodeTraversal(compiler, this)).traverseRoots(externs, root);\n  }\n\n  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    \n    \n    \n    \n    \n  }\n\n  \n  private class GatherCandiates extends AbstractShallowCallback { @Override public void visit(NodeTraversal t, Node n, Node parent) {\n      DiGraphNode<Node, Branch> graphNode = cfg.getDirectedGraphNode(n);\n      if (graphNode == null) {\n        \n        return;\n      }\n      FlowState<MustDef> state = graphNode.getAnnotation();\n      final MustDef defs = state.getIn();\n      final Node cfgNode = n;\n      AbstractCfgNodeTraversalCallback gatherCb =\n          new AbstractCfgNodeTraversalCallback() {\n\n        @Override\n        public void visit(NodeTraversal t, Node n, Node parent) {\n          if (n.isName()) {\n\n            \n            \n            if (parent == null) {\n              return;\n            }\n\n            \n            if ((NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == n)\n                || parent.isVar() || parent.isInc() || parent.isDec() ||\n                parent.isParamList() || parent.isCatch()) {\n              return;\n            }\n\n            String name = n.getString();\n            if (compiler.getCodingConvention().isExported(name)) {\n              return;\n            }\n\n            Definition def = reachingDef.getDef(name, cfgNode);\n            \n            \n            if (def != null &&\n                !reachingDef.dependsOnOuterScopeVars(def)) {\n              candidates.add(new Candidate(name, def, n, cfgNode));\n            }\n          }\n        }\n      };\n\n      NodeTraversal.traverse(compiler, cfgNode, gatherCb);\n    }\n  }\n\n  \n  private class Candidate { private final String varName; private Node def; private final Definition defMetadata; private final Node use; private final Node useCfgNode; private int numUseWithinUseCfgNode; Candidate(String varName, Definition defMetadata, Node use, Node useCfgNode) {\n      Preconditions.checkArgument(use.isName());\n      this.varName = varName;\n      this.defMetadata = defMetadata;\n      this.use = use;\n      this.useCfgNode = useCfgNode;\n    }\n\n    private Node getDefCfgNode() {\n      return defMetadata.node;\n    }\n\n    private boolean canInline(final Scope scope) {\n      \n      if (getDefCfgNode().isFunction()) {\n        return false;\n      }\n\n      \n      \n      \n      for (Var dependency : defMetadata.depends) {\n        if (inlinedNewDependencies.contains(dependency)) {\n          return false;\n        }\n      }\n\n      getDefinition(getDefCfgNode(), null);\n      getNumUseInUseCfgNode(useCfgNode, null);\n\n      \n      if (def == null) {\n        return false;\n      }\n\n      \n      \n      if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) {\n        return false;\n      }\n\n      \n      \n      \n      if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) {\n        return false;\n      }\n\n      \n      \n      \n      if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) {\n        return false;\n      }\n\n      \n      \n      \n      if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) {\n        return false;\n      }\n\n      \n\n      \n      \n      \n      if (numUseWithinUseCfgNode != 1) {\n        return false;\n      }\n\n      \n      if (NodeUtil.isWithinLoop(use)) {\n        return false;\n      }\n\n\n      Collection<Node> uses = reachingUses.getUses(varName, getDefCfgNode());\n\n      if (uses.size() != 1) {\n        return false;\n      }\n\n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      if (NodeUtil.has(def.getLastChild(),\n          new Predicate<Node>() {\n              @Override\n              public boolean apply(Node input) {\n                switch (input.getType()) {\n                  case Token.GETELEM:\n                  case Token.GETPROP:\n                  case Token.ARRAYLIT:\n                  case Token.OBJECTLIT:\n                  case Token.REGEXP:\n                  case Token.NEW:\n                    return true;\n                  case Token.NAME:\n                    Var var = scope.getOwnSlot(input.getString());\n                    if (var != null\n                        && var.getParentNode().isCatch()) {\n                      return true;\n                    }\n                }\n                return false;\n              }\n          },\n          new Predicate<Node>() {\n              @Override\n              public boolean apply(Node input) {\n                \n                return !input.isFunction();\n              }\n          })) {\n        return false;\n      }\n\n      \n      \n      if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) &&\n          getDefCfgNode().getNext() != useCfgNode) {\n        \n        \n        \n        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>\n          pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(\n                 cfg,\n                 cfg.getDirectedGraphNode(getDefCfgNode()),\n                 cfg.getDirectedGraphNode(useCfgNode),\n                 SIDE_EFFECT_PREDICATE,\n                 Predicates.\n                     <DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(),\n                 false);\n        if (pathCheck.somePathsSatisfyPredicate()) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    \n    private void inlineVariable() {\n      Node defParent = def.getParent();\n      Node useParent = use.getParent();\n      if (def.isAssign()) {\n        Node rhs = def.getLastChild();\n        rhs.detachFromParent();\n        \n        Preconditions.checkState(defParent.isExprResult());\n        while (defParent.getParent().isLabel()) {\n          defParent = defParent.getParent();\n        }\n        defParent.detachFromParent();\n        useParent.replaceChild(use, rhs);\n      } else if (defParent.isVar()) {\n        Node rhs = def.getLastChild();\n        def.removeChild(rhs);\n        useParent.replaceChild(use, rhs);\n      } else {\n        Preconditions.checkState(false, \"No other definitions can be inlined.\");\n      }\n      compiler.reportCodeChange();\n    }\n\n    \n    private void getDefinition(Node n, Node parent) {\n      AbstractCfgNodeTraversalCallback gatherCb =\n        new AbstractCfgNodeTraversalCallback() {\n\n        @Override\n        public void visit(NodeTraversal t, Node n, Node parent) {\n          switch (n.getType()) {\n            case Token.NAME:\n              if (n.getString().equals(varName) && n.hasChildren()) {\n                def = n;\n              }\n              return;\n\n            case Token.ASSIGN:\n              Node lhs = n.getFirstChild();\n              if (lhs.isName() && lhs.getString().equals(varName)) {\n                def = n;\n              }\n              return;\n          }\n        }\n      };\n      NodeTraversal.traverse(compiler, n, gatherCb);\n    }\n\n    \n    private void getNumUseInUseCfgNode(Node n, Node parant) {\n\n      AbstractCfgNodeTraversalCallback gatherCb =\n          new AbstractCfgNodeTraversalCallback() {\n\n        @Override\n        public void visit(NodeTraversal t, Node n, Node parent) {\n          if (n.isName() && n.getString().equals(varName) &&\n              \n              !(parent.isAssign() &&\n               (parent.getFirstChild() == n))) {\n            numUseWithinUseCfgNode++;\n          }\n        }\n      };\n\n      NodeTraversal.traverse(compiler, n, gatherCb);\n    }\n  }\n\n  \n  private static boolean checkRightOf( Node n, Node expressionRoot, Predicate<Node> predicate) {\n    for (Node p = n; p != expressionRoot; p = p.getParent()) {\n      for (Node cur = p.getNext(); cur != null; cur = cur.getNext()) {\n        if (predicate.apply(cur)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  \n  private static boolean checkLeftOf( Node n, Node expressionRoot, Predicate<Node> predicate) {\n    for (Node p = n.getParent(); p != expressionRoot; p = p.getParent()) {\n      for (Node cur = p.getParent().getFirstChild(); cur != p;\n          cur = cur.getNext()) {\n        if (predicate.apply(cur)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n}\n",
      "buggy_signatures": [
        "public boolean apply(Node n)",
        "public FlowSensitiveInlineVariables(AbstractCompiler compiler)",
        "public void enterScope(NodeTraversal t)",
        "public void exitScope(NodeTraversal t)",
        "public void process(Node externs, Node root)",
        "public void visit(NodeTraversal t, Node n, Node parent)",
        "private class GatherCandiates extends AbstractShallowCallback { @Override public void visit(NodeTraversal t, Node n, Node parent)",
        "public void visit(NodeTraversal t, Node n, Node parent)",
        "private class Candidate { private final String varName; private Node def; private final Definition defMetadata; private final Node use; private final Node useCfgNode; private int numUseWithinUseCfgNode; Candidate(String varName, Definition defMetadata, Node use, Node useCfgNode)",
        "private Node getDefCfgNode()",
        "private boolean canInline()",
        "public boolean apply(Node input)",
        "public boolean apply(Node input)",
        "private void inlineVariable()",
        "private void getDefinition(Node n, Node parent)",
        "public void visit(NodeTraversal t, Node n, Node parent)",
        "private void getNumUseInUseCfgNode(Node n, Node parant)",
        "public void visit(NodeTraversal t, Node n, Node parent)",
        "private static boolean checkRightOf( Node n, Node expressionRoot, Predicate<Node> predicate)",
        "private static boolean checkLeftOf( Node n, Node expressionRoot, Predicate<Node> predicate)"
      ],
      "fixed_signatures": [
        "public boolean apply(Node n)",
        "public FlowSensitiveInlineVariables(AbstractCompiler compiler)",
        "public void enterScope(NodeTraversal t)",
        "public void exitScope(NodeTraversal t)",
        "public void process(Node externs, Node root)",
        "public void visit(NodeTraversal t, Node n, Node parent)",
        "private class GatherCandiates extends AbstractShallowCallback { @Override public void visit(NodeTraversal t, Node n, Node parent)",
        "public void visit(NodeTraversal t, Node n, Node parent)",
        "private class Candidate { private final String varName; private Node def; private final Definition defMetadata; private final Node use; private final Node useCfgNode; private int numUseWithinUseCfgNode; Candidate(String varName, Definition defMetadata, Node use, Node useCfgNode)",
        "private Node getDefCfgNode()",
        "private boolean canInline(final Scope scope)",
        "public boolean apply(Node input)",
        "public boolean apply(Node input)",
        "private void inlineVariable()",
        "private void getDefinition(Node n, Node parent)",
        "public void visit(NodeTraversal t, Node n, Node parent)",
        "private void getNumUseInUseCfgNode(Node n, Node parant)",
        "public void visit(NodeTraversal t, Node n, Node parent)",
        "private static boolean checkRightOf( Node n, Node expressionRoot, Predicate<Node> predicate)",
        "private static boolean checkLeftOf( Node n, Node expressionRoot, Predicate<Node> predicate)"
      ],
      "methods": [
        {
          "buggy_method": "  public void enterScope(NodeTraversal t) {\n\n  if (t.inGlobalScope()) {\n  return; \n  }\n\n  if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE <\n  t.getScope().getVarCount()) {\n  return;\n  }\n\n  \n  ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n  \n  Preconditions.checkState(t.getScopeRoot().isFunction());\n  cfa.process(null, t.getScopeRoot().getLastChild());\n  cfg = cfa.getCfg();\n  reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n  reachingDef.analyze();\n  candidates = Lists.newLinkedList();\n\n  \n  \n  new NodeTraversal(compiler, new GatherCandiates()).traverse(\n  t.getScopeRoot().getLastChild());\n\n  \n  reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n  reachingUses.analyze();\n  for (Candidate c : candidates) {\n  if (c.canInline()) {\n  c.inlineVariable();\n\n  \n  \n  \n  \n  \n  \n  \n  if (!c.defMetadata.depends.isEmpty()) {\n  inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n  }\n  }\n  }\n  }",
          "fixed_method": "  public void enterScope(NodeTraversal t) {\n\n  if (t.inGlobalScope()) {\n  return; \n  }\n\n  if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE <\n  t.getScope().getVarCount()) {\n  return;\n  }\n\n  \n  ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n  \n  Preconditions.checkState(t.getScopeRoot().isFunction());\n  cfa.process(null, t.getScopeRoot().getLastChild());\n  cfg = cfa.getCfg();\n  reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n  reachingDef.analyze();\n  candidates = Lists.newLinkedList();\n\n  \n  \n  new NodeTraversal(compiler, new GatherCandiates()).traverse(\n  t.getScopeRoot().getLastChild());\n\n  \n  reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n  reachingUses.analyze();\n  for (Candidate c : candidates) {\n  if (c.canInline(t.getScope())) {\n  c.inlineVariable();\n\n  \n  \n  \n  \n  \n  \n  \n  if (!c.defMetadata.depends.isEmpty()) {\n  inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n  }\n  }\n  }\n  }",
          "diff": [
            "@@ -152,7 +152,7 @@",
            "     reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n",
            "     reachingUses.analyze();\n",
            "     for (Candidate c : candidates) {\n",
            "-      if (c.canInline()) {\n",
            "+      if (c.canInline(t.getScope())) {\n",
            "         c.inlineVariable();\n",
            " \n",
            "         // If definition c has dependencies, then inlining it may have\n"
          ],
          "changed_lines": 2
        },
        {
          "buggy_method": "  private boolean canInline() {\n  \n  if (getDefCfgNode().isFunction()) {\n  return false;\n  }\n\n  \n  \n  \n  for (Var dependency : defMetadata.depends) {\n  if (inlinedNewDependencies.contains(dependency)) {\n  return false;\n  }\n  }\n\n  getDefinition(getDefCfgNode(), null);\n  getNumUseInUseCfgNode(useCfgNode, null);\n\n  \n  if (def == null) {\n  return false;\n  }\n\n  \n  \n  if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) {\n  return false;\n  }\n\n  \n  \n  \n  if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) {\n  return false;\n  }\n\n  \n  \n  \n  if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) {\n  return false;\n  }\n\n  \n  \n  \n  if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) {\n  return false;\n  }\n\n  \n\n  \n  \n  \n  if (numUseWithinUseCfgNode != 1) {\n  return false;\n  }\n\n  \n  if (NodeUtil.isWithinLoop(use)) {\n  return false;\n  }\n\n\n  Collection<Node> uses = reachingUses.getUses(varName, getDefCfgNode());\n\n  if (uses.size() != 1) {\n  return false;\n  }\n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if (NodeUtil.has(def.getLastChild(),\n  new Predicate<Node>() {\n  @Override\n  public boolean apply(Node input) {\n  switch (input.getType()) {\n  case Token.GETELEM:\n  case Token.GETPROP:\n  case Token.ARRAYLIT:\n  case Token.OBJECTLIT:\n  case Token.REGEXP:\n  case Token.NEW:\n  return true;\n  }\n  return false;\n  }\n  },\n  new Predicate<Node>() {\n  @Override\n  public boolean apply(Node input) {\n  \n  return !input.isFunction();\n  }\n  })) {\n  return false;\n  }\n\n  \n  \n  if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) &&\n  getDefCfgNode().getNext() != useCfgNode) {\n  \n  \n  \n  CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>\n  pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(\n  cfg,\n  cfg.getDirectedGraphNode(getDefCfgNode()),\n  cfg.getDirectedGraphNode(useCfgNode),\n  SIDE_EFFECT_PREDICATE,\n  Predicates.\n  <DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(),\n  false);\n  if (pathCheck.somePathsSatisfyPredicate()) {\n  return false;\n  }\n  }\n\n  return true;\n  }",
          "fixed_method": "  private boolean canInline(final Scope scope) {\n  \n  if (getDefCfgNode().isFunction()) {\n  return false;\n  }\n\n  \n  \n  \n  for (Var dependency : defMetadata.depends) {\n  if (inlinedNewDependencies.contains(dependency)) {\n  return false;\n  }\n  }\n\n  getDefinition(getDefCfgNode(), null);\n  getNumUseInUseCfgNode(useCfgNode, null);\n\n  \n  if (def == null) {\n  return false;\n  }\n\n  \n  \n  if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) {\n  return false;\n  }\n\n  \n  \n  \n  if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) {\n  return false;\n  }\n\n  \n  \n  \n  if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) {\n  return false;\n  }\n\n  \n  \n  \n  if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) {\n  return false;\n  }\n\n  \n\n  \n  \n  \n  if (numUseWithinUseCfgNode != 1) {\n  return false;\n  }\n\n  \n  if (NodeUtil.isWithinLoop(use)) {\n  return false;\n  }\n\n\n  Collection<Node> uses = reachingUses.getUses(varName, getDefCfgNode());\n\n  if (uses.size() != 1) {\n  return false;\n  }\n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if (NodeUtil.has(def.getLastChild(),\n  new Predicate<Node>() {\n  @Override\n  public boolean apply(Node input) {\n  switch (input.getType()) {\n  case Token.GETELEM:\n  case Token.GETPROP:\n  case Token.ARRAYLIT:\n  case Token.OBJECTLIT:\n  case Token.REGEXP:\n  case Token.NEW:\n  return true;\n  case Token.NAME:\n  Var var = scope.getOwnSlot(input.getString());\n  if (var != null\n  && var.getParentNode().isCatch()) {\n  return true;\n  }\n  }\n  return false;\n  }\n  },\n  new Predicate<Node>() {\n  @Override\n  public boolean apply(Node input) {\n  \n  return !input.isFunction();\n  }\n  })) {\n  return false;\n  }\n\n  \n  \n  if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) &&\n  getDefCfgNode().getNext() != useCfgNode) {\n  \n  \n  \n  CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>\n  pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(\n  cfg,\n  cfg.getDirectedGraphNode(getDefCfgNode()),\n  cfg.getDirectedGraphNode(useCfgNode),\n  SIDE_EFFECT_PREDICATE,\n  Predicates.\n  <DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(),\n  false);\n  if (pathCheck.somePathsSatisfyPredicate()) {\n  return false;\n  }\n  }\n\n  return true;\n  }",
          "diff": [
            "@@ -277,7 +277,7 @@",
            "       return defMetadata.node;\n",
            "     }\n",
            " \n",
            "-    private boolean canInline() {\n",
            "+    private boolean canInline(final Scope scope) {\n",
            "       // Cannot inline a parameter.\n",
            "       if (getDefCfgNode().isFunction()) {\n",
            "         return false;\n"
          ],
          "changed_lines": 2
        },
        {
          "buggy_method": "  public boolean apply(Node input) {\n  switch (input.getType()) {\n  case Token.GETELEM:\n  case Token.GETPROP:\n  case Token.ARRAYLIT:\n  case Token.OBJECTLIT:\n  case Token.REGEXP:\n  case Token.NEW:\n  return true;\n  }\n  return false;\n  }",
          "fixed_method": "  public boolean apply(Node input) {\n  switch (input.getType()) {\n  case Token.GETELEM:\n  case Token.GETPROP:\n  case Token.ARRAYLIT:\n  case Token.OBJECTLIT:\n  case Token.REGEXP:\n  case Token.NEW:\n  return true;\n  case Token.NAME:\n  Var var = scope.getOwnSlot(input.getString());\n  if (var != null\n  && var.getParentNode().isCatch()) {\n  return true;\n  }\n  }\n  return false;\n  }",
          "diff": [
            "@@ -372,6 +372,12 @@",
            "                   case Token.REGEXP:\n",
            "                   case Token.NEW:\n",
            "                     return true;\n",
            "+                  case Token.NAME:\n",
            "+                    Var var = scope.getOwnSlot(input.getString());\n",
            "+                    if (var != null\n",
            "+                        && var.getParentNode().isCatch()) {\n",
            "+                      return true;\n",
            "+                    }\n",
            "                 }\n",
            "                 return false;\n",
            "               }\n"
          ],
          "changed_lines": 6
        }
      ]
    }
  ]
}
