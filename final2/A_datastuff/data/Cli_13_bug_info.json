{
  "bug_id": "13",
  "failed_tests": {
    "org.apache.commons.cli2.bug.BugLoopingOptionLookAlikeTest": [
      {
        "methodName": "testLoopingOptionLookAlike2",
        "error": "junit.framework.ComparisonFailure",
        "message": "expected:<Unexpected [testfile.txt while processing ]> but was:<Unexpected [value \"testfile.txt\" found while processing  input]>",
        "fail_line": "            assertEquals(\"Unexpected testfile.txt while processing \", e.getMessage());",
        "test_source": "  public void testLoopingOptionLookAlike2() {\n  final ArgumentBuilder abuilder = new ArgumentBuilder();\n  final GroupBuilder gbuilder = new GroupBuilder();\n  final Argument inputfile_opt = abuilder.withName(\"input\").withMinimum(1).withMaximum(1).create();\n  final Argument outputfile_opt = abuilder.withName(\"output\").withMinimum(1).withMaximum(1).create();\n  final Argument targets = new SourceDestArgument(inputfile_opt, outputfile_opt);\n  final Group options = gbuilder.withOption(targets).create();\n  final Parser parser = new Parser();\n  parser.setGroup(options);\n  try {\n  parser.parse(new String[] { \"testfile.txt\", \"testfile.txt\", \"testfile.txt\", \"testfile.txt\" });\n  fail(\"OptionException\");\n  } catch (OptionException e) {\n  assertEquals(\"Unexpected testfile.txt while processing \", e.getMessage());\n  }\n  }  ",
        "stack": [
          "BugLoopingOptionLookAlikeTest.testLoopingOptionLookAlike2 line 76"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/cli2/WriteableCommandLine.java",
      "buggy_full_code": "\npackage org.apache.commons.cli2;\n\nimport java.util.List;\n\n\npublic interface WriteableCommandLine extends CommandLine {\n\n    \n    void addOption(final Option option);\n\n    \n    void addValue(final Option option, final Object value);\n\n    \n\n    \n    void setDefaultValues(final Option option, final List defaultValues);\n\n    \n    void addSwitch(final Option option, final boolean value) throws IllegalStateException;\n\n    \n    void setDefaultSwitch(final Option option, final Boolean defaultSwitch);\n\n    \n    void addProperty(final String property, final String value);\n\n    \n    boolean looksLikeOption(final String argument);\n}\n",
      "fixed_full_code": "\npackage org.apache.commons.cli2;\n\nimport java.util.List;\n\n\npublic interface WriteableCommandLine extends CommandLine {\n\n    \n    void addOption(final Option option);\n\n    \n    void addValue(final Option option, final Object value);\n\n    \n    List getUndefaultedValues(final Option option);\n\n    \n    void setDefaultValues(final Option option, final List defaultValues);\n\n    \n    void addSwitch(final Option option, final boolean value) throws IllegalStateException;\n\n    \n    void setDefaultSwitch(final Option option, final Boolean defaultSwitch);\n\n    \n    void addProperty(final String property, final String value);\n\n    \n    boolean looksLikeOption(final String argument);\n}\n",
      "buggy_signatures": [],
      "fixed_signatures": [],
      "methods": [
        {
          "buggy_method": "",
          "fixed_method": "",
          "diff": [
            "@@ -44,6 +44,7 @@",
            "      * @param option the Option associated with the values\n",
            "      * @return a list of values or an empty List if none are found\n",
            "      */\n",
            "+    List getUndefaultedValues(final Option option);\n",
            " \n",
            "     /**\n",
            "      * Sets the default values for an Option in the CommandLine\n"
          ],
          "changed_lines": 1
        }
      ]
    },
    {
      "name": "org/apache/commons/cli2/commandline/WriteableCommandLineImpl.java",
      "buggy_full_code": "\npackage org.apache.commons.cli2.commandline;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Set;\n\nimport org.apache.commons.cli2.Argument;\nimport org.apache.commons.cli2.Option;\nimport org.apache.commons.cli2.WriteableCommandLine;\nimport org.apache.commons.cli2.resource.ResourceConstants;\nimport org.apache.commons.cli2.resource.ResourceHelper;\n\n\npublic class WriteableCommandLineImpl extends CommandLineImpl implements WriteableCommandLine { private final Properties properties = new Properties(); private final List options = new ArrayList(); private final Map nameToOption = new HashMap(); private final Map values = new HashMap(); private final Map switches = new HashMap(); private final Map defaultValues = new HashMap(); private final Map defaultSwitches = new HashMap(); private final List normalised; private final Set prefixes; public WriteableCommandLineImpl(final Option rootOption, final List arguments) {\n        this.prefixes = rootOption.getPrefixes();\n        this.normalised = arguments;\n    }\n\n    public void addOption(Option option) {\n        options.add(option);\n        nameToOption.put(option.getPreferredName(), option);\n\n        for (Iterator i = option.getTriggers().iterator(); i.hasNext();) {\n            nameToOption.put(i.next(), option);\n        }\n    }\n\n    public void addValue(final Option option, final Object value) {\n        if (option instanceof Argument) {\n            addOption(option);\n        }\n\n        List valueList = (List) values.get(option);\n\n        if (valueList == null) {\n            valueList = new ArrayList();\n            values.put(option, valueList);\n        }\n\n        valueList.add(value);\n    }\n\n    public void addSwitch(final Option option, final boolean value) {\n        addOption(option);\n\n        if (switches.containsKey(option)) {\n            throw new IllegalStateException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.SWITCH_ALREADY_SET));\n        } else {\n            switches.put(option, value ? Boolean.TRUE : Boolean.FALSE);\n        }\n    }\n\n    public boolean hasOption(final Option option) {\n        final boolean present = options.contains(option);\n\n        return present;\n    }\n\n    public Option getOption(final String trigger) {\n        return (Option) nameToOption.get(trigger);\n    }\n\n    public List getValues(final Option option, final List defaultValues) {\n        \n        List valueList = (List) values.get(option);\n\n        \n        if ((valueList == null) || valueList.isEmpty()) {\n            valueList = defaultValues;\n        }\n\n        \n        if ((valueList == null) || valueList.isEmpty()) {\n            valueList = (List) this.defaultValues.get(option);\n        }\n\n        \n        if (valueList == null) {\n            valueList = Collections.EMPTY_LIST;\n        }\n\n        return valueList;\n    }\n\n      \n\n      \n\n    public Boolean getSwitch(final Option option, final Boolean defaultValue) {\n        \n        Boolean bool = (Boolean) switches.get(option);\n\n        \n        if (bool == null) {\n            bool = defaultValue;\n        }\n\n        \n        if (bool == null) {\n            bool = (Boolean) this.defaultSwitches.get(option);\n        }\n\n        return bool;\n    }\n\n    public void addProperty(final String property, final String value) {\n        properties.setProperty(property, value);\n    }\n\n    public String getProperty(final String property, final String defaultValue) {\n        return properties.getProperty(property, defaultValue);\n    }\n\n    public Set getProperties() {\n        return Collections.unmodifiableSet(properties.keySet());\n    }\n\n    public boolean looksLikeOption(final String trigger) {\n        for (final Iterator i = prefixes.iterator(); i.hasNext();) {\n            final String prefix = (String) i.next();\n\n            if (trigger.startsWith(prefix)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    public String toString() {\n        final StringBuffer buffer = new StringBuffer();\n\n        \n        for (final Iterator i = normalised.iterator(); i.hasNext();) {\n            final String arg = (String) i.next();\n\n            if (arg.indexOf(' ') >= 0) {\n                buffer.append(\"\\\"\").append(arg).append(\"\\\"\");\n            } else {\n                buffer.append(arg);\n            }\n\n            if (i.hasNext()) {\n                buffer.append(' ');\n            }\n        }\n\n        return buffer.toString();\n    }\n\n    public List getOptions() {\n        return Collections.unmodifiableList(options);\n    }\n\n    public Set getOptionTriggers() {\n        return Collections.unmodifiableSet(nameToOption.keySet());\n    }\n\n    public void setDefaultValues(final Option option, final List defaults) {\n        if (defaults == null) {\n            defaultValues.remove(option);\n        } else {\n            defaultValues.put(option, defaults);\n        }\n    }\n\n    public void setDefaultSwitch(final Option option, final Boolean defaultSwitch) {\n        if (defaultSwitch == null) {\n            defaultSwitches.remove(option);\n        } else {\n            defaultSwitches.put(option, defaultSwitch);\n        }\n    }\n\n    public List getNormalised() {\n        return Collections.unmodifiableList(normalised);\n    }\n}\n",
      "fixed_full_code": "\npackage org.apache.commons.cli2.commandline;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Set;\n\nimport org.apache.commons.cli2.Argument;\nimport org.apache.commons.cli2.Option;\nimport org.apache.commons.cli2.WriteableCommandLine;\nimport org.apache.commons.cli2.resource.ResourceConstants;\nimport org.apache.commons.cli2.resource.ResourceHelper;\n\n\npublic class WriteableCommandLineImpl extends CommandLineImpl implements WriteableCommandLine { private final Properties properties = new Properties(); private final List options = new ArrayList(); private final Map nameToOption = new HashMap(); private final Map values = new HashMap(); private final Map switches = new HashMap(); private final Map defaultValues = new HashMap(); private final Map defaultSwitches = new HashMap(); private final List normalised; private final Set prefixes; public WriteableCommandLineImpl(final Option rootOption, final List arguments) {\n        this.prefixes = rootOption.getPrefixes();\n        this.normalised = arguments;\n    }\n\n    public void addOption(Option option) {\n        options.add(option);\n        nameToOption.put(option.getPreferredName(), option);\n\n        for (Iterator i = option.getTriggers().iterator(); i.hasNext();) {\n            nameToOption.put(i.next(), option);\n        }\n    }\n\n    public void addValue(final Option option, final Object value) {\n        if (option instanceof Argument) {\n            addOption(option);\n        }\n\n        List valueList = (List) values.get(option);\n\n        if (valueList == null) {\n            valueList = new ArrayList();\n            values.put(option, valueList);\n        }\n\n        valueList.add(value);\n    }\n\n    public void addSwitch(final Option option, final boolean value) {\n        addOption(option);\n\n        if (switches.containsKey(option)) {\n            throw new IllegalStateException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.SWITCH_ALREADY_SET));\n        } else {\n            switches.put(option, value ? Boolean.TRUE : Boolean.FALSE);\n        }\n    }\n\n    public boolean hasOption(final Option option) {\n        final boolean present = options.contains(option);\n\n        return present;\n    }\n\n    public Option getOption(final String trigger) {\n        return (Option) nameToOption.get(trigger);\n    }\n\n    public List getValues(final Option option, final List defaultValues) {\n        \n        List valueList = (List) values.get(option);\n\n        \n        if ((valueList == null) || valueList.isEmpty()) {\n            valueList = defaultValues;\n        }\n\n        \n        if ((valueList == null) || valueList.isEmpty()) {\n            valueList = (List) this.defaultValues.get(option);\n        }\n\n        \n        if (valueList == null) {\n            valueList = Collections.EMPTY_LIST;\n        }\n\n        return valueList;\n    }\n\n    public List getUndefaultedValues(Option option) {\n      \n      List valueList = (List) values.get(option);\n\n      \n      if (valueList == null) {\n        valueList = Collections.EMPTY_LIST;\n      }\n\n      return valueList;\n    }\n\n    public Boolean getSwitch(final Option option, final Boolean defaultValue) {\n        \n        Boolean bool = (Boolean) switches.get(option);\n\n        \n        if (bool == null) {\n            bool = defaultValue;\n        }\n\n        \n        if (bool == null) {\n            bool = (Boolean) this.defaultSwitches.get(option);\n        }\n\n        return bool;\n    }\n\n    public void addProperty(final String property, final String value) {\n        properties.setProperty(property, value);\n    }\n\n    public String getProperty(final String property, final String defaultValue) {\n        return properties.getProperty(property, defaultValue);\n    }\n\n    public Set getProperties() {\n        return Collections.unmodifiableSet(properties.keySet());\n    }\n\n    public boolean looksLikeOption(final String trigger) {\n        for (final Iterator i = prefixes.iterator(); i.hasNext();) {\n            final String prefix = (String) i.next();\n\n            if (trigger.startsWith(prefix)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    public String toString() {\n        final StringBuffer buffer = new StringBuffer();\n\n        \n        for (final Iterator i = normalised.iterator(); i.hasNext();) {\n            final String arg = (String) i.next();\n\n            if (arg.indexOf(' ') >= 0) {\n                buffer.append(\"\\\"\").append(arg).append(\"\\\"\");\n            } else {\n                buffer.append(arg);\n            }\n\n            if (i.hasNext()) {\n                buffer.append(' ');\n            }\n        }\n\n        return buffer.toString();\n    }\n\n    public List getOptions() {\n        return Collections.unmodifiableList(options);\n    }\n\n    public Set getOptionTriggers() {\n        return Collections.unmodifiableSet(nameToOption.keySet());\n    }\n\n    public void setDefaultValues(final Option option, final List defaults) {\n        if (defaults == null) {\n            defaultValues.remove(option);\n        } else {\n            defaultValues.put(option, defaults);\n        }\n    }\n\n    public void setDefaultSwitch(final Option option, final Boolean defaultSwitch) {\n        if (defaultSwitch == null) {\n            defaultSwitches.remove(option);\n        } else {\n            defaultSwitches.put(option, defaultSwitch);\n        }\n    }\n\n    public List getNormalised() {\n        return Collections.unmodifiableList(normalised);\n    }\n}\n",
      "buggy_signatures": [
        "public void addOption(Option option)",
        "public void addValue(final Option option, final Object value)",
        "public void addSwitch(final Option option, final boolean value)",
        "public boolean hasOption(final Option option)",
        "public Option getOption(final String trigger)",
        "public List getValues(final Option option, final List defaultValues)",
        "public Boolean getSwitch(final Option option, final Boolean defaultValue)",
        "public void addProperty(final String property, final String value)",
        "public String getProperty(final String property, final String defaultValue)",
        "public Set getProperties()",
        "public boolean looksLikeOption(final String trigger)",
        "public String toString()",
        "public List getOptions()",
        "public Set getOptionTriggers()",
        "public void setDefaultValues(final Option option, final List defaults)",
        "public void setDefaultSwitch(final Option option, final Boolean defaultSwitch)",
        "public List getNormalised()"
      ],
      "fixed_signatures": [
        "public void addOption(Option option)",
        "public void addValue(final Option option, final Object value)",
        "public void addSwitch(final Option option, final boolean value)",
        "public boolean hasOption(final Option option)",
        "public Option getOption(final String trigger)",
        "public List getValues(final Option option, final List defaultValues)",
        "public List getUndefaultedValues(Option option)",
        "public Boolean getSwitch(final Option option, final Boolean defaultValue)",
        "public void addProperty(final String property, final String value)",
        "public String getProperty(final String property, final String defaultValue)",
        "public Set getProperties()",
        "public boolean looksLikeOption(final String trigger)",
        "public String toString()",
        "public List getOptions()",
        "public Set getOptionTriggers()",
        "public void setDefaultValues(final Option option, final List defaults)",
        "public void setDefaultSwitch(final Option option, final Boolean defaultSwitch)",
        "public List getNormalised()"
      ],
      "methods": [
        {
          "buggy_method": "  public Boolean getSwitch(final Option option, final Boolean defaultValue) {\n  \n  Boolean bool = (Boolean) switches.get(option);\n\n  \n  if (bool == null) {\n  bool = defaultValue;\n  }\n\n  \n  if (bool == null) {\n  bool = (Boolean) this.defaultSwitches.get(option);\n  }\n\n  return bool;\n  }",
          "fixed_method": "  public List getUndefaultedValues(Option option) {\n  \n  List valueList = (List) values.get(option);\n\n  \n  if (valueList == null) {\n  valueList = Collections.EMPTY_LIST;\n  }\n\n  return valueList;\n  }",
          "diff": [
            "@@ -129,9 +129,17 @@",
            "         return valueList;\n",
            "     }\n",
            " \n",
            "+    public List getUndefaultedValues(Option option) {\n",
            "       // First grab the command line values\n",
            "+      List valueList = (List) values.get(option);\n",
            " \n",
            "       // Finally use an empty list\n",
            "+      if (valueList == null) {\n",
            "+        valueList = Collections.EMPTY_LIST;\n",
            "+      }\n",
            "+\n",
            "+      return valueList;\n",
            "+    }\n",
            " \n",
            "     public Boolean getSwitch(final Option option,\n",
            "                              final Boolean defaultValue) {\n"
          ],
          "changed_lines": 8
        }
      ]
    },
    {
      "name": "org/apache/commons/cli2/option/ArgumentImpl.java",
      "buggy_full_code": "\npackage org.apache.commons.cli2.option;\n\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Set;\nimport java.util.StringTokenizer;\n\nimport org.apache.commons.cli2.Argument;\nimport org.apache.commons.cli2.DisplaySetting;\nimport org.apache.commons.cli2.HelpLine;\nimport org.apache.commons.cli2.Option;\nimport org.apache.commons.cli2.OptionException;\nimport org.apache.commons.cli2.WriteableCommandLine;\nimport org.apache.commons.cli2.resource.ResourceConstants;\nimport org.apache.commons.cli2.resource.ResourceHelper;\nimport org.apache.commons.cli2.validation.InvalidArgumentException;\nimport org.apache.commons.cli2.validation.Validator;\n\n\npublic class ArgumentImpl extends OptionImpl implements Argument { private static final char NUL = '\\0'; public static final char DEFAULT_INITIAL_SEPARATOR = NUL; public static final char DEFAULT_SUBSEQUENT_SEPARATOR = NUL; public static final String DEFAULT_CONSUME_REMAINING = \"--\"; private final String name; private final String description; private final int minimum; private final int maximum; private final char initialSeparator; private final char subsequentSeparator; private final boolean subsequentSplit; private final Validator validator; private final String consumeRemaining; private final List defaultValues; private final ResourceHelper resources = ResourceHelper.getResourceHelper(); public ArgumentImpl(final String name, final String description, final int minimum, final int maximum, final char initialSeparator, final char subsequentSeparator, final Validator validator, final String consumeRemaining, final List valueDefaults, final int id) {\n        super(id, false);\n\n        this.name = (name == null) ? \"arg\" : name;\n        this.description = description;\n        this.minimum = minimum;\n        this.maximum = maximum;\n        this.initialSeparator = initialSeparator;\n        this.subsequentSeparator = subsequentSeparator;\n        this.subsequentSplit = subsequentSeparator != NUL;\n        this.validator = validator;\n        this.consumeRemaining = consumeRemaining;\n        this.defaultValues = valueDefaults;\n\n        if (minimum > maximum) {\n            throw new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_MIN_EXCEEDS_MAX));\n        }\n\n        if ((valueDefaults != null) && (valueDefaults.size() > 0)) {\n            if (valueDefaults.size() < minimum) {\n                throw new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_TOO_FEW_DEFAULTS));\n            }\n\n            if (valueDefaults.size() > maximum) {\n                throw new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_TOO_MANY_DEFAULTS));\n            }\n        }\n    }\n\n    public String getPreferredName() {\n        return name;\n    }\n\n    public void processValues(final WriteableCommandLine commandLine, final ListIterator arguments, final Option option) throws OptionException {\n        \n        int argumentCount = 0;\n\n        while (arguments.hasNext() && (argumentCount < maximum)) {\n            final String allValuesQuoted = (String) arguments.next();\n            final String allValues = stripBoundaryQuotes(allValuesQuoted);\n\n            \n            if (allValuesQuoted.equals(consumeRemaining)) {\n                while (arguments.hasNext() && (argumentCount < maximum)) {\n                    ++argumentCount;\n                    commandLine.addValue(option, arguments.next());\n                }\n            }\n            \n            else if (commandLine.looksLikeOption(allValuesQuoted)) {\n                arguments.previous();\n\n                break;\n            }\n            \n            else if (subsequentSplit) {\n                final StringTokenizer values =\n                    new StringTokenizer(allValues, String.valueOf(subsequentSeparator));\n\n                arguments.remove();\n\n                while (values.hasMoreTokens() && (argumentCount < maximum)) {\n                    ++argumentCount;\n\n                    final String token = values.nextToken();\n                    commandLine.addValue(option, token);\n                    arguments.add(token);\n                }\n\n                if (values.hasMoreTokens()) {\n                    throw new OptionException(option, ResourceConstants.ARGUMENT_UNEXPECTED_VALUE,\n                                              values.nextToken());\n                }\n            }\n            \n            else {\n                ++argumentCount;\n                commandLine.addValue(option, allValues);\n            }\n        }\n    }\n\n    public boolean canProcess(final WriteableCommandLine commandLine, final String arg) {\n        return true;\n    }\n\n    public Set getPrefixes() {\n        return Collections.EMPTY_SET;\n    }\n\n    public void process(WriteableCommandLine commandLine, ListIterator args) throws OptionException {\n        processValues(commandLine, args, this);\n    }\n\n    public char getInitialSeparator() {\n        return this.initialSeparator;\n    }\n\n    public char getSubsequentSeparator() {\n        return this.subsequentSeparator;\n    }\n\n    public Set getTriggers() {\n        return Collections.EMPTY_SET;\n    }\n\n    public String getConsumeRemaining() {\n        return this.consumeRemaining;\n    }\n\n    public List getDefaultValues() {\n        return this.defaultValues;\n    }\n\n    public Validator getValidator() {\n        return this.validator;\n    }\n\n    public void validate(final WriteableCommandLine commandLine) throws OptionException {\n        validate(commandLine, this);\n    }\n\n    public void validate(final WriteableCommandLine commandLine, final Option option) throws OptionException {\n        final List values = commandLine.getValues(option);\n\n        if (values.size() < minimum) {\n            throw new OptionException(option, ResourceConstants.ARGUMENT_MISSING_VALUES);\n        }\n\n        if (values.size() > maximum) {\n            throw new OptionException(option, ResourceConstants.ARGUMENT_UNEXPECTED_VALUE,\n                                      (String) values.get(maximum));\n        }\n\n        if (validator != null) {\n            try {\n                validator.validate(values);\n            } catch (InvalidArgumentException ive) {\n                throw new OptionException(option, ResourceConstants.ARGUMENT_UNEXPECTED_VALUE,\n                                          ive.getMessage());\n            }\n        }\n    }\n\n    public void appendUsage(final StringBuffer buffer, final Set helpSettings, final Comparator comp) {\n        \n        final boolean optional = helpSettings.contains(DisplaySetting.DISPLAY_OPTIONAL);\n\n        \n        final boolean numbered =\n            (maximum > 1) && helpSettings.contains(DisplaySetting.DISPLAY_ARGUMENT_NUMBERED);\n\n        final boolean bracketed = helpSettings.contains(DisplaySetting.DISPLAY_ARGUMENT_BRACKETED);\n\n        \n        final int max = (maximum == Integer.MAX_VALUE) ? 2 : maximum;\n\n        int i = 0;\n\n        \n        while (i < max) {\n            \n            if (i > 0) {\n                buffer.append(' ');\n            }\n\n            \n            if ((i >= minimum) && (optional || (i > 0))) {\n                buffer.append('[');\n            }\n\n            if (bracketed) {\n                buffer.append('<');\n            }\n\n            \n            buffer.append(name);\n            ++i;\n\n            \n            if (numbered) {\n                buffer.append(i);\n            }\n\n            if (bracketed) {\n                buffer.append('>');\n            }\n        }\n\n        \n        if (maximum == Integer.MAX_VALUE) {\n            \n            buffer.append(\" ...\");\n        }\n\n        \n        while (i > 0) {\n            --i;\n\n            \n            if ((i >= minimum) && (optional || (i > 0))) {\n                buffer.append(']');\n            }\n        }\n    }\n\n    public String getDescription() {\n        return description;\n    }\n\n    public List helpLines(final int depth, final Set helpSettings, final Comparator comp) {\n        final HelpLine helpLine = new HelpLineImpl(this, depth);\n\n        return Collections.singletonList(helpLine);\n    }\n\n    public int getMaximum() {\n        return maximum;\n    }\n\n    public int getMinimum() {\n        return minimum;\n    }\n\n    \n    public String stripBoundaryQuotes(String token) {\n        if (!token.startsWith(\"\\\"\") || !token.endsWith(\"\\\"\")) {\n            return token;\n        }\n\n        token = token.substring(1, token.length() - 1);\n\n        return token;\n    }\n\n    public boolean isRequired() {\n        return getMinimum() > 0;\n    }\n\n    public void defaults(final WriteableCommandLine commandLine) {\n        super.defaults(commandLine);\n        defaultValues(commandLine, this);\n    }\n\n    public void defaultValues(final WriteableCommandLine commandLine, final Option option) {\n        commandLine.setDefaultValues(option, defaultValues);\n    }\n}\n",
      "fixed_full_code": "\npackage org.apache.commons.cli2.option;\n\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Set;\nimport java.util.StringTokenizer;\n\nimport org.apache.commons.cli2.Argument;\nimport org.apache.commons.cli2.DisplaySetting;\nimport org.apache.commons.cli2.HelpLine;\nimport org.apache.commons.cli2.Option;\nimport org.apache.commons.cli2.OptionException;\nimport org.apache.commons.cli2.WriteableCommandLine;\nimport org.apache.commons.cli2.resource.ResourceConstants;\nimport org.apache.commons.cli2.resource.ResourceHelper;\nimport org.apache.commons.cli2.validation.InvalidArgumentException;\nimport org.apache.commons.cli2.validation.Validator;\n\n\npublic class ArgumentImpl extends OptionImpl implements Argument { private static final char NUL = '\\0'; public static final char DEFAULT_INITIAL_SEPARATOR = NUL; public static final char DEFAULT_SUBSEQUENT_SEPARATOR = NUL; public static final String DEFAULT_CONSUME_REMAINING = \"--\"; private final String name; private final String description; private final int minimum; private final int maximum; private final char initialSeparator; private final char subsequentSeparator; private final boolean subsequentSplit; private final Validator validator; private final String consumeRemaining; private final List defaultValues; private final ResourceHelper resources = ResourceHelper.getResourceHelper(); public ArgumentImpl(final String name, final String description, final int minimum, final int maximum, final char initialSeparator, final char subsequentSeparator, final Validator validator, final String consumeRemaining, final List valueDefaults, final int id) {\n        super(id, false);\n\n        this.name = (name == null) ? \"arg\" : name;\n        this.description = description;\n        this.minimum = minimum;\n        this.maximum = maximum;\n        this.initialSeparator = initialSeparator;\n        this.subsequentSeparator = subsequentSeparator;\n        this.subsequentSplit = subsequentSeparator != NUL;\n        this.validator = validator;\n        this.consumeRemaining = consumeRemaining;\n        this.defaultValues = valueDefaults;\n\n        if (minimum > maximum) {\n            throw new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_MIN_EXCEEDS_MAX));\n        }\n\n        if ((valueDefaults != null) && (valueDefaults.size() > 0)) {\n            if (valueDefaults.size() < minimum) {\n                throw new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_TOO_FEW_DEFAULTS));\n            }\n\n            if (valueDefaults.size() > maximum) {\n                throw new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_TOO_MANY_DEFAULTS));\n            }\n        }\n    }\n\n    public String getPreferredName() {\n        return name;\n    }\n\n    public void processValues(final WriteableCommandLine commandLine, final ListIterator arguments, final Option option) throws OptionException {\n        \n        int argumentCount = commandLine.getUndefaultedValues(option).size();\n\n        while (arguments.hasNext() && (argumentCount < maximum)) {\n            final String allValuesQuoted = (String) arguments.next();\n            final String allValues = stripBoundaryQuotes(allValuesQuoted);\n\n            \n            if (allValuesQuoted.equals(consumeRemaining)) {\n                while (arguments.hasNext() && (argumentCount < maximum)) {\n                    ++argumentCount;\n                    commandLine.addValue(option, arguments.next());\n                }\n            }\n            \n            else if (commandLine.looksLikeOption(allValuesQuoted)) {\n                arguments.previous();\n\n                break;\n            }\n            \n            else if (subsequentSplit) {\n                final StringTokenizer values =\n                    new StringTokenizer(allValues, String.valueOf(subsequentSeparator));\n\n                arguments.remove();\n\n                while (values.hasMoreTokens() && (argumentCount < maximum)) {\n                    ++argumentCount;\n\n                    final String token = values.nextToken();\n                    commandLine.addValue(option, token);\n                    arguments.add(token);\n                }\n\n                if (values.hasMoreTokens()) {\n                    throw new OptionException(option, ResourceConstants.ARGUMENT_UNEXPECTED_VALUE,\n                                              values.nextToken());\n                }\n            }\n            \n            else {\n                ++argumentCount;\n                commandLine.addValue(option, allValues);\n            }\n        }\n    }\n\n    public boolean canProcess(final WriteableCommandLine commandLine, final String arg) {\n        return true;\n    }\n\n    public Set getPrefixes() {\n        return Collections.EMPTY_SET;\n    }\n\n    public void process(WriteableCommandLine commandLine, ListIterator args) throws OptionException {\n        processValues(commandLine, args, this);\n    }\n\n    public char getInitialSeparator() {\n        return this.initialSeparator;\n    }\n\n    public char getSubsequentSeparator() {\n        return this.subsequentSeparator;\n    }\n\n    public Set getTriggers() {\n        return Collections.EMPTY_SET;\n    }\n\n    public String getConsumeRemaining() {\n        return this.consumeRemaining;\n    }\n\n    public List getDefaultValues() {\n        return this.defaultValues;\n    }\n\n    public Validator getValidator() {\n        return this.validator;\n    }\n\n    public void validate(final WriteableCommandLine commandLine) throws OptionException {\n        validate(commandLine, this);\n    }\n\n    public void validate(final WriteableCommandLine commandLine, final Option option) throws OptionException {\n        final List values = commandLine.getValues(option);\n\n        if (values.size() < minimum) {\n            throw new OptionException(option, ResourceConstants.ARGUMENT_MISSING_VALUES);\n        }\n\n        if (values.size() > maximum) {\n            throw new OptionException(option, ResourceConstants.ARGUMENT_UNEXPECTED_VALUE,\n                                      (String) values.get(maximum));\n        }\n\n        if (validator != null) {\n            try {\n                validator.validate(values);\n            } catch (InvalidArgumentException ive) {\n                throw new OptionException(option, ResourceConstants.ARGUMENT_UNEXPECTED_VALUE,\n                                          ive.getMessage());\n            }\n        }\n    }\n\n    public void appendUsage(final StringBuffer buffer, final Set helpSettings, final Comparator comp) {\n        \n        final boolean optional = helpSettings.contains(DisplaySetting.DISPLAY_OPTIONAL);\n\n        \n        final boolean numbered =\n            (maximum > 1) && helpSettings.contains(DisplaySetting.DISPLAY_ARGUMENT_NUMBERED);\n\n        final boolean bracketed = helpSettings.contains(DisplaySetting.DISPLAY_ARGUMENT_BRACKETED);\n\n        \n        final int max = (maximum == Integer.MAX_VALUE) ? 2 : maximum;\n\n        int i = 0;\n\n        \n        while (i < max) {\n            \n            if (i > 0) {\n                buffer.append(' ');\n            }\n\n            \n            if ((i >= minimum) && (optional || (i > 0))) {\n                buffer.append('[');\n            }\n\n            if (bracketed) {\n                buffer.append('<');\n            }\n\n            \n            buffer.append(name);\n            ++i;\n\n            \n            if (numbered) {\n                buffer.append(i);\n            }\n\n            if (bracketed) {\n                buffer.append('>');\n            }\n        }\n\n        \n        if (maximum == Integer.MAX_VALUE) {\n            \n            buffer.append(\" ...\");\n        }\n\n        \n        while (i > 0) {\n            --i;\n\n            \n            if ((i >= minimum) && (optional || (i > 0))) {\n                buffer.append(']');\n            }\n        }\n    }\n\n    public String getDescription() {\n        return description;\n    }\n\n    public List helpLines(final int depth, final Set helpSettings, final Comparator comp) {\n        final HelpLine helpLine = new HelpLineImpl(this, depth);\n\n        return Collections.singletonList(helpLine);\n    }\n\n    public int getMaximum() {\n        return maximum;\n    }\n\n    public int getMinimum() {\n        return minimum;\n    }\n\n    \n    public String stripBoundaryQuotes(String token) {\n        if (!token.startsWith(\"\\\"\") || !token.endsWith(\"\\\"\")) {\n            return token;\n        }\n\n        token = token.substring(1, token.length() - 1);\n\n        return token;\n    }\n\n    public boolean isRequired() {\n        return getMinimum() > 0;\n    }\n\n    public void defaults(final WriteableCommandLine commandLine) {\n        super.defaults(commandLine);\n        defaultValues(commandLine, this);\n    }\n\n    public void defaultValues(final WriteableCommandLine commandLine, final Option option) {\n        commandLine.setDefaultValues(option, defaultValues);\n    }\n}\n",
      "buggy_signatures": [
        "public String getPreferredName()",
        "public void processValues(final WriteableCommandLine commandLine, final ListIterator arguments, final Option option) throws OptionException",
        "public boolean canProcess(final WriteableCommandLine commandLine, final String arg)",
        "public Set getPrefixes()",
        "public void process(WriteableCommandLine commandLine, ListIterator args) throws OptionException",
        "public char getInitialSeparator()",
        "public char getSubsequentSeparator()",
        "public Set getTriggers()",
        "public String getConsumeRemaining()",
        "public List getDefaultValues()",
        "public Validator getValidator()",
        "public void validate(final WriteableCommandLine commandLine) throws OptionException",
        "public void validate(final WriteableCommandLine commandLine, final Option option) throws OptionException",
        "public void appendUsage(final StringBuffer buffer, final Set helpSettings, final Comparator comp)",
        "public String getDescription()",
        "public List helpLines(final int depth, final Set helpSettings, final Comparator comp)",
        "public int getMaximum()",
        "public int getMinimum()",
        "public String stripBoundaryQuotes(String token)",
        "public boolean isRequired()",
        "public void defaults(final WriteableCommandLine commandLine)",
        "public void defaultValues(final WriteableCommandLine commandLine, final Option option)"
      ],
      "fixed_signatures": [
        "public String getPreferredName()",
        "public void processValues(final WriteableCommandLine commandLine, final ListIterator arguments, final Option option) throws OptionException",
        "public boolean canProcess(final WriteableCommandLine commandLine, final String arg)",
        "public Set getPrefixes()",
        "public void process(WriteableCommandLine commandLine, ListIterator args) throws OptionException",
        "public char getInitialSeparator()",
        "public char getSubsequentSeparator()",
        "public Set getTriggers()",
        "public String getConsumeRemaining()",
        "public List getDefaultValues()",
        "public Validator getValidator()",
        "public void validate(final WriteableCommandLine commandLine) throws OptionException",
        "public void validate(final WriteableCommandLine commandLine, final Option option) throws OptionException",
        "public void appendUsage(final StringBuffer buffer, final Set helpSettings, final Comparator comp)",
        "public String getDescription()",
        "public List helpLines(final int depth, final Set helpSettings, final Comparator comp)",
        "public int getMaximum()",
        "public int getMinimum()",
        "public String stripBoundaryQuotes(String token)",
        "public boolean isRequired()",
        "public void defaults(final WriteableCommandLine commandLine)",
        "public void defaultValues(final WriteableCommandLine commandLine, final Option option)"
      ],
      "methods": [
        {
          "buggy_method": "  public void processValues(final WriteableCommandLine commandLine, final ListIterator arguments, final Option option) throws OptionException {\n  \n  int argumentCount = 0;\n\n  while (arguments.hasNext() && (argumentCount < maximum)) {\n  final String allValuesQuoted = (String) arguments.next();\n  final String allValues = stripBoundaryQuotes(allValuesQuoted);\n\n  \n  if (allValuesQuoted.equals(consumeRemaining)) {\n  while (arguments.hasNext() && (argumentCount < maximum)) {\n  ++argumentCount;\n  commandLine.addValue(option, arguments.next());\n  }\n  }\n  \n  else if (commandLine.looksLikeOption(allValuesQuoted)) {\n  arguments.previous();\n\n  break;\n  }\n  \n  else if (subsequentSplit) {\n  final StringTokenizer values =\n  new StringTokenizer(allValues, String.valueOf(subsequentSeparator));\n\n  arguments.remove();\n\n  while (values.hasMoreTokens() && (argumentCount < maximum)) {\n  ++argumentCount;\n\n  final String token = values.nextToken();\n  commandLine.addValue(option, token);\n  arguments.add(token);\n  }\n\n  if (values.hasMoreTokens()) {\n  throw new OptionException(option, ResourceConstants.ARGUMENT_UNEXPECTED_VALUE,\n  values.nextToken());\n  }\n  }\n  \n  else {\n  ++argumentCount;\n  commandLine.addValue(option, allValues);\n  }\n  }\n  }",
          "fixed_method": "  public void processValues(final WriteableCommandLine commandLine, final ListIterator arguments, final Option option) throws OptionException {\n  \n  int argumentCount = commandLine.getUndefaultedValues(option).size();\n\n  while (arguments.hasNext() && (argumentCount < maximum)) {\n  final String allValuesQuoted = (String) arguments.next();\n  final String allValues = stripBoundaryQuotes(allValuesQuoted);\n\n  \n  if (allValuesQuoted.equals(consumeRemaining)) {\n  while (arguments.hasNext() && (argumentCount < maximum)) {\n  ++argumentCount;\n  commandLine.addValue(option, arguments.next());\n  }\n  }\n  \n  else if (commandLine.looksLikeOption(allValuesQuoted)) {\n  arguments.previous();\n\n  break;\n  }\n  \n  else if (subsequentSplit) {\n  final StringTokenizer values =\n  new StringTokenizer(allValues, String.valueOf(subsequentSeparator));\n\n  arguments.remove();\n\n  while (values.hasMoreTokens() && (argumentCount < maximum)) {\n  ++argumentCount;\n\n  final String token = values.nextToken();\n  commandLine.addValue(option, token);\n  arguments.add(token);\n  }\n\n  if (values.hasMoreTokens()) {\n  throw new OptionException(option, ResourceConstants.ARGUMENT_UNEXPECTED_VALUE,\n  values.nextToken());\n  }\n  }\n  \n  else {\n  ++argumentCount;\n  commandLine.addValue(option, allValues);\n  }\n  }\n  }",
          "diff": [
            "@@ -141,7 +141,7 @@",
            "                               final Option option)\n",
            "         throws OptionException {\n",
            "         // count of arguments processed for this option.\n",
            "-        int argumentCount = 0;\n",
            "+        int argumentCount = commandLine.getUndefaultedValues(option).size();\n",
            " \n",
            "         while (arguments.hasNext() && (argumentCount < maximum)) {\n",
            "             final String allValuesQuoted = (String) arguments.next();\n"
          ],
          "changed_lines": 2
        }
      ]
    }
  ]
}
