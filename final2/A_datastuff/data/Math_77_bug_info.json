{
  "bug_id": "77",
  "failed_tests": {
    "org.apache.commons.math.linear.ArrayRealVectorTest": [
      {
        "methodName": "testBasicFunctions",
        "error": "junit.framework.AssertionFailedError",
        "message": "compare values   expected:<6.0> but was:<128.0>",
        "fail_line": "        assertEquals(\"compare values  \", 6.0, d_getLInfNorm);",
        "test_source": "  public void testBasicFunctions() {\n  ArrayRealVector v1 = new ArrayRealVector(vec1);\n  ArrayRealVector v2 = new ArrayRealVector(vec2);\n  ArrayRealVector v5 = new ArrayRealVector(vec5);\n  ArrayRealVector v_null = new ArrayRealVector(vec_null);\n\n  RealVectorTestImpl v2_t = new RealVectorTestImpl(vec2);\n\n  // emacs calc: [-4, 0, 3, 1, -6, 3] A --> 8.4261497731763586307\n  double d_getNorm = v5.getNorm();\n  assertEquals(\"compare values  \", 8.4261497731763586307, d_getNorm);\n\n  // emacs calc: [-4, 0, 3, 1, -6, 3] vN --> 17\n  double d_getL1Norm = v5.getL1Norm();\n  assertEquals(\"compare values  \", 17.0, d_getL1Norm);\n\n  // emacs calc: [-4, 0, 3, 1, -6, 3] vn --> 6\n  double d_getLInfNorm = v5.getLInfNorm();\n  assertEquals(\"compare values  \", 6.0, d_getLInfNorm);\n\n\n  //octave =  sqrt(sumsq(v1-v2))\n  double dist = v1.getDistance(v2);\n  assertEquals(\"compare values  \",v1.subtract(v2).getNorm(), dist );\n\n  //octave =  sqrt(sumsq(v1-v2))\n  double dist_2 = v1.getDistance(v2_t);\n  assertEquals(\"compare values  \", v1.subtract(v2).getNorm(),dist_2 );\n\n  //octave =  sqrt(sumsq(v1-v2))\n  double dist_3 = v1.getDistance((RealVector) v2);\n  assertEquals(\"compare values  \", v1.subtract(v2).getNorm(),dist_3 );\n\n  //octave =  ???\n  double d_getL1Distance = v1. getL1Distance(v2);\n  assertEquals(\"compare values  \",9d, d_getL1Distance );\n\n  double d_getL1Distance_2 = v1. getL1Distance(v2_t);\n  assertEquals(\"compare values  \",9d, d_getL1Distance_2 );\n\n  double d_getL1Distance_3 = v1. getL1Distance((RealVector) v2);\n  assertEquals(\"compare values  \",9d, d_getL1Distance_3 );\n\n  //octave =  ???\n  double d_getLInfDistance = v1. getLInfDistance(v2);\n  assertEquals(\"compare values  \",3d, d_getLInfDistance );\n\n  double d_getLInfDistance_2 = v1. getLInfDistance(v2_t);\n  assertEquals(\"compare values  \",3d, d_getLInfDistance_2 );\n\n  double d_getLInfDistance_3 = v1. getLInfDistance((RealVector) v2);\n  assertEquals(\"compare values  \",3d, d_getLInfDistance_3 );\n\n  //octave =  v1 + v2\n  ArrayRealVector v_add = v1.add(v2);\n  double[] result_add = {5d, 7d, 9d};\n  assertClose(\"compare vect\" ,v_add.getData(),result_add,normTolerance);\n\n  RealVectorTestImpl vt2 = new RealVectorTestImpl(vec2);\n  RealVector v_add_i = v1.add(vt2);\n  double[] result_add_i = {5d, 7d, 9d};\n  assertClose(\"compare vect\" ,v_add_i.getData(),result_add_i,normTolerance);\n\n  //octave =  v1 - v2\n  ArrayRealVector v_subtract = v1.subtract(v2);\n  double[] result_subtract = {-3d, -3d, -3d};\n  assertClose(\"compare vect\" ,v_subtract.getData(),result_subtract,normTolerance);\n\n  RealVector v_subtract_i = v1.subtract(vt2);\n  double[] result_subtract_i = {-3d, -3d, -3d};\n  assertClose(\"compare vect\" ,v_subtract_i.getData(),result_subtract_i,normTolerance);\n\n  // octave v1 .* v2\n  ArrayRealVector  v_ebeMultiply = v1.ebeMultiply(v2);\n  double[] result_ebeMultiply = {4d, 10d, 18d};\n  assertClose(\"compare vect\" ,v_ebeMultiply.getData(),result_ebeMultiply,normTolerance);\n\n  RealVector  v_ebeMultiply_2 = v1.ebeMultiply(v2_t);\n  double[] result_ebeMultiply_2 = {4d, 10d, 18d};\n  assertClose(\"compare vect\" ,v_ebeMultiply_2.getData(),result_ebeMultiply_2,normTolerance);\n\n  RealVector  v_ebeMultiply_3 = v1.ebeMultiply((RealVector) v2);\n  double[] result_ebeMultiply_3 = {4d, 10d, 18d};\n  assertClose(\"compare vect\" ,v_ebeMultiply_3.getData(),result_ebeMultiply_3,normTolerance);\n\n  // octave v1 ./ v2\n  ArrayRealVector  v_ebeDivide = v1.ebeDivide(v2);\n  double[] result_ebeDivide = {0.25d, 0.4d, 0.5d};\n  assertClose(\"compare vect\" ,v_ebeDivide.getData(),result_ebeDivide,normTolerance);\n\n  RealVector  v_ebeDivide_2 = v1.ebeDivide(v2_t);\n  double[] result_ebeDivide_2 = {0.25d, 0.4d, 0.5d};\n  assertClose(\"compare vect\" ,v_ebeDivide_2.getData(),result_ebeDivide_2,normTolerance);\n\n  RealVector  v_ebeDivide_3 = v1.ebeDivide((RealVector) v2);\n  double[] result_ebeDivide_3 = {0.25d, 0.4d, 0.5d};\n  assertClose(\"compare vect\" ,v_ebeDivide_3.getData(),result_ebeDivide_3,normTolerance);\n\n  // octave  dot(v1,v2)\n  double dot =  v1.dotProduct(v2);\n  assertEquals(\"compare val \",32d, dot);\n\n  // octave  dot(v1,v2_t)\n  double dot_2 =  v1.dotProduct(v2_t);\n  assertEquals(\"compare val \",32d, dot_2);\n\n  RealMatrix m_outerProduct = v1.outerProduct(v2);\n  assertEquals(\"compare val \",4d, m_outerProduct.getEntry(0,0));\n\n  RealMatrix m_outerProduct_2 = v1.outerProduct(v2_t);\n  assertEquals(\"compare val \",4d, m_outerProduct_2.getEntry(0,0));\n\n  RealMatrix m_outerProduct_3 = v1.outerProduct((RealVector) v2);\n  assertEquals(\"compare val \",4d, m_outerProduct_3.getEntry(0,0));\n\n  RealVector v_unitVector = v1.unitVector();\n  RealVector v_unitVector_2 = v1.mapDivide(v1.getNorm());\n  assertClose(\"compare vect\" ,v_unitVector.getData(),v_unitVector_2.getData(),normTolerance);\n\n  try {\n  v_null.unitVector();\n  fail(\"Expecting ArithmeticException\");\n  } catch (ArithmeticException ex) {\n  // expected behavior\n  } catch (Exception e) {\n  fail(\"wrong exception caught\");\n  }\n\n  ArrayRealVector v_unitize = (ArrayRealVector)v1.copy();\n  v_unitize.unitize();\n  assertClose(\"compare vect\" ,v_unitVector_2.getData(),v_unitize.getData(),normTolerance);\n  try {\n  v_null.unitize();\n  fail(\"Expecting ArithmeticException\");\n  } catch (ArithmeticException ex) {\n  // expected behavior\n  } catch (Exception e) {\n  fail(\"wrong exception caught\");\n  }\n\n  ArrayRealVector v_projection = v1.projection(v2);\n  double[] result_projection = {1.662337662337662, 2.0779220779220777, 2.493506493506493};\n  assertClose(\"compare vect\", v_projection.getData(), result_projection, normTolerance);\n\n  RealVector v_projection_2 = v1.projection(v2_t);\n  double[] result_projection_2 = {1.662337662337662, 2.0779220779220777, 2.493506493506493};\n  assertClose(\"compare vect\", v_projection_2.getData(), result_projection_2, normTolerance);\n\n  RealVector v_projection_3 = v1.projection(v2.getData());\n  double[] result_projection_3 = {1.662337662337662, 2.0779220779220777, 2.493506493506493};\n  assertClose(\"compare vect\", v_projection_3.getData(), result_projection_3, normTolerance);\n\n  }",
        "stack": [
          "ArrayRealVectorTest.testBasicFunctions line 1098"
        ]
      }
    ],
    "org.apache.commons.math.linear.SparseRealVectorTest": [
      {
        "methodName": "testBasicFunctions",
        "error": "junit.framework.AssertionFailedError",
        "message": "compare values   expected:<6.0> but was:<-3.0>",
        "fail_line": "        assertEquals(\"compare values  \", 6.0, d_getLInfNorm);",
        "test_source": "  public void testBasicFunctions() {\n  OpenMapRealVector v1 = new OpenMapRealVector(vec1);\n  OpenMapRealVector v2 = new OpenMapRealVector(vec2);\n  OpenMapRealVector v5 = new OpenMapRealVector(vec5);\n  OpenMapRealVector v_null = new OpenMapRealVector(vec_null);\n\n  SparseRealVectorTestImpl v2_t = new SparseRealVectorTestImpl(vec2);\n\n  // emacs calc: [-4, 0, 3, 1, -6, 3] A --> 8.4261497731763586307\n  double d_getNorm = v5.getNorm();\n  assertEquals(\"compare values  \", 8.4261497731763586307, d_getNorm);\n\n  // emacs calc: [-4, 0, 3, 1, -6, 3] vN --> 17\n  double d_getL1Norm = v5.getL1Norm();\n  assertEquals(\"compare values  \", 17.0, d_getL1Norm);\n\n  // emacs calc: [-4, 0, 3, 1, -6, 3] vn --> 6\n  double d_getLInfNorm = v5.getLInfNorm();\n  assertEquals(\"compare values  \", 6.0, d_getLInfNorm);\n\n  //octave =  sqrt(sumsq(v1-v2))\n  double dist = v1.getDistance(v2);\n  assertEquals(\"compare values  \",v1.subtract(v2).getNorm(), dist );\n\n  //octave =  sqrt(sumsq(v1-v2))\n  double dist_2 = v1.getDistance(v2_t);\n  assertEquals(\"compare values  \", v1.subtract(v2).getNorm(),dist_2 );\n\n  //octave =  ???\n  double d_getL1Distance = v1. getL1Distance(v2);\n  assertEquals(\"compare values  \",9d, d_getL1Distance );\n\n  double d_getL1Distance_2 = v1. getL1Distance(v2_t);\n  assertEquals(\"compare values  \",9d, d_getL1Distance_2 );\n\n  //octave =  ???\n  double d_getLInfDistance = v1. getLInfDistance(v2);\n  assertEquals(\"compare values  \",3d, d_getLInfDistance );\n\n  double d_getLInfDistance_2 = v1. getLInfDistance(v2_t);\n  assertEquals(\"compare values  \",3d, d_getLInfDistance_2 );\n\n  //octave =  v1 + v2\n  OpenMapRealVector v_add = v1.add(v2);\n  double[] result_add = {5d, 7d, 9d};\n  assertClose(\"compare vect\" ,v_add.getData(),result_add,normTolerance);\n\n  SparseRealVectorTestImpl vt2 = new SparseRealVectorTestImpl(vec2);\n  RealVector v_add_i = v1.add(vt2);\n  double[] result_add_i = {5d, 7d, 9d};\n  assertClose(\"compare vect\" ,v_add_i.getData(),result_add_i,normTolerance);\n\n  //octave =  v1 - v2\n  OpenMapRealVector v_subtract = v1.subtract(v2);\n  double[] result_subtract = {-3d, -3d, -3d};\n  assertClose(\"compare vect\" ,v_subtract.getData(),result_subtract,normTolerance);\n\n  RealVector v_subtract_i = v1.subtract(vt2);\n  double[] result_subtract_i = {-3d, -3d, -3d};\n  assertClose(\"compare vect\" ,v_subtract_i.getData(),result_subtract_i,normTolerance);\n\n  // octave v1 .* v2\n  RealVector  v_ebeMultiply = v1.ebeMultiply(v2);\n  double[] result_ebeMultiply = {4d, 10d, 18d};\n  assertClose(\"compare vect\" ,v_ebeMultiply.getData(),result_ebeMultiply,normTolerance);\n\n  RealVector  v_ebeMultiply_2 = v1.ebeMultiply(v2_t);\n  double[] result_ebeMultiply_2 = {4d, 10d, 18d};\n  assertClose(\"compare vect\" ,v_ebeMultiply_2.getData(),result_ebeMultiply_2,normTolerance);\n\n  // octave v1 ./ v2\n  RealVector  v_ebeDivide = v1.ebeDivide(v2);\n  double[] result_ebeDivide = {0.25d, 0.4d, 0.5d};\n  assertClose(\"compare vect\" ,v_ebeDivide.getData(),result_ebeDivide,normTolerance);\n\n  RealVector  v_ebeDivide_2 = v1.ebeDivide(v2_t);\n  double[] result_ebeDivide_2 = {0.25d, 0.4d, 0.5d};\n  assertClose(\"compare vect\" ,v_ebeDivide_2.getData(),result_ebeDivide_2,normTolerance);\n\n  // octave  dot(v1,v2)\n  double dot =  v1.dotProduct(v2);\n  assertEquals(\"compare val \",32d, dot);\n\n  // octave  dot(v1,v2_t)\n  double dot_2 =  v1.dotProduct(v2_t);\n  assertEquals(\"compare val \",32d, dot_2);\n\n  RealMatrix m_outerProduct = v1.outerProduct(v2);\n  assertEquals(\"compare val \",4d, m_outerProduct.getEntry(0,0));\n\n  RealMatrix m_outerProduct_2 = v1.outerProduct(v2_t);\n  assertEquals(\"compare val \",4d, m_outerProduct_2.getEntry(0,0));\n\n  RealVector v_unitVector = v1.unitVector();\n  RealVector v_unitVector_2 = v1.mapDivide(v1.getNorm());\n  assertClose(\"compare vect\" ,v_unitVector.getData(),v_unitVector_2.getData(),normTolerance);\n\n  try {\n  v_null.unitVector();\n  fail(\"Expecting ArithmeticException\");\n  } catch (ArithmeticException ex) {\n  // expected behavior\n  } catch (Exception e) {\n  fail(\"wrong exception caught\");\n  }\n\n  OpenMapRealVector v_unitize = v1.copy();\n  v_unitize.unitize();\n  assertClose(\"compare vect\" ,v_unitVector_2.getData(),v_unitize.getData(),normTolerance);\n  try {\n  v_null.unitize();\n  fail(\"Expecting ArithmeticException\");\n  } catch (ArithmeticException ex) {\n  // expected behavior\n  } catch (Exception e) {\n  fail(\"wrong exception caught\");\n  }\n\n  RealVector v_projection = v1.projection(v2);\n  double[] result_projection = {1.662337662337662, 2.0779220779220777, 2.493506493506493};\n  assertClose(\"compare vect\", v_projection.getData(), result_projection, normTolerance);\n\n  RealVector v_projection_2 = v1.projection(v2_t);\n  double[] result_projection_2 = {1.662337662337662, 2.0779220779220777, 2.493506493506493};\n  assertClose(\"compare vect\", v_projection_2.getData(), result_projection_2, normTolerance);\n\n  }",
        "stack": [
          "SparseRealVectorTest.testBasicFunctions line 968"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/math/linear/ArrayRealVector.java",
      "buggy_full_code": "\npackage org.apache.commons.math.linear;\n\nimport java.io.Serializable;\nimport java.util.Arrays;\nimport java.util.Iterator;\n\nimport org.apache.commons.math.MathRuntimeException;\nimport org.apache.commons.math.util.MathUtils;\n\n\npublic class ArrayRealVector extends AbstractRealVector implements Serializable { private static final String NON_FITTING_POSITION_AND_SIZE_MESSAGE = \"position {0} and size {1} don't fit to the size of the input array {2}\"; private static final long serialVersionUID = -1097961340710804027L; private static final RealVectorFormat DEFAULT_FORMAT = RealVectorFormat.getInstance(); protected double data[]; public ArrayRealVector() {\n        data = new double[0];\n    }\n\n    \n    public ArrayRealVector(int size) {\n        data = new double[size];\n    }\n\n    \n    public ArrayRealVector(int size, double preset) {\n        data = new double[size];\n        Arrays.fill(data, preset);\n    }\n\n    \n    public ArrayRealVector(double[] d) {\n        data = d.clone();\n    }\n\n    \n    public ArrayRealVector(double[] d, boolean copyArray) throws NullPointerException, IllegalArgumentException {\n        if (d == null) {\n            throw new NullPointerException();\n        }\n        if (d.length == 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\"vector must have at least one element\");\n        }\n        data = copyArray ? d.clone() :  d;\n    }\n\n    \n    public ArrayRealVector(double[] d, int pos, int size) {\n        if (d.length < pos + size) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  NON_FITTING_POSITION_AND_SIZE_MESSAGE, pos, size, d.length);\n        }\n        data = new double[size];\n        System.arraycopy(d, pos, data, 0, size);\n    }\n\n    \n    public ArrayRealVector(Double[] d) {\n        data = new double[d.length];\n        for (int i = 0; i < d.length; i++) {\n            data[i] = d[i].doubleValue();\n        }\n    }\n\n    \n    public ArrayRealVector(Double[] d, int pos, int size) {\n        if (d.length < pos + size) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  NON_FITTING_POSITION_AND_SIZE_MESSAGE, pos, size, d.length);\n        }\n        data = new double[size];\n        for (int i = pos; i < pos + size; i++) {\n            data[i-pos] = d[i].doubleValue();\n        }\n    }\n\n    \n    public ArrayRealVector(RealVector v) {\n        data = new double[v.getDimension()];\n        for (int i = 0; i < data.length; ++i) {\n            data[i] = v.getEntry(i);\n        }\n    }\n\n    \n    public ArrayRealVector(ArrayRealVector v) {\n        this(v, true);\n    }\n\n    \n    public ArrayRealVector(ArrayRealVector v, boolean deep) {\n        data = deep ? v.data.clone() : v.data;\n    }\n\n    \n    public ArrayRealVector(ArrayRealVector v1, ArrayRealVector v2) {\n        data = new double[v1.data.length + v2.data.length];\n        System.arraycopy(v1.data, 0, data, 0, v1.data.length);\n        System.arraycopy(v2.data, 0, data, v1.data.length, v2.data.length);\n    }\n\n    \n    public ArrayRealVector(ArrayRealVector v1, RealVector v2) {\n        final int l1 = v1.data.length;\n        final int l2 = v2.getDimension();\n        data = new double[l1 + l2];\n        System.arraycopy(v1.data, 0, data, 0, l1);\n        for (int i = 0; i < l2; ++i) {\n            data[l1 + i] = v2.getEntry(i);\n        }\n    }\n\n    \n    public ArrayRealVector(RealVector v1, ArrayRealVector v2) {\n        final int l1 = v1.getDimension();\n        final int l2 = v2.data.length;\n        data = new double[l1 + l2];\n        for (int i = 0; i < l1; ++i) {\n            data[i] = v1.getEntry(i);\n        }\n        System.arraycopy(v2.data, 0, data, l1, l2);\n    }\n\n    \n    public ArrayRealVector(ArrayRealVector v1, double[] v2) {\n        final int l1 = v1.getDimension();\n        final int l2 = v2.length;\n        data = new double[l1 + l2];\n        System.arraycopy(v1.data, 0, data, 0, l1);\n        System.arraycopy(v2, 0, data, l1, l2);\n    }\n\n    \n    public ArrayRealVector(double[] v1, ArrayRealVector v2) {\n        final int l1 = v1.length;\n        final int l2 = v2.getDimension();\n        data = new double[l1 + l2];\n        System.arraycopy(v1, 0, data, 0, l1);\n        System.arraycopy(v2.data, 0, data, l1, l2);\n    }\n\n    \n    public ArrayRealVector(double[] v1, double[] v2) {\n        final int l1 = v1.length;\n        final int l2 = v2.length;\n        data = new double[l1 + l2];\n        System.arraycopy(v1, 0, data, 0, l1);\n        System.arraycopy(v2, 0, data, l1, l2);\n    }\n\n    \n    public AbstractRealVector copy() {\n        return new ArrayRealVector(this, true);\n    }\n\n    \n    public RealVector add(RealVector v) throws IllegalArgumentException {\n        if (v instanceof ArrayRealVector) {\n            return add((ArrayRealVector) v);\n        } else {\n            checkVectorDimensions(v);\n            double[] out = data.clone();\n            Iterator<Entry> it = v.sparseIterator();\n            Entry e;\n            while (it.hasNext() && (e = it.next()) != null) {\n                out[e.getIndex()] += e.getValue();\n            }\n            return new ArrayRealVector(out, false);\n        }\n    }\n\n    \n    public RealVector add(double[] v) throws IllegalArgumentException {\n        checkVectorDimensions(v.length);\n        double[] out = data.clone();\n        for (int i = 0; i < data.length; i++) {\n            out[i] += v[i];\n        }\n        return new ArrayRealVector(out, false);\n    }\n\n    \n    public ArrayRealVector add(ArrayRealVector v) throws IllegalArgumentException {\n        return (ArrayRealVector) add(v.data);\n    }\n\n    \n    public RealVector subtract(RealVector v) throws IllegalArgumentException {\n        if (v instanceof ArrayRealVector) {\n            return subtract((ArrayRealVector) v);\n        } else {\n            checkVectorDimensions(v);\n            double[] out = data.clone();\n            Iterator<Entry> it = v.sparseIterator();\n            Entry e;\n            while(it.hasNext() && (e = it.next()) != null) {\n                out[e.getIndex()] -= e.getValue();\n            }\n            return new ArrayRealVector(out, false);\n        }\n    }\n\n    \n    public RealVector subtract(double[] v) throws IllegalArgumentException {\n        checkVectorDimensions(v.length);\n        double[] out = data.clone();\n        for (int i = 0; i < data.length; i++) {\n            out[i] -= v[i];\n        }\n        return new ArrayRealVector(out, false);\n    }\n\n    \n    public ArrayRealVector subtract(ArrayRealVector v) throws IllegalArgumentException {\n        return (ArrayRealVector) subtract(v.data);\n    }\n\n    \n    public RealVector mapAddToSelf(double d) {\n        for (int i = 0; i < data.length; i++) {\n            data[i] = data[i] + d;\n        }\n        return this;\n    }\n\n    \n    public RealVector mapSubtractToSelf(double d) {\n        for (int i = 0; i < data.length; i++) {\n            data[i] = data[i] - d;\n        }\n        return this;\n    }\n\n    \n    public RealVector mapMultiplyToSelf(double d) {\n        for (int i = 0; i < data.length; i++) {\n            data[i] = data[i] * d;\n        }\n        return this;\n    }\n\n    \n    public RealVector mapDivideToSelf(double d) {\n        for (int i = 0; i < data.length; i++) {\n            data[i] = data[i] / d;\n        }\n        return this;\n    }\n\n    \n    public RealVector mapPowToSelf(double d) {\n        for (int i = 0; i < data.length; i++) {\n            data[i] = Math.pow(data[i], d);\n        }\n        return this;\n    }\n\n    \n    public RealVector mapExpToSelf() {\n        for (int i = 0; i < data.length; i++) {\n            data[i] = Math.exp(data[i]);\n        }\n        return this;\n    }\n\n    \n    public RealVector mapExpm1ToSelf() {\n        for (int i = 0; i < data.length; i++) {\n            data[i] = Math.expm1(data[i]);\n        }\n        return this;\n    }\n\n    \n    public RealVector mapLogToSelf() {\n        for (int i = 0; i < data.length; i++) {\n            data[i] = Math.log(data[i]);\n        }\n        return this;\n    }\n\n    \n    public RealVector mapLog10ToSelf() {\n        for (int i = 0; i < data.length; i++) {\n            data[i] = Math.log10(data[i]);\n        }\n        return this;\n    }\n\n    \n    public RealVector mapLog1pToSelf() {\n        for (int i = 0; i < data.length; i++) {\n            data[i] = Math.log1p(data[i]);\n        }\n        return this;\n    }\n\n    \n    public RealVector mapCoshToSelf() {\n        for (int i = 0; i < data.length; i++) {\n            data[i] = Math.cosh(data[i]);\n        }\n        return this;\n    }\n\n    \n    public RealVector mapSinhToSelf() {\n        for (int i = 0; i < data.length; i++) {\n            data[i] = Math.sinh(data[i]);\n        }\n        return this;\n    }\n\n    \n    public RealVector mapTanhToSelf() {\n        for (int i = 0; i < data.length; i++) {\n            data[i] = Math.tanh(data[i]);\n        }\n        return this;\n    }\n\n    \n    public RealVector mapCosToSelf() {\n        for (int i = 0; i < data.length; i++) {\n            data[i] = Math.cos(data[i]);\n        }\n        return this;\n    }\n\n    \n    public RealVector mapSinToSelf() {\n        for (int i = 0; i < data.length; i++) {\n            data[i] = Math.sin(data[i]);\n        }\n        return this;\n    }\n\n    \n    public RealVector mapTanToSelf() {\n        for (int i = 0; i < data.length; i++) {\n            data[i] = Math.tan(data[i]);\n        }\n        return this;\n    }\n\n    \n    public RealVector mapAcosToSelf() {\n        for (int i = 0; i < data.length; i++) {\n            data[i] = Math.acos(data[i]);\n        }\n        return this;\n    }\n\n    \n    public RealVector mapAsinToSelf() {\n        for (int i = 0; i < data.length; i++) {\n            data[i] = Math.asin(data[i]);\n        }\n        return this;\n    }\n\n    \n    public RealVector mapAtanToSelf() {\n        for (int i = 0; i < data.length; i++) {\n            data[i] = Math.atan(data[i]);\n        }\n        return this;\n    }\n\n    \n    public RealVector mapInvToSelf() {\n        for (int i = 0; i < data.length; i++) {\n            data[i] = 1.0 / data[i];\n        }\n        return this;\n    }\n\n    \n    public RealVector mapAbsToSelf() {\n        for (int i = 0; i < data.length; i++) {\n            data[i] = Math.abs(data[i]);\n        }\n        return this;\n    }\n\n    \n    public RealVector mapSqrtToSelf() {\n        for (int i = 0; i < data.length; i++) {\n            data[i] = Math.sqrt(data[i]);\n        }\n        return this;\n    }\n\n    \n    public RealVector mapCbrtToSelf() {\n        for (int i = 0; i < data.length; i++) {\n            data[i] = Math.cbrt(data[i]);\n        }\n        return this;\n    }\n\n    \n    public RealVector mapCeilToSelf() {\n        for (int i = 0; i < data.length; i++) {\n            data[i] = Math.ceil(data[i]);\n        }\n        return this;\n    }\n\n    \n    public RealVector mapFloorToSelf() {\n        for (int i = 0; i < data.length; i++) {\n            data[i] = Math.floor(data[i]);\n        }\n        return this;\n    }\n\n    \n    public RealVector mapRintToSelf() {\n        for (int i = 0; i < data.length; i++) {\n            data[i] = Math.rint(data[i]);\n        }\n        return this;\n    }\n\n    \n    public RealVector mapSignumToSelf() {\n        for (int i = 0; i < data.length; i++) {\n            data[i] = Math.signum(data[i]);\n        }\n        return this;\n    }\n\n    \n    public RealVector mapUlpToSelf() {\n        for (int i = 0; i < data.length; i++) {\n            data[i] = Math.ulp(data[i]);\n        }\n        return this;\n    }\n\n    \n    public RealVector ebeMultiply(RealVector v) throws IllegalArgumentException {\n        if (v instanceof ArrayRealVector) {\n            return ebeMultiply((ArrayRealVector) v);\n        } else {\n            checkVectorDimensions(v);\n            double[] out = data.clone();\n            for (int i = 0; i < data.length; i++) {\n                out[i] *= v.getEntry(i);\n            }\n            return new ArrayRealVector(out, false);\n        }\n    }\n\n    \n    public RealVector ebeMultiply(double[] v) throws IllegalArgumentException {\n        checkVectorDimensions(v.length);\n        double[] out = data.clone();\n        for (int i = 0; i < data.length; i++) {\n            out[i] *= v[i];\n        }\n        return new ArrayRealVector(out, false);\n    }\n\n    \n    public ArrayRealVector ebeMultiply(ArrayRealVector v) throws IllegalArgumentException {\n        return (ArrayRealVector) ebeMultiply(v.data);\n    }\n\n    \n    public RealVector ebeDivide(RealVector v) throws IllegalArgumentException {\n        if (v instanceof ArrayRealVector) {\n            return ebeDivide((ArrayRealVector) v);\n        } else {\n            checkVectorDimensions(v);\n            double[] out = data.clone();\n            for (int i = 0; i < data.length; i++) {\n                out[i] /= v.getEntry(i);\n            }\n            return new ArrayRealVector(out, false);\n        }\n    }\n\n    \n    public RealVector ebeDivide(double[] v) throws IllegalArgumentException {\n        checkVectorDimensions(v.length);\n        double[] out = data.clone();\n        for (int i = 0; i < data.length; i++) {\n                out[i] /= v[i];\n        }\n        return new ArrayRealVector(out, false);\n    }\n\n    \n    public ArrayRealVector ebeDivide(ArrayRealVector v) throws IllegalArgumentException {\n        return (ArrayRealVector) ebeDivide(v.data);\n    }\n\n    \n    public double[] getData() {\n        return data.clone();\n    }\n\n    \n    public double[] getDataRef() {\n        return data;\n    }\n\n    \n    public double dotProduct(RealVector v) throws IllegalArgumentException {\n        if (v instanceof ArrayRealVector) {\n            return dotProduct((ArrayRealVector) v);\n        } else {\n            checkVectorDimensions(v);\n            double dot = 0;\n            Iterator<Entry> it = v.sparseIterator();\n            Entry e;\n            while(it.hasNext() && (e = it.next()) != null) {\n                dot += data[e.getIndex()] * e.getValue();\n            }\n            return dot;\n        }\n    }\n\n    \n    public double dotProduct(double[] v) throws IllegalArgumentException {\n        checkVectorDimensions(v.length);\n        double dot = 0;\n        for (int i = 0; i < data.length; i++) {\n            dot += data[i] * v[i];\n        }\n        return dot;\n    }\n\n    \n    public double dotProduct(ArrayRealVector v) throws IllegalArgumentException {\n        return dotProduct(v.data);\n    }\n\n    \n    @Override\n    public double getNorm() {\n        double sum = 0;\n        for (double a : data) {\n            sum += a * a;\n        }\n        return Math.sqrt(sum);\n    }\n\n    \n    @Override\n    public double getL1Norm() {\n        double sum = 0;\n        for (double a : data) {\n            sum += Math.abs(a);\n        }\n        return sum;\n    }\n\n    \n    @Override\n    public double getLInfNorm() {\n        double max = 0;\n        for (double a : data) {\n            max += Math.max(max, Math.abs(a));\n        }\n        return max;\n    }\n\n    \n    public double getDistance(RealVector v) throws IllegalArgumentException {\n        if (v instanceof ArrayRealVector) {\n            return getDistance((ArrayRealVector) v);\n        } else {\n            checkVectorDimensions(v);\n            double sum = 0;\n            for (int i = 0; i < data.length; ++i) {\n                final double delta = data[i] - v.getEntry(i);\n                sum += delta * delta;\n            }\n            return Math.sqrt(sum);\n        }\n    }\n\n    \n    public double getDistance(double[] v) throws IllegalArgumentException {\n        checkVectorDimensions(v.length);\n        double sum = 0;\n        for (int i = 0; i < data.length; ++i) {\n            final double delta = data[i] - v[i];\n            sum += delta * delta;\n        }\n        return Math.sqrt(sum);\n    }\n\n   \n    public double getDistance(ArrayRealVector v) throws IllegalArgumentException {\n        return getDistance(v.data);\n    }\n\n    \n    public double getL1Distance(RealVector v) throws IllegalArgumentException {\n        if (v instanceof ArrayRealVector) {\n            return getL1Distance((ArrayRealVector) v);\n        } else {\n            checkVectorDimensions(v);\n            double sum = 0;\n            for (int i = 0; i < data.length; ++i) {\n                final double delta = data[i] - v.getEntry(i);\n                sum += Math.abs(delta);\n            }\n            return sum;\n        }\n    }\n\n    \n    public double getL1Distance(double[] v) throws IllegalArgumentException {\n        checkVectorDimensions(v.length);\n        double sum = 0;\n        for (int i = 0; i < data.length; ++i) {\n            final double delta = data[i] - v[i];\n            sum += Math.abs(delta);\n        }\n        return sum;\n    }\n\n    \n    public double getL1Distance(ArrayRealVector v) throws IllegalArgumentException {\n        return getL1Distance(v.data);\n    }\n\n    \n    public double getLInfDistance(RealVector v) throws IllegalArgumentException {\n        if (v instanceof ArrayRealVector) {\n            return getLInfDistance((ArrayRealVector) v);\n        } else {\n            checkVectorDimensions(v);\n            double max = 0;\n            for (int i = 0; i < data.length; ++i) {\n                final double delta = data[i] - v.getEntry(i);\n                max = Math.max(max, Math.abs(delta));\n            }\n            return max;\n        }\n    }\n\n    \n    public double getLInfDistance(double[] v) throws IllegalArgumentException {\n        checkVectorDimensions(v.length);\n        double max = 0;\n        for (int i = 0; i < data.length; ++i) {\n            final double delta = data[i] - v[i];\n            max = Math.max(max, Math.abs(delta));\n        }\n        return max;\n    }\n\n    \n    public double getLInfDistance(ArrayRealVector v) throws IllegalArgumentException {\n        return getLInfDistance(v.data);\n    }\n\n    \n    public RealVector unitVector() throws ArithmeticException {\n        final double norm = getNorm();\n        if (norm == 0) {\n            throw MathRuntimeException.createArithmeticException(\"zero norm\");\n        }\n        return mapDivide(norm);\n    }\n\n    \n    public void unitize() throws ArithmeticException {\n        final double norm = getNorm();\n        if (norm == 0) {\n            throw MathRuntimeException.createArithmeticException(\"cannot normalize a zero norm vector\");\n        }\n        mapDivideToSelf(norm);\n    }\n\n    \n    public RealVector projection(RealVector v) {\n        return v.mapMultiply(dotProduct(v) / v.dotProduct(v));\n    }\n\n    \n    public RealVector projection(double[] v) {\n        return projection(new ArrayRealVector(v, false));\n    }\n\n   \n    public ArrayRealVector projection(ArrayRealVector v) {\n        return (ArrayRealVector) v.mapMultiply(dotProduct(v) / v.dotProduct(v));\n    }\n\n    \n    public RealMatrix outerProduct(RealVector v) throws IllegalArgumentException {\n        if (v instanceof ArrayRealVector) {\n            return outerProduct((ArrayRealVector) v);\n        } else {\n            checkVectorDimensions(v);\n            final int m = data.length;\n            final RealMatrix out = MatrixUtils.createRealMatrix(m, m);\n            for (int i = 0; i < data.length; i++) {\n                for (int j = 0; j < data.length; j++) {\n                    out.setEntry(i, j, data[i] * v.getEntry(j));\n                }\n            }\n            return out;\n        }\n    }\n\n    \n    public RealMatrix outerProduct(ArrayRealVector v) throws IllegalArgumentException {\n        return outerProduct(v.data);\n    }\n\n    \n    public RealMatrix outerProduct(double[] v) throws IllegalArgumentException {\n        checkVectorDimensions(v.length);\n        final int m = data.length;\n        final RealMatrix out = MatrixUtils.createRealMatrix(m, m);\n        for (int i = 0; i < data.length; i++) {\n            for (int j = 0; j < data.length; j++) {\n                out.setEntry(i, j, data[i] * v[j]);\n            }\n        }\n        return out;\n    }\n\n    \n    public double getEntry(int index) throws MatrixIndexException {\n        return data[index];\n    }\n\n    \n    public int getDimension() {\n        return data.length;\n    }\n\n    \n    public RealVector append(RealVector v) {\n        try {\n            return new ArrayRealVector(this, (ArrayRealVector) v);\n        } catch (ClassCastException cce) {\n            return new ArrayRealVector(this, v);\n        }\n    }\n\n    \n    public ArrayRealVector append(ArrayRealVector v) {\n        return new ArrayRealVector(this, v);\n    }\n\n    \n    public RealVector append(double in) {\n        final double[] out = new double[data.length + 1];\n        System.arraycopy(data, 0, out, 0, data.length);\n        out[data.length] = in;\n        return new ArrayRealVector(out, false);\n    }\n\n    \n    public RealVector append(double[] in) {\n        return new ArrayRealVector(this, in);\n    }\n\n    \n    public RealVector getSubVector(int index, int n) {\n        ArrayRealVector out = new ArrayRealVector(n);\n        try {\n            System.arraycopy(data, index, out.data, 0, n);\n        } catch (IndexOutOfBoundsException e) {\n            checkIndex(index);\n            checkIndex(index + n - 1);\n        }\n        return out;\n    }\n\n    \n    public void setEntry(int index, double value) {\n        try {\n            data[index] = value;\n        } catch (IndexOutOfBoundsException e) {\n            checkIndex(index);\n        }\n    }\n\n    \n    public void setSubVector(int index, RealVector v) {\n        try {\n            try {\n                set(index, (ArrayRealVector) v);\n            } catch (ClassCastException cce) {\n                for (int i = index; i < index + v.getDimension(); ++i) {\n                    data[i] = v.getEntry(i-index);\n                }\n            }\n        } catch (IndexOutOfBoundsException e) {\n            checkIndex(index);\n            checkIndex(index + v.getDimension() - 1);\n        }\n    }\n\n    \n    public void setSubVector(int index, double[] v) {\n        try {\n            System.arraycopy(v, 0, data, index, v.length);\n        } catch (IndexOutOfBoundsException e) {\n            checkIndex(index);\n            checkIndex(index + v.length - 1);\n        }\n    }\n\n    \n    public void set(int index, ArrayRealVector v) throws MatrixIndexException {\n        setSubVector(index, v.data);\n    }\n\n    \n    public void set(double value) {\n        Arrays.fill(data, value);\n    }\n\n    \n    public double[] toArray() {\n        return data.clone();\n    }\n\n    \n    @Override\n    public String toString() {\n        return DEFAULT_FORMAT.format(this);\n    }\n\n    \n    protected void checkVectorDimensions(RealVector v) throws IllegalArgumentException {\n        checkVectorDimensions(v.getDimension());\n    }\n\n    \n    protected void checkVectorDimensions(int n) throws IllegalArgumentException {\n        if (data.length != n) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                    \"vector length mismatch: got {0} but expected {1}\",\n                    data.length, n);\n        }\n    }\n\n    \n    public boolean isNaN() {\n        for (double v : data) {\n            if (Double.isNaN(v)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    \n    public boolean isInfinite() {\n\n        if (isNaN()) {\n            return false;\n        }\n\n        for (double v : data) {\n            if (Double.isInfinite(v)) {\n                return true;\n            }\n        }\n\n        return false;\n\n    }\n\n    \n    @Override\n    public boolean equals(Object other) {\n\n      if (this == other) {\n        return true;\n      }\n\n      if (other == null || !(other instanceof RealVector)) {\n        return false;\n      }\n\n\n      RealVector rhs = (RealVector) other;\n      if (data.length != rhs.getDimension()) {\n        return false;\n      }\n\n      if (rhs.isNaN()) {\n        return this.isNaN();\n      }\n\n      for (int i = 0; i < data.length; ++i) {\n        if (data[i] != rhs.getEntry(i)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    \n    @Override\n    public int hashCode() {\n        if (isNaN()) {\n            return 9;\n        }\n        return MathUtils.hash(data);\n    }\n\n}\n",
      "fixed_full_code": "\npackage org.apache.commons.math.linear;\n\nimport java.io.Serializable;\nimport java.util.Arrays;\nimport java.util.Iterator;\n\nimport org.apache.commons.math.MathRuntimeException;\nimport org.apache.commons.math.util.MathUtils;\n\n\npublic class ArrayRealVector extends AbstractRealVector implements Serializable { private static final String NON_FITTING_POSITION_AND_SIZE_MESSAGE = \"position {0} and size {1} don't fit to the size of the input array {2}\"; private static final long serialVersionUID = -1097961340710804027L; private static final RealVectorFormat DEFAULT_FORMAT = RealVectorFormat.getInstance(); protected double data[]; public ArrayRealVector() {\n        data = new double[0];\n    }\n\n    \n    public ArrayRealVector(int size) {\n        data = new double[size];\n    }\n\n    \n    public ArrayRealVector(int size, double preset) {\n        data = new double[size];\n        Arrays.fill(data, preset);\n    }\n\n    \n    public ArrayRealVector(double[] d) {\n        data = d.clone();\n    }\n\n    \n    public ArrayRealVector(double[] d, boolean copyArray) throws NullPointerException, IllegalArgumentException {\n        if (d == null) {\n            throw new NullPointerException();\n        }\n        if (d.length == 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\"vector must have at least one element\");\n        }\n        data = copyArray ? d.clone() :  d;\n    }\n\n    \n    public ArrayRealVector(double[] d, int pos, int size) {\n        if (d.length < pos + size) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  NON_FITTING_POSITION_AND_SIZE_MESSAGE, pos, size, d.length);\n        }\n        data = new double[size];\n        System.arraycopy(d, pos, data, 0, size);\n    }\n\n    \n    public ArrayRealVector(Double[] d) {\n        data = new double[d.length];\n        for (int i = 0; i < d.length; i++) {\n            data[i] = d[i].doubleValue();\n        }\n    }\n\n    \n    public ArrayRealVector(Double[] d, int pos, int size) {\n        if (d.length < pos + size) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  NON_FITTING_POSITION_AND_SIZE_MESSAGE, pos, size, d.length);\n        }\n        data = new double[size];\n        for (int i = pos; i < pos + size; i++) {\n            data[i-pos] = d[i].doubleValue();\n        }\n    }\n\n    \n    public ArrayRealVector(RealVector v) {\n        data = new double[v.getDimension()];\n        for (int i = 0; i < data.length; ++i) {\n            data[i] = v.getEntry(i);\n        }\n    }\n\n    \n    public ArrayRealVector(ArrayRealVector v) {\n        this(v, true);\n    }\n\n    \n    public ArrayRealVector(ArrayRealVector v, boolean deep) {\n        data = deep ? v.data.clone() : v.data;\n    }\n\n    \n    public ArrayRealVector(ArrayRealVector v1, ArrayRealVector v2) {\n        data = new double[v1.data.length + v2.data.length];\n        System.arraycopy(v1.data, 0, data, 0, v1.data.length);\n        System.arraycopy(v2.data, 0, data, v1.data.length, v2.data.length);\n    }\n\n    \n    public ArrayRealVector(ArrayRealVector v1, RealVector v2) {\n        final int l1 = v1.data.length;\n        final int l2 = v2.getDimension();\n        data = new double[l1 + l2];\n        System.arraycopy(v1.data, 0, data, 0, l1);\n        for (int i = 0; i < l2; ++i) {\n            data[l1 + i] = v2.getEntry(i);\n        }\n    }\n\n    \n    public ArrayRealVector(RealVector v1, ArrayRealVector v2) {\n        final int l1 = v1.getDimension();\n        final int l2 = v2.data.length;\n        data = new double[l1 + l2];\n        for (int i = 0; i < l1; ++i) {\n            data[i] = v1.getEntry(i);\n        }\n        System.arraycopy(v2.data, 0, data, l1, l2);\n    }\n\n    \n    public ArrayRealVector(ArrayRealVector v1, double[] v2) {\n        final int l1 = v1.getDimension();\n        final int l2 = v2.length;\n        data = new double[l1 + l2];\n        System.arraycopy(v1.data, 0, data, 0, l1);\n        System.arraycopy(v2, 0, data, l1, l2);\n    }\n\n    \n    public ArrayRealVector(double[] v1, ArrayRealVector v2) {\n        final int l1 = v1.length;\n        final int l2 = v2.getDimension();\n        data = new double[l1 + l2];\n        System.arraycopy(v1, 0, data, 0, l1);\n        System.arraycopy(v2.data, 0, data, l1, l2);\n    }\n\n    \n    public ArrayRealVector(double[] v1, double[] v2) {\n        final int l1 = v1.length;\n        final int l2 = v2.length;\n        data = new double[l1 + l2];\n        System.arraycopy(v1, 0, data, 0, l1);\n        System.arraycopy(v2, 0, data, l1, l2);\n    }\n\n    \n    public AbstractRealVector copy() {\n        return new ArrayRealVector(this, true);\n    }\n\n    \n    public RealVector add(RealVector v) throws IllegalArgumentException {\n        if (v instanceof ArrayRealVector) {\n            return add((ArrayRealVector) v);\n        } else {\n            checkVectorDimensions(v);\n            double[] out = data.clone();\n            Iterator<Entry> it = v.sparseIterator();\n            Entry e;\n            while (it.hasNext() && (e = it.next()) != null) {\n                out[e.getIndex()] += e.getValue();\n            }\n            return new ArrayRealVector(out, false);\n        }\n    }\n\n    \n    public RealVector add(double[] v) throws IllegalArgumentException {\n        checkVectorDimensions(v.length);\n        double[] out = data.clone();\n        for (int i = 0; i < data.length; i++) {\n            out[i] += v[i];\n        }\n        return new ArrayRealVector(out, false);\n    }\n\n    \n    public ArrayRealVector add(ArrayRealVector v) throws IllegalArgumentException {\n        return (ArrayRealVector) add(v.data);\n    }\n\n    \n    public RealVector subtract(RealVector v) throws IllegalArgumentException {\n        if (v instanceof ArrayRealVector) {\n            return subtract((ArrayRealVector) v);\n        } else {\n            checkVectorDimensions(v);\n            double[] out = data.clone();\n            Iterator<Entry> it = v.sparseIterator();\n            Entry e;\n            while(it.hasNext() && (e = it.next()) != null) {\n                out[e.getIndex()] -= e.getValue();\n            }\n            return new ArrayRealVector(out, false);\n        }\n    }\n\n    \n    public RealVector subtract(double[] v) throws IllegalArgumentException {\n        checkVectorDimensions(v.length);\n        double[] out = data.clone();\n        for (int i = 0; i < data.length; i++) {\n            out[i] -= v[i];\n        }\n        return new ArrayRealVector(out, false);\n    }\n\n    \n    public ArrayRealVector subtract(ArrayRealVector v) throws IllegalArgumentException {\n        return (ArrayRealVector) subtract(v.data);\n    }\n\n    \n    public RealVector mapAddToSelf(double d) {\n        for (int i = 0; i < data.length; i++) {\n            data[i] = data[i] + d;\n        }\n        return this;\n    }\n\n    \n    public RealVector mapSubtractToSelf(double d) {\n        for (int i = 0; i < data.length; i++) {\n            data[i] = data[i] - d;\n        }\n        return this;\n    }\n\n    \n    public RealVector mapMultiplyToSelf(double d) {\n        for (int i = 0; i < data.length; i++) {\n            data[i] = data[i] * d;\n        }\n        return this;\n    }\n\n    \n    public RealVector mapDivideToSelf(double d) {\n        for (int i = 0; i < data.length; i++) {\n            data[i] = data[i] / d;\n        }\n        return this;\n    }\n\n    \n    public RealVector mapPowToSelf(double d) {\n        for (int i = 0; i < data.length; i++) {\n            data[i] = Math.pow(data[i], d);\n        }\n        return this;\n    }\n\n    \n    public RealVector mapExpToSelf() {\n        for (int i = 0; i < data.length; i++) {\n            data[i] = Math.exp(data[i]);\n        }\n        return this;\n    }\n\n    \n    public RealVector mapExpm1ToSelf() {\n        for (int i = 0; i < data.length; i++) {\n            data[i] = Math.expm1(data[i]);\n        }\n        return this;\n    }\n\n    \n    public RealVector mapLogToSelf() {\n        for (int i = 0; i < data.length; i++) {\n            data[i] = Math.log(data[i]);\n        }\n        return this;\n    }\n\n    \n    public RealVector mapLog10ToSelf() {\n        for (int i = 0; i < data.length; i++) {\n            data[i] = Math.log10(data[i]);\n        }\n        return this;\n    }\n\n    \n    public RealVector mapLog1pToSelf() {\n        for (int i = 0; i < data.length; i++) {\n            data[i] = Math.log1p(data[i]);\n        }\n        return this;\n    }\n\n    \n    public RealVector mapCoshToSelf() {\n        for (int i = 0; i < data.length; i++) {\n            data[i] = Math.cosh(data[i]);\n        }\n        return this;\n    }\n\n    \n    public RealVector mapSinhToSelf() {\n        for (int i = 0; i < data.length; i++) {\n            data[i] = Math.sinh(data[i]);\n        }\n        return this;\n    }\n\n    \n    public RealVector mapTanhToSelf() {\n        for (int i = 0; i < data.length; i++) {\n            data[i] = Math.tanh(data[i]);\n        }\n        return this;\n    }\n\n    \n    public RealVector mapCosToSelf() {\n        for (int i = 0; i < data.length; i++) {\n            data[i] = Math.cos(data[i]);\n        }\n        return this;\n    }\n\n    \n    public RealVector mapSinToSelf() {\n        for (int i = 0; i < data.length; i++) {\n            data[i] = Math.sin(data[i]);\n        }\n        return this;\n    }\n\n    \n    public RealVector mapTanToSelf() {\n        for (int i = 0; i < data.length; i++) {\n            data[i] = Math.tan(data[i]);\n        }\n        return this;\n    }\n\n    \n    public RealVector mapAcosToSelf() {\n        for (int i = 0; i < data.length; i++) {\n            data[i] = Math.acos(data[i]);\n        }\n        return this;\n    }\n\n    \n    public RealVector mapAsinToSelf() {\n        for (int i = 0; i < data.length; i++) {\n            data[i] = Math.asin(data[i]);\n        }\n        return this;\n    }\n\n    \n    public RealVector mapAtanToSelf() {\n        for (int i = 0; i < data.length; i++) {\n            data[i] = Math.atan(data[i]);\n        }\n        return this;\n    }\n\n    \n    public RealVector mapInvToSelf() {\n        for (int i = 0; i < data.length; i++) {\n            data[i] = 1.0 / data[i];\n        }\n        return this;\n    }\n\n    \n    public RealVector mapAbsToSelf() {\n        for (int i = 0; i < data.length; i++) {\n            data[i] = Math.abs(data[i]);\n        }\n        return this;\n    }\n\n    \n    public RealVector mapSqrtToSelf() {\n        for (int i = 0; i < data.length; i++) {\n            data[i] = Math.sqrt(data[i]);\n        }\n        return this;\n    }\n\n    \n    public RealVector mapCbrtToSelf() {\n        for (int i = 0; i < data.length; i++) {\n            data[i] = Math.cbrt(data[i]);\n        }\n        return this;\n    }\n\n    \n    public RealVector mapCeilToSelf() {\n        for (int i = 0; i < data.length; i++) {\n            data[i] = Math.ceil(data[i]);\n        }\n        return this;\n    }\n\n    \n    public RealVector mapFloorToSelf() {\n        for (int i = 0; i < data.length; i++) {\n            data[i] = Math.floor(data[i]);\n        }\n        return this;\n    }\n\n    \n    public RealVector mapRintToSelf() {\n        for (int i = 0; i < data.length; i++) {\n            data[i] = Math.rint(data[i]);\n        }\n        return this;\n    }\n\n    \n    public RealVector mapSignumToSelf() {\n        for (int i = 0; i < data.length; i++) {\n            data[i] = Math.signum(data[i]);\n        }\n        return this;\n    }\n\n    \n    public RealVector mapUlpToSelf() {\n        for (int i = 0; i < data.length; i++) {\n            data[i] = Math.ulp(data[i]);\n        }\n        return this;\n    }\n\n    \n    public RealVector ebeMultiply(RealVector v) throws IllegalArgumentException {\n        if (v instanceof ArrayRealVector) {\n            return ebeMultiply((ArrayRealVector) v);\n        } else {\n            checkVectorDimensions(v);\n            double[] out = data.clone();\n            for (int i = 0; i < data.length; i++) {\n                out[i] *= v.getEntry(i);\n            }\n            return new ArrayRealVector(out, false);\n        }\n    }\n\n    \n    public RealVector ebeMultiply(double[] v) throws IllegalArgumentException {\n        checkVectorDimensions(v.length);\n        double[] out = data.clone();\n        for (int i = 0; i < data.length; i++) {\n            out[i] *= v[i];\n        }\n        return new ArrayRealVector(out, false);\n    }\n\n    \n    public ArrayRealVector ebeMultiply(ArrayRealVector v) throws IllegalArgumentException {\n        return (ArrayRealVector) ebeMultiply(v.data);\n    }\n\n    \n    public RealVector ebeDivide(RealVector v) throws IllegalArgumentException {\n        if (v instanceof ArrayRealVector) {\n            return ebeDivide((ArrayRealVector) v);\n        } else {\n            checkVectorDimensions(v);\n            double[] out = data.clone();\n            for (int i = 0; i < data.length; i++) {\n                out[i] /= v.getEntry(i);\n            }\n            return new ArrayRealVector(out, false);\n        }\n    }\n\n    \n    public RealVector ebeDivide(double[] v) throws IllegalArgumentException {\n        checkVectorDimensions(v.length);\n        double[] out = data.clone();\n        for (int i = 0; i < data.length; i++) {\n                out[i] /= v[i];\n        }\n        return new ArrayRealVector(out, false);\n    }\n\n    \n    public ArrayRealVector ebeDivide(ArrayRealVector v) throws IllegalArgumentException {\n        return (ArrayRealVector) ebeDivide(v.data);\n    }\n\n    \n    public double[] getData() {\n        return data.clone();\n    }\n\n    \n    public double[] getDataRef() {\n        return data;\n    }\n\n    \n    public double dotProduct(RealVector v) throws IllegalArgumentException {\n        if (v instanceof ArrayRealVector) {\n            return dotProduct((ArrayRealVector) v);\n        } else {\n            checkVectorDimensions(v);\n            double dot = 0;\n            Iterator<Entry> it = v.sparseIterator();\n            Entry e;\n            while(it.hasNext() && (e = it.next()) != null) {\n                dot += data[e.getIndex()] * e.getValue();\n            }\n            return dot;\n        }\n    }\n\n    \n    public double dotProduct(double[] v) throws IllegalArgumentException {\n        checkVectorDimensions(v.length);\n        double dot = 0;\n        for (int i = 0; i < data.length; i++) {\n            dot += data[i] * v[i];\n        }\n        return dot;\n    }\n\n    \n    public double dotProduct(ArrayRealVector v) throws IllegalArgumentException {\n        return dotProduct(v.data);\n    }\n\n    \n    @Override\n    public double getNorm() {\n        double sum = 0;\n        for (double a : data) {\n            sum += a * a;\n        }\n        return Math.sqrt(sum);\n    }\n\n    \n    @Override\n    public double getL1Norm() {\n        double sum = 0;\n        for (double a : data) {\n            sum += Math.abs(a);\n        }\n        return sum;\n    }\n\n    \n    @Override\n    public double getLInfNorm() {\n        double max = 0;\n        for (double a : data) {\n            max = Math.max(max, Math.abs(a));\n        }\n        return max;\n    }\n\n    \n    public double getDistance(RealVector v) throws IllegalArgumentException {\n        if (v instanceof ArrayRealVector) {\n            return getDistance((ArrayRealVector) v);\n        } else {\n            checkVectorDimensions(v);\n            double sum = 0;\n            for (int i = 0; i < data.length; ++i) {\n                final double delta = data[i] - v.getEntry(i);\n                sum += delta * delta;\n            }\n            return Math.sqrt(sum);\n        }\n    }\n\n    \n    public double getDistance(double[] v) throws IllegalArgumentException {\n        checkVectorDimensions(v.length);\n        double sum = 0;\n        for (int i = 0; i < data.length; ++i) {\n            final double delta = data[i] - v[i];\n            sum += delta * delta;\n        }\n        return Math.sqrt(sum);\n    }\n\n   \n    public double getDistance(ArrayRealVector v) throws IllegalArgumentException {\n        return getDistance(v.data);\n    }\n\n    \n    public double getL1Distance(RealVector v) throws IllegalArgumentException {\n        if (v instanceof ArrayRealVector) {\n            return getL1Distance((ArrayRealVector) v);\n        } else {\n            checkVectorDimensions(v);\n            double sum = 0;\n            for (int i = 0; i < data.length; ++i) {\n                final double delta = data[i] - v.getEntry(i);\n                sum += Math.abs(delta);\n            }\n            return sum;\n        }\n    }\n\n    \n    public double getL1Distance(double[] v) throws IllegalArgumentException {\n        checkVectorDimensions(v.length);\n        double sum = 0;\n        for (int i = 0; i < data.length; ++i) {\n            final double delta = data[i] - v[i];\n            sum += Math.abs(delta);\n        }\n        return sum;\n    }\n\n    \n    public double getL1Distance(ArrayRealVector v) throws IllegalArgumentException {\n        return getL1Distance(v.data);\n    }\n\n    \n    public double getLInfDistance(RealVector v) throws IllegalArgumentException {\n        if (v instanceof ArrayRealVector) {\n            return getLInfDistance((ArrayRealVector) v);\n        } else {\n            checkVectorDimensions(v);\n            double max = 0;\n            for (int i = 0; i < data.length; ++i) {\n                final double delta = data[i] - v.getEntry(i);\n                max = Math.max(max, Math.abs(delta));\n            }\n            return max;\n        }\n    }\n\n    \n    public double getLInfDistance(double[] v) throws IllegalArgumentException {\n        checkVectorDimensions(v.length);\n        double max = 0;\n        for (int i = 0; i < data.length; ++i) {\n            final double delta = data[i] - v[i];\n            max = Math.max(max, Math.abs(delta));\n        }\n        return max;\n    }\n\n    \n    public double getLInfDistance(ArrayRealVector v) throws IllegalArgumentException {\n        return getLInfDistance(v.data);\n    }\n\n    \n    public RealVector unitVector() throws ArithmeticException {\n        final double norm = getNorm();\n        if (norm == 0) {\n            throw MathRuntimeException.createArithmeticException(\"zero norm\");\n        }\n        return mapDivide(norm);\n    }\n\n    \n    public void unitize() throws ArithmeticException {\n        final double norm = getNorm();\n        if (norm == 0) {\n            throw MathRuntimeException.createArithmeticException(\"cannot normalize a zero norm vector\");\n        }\n        mapDivideToSelf(norm);\n    }\n\n    \n    public RealVector projection(RealVector v) {\n        return v.mapMultiply(dotProduct(v) / v.dotProduct(v));\n    }\n\n    \n    public RealVector projection(double[] v) {\n        return projection(new ArrayRealVector(v, false));\n    }\n\n   \n    public ArrayRealVector projection(ArrayRealVector v) {\n        return (ArrayRealVector) v.mapMultiply(dotProduct(v) / v.dotProduct(v));\n    }\n\n    \n    public RealMatrix outerProduct(RealVector v) throws IllegalArgumentException {\n        if (v instanceof ArrayRealVector) {\n            return outerProduct((ArrayRealVector) v);\n        } else {\n            checkVectorDimensions(v);\n            final int m = data.length;\n            final RealMatrix out = MatrixUtils.createRealMatrix(m, m);\n            for (int i = 0; i < data.length; i++) {\n                for (int j = 0; j < data.length; j++) {\n                    out.setEntry(i, j, data[i] * v.getEntry(j));\n                }\n            }\n            return out;\n        }\n    }\n\n    \n    public RealMatrix outerProduct(ArrayRealVector v) throws IllegalArgumentException {\n        return outerProduct(v.data);\n    }\n\n    \n    public RealMatrix outerProduct(double[] v) throws IllegalArgumentException {\n        checkVectorDimensions(v.length);\n        final int m = data.length;\n        final RealMatrix out = MatrixUtils.createRealMatrix(m, m);\n        for (int i = 0; i < data.length; i++) {\n            for (int j = 0; j < data.length; j++) {\n                out.setEntry(i, j, data[i] * v[j]);\n            }\n        }\n        return out;\n    }\n\n    \n    public double getEntry(int index) throws MatrixIndexException {\n        return data[index];\n    }\n\n    \n    public int getDimension() {\n        return data.length;\n    }\n\n    \n    public RealVector append(RealVector v) {\n        try {\n            return new ArrayRealVector(this, (ArrayRealVector) v);\n        } catch (ClassCastException cce) {\n            return new ArrayRealVector(this, v);\n        }\n    }\n\n    \n    public ArrayRealVector append(ArrayRealVector v) {\n        return new ArrayRealVector(this, v);\n    }\n\n    \n    public RealVector append(double in) {\n        final double[] out = new double[data.length + 1];\n        System.arraycopy(data, 0, out, 0, data.length);\n        out[data.length] = in;\n        return new ArrayRealVector(out, false);\n    }\n\n    \n    public RealVector append(double[] in) {\n        return new ArrayRealVector(this, in);\n    }\n\n    \n    public RealVector getSubVector(int index, int n) {\n        ArrayRealVector out = new ArrayRealVector(n);\n        try {\n            System.arraycopy(data, index, out.data, 0, n);\n        } catch (IndexOutOfBoundsException e) {\n            checkIndex(index);\n            checkIndex(index + n - 1);\n        }\n        return out;\n    }\n\n    \n    public void setEntry(int index, double value) {\n        try {\n            data[index] = value;\n        } catch (IndexOutOfBoundsException e) {\n            checkIndex(index);\n        }\n    }\n\n    \n    public void setSubVector(int index, RealVector v) {\n        try {\n            try {\n                set(index, (ArrayRealVector) v);\n            } catch (ClassCastException cce) {\n                for (int i = index; i < index + v.getDimension(); ++i) {\n                    data[i] = v.getEntry(i-index);\n                }\n            }\n        } catch (IndexOutOfBoundsException e) {\n            checkIndex(index);\n            checkIndex(index + v.getDimension() - 1);\n        }\n    }\n\n    \n    public void setSubVector(int index, double[] v) {\n        try {\n            System.arraycopy(v, 0, data, index, v.length);\n        } catch (IndexOutOfBoundsException e) {\n            checkIndex(index);\n            checkIndex(index + v.length - 1);\n        }\n    }\n\n    \n    public void set(int index, ArrayRealVector v) throws MatrixIndexException {\n        setSubVector(index, v.data);\n    }\n\n    \n    public void set(double value) {\n        Arrays.fill(data, value);\n    }\n\n    \n    public double[] toArray() {\n        return data.clone();\n    }\n\n    \n    @Override\n    public String toString() {\n        return DEFAULT_FORMAT.format(this);\n    }\n\n    \n    protected void checkVectorDimensions(RealVector v) throws IllegalArgumentException {\n        checkVectorDimensions(v.getDimension());\n    }\n\n    \n    protected void checkVectorDimensions(int n) throws IllegalArgumentException {\n        if (data.length != n) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                    \"vector length mismatch: got {0} but expected {1}\",\n                    data.length, n);\n        }\n    }\n\n    \n    public boolean isNaN() {\n        for (double v : data) {\n            if (Double.isNaN(v)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    \n    public boolean isInfinite() {\n\n        if (isNaN()) {\n            return false;\n        }\n\n        for (double v : data) {\n            if (Double.isInfinite(v)) {\n                return true;\n            }\n        }\n\n        return false;\n\n    }\n\n    \n    @Override\n    public boolean equals(Object other) {\n\n      if (this == other) {\n        return true;\n      }\n\n      if (other == null || !(other instanceof RealVector)) {\n        return false;\n      }\n\n\n      RealVector rhs = (RealVector) other;\n      if (data.length != rhs.getDimension()) {\n        return false;\n      }\n\n      if (rhs.isNaN()) {\n        return this.isNaN();\n      }\n\n      for (int i = 0; i < data.length; ++i) {\n        if (data[i] != rhs.getEntry(i)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    \n    @Override\n    public int hashCode() {\n        if (isNaN()) {\n            return 9;\n        }\n        return MathUtils.hash(data);\n    }\n\n}\n",
      "buggy_signatures": [
        "public ArrayRealVector(int size)",
        "public ArrayRealVector(int size, double preset)",
        "public ArrayRealVector(double[] d)",
        "public ArrayRealVector(double[] d, boolean copyArray) throws NullPointerException, IllegalArgumentException",
        "public ArrayRealVector(double[] d, int pos, int size)",
        "public ArrayRealVector(Double[] d)",
        "public ArrayRealVector(Double[] d, int pos, int size)",
        "public ArrayRealVector(RealVector v)",
        "public ArrayRealVector(ArrayRealVector v)",
        "public ArrayRealVector(ArrayRealVector v, boolean deep)",
        "public ArrayRealVector(ArrayRealVector v1, ArrayRealVector v2)",
        "public ArrayRealVector(ArrayRealVector v1, RealVector v2)",
        "public ArrayRealVector(RealVector v1, ArrayRealVector v2)",
        "public ArrayRealVector(ArrayRealVector v1, double[] v2)",
        "public ArrayRealVector(double[] v1, ArrayRealVector v2)",
        "public ArrayRealVector(double[] v1, double[] v2)",
        "public AbstractRealVector copy()",
        "public RealVector add(RealVector v) throws IllegalArgumentException",
        "public RealVector add(double[] v) throws IllegalArgumentException",
        "public ArrayRealVector add(ArrayRealVector v) throws IllegalArgumentException",
        "public RealVector subtract(RealVector v) throws IllegalArgumentException",
        "public RealVector subtract(double[] v) throws IllegalArgumentException",
        "public ArrayRealVector subtract(ArrayRealVector v) throws IllegalArgumentException",
        "public RealVector mapAddToSelf(double d)",
        "public RealVector mapSubtractToSelf(double d)",
        "public RealVector mapMultiplyToSelf(double d)",
        "public RealVector mapDivideToSelf(double d)",
        "public RealVector mapPowToSelf(double d)",
        "public RealVector mapExpToSelf()",
        "public RealVector mapExpm1ToSelf()",
        "public RealVector mapLogToSelf()",
        "public RealVector mapLog10ToSelf()",
        "public RealVector mapLog1pToSelf()",
        "public RealVector mapCoshToSelf()",
        "public RealVector mapSinhToSelf()",
        "public RealVector mapTanhToSelf()",
        "public RealVector mapCosToSelf()",
        "public RealVector mapSinToSelf()",
        "public RealVector mapTanToSelf()",
        "public RealVector mapAcosToSelf()",
        "public RealVector mapAsinToSelf()",
        "public RealVector mapAtanToSelf()",
        "public RealVector mapInvToSelf()",
        "public RealVector mapAbsToSelf()",
        "public RealVector mapSqrtToSelf()",
        "public RealVector mapCbrtToSelf()",
        "public RealVector mapCeilToSelf()",
        "public RealVector mapFloorToSelf()",
        "public RealVector mapRintToSelf()",
        "public RealVector mapSignumToSelf()",
        "public RealVector mapUlpToSelf()",
        "public RealVector ebeMultiply(RealVector v) throws IllegalArgumentException",
        "public RealVector ebeMultiply(double[] v) throws IllegalArgumentException",
        "public ArrayRealVector ebeMultiply(ArrayRealVector v) throws IllegalArgumentException",
        "public RealVector ebeDivide(RealVector v) throws IllegalArgumentException",
        "public RealVector ebeDivide(double[] v) throws IllegalArgumentException",
        "public ArrayRealVector ebeDivide(ArrayRealVector v) throws IllegalArgumentException",
        "public double[] getData()",
        "public double[] getDataRef()",
        "public double dotProduct(RealVector v) throws IllegalArgumentException",
        "public double dotProduct(double[] v) throws IllegalArgumentException",
        "public double dotProduct(ArrayRealVector v) throws IllegalArgumentException",
        "public double getNorm()",
        "public double getL1Norm()",
        "public double getLInfNorm()",
        "public double getDistance(RealVector v) throws IllegalArgumentException",
        "public double getDistance(double[] v) throws IllegalArgumentException",
        "public double getDistance(ArrayRealVector v) throws IllegalArgumentException",
        "public double getL1Distance(RealVector v) throws IllegalArgumentException",
        "public double getL1Distance(double[] v) throws IllegalArgumentException",
        "public double getL1Distance(ArrayRealVector v) throws IllegalArgumentException",
        "public double getLInfDistance(RealVector v) throws IllegalArgumentException",
        "public double getLInfDistance(double[] v) throws IllegalArgumentException",
        "public double getLInfDistance(ArrayRealVector v) throws IllegalArgumentException",
        "public RealVector unitVector() throws ArithmeticException",
        "public void unitize() throws ArithmeticException",
        "public RealVector projection(RealVector v)",
        "public RealVector projection(double[] v)",
        "public ArrayRealVector projection(ArrayRealVector v)",
        "public RealMatrix outerProduct(RealVector v) throws IllegalArgumentException",
        "public RealMatrix outerProduct(ArrayRealVector v) throws IllegalArgumentException",
        "public RealMatrix outerProduct(double[] v) throws IllegalArgumentException",
        "public double getEntry(int index) throws MatrixIndexException",
        "public int getDimension()",
        "public RealVector append(RealVector v)",
        "public ArrayRealVector append(ArrayRealVector v)",
        "public RealVector append(double in)",
        "public RealVector append(double[] in)",
        "public RealVector getSubVector(int index, int n)",
        "public void setEntry(int index, double value)",
        "public void setSubVector(int index, RealVector v)",
        "public void setSubVector(int index, double[] v)",
        "public void set(int index, ArrayRealVector v) throws MatrixIndexException",
        "public void set(double value)",
        "public double[] toArray()",
        "public String toString()",
        "protected void checkVectorDimensions(RealVector v) throws IllegalArgumentException",
        "protected void checkVectorDimensions(int n) throws IllegalArgumentException",
        "public boolean isNaN()",
        "public boolean isInfinite()",
        "public boolean equals(Object other)",
        "public int hashCode()"
      ],
      "fixed_signatures": [
        "public ArrayRealVector(int size)",
        "public ArrayRealVector(int size, double preset)",
        "public ArrayRealVector(double[] d)",
        "public ArrayRealVector(double[] d, boolean copyArray) throws NullPointerException, IllegalArgumentException",
        "public ArrayRealVector(double[] d, int pos, int size)",
        "public ArrayRealVector(Double[] d)",
        "public ArrayRealVector(Double[] d, int pos, int size)",
        "public ArrayRealVector(RealVector v)",
        "public ArrayRealVector(ArrayRealVector v)",
        "public ArrayRealVector(ArrayRealVector v, boolean deep)",
        "public ArrayRealVector(ArrayRealVector v1, ArrayRealVector v2)",
        "public ArrayRealVector(ArrayRealVector v1, RealVector v2)",
        "public ArrayRealVector(RealVector v1, ArrayRealVector v2)",
        "public ArrayRealVector(ArrayRealVector v1, double[] v2)",
        "public ArrayRealVector(double[] v1, ArrayRealVector v2)",
        "public ArrayRealVector(double[] v1, double[] v2)",
        "public AbstractRealVector copy()",
        "public RealVector add(RealVector v) throws IllegalArgumentException",
        "public RealVector add(double[] v) throws IllegalArgumentException",
        "public ArrayRealVector add(ArrayRealVector v) throws IllegalArgumentException",
        "public RealVector subtract(RealVector v) throws IllegalArgumentException",
        "public RealVector subtract(double[] v) throws IllegalArgumentException",
        "public ArrayRealVector subtract(ArrayRealVector v) throws IllegalArgumentException",
        "public RealVector mapAddToSelf(double d)",
        "public RealVector mapSubtractToSelf(double d)",
        "public RealVector mapMultiplyToSelf(double d)",
        "public RealVector mapDivideToSelf(double d)",
        "public RealVector mapPowToSelf(double d)",
        "public RealVector mapExpToSelf()",
        "public RealVector mapExpm1ToSelf()",
        "public RealVector mapLogToSelf()",
        "public RealVector mapLog10ToSelf()",
        "public RealVector mapLog1pToSelf()",
        "public RealVector mapCoshToSelf()",
        "public RealVector mapSinhToSelf()",
        "public RealVector mapTanhToSelf()",
        "public RealVector mapCosToSelf()",
        "public RealVector mapSinToSelf()",
        "public RealVector mapTanToSelf()",
        "public RealVector mapAcosToSelf()",
        "public RealVector mapAsinToSelf()",
        "public RealVector mapAtanToSelf()",
        "public RealVector mapInvToSelf()",
        "public RealVector mapAbsToSelf()",
        "public RealVector mapSqrtToSelf()",
        "public RealVector mapCbrtToSelf()",
        "public RealVector mapCeilToSelf()",
        "public RealVector mapFloorToSelf()",
        "public RealVector mapRintToSelf()",
        "public RealVector mapSignumToSelf()",
        "public RealVector mapUlpToSelf()",
        "public RealVector ebeMultiply(RealVector v) throws IllegalArgumentException",
        "public RealVector ebeMultiply(double[] v) throws IllegalArgumentException",
        "public ArrayRealVector ebeMultiply(ArrayRealVector v) throws IllegalArgumentException",
        "public RealVector ebeDivide(RealVector v) throws IllegalArgumentException",
        "public RealVector ebeDivide(double[] v) throws IllegalArgumentException",
        "public ArrayRealVector ebeDivide(ArrayRealVector v) throws IllegalArgumentException",
        "public double[] getData()",
        "public double[] getDataRef()",
        "public double dotProduct(RealVector v) throws IllegalArgumentException",
        "public double dotProduct(double[] v) throws IllegalArgumentException",
        "public double dotProduct(ArrayRealVector v) throws IllegalArgumentException",
        "public double getNorm()",
        "public double getL1Norm()",
        "public double getLInfNorm()",
        "public double getDistance(RealVector v) throws IllegalArgumentException",
        "public double getDistance(double[] v) throws IllegalArgumentException",
        "public double getDistance(ArrayRealVector v) throws IllegalArgumentException",
        "public double getL1Distance(RealVector v) throws IllegalArgumentException",
        "public double getL1Distance(double[] v) throws IllegalArgumentException",
        "public double getL1Distance(ArrayRealVector v) throws IllegalArgumentException",
        "public double getLInfDistance(RealVector v) throws IllegalArgumentException",
        "public double getLInfDistance(double[] v) throws IllegalArgumentException",
        "public double getLInfDistance(ArrayRealVector v) throws IllegalArgumentException",
        "public RealVector unitVector() throws ArithmeticException",
        "public void unitize() throws ArithmeticException",
        "public RealVector projection(RealVector v)",
        "public RealVector projection(double[] v)",
        "public ArrayRealVector projection(ArrayRealVector v)",
        "public RealMatrix outerProduct(RealVector v) throws IllegalArgumentException",
        "public RealMatrix outerProduct(ArrayRealVector v) throws IllegalArgumentException",
        "public RealMatrix outerProduct(double[] v) throws IllegalArgumentException",
        "public double getEntry(int index) throws MatrixIndexException",
        "public int getDimension()",
        "public RealVector append(RealVector v)",
        "public ArrayRealVector append(ArrayRealVector v)",
        "public RealVector append(double in)",
        "public RealVector append(double[] in)",
        "public RealVector getSubVector(int index, int n)",
        "public void setEntry(int index, double value)",
        "public void setSubVector(int index, RealVector v)",
        "public void setSubVector(int index, double[] v)",
        "public void set(int index, ArrayRealVector v) throws MatrixIndexException",
        "public void set(double value)",
        "public double[] toArray()",
        "public String toString()",
        "protected void checkVectorDimensions(RealVector v) throws IllegalArgumentException",
        "protected void checkVectorDimensions(int n) throws IllegalArgumentException",
        "public boolean isNaN()",
        "public boolean isInfinite()",
        "public boolean equals(Object other)",
        "public int hashCode()"
      ],
      "methods": [
        {
          "buggy_method": "  public double getLInfNorm() {\n  double max = 0;\n  for (double a : data) {\n  max += Math.max(max, Math.abs(a));\n  }\n  return max;\n  }",
          "fixed_method": "  public double getLInfNorm() {\n  double max = 0;\n  for (double a : data) {\n  max = Math.max(max, Math.abs(a));\n  }\n  return max;\n  }",
          "diff": [
            "@@ -718,7 +718,7 @@",
            "     public double getLInfNorm() {\n",
            "         double max = 0;\n",
            "         for (double a : data) {\n",
            "-            max += Math.max(max, Math.abs(a));\n",
            "+            max = Math.max(max, Math.abs(a));\n",
            "         }\n",
            "         return max;\n",
            "     }\n"
          ],
          "changed_lines": 2
        }
      ]
    },
    {
      "name": "org/apache/commons/math/linear/OpenMapRealVector.java",
      "buggy_full_code": "\npackage org.apache.commons.math.linear;\n\nimport java.io.Serializable;\n\nimport org.apache.commons.math.MathRuntimeException;\nimport org.apache.commons.math.util.OpenIntToDoubleHashMap;\nimport org.apache.commons.math.util.OpenIntToDoubleHashMap.Iterator;\n\n\npublic class OpenMapRealVector extends AbstractRealVector implements SparseRealVector, Serializable { public static final double DEFAULT_ZERO_TOLERANCE = 1.0e-12; private static final long serialVersionUID = 8772222695580707260L; private final OpenIntToDoubleHashMap entries; private final int virtualSize; private double epsilon; public OpenMapRealVector() {\n        this(0, DEFAULT_ZERO_TOLERANCE);\n    }\n\n    \n    public OpenMapRealVector(int dimension) {\n        this(dimension, DEFAULT_ZERO_TOLERANCE);\n    }\n\n    \n    public OpenMapRealVector(int dimension, double epsilon) {\n        virtualSize = dimension;\n        entries = new OpenIntToDoubleHashMap(0.0);\n        this.epsilon = epsilon;\n    }\n\n    \n    protected OpenMapRealVector(OpenMapRealVector v, int resize) {\n        virtualSize = v.getDimension() + resize;\n        entries = new OpenIntToDoubleHashMap(v.entries);\n        epsilon = v.epsilon;\n    }\n\n    \n    public OpenMapRealVector(int dimension, int expectedSize) {\n        this(dimension, expectedSize, DEFAULT_ZERO_TOLERANCE);\n    }\n\n    \n    public OpenMapRealVector(int dimension, int expectedSize, double epsilon) {\n        virtualSize = dimension;\n        entries = new OpenIntToDoubleHashMap(expectedSize, 0.0);\n        this.epsilon = epsilon;\n    }\n\n    \n    public OpenMapRealVector(double[] values) {\n        this(values, DEFAULT_ZERO_TOLERANCE);\n    }\n\n    \n    public OpenMapRealVector(double[] values, double epsilon) {\n        virtualSize = values.length;\n        entries = new OpenIntToDoubleHashMap(0.0);\n        this.epsilon = epsilon;\n        for (int key = 0; key < values.length; key++) {\n            double value = values[key];\n            if (!isDefaultValue(value)) {\n                entries.put(key, value);\n            }\n        }\n    }\n\n    \n    public OpenMapRealVector(Double[] values) {\n        this(values, DEFAULT_ZERO_TOLERANCE);\n    }\n\n    \n    public OpenMapRealVector(Double[] values, double epsilon) {\n        virtualSize = values.length;\n        entries = new OpenIntToDoubleHashMap(0.0);\n        this.epsilon = epsilon;\n        for (int key = 0; key < values.length; key++) {\n            double value = values[key].doubleValue();\n            if (!isDefaultValue(value)) {\n                entries.put(key, value);\n            }\n        }\n    }\n\n    \n    public OpenMapRealVector(OpenMapRealVector v) {\n        virtualSize = v.getDimension();\n        entries = new OpenIntToDoubleHashMap(v.getEntries());\n        epsilon = v.epsilon;\n    }\n\n    \n    public OpenMapRealVector(RealVector v) {\n        virtualSize = v.getDimension();\n        entries = new OpenIntToDoubleHashMap(0.0);\n        epsilon = DEFAULT_ZERO_TOLERANCE;\n        for (int key = 0; key < virtualSize; key++) {\n            double value = v.getEntry(key);\n            if (!isDefaultValue(value)) {\n                entries.put(key, value);\n            }\n        }\n    }\n\n    \n    private OpenIntToDoubleHashMap getEntries() {\n        return entries;\n    }\n\n    \n    protected boolean isDefaultValue(double value) {\n        return Math.abs(value) < epsilon;\n    }\n\n    \n    public RealVector add(RealVector v) throws IllegalArgumentException {\n        checkVectorDimensions(v.getDimension());\n        if (v instanceof OpenMapRealVector) {\n            return add((OpenMapRealVector) v);\n        } else {\n            return super.add(v);\n        }\n    }\n\n    \n    public OpenMapRealVector add(OpenMapRealVector v) throws IllegalArgumentException {\n        checkVectorDimensions(v.getDimension());\n        boolean copyThis = entries.size() > v.entries.size();\n        OpenMapRealVector res = copyThis ? this.copy() : v.copy();\n        Iterator iter = copyThis ? v.entries.iterator() : entries.iterator();\n        OpenIntToDoubleHashMap randomAccess = copyThis ? entries : v.entries;\n        while (iter.hasNext()) {\n            iter.advance();\n            int key = iter.key();\n            if (randomAccess.containsKey(key)) {\n                res.setEntry(key, randomAccess.get(key) + iter.value());\n            } else {\n                res.setEntry(key, iter.value());\n            }\n        }\n        return res;\n    }\n\n    \n    public OpenMapRealVector append(OpenMapRealVector v) {\n        OpenMapRealVector res = new OpenMapRealVector(this, v.getDimension());\n        Iterator iter = v.entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            res.setEntry(iter.key() + virtualSize, iter.value());\n        }\n        return res;\n    }\n\n    \n    public OpenMapRealVector append(RealVector v) {\n        if (v instanceof OpenMapRealVector) {\n            return append((OpenMapRealVector) v);\n        }\n        return append(v.getData());\n    }\n\n    \n    public OpenMapRealVector append(double d) {\n        OpenMapRealVector res = new OpenMapRealVector(this, 1);\n        res.setEntry(virtualSize, d);\n        return res;\n    }\n\n    \n    public OpenMapRealVector append(double[] a) {\n        OpenMapRealVector res = new OpenMapRealVector(this, a.length);\n        for (int i = 0; i < a.length; i++) {\n            res.setEntry(i + virtualSize, a[i]);\n        }\n        return res;\n    }\n\n    \n    public OpenMapRealVector copy() {\n        return new OpenMapRealVector(this);\n    }\n\n    \n    public double dotProduct(OpenMapRealVector v) throws IllegalArgumentException {\n        checkVectorDimensions(v.getDimension());\n        boolean thisIsSmaller  = entries.size() < v.entries.size();\n        Iterator iter = thisIsSmaller  ? entries.iterator() : v.entries.iterator();\n        OpenIntToDoubleHashMap larger = thisIsSmaller  ? v.entries : entries;\n        double d = 0;\n        while(iter.hasNext()) {\n            iter.advance();\n            d += iter.value() * larger.get(iter.key());\n        }\n        return d;\n    }\n\n    \n    public double dotProduct(RealVector v) throws IllegalArgumentException {\n        if(v instanceof OpenMapRealVector) {\n            return dotProduct((OpenMapRealVector)v);\n        } else {\n            return super.dotProduct(v);\n        }\n    }\n\n    \n    public OpenMapRealVector ebeDivide(RealVector v) throws IllegalArgumentException {\n        checkVectorDimensions(v.getDimension());\n        OpenMapRealVector res = new OpenMapRealVector(this);\n        Iterator iter = res.entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            res.setEntry(iter.key(), iter.value() / v.getEntry(iter.key()));\n        }\n        return res;\n    }\n\n    \n    public OpenMapRealVector ebeDivide(double[] v) throws IllegalArgumentException {\n        checkVectorDimensions(v.length);\n        OpenMapRealVector res = new OpenMapRealVector(this);\n        Iterator iter = res.entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            res.setEntry(iter.key(), iter.value() / v[iter.key()]);\n        }\n        return res;\n    }\n\n    \n    public OpenMapRealVector ebeMultiply(RealVector v) throws IllegalArgumentException {\n        checkVectorDimensions(v.getDimension());\n        OpenMapRealVector res = new OpenMapRealVector(this);\n        Iterator iter = res.entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key()));\n        }\n        return res;\n    }\n\n    \n    public OpenMapRealVector ebeMultiply(double[] v) throws IllegalArgumentException {\n        checkVectorDimensions(v.length);\n        OpenMapRealVector res = new OpenMapRealVector(this);\n        Iterator iter = res.entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            res.setEntry(iter.key(), iter.value() * v[iter.key()]);\n        }\n        return res;\n    }\n\n    \n    public OpenMapRealVector getSubVector(int index, int n) throws MatrixIndexException {\n        checkIndex(index);\n        checkIndex(index + n - 1);\n        OpenMapRealVector res = new OpenMapRealVector(n);\n        int end = index + n;\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            int key = iter.key();\n            if (key >= index && key < end) {\n                res.setEntry(key - index, iter.value());\n            }\n        }\n        return res;\n    }\n\n    \n    public double[] getData() {\n        double[] res = new double[virtualSize];\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            res[iter.key()] = iter.value();\n        }\n        return res;\n    }\n\n    \n    public int getDimension() {\n        return virtualSize;\n    }\n\n    \n    public double getDistance(OpenMapRealVector v) throws IllegalArgumentException {\n        Iterator iter = entries.iterator();\n        double res = 0;\n        while (iter.hasNext()) {\n            iter.advance();\n            int key = iter.key();\n            double delta;\n            delta = iter.value() - v.getEntry(key);\n            res += delta * delta;\n        }\n        iter = v.getEntries().iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            int key = iter.key();\n            if (!entries.containsKey(key)) {\n                final double value = iter.value();\n                res += value * value;\n            }\n        }\n        return Math.sqrt(res);\n    }\n\n    \n    public double getDistance(RealVector v) throws IllegalArgumentException {\n        checkVectorDimensions(v.getDimension());\n        if (v instanceof OpenMapRealVector) {\n            return getDistance((OpenMapRealVector) v);\n        }\n        return getDistance(v.getData());\n    }\n\n    \n    public double getDistance(double[] v) throws IllegalArgumentException {\n        checkVectorDimensions(v.length);\n        double res = 0;\n        for (int i = 0; i < v.length; i++) {\n            double delta = entries.get(i) - v[i];\n            res += delta * delta;\n        }\n        return Math.sqrt(res);\n    }\n\n    \n    public double getEntry(int index) throws MatrixIndexException {\n        checkIndex(index);\n        return entries.get(index);\n    }\n\n    \n    public double getL1Distance(OpenMapRealVector v) {\n        double max = 0;\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            double delta = Math.abs(iter.value() - v.getEntry(iter.key()));\n            max += delta;\n        }\n        iter = v.getEntries().iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            int key = iter.key();\n            if (!entries.containsKey(key)) {\n                double delta = Math.abs(iter.value());\n                max +=  Math.abs(delta);\n            }\n        }\n        return max;\n    }\n\n    \n    public double getL1Distance(RealVector v) throws IllegalArgumentException {\n        checkVectorDimensions(v.getDimension());\n        if (v instanceof OpenMapRealVector) {\n            return getL1Distance((OpenMapRealVector) v);\n        }\n        return getL1Distance(v.getData());\n    }\n\n    \n    public double getL1Distance(double[] v) throws IllegalArgumentException {\n        checkVectorDimensions(v.length);\n        double max = 0;\n        for (int i = 0; i < v.length; i++) {\n            double delta = Math.abs(getEntry(i) - v[i]);\n            max += delta;\n        }\n        return max;\n    }\n\n    public double getLInfNorm() {\n        double max = 0;\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            max += iter.value();\n        }\n        return max;\n    }\n    \n    private double getLInfDistance(OpenMapRealVector v) {\n        double max = 0;\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            double delta = Math.abs(iter.value() - v.getEntry(iter.key()));\n            if (delta > max) {\n                max = delta;\n            }\n        }\n        iter = v.getEntries().iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            int key = iter.key();\n            if (!entries.containsKey(key)) {\n                if (iter.value() > max) {\n                    max = iter.value();\n                }\n            }\n        }\n        return max;\n    }\n\n    \n    public double getLInfDistance(RealVector v) throws IllegalArgumentException {\n        checkVectorDimensions(v.getDimension());\n        if (v instanceof OpenMapRealVector) {\n            return getLInfDistance((OpenMapRealVector) v);\n        }\n        return getLInfDistance(v.getData());\n    }\n\n    \n    public double getLInfDistance(double[] v) throws IllegalArgumentException {\n        checkVectorDimensions(v.length);\n        double max = 0;\n        for (int i = 0; i < v.length; i++) {\n            double delta = Math.abs(getEntry(i) - v[i]);\n            if (delta > max) {\n                max = delta;\n            }\n        }\n        return max;\n    }\n\n    \n    public boolean isInfinite() {\n        boolean infiniteFound = false;\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            final double value = iter.value();\n            if (Double.isNaN(value)) {\n                return false;\n            }\n            if (Double.isInfinite(value)) {\n                infiniteFound = true;\n            }\n        }\n        return infiniteFound;\n    }\n\n    \n    public boolean isNaN() {\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            if (Double.isNaN(iter.value())) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    \n    public OpenMapRealVector mapAdd(double d) {\n        return copy().mapAddToSelf(d);\n    }\n\n    \n    public OpenMapRealVector mapAddToSelf(double d) {\n        for (int i = 0; i < virtualSize; i++) {\n            setEntry(i, getEntry(i) + d);\n        }\n        return this;\n    }\n\n     \n    public RealMatrix outerProduct(double[] v) throws IllegalArgumentException {\n        checkVectorDimensions(v.length);\n        RealMatrix res = new OpenMapRealMatrix(virtualSize, virtualSize);\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            int row = iter.key();\n            double value = iter.value();\n            for (int col = 0; col < virtualSize; col++) {\n                res.setEntry(row, col, value * v[col]);\n            }\n        }\n        return res;\n    }\n\n    \n    public RealVector projection(RealVector v) throws IllegalArgumentException {\n        checkVectorDimensions(v.getDimension());\n        return v.mapMultiply(dotProduct(v) / v.dotProduct(v));\n    }\n\n    \n    public OpenMapRealVector projection(double[] v) throws IllegalArgumentException {\n        checkVectorDimensions(v.length);\n        return (OpenMapRealVector) projection(new OpenMapRealVector(v));\n    }\n\n    \n    public void setEntry(int index, double value) throws MatrixIndexException {\n        checkIndex(index);\n        if (!isDefaultValue(value)) {\n            entries.put(index, value);\n        } else if (entries.containsKey(index)) {\n            entries.remove(index);\n        }\n    }\n\n    \n    public void setSubVector(int index, RealVector v) throws MatrixIndexException {\n        checkIndex(index);\n        checkIndex(index + v.getDimension() - 1);\n        setSubVector(index, v.getData());\n    }\n\n    \n    public void setSubVector(int index, double[] v) throws MatrixIndexException {\n        checkIndex(index);\n        checkIndex(index + v.length - 1);\n        for (int i = 0; i < v.length; i++) {\n            setEntry(i + index, v[i]);\n        }\n    }\n\n    \n    public void set(double value) {\n        for (int i = 0; i < virtualSize; i++) {\n            setEntry(i, value);\n        }\n    }\n\n    \n    public OpenMapRealVector subtract(OpenMapRealVector v) throws IllegalArgumentException {\n        checkVectorDimensions(v.getDimension());\n        OpenMapRealVector res = copy();\n        Iterator iter = v.getEntries().iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            int key = iter.key();\n            if (entries.containsKey(key)) {\n                res.setEntry(key, entries.get(key) - iter.value());\n            } else {\n                res.setEntry(key, -iter.value());\n            }\n        }\n        return res;\n    }\n\n    \n    public OpenMapRealVector subtract(RealVector v) throws IllegalArgumentException {\n        checkVectorDimensions(v.getDimension());\n        if (v instanceof OpenMapRealVector) {\n            return subtract((OpenMapRealVector) v);\n        }\n        return subtract(v.getData());\n    }\n\n    \n    public OpenMapRealVector subtract(double[] v) throws IllegalArgumentException {\n        checkVectorDimensions(v.length);\n        OpenMapRealVector res = new OpenMapRealVector(this);\n        for (int i = 0; i < v.length; i++) {\n            if (entries.containsKey(i)) {\n                res.setEntry(i, entries.get(i) - v[i]);\n            } else {\n                res.setEntry(i, -v[i]);\n            }\n        }\n        return res;\n    }\n\n\n    \n    public OpenMapRealVector unitVector() {\n        OpenMapRealVector res = copy();\n        res.unitize();\n        return res;\n    }\n\n    \n    public void unitize() {\n        double norm = getNorm();\n        if (isDefaultValue(norm)) {\n            throw  MathRuntimeException.createArithmeticException(\"cannot normalize a zero norm vector\");\n        }\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            entries.put(iter.key(), iter.value() / norm);\n        }\n\n    }\n\n\n    \n    public double[] toArray() {\n        return getData();\n    }\n\n    \n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        long temp;\n        temp = Double.doubleToLongBits(epsilon);\n        result = prime * result + (int) (temp ^ (temp >>> 32));\n        result = prime * result + virtualSize;\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            temp = Double.doubleToLongBits(iter.value());\n            result = prime * result + (int) (temp ^ (temp >>32));\n        }\n        return result;\n    }\n\n    \n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (!(obj instanceof OpenMapRealVector)) {\n            return false;\n        }\n        OpenMapRealVector other = (OpenMapRealVector) obj;\n        if (virtualSize != other.virtualSize) {\n            return false;\n        }\n        if (Double.doubleToLongBits(epsilon) !=\n            Double.doubleToLongBits(other.epsilon)) {\n            return false;\n        }\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            double test = other.getEntry(iter.key());\n            if (Double.doubleToLongBits(test) != Double.doubleToLongBits(iter.value())) {\n                return false;\n            }\n        }\n        iter = other.getEntries().iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            double test = iter.value();\n            if (Double.doubleToLongBits(test) != Double.doubleToLongBits(getEntry(iter.key()))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public double getSparcity() {\n        return (double)entries.size()/(double)getDimension();\n    }\n\n    \n    public java.util.Iterator<Entry> sparseIterator() {\n        return new OpenMapSparseIterator();\n    }\n\n    \n    protected class OpenMapEntry extends Entry { private final Iterator iter; protected OpenMapEntry(Iterator iter) {\n            this.iter = iter;\n        }\n\n        \n        @Override\n        public double getValue() {\n            return iter.value();\n        }\n\n        \n        @Override\n        public void setValue(double value) {\n            entries.put(iter.key(), value);\n        }\n\n        \n        @Override\n        public int getIndex() {\n            return iter.key();\n        }\n\n    }\n\n    \n    protected class OpenMapSparseIterator implements java.util.Iterator<Entry> { private final Iterator iter; private final Entry current; protected OpenMapSparseIterator() {\n            iter = entries.iterator();\n            current = new OpenMapEntry(iter);\n        }\n\n        \n        public boolean hasNext() {\n            return iter.hasNext();\n        }\n\n        \n        public Entry next() {\n            iter.advance();\n            return current;\n        }\n\n        \n        public void remove() {\n            throw new UnsupportedOperationException(\"Not supported\");\n       }\n\n    }\n}\n",
      "fixed_full_code": "\npackage org.apache.commons.math.linear;\n\nimport java.io.Serializable;\n\nimport org.apache.commons.math.MathRuntimeException;\nimport org.apache.commons.math.util.OpenIntToDoubleHashMap;\nimport org.apache.commons.math.util.OpenIntToDoubleHashMap.Iterator;\n\n\npublic class OpenMapRealVector extends AbstractRealVector implements SparseRealVector, Serializable { public static final double DEFAULT_ZERO_TOLERANCE = 1.0e-12; private static final long serialVersionUID = 8772222695580707260L; private final OpenIntToDoubleHashMap entries; private final int virtualSize; private double epsilon; public OpenMapRealVector() {\n        this(0, DEFAULT_ZERO_TOLERANCE);\n    }\n\n    \n    public OpenMapRealVector(int dimension) {\n        this(dimension, DEFAULT_ZERO_TOLERANCE);\n    }\n\n    \n    public OpenMapRealVector(int dimension, double epsilon) {\n        virtualSize = dimension;\n        entries = new OpenIntToDoubleHashMap(0.0);\n        this.epsilon = epsilon;\n    }\n\n    \n    protected OpenMapRealVector(OpenMapRealVector v, int resize) {\n        virtualSize = v.getDimension() + resize;\n        entries = new OpenIntToDoubleHashMap(v.entries);\n        epsilon = v.epsilon;\n    }\n\n    \n    public OpenMapRealVector(int dimension, int expectedSize) {\n        this(dimension, expectedSize, DEFAULT_ZERO_TOLERANCE);\n    }\n\n    \n    public OpenMapRealVector(int dimension, int expectedSize, double epsilon) {\n        virtualSize = dimension;\n        entries = new OpenIntToDoubleHashMap(expectedSize, 0.0);\n        this.epsilon = epsilon;\n    }\n\n    \n    public OpenMapRealVector(double[] values) {\n        this(values, DEFAULT_ZERO_TOLERANCE);\n    }\n\n    \n    public OpenMapRealVector(double[] values, double epsilon) {\n        virtualSize = values.length;\n        entries = new OpenIntToDoubleHashMap(0.0);\n        this.epsilon = epsilon;\n        for (int key = 0; key < values.length; key++) {\n            double value = values[key];\n            if (!isDefaultValue(value)) {\n                entries.put(key, value);\n            }\n        }\n    }\n\n    \n    public OpenMapRealVector(Double[] values) {\n        this(values, DEFAULT_ZERO_TOLERANCE);\n    }\n\n    \n    public OpenMapRealVector(Double[] values, double epsilon) {\n        virtualSize = values.length;\n        entries = new OpenIntToDoubleHashMap(0.0);\n        this.epsilon = epsilon;\n        for (int key = 0; key < values.length; key++) {\n            double value = values[key].doubleValue();\n            if (!isDefaultValue(value)) {\n                entries.put(key, value);\n            }\n        }\n    }\n\n    \n    public OpenMapRealVector(OpenMapRealVector v) {\n        virtualSize = v.getDimension();\n        entries = new OpenIntToDoubleHashMap(v.getEntries());\n        epsilon = v.epsilon;\n    }\n\n    \n    public OpenMapRealVector(RealVector v) {\n        virtualSize = v.getDimension();\n        entries = new OpenIntToDoubleHashMap(0.0);\n        epsilon = DEFAULT_ZERO_TOLERANCE;\n        for (int key = 0; key < virtualSize; key++) {\n            double value = v.getEntry(key);\n            if (!isDefaultValue(value)) {\n                entries.put(key, value);\n            }\n        }\n    }\n\n    \n    private OpenIntToDoubleHashMap getEntries() {\n        return entries;\n    }\n\n    \n    protected boolean isDefaultValue(double value) {\n        return Math.abs(value) < epsilon;\n    }\n\n    \n    public RealVector add(RealVector v) throws IllegalArgumentException {\n        checkVectorDimensions(v.getDimension());\n        if (v instanceof OpenMapRealVector) {\n            return add((OpenMapRealVector) v);\n        } else {\n            return super.add(v);\n        }\n    }\n\n    \n    public OpenMapRealVector add(OpenMapRealVector v) throws IllegalArgumentException {\n        checkVectorDimensions(v.getDimension());\n        boolean copyThis = entries.size() > v.entries.size();\n        OpenMapRealVector res = copyThis ? this.copy() : v.copy();\n        Iterator iter = copyThis ? v.entries.iterator() : entries.iterator();\n        OpenIntToDoubleHashMap randomAccess = copyThis ? entries : v.entries;\n        while (iter.hasNext()) {\n            iter.advance();\n            int key = iter.key();\n            if (randomAccess.containsKey(key)) {\n                res.setEntry(key, randomAccess.get(key) + iter.value());\n            } else {\n                res.setEntry(key, iter.value());\n            }\n        }\n        return res;\n    }\n\n    \n    public OpenMapRealVector append(OpenMapRealVector v) {\n        OpenMapRealVector res = new OpenMapRealVector(this, v.getDimension());\n        Iterator iter = v.entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            res.setEntry(iter.key() + virtualSize, iter.value());\n        }\n        return res;\n    }\n\n    \n    public OpenMapRealVector append(RealVector v) {\n        if (v instanceof OpenMapRealVector) {\n            return append((OpenMapRealVector) v);\n        }\n        return append(v.getData());\n    }\n\n    \n    public OpenMapRealVector append(double d) {\n        OpenMapRealVector res = new OpenMapRealVector(this, 1);\n        res.setEntry(virtualSize, d);\n        return res;\n    }\n\n    \n    public OpenMapRealVector append(double[] a) {\n        OpenMapRealVector res = new OpenMapRealVector(this, a.length);\n        for (int i = 0; i < a.length; i++) {\n            res.setEntry(i + virtualSize, a[i]);\n        }\n        return res;\n    }\n\n    \n    public OpenMapRealVector copy() {\n        return new OpenMapRealVector(this);\n    }\n\n    \n    public double dotProduct(OpenMapRealVector v) throws IllegalArgumentException {\n        checkVectorDimensions(v.getDimension());\n        boolean thisIsSmaller  = entries.size() < v.entries.size();\n        Iterator iter = thisIsSmaller  ? entries.iterator() : v.entries.iterator();\n        OpenIntToDoubleHashMap larger = thisIsSmaller  ? v.entries : entries;\n        double d = 0;\n        while(iter.hasNext()) {\n            iter.advance();\n            d += iter.value() * larger.get(iter.key());\n        }\n        return d;\n    }\n\n    \n    public double dotProduct(RealVector v) throws IllegalArgumentException {\n        if(v instanceof OpenMapRealVector) {\n            return dotProduct((OpenMapRealVector)v);\n        } else {\n            return super.dotProduct(v);\n        }\n    }\n\n    \n    public OpenMapRealVector ebeDivide(RealVector v) throws IllegalArgumentException {\n        checkVectorDimensions(v.getDimension());\n        OpenMapRealVector res = new OpenMapRealVector(this);\n        Iterator iter = res.entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            res.setEntry(iter.key(), iter.value() / v.getEntry(iter.key()));\n        }\n        return res;\n    }\n\n    \n    public OpenMapRealVector ebeDivide(double[] v) throws IllegalArgumentException {\n        checkVectorDimensions(v.length);\n        OpenMapRealVector res = new OpenMapRealVector(this);\n        Iterator iter = res.entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            res.setEntry(iter.key(), iter.value() / v[iter.key()]);\n        }\n        return res;\n    }\n\n    \n    public OpenMapRealVector ebeMultiply(RealVector v) throws IllegalArgumentException {\n        checkVectorDimensions(v.getDimension());\n        OpenMapRealVector res = new OpenMapRealVector(this);\n        Iterator iter = res.entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key()));\n        }\n        return res;\n    }\n\n    \n    public OpenMapRealVector ebeMultiply(double[] v) throws IllegalArgumentException {\n        checkVectorDimensions(v.length);\n        OpenMapRealVector res = new OpenMapRealVector(this);\n        Iterator iter = res.entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            res.setEntry(iter.key(), iter.value() * v[iter.key()]);\n        }\n        return res;\n    }\n\n    \n    public OpenMapRealVector getSubVector(int index, int n) throws MatrixIndexException {\n        checkIndex(index);\n        checkIndex(index + n - 1);\n        OpenMapRealVector res = new OpenMapRealVector(n);\n        int end = index + n;\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            int key = iter.key();\n            if (key >= index && key < end) {\n                res.setEntry(key - index, iter.value());\n            }\n        }\n        return res;\n    }\n\n    \n    public double[] getData() {\n        double[] res = new double[virtualSize];\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            res[iter.key()] = iter.value();\n        }\n        return res;\n    }\n\n    \n    public int getDimension() {\n        return virtualSize;\n    }\n\n    \n    public double getDistance(OpenMapRealVector v) throws IllegalArgumentException {\n        Iterator iter = entries.iterator();\n        double res = 0;\n        while (iter.hasNext()) {\n            iter.advance();\n            int key = iter.key();\n            double delta;\n            delta = iter.value() - v.getEntry(key);\n            res += delta * delta;\n        }\n        iter = v.getEntries().iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            int key = iter.key();\n            if (!entries.containsKey(key)) {\n                final double value = iter.value();\n                res += value * value;\n            }\n        }\n        return Math.sqrt(res);\n    }\n\n    \n    public double getDistance(RealVector v) throws IllegalArgumentException {\n        checkVectorDimensions(v.getDimension());\n        if (v instanceof OpenMapRealVector) {\n            return getDistance((OpenMapRealVector) v);\n        }\n        return getDistance(v.getData());\n    }\n\n    \n    public double getDistance(double[] v) throws IllegalArgumentException {\n        checkVectorDimensions(v.length);\n        double res = 0;\n        for (int i = 0; i < v.length; i++) {\n            double delta = entries.get(i) - v[i];\n            res += delta * delta;\n        }\n        return Math.sqrt(res);\n    }\n\n    \n    public double getEntry(int index) throws MatrixIndexException {\n        checkIndex(index);\n        return entries.get(index);\n    }\n\n    \n    public double getL1Distance(OpenMapRealVector v) {\n        double max = 0;\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            double delta = Math.abs(iter.value() - v.getEntry(iter.key()));\n            max += delta;\n        }\n        iter = v.getEntries().iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            int key = iter.key();\n            if (!entries.containsKey(key)) {\n                double delta = Math.abs(iter.value());\n                max +=  Math.abs(delta);\n            }\n        }\n        return max;\n    }\n\n    \n    public double getL1Distance(RealVector v) throws IllegalArgumentException {\n        checkVectorDimensions(v.getDimension());\n        if (v instanceof OpenMapRealVector) {\n            return getL1Distance((OpenMapRealVector) v);\n        }\n        return getL1Distance(v.getData());\n    }\n\n    \n    public double getL1Distance(double[] v) throws IllegalArgumentException {\n        checkVectorDimensions(v.length);\n        double max = 0;\n        for (int i = 0; i < v.length; i++) {\n            double delta = Math.abs(getEntry(i) - v[i]);\n            max += delta;\n        }\n        return max;\n    }\n\n    \n    private double getLInfDistance(OpenMapRealVector v) {\n        double max = 0;\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            double delta = Math.abs(iter.value() - v.getEntry(iter.key()));\n            if (delta > max) {\n                max = delta;\n            }\n        }\n        iter = v.getEntries().iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            int key = iter.key();\n            if (!entries.containsKey(key)) {\n                if (iter.value() > max) {\n                    max = iter.value();\n                }\n            }\n        }\n        return max;\n    }\n\n    \n    public double getLInfDistance(RealVector v) throws IllegalArgumentException {\n        checkVectorDimensions(v.getDimension());\n        if (v instanceof OpenMapRealVector) {\n            return getLInfDistance((OpenMapRealVector) v);\n        }\n        return getLInfDistance(v.getData());\n    }\n\n    \n    public double getLInfDistance(double[] v) throws IllegalArgumentException {\n        checkVectorDimensions(v.length);\n        double max = 0;\n        for (int i = 0; i < v.length; i++) {\n            double delta = Math.abs(getEntry(i) - v[i]);\n            if (delta > max) {\n                max = delta;\n            }\n        }\n        return max;\n    }\n\n    \n    public boolean isInfinite() {\n        boolean infiniteFound = false;\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            final double value = iter.value();\n            if (Double.isNaN(value)) {\n                return false;\n            }\n            if (Double.isInfinite(value)) {\n                infiniteFound = true;\n            }\n        }\n        return infiniteFound;\n    }\n\n    \n    public boolean isNaN() {\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            if (Double.isNaN(iter.value())) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    \n    public OpenMapRealVector mapAdd(double d) {\n        return copy().mapAddToSelf(d);\n    }\n\n    \n    public OpenMapRealVector mapAddToSelf(double d) {\n        for (int i = 0; i < virtualSize; i++) {\n            setEntry(i, getEntry(i) + d);\n        }\n        return this;\n    }\n\n     \n    public RealMatrix outerProduct(double[] v) throws IllegalArgumentException {\n        checkVectorDimensions(v.length);\n        RealMatrix res = new OpenMapRealMatrix(virtualSize, virtualSize);\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            int row = iter.key();\n            double value = iter.value();\n            for (int col = 0; col < virtualSize; col++) {\n                res.setEntry(row, col, value * v[col]);\n            }\n        }\n        return res;\n    }\n\n    \n    public RealVector projection(RealVector v) throws IllegalArgumentException {\n        checkVectorDimensions(v.getDimension());\n        return v.mapMultiply(dotProduct(v) / v.dotProduct(v));\n    }\n\n    \n    public OpenMapRealVector projection(double[] v) throws IllegalArgumentException {\n        checkVectorDimensions(v.length);\n        return (OpenMapRealVector) projection(new OpenMapRealVector(v));\n    }\n\n    \n    public void setEntry(int index, double value) throws MatrixIndexException {\n        checkIndex(index);\n        if (!isDefaultValue(value)) {\n            entries.put(index, value);\n        } else if (entries.containsKey(index)) {\n            entries.remove(index);\n        }\n    }\n\n    \n    public void setSubVector(int index, RealVector v) throws MatrixIndexException {\n        checkIndex(index);\n        checkIndex(index + v.getDimension() - 1);\n        setSubVector(index, v.getData());\n    }\n\n    \n    public void setSubVector(int index, double[] v) throws MatrixIndexException {\n        checkIndex(index);\n        checkIndex(index + v.length - 1);\n        for (int i = 0; i < v.length; i++) {\n            setEntry(i + index, v[i]);\n        }\n    }\n\n    \n    public void set(double value) {\n        for (int i = 0; i < virtualSize; i++) {\n            setEntry(i, value);\n        }\n    }\n\n    \n    public OpenMapRealVector subtract(OpenMapRealVector v) throws IllegalArgumentException {\n        checkVectorDimensions(v.getDimension());\n        OpenMapRealVector res = copy();\n        Iterator iter = v.getEntries().iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            int key = iter.key();\n            if (entries.containsKey(key)) {\n                res.setEntry(key, entries.get(key) - iter.value());\n            } else {\n                res.setEntry(key, -iter.value());\n            }\n        }\n        return res;\n    }\n\n    \n    public OpenMapRealVector subtract(RealVector v) throws IllegalArgumentException {\n        checkVectorDimensions(v.getDimension());\n        if (v instanceof OpenMapRealVector) {\n            return subtract((OpenMapRealVector) v);\n        }\n        return subtract(v.getData());\n    }\n\n    \n    public OpenMapRealVector subtract(double[] v) throws IllegalArgumentException {\n        checkVectorDimensions(v.length);\n        OpenMapRealVector res = new OpenMapRealVector(this);\n        for (int i = 0; i < v.length; i++) {\n            if (entries.containsKey(i)) {\n                res.setEntry(i, entries.get(i) - v[i]);\n            } else {\n                res.setEntry(i, -v[i]);\n            }\n        }\n        return res;\n    }\n\n\n    \n    public OpenMapRealVector unitVector() {\n        OpenMapRealVector res = copy();\n        res.unitize();\n        return res;\n    }\n\n    \n    public void unitize() {\n        double norm = getNorm();\n        if (isDefaultValue(norm)) {\n            throw  MathRuntimeException.createArithmeticException(\"cannot normalize a zero norm vector\");\n        }\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            entries.put(iter.key(), iter.value() / norm);\n        }\n\n    }\n\n\n    \n    public double[] toArray() {\n        return getData();\n    }\n\n    \n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        long temp;\n        temp = Double.doubleToLongBits(epsilon);\n        result = prime * result + (int) (temp ^ (temp >>> 32));\n        result = prime * result + virtualSize;\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            temp = Double.doubleToLongBits(iter.value());\n            result = prime * result + (int) (temp ^ (temp >>32));\n        }\n        return result;\n    }\n\n    \n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (!(obj instanceof OpenMapRealVector)) {\n            return false;\n        }\n        OpenMapRealVector other = (OpenMapRealVector) obj;\n        if (virtualSize != other.virtualSize) {\n            return false;\n        }\n        if (Double.doubleToLongBits(epsilon) !=\n            Double.doubleToLongBits(other.epsilon)) {\n            return false;\n        }\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            double test = other.getEntry(iter.key());\n            if (Double.doubleToLongBits(test) != Double.doubleToLongBits(iter.value())) {\n                return false;\n            }\n        }\n        iter = other.getEntries().iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            double test = iter.value();\n            if (Double.doubleToLongBits(test) != Double.doubleToLongBits(getEntry(iter.key()))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public double getSparcity() {\n        return (double)entries.size()/(double)getDimension();\n    }\n\n    \n    public java.util.Iterator<Entry> sparseIterator() {\n        return new OpenMapSparseIterator();\n    }\n\n    \n    protected class OpenMapEntry extends Entry { private final Iterator iter; protected OpenMapEntry(Iterator iter) {\n            this.iter = iter;\n        }\n\n        \n        @Override\n        public double getValue() {\n            return iter.value();\n        }\n\n        \n        @Override\n        public void setValue(double value) {\n            entries.put(iter.key(), value);\n        }\n\n        \n        @Override\n        public int getIndex() {\n            return iter.key();\n        }\n\n    }\n\n    \n    protected class OpenMapSparseIterator implements java.util.Iterator<Entry> { private final Iterator iter; private final Entry current; protected OpenMapSparseIterator() {\n            iter = entries.iterator();\n            current = new OpenMapEntry(iter);\n        }\n\n        \n        public boolean hasNext() {\n            return iter.hasNext();\n        }\n\n        \n        public Entry next() {\n            iter.advance();\n            return current;\n        }\n\n        \n        public void remove() {\n            throw new UnsupportedOperationException(\"Not supported\");\n       }\n\n    }\n}\n",
      "buggy_signatures": [
        "public OpenMapRealVector(int dimension)",
        "public OpenMapRealVector(int dimension, double epsilon)",
        "protected OpenMapRealVector(OpenMapRealVector v, int resize)",
        "public OpenMapRealVector(int dimension, int expectedSize)",
        "public OpenMapRealVector(int dimension, int expectedSize, double epsilon)",
        "public OpenMapRealVector(double[] values)",
        "public OpenMapRealVector(double[] values, double epsilon)",
        "public OpenMapRealVector(Double[] values)",
        "public OpenMapRealVector(Double[] values, double epsilon)",
        "public OpenMapRealVector(OpenMapRealVector v)",
        "public OpenMapRealVector(RealVector v)",
        "private OpenIntToDoubleHashMap getEntries()",
        "protected boolean isDefaultValue(double value)",
        "public RealVector add(RealVector v) throws IllegalArgumentException",
        "public OpenMapRealVector add(OpenMapRealVector v) throws IllegalArgumentException",
        "public OpenMapRealVector append(OpenMapRealVector v)",
        "public OpenMapRealVector append(RealVector v)",
        "public OpenMapRealVector append(double d)",
        "public OpenMapRealVector append(double[] a)",
        "public OpenMapRealVector copy()",
        "public double dotProduct(OpenMapRealVector v) throws IllegalArgumentException",
        "public double dotProduct(RealVector v) throws IllegalArgumentException",
        "public OpenMapRealVector ebeDivide(RealVector v) throws IllegalArgumentException",
        "public OpenMapRealVector ebeDivide(double[] v) throws IllegalArgumentException",
        "public OpenMapRealVector ebeMultiply(RealVector v) throws IllegalArgumentException",
        "public OpenMapRealVector ebeMultiply(double[] v) throws IllegalArgumentException",
        "public OpenMapRealVector getSubVector(int index, int n) throws MatrixIndexException",
        "public double[] getData()",
        "public int getDimension()",
        "public double getDistance(OpenMapRealVector v) throws IllegalArgumentException",
        "public double getDistance(RealVector v) throws IllegalArgumentException",
        "public double getDistance(double[] v) throws IllegalArgumentException",
        "public double getEntry(int index) throws MatrixIndexException",
        "public double getL1Distance(OpenMapRealVector v)",
        "public double getL1Distance(RealVector v) throws IllegalArgumentException",
        "public double getL1Distance(double[] v) throws IllegalArgumentException",
        "public double getLInfNorm()",
        "private double getLInfDistance(OpenMapRealVector v)",
        "public double getLInfDistance(RealVector v) throws IllegalArgumentException",
        "public double getLInfDistance(double[] v) throws IllegalArgumentException",
        "public boolean isInfinite()",
        "public boolean isNaN()",
        "public OpenMapRealVector mapAdd(double d)",
        "public OpenMapRealVector mapAddToSelf(double d)",
        "public RealMatrix outerProduct(double[] v) throws IllegalArgumentException",
        "public RealVector projection(RealVector v) throws IllegalArgumentException",
        "public OpenMapRealVector projection(double[] v) throws IllegalArgumentException",
        "public void setEntry(int index, double value) throws MatrixIndexException",
        "public void setSubVector(int index, RealVector v) throws MatrixIndexException",
        "public void setSubVector(int index, double[] v) throws MatrixIndexException",
        "public void set(double value)",
        "public OpenMapRealVector subtract(OpenMapRealVector v) throws IllegalArgumentException",
        "public OpenMapRealVector subtract(RealVector v) throws IllegalArgumentException",
        "public OpenMapRealVector subtract(double[] v) throws IllegalArgumentException",
        "public OpenMapRealVector unitVector()",
        "public void unitize()",
        "public double[] toArray()",
        "public int hashCode()",
        "public boolean equals(Object obj)",
        "public double getSparcity()",
        "public java.util.Iterator<Entry> sparseIterator()",
        "protected class OpenMapEntry extends Entry { private final Iterator iter; protected OpenMapEntry(Iterator iter)",
        "public double getValue()",
        "public void setValue(double value)",
        "public int getIndex()",
        "protected class OpenMapSparseIterator implements java.util.Iterator<Entry> { private final Iterator iter; private final Entry current; protected OpenMapSparseIterator()",
        "public boolean hasNext()",
        "public Entry next()",
        "public void remove()"
      ],
      "fixed_signatures": [
        "public OpenMapRealVector(int dimension)",
        "public OpenMapRealVector(int dimension, double epsilon)",
        "protected OpenMapRealVector(OpenMapRealVector v, int resize)",
        "public OpenMapRealVector(int dimension, int expectedSize)",
        "public OpenMapRealVector(int dimension, int expectedSize, double epsilon)",
        "public OpenMapRealVector(double[] values)",
        "public OpenMapRealVector(double[] values, double epsilon)",
        "public OpenMapRealVector(Double[] values)",
        "public OpenMapRealVector(Double[] values, double epsilon)",
        "public OpenMapRealVector(OpenMapRealVector v)",
        "public OpenMapRealVector(RealVector v)",
        "private OpenIntToDoubleHashMap getEntries()",
        "protected boolean isDefaultValue(double value)",
        "public RealVector add(RealVector v) throws IllegalArgumentException",
        "public OpenMapRealVector add(OpenMapRealVector v) throws IllegalArgumentException",
        "public OpenMapRealVector append(OpenMapRealVector v)",
        "public OpenMapRealVector append(RealVector v)",
        "public OpenMapRealVector append(double d)",
        "public OpenMapRealVector append(double[] a)",
        "public OpenMapRealVector copy()",
        "public double dotProduct(OpenMapRealVector v) throws IllegalArgumentException",
        "public double dotProduct(RealVector v) throws IllegalArgumentException",
        "public OpenMapRealVector ebeDivide(RealVector v) throws IllegalArgumentException",
        "public OpenMapRealVector ebeDivide(double[] v) throws IllegalArgumentException",
        "public OpenMapRealVector ebeMultiply(RealVector v) throws IllegalArgumentException",
        "public OpenMapRealVector ebeMultiply(double[] v) throws IllegalArgumentException",
        "public OpenMapRealVector getSubVector(int index, int n) throws MatrixIndexException",
        "public double[] getData()",
        "public int getDimension()",
        "public double getDistance(OpenMapRealVector v) throws IllegalArgumentException",
        "public double getDistance(RealVector v) throws IllegalArgumentException",
        "public double getDistance(double[] v) throws IllegalArgumentException",
        "public double getEntry(int index) throws MatrixIndexException",
        "public double getL1Distance(OpenMapRealVector v)",
        "public double getL1Distance(RealVector v) throws IllegalArgumentException",
        "public double getL1Distance(double[] v) throws IllegalArgumentException",
        "private double getLInfDistance(OpenMapRealVector v)",
        "public double getLInfDistance(RealVector v) throws IllegalArgumentException",
        "public double getLInfDistance(double[] v) throws IllegalArgumentException",
        "public boolean isInfinite()",
        "public boolean isNaN()",
        "public OpenMapRealVector mapAdd(double d)",
        "public OpenMapRealVector mapAddToSelf(double d)",
        "public RealMatrix outerProduct(double[] v) throws IllegalArgumentException",
        "public RealVector projection(RealVector v) throws IllegalArgumentException",
        "public OpenMapRealVector projection(double[] v) throws IllegalArgumentException",
        "public void setEntry(int index, double value) throws MatrixIndexException",
        "public void setSubVector(int index, RealVector v) throws MatrixIndexException",
        "public void setSubVector(int index, double[] v) throws MatrixIndexException",
        "public void set(double value)",
        "public OpenMapRealVector subtract(OpenMapRealVector v) throws IllegalArgumentException",
        "public OpenMapRealVector subtract(RealVector v) throws IllegalArgumentException",
        "public OpenMapRealVector subtract(double[] v) throws IllegalArgumentException",
        "public OpenMapRealVector unitVector()",
        "public void unitize()",
        "public double[] toArray()",
        "public int hashCode()",
        "public boolean equals(Object obj)",
        "public double getSparcity()",
        "public java.util.Iterator<Entry> sparseIterator()",
        "protected class OpenMapEntry extends Entry { private final Iterator iter; protected OpenMapEntry(Iterator iter)",
        "public double getValue()",
        "public void setValue(double value)",
        "public int getIndex()",
        "protected class OpenMapSparseIterator implements java.util.Iterator<Entry> { private final Iterator iter; private final Entry current; protected OpenMapSparseIterator()",
        "public boolean hasNext()",
        "public Entry next()",
        "public void remove()"
      ],
      "methods": [
        {
          "buggy_method": "  public double getLInfNorm() {\n  double max = 0;\n  Iterator iter = entries.iterator();\n  while (iter.hasNext()) {\n  iter.advance();\n  max += iter.value();\n  }\n  return max;\n  }",
          "fixed_method": "  public double getL1Distance(double[] v) throws IllegalArgumentException {\n  checkVectorDimensions(v.length);\n  double max = 0;\n  for (int i = 0; i < v.length; i++) {\n  double delta = Math.abs(getEntry(i) - v[i]);\n  max += delta;\n  }\n  return max;\n  }",
          "diff": [
            "@@ -495,15 +495,6 @@",
            "         return max;\n",
            "     }\n",
            " \n",
            "-    public double getLInfNorm() {\n",
            "-        double max = 0;\n",
            "-        Iterator iter = entries.iterator();\n",
            "-        while (iter.hasNext()) {\n",
            "-            iter.advance();\n",
            "-            max += iter.value();\n",
            "-        }\n",
            "-        return max;\n",
            "-    }\n",
            "     /**\n",
            "      * Optimized method to compute LInfDistance.\n",
            "      * @param v The vector to compute from\n"
          ],
          "changed_lines": 9
        }
      ]
    }
  ]
}
