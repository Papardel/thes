{
  "bug_id": "61",
  "failed_tests": {
    "org.apache.commons.math.distribution.PoissonDistributionTest": [
      {
        "methodName": "testMean",
        "error": "org.apache.commons.math.MathRuntimeException$4",
        "message": "the Poisson mean must be positive (-1)",
        "fail_line": "            dist = new PoissonDistributionImpl(-1);",
        "test_source": "  public void testMean() {\n  PoissonDistribution dist;\n  try {\n  dist = new PoissonDistributionImpl(-1);\n  fail(\"negative mean: NotStrictlyPositiveException expected\");\n  } catch(NotStrictlyPositiveException ex) {\n  // Expected.\n  }\n\n  dist = new PoissonDistributionImpl(10.0);\n  assertEquals(10.0, dist.getMean(), 0.0);\n  }",
        "stack": [
          "MathRuntimeException.createIllegalArgumentException line 387, PoissonDistributionImpl.<init> line 94, PoissonDistributionImpl.<init> line 80, PoissonDistributionTest.testMean line 140"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/math/distribution/PoissonDistributionImpl.java",
      "buggy_full_code": "\npackage org.apache.commons.math.distribution;\n\nimport java.io.Serializable;\n\nimport org.apache.commons.math.MathException;\nimport org.apache.commons.math.MathRuntimeException;\nimport org.apache.commons.math.exception.util.LocalizedFormats;\nimport org.apache.commons.math.special.Gamma;\nimport org.apache.commons.math.util.MathUtils;\nimport org.apache.commons.math.util.FastMath;\n\n\npublic class PoissonDistributionImpl extends AbstractIntegerDistribution implements PoissonDistribution, Serializable { public static final int DEFAULT_MAX_ITERATIONS = 10000000; public static final double DEFAULT_EPSILON = 1E-12; private static final long serialVersionUID = -3349935121172596109L; private NormalDistribution normal; private double mean; private int maxIterations = DEFAULT_MAX_ITERATIONS; private double epsilon = DEFAULT_EPSILON; public PoissonDistributionImpl(double p) {\n        this(p, DEFAULT_EPSILON, DEFAULT_MAX_ITERATIONS);\n    }\n\n    \n    public PoissonDistributionImpl(double p, double epsilon, int maxIterations) {\n        if (p <= 0) {\n            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NOT_POSITIVE_POISSON_MEAN, p);\n        }\n        mean = p;\n        normal = new NormalDistributionImpl(p, FastMath.sqrt(p));\n        this.epsilon = epsilon;\n        this.maxIterations = maxIterations;\n    }\n\n    \n    public PoissonDistributionImpl(double p, double epsilon) {\n        this(p, epsilon, DEFAULT_MAX_ITERATIONS);\n    }\n\n    \n    public PoissonDistributionImpl(double p, int maxIterations) {\n        this(p, DEFAULT_EPSILON, maxIterations);\n    }\n\n    \n    public double getMean() {\n        return mean;\n    }\n\n    \n    public double probability(int x) {\n        double ret;\n        if (x < 0 || x == Integer.MAX_VALUE) {\n            ret = 0.0;\n        } else if (x == 0) {\n            ret = FastMath.exp(-mean);\n        } else {\n            ret = FastMath.exp(-SaddlePointExpansion.getStirlingError(x) -\n                  SaddlePointExpansion.getDeviancePart(x, mean)) /\n                  FastMath.sqrt(MathUtils.TWO_PI * x);\n        }\n        return ret;\n    }\n\n    \n    @Override\n    public double cumulativeProbability(int x) throws MathException {\n        if (x < 0) {\n            return 0;\n        }\n        if (x == Integer.MAX_VALUE) {\n            return 1;\n        }\n        return Gamma.regularizedGammaQ((double) x + 1, mean, epsilon, maxIterations);\n    }\n\n    \n    public double normalApproximateProbability(int x) throws MathException {\n        \n        return normal.cumulativeProbability(x + 0.5);\n    }\n\n    \n    @Override\n    public int sample() throws MathException {\n        return (int) FastMath.min(randomData.nextPoisson(mean), Integer.MAX_VALUE);\n    }\n\n    \n    @Override\n    protected int getDomainLowerBound(double p) {\n        return 0;\n    }\n\n    \n    @Override\n    protected int getDomainUpperBound(double p) {\n        return Integer.MAX_VALUE;\n    }\n}\n",
      "fixed_full_code": "\npackage org.apache.commons.math.distribution;\n\nimport java.io.Serializable;\n\nimport org.apache.commons.math.MathException;\nimport org.apache.commons.math.exception.NotStrictlyPositiveException;\nimport org.apache.commons.math.exception.util.LocalizedFormats;\nimport org.apache.commons.math.special.Gamma;\nimport org.apache.commons.math.util.MathUtils;\nimport org.apache.commons.math.util.FastMath;\n\n\npublic class PoissonDistributionImpl extends AbstractIntegerDistribution implements PoissonDistribution, Serializable { public static final int DEFAULT_MAX_ITERATIONS = 10000000; public static final double DEFAULT_EPSILON = 1E-12; private static final long serialVersionUID = -3349935121172596109L; private NormalDistribution normal; private double mean; private int maxIterations = DEFAULT_MAX_ITERATIONS; private double epsilon = DEFAULT_EPSILON; public PoissonDistributionImpl(double p) {\n        this(p, DEFAULT_EPSILON, DEFAULT_MAX_ITERATIONS);\n    }\n\n    \n    public PoissonDistributionImpl(double p, double epsilon, int maxIterations) {\n        if (p <= 0) {\n            throw new NotStrictlyPositiveException(LocalizedFormats.MEAN, p);\n        }\n        mean = p;\n        normal = new NormalDistributionImpl(p, FastMath.sqrt(p));\n        this.epsilon = epsilon;\n        this.maxIterations = maxIterations;\n    }\n\n    \n    public PoissonDistributionImpl(double p, double epsilon) {\n        this(p, epsilon, DEFAULT_MAX_ITERATIONS);\n    }\n\n    \n    public PoissonDistributionImpl(double p, int maxIterations) {\n        this(p, DEFAULT_EPSILON, maxIterations);\n    }\n\n    \n    public double getMean() {\n        return mean;\n    }\n\n    \n    public double probability(int x) {\n        double ret;\n        if (x < 0 || x == Integer.MAX_VALUE) {\n            ret = 0.0;\n        } else if (x == 0) {\n            ret = FastMath.exp(-mean);\n        } else {\n            ret = FastMath.exp(-SaddlePointExpansion.getStirlingError(x) -\n                  SaddlePointExpansion.getDeviancePart(x, mean)) /\n                  FastMath.sqrt(MathUtils.TWO_PI * x);\n        }\n        return ret;\n    }\n\n    \n    @Override\n    public double cumulativeProbability(int x) throws MathException {\n        if (x < 0) {\n            return 0;\n        }\n        if (x == Integer.MAX_VALUE) {\n            return 1;\n        }\n        return Gamma.regularizedGammaQ((double) x + 1, mean, epsilon, maxIterations);\n    }\n\n    \n    public double normalApproximateProbability(int x) throws MathException {\n        \n        return normal.cumulativeProbability(x + 0.5);\n    }\n\n    \n    @Override\n    public int sample() throws MathException {\n        return (int) FastMath.min(randomData.nextPoisson(mean), Integer.MAX_VALUE);\n    }\n\n    \n    @Override\n    protected int getDomainLowerBound(double p) {\n        return 0;\n    }\n\n    \n    @Override\n    protected int getDomainUpperBound(double p) {\n        return Integer.MAX_VALUE;\n    }\n}\n",
      "buggy_signatures": [
        "public PoissonDistributionImpl(double p, double epsilon, int maxIterations)",
        "public PoissonDistributionImpl(double p, double epsilon)",
        "public PoissonDistributionImpl(double p, int maxIterations)",
        "public double getMean()",
        "public double probability(int x)",
        "public double cumulativeProbability(int x) throws MathException",
        "public double normalApproximateProbability(int x) throws MathException",
        "public int sample() throws MathException",
        "protected int getDomainLowerBound(double p)",
        "protected int getDomainUpperBound(double p)"
      ],
      "fixed_signatures": [
        "public PoissonDistributionImpl(double p, double epsilon, int maxIterations)",
        "public PoissonDistributionImpl(double p, double epsilon)",
        "public PoissonDistributionImpl(double p, int maxIterations)",
        "public double getMean()",
        "public double probability(int x)",
        "public double cumulativeProbability(int x) throws MathException",
        "public double normalApproximateProbability(int x) throws MathException",
        "public int sample() throws MathException",
        "protected int getDomainLowerBound(double p)",
        "protected int getDomainUpperBound(double p)"
      ],
      "methods": [
        {
          "buggy_method": "",
          "fixed_method": "",
          "diff": [
            "@@ -19,7 +19,7 @@",
            " import java.io.Serializable;\n",
            " \n",
            " import org.apache.commons.math.MathException;\n",
            "-import org.apache.commons.math.MathRuntimeException;\n",
            "+import org.apache.commons.math.exception.NotStrictlyPositiveException;\n",
            " import org.apache.commons.math.exception.util.LocalizedFormats;\n",
            " import org.apache.commons.math.special.Gamma;\n",
            " import org.apache.commons.math.util.MathUtils;\n"
          ],
          "changed_lines": 2
        },
        {
          "buggy_method": "  public PoissonDistributionImpl(double p, double epsilon, int maxIterations) {\n  if (p <= 0) {\n  throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NOT_POSITIVE_POISSON_MEAN, p);\n  }\n  mean = p;\n  normal = new NormalDistributionImpl(p, FastMath.sqrt(p));\n  this.epsilon = epsilon;\n  this.maxIterations = maxIterations;\n  }",
          "fixed_method": "  public PoissonDistributionImpl(double p, double epsilon, int maxIterations) {\n  if (p <= 0) {\n  throw new NotStrictlyPositiveException(LocalizedFormats.MEAN, p);\n  }\n  mean = p;\n  normal = new NormalDistributionImpl(p, FastMath.sqrt(p));\n  this.epsilon = epsilon;\n  this.maxIterations = maxIterations;\n  }",
          "diff": [
            "@@ -91,7 +91,7 @@",
            "      */\n",
            "     public PoissonDistributionImpl(double p, double epsilon, int maxIterations) {\n",
            "         if (p <= 0) {\n",
            "-            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NOT_POSITIVE_POISSON_MEAN, p);\n",
            "+            throw new NotStrictlyPositiveException(LocalizedFormats.MEAN, p);\n",
            "         }\n",
            "         mean = p;\n",
            "         normal = new NormalDistributionImpl(p, FastMath.sqrt(p));\n"
          ],
          "changed_lines": 2
        }
      ]
    }
  ]
}
