{
  "bug_id": "11",
  "failed_tests": {
    "org.joda.time.tz.TestCompiler": [
      {
        "methodName": "testDateTimeZoneBuilder",
        "error": "junit.framework.AssertionFailedError",
        "message": "",
        "fail_line": "        assertNotNull(zone[0]);",
        "test_source": "  public void testDateTimeZoneBuilder() throws Exception {\n  // test multithreading, issue #18\n  getTestDataTimeZoneBuilder().toDateTimeZone(\"TestDTZ1\", true);\n  final DateTimeZone[] zone = new DateTimeZone[1];\n  Thread t = new Thread(new Runnable() {\n  public void run() {\n  zone[0] = getTestDataTimeZoneBuilder().toDateTimeZone(\"TestDTZ2\", true);\n  }\n  });\n  t.start();\n  t.join();\n  assertNotNull(zone[0]);\n  }",
        "stack": [
          "TestCompiler.testDateTimeZoneBuilder line 99"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/joda/time/tz/ZoneInfoCompiler.java",
      "buggy_full_code": "\npackage org.joda.time.tz;\n\nimport java.io.BufferedReader;\nimport java.io.DataOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\nimport java.util.Map.Entry;\n\nimport org.joda.time.Chronology;\nimport org.joda.time.DateTime;\nimport org.joda.time.DateTimeField;\nimport org.joda.time.DateTimeZone;\nimport org.joda.time.LocalDate;\nimport org.joda.time.MutableDateTime;\nimport org.joda.time.chrono.ISOChronology;\nimport org.joda.time.chrono.LenientChronology;\nimport org.joda.time.format.DateTimeFormatter;\nimport org.joda.time.format.ISODateTimeFormat;\n\n\npublic class ZoneInfoCompiler { static DateTimeOfYear cStartOfYear; static Chronology cLenientISO; static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>(); static {\n        cVerbose.set(Boolean.FALSE);\n    }\n\n    \n    public static boolean verbose() {\n        return cVerbose.get();\n    }\n\n    \n    \n    public static void main(String[] args) throws Exception {\n        if (args.length == 0) {\n            printUsage();\n            return;\n        }\n\n        File inputDir = null;\n        File outputDir = null;\n        boolean verbose = false;\n\n        int i;\n        for (i=0; i<args.length; i++) {\n            try {\n                if (\"-src\".equals(args[i])) {\n                    inputDir = new File(args[++i]);\n                } else if (\"-dst\".equals(args[i])) {\n                    outputDir = new File(args[++i]);\n                } else if (\"-verbose\".equals(args[i])) {\n                    verbose = true;\n                } else if (\"-?\".equals(args[i])) {\n                    printUsage();\n                    return;\n                } else {\n                    break;\n                }\n            } catch (IndexOutOfBoundsException e) {\n                printUsage();\n                return;\n            }\n        }\n\n        if (i >= args.length) {\n            printUsage();\n            return;\n        }\n\n        File[] sources = new File[args.length - i];\n        for (int j=0; i<args.length; i++,j++) {\n            sources[j] = inputDir == null ? new File(args[i]) : new File(inputDir, args[i]);\n        }\n\n        cVerbose.set(verbose);\n        ZoneInfoCompiler zic = new ZoneInfoCompiler();\n        zic.compile(outputDir, sources);\n    }\n\n    private static void printUsage() {\n        System.out.println(\"Usage: java org.joda.time.tz.ZoneInfoCompiler <options> <source files>\");\n        System.out.println(\"where possible options include:\");\n        System.out.println(\"  -src <directory>    Specify where to read source files\");\n        System.out.println(\"  -dst <directory>    Specify where to write generated files\");\n        System.out.println(\"  -verbose            Output verbosely (default false)\");\n    }\n\n    static DateTimeOfYear getStartOfYear() {\n        if (cStartOfYear == null) {\n            cStartOfYear = new DateTimeOfYear();\n        }\n        return cStartOfYear;\n    }\n\n    static Chronology getLenientISOChronology() {\n        if (cLenientISO == null) {\n            cLenientISO = LenientChronology.getInstance(ISOChronology.getInstanceUTC());\n        }\n        return cLenientISO;\n    }\n\n    \n    static void writeZoneInfoMap(DataOutputStream dout, Map<String, DateTimeZone> zimap) throws IOException {\n        \n        Map<String, Short> idToIndex = new HashMap<String, Short>(zimap.size());\n        TreeMap<Short, String> indexToId = new TreeMap<Short, String>();\n\n        short count = 0;\n        for (Entry<String, DateTimeZone> entry : zimap.entrySet()) {\n            String id = (String)entry.getKey();\n            if (!idToIndex.containsKey(id)) {\n                Short index = Short.valueOf(count);\n                idToIndex.put(id, index);\n                indexToId.put(index, id);\n                if (++count == 0) {\n                    throw new InternalError(\"Too many time zone ids\");\n                }\n            }\n            id = ((DateTimeZone)entry.getValue()).getID();\n            if (!idToIndex.containsKey(id)) {\n                Short index = Short.valueOf(count);\n                idToIndex.put(id, index);\n                indexToId.put(index, id);\n                if (++count == 0) {\n                    throw new InternalError(\"Too many time zone ids\");\n                }\n            }\n        }\n\n        \n        dout.writeShort(indexToId.size());\n        for (String id : indexToId.values()) {\n            dout.writeUTF(id);\n        }\n\n        \n        dout.writeShort(zimap.size());\n        for (Entry<String, DateTimeZone> entry : zimap.entrySet()) {\n            String id = entry.getKey();\n            dout.writeShort(idToIndex.get(id).shortValue());\n            id = entry.getValue().getID();\n            dout.writeShort(idToIndex.get(id).shortValue());\n        }\n    }\n\n    static int parseYear(String str, int def) {\n        str = str.toLowerCase();\n        if (str.equals(\"minimum\") || str.equals(\"min\")) {\n            return Integer.MIN_VALUE;\n        } else if (str.equals(\"maximum\") || str.equals(\"max\")) {\n            return Integer.MAX_VALUE;\n        } else if (str.equals(\"only\")) {\n            return def;\n        }\n        return Integer.parseInt(str);\n    }\n\n    static int parseMonth(String str) {\n        DateTimeField field = ISOChronology.getInstanceUTC().monthOfYear();\n        return field.get(field.set(0, str, Locale.ENGLISH));\n    }\n\n    static int parseDayOfWeek(String str) {\n        DateTimeField field = ISOChronology.getInstanceUTC().dayOfWeek();\n        return field.get(field.set(0, str, Locale.ENGLISH));\n    }\n    \n    static String parseOptional(String str) {\n        return (str.equals(\"-\")) ? null : str;\n    }\n\n    static int parseTime(String str) {\n        DateTimeFormatter p = ISODateTimeFormat.hourMinuteSecondFraction();\n        MutableDateTime mdt = new MutableDateTime(0, getLenientISOChronology());\n        int pos = 0;\n        if (str.startsWith(\"-\")) {\n            pos = 1;\n        }\n        int newPos = p.parseInto(mdt, str, pos);\n        if (newPos == ~pos) {\n            throw new IllegalArgumentException(str);\n        }\n        int millis = (int)mdt.getMillis();\n        if (pos == 1) {\n            millis = -millis;\n        }\n        return millis;\n    }\n\n    static char parseZoneChar(char c) {\n        switch (c) {\n        case 's': case 'S':\n            \n            return 's';\n        case 'u': case 'U': case 'g': case 'G': case 'z': case 'Z':\n            \n            return 'u';\n        case 'w': case 'W': default:\n            \n            return 'w';\n        }\n    }\n\n    \n    static boolean test(String id, DateTimeZone tz) {\n        if (!id.equals(tz.getID())) {\n            return true;\n        }\n\n        \n\n        long millis = ISOChronology.getInstanceUTC().year().set(0, 1850);\n        long end = ISOChronology.getInstanceUTC().year().set(0, 2050);\n\n        int offset = tz.getOffset(millis);\n        String key = tz.getNameKey(millis);\n\n        List<Long> transitions = new ArrayList<Long>();\n\n        while (true) {\n            long next = tz.nextTransition(millis);\n            if (next == millis || next > end) {\n                break;\n            }\n\n            millis = next;\n\n            int nextOffset = tz.getOffset(millis);\n            String nextKey = tz.getNameKey(millis);\n\n            if (offset == nextOffset\n                && key.equals(nextKey)) {\n                System.out.println(\"*d* Error in \" + tz.getID() + \" \"\n                                   + new DateTime(millis,\n                                                  ISOChronology.getInstanceUTC()));\n                return false;\n            }\n\n            if (nextKey == null || (nextKey.length() < 3 && !\"??\".equals(nextKey))) {\n                System.out.println(\"*s* Error in \" + tz.getID() + \" \"\n                                   + new DateTime(millis,\n                                                  ISOChronology.getInstanceUTC())\n                                   + \", nameKey=\" + nextKey);\n                return false;\n            }\n\n            transitions.add(Long.valueOf(millis));\n\n            offset = nextOffset;\n            key = nextKey;\n        }\n\n        \n\n        millis = ISOChronology.getInstanceUTC().year().set(0, 2050);\n        end = ISOChronology.getInstanceUTC().year().set(0, 1850);\n\n        for (int i=transitions.size(); --i>= 0; ) {\n            long prev = tz.previousTransition(millis);\n            if (prev == millis || prev < end) {\n                break;\n            }\n\n            millis = prev;\n\n            long trans = transitions.get(i).longValue();\n            \n            if (trans - 1 != millis) {\n                System.out.println(\"*r* Error in \" + tz.getID() + \" \"\n                                   + new DateTime(millis,\n                                                  ISOChronology.getInstanceUTC()) + \" != \"\n                                   + new DateTime(trans - 1,\n                                                  ISOChronology.getInstanceUTC()));\n                                   \n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    \n    private Map<String, RuleSet> iRuleSets; private List<Zone> iZones; private List<String> iLinks; public ZoneInfoCompiler() {\n        iRuleSets = new HashMap<String, RuleSet>();\n        iZones = new ArrayList<Zone>();\n        iLinks = new ArrayList<String>();\n    }\n\n    \n    public Map<String, DateTimeZone> compile(File outputDir, File[] sources) throws IOException {\n        if (sources != null) {\n            for (int i=0; i<sources.length; i++) {\n                BufferedReader in = new BufferedReader(new FileReader(sources[i]));\n                parseDataFile(in);\n                in.close();\n            }\n        }\n\n        if (outputDir != null) {\n            if (!outputDir.exists()) {\n                if (!outputDir.mkdirs()) {\n                    throw new IOException(\"Destination directory doesn't exist and cannot be created: \" + outputDir);\n                }\n            }\n            if (!outputDir.isDirectory()) {\n                throw new IOException(\"Destination is not a directory: \" + outputDir);\n            }\n        }\n\n        Map<String, DateTimeZone> map = new TreeMap<String, DateTimeZone>();\n\n        System.out.println(\"Writing zoneinfo files\");\n        for (int i=0; i<iZones.size(); i++) {\n            Zone zone = iZones.get(i);\n            DateTimeZoneBuilder builder = new DateTimeZoneBuilder();\n            zone.addToBuilder(builder, iRuleSets);\n            final DateTimeZone original = builder.toDateTimeZone(zone.iName, true);\n            DateTimeZone tz = original;\n            if (test(tz.getID(), tz)) {\n                map.put(tz.getID(), tz);\n                if (outputDir != null) {\n                    if (ZoneInfoCompiler.verbose()) {\n                        System.out.println(\"Writing \" + tz.getID());\n                    }\n                    File file = new File(outputDir, tz.getID());\n                    if (!file.getParentFile().exists()) {\n                        file.getParentFile().mkdirs();\n                    }\n                    OutputStream out = new FileOutputStream(file);\n                    try {\n                        builder.writeTo(zone.iName, out);\n                    } finally {\n                        out.close();\n                    }\n\n                    \n                    InputStream in = new FileInputStream(file);\n                    DateTimeZone tz2 = DateTimeZoneBuilder.readFrom(in, tz.getID());\n                    in.close();\n\n                    if (!original.equals(tz2)) {\n                        System.out.println(\"*e* Error in \" + tz.getID() +\n                                           \": Didn't read properly from file\");\n                    }\n                }\n            }\n        }\n\n        for (int pass=0; pass<2; pass++) {\n            for (int i=0; i<iLinks.size(); i += 2) {\n                String id = iLinks.get(i);\n                String alias = iLinks.get(i + 1);\n                DateTimeZone tz = map.get(id);\n                if (tz == null) {\n                    if (pass > 0) {\n                        System.out.println(\"Cannot find time zone '\" + id +\n                                           \"' to link alias '\" + alias + \"' to\");\n                    }\n                } else {\n                    map.put(alias, tz);\n                }\n            }\n        }\n\n        if (outputDir != null) {\n            System.out.println(\"Writing ZoneInfoMap\");\n            File file = new File(outputDir, \"ZoneInfoMap\");\n            if (!file.getParentFile().exists()) {\n                file.getParentFile().mkdirs();\n            }\n\n            OutputStream out = new FileOutputStream(file);\n            DataOutputStream dout = new DataOutputStream(out);\n            try {\n                \n                Map<String, DateTimeZone> zimap = new TreeMap<String, DateTimeZone>(String.CASE_INSENSITIVE_ORDER);\n                zimap.putAll(map);\n                writeZoneInfoMap(dout, zimap);\n            } finally {\n                dout.close();\n            }\n        }\n\n        return map;\n    }\n\n    public void parseDataFile(BufferedReader in) throws IOException {\n        Zone zone = null;\n        String line;\n        while ((line = in.readLine()) != null) {\n            String trimmed = line.trim();\n            if (trimmed.length() == 0 || trimmed.charAt(0) == '#') {\n                continue;\n            }\n\n            int index = line.indexOf('#');\n            if (index >= 0) {\n                line = line.substring(0, index);\n            }\n\n            \n\n            StringTokenizer st = new StringTokenizer(line, \" \\t\");\n\n            if (Character.isWhitespace(line.charAt(0)) && st.hasMoreTokens()) {\n                if (zone != null) {\n                    \n                    zone.chain(st);\n                }\n                continue;\n            } else {\n                if (zone != null) {\n                    iZones.add(zone);\n                }\n                zone = null;\n            }\n\n            if (st.hasMoreTokens()) {\n                String token = st.nextToken();\n                if (token.equalsIgnoreCase(\"Rule\")) {\n                    Rule r = new Rule(st);\n                    RuleSet rs = iRuleSets.get(r.iName);\n                    if (rs == null) {\n                        rs = new RuleSet(r);\n                        iRuleSets.put(r.iName, rs);\n                    } else {\n                        rs.addRule(r);\n                    }\n                } else if (token.equalsIgnoreCase(\"Zone\")) {\n                    zone = new Zone(st);\n                } else if (token.equalsIgnoreCase(\"Link\")) {\n                    iLinks.add(st.nextToken());\n                    iLinks.add(st.nextToken());\n                } else {\n                    System.out.println(\"Unknown line: \" + line);\n                }\n            }\n        }\n\n        if (zone != null) {\n            iZones.add(zone);\n        }\n    }\n\n    static class DateTimeOfYear { public final int iMonthOfYear; public final int iDayOfMonth; public final int iDayOfWeek; public final boolean iAdvanceDayOfWeek; public final int iMillisOfDay; public final char iZoneChar; DateTimeOfYear() {\n            iMonthOfYear = 1;\n            iDayOfMonth = 1;\n            iDayOfWeek = 0;\n            iAdvanceDayOfWeek = false;\n            iMillisOfDay = 0;\n            iZoneChar = 'w';\n        }\n\n        DateTimeOfYear(StringTokenizer st) {\n            int month = 1;\n            int day = 1;\n            int dayOfWeek = 0;\n            int millis = 0;\n            boolean advance = false;\n            char zoneChar = 'w';\n\n            if (st.hasMoreTokens()) {\n                month = parseMonth(st.nextToken());\n\n                if (st.hasMoreTokens()) {\n                    String str = st.nextToken();\n                    if (str.startsWith(\"last\")) {\n                        day = -1;\n                        dayOfWeek = parseDayOfWeek(str.substring(4));\n                        advance = false;\n                    } else {\n                        try {\n                            day = Integer.parseInt(str);\n                            dayOfWeek = 0;\n                            advance = false;\n                        } catch (NumberFormatException e) {\n                            int index = str.indexOf(\">=\");\n                            if (index > 0) {\n                                day = Integer.parseInt(str.substring(index + 2));\n                                dayOfWeek = parseDayOfWeek(str.substring(0, index));\n                                advance = true;\n                            } else {\n                                index = str.indexOf(\"<=\");\n                                if (index > 0) {\n                                    day = Integer.parseInt(str.substring(index + 2));\n                                    dayOfWeek = parseDayOfWeek(str.substring(0, index));\n                                    advance = false;\n                                } else {\n                                    throw new IllegalArgumentException(str);\n                                }\n                            }\n                        }\n                    }\n\n                    if (st.hasMoreTokens()) {\n                        str = st.nextToken();\n                        zoneChar = parseZoneChar(str.charAt(str.length() - 1));\n                        if (str.equals(\"24:00\")) {\n                            LocalDate date = (day == -1 ?\n                                    new LocalDate(2001, month, 1).plusMonths(1) :\n                                    new LocalDate(2001, month, day).plusDays(1));\n                            advance = (day != -1);\n                            month = date.getMonthOfYear();\n                            day = date.getDayOfMonth();\n                            dayOfWeek = ((dayOfWeek - 1 + 1) % 7) + 1;\n                        } else {\n                            millis = parseTime(str);\n                        }\n                    }\n                }\n            }\n\n            iMonthOfYear = month;\n            iDayOfMonth = day;\n            iDayOfWeek = dayOfWeek;\n            iAdvanceDayOfWeek = advance;\n            iMillisOfDay = millis;\n            iZoneChar = zoneChar;\n        }\n\n        \n        public void addRecurring(DateTimeZoneBuilder builder, String nameKey, int saveMillis, int fromYear, int toYear) {\n            builder.addRecurringSavings(nameKey, saveMillis,\n                                        fromYear, toYear,\n                                        iZoneChar,\n                                        iMonthOfYear,\n                                        iDayOfMonth,\n                                        iDayOfWeek,\n                                        iAdvanceDayOfWeek,\n                                        iMillisOfDay);\n        }\n\n        \n        public void addCutover(DateTimeZoneBuilder builder, int year) {\n            builder.addCutover(year,\n                               iZoneChar,\n                               iMonthOfYear,\n                               iDayOfMonth,\n                               iDayOfWeek,\n                               iAdvanceDayOfWeek,\n                               iMillisOfDay);\n        }\n\n        public String toString() {\n            return\n                \"MonthOfYear: \" + iMonthOfYear + \"\\n\" +\n                \"DayOfMonth: \" + iDayOfMonth + \"\\n\" +\n                \"DayOfWeek: \" + iDayOfWeek + \"\\n\" +\n                \"AdvanceDayOfWeek: \" + iAdvanceDayOfWeek + \"\\n\" +\n                \"MillisOfDay: \" + iMillisOfDay + \"\\n\" +\n                \"ZoneChar: \" + iZoneChar + \"\\n\";\n        }\n    }\n\n    private static class Rule { public final String iName; public final int iFromYear; public final int iToYear; public final String iType; public final DateTimeOfYear iDateTimeOfYear; public final int iSaveMillis; public final String iLetterS; Rule(StringTokenizer st) {\n            iName = st.nextToken().intern();\n            iFromYear = parseYear(st.nextToken(), 0);\n            iToYear = parseYear(st.nextToken(), iFromYear);\n            if (iToYear < iFromYear) {\n                throw new IllegalArgumentException();\n            }\n            iType = parseOptional(st.nextToken());\n            iDateTimeOfYear = new DateTimeOfYear(st);\n            iSaveMillis = parseTime(st.nextToken());\n            iLetterS = parseOptional(st.nextToken());\n        }\n\n        \n        public void addRecurring(DateTimeZoneBuilder builder, String nameFormat) {\n            String nameKey = formatName(nameFormat);\n            iDateTimeOfYear.addRecurring\n                (builder, nameKey, iSaveMillis, iFromYear, iToYear);\n        }\n\n        private String formatName(String nameFormat) {\n            int index = nameFormat.indexOf('/');\n            if (index > 0) {\n                if (iSaveMillis == 0) {\n                    \n                    return nameFormat.substring(0, index).intern();\n                } else {\n                    return nameFormat.substring(index + 1).intern();\n                }\n            }\n            index = nameFormat.indexOf(\"%s\");\n            if (index < 0) {\n                return nameFormat;\n            }\n            String left = nameFormat.substring(0, index);\n            String right = nameFormat.substring(index + 2);\n            String name;\n            if (iLetterS == null) {\n                name = left.concat(right);\n            } else {\n                name = left + iLetterS + right;\n            }\n            return name.intern();\n        }\n\n        public String toString() {\n            return\n                \"[Rule]\\n\" + \n                \"Name: \" + iName + \"\\n\" +\n                \"FromYear: \" + iFromYear + \"\\n\" +\n                \"ToYear: \" + iToYear + \"\\n\" +\n                \"Type: \" + iType + \"\\n\" +\n                iDateTimeOfYear +\n                \"SaveMillis: \" + iSaveMillis + \"\\n\" +\n                \"LetterS: \" + iLetterS + \"\\n\";\n        }\n    }\n\n    private static class RuleSet { private List<Rule> iRules; RuleSet(Rule rule) {\n            iRules = new ArrayList<Rule>();\n            iRules.add(rule);\n        }\n\n        void addRule(Rule rule) {\n            if (!(rule.iName.equals(iRules.get(0).iName))) {\n                throw new IllegalArgumentException(\"Rule name mismatch\");\n            }\n            iRules.add(rule);\n        }\n\n        \n        public void addRecurring(DateTimeZoneBuilder builder, String nameFormat) {\n            for (int i=0; i<iRules.size(); i++) {\n                Rule rule = iRules.get(i);\n                rule.addRecurring(builder, nameFormat);\n            }\n        }\n    }\n\n    private static class Zone { public final String iName; public final int iOffsetMillis; public final String iRules; public final String iFormat; public final int iUntilYear; public final DateTimeOfYear iUntilDateTimeOfYear; private Zone iNext; Zone(StringTokenizer st) {\n            this(st.nextToken(), st);\n        }\n\n        private Zone(String name, StringTokenizer st) {\n            iName = name.intern();\n            iOffsetMillis = parseTime(st.nextToken());\n            iRules = parseOptional(st.nextToken());\n            iFormat = st.nextToken().intern();\n\n            int year = Integer.MAX_VALUE;\n            DateTimeOfYear dtOfYear = getStartOfYear();\n\n            if (st.hasMoreTokens()) {\n                year = Integer.parseInt(st.nextToken());\n                if (st.hasMoreTokens()) {\n                    dtOfYear = new DateTimeOfYear(st);\n                }\n            }\n\n            iUntilYear = year;\n            iUntilDateTimeOfYear = dtOfYear;\n        }\n\n        void chain(StringTokenizer st) {\n            if (iNext != null) {\n                iNext.chain(st);\n            } else {\n                iNext = new Zone(iName, st);\n            }\n        }\n\n        \n\n        \n        public void addToBuilder(DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets) {\n            addToBuilder(this, builder, ruleSets);\n        }\n\n        private static void addToBuilder(Zone zone, DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets) {\n            for (; zone != null; zone = zone.iNext) {\n                builder.setStandardOffset(zone.iOffsetMillis);\n\n                if (zone.iRules == null) {\n                    builder.setFixedSavings(zone.iFormat, 0);\n                } else {\n                    try {\n                        \n                        int saveMillis = parseTime(zone.iRules);\n                        builder.setFixedSavings(zone.iFormat, saveMillis);\n                    }\n                    catch (Exception e) {\n                        RuleSet rs = ruleSets.get(zone.iRules);\n                        if (rs == null) {\n                            throw new IllegalArgumentException\n                                (\"Rules not found: \" + zone.iRules);\n                        }\n                        rs.addRecurring(builder, zone.iFormat);\n                    }\n                }\n\n                if (zone.iUntilYear == Integer.MAX_VALUE) {\n                    break;\n                }\n\n                zone.iUntilDateTimeOfYear.addCutover(builder, zone.iUntilYear);\n            }\n        }\n\n        public String toString() {\n            String str =\n                \"[Zone]\\n\" + \n                \"Name: \" + iName + \"\\n\" +\n                \"OffsetMillis: \" + iOffsetMillis + \"\\n\" +\n                \"Rules: \" + iRules + \"\\n\" +\n                \"Format: \" + iFormat + \"\\n\" +\n                \"UntilYear: \" + iUntilYear + \"\\n\" +\n                iUntilDateTimeOfYear;\n\n            if (iNext == null) {\n                return str;\n            }\n\n            return str + \"...\\n\" + iNext.toString();\n        }\n    }\n}\n\n",
      "fixed_full_code": "\npackage org.joda.time.tz;\n\nimport java.io.BufferedReader;\nimport java.io.DataOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\nimport java.util.Map.Entry;\n\nimport org.joda.time.Chronology;\nimport org.joda.time.DateTime;\nimport org.joda.time.DateTimeField;\nimport org.joda.time.DateTimeZone;\nimport org.joda.time.LocalDate;\nimport org.joda.time.MutableDateTime;\nimport org.joda.time.chrono.ISOChronology;\nimport org.joda.time.chrono.LenientChronology;\nimport org.joda.time.format.DateTimeFormatter;\nimport org.joda.time.format.ISODateTimeFormat;\n\n\npublic class ZoneInfoCompiler { static DateTimeOfYear cStartOfYear; static Chronology cLenientISO; static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>() {\n        protected Boolean initialValue() {\n            return Boolean.FALSE;\n        }\n    };\n\n    \n    public static boolean verbose() {\n        return cVerbose.get();\n    }\n\n    \n    \n    public static void main(String[] args) throws Exception {\n        if (args.length == 0) {\n            printUsage();\n            return;\n        }\n\n        File inputDir = null;\n        File outputDir = null;\n        boolean verbose = false;\n\n        int i;\n        for (i=0; i<args.length; i++) {\n            try {\n                if (\"-src\".equals(args[i])) {\n                    inputDir = new File(args[++i]);\n                } else if (\"-dst\".equals(args[i])) {\n                    outputDir = new File(args[++i]);\n                } else if (\"-verbose\".equals(args[i])) {\n                    verbose = true;\n                } else if (\"-?\".equals(args[i])) {\n                    printUsage();\n                    return;\n                } else {\n                    break;\n                }\n            } catch (IndexOutOfBoundsException e) {\n                printUsage();\n                return;\n            }\n        }\n\n        if (i >= args.length) {\n            printUsage();\n            return;\n        }\n\n        File[] sources = new File[args.length - i];\n        for (int j=0; i<args.length; i++,j++) {\n            sources[j] = inputDir == null ? new File(args[i]) : new File(inputDir, args[i]);\n        }\n\n        cVerbose.set(verbose);\n        ZoneInfoCompiler zic = new ZoneInfoCompiler();\n        zic.compile(outputDir, sources);\n    }\n\n    private static void printUsage() {\n        System.out.println(\"Usage: java org.joda.time.tz.ZoneInfoCompiler <options> <source files>\");\n        System.out.println(\"where possible options include:\");\n        System.out.println(\"  -src <directory>    Specify where to read source files\");\n        System.out.println(\"  -dst <directory>    Specify where to write generated files\");\n        System.out.println(\"  -verbose            Output verbosely (default false)\");\n    }\n\n    static DateTimeOfYear getStartOfYear() {\n        if (cStartOfYear == null) {\n            cStartOfYear = new DateTimeOfYear();\n        }\n        return cStartOfYear;\n    }\n\n    static Chronology getLenientISOChronology() {\n        if (cLenientISO == null) {\n            cLenientISO = LenientChronology.getInstance(ISOChronology.getInstanceUTC());\n        }\n        return cLenientISO;\n    }\n\n    \n    static void writeZoneInfoMap(DataOutputStream dout, Map<String, DateTimeZone> zimap) throws IOException {\n        \n        Map<String, Short> idToIndex = new HashMap<String, Short>(zimap.size());\n        TreeMap<Short, String> indexToId = new TreeMap<Short, String>();\n\n        short count = 0;\n        for (Entry<String, DateTimeZone> entry : zimap.entrySet()) {\n            String id = (String)entry.getKey();\n            if (!idToIndex.containsKey(id)) {\n                Short index = Short.valueOf(count);\n                idToIndex.put(id, index);\n                indexToId.put(index, id);\n                if (++count == 0) {\n                    throw new InternalError(\"Too many time zone ids\");\n                }\n            }\n            id = ((DateTimeZone)entry.getValue()).getID();\n            if (!idToIndex.containsKey(id)) {\n                Short index = Short.valueOf(count);\n                idToIndex.put(id, index);\n                indexToId.put(index, id);\n                if (++count == 0) {\n                    throw new InternalError(\"Too many time zone ids\");\n                }\n            }\n        }\n\n        \n        dout.writeShort(indexToId.size());\n        for (String id : indexToId.values()) {\n            dout.writeUTF(id);\n        }\n\n        \n        dout.writeShort(zimap.size());\n        for (Entry<String, DateTimeZone> entry : zimap.entrySet()) {\n            String id = entry.getKey();\n            dout.writeShort(idToIndex.get(id).shortValue());\n            id = entry.getValue().getID();\n            dout.writeShort(idToIndex.get(id).shortValue());\n        }\n    }\n\n    static int parseYear(String str, int def) {\n        str = str.toLowerCase();\n        if (str.equals(\"minimum\") || str.equals(\"min\")) {\n            return Integer.MIN_VALUE;\n        } else if (str.equals(\"maximum\") || str.equals(\"max\")) {\n            return Integer.MAX_VALUE;\n        } else if (str.equals(\"only\")) {\n            return def;\n        }\n        return Integer.parseInt(str);\n    }\n\n    static int parseMonth(String str) {\n        DateTimeField field = ISOChronology.getInstanceUTC().monthOfYear();\n        return field.get(field.set(0, str, Locale.ENGLISH));\n    }\n\n    static int parseDayOfWeek(String str) {\n        DateTimeField field = ISOChronology.getInstanceUTC().dayOfWeek();\n        return field.get(field.set(0, str, Locale.ENGLISH));\n    }\n    \n    static String parseOptional(String str) {\n        return (str.equals(\"-\")) ? null : str;\n    }\n\n    static int parseTime(String str) {\n        DateTimeFormatter p = ISODateTimeFormat.hourMinuteSecondFraction();\n        MutableDateTime mdt = new MutableDateTime(0, getLenientISOChronology());\n        int pos = 0;\n        if (str.startsWith(\"-\")) {\n            pos = 1;\n        }\n        int newPos = p.parseInto(mdt, str, pos);\n        if (newPos == ~pos) {\n            throw new IllegalArgumentException(str);\n        }\n        int millis = (int)mdt.getMillis();\n        if (pos == 1) {\n            millis = -millis;\n        }\n        return millis;\n    }\n\n    static char parseZoneChar(char c) {\n        switch (c) {\n        case 's': case 'S':\n            \n            return 's';\n        case 'u': case 'U': case 'g': case 'G': case 'z': case 'Z':\n            \n            return 'u';\n        case 'w': case 'W': default:\n            \n            return 'w';\n        }\n    }\n\n    \n    static boolean test(String id, DateTimeZone tz) {\n        if (!id.equals(tz.getID())) {\n            return true;\n        }\n\n        \n\n        long millis = ISOChronology.getInstanceUTC().year().set(0, 1850);\n        long end = ISOChronology.getInstanceUTC().year().set(0, 2050);\n\n        int offset = tz.getOffset(millis);\n        String key = tz.getNameKey(millis);\n\n        List<Long> transitions = new ArrayList<Long>();\n\n        while (true) {\n            long next = tz.nextTransition(millis);\n            if (next == millis || next > end) {\n                break;\n            }\n\n            millis = next;\n\n            int nextOffset = tz.getOffset(millis);\n            String nextKey = tz.getNameKey(millis);\n\n            if (offset == nextOffset\n                && key.equals(nextKey)) {\n                System.out.println(\"*d* Error in \" + tz.getID() + \" \"\n                                   + new DateTime(millis,\n                                                  ISOChronology.getInstanceUTC()));\n                return false;\n            }\n\n            if (nextKey == null || (nextKey.length() < 3 && !\"??\".equals(nextKey))) {\n                System.out.println(\"*s* Error in \" + tz.getID() + \" \"\n                                   + new DateTime(millis,\n                                                  ISOChronology.getInstanceUTC())\n                                   + \", nameKey=\" + nextKey);\n                return false;\n            }\n\n            transitions.add(Long.valueOf(millis));\n\n            offset = nextOffset;\n            key = nextKey;\n        }\n\n        \n\n        millis = ISOChronology.getInstanceUTC().year().set(0, 2050);\n        end = ISOChronology.getInstanceUTC().year().set(0, 1850);\n\n        for (int i=transitions.size(); --i>= 0; ) {\n            long prev = tz.previousTransition(millis);\n            if (prev == millis || prev < end) {\n                break;\n            }\n\n            millis = prev;\n\n            long trans = transitions.get(i).longValue();\n            \n            if (trans - 1 != millis) {\n                System.out.println(\"*r* Error in \" + tz.getID() + \" \"\n                                   + new DateTime(millis,\n                                                  ISOChronology.getInstanceUTC()) + \" != \"\n                                   + new DateTime(trans - 1,\n                                                  ISOChronology.getInstanceUTC()));\n                                   \n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    \n    private Map<String, RuleSet> iRuleSets; private List<Zone> iZones; private List<String> iLinks; public ZoneInfoCompiler() {\n        iRuleSets = new HashMap<String, RuleSet>();\n        iZones = new ArrayList<Zone>();\n        iLinks = new ArrayList<String>();\n    }\n\n    \n    public Map<String, DateTimeZone> compile(File outputDir, File[] sources) throws IOException {\n        if (sources != null) {\n            for (int i=0; i<sources.length; i++) {\n                BufferedReader in = new BufferedReader(new FileReader(sources[i]));\n                parseDataFile(in);\n                in.close();\n            }\n        }\n\n        if (outputDir != null) {\n            if (!outputDir.exists()) {\n                if (!outputDir.mkdirs()) {\n                    throw new IOException(\"Destination directory doesn't exist and cannot be created: \" + outputDir);\n                }\n            }\n            if (!outputDir.isDirectory()) {\n                throw new IOException(\"Destination is not a directory: \" + outputDir);\n            }\n        }\n\n        Map<String, DateTimeZone> map = new TreeMap<String, DateTimeZone>();\n\n        System.out.println(\"Writing zoneinfo files\");\n        for (int i=0; i<iZones.size(); i++) {\n            Zone zone = iZones.get(i);\n            DateTimeZoneBuilder builder = new DateTimeZoneBuilder();\n            zone.addToBuilder(builder, iRuleSets);\n            final DateTimeZone original = builder.toDateTimeZone(zone.iName, true);\n            DateTimeZone tz = original;\n            if (test(tz.getID(), tz)) {\n                map.put(tz.getID(), tz);\n                if (outputDir != null) {\n                    if (ZoneInfoCompiler.verbose()) {\n                        System.out.println(\"Writing \" + tz.getID());\n                    }\n                    File file = new File(outputDir, tz.getID());\n                    if (!file.getParentFile().exists()) {\n                        file.getParentFile().mkdirs();\n                    }\n                    OutputStream out = new FileOutputStream(file);\n                    try {\n                        builder.writeTo(zone.iName, out);\n                    } finally {\n                        out.close();\n                    }\n\n                    \n                    InputStream in = new FileInputStream(file);\n                    DateTimeZone tz2 = DateTimeZoneBuilder.readFrom(in, tz.getID());\n                    in.close();\n\n                    if (!original.equals(tz2)) {\n                        System.out.println(\"*e* Error in \" + tz.getID() +\n                                           \": Didn't read properly from file\");\n                    }\n                }\n            }\n        }\n\n        for (int pass=0; pass<2; pass++) {\n            for (int i=0; i<iLinks.size(); i += 2) {\n                String id = iLinks.get(i);\n                String alias = iLinks.get(i + 1);\n                DateTimeZone tz = map.get(id);\n                if (tz == null) {\n                    if (pass > 0) {\n                        System.out.println(\"Cannot find time zone '\" + id +\n                                           \"' to link alias '\" + alias + \"' to\");\n                    }\n                } else {\n                    map.put(alias, tz);\n                }\n            }\n        }\n\n        if (outputDir != null) {\n            System.out.println(\"Writing ZoneInfoMap\");\n            File file = new File(outputDir, \"ZoneInfoMap\");\n            if (!file.getParentFile().exists()) {\n                file.getParentFile().mkdirs();\n            }\n\n            OutputStream out = new FileOutputStream(file);\n            DataOutputStream dout = new DataOutputStream(out);\n            try {\n                \n                Map<String, DateTimeZone> zimap = new TreeMap<String, DateTimeZone>(String.CASE_INSENSITIVE_ORDER);\n                zimap.putAll(map);\n                writeZoneInfoMap(dout, zimap);\n            } finally {\n                dout.close();\n            }\n        }\n\n        return map;\n    }\n\n    public void parseDataFile(BufferedReader in) throws IOException {\n        Zone zone = null;\n        String line;\n        while ((line = in.readLine()) != null) {\n            String trimmed = line.trim();\n            if (trimmed.length() == 0 || trimmed.charAt(0) == '#') {\n                continue;\n            }\n\n            int index = line.indexOf('#');\n            if (index >= 0) {\n                line = line.substring(0, index);\n            }\n\n            \n\n            StringTokenizer st = new StringTokenizer(line, \" \\t\");\n\n            if (Character.isWhitespace(line.charAt(0)) && st.hasMoreTokens()) {\n                if (zone != null) {\n                    \n                    zone.chain(st);\n                }\n                continue;\n            } else {\n                if (zone != null) {\n                    iZones.add(zone);\n                }\n                zone = null;\n            }\n\n            if (st.hasMoreTokens()) {\n                String token = st.nextToken();\n                if (token.equalsIgnoreCase(\"Rule\")) {\n                    Rule r = new Rule(st);\n                    RuleSet rs = iRuleSets.get(r.iName);\n                    if (rs == null) {\n                        rs = new RuleSet(r);\n                        iRuleSets.put(r.iName, rs);\n                    } else {\n                        rs.addRule(r);\n                    }\n                } else if (token.equalsIgnoreCase(\"Zone\")) {\n                    zone = new Zone(st);\n                } else if (token.equalsIgnoreCase(\"Link\")) {\n                    iLinks.add(st.nextToken());\n                    iLinks.add(st.nextToken());\n                } else {\n                    System.out.println(\"Unknown line: \" + line);\n                }\n            }\n        }\n\n        if (zone != null) {\n            iZones.add(zone);\n        }\n    }\n\n    static class DateTimeOfYear { public final int iMonthOfYear; public final int iDayOfMonth; public final int iDayOfWeek; public final boolean iAdvanceDayOfWeek; public final int iMillisOfDay; public final char iZoneChar; DateTimeOfYear() {\n            iMonthOfYear = 1;\n            iDayOfMonth = 1;\n            iDayOfWeek = 0;\n            iAdvanceDayOfWeek = false;\n            iMillisOfDay = 0;\n            iZoneChar = 'w';\n        }\n\n        DateTimeOfYear(StringTokenizer st) {\n            int month = 1;\n            int day = 1;\n            int dayOfWeek = 0;\n            int millis = 0;\n            boolean advance = false;\n            char zoneChar = 'w';\n\n            if (st.hasMoreTokens()) {\n                month = parseMonth(st.nextToken());\n\n                if (st.hasMoreTokens()) {\n                    String str = st.nextToken();\n                    if (str.startsWith(\"last\")) {\n                        day = -1;\n                        dayOfWeek = parseDayOfWeek(str.substring(4));\n                        advance = false;\n                    } else {\n                        try {\n                            day = Integer.parseInt(str);\n                            dayOfWeek = 0;\n                            advance = false;\n                        } catch (NumberFormatException e) {\n                            int index = str.indexOf(\">=\");\n                            if (index > 0) {\n                                day = Integer.parseInt(str.substring(index + 2));\n                                dayOfWeek = parseDayOfWeek(str.substring(0, index));\n                                advance = true;\n                            } else {\n                                index = str.indexOf(\"<=\");\n                                if (index > 0) {\n                                    day = Integer.parseInt(str.substring(index + 2));\n                                    dayOfWeek = parseDayOfWeek(str.substring(0, index));\n                                    advance = false;\n                                } else {\n                                    throw new IllegalArgumentException(str);\n                                }\n                            }\n                        }\n                    }\n\n                    if (st.hasMoreTokens()) {\n                        str = st.nextToken();\n                        zoneChar = parseZoneChar(str.charAt(str.length() - 1));\n                        if (str.equals(\"24:00\")) {\n                            LocalDate date = (day == -1 ?\n                                    new LocalDate(2001, month, 1).plusMonths(1) :\n                                    new LocalDate(2001, month, day).plusDays(1));\n                            advance = (day != -1);\n                            month = date.getMonthOfYear();\n                            day = date.getDayOfMonth();\n                            dayOfWeek = ((dayOfWeek - 1 + 1) % 7) + 1;\n                        } else {\n                            millis = parseTime(str);\n                        }\n                    }\n                }\n            }\n\n            iMonthOfYear = month;\n            iDayOfMonth = day;\n            iDayOfWeek = dayOfWeek;\n            iAdvanceDayOfWeek = advance;\n            iMillisOfDay = millis;\n            iZoneChar = zoneChar;\n        }\n\n        \n        public void addRecurring(DateTimeZoneBuilder builder, String nameKey, int saveMillis, int fromYear, int toYear) {\n            builder.addRecurringSavings(nameKey, saveMillis,\n                                        fromYear, toYear,\n                                        iZoneChar,\n                                        iMonthOfYear,\n                                        iDayOfMonth,\n                                        iDayOfWeek,\n                                        iAdvanceDayOfWeek,\n                                        iMillisOfDay);\n        }\n\n        \n        public void addCutover(DateTimeZoneBuilder builder, int year) {\n            builder.addCutover(year,\n                               iZoneChar,\n                               iMonthOfYear,\n                               iDayOfMonth,\n                               iDayOfWeek,\n                               iAdvanceDayOfWeek,\n                               iMillisOfDay);\n        }\n\n        public String toString() {\n            return\n                \"MonthOfYear: \" + iMonthOfYear + \"\\n\" +\n                \"DayOfMonth: \" + iDayOfMonth + \"\\n\" +\n                \"DayOfWeek: \" + iDayOfWeek + \"\\n\" +\n                \"AdvanceDayOfWeek: \" + iAdvanceDayOfWeek + \"\\n\" +\n                \"MillisOfDay: \" + iMillisOfDay + \"\\n\" +\n                \"ZoneChar: \" + iZoneChar + \"\\n\";\n        }\n    }\n\n    private static class Rule { public final String iName; public final int iFromYear; public final int iToYear; public final String iType; public final DateTimeOfYear iDateTimeOfYear; public final int iSaveMillis; public final String iLetterS; Rule(StringTokenizer st) {\n            iName = st.nextToken().intern();\n            iFromYear = parseYear(st.nextToken(), 0);\n            iToYear = parseYear(st.nextToken(), iFromYear);\n            if (iToYear < iFromYear) {\n                throw new IllegalArgumentException();\n            }\n            iType = parseOptional(st.nextToken());\n            iDateTimeOfYear = new DateTimeOfYear(st);\n            iSaveMillis = parseTime(st.nextToken());\n            iLetterS = parseOptional(st.nextToken());\n        }\n\n        \n        public void addRecurring(DateTimeZoneBuilder builder, String nameFormat) {\n            String nameKey = formatName(nameFormat);\n            iDateTimeOfYear.addRecurring\n                (builder, nameKey, iSaveMillis, iFromYear, iToYear);\n        }\n\n        private String formatName(String nameFormat) {\n            int index = nameFormat.indexOf('/');\n            if (index > 0) {\n                if (iSaveMillis == 0) {\n                    \n                    return nameFormat.substring(0, index).intern();\n                } else {\n                    return nameFormat.substring(index + 1).intern();\n                }\n            }\n            index = nameFormat.indexOf(\"%s\");\n            if (index < 0) {\n                return nameFormat;\n            }\n            String left = nameFormat.substring(0, index);\n            String right = nameFormat.substring(index + 2);\n            String name;\n            if (iLetterS == null) {\n                name = left.concat(right);\n            } else {\n                name = left + iLetterS + right;\n            }\n            return name.intern();\n        }\n\n        public String toString() {\n            return\n                \"[Rule]\\n\" + \n                \"Name: \" + iName + \"\\n\" +\n                \"FromYear: \" + iFromYear + \"\\n\" +\n                \"ToYear: \" + iToYear + \"\\n\" +\n                \"Type: \" + iType + \"\\n\" +\n                iDateTimeOfYear +\n                \"SaveMillis: \" + iSaveMillis + \"\\n\" +\n                \"LetterS: \" + iLetterS + \"\\n\";\n        }\n    }\n\n    private static class RuleSet { private List<Rule> iRules; RuleSet(Rule rule) {\n            iRules = new ArrayList<Rule>();\n            iRules.add(rule);\n        }\n\n        void addRule(Rule rule) {\n            if (!(rule.iName.equals(iRules.get(0).iName))) {\n                throw new IllegalArgumentException(\"Rule name mismatch\");\n            }\n            iRules.add(rule);\n        }\n\n        \n        public void addRecurring(DateTimeZoneBuilder builder, String nameFormat) {\n            for (int i=0; i<iRules.size(); i++) {\n                Rule rule = iRules.get(i);\n                rule.addRecurring(builder, nameFormat);\n            }\n        }\n    }\n\n    private static class Zone { public final String iName; public final int iOffsetMillis; public final String iRules; public final String iFormat; public final int iUntilYear; public final DateTimeOfYear iUntilDateTimeOfYear; private Zone iNext; Zone(StringTokenizer st) {\n            this(st.nextToken(), st);\n        }\n\n        private Zone(String name, StringTokenizer st) {\n            iName = name.intern();\n            iOffsetMillis = parseTime(st.nextToken());\n            iRules = parseOptional(st.nextToken());\n            iFormat = st.nextToken().intern();\n\n            int year = Integer.MAX_VALUE;\n            DateTimeOfYear dtOfYear = getStartOfYear();\n\n            if (st.hasMoreTokens()) {\n                year = Integer.parseInt(st.nextToken());\n                if (st.hasMoreTokens()) {\n                    dtOfYear = new DateTimeOfYear(st);\n                }\n            }\n\n            iUntilYear = year;\n            iUntilDateTimeOfYear = dtOfYear;\n        }\n\n        void chain(StringTokenizer st) {\n            if (iNext != null) {\n                iNext.chain(st);\n            } else {\n                iNext = new Zone(iName, st);\n            }\n        }\n\n        \n\n        \n        public void addToBuilder(DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets) {\n            addToBuilder(this, builder, ruleSets);\n        }\n\n        private static void addToBuilder(Zone zone, DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets) {\n            for (; zone != null; zone = zone.iNext) {\n                builder.setStandardOffset(zone.iOffsetMillis);\n\n                if (zone.iRules == null) {\n                    builder.setFixedSavings(zone.iFormat, 0);\n                } else {\n                    try {\n                        \n                        int saveMillis = parseTime(zone.iRules);\n                        builder.setFixedSavings(zone.iFormat, saveMillis);\n                    }\n                    catch (Exception e) {\n                        RuleSet rs = ruleSets.get(zone.iRules);\n                        if (rs == null) {\n                            throw new IllegalArgumentException\n                                (\"Rules not found: \" + zone.iRules);\n                        }\n                        rs.addRecurring(builder, zone.iFormat);\n                    }\n                }\n\n                if (zone.iUntilYear == Integer.MAX_VALUE) {\n                    break;\n                }\n\n                zone.iUntilDateTimeOfYear.addCutover(builder, zone.iUntilYear);\n            }\n        }\n\n        public String toString() {\n            String str =\n                \"[Zone]\\n\" + \n                \"Name: \" + iName + \"\\n\" +\n                \"OffsetMillis: \" + iOffsetMillis + \"\\n\" +\n                \"Rules: \" + iRules + \"\\n\" +\n                \"Format: \" + iFormat + \"\\n\" +\n                \"UntilYear: \" + iUntilYear + \"\\n\" +\n                iUntilDateTimeOfYear;\n\n            if (iNext == null) {\n                return str;\n            }\n\n            return str + \"...\\n\" + iNext.toString();\n        }\n    }\n}\n\n",
      "buggy_signatures": [
        "public static boolean verbose()",
        "public static void main(String[] args) throws Exception",
        "private static void printUsage()",
        "static DateTimeOfYear getStartOfYear()",
        "static Chronology getLenientISOChronology()",
        "static void writeZoneInfoMap(DataOutputStream dout, Map<String, DateTimeZone> zimap) throws IOException",
        "static int parseYear(String str, int def)",
        "static int parseMonth(String str)",
        "static int parseDayOfWeek(String str)",
        "static String parseOptional(String str)",
        "static int parseTime(String str)",
        "static char parseZoneChar(char c)",
        "static boolean test(String id, DateTimeZone tz)",
        "private Map<String, RuleSet> iRuleSets; private List<Zone> iZones; private List<String> iLinks; public ZoneInfoCompiler()",
        "public Map<String, DateTimeZone> compile(File outputDir, File[] sources) throws IOException",
        "public void parseDataFile(BufferedReader in) throws IOException",
        "static class DateTimeOfYear { public final int iMonthOfYear; public final int iDayOfMonth; public final int iDayOfWeek; public final boolean iAdvanceDayOfWeek; public final int iMillisOfDay; public final char iZoneChar; DateTimeOfYear()",
        "public void addRecurring(DateTimeZoneBuilder builder, String nameKey, int saveMillis, int fromYear, int toYear)",
        "public void addCutover(DateTimeZoneBuilder builder, int year)",
        "public String toString()",
        "private static class Rule { public final String iName; public final int iFromYear; public final int iToYear; public final String iType; public final DateTimeOfYear iDateTimeOfYear; public final int iSaveMillis; public final String iLetterS; Rule(StringTokenizer st)",
        "public void addRecurring(DateTimeZoneBuilder builder, String nameFormat)",
        "private String formatName(String nameFormat)",
        "public String toString()",
        "private static class RuleSet { private List<Rule> iRules; RuleSet(Rule rule)",
        "public void addRecurring(DateTimeZoneBuilder builder, String nameFormat)",
        "private static class Zone { public final String iName; public final int iOffsetMillis; public final String iRules; public final String iFormat; public final int iUntilYear; public final DateTimeOfYear iUntilDateTimeOfYear; private Zone iNext; Zone(StringTokenizer st)",
        "private Zone(String name, StringTokenizer st)",
        "public void addToBuilder(DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets)",
        "private static void addToBuilder(Zone zone, DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets)",
        "public String toString()"
      ],
      "fixed_signatures": [
        "protected Boolean initialValue()",
        "public static boolean verbose()",
        "public static void main(String[] args) throws Exception",
        "private static void printUsage()",
        "static DateTimeOfYear getStartOfYear()",
        "static Chronology getLenientISOChronology()",
        "static void writeZoneInfoMap(DataOutputStream dout, Map<String, DateTimeZone> zimap) throws IOException",
        "static int parseYear(String str, int def)",
        "static int parseMonth(String str)",
        "static int parseDayOfWeek(String str)",
        "static String parseOptional(String str)",
        "static int parseTime(String str)",
        "static char parseZoneChar(char c)",
        "static boolean test(String id, DateTimeZone tz)",
        "private Map<String, RuleSet> iRuleSets; private List<Zone> iZones; private List<String> iLinks; public ZoneInfoCompiler()",
        "public Map<String, DateTimeZone> compile(File outputDir, File[] sources) throws IOException",
        "public void parseDataFile(BufferedReader in) throws IOException",
        "static class DateTimeOfYear { public final int iMonthOfYear; public final int iDayOfMonth; public final int iDayOfWeek; public final boolean iAdvanceDayOfWeek; public final int iMillisOfDay; public final char iZoneChar; DateTimeOfYear()",
        "public void addRecurring(DateTimeZoneBuilder builder, String nameKey, int saveMillis, int fromYear, int toYear)",
        "public void addCutover(DateTimeZoneBuilder builder, int year)",
        "public String toString()",
        "private static class Rule { public final String iName; public final int iFromYear; public final int iToYear; public final String iType; public final DateTimeOfYear iDateTimeOfYear; public final int iSaveMillis; public final String iLetterS; Rule(StringTokenizer st)",
        "public void addRecurring(DateTimeZoneBuilder builder, String nameFormat)",
        "private String formatName(String nameFormat)",
        "public String toString()",
        "private static class RuleSet { private List<Rule> iRules; RuleSet(Rule rule)",
        "public void addRecurring(DateTimeZoneBuilder builder, String nameFormat)",
        "private static class Zone { public final String iName; public final int iOffsetMillis; public final String iRules; public final String iFormat; public final int iUntilYear; public final DateTimeOfYear iUntilDateTimeOfYear; private Zone iNext; Zone(StringTokenizer st)",
        "private Zone(String name, StringTokenizer st)",
        "public void addToBuilder(DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets)",
        "private static void addToBuilder(Zone zone, DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets)",
        "public String toString()"
      ],
      "methods": [
        {
          "buggy_method": "  static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>(); static {\n  cVerbose.set(Boolean.FALSE);\n  }",
          "fixed_method": "  protected Boolean initialValue() {\n  return Boolean.FALSE;\n  }",
          "diff": [
            "@@ -65,10 +65,11 @@",
            " \n",
            "     static Chronology cLenientISO;\n",
            " \n",
            "-    static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>();\n",
            "-    static {\n",
            "-        cVerbose.set(Boolean.FALSE);\n",
            "-    }\n",
            "+    static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>() {\n",
            "+        protected Boolean initialValue() {\n",
            "+            return Boolean.FALSE;\n",
            "+        }\n",
            "+    };\n",
            " \n",
            "     /**\n",
            "      * Gets a flag indicating that verbose logging is required.\n"
          ],
          "changed_lines": 9
        }
      ]
    }
  ]
}
