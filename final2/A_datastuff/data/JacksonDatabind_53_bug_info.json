{
  "bug_id": "53",
  "failed_tests": {
    "com.fasterxml.jackson.databind.jsontype.TypeRefinementForMap1215Test": [
      {
        "methodName": "testMapRefinement",
        "error": "com.fasterxml.jackson.databind.JsonMappingException",
        "message": "Can not construct instance of com.fasterxml.jackson.databind.jsontype.TypeRefinementForMap1215Test$HasUniqueId, problem: abstract types either need to be mapped to concrete types, have custom deserializer, or be instantiated with additional type information",
        "fail_line": "        Data data = m.readValue(json, Data.class);",
        "test_source": "  public void testMapRefinement() throws Exception {\n  String ID1 = \"3a6383d4-8123-4c43-8b8d-7cedf3e59404\";\n  String ID2 = \"81c3d978-90c4-4b00-8da1-1c39ffcab02c\";\n  String json = aposToQuotes(\n\"{'id':'\"+ID1+\"','items':[{'id':'\"+ID2+\"','property':'value'}]}\");\n\n  ObjectMapper m = new ObjectMapper();\n  Data data = m.readValue(json, Data.class);\n\n  assertEquals(ID1, data.id);\n  assertNotNull(data.items);\n  assertEquals(1, data.items.size());\n  Item value = data.items.get(ID2);\n  assertNotNull(value);\n  assertEquals(\"value\", value.property);\n  }",
        "stack": [
          "JsonMappingException.from line 255, DeserializationContext.instantiationException line 1007, AbstractDeserializer.deserialize line 150, ObjectArrayDeserializer.deserialize line 196, ObjectArrayDeserializer.deserialize line 20, MapDeserializer.deserialize line 325, MapDeserializer.deserialize line 26, SettableBeanProperty.deserialize line 490, FieldProperty.deserializeAndSet line 101, BeanDeserializer.vanillaDeserialize line 260, BeanDeserializer.deserialize line 125, ObjectMapper._readMapAndClose line 3807, ObjectMapper.readValue line 2797, TypeRefinementForMap1215Test.testMapRefinement line 65"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "com/fasterxml/jackson/databind/type/TypeBindings.java",
      "buggy_full_code": "package com.fasterxml.jackson.databind.type;\n\nimport java.lang.reflect.*;\nimport java.util.*;\n\nimport com.fasterxml.jackson.databind.JavaType;\n\n\npublic class TypeBindings implements java.io.Serializable { private static final long serialVersionUID = 1L; private final static String[] NO_STRINGS = new String[0]; private final static JavaType[] NO_TYPES = new JavaType[0]; private final static TypeBindings EMPTY = new TypeBindings(NO_STRINGS, NO_TYPES, null); private final String[] _names; private final JavaType[] _types; private final String[] _unboundVariables; private final int _hashCode; private TypeBindings(String[] names, JavaType[] types, String[] uvars) {\n        _names = (names == null) ? NO_STRINGS : names;\n        _types = (types == null) ? NO_TYPES : types;\n        if (_names.length != _types.length) {\n            throw new IllegalArgumentException(\"Mismatching names (\"+_names.length+\"), types (\"+_types.length+\")\");\n        }\n        int h = 1;\n        for (int i = 0, len = _types.length; i < len; ++i) {\n            h += _types[i].hashCode();\n        }\n        _unboundVariables = uvars;\n        _hashCode = h;\n    }\n\n    public static TypeBindings emptyBindings() {\n        return EMPTY;\n    }\n\n    \n    protected Object readResolve() {\n        if ((_names == null) || (_names.length == 0)) {\n            return EMPTY;\n        }\n        return this;\n    }\n\n    \n    public static TypeBindings create(Class<?> erasedType, List<JavaType> typeList) {\n        JavaType[] types = (typeList == null || typeList.isEmpty()) ?\n                NO_TYPES : typeList.toArray(new JavaType[typeList.size()]);\n        return create(erasedType, types);\n    }\n\n    public static TypeBindings create(Class<?> erasedType, JavaType[] types) {\n        if (types == null) {\n            types = NO_TYPES;\n        } else switch (types.length) {\n        case 1:\n            return create(erasedType, types[0]);\n        case 2:\n            return create(erasedType, types[0], types[1]);\n        }\n        TypeVariable<?>[] vars = erasedType.getTypeParameters();\n        String[] names;\n        if (vars == null || vars.length == 0) {\n            names = NO_STRINGS;\n        } else {\n            int len = vars.length;\n            names = new String[len];\n            for (int i = 0; i < len; ++i) {\n                names[i] = vars[i].getName();\n            }\n        }\n        \n        if (names.length != types.length) {\n            throw new IllegalArgumentException(\"Can not create TypeBindings for class \"+erasedType.getName()\n                   +\" with \"+types.length+\" type parameter\"\n                   +((types.length == 1) ? \"\" : \"s\")+\": class expects \"+names.length);\n        }\n        return new TypeBindings(names, types, null);\n    }\n\n    public static TypeBindings create(Class<?> erasedType, JavaType typeArg1) {\n        \n        TypeVariable<?>[] vars = TypeParamStash.paramsFor1(erasedType);\n        int varLen = (vars == null) ? 0 : vars.length;\n        if (varLen != 1) {\n            throw new IllegalArgumentException(\"Can not create TypeBindings for class \"+erasedType.getName()\n                    +\" with 1 type parameter: class expects \"+varLen);\n        }\n        return new TypeBindings(new String[] { vars[0].getName() },\n                new JavaType[] { typeArg1 }, null);\n    }\n\n    public static TypeBindings create(Class<?> erasedType, JavaType typeArg1, JavaType typeArg2) {\n        \n        TypeVariable<?>[] vars = TypeParamStash.paramsFor2(erasedType);\n        int varLen = (vars == null) ? 0 : vars.length;\n        if (varLen != 2) {\n            throw new IllegalArgumentException(\"Can not create TypeBindings for class \"+erasedType.getName()\n                    +\" with 2 type parameters: class expects \"+varLen);\n        }\n        return new TypeBindings(new String[] { vars[0].getName(), vars[1].getName() },\n                new JavaType[] { typeArg1, typeArg2 }, null);\n    }\n    \n    \n    public static TypeBindings createIfNeeded(Class<?> erasedType, JavaType typeArg1) {\n        TypeVariable<?>[] vars = erasedType.getTypeParameters();\n        int varLen = (vars == null) ? 0 : vars.length;\n        if (varLen == 0) {\n            return EMPTY;\n        }\n        if (varLen != 1) {\n            throw new IllegalArgumentException(\"Can not create TypeBindings for class \"+erasedType.getName()\n                    +\" with 1 type parameter: class expects \"+varLen);\n        }\n        return new TypeBindings(new String[] { vars[0].getName() },\n                new JavaType[] { typeArg1 }, null);\n    }\n    \n    \n    public static TypeBindings createIfNeeded(Class<?> erasedType, JavaType[] types) {\n        TypeVariable<?>[] vars = erasedType.getTypeParameters();\n        if (vars == null || vars.length == 0) {\n            return EMPTY;\n        }\n        if (types == null) {\n            types = NO_TYPES;\n        }\n        int len = vars.length;\n        String[] names = new String[len];\n        for (int i = 0; i < len; ++i) {\n            names[i] = vars[i].getName();\n        }\n        \n        if (names.length != types.length) {\n            throw new IllegalArgumentException(\"Can not create TypeBindings for class \"+erasedType.getName()\n                   +\" with \"+types.length+\" type parameter\"\n                   +((types.length == 1) ? \"\" : \"s\")+\": class expects \"+names.length);\n        }\n        return new TypeBindings(names, types, null);\n    }\n    \n    \n    public TypeBindings withUnboundVariable(String name) {\n        int len = (_unboundVariables == null) ? 0 : _unboundVariables.length;\n        String[] names =  (len == 0)\n                ? new String[1] : Arrays.copyOf(_unboundVariables, len+1);\n        names[len] = name;\n        return new TypeBindings(_names, _types, names);\n    }\n\n    \n\n    \n    public JavaType findBoundType(String name) {\n        for (int i = 0, len = _names.length; i < len; ++i) {\n            if (name.equals(_names[i])) {\n                JavaType t = _types[i];\n                if (t instanceof ResolvedRecursiveType) {\n                    ResolvedRecursiveType rrt = (ResolvedRecursiveType) t;\n                    JavaType t2 = rrt.getSelfReferencedType();\n                    if (t2 != null) {\n                        t = t2;\n                    } else {\n                        \n\n                    }\n                }\n                return t;\n            }\n        }\n        return null;\n    }\n\n    public boolean isEmpty() {\n        return (_types.length == 0);\n    }\n    \n    \n    public int size() { \n        return _types.length;\n    }\n\n    public String getBoundName(int index) {\n        if (index < 0 || index >= _names.length) {\n            return null;\n        }\n        return _names[index];\n    }\n\n    public JavaType getBoundType(int index) {\n        if (index < 0 || index >= _types.length) {\n            return null;\n        }\n        return _types[index];\n    }\n\n    \n    public List<JavaType> getTypeParameters() {\n        if (_types.length == 0) {\n            return Collections.emptyList();\n        }\n        return Arrays.asList(_types);\n    }\n\n    \n    public boolean hasUnbound(String name) {\n        if (_unboundVariables != null) {\n            for (int i = _unboundVariables.length; --i >= 0; ) {\n                if (name.equals(_unboundVariables[i])) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    \n        \n        \n\n    \n    \n    @Override public String toString() {\n        if (_types.length == 0) {\n            return \"<>\";\n        }\n        StringBuilder sb = new StringBuilder();\n        sb.append('<');\n        for (int i = 0, len = _types.length; i < len; ++i) {\n            if (i > 0) {\n                sb.append(',');\n            }\n\n            String sig = _types[i].getGenericSignature();\n            sb.append(sig);\n        }\n        sb.append('>');\n        return sb.toString();\n    }\n\n    @Override public int hashCode() { return _hashCode; }\n\n    @Override public boolean equals(Object o) {\n        if (o == this) return true;\n        if (o == null || o.getClass() != getClass()) return false;\n        TypeBindings other = (TypeBindings) o;\n        int len = _types.length;\n        if (len != other.size()) {\n            return false;\n        }\n        JavaType[] otherTypes = other._types;\n        for (int i = 0; i < len; ++i) {\n            if (!otherTypes[i].equals(_types[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n\n    protected JavaType[] typeParameterArray() {\n        return _types;\n    }\n\n    \n\n    \n    \n    \n\n    \n    static class TypeParamStash { private final static TypeVariable<?>[] VARS_ABSTRACT_LIST = AbstractList.class.getTypeParameters(); private final static TypeVariable<?>[] VARS_COLLECTION = Collection.class.getTypeParameters(); private final static TypeVariable<?>[] VARS_ITERABLE = Iterable.class.getTypeParameters(); private final static TypeVariable<?>[] VARS_LIST = List.class.getTypeParameters(); private final static TypeVariable<?>[] VARS_ARRAY_LIST = ArrayList.class.getTypeParameters(); private final static TypeVariable<?>[] VARS_MAP = Map.class.getTypeParameters(); private final static TypeVariable<?>[] VARS_HASH_MAP = HashMap.class.getTypeParameters(); private final static TypeVariable<?>[] VARS_LINKED_HASH_MAP = LinkedHashMap.class.getTypeParameters(); public static TypeVariable<?>[] paramsFor1(Class<?> erasedType) {\n            if (erasedType == Collection.class) {\n                return VARS_COLLECTION;\n            }\n            if (erasedType == List.class) {\n                return VARS_LIST;\n            }\n            if (erasedType == ArrayList.class) {\n                return VARS_ARRAY_LIST;\n            }\n            if (erasedType == AbstractList.class) {\n                return VARS_ABSTRACT_LIST;\n            }\n            if (erasedType == Iterable.class) {\n                return VARS_ITERABLE;\n            }\n            return erasedType.getTypeParameters();\n        }    \n\n        public static TypeVariable<?>[] paramsFor2(Class<?> erasedType) {\n            if (erasedType == Map.class) {\n                return VARS_MAP;\n            }\n            if (erasedType == HashMap.class) {\n                return VARS_HASH_MAP;\n            }\n            if (erasedType == LinkedHashMap.class) {\n                return VARS_LINKED_HASH_MAP;\n            }\n            return erasedType.getTypeParameters();\n        }    \n    }\n\n    \n\n\n}\n",
      "fixed_full_code": "package com.fasterxml.jackson.databind.type;\n\nimport java.lang.reflect.*;\nimport java.util.*;\n\nimport com.fasterxml.jackson.databind.JavaType;\n\n\npublic class TypeBindings implements java.io.Serializable { private static final long serialVersionUID = 1L; private final static String[] NO_STRINGS = new String[0]; private final static JavaType[] NO_TYPES = new JavaType[0]; private final static TypeBindings EMPTY = new TypeBindings(NO_STRINGS, NO_TYPES, null); private final String[] _names; private final JavaType[] _types; private final String[] _unboundVariables; private final int _hashCode; private TypeBindings(String[] names, JavaType[] types, String[] uvars) {\n        _names = (names == null) ? NO_STRINGS : names;\n        _types = (types == null) ? NO_TYPES : types;\n        if (_names.length != _types.length) {\n            throw new IllegalArgumentException(\"Mismatching names (\"+_names.length+\"), types (\"+_types.length+\")\");\n        }\n        int h = 1;\n        for (int i = 0, len = _types.length; i < len; ++i) {\n            h += _types[i].hashCode();\n        }\n        _unboundVariables = uvars;\n        _hashCode = h;\n    }\n\n    public static TypeBindings emptyBindings() {\n        return EMPTY;\n    }\n\n    \n    protected Object readResolve() {\n        if ((_names == null) || (_names.length == 0)) {\n            return EMPTY;\n        }\n        return this;\n    }\n\n    \n    public static TypeBindings create(Class<?> erasedType, List<JavaType> typeList) {\n        JavaType[] types = (typeList == null || typeList.isEmpty()) ?\n                NO_TYPES : typeList.toArray(new JavaType[typeList.size()]);\n        return create(erasedType, types);\n    }\n\n    public static TypeBindings create(Class<?> erasedType, JavaType[] types) {\n        if (types == null) {\n            types = NO_TYPES;\n        } else switch (types.length) {\n        case 1:\n            return create(erasedType, types[0]);\n        case 2:\n            return create(erasedType, types[0], types[1]);\n        }\n        TypeVariable<?>[] vars = erasedType.getTypeParameters();\n        String[] names;\n        if (vars == null || vars.length == 0) {\n            names = NO_STRINGS;\n        } else {\n            int len = vars.length;\n            names = new String[len];\n            for (int i = 0; i < len; ++i) {\n                names[i] = vars[i].getName();\n            }\n        }\n        \n        if (names.length != types.length) {\n            throw new IllegalArgumentException(\"Can not create TypeBindings for class \"+erasedType.getName()\n                   +\" with \"+types.length+\" type parameter\"\n                   +((types.length == 1) ? \"\" : \"s\")+\": class expects \"+names.length);\n        }\n        return new TypeBindings(names, types, null);\n    }\n\n    public static TypeBindings create(Class<?> erasedType, JavaType typeArg1) {\n        \n        TypeVariable<?>[] vars = TypeParamStash.paramsFor1(erasedType);\n        int varLen = (vars == null) ? 0 : vars.length;\n        if (varLen != 1) {\n            throw new IllegalArgumentException(\"Can not create TypeBindings for class \"+erasedType.getName()\n                    +\" with 1 type parameter: class expects \"+varLen);\n        }\n        return new TypeBindings(new String[] { vars[0].getName() },\n                new JavaType[] { typeArg1 }, null);\n    }\n\n    public static TypeBindings create(Class<?> erasedType, JavaType typeArg1, JavaType typeArg2) {\n        \n        TypeVariable<?>[] vars = TypeParamStash.paramsFor2(erasedType);\n        int varLen = (vars == null) ? 0 : vars.length;\n        if (varLen != 2) {\n            throw new IllegalArgumentException(\"Can not create TypeBindings for class \"+erasedType.getName()\n                    +\" with 2 type parameters: class expects \"+varLen);\n        }\n        return new TypeBindings(new String[] { vars[0].getName(), vars[1].getName() },\n                new JavaType[] { typeArg1, typeArg2 }, null);\n    }\n    \n    \n    public static TypeBindings createIfNeeded(Class<?> erasedType, JavaType typeArg1) {\n        TypeVariable<?>[] vars = erasedType.getTypeParameters();\n        int varLen = (vars == null) ? 0 : vars.length;\n        if (varLen == 0) {\n            return EMPTY;\n        }\n        if (varLen != 1) {\n            throw new IllegalArgumentException(\"Can not create TypeBindings for class \"+erasedType.getName()\n                    +\" with 1 type parameter: class expects \"+varLen);\n        }\n        return new TypeBindings(new String[] { vars[0].getName() },\n                new JavaType[] { typeArg1 }, null);\n    }\n    \n    \n    public static TypeBindings createIfNeeded(Class<?> erasedType, JavaType[] types) {\n        TypeVariable<?>[] vars = erasedType.getTypeParameters();\n        if (vars == null || vars.length == 0) {\n            return EMPTY;\n        }\n        if (types == null) {\n            types = NO_TYPES;\n        }\n        int len = vars.length;\n        String[] names = new String[len];\n        for (int i = 0; i < len; ++i) {\n            names[i] = vars[i].getName();\n        }\n        \n        if (names.length != types.length) {\n            throw new IllegalArgumentException(\"Can not create TypeBindings for class \"+erasedType.getName()\n                   +\" with \"+types.length+\" type parameter\"\n                   +((types.length == 1) ? \"\" : \"s\")+\": class expects \"+names.length);\n        }\n        return new TypeBindings(names, types, null);\n    }\n    \n    \n    public TypeBindings withUnboundVariable(String name) {\n        int len = (_unboundVariables == null) ? 0 : _unboundVariables.length;\n        String[] names =  (len == 0)\n                ? new String[1] : Arrays.copyOf(_unboundVariables, len+1);\n        names[len] = name;\n        return new TypeBindings(_names, _types, names);\n    }\n\n    \n\n    \n    public JavaType findBoundType(String name) {\n        for (int i = 0, len = _names.length; i < len; ++i) {\n            if (name.equals(_names[i])) {\n                JavaType t = _types[i];\n                if (t instanceof ResolvedRecursiveType) {\n                    ResolvedRecursiveType rrt = (ResolvedRecursiveType) t;\n                    JavaType t2 = rrt.getSelfReferencedType();\n                    if (t2 != null) {\n                        t = t2;\n                    } else {\n                        \n\n                    }\n                }\n                return t;\n            }\n        }\n        return null;\n    }\n\n    public boolean isEmpty() {\n        return (_types.length == 0);\n    }\n    \n    \n    public int size() { \n        return _types.length;\n    }\n\n    public String getBoundName(int index) {\n        if (index < 0 || index >= _names.length) {\n            return null;\n        }\n        return _names[index];\n    }\n\n    public JavaType getBoundType(int index) {\n        if (index < 0 || index >= _types.length) {\n            return null;\n        }\n        return _types[index];\n    }\n\n    \n    public List<JavaType> getTypeParameters() {\n        if (_types.length == 0) {\n            return Collections.emptyList();\n        }\n        return Arrays.asList(_types);\n    }\n\n    \n    public boolean hasUnbound(String name) {\n        if (_unboundVariables != null) {\n            for (int i = _unboundVariables.length; --i >= 0; ) {\n                if (name.equals(_unboundVariables[i])) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    \n    public Object asKey(Class<?> rawBase) {\n        \n        \n        return new AsKey(rawBase, _types, _hashCode);\n    }\n\n    \n    \n    @Override public String toString() {\n        if (_types.length == 0) {\n            return \"<>\";\n        }\n        StringBuilder sb = new StringBuilder();\n        sb.append('<');\n        for (int i = 0, len = _types.length; i < len; ++i) {\n            if (i > 0) {\n                sb.append(',');\n            }\n\n            String sig = _types[i].getGenericSignature();\n            sb.append(sig);\n        }\n        sb.append('>');\n        return sb.toString();\n    }\n\n    @Override public int hashCode() { return _hashCode; }\n\n    @Override public boolean equals(Object o) {\n        if (o == this) return true;\n        if (o == null || o.getClass() != getClass()) return false;\n        TypeBindings other = (TypeBindings) o;\n        int len = _types.length;\n        if (len != other.size()) {\n            return false;\n        }\n        JavaType[] otherTypes = other._types;\n        for (int i = 0; i < len; ++i) {\n            if (!otherTypes[i].equals(_types[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n\n    protected JavaType[] typeParameterArray() {\n        return _types;\n    }\n\n    \n\n    \n    \n    \n\n    \n    static class TypeParamStash { private final static TypeVariable<?>[] VARS_ABSTRACT_LIST = AbstractList.class.getTypeParameters(); private final static TypeVariable<?>[] VARS_COLLECTION = Collection.class.getTypeParameters(); private final static TypeVariable<?>[] VARS_ITERABLE = Iterable.class.getTypeParameters(); private final static TypeVariable<?>[] VARS_LIST = List.class.getTypeParameters(); private final static TypeVariable<?>[] VARS_ARRAY_LIST = ArrayList.class.getTypeParameters(); private final static TypeVariable<?>[] VARS_MAP = Map.class.getTypeParameters(); private final static TypeVariable<?>[] VARS_HASH_MAP = HashMap.class.getTypeParameters(); private final static TypeVariable<?>[] VARS_LINKED_HASH_MAP = LinkedHashMap.class.getTypeParameters(); public static TypeVariable<?>[] paramsFor1(Class<?> erasedType) {\n            if (erasedType == Collection.class) {\n                return VARS_COLLECTION;\n            }\n            if (erasedType == List.class) {\n                return VARS_LIST;\n            }\n            if (erasedType == ArrayList.class) {\n                return VARS_ARRAY_LIST;\n            }\n            if (erasedType == AbstractList.class) {\n                return VARS_ABSTRACT_LIST;\n            }\n            if (erasedType == Iterable.class) {\n                return VARS_ITERABLE;\n            }\n            return erasedType.getTypeParameters();\n        }    \n\n        public static TypeVariable<?>[] paramsFor2(Class<?> erasedType) {\n            if (erasedType == Map.class) {\n                return VARS_MAP;\n            }\n            if (erasedType == HashMap.class) {\n                return VARS_HASH_MAP;\n            }\n            if (erasedType == LinkedHashMap.class) {\n                return VARS_LINKED_HASH_MAP;\n            }\n            return erasedType.getTypeParameters();\n        }    \n    }\n\n    \n    final static class AsKey { private final Class<?> _raw; private final JavaType[] _params; private final int _hash; public AsKey(Class<?> raw, JavaType[] params, int hash) {\n            _raw = raw ;\n            _params = params;\n            _hash = hash;\n        }\n\n        @Override\n        public int hashCode() { return _hash; }\n\n        @Override\n        public boolean equals(Object o) {\n            if (o == this) return true;\n            if (o == null) return false;\n            if (o.getClass() != getClass()) return false;\n            AsKey other = (AsKey) o;\n\n            if ((_hash == other._hash) && (_raw == other._raw)) {\n                final JavaType[] otherParams = other._params;\n                final int len = _params.length;\n\n                if (len == otherParams.length) {\n                    for (int i = 0; i < len; ++i) {\n                        if (!_params[i].equals(otherParams[i])) {\n                            return false;\n                        }\n                    }\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        @Override\n        public String toString() {\n            return _raw.getName()+\"<>\";\n        }\n    }\n}\n",
      "buggy_signatures": [
        "public static TypeBindings emptyBindings()",
        "protected Object readResolve()",
        "public static TypeBindings create(Class<?> erasedType, List<JavaType> typeList)",
        "public static TypeBindings create(Class<?> erasedType, JavaType[] types)",
        "public static TypeBindings create(Class<?> erasedType, JavaType typeArg1)",
        "public static TypeBindings create(Class<?> erasedType, JavaType typeArg1, JavaType typeArg2)",
        "public static TypeBindings createIfNeeded(Class<?> erasedType, JavaType typeArg1)",
        "public static TypeBindings createIfNeeded(Class<?> erasedType, JavaType[] types)",
        "public TypeBindings withUnboundVariable(String name)",
        "public JavaType findBoundType(String name)",
        "public boolean isEmpty()",
        "public int size()",
        "public String getBoundName(int index)",
        "public JavaType getBoundType(int index)",
        "public List<JavaType> getTypeParameters()",
        "public boolean hasUnbound(String name)",
        "public String toString()",
        "public int hashCode()",
        "public boolean equals(Object o)",
        "protected JavaType[] typeParameterArray()",
        "public static TypeVariable<?>[] paramsFor2(Class<?> erasedType)"
      ],
      "fixed_signatures": [
        "public static TypeBindings emptyBindings()",
        "protected Object readResolve()",
        "public static TypeBindings create(Class<?> erasedType, List<JavaType> typeList)",
        "public static TypeBindings create(Class<?> erasedType, JavaType[] types)",
        "public static TypeBindings create(Class<?> erasedType, JavaType typeArg1)",
        "public static TypeBindings create(Class<?> erasedType, JavaType typeArg1, JavaType typeArg2)",
        "public static TypeBindings createIfNeeded(Class<?> erasedType, JavaType typeArg1)",
        "public static TypeBindings createIfNeeded(Class<?> erasedType, JavaType[] types)",
        "public TypeBindings withUnboundVariable(String name)",
        "public JavaType findBoundType(String name)",
        "public boolean isEmpty()",
        "public int size()",
        "public String getBoundName(int index)",
        "public JavaType getBoundType(int index)",
        "public List<JavaType> getTypeParameters()",
        "public boolean hasUnbound(String name)",
        "public Object asKey(Class<?> rawBase)",
        "public String toString()",
        "public int hashCode()",
        "public boolean equals(Object o)",
        "protected JavaType[] typeParameterArray()",
        "public static TypeVariable<?>[] paramsFor2(Class<?> erasedType)",
        "static class AsKey { private final Class<?> _raw; private final JavaType[] _params; private final int _hash; public AsKey(Class<?> raw, JavaType[] params, int hash)",
        "public int hashCode()",
        "public boolean equals(Object o)",
        "public String toString()"
      ],
      "methods": [
        {
          "buggy_method": "  public boolean hasUnbound(String name) {\n  if (_unboundVariables != null) {\n  for (int i = _unboundVariables.length; --i >= 0; ) {\n  if (name.equals(_unboundVariables[i])) {\n  return true;\n  }\n  }\n  }\n  return false;\n  }",
          "fixed_method": "  public Object asKey(Class<?> rawBase) {\n  \n  \n  return new AsKey(rawBase, _types, _hashCode);\n  }",
          "diff": [
            "@@ -299,8 +299,11 @@",
            "      *\n",
            "      * @since 2.8\n",
            "      */\n",
            "+    public Object asKey(Class<?> rawBase) {\n",
            "         // safe to pass _types array without copy since it is not exposed via\n",
            "         // any access, nor modified by this class\n",
            "+        return new AsKey(rawBase, _types, _hashCode);\n",
            "+    }\n",
            " \n",
            "     /*\n",
            "     /**********************************************************************\n"
          ],
          "changed_lines": 3
        },
        {
          "buggy_method": "  public static TypeVariable<?>[] paramsFor2(Class<?> erasedType) {\n  if (erasedType == Map.class) {\n  return VARS_MAP;\n  }\n  if (erasedType == HashMap.class) {\n  return VARS_HASH_MAP;\n  }\n  if (erasedType == LinkedHashMap.class) {\n  return VARS_LINKED_HASH_MAP;\n  }\n  return erasedType.getTypeParameters();\n  }  ",
          "fixed_method": "  public static TypeVariable<?>[] paramsFor2(Class<?> erasedType) {\n  if (erasedType == Map.class) {\n  return VARS_MAP;\n  }\n  if (erasedType == HashMap.class) {\n  return VARS_HASH_MAP;\n  }\n  if (erasedType == LinkedHashMap.class) {\n  return VARS_LINKED_HASH_MAP;\n  }\n  return erasedType.getTypeParameters();\n  }  ",
          "diff": [
            "@@ -425,6 +428,46 @@",
            "      *\n",
            "      * @since 2.8\n",
            "      */\n",
            "-\n",
            "-\n",
            "+    final static class AsKey {\n",
            "+        private final Class<?> _raw;\n",
            "+        private final JavaType[] _params;\n",
            "+        private final int _hash;\n",
            "+\n",
            "+        public AsKey(Class<?> raw, JavaType[] params, int hash) {\n",
            "+            _raw = raw ;\n",
            "+            _params = params;\n",
            "+            _hash = hash;\n",
            "+        }\n",
            "+\n",
            "+        @Override\n",
            "+        public int hashCode() { return _hash; }\n",
            "+\n",
            "+        @Override\n",
            "+        public boolean equals(Object o) {\n",
            "+            if (o == this) return true;\n",
            "+            if (o == null) return false;\n",
            "+            if (o.getClass() != getClass()) return false;\n",
            "+            AsKey other = (AsKey) o;\n",
            "+\n",
            "+            if ((_hash == other._hash) && (_raw == other._raw)) {\n",
            "+                final JavaType[] otherParams = other._params;\n",
            "+                final int len = _params.length;\n",
            "+\n",
            "+                if (len == otherParams.length) {\n",
            "+                    for (int i = 0; i < len; ++i) {\n",
            "+                        if (!_params[i].equals(otherParams[i])) {\n",
            "+                            return false;\n",
            "+                        }\n",
            "+                    }\n",
            "+                    return true;\n",
            "+                }\n",
            "+            }\n",
            "+            return false;\n",
            "+        }\n",
            "+\n",
            "+        @Override\n",
            "+        public String toString() {\n",
            "+            return _raw.getName()+\"<>\";\n",
            "+        }\n",
            "+    }\n",
            " }\n"
          ],
          "changed_lines": 44
        }
      ]
    },
    {
      "name": "com/fasterxml/jackson/databind/type/TypeFactory.java",
      "buggy_full_code": "package com.fasterxml.jackson.databind.type;\n\nimport java.util.*;\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.lang.reflect.*;\n\nimport com.fasterxml.jackson.core.type.TypeReference;\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.util.ArrayBuilders;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\nimport com.fasterxml.jackson.databind.util.LRUMap;\n\n\n@SuppressWarnings({\"rawtypes\" })\npublic final class TypeFactory implements java.io.Serializable { private static final long serialVersionUID = 1L; private final static JavaType[] NO_TYPES = new JavaType[0]; protected final static TypeFactory instance = new TypeFactory(); protected final static TypeBindings EMPTY_BINDINGS = TypeBindings.emptyBindings(); private final static Class<?> CLS_STRING = String.class; private final static Class<?> CLS_OBJECT = Object.class; private final static Class<?> CLS_COMPARABLE = Comparable.class; private final static Class<?> CLS_CLASS = Class.class; private final static Class<?> CLS_ENUM = Enum.class; private final static Class<?> CLS_BOOL = Boolean.TYPE; private final static Class<?> CLS_INT = Integer.TYPE; private final static Class<?> CLS_LONG = Long.TYPE; protected final static SimpleType CORE_TYPE_BOOL = new SimpleType(CLS_BOOL); protected final static SimpleType CORE_TYPE_INT = new SimpleType(CLS_INT); protected final static SimpleType CORE_TYPE_LONG = new SimpleType(CLS_LONG); protected final static SimpleType CORE_TYPE_STRING = new SimpleType(CLS_STRING); protected final static SimpleType CORE_TYPE_OBJECT = new SimpleType(CLS_OBJECT); protected final static SimpleType CORE_TYPE_COMPARABLE = new SimpleType(CLS_COMPARABLE); protected final static SimpleType CORE_TYPE_ENUM = new SimpleType(CLS_ENUM); protected final static SimpleType CORE_TYPE_CLASS = new SimpleType(CLS_CLASS); protected final LRUMap<Class<?>, JavaType> _typeCache = new LRUMap<Class<?>, JavaType>(16, 100); protected final TypeModifier[] _modifiers; protected final TypeParser _parser; protected final ClassLoader _classLoader; private TypeFactory() {\n        _parser = new TypeParser(this);\n        _modifiers = null;\n        _classLoader = null;\n    }\n\n    protected TypeFactory(TypeParser p, TypeModifier[] mods) {\n        this(p, mods, null);\n    }\n    \n    protected TypeFactory(TypeParser p, TypeModifier[] mods, ClassLoader classLoader) {\n        \n        _parser = p.withFactory(this);\n        _modifiers = mods;\n        _classLoader = classLoader;\n    }\n\n    public TypeFactory withModifier(TypeModifier mod) {\n        if (mod == null) { \n            return new TypeFactory(_parser, _modifiers, _classLoader);\n        }\n        if (_modifiers == null) {\n            return new TypeFactory(_parser, new TypeModifier[] { mod }, _classLoader);\n        }\n        return new TypeFactory(_parser, ArrayBuilders.insertInListNoDup(_modifiers, mod), _classLoader);\n    }\n    \n    public TypeFactory withClassLoader(ClassLoader classLoader) {\n        return new TypeFactory(_parser, _modifiers, classLoader);\n    }\n\n    \n    public static TypeFactory defaultInstance() { return instance; }\n\n    \n    public void clearCache() {\n        _typeCache.clear();\n    }\n\n    public ClassLoader getClassLoader() {\n        return _classLoader;\n    }\n    \n    \n    \n    \n    public static JavaType unknownType() {\n        return defaultInstance()._unknownType();\n    }\n\n    \n    public static Class<?> rawClass(Type t) {\n        if (t instanceof Class<?>) {\n            return (Class<?>) t;\n        }\n        \n        return defaultInstance().constructType(t).getRawClass();\n    }\n\n    \n\n    \n    public Class<?> findClass(String className) throws ClassNotFoundException {\n        if (className.indexOf('.') < 0) {\n            Class<?> prim = _findPrimitive(className);\n            if (prim != null) {\n                return prim;\n            }\n        }\n        \n        Throwable prob = null;\n        ClassLoader loader = this.getClassLoader();\n        if (loader == null) {\n          loader = \tThread.currentThread().getContextClassLoader();\n        }\n        if (loader != null) {\n            try {\n                return classForName(className, true, loader);\n            } catch (Exception e) {\n                prob = ClassUtil.getRootCause(e);\n            }\n        }\n        try {\n            return classForName(className);\n        } catch (Exception e) {\n            if (prob == null) {\n                prob = ClassUtil.getRootCause(e);\n            }\n        }\n        if (prob instanceof RuntimeException) {\n            throw (RuntimeException) prob;\n        }\n        throw new ClassNotFoundException(prob.getMessage(), prob);\n    }\n    \n    protected Class<?> classForName(String name, boolean initialize, ClassLoader loader) throws ClassNotFoundException {\n    \treturn Class.forName(name, true, loader);\n    }\n    \n    protected Class<?> classForName(String name) throws ClassNotFoundException {\n        return Class.forName(name);\n    }\n\n    protected Class<?> _findPrimitive(String className) {\n        if (\"int\".equals(className)) return Integer.TYPE;\n        if (\"long\".equals(className)) return Long.TYPE;\n        if (\"float\".equals(className)) return Float.TYPE;\n        if (\"double\".equals(className)) return Double.TYPE;\n        if (\"boolean\".equals(className)) return Boolean.TYPE;\n        if (\"byte\".equals(className)) return Byte.TYPE;\n        if (\"char\".equals(className)) return Character.TYPE;\n        if (\"short\".equals(className)) return Short.TYPE;\n        if (\"void\".equals(className)) return Void.TYPE;\n        return null;\n    }\n    \n    \n\n    \n    public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass) {\n        \n        final Class<?> rawBase = baseType.getRawClass();\n        if (rawBase == subclass) {\n            return baseType;\n        }\n\n        JavaType newType;\n\n        \n        do { \n            if (rawBase == Object.class) {\n                newType = _fromClass(null, subclass, TypeBindings.emptyBindings());\n                break;\n            }\n            if (!rawBase.isAssignableFrom(subclass)) {\n                throw new IllegalArgumentException(String.format(\n                        \"Class %s not subtype of %s\", subclass.getName(), baseType));\n            }\n            \n\n            \n            if (baseType.getBindings().isEmpty()) {\n                newType = _fromClass(null, subclass, TypeBindings.emptyBindings());     \n                break;\n            }\n            \n            if (baseType.isContainerType()) {\n                if (baseType.isMapLikeType()) {\n                    if ((subclass == HashMap.class)\n                            || (subclass == LinkedHashMap.class)\n                            || (subclass == EnumMap.class)\n                            || (subclass == TreeMap.class)) {\n                        newType = _fromClass(null, subclass,\n                                TypeBindings.create(subclass, baseType.getKeyType(), baseType.getContentType()));\n                        break;\n                    }\n                } else if (baseType.isCollectionLikeType()) {\n                    if ((subclass == ArrayList.class)\n                            || (subclass == LinkedList.class)\n                            || (subclass == HashSet.class)\n                            || (subclass == TreeSet.class)) {\n                        newType = _fromClass(null, subclass,\n                                TypeBindings.create(subclass, baseType.getContentType()));\n                        break;\n                    }\n                    \n                    \n                    if (rawBase == EnumSet.class) {\n                        return baseType;\n                    }\n                }\n            }\n            \n            int typeParamCount = subclass.getTypeParameters().length;\n            if (typeParamCount == 0) {\n                newType = _fromClass(null, subclass, TypeBindings.emptyBindings());     \n                break;\n            }\n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            if (baseType.isInterface()) {\n                newType = baseType.refine(subclass, TypeBindings.emptyBindings(), null, new JavaType[] { baseType });\n            } else {\n                newType = baseType.refine(subclass, TypeBindings.emptyBindings(), baseType, NO_TYPES);\n            }\n            \n            if (newType == null) {\n                TypeBindings tb = null;\n                if (baseType.containedTypeCount() == typeParamCount) {\n                    if (typeParamCount == 1) {\n                        tb = TypeBindings.create(subclass, baseType.containedType(0));\n                    } else if (typeParamCount == 2) {\n                        tb = TypeBindings.create(subclass, baseType.containedType(0),\n                                baseType.containedType(1));\n                    }\n                }\n                newType = _fromClass(null, subclass,\n                        (tb == null) ? TypeBindings.emptyBindings() : tb);\n            }\n        } while (false);\n\n        \n\n        return newType;\n\n        \n        \n        \n    }\n\n        \n        \n        \n\n    \n    public JavaType constructGeneralizedType(JavaType baseType, Class<?> superClass) {\n        \n        final Class<?> rawBase = baseType.getRawClass();\n        if (rawBase == superClass) {\n            return baseType;\n        }\n        JavaType superType = baseType.findSuperType(superClass);\n        if (superType == null) {\n            \n            if (!superClass.isAssignableFrom(rawBase)) {\n                throw new IllegalArgumentException(String.format(\n                        \"Class %s not a super-type of %s\", superClass.getName(), baseType));\n            }\n            \n            throw new IllegalArgumentException(String.format(\n                    \"Internal error: class %s not included as super-type for %s\",\n                    superClass.getName(), baseType));\n        }\n        return superType;\n    }\n\n    \n    public JavaType constructFromCanonical(String canonical) throws IllegalArgumentException {\n        return _parser.parse(canonical);\n    }\n\n    \n    public JavaType[] findTypeParameters(JavaType type, Class<?> expType) {\n        JavaType match = type.findSuperType(expType);\n        if (match == null) {\n            return NO_TYPES;\n        }\n        return match.getBindings().typeParameterArray();\n    }\n\n    \n    @Deprecated \n    public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType, TypeBindings bindings) {\n        return findTypeParameters(constructType(clz, bindings), expType);\n    }\n    \n    \n    @Deprecated \n    public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType) {\n        return findTypeParameters(constructType(clz), expType);\n    }\n\n    \n    public JavaType moreSpecificType(JavaType type1, JavaType type2) {\n        if (type1 == null) {\n            return type2;\n        }\n        if (type2 == null) {\n            return type1;\n        }\n        Class<?> raw1 = type1.getRawClass();\n        Class<?> raw2 = type2.getRawClass();\n        if (raw1 == raw2) {\n            return type1;\n        }\n        \n        if (raw1.isAssignableFrom(raw2)) {\n            return type2;\n        }\n        return type1;\n    }\n    \n    \n\n    public JavaType constructType(Type type) {\n        return _fromAny(null, type, EMPTY_BINDINGS);\n    }\n\n    public JavaType constructType(Type type, TypeBindings bindings) {\n        return _fromAny(null, type, bindings);\n    }\n    \n    public JavaType constructType(TypeReference<?> typeRef) {\n        \n        return _fromAny(null, typeRef.getType(), EMPTY_BINDINGS);\n\n        \n        \n\n        \n    }\n\n    \n    @Deprecated\n    public JavaType constructType(Type type, Class<?> contextClass) {\n        TypeBindings bindings = (contextClass == null)\n                ? TypeBindings.emptyBindings() : constructType(contextClass).getBindings();\n        return _fromAny(null, type, bindings);\n    }\n\n    \n    @Deprecated\n    public JavaType constructType(Type type, JavaType contextType) {\n        TypeBindings bindings = (contextType == null)\n                ? TypeBindings.emptyBindings() : contextType.getBindings();\n        return _fromAny(null, type, bindings);\n    }\n\n    \n\n    \n    public ArrayType constructArrayType(Class<?> elementType) {\n        return ArrayType.construct(_fromAny(null, elementType, null), null);\n    }\n    \n    \n    public ArrayType constructArrayType(JavaType elementType) {\n        return ArrayType.construct(elementType, null);\n    }\n\n    \n    public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, Class<?> elementClass) {\n        return constructCollectionType(collectionClass,\n                _fromClass(null, elementClass, EMPTY_BINDINGS));\n    }\n\n    \n    public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, JavaType elementType) {\n        \n        \n        return (CollectionType) _fromClass(null, collectionClass,\n                TypeBindings.create(collectionClass, elementType));\n    }\n\n    \n    public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, Class<?> elementClass) {\n        return constructCollectionLikeType(collectionClass,\n                _fromClass(null, elementClass, EMPTY_BINDINGS));\n    }\n    \n    \n    public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, JavaType elementType) {\n        JavaType type = _fromClass(null, collectionClass,\n                TypeBindings.createIfNeeded(collectionClass, elementType));\n        if (type instanceof CollectionLikeType) {\n            return (CollectionLikeType) type;\n        }\n        return CollectionLikeType.upgradeFrom(type, elementType);\n    }\n\n    \n    public MapType constructMapType(Class<? extends Map> mapClass, Class<?> keyClass, Class<?> valueClass) {\n        JavaType kt, vt;\n        if (mapClass == Properties.class) {\n            kt = vt = CORE_TYPE_STRING;\n        } else {\n            kt = _fromClass(null, keyClass, EMPTY_BINDINGS);\n            vt = _fromClass(null, valueClass, EMPTY_BINDINGS);\n        }\n        return constructMapType(mapClass, kt, vt);\n    }\n\n    \n    public MapType constructMapType(Class<? extends Map> mapClass, JavaType keyType, JavaType valueType) {\n        return (MapType) _fromClass(null, mapClass,\n                TypeBindings.create(mapClass, new JavaType[] {\n                        keyType, valueType\n                }));\n    }\n\n    \n    public MapLikeType constructMapLikeType(Class<?> mapClass, Class<?> keyClass, Class<?> valueClass) {\n        return constructMapLikeType(mapClass,\n                _fromClass(null, keyClass, EMPTY_BINDINGS),\n                _fromClass(null, valueClass, EMPTY_BINDINGS));\n    }\n\n    \n    public MapLikeType constructMapLikeType(Class<?> mapClass, JavaType keyType, JavaType valueType) {\n        \n        \n        JavaType type = _fromClass(null, mapClass,\n                TypeBindings.createIfNeeded(mapClass, new JavaType[] { keyType, valueType }));\n        if (type instanceof MapLikeType) {\n            return (MapLikeType) type;\n        }\n        return MapLikeType.upgradeFrom(type, keyType, valueType);\n    }\n\n    \n    public JavaType constructSimpleType(Class<?> rawType, JavaType[] parameterTypes) {\n        return _fromClass(null, rawType, TypeBindings.create(rawType, parameterTypes));\n    }\n\n    \n    @Deprecated\n    public JavaType constructSimpleType(Class<?> rawType, Class<?> parameterTarget, JavaType[] parameterTypes) {\n        return constructSimpleType(rawType, parameterTypes);\n    } \n\n    \n    public JavaType constructReferenceType(Class<?> rawType, JavaType referredType) {\n        return ReferenceType.construct(rawType, null, \n                null, null, \n                referredType);\n    }\n\n    \n    public JavaType uncheckedSimpleType(Class<?> cls) {\n        \n        return _constructSimple(cls, EMPTY_BINDINGS, null, null);\n    }\n\n    \n    public JavaType constructParametricType(Class<?> parametrized, Class<?>... parameterClasses) {\n        int len = parameterClasses.length;\n        JavaType[] pt = new JavaType[len];\n        for (int i = 0; i < len; ++i) {\n            pt[i] = _fromClass(null, parameterClasses[i], null);\n        }\n        return constructParametricType(parametrized, pt);\n    }\n\n    \n    public JavaType constructParametricType(Class<?> rawType, JavaType... parameterTypes) {\n        return _fromClass(null, rawType, TypeBindings.create(rawType, parameterTypes));\n    }\n\n    \n    public JavaType constructParametrizedType(Class<?> parametrized, Class<?> parametersFor, JavaType... parameterTypes) {\n        return constructParametricType(parametrized, parameterTypes);\n    }\n\n    \n    public JavaType constructParametrizedType(Class<?> parametrized, Class<?> parametersFor, Class<?>... parameterClasses) {\n        return constructParametricType(parametrized, parameterClasses);\n    }\n\n    \n\n    \n    public CollectionType constructRawCollectionType(Class<? extends Collection> collectionClass) {\n        return constructCollectionType(collectionClass, unknownType());\n    }\n\n    \n    public CollectionLikeType constructRawCollectionLikeType(Class<?> collectionClass) {\n        return constructCollectionLikeType(collectionClass, unknownType());\n    }\n\n    \n    public MapType constructRawMapType(Class<? extends Map> mapClass) {\n        return constructMapType(mapClass, unknownType(), unknownType());\n    }\n\n    \n    public MapLikeType constructRawMapLikeType(Class<?> mapClass) {\n        return constructMapLikeType(mapClass, unknownType(), unknownType());\n    }\n\n    \n\n    private JavaType _mapType(Class<?> rawClass, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) {\n        JavaType kt, vt;\n        \n        \n        if (rawClass == Properties.class) {\n            kt = vt = CORE_TYPE_STRING;\n        } else {\n            List<JavaType> typeParams = bindings.getTypeParameters();\n            \n            switch (typeParams.size()) {\n            case 0: \n                kt = vt = _unknownType();\n                break;\n            case 2:\n                kt = typeParams.get(0);\n                vt = typeParams.get(1);\n                break;\n            default:\n                throw new IllegalArgumentException(\"Strange Map type \"+rawClass.getName()+\": can not determine type parameters\");\n            }\n        }\n        return MapType.construct(rawClass, bindings, superClass, superInterfaces, kt, vt);\n    }\n\n    private JavaType _collectionType(Class<?> rawClass, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) {\n        List<JavaType> typeParams = bindings.getTypeParameters();\n        \n        JavaType ct;\n        if (typeParams.isEmpty()) {\n            ct = _unknownType();\n        } else if (typeParams.size() == 1) {\n            ct = typeParams.get(0);\n        } else {\n            throw new IllegalArgumentException(\"Strange Collection type \"+rawClass.getName()+\": can not determine type parameters\");\n        }\n        return CollectionType.construct(rawClass, bindings, superClass, superInterfaces, ct);\n    }\n\n    private JavaType _referenceType(Class<?> rawClass, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) {\n        List<JavaType> typeParams = bindings.getTypeParameters();\n        \n        JavaType ct;\n        if (typeParams.isEmpty()) {\n            ct = _unknownType();\n        } else if (typeParams.size() == 1) {\n            ct = typeParams.get(0);\n        } else {\n            throw new IllegalArgumentException(\"Strange Reference type \"+rawClass.getName()+\": can not determine type parameters\");\n        }\n        return ReferenceType.construct(rawClass, bindings, superClass, superInterfaces, ct);\n    }\n\n    \n    protected JavaType _constructSimple(Class<?> raw, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) {\n        if (bindings.isEmpty()) {\n            JavaType result = _findWellKnownSimple(raw);\n            if (result != null) {\n                return result;\n            }\n        }\n        return _newSimpleType(raw, bindings, superClass, superInterfaces);\n    }\n\n    \n    protected JavaType _newSimpleType(Class<?> raw, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) {\n        return new SimpleType(raw, bindings, superClass, superInterfaces);\n    }\n\n    protected JavaType _unknownType() {\n        \n        return CORE_TYPE_OBJECT;\n    }\n\n    \n    protected JavaType _findWellKnownSimple(Class<?> clz) {\n        if (clz.isPrimitive()) {\n            if (clz == CLS_BOOL) return CORE_TYPE_BOOL;\n            if (clz == CLS_INT) return CORE_TYPE_INT;\n            if (clz == CLS_LONG) return CORE_TYPE_LONG;\n        } else {\n            if (clz == CLS_STRING) return CORE_TYPE_STRING;\n            if (clz == CLS_OBJECT) return CORE_TYPE_OBJECT; \n        }\n        return null;\n    }\n\n    \n\n    \n    protected JavaType _fromAny(ClassStack context, Type type, TypeBindings bindings) {\n        JavaType resultType;\n\n        \n        if (type instanceof Class<?>) {\n            \n            resultType = _fromClass(context, (Class<?>) type, EMPTY_BINDINGS);\n        }\n        \n        else if (type instanceof ParameterizedType) {\n            resultType = _fromParamType(context, (ParameterizedType) type, bindings);\n        }\n        else if (type instanceof JavaType) { \n            \n            return (JavaType) type;\n        }\n        else if (type instanceof GenericArrayType) {\n            resultType = _fromArrayType(context, (GenericArrayType) type, bindings);\n        }\n        else if (type instanceof TypeVariable<?>) {\n            resultType = _fromVariable(context, (TypeVariable<?>) type, bindings);\n        }\n        else if (type instanceof WildcardType) {\n            resultType = _fromWildcard(context, (WildcardType) type, bindings);\n        } else {\n            \n            throw new IllegalArgumentException(\"Unrecognized Type: \"+((type == null) ? \"[null]\" : type.toString()));\n        }\n        \n        if (_modifiers != null) {\n            TypeBindings b = resultType.getBindings();\n            if (b == null) {\n                b = EMPTY_BINDINGS;\n            }\n            for (TypeModifier mod : _modifiers) {\n                JavaType t = mod.modifyType(resultType, type, b, this);\n                if (t == null) {\n                    throw new IllegalStateException(String.format(\n                            \"TypeModifier %s (of type %s) return null for type %s\",\n                            mod, mod.getClass().getName(), resultType));\n                }\n                resultType = t;\n            }\n        }\n        return resultType;\n    }\n\n    \n    protected JavaType _fromClass(ClassStack context, Class<?> rawType, TypeBindings bindings) {\n        \n        JavaType result = _findWellKnownSimple(rawType);\n        if (result != null) {\n            return result;\n        }\n        \n        boolean cachable = (bindings == null) || bindings.isEmpty();\n        if (cachable) {\n            result = _typeCache.get(rawType);\n        if (result != null) {\n            return result;\n            }\n        }\n\n        \n        if (context == null) {\n            context = new ClassStack(rawType);\n        } else {\n            ClassStack prev = context.find(rawType);\n            if (prev != null) {\n                \n                ResolvedRecursiveType selfRef = new ResolvedRecursiveType(rawType, EMPTY_BINDINGS);\n                prev.addSelfReference(selfRef);\n                return selfRef;\n            }\n            \n            context = context.child(rawType);\n        }\n\n        \n        if (rawType.isArray()) {\n            result = ArrayType.construct(_fromAny(context, rawType.getComponentType(), bindings),\n                    bindings);\n        } else {\n            \n            \n            JavaType superClass;\n            JavaType[] superInterfaces;\n\n            if (rawType.isInterface()) {\n                superClass = null;\n                superInterfaces = _resolveSuperInterfaces(context, rawType, bindings);\n            } else {\n                \n                superClass = _resolveSuperClass(context, rawType, bindings);\n                superInterfaces = _resolveSuperInterfaces(context, rawType, bindings);\n            }\n\n            \n            if (rawType == Properties.class) {\n                result = MapType.construct(rawType, bindings, superClass, superInterfaces,\n                        CORE_TYPE_STRING, CORE_TYPE_STRING);\n            }\n            \n            \n            else if (superClass != null) {\n                result = superClass.refine(rawType, bindings, superClass, superInterfaces);\n            }\n            \n            if (result == null) {\n                result = _fromWellKnownClass(context, rawType, bindings, superClass, superInterfaces); \n                if (result == null) {\n                    result = _fromWellKnownInterface(context, rawType, bindings, superClass, superInterfaces);\n                    if (result == null) {\n                        \n                        result = _newSimpleType(rawType, bindings, superClass, superInterfaces);\n                    }\n                }\n            }\n        }\n        context.resolveSelfReferences(result);\n        if (cachable) {\n            _typeCache.putIfAbsent(rawType, result);\n        }\n        return result;\n    }\n\n    protected JavaType _resolveSuperClass(ClassStack context, Class<?> rawType, TypeBindings parentBindings) {\n        Type parent = ClassUtil.getGenericSuperclass(rawType);\n        if (parent == null) {\n            return null;\n        }\n        return _fromAny(context, parent, parentBindings);\n    }\n\n    protected JavaType[] _resolveSuperInterfaces(ClassStack context, Class<?> rawType, TypeBindings parentBindings) {\n        Type[] types = ClassUtil.getGenericInterfaces(rawType);\n        if (types == null || types.length == 0) {\n            return NO_TYPES;\n        }\n        int len = types.length;\n        JavaType[] resolved = new JavaType[len];\n        for (int i = 0; i < len; ++i) {\n            Type type = types[i];\n            resolved[i] = _fromAny(context, type, parentBindings);\n        }\n        return resolved;\n    }\n\n    \n    protected JavaType _fromWellKnownClass(ClassStack context, Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) {\n        \n        if (rawType == Map.class) {\n            return _mapType(rawType, bindings, superClass, superInterfaces);\n        }\n        if (rawType == Collection.class) {\n            return _collectionType(rawType, bindings, superClass, superInterfaces);\n        }\n        \n        if (rawType == AtomicReference.class) {\n            return _referenceType(rawType, bindings, superClass, superInterfaces);\n        }\n        \n        \n        \n        \n        return null;\n    }\n\n    protected JavaType _fromWellKnownInterface(ClassStack context, Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) {\n        \n        \n        final int intCount = superInterfaces.length;\n\n        for (int i = 0; i < intCount; ++i) {\n            JavaType result = superInterfaces[i].refine(rawType, bindings, superClass, superInterfaces);\n            if (result != null) {\n                return result;\n            }\n        }\n        return null;\n    }\n\n    \n    protected JavaType _fromParamType(ClassStack context, ParameterizedType ptype, TypeBindings parentBindings) {\n        \n        Class<?> rawType = (Class<?>) ptype.getRawType();\n\n        \n        \n        if (rawType == CLS_ENUM) {\n            return CORE_TYPE_ENUM;\n        }\n        if (rawType == CLS_COMPARABLE) {\n            return CORE_TYPE_COMPARABLE;\n        }\n        if (rawType == CLS_CLASS) {\n            return CORE_TYPE_CLASS;\n        }\n\n        \n        \n        \n        Type[] args = ptype.getActualTypeArguments();\n        int paramCount = (args == null) ? 0 : args.length;\n        JavaType[] pt;\n        TypeBindings newBindings;        \n\n        if (paramCount == 0) {\n            newBindings = EMPTY_BINDINGS;\n        } else {\n            pt = new JavaType[paramCount];\n            for (int i = 0; i < paramCount; ++i) {\n                pt[i] = _fromAny(context, args[i], parentBindings);\n            }\n            newBindings = TypeBindings.create(rawType, pt);\n        }\n        return _fromClass(context, rawType, newBindings);\n    }\n\n    protected JavaType _fromArrayType(ClassStack context, GenericArrayType type, TypeBindings bindings) {\n        JavaType elementType = _fromAny(context, type.getGenericComponentType(), bindings);\n        return ArrayType.construct(elementType, bindings);\n    }\n\n    protected JavaType _fromVariable(ClassStack context, TypeVariable<?> var, TypeBindings bindings) {\n        \n        final String name = var.getName();\n        JavaType type = bindings.findBoundType(name);\n        if (type != null) {\n            return type;\n        }\n        \n        \n        if (bindings.hasUnbound(name)) {\n            return CORE_TYPE_OBJECT;\n        }\n        bindings = bindings.withUnboundVariable(name);\n\n        Type[] bounds = var.getBounds();\n        return _fromAny(context, bounds[0], bindings);\n    }\n\n    protected JavaType _fromWildcard(ClassStack context, WildcardType type, TypeBindings bindings) {\n        \n        return _fromAny(context, type.getUpperBounds()[0], bindings);\n    }\n}\n",
      "fixed_full_code": "package com.fasterxml.jackson.databind.type;\n\nimport java.util.*;\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.lang.reflect.*;\n\nimport com.fasterxml.jackson.core.type.TypeReference;\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.util.ArrayBuilders;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\nimport com.fasterxml.jackson.databind.util.LRUMap;\n\n\n@SuppressWarnings({\"rawtypes\" })\npublic final class TypeFactory implements java.io.Serializable { private static final long serialVersionUID = 1L; private final static JavaType[] NO_TYPES = new JavaType[0]; protected final static TypeFactory instance = new TypeFactory(); protected final static TypeBindings EMPTY_BINDINGS = TypeBindings.emptyBindings(); private final static Class<?> CLS_STRING = String.class; private final static Class<?> CLS_OBJECT = Object.class; private final static Class<?> CLS_COMPARABLE = Comparable.class; private final static Class<?> CLS_CLASS = Class.class; private final static Class<?> CLS_ENUM = Enum.class; private final static Class<?> CLS_BOOL = Boolean.TYPE; private final static Class<?> CLS_INT = Integer.TYPE; private final static Class<?> CLS_LONG = Long.TYPE; protected final static SimpleType CORE_TYPE_BOOL = new SimpleType(CLS_BOOL); protected final static SimpleType CORE_TYPE_INT = new SimpleType(CLS_INT); protected final static SimpleType CORE_TYPE_LONG = new SimpleType(CLS_LONG); protected final static SimpleType CORE_TYPE_STRING = new SimpleType(CLS_STRING); protected final static SimpleType CORE_TYPE_OBJECT = new SimpleType(CLS_OBJECT); protected final static SimpleType CORE_TYPE_COMPARABLE = new SimpleType(CLS_COMPARABLE); protected final static SimpleType CORE_TYPE_ENUM = new SimpleType(CLS_ENUM); protected final static SimpleType CORE_TYPE_CLASS = new SimpleType(CLS_CLASS); protected final LRUMap<Object,JavaType> _typeCache = new LRUMap<Object,JavaType>(16, 100); protected final TypeModifier[] _modifiers; protected final TypeParser _parser; protected final ClassLoader _classLoader; private TypeFactory() {\n        _parser = new TypeParser(this);\n        _modifiers = null;\n        _classLoader = null;\n    }\n\n    protected TypeFactory(TypeParser p, TypeModifier[] mods) {\n        this(p, mods, null);\n    }\n    \n    protected TypeFactory(TypeParser p, TypeModifier[] mods, ClassLoader classLoader) {\n        \n        _parser = p.withFactory(this);\n        _modifiers = mods;\n        _classLoader = classLoader;\n    }\n\n    public TypeFactory withModifier(TypeModifier mod) {\n        if (mod == null) { \n            return new TypeFactory(_parser, _modifiers, _classLoader);\n        }\n        if (_modifiers == null) {\n            return new TypeFactory(_parser, new TypeModifier[] { mod }, _classLoader);\n        }\n        return new TypeFactory(_parser, ArrayBuilders.insertInListNoDup(_modifiers, mod), _classLoader);\n    }\n    \n    public TypeFactory withClassLoader(ClassLoader classLoader) {\n        return new TypeFactory(_parser, _modifiers, classLoader);\n    }\n\n    \n    public static TypeFactory defaultInstance() { return instance; }\n\n    \n    public void clearCache() {\n        _typeCache.clear();\n    }\n\n    public ClassLoader getClassLoader() {\n        return _classLoader;\n    }\n    \n    \n    \n    \n    public static JavaType unknownType() {\n        return defaultInstance()._unknownType();\n    }\n\n    \n    public static Class<?> rawClass(Type t) {\n        if (t instanceof Class<?>) {\n            return (Class<?>) t;\n        }\n        \n        return defaultInstance().constructType(t).getRawClass();\n    }\n\n    \n\n    \n    public Class<?> findClass(String className) throws ClassNotFoundException {\n        if (className.indexOf('.') < 0) {\n            Class<?> prim = _findPrimitive(className);\n            if (prim != null) {\n                return prim;\n            }\n        }\n        \n        Throwable prob = null;\n        ClassLoader loader = this.getClassLoader();\n        if (loader == null) {\n          loader = \tThread.currentThread().getContextClassLoader();\n        }\n        if (loader != null) {\n            try {\n                return classForName(className, true, loader);\n            } catch (Exception e) {\n                prob = ClassUtil.getRootCause(e);\n            }\n        }\n        try {\n            return classForName(className);\n        } catch (Exception e) {\n            if (prob == null) {\n                prob = ClassUtil.getRootCause(e);\n            }\n        }\n        if (prob instanceof RuntimeException) {\n            throw (RuntimeException) prob;\n        }\n        throw new ClassNotFoundException(prob.getMessage(), prob);\n    }\n    \n    protected Class<?> classForName(String name, boolean initialize, ClassLoader loader) throws ClassNotFoundException {\n    \treturn Class.forName(name, true, loader);\n    }\n    \n    protected Class<?> classForName(String name) throws ClassNotFoundException {\n        return Class.forName(name);\n    }\n\n    protected Class<?> _findPrimitive(String className) {\n        if (\"int\".equals(className)) return Integer.TYPE;\n        if (\"long\".equals(className)) return Long.TYPE;\n        if (\"float\".equals(className)) return Float.TYPE;\n        if (\"double\".equals(className)) return Double.TYPE;\n        if (\"boolean\".equals(className)) return Boolean.TYPE;\n        if (\"byte\".equals(className)) return Byte.TYPE;\n        if (\"char\".equals(className)) return Character.TYPE;\n        if (\"short\".equals(className)) return Short.TYPE;\n        if (\"void\".equals(className)) return Void.TYPE;\n        return null;\n    }\n    \n    \n\n    \n    public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass) {\n        \n        final Class<?> rawBase = baseType.getRawClass();\n        if (rawBase == subclass) {\n            return baseType;\n        }\n\n        JavaType newType;\n\n        \n        do { \n            if (rawBase == Object.class) {\n                newType = _fromClass(null, subclass, TypeBindings.emptyBindings());\n                break;\n            }\n            if (!rawBase.isAssignableFrom(subclass)) {\n                throw new IllegalArgumentException(String.format(\n                        \"Class %s not subtype of %s\", subclass.getName(), baseType));\n            }\n            \n\n            \n            if (baseType.getBindings().isEmpty()) {\n                newType = _fromClass(null, subclass, TypeBindings.emptyBindings());     \n                break;\n            }\n            \n            if (baseType.isContainerType()) {\n                if (baseType.isMapLikeType()) {\n                    if ((subclass == HashMap.class)\n                            || (subclass == LinkedHashMap.class)\n                            || (subclass == EnumMap.class)\n                            || (subclass == TreeMap.class)) {\n                        newType = _fromClass(null, subclass,\n                                TypeBindings.create(subclass, baseType.getKeyType(), baseType.getContentType()));\n                        break;\n                    }\n                } else if (baseType.isCollectionLikeType()) {\n                    if ((subclass == ArrayList.class)\n                            || (subclass == LinkedList.class)\n                            || (subclass == HashSet.class)\n                            || (subclass == TreeSet.class)) {\n                        newType = _fromClass(null, subclass,\n                                TypeBindings.create(subclass, baseType.getContentType()));\n                        break;\n                    }\n                    \n                    \n                    if (rawBase == EnumSet.class) {\n                        return baseType;\n                    }\n                }\n            }\n            \n            int typeParamCount = subclass.getTypeParameters().length;\n            if (typeParamCount == 0) {\n                newType = _fromClass(null, subclass, TypeBindings.emptyBindings());     \n                break;\n            }\n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            TypeBindings tb = _bindingsForSubtype(baseType, typeParamCount, subclass);\n            if (baseType.isInterface()) {\n                newType = baseType.refine(subclass, tb, null, new JavaType[] { baseType });\n            } else {\n                newType = baseType.refine(subclass, tb, baseType, NO_TYPES);\n            }\n            \n            if (newType == null) {\n                newType = _fromClass(null, subclass, tb);\n            }\n        } while (false);\n\n        \n\n        return newType;\n\n        \n        \n        \n    }\n\n    private TypeBindings _bindingsForSubtype(JavaType baseType, int typeParamCount, Class<?> subclass) {\n        \n        \n        int baseCount = baseType.containedTypeCount();\n        if (baseCount == typeParamCount) {\n            if (typeParamCount == 1) {\n                return TypeBindings.create(subclass, baseType.containedType(0));\n            }\n            if (typeParamCount == 2) {\n                return TypeBindings.create(subclass, baseType.containedType(0),\n                        baseType.containedType(1));\n            }\n            List<JavaType> types = new ArrayList<JavaType>(baseCount);\n            for (int i = 0; i < baseCount; ++i) {\n                types.add(baseType.containedType(i));\n            }\n            return TypeBindings.create(subclass, types);\n        }\n        \n        return TypeBindings.emptyBindings();\n    }\n\n    \n    public JavaType constructGeneralizedType(JavaType baseType, Class<?> superClass) {\n        \n        final Class<?> rawBase = baseType.getRawClass();\n        if (rawBase == superClass) {\n            return baseType;\n        }\n        JavaType superType = baseType.findSuperType(superClass);\n        if (superType == null) {\n            \n            if (!superClass.isAssignableFrom(rawBase)) {\n                throw new IllegalArgumentException(String.format(\n                        \"Class %s not a super-type of %s\", superClass.getName(), baseType));\n            }\n            \n            throw new IllegalArgumentException(String.format(\n                    \"Internal error: class %s not included as super-type for %s\",\n                    superClass.getName(), baseType));\n        }\n        return superType;\n    }\n\n    \n    public JavaType constructFromCanonical(String canonical) throws IllegalArgumentException {\n        return _parser.parse(canonical);\n    }\n\n    \n    public JavaType[] findTypeParameters(JavaType type, Class<?> expType) {\n        JavaType match = type.findSuperType(expType);\n        if (match == null) {\n            return NO_TYPES;\n        }\n        return match.getBindings().typeParameterArray();\n    }\n\n    \n    @Deprecated \n    public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType, TypeBindings bindings) {\n        return findTypeParameters(constructType(clz, bindings), expType);\n    }\n    \n    \n    @Deprecated \n    public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType) {\n        return findTypeParameters(constructType(clz), expType);\n    }\n\n    \n    public JavaType moreSpecificType(JavaType type1, JavaType type2) {\n        if (type1 == null) {\n            return type2;\n        }\n        if (type2 == null) {\n            return type1;\n        }\n        Class<?> raw1 = type1.getRawClass();\n        Class<?> raw2 = type2.getRawClass();\n        if (raw1 == raw2) {\n            return type1;\n        }\n        \n        if (raw1.isAssignableFrom(raw2)) {\n            return type2;\n        }\n        return type1;\n    }\n    \n    \n\n    public JavaType constructType(Type type) {\n        return _fromAny(null, type, EMPTY_BINDINGS);\n    }\n\n    public JavaType constructType(Type type, TypeBindings bindings) {\n        return _fromAny(null, type, bindings);\n    }\n    \n    public JavaType constructType(TypeReference<?> typeRef) {\n        \n        return _fromAny(null, typeRef.getType(), EMPTY_BINDINGS);\n\n        \n        \n\n        \n    }\n\n    \n    @Deprecated\n    public JavaType constructType(Type type, Class<?> contextClass) {\n        TypeBindings bindings = (contextClass == null)\n                ? TypeBindings.emptyBindings() : constructType(contextClass).getBindings();\n        return _fromAny(null, type, bindings);\n    }\n\n    \n    @Deprecated\n    public JavaType constructType(Type type, JavaType contextType) {\n        TypeBindings bindings = (contextType == null)\n                ? TypeBindings.emptyBindings() : contextType.getBindings();\n        return _fromAny(null, type, bindings);\n    }\n\n    \n\n    \n    public ArrayType constructArrayType(Class<?> elementType) {\n        return ArrayType.construct(_fromAny(null, elementType, null), null);\n    }\n    \n    \n    public ArrayType constructArrayType(JavaType elementType) {\n        return ArrayType.construct(elementType, null);\n    }\n\n    \n    public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, Class<?> elementClass) {\n        return constructCollectionType(collectionClass,\n                _fromClass(null, elementClass, EMPTY_BINDINGS));\n    }\n\n    \n    public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, JavaType elementType) {\n        \n        \n        return (CollectionType) _fromClass(null, collectionClass,\n                TypeBindings.create(collectionClass, elementType));\n    }\n\n    \n    public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, Class<?> elementClass) {\n        return constructCollectionLikeType(collectionClass,\n                _fromClass(null, elementClass, EMPTY_BINDINGS));\n    }\n    \n    \n    public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, JavaType elementType) {\n        JavaType type = _fromClass(null, collectionClass,\n                TypeBindings.createIfNeeded(collectionClass, elementType));\n        if (type instanceof CollectionLikeType) {\n            return (CollectionLikeType) type;\n        }\n        return CollectionLikeType.upgradeFrom(type, elementType);\n    }\n\n    \n    public MapType constructMapType(Class<? extends Map> mapClass, Class<?> keyClass, Class<?> valueClass) {\n        JavaType kt, vt;\n        if (mapClass == Properties.class) {\n            kt = vt = CORE_TYPE_STRING;\n        } else {\n            kt = _fromClass(null, keyClass, EMPTY_BINDINGS);\n            vt = _fromClass(null, valueClass, EMPTY_BINDINGS);\n        }\n        return constructMapType(mapClass, kt, vt);\n    }\n\n    \n    public MapType constructMapType(Class<? extends Map> mapClass, JavaType keyType, JavaType valueType) {\n        return (MapType) _fromClass(null, mapClass,\n                TypeBindings.create(mapClass, new JavaType[] {\n                        keyType, valueType\n                }));\n    }\n\n    \n    public MapLikeType constructMapLikeType(Class<?> mapClass, Class<?> keyClass, Class<?> valueClass) {\n        return constructMapLikeType(mapClass,\n                _fromClass(null, keyClass, EMPTY_BINDINGS),\n                _fromClass(null, valueClass, EMPTY_BINDINGS));\n    }\n\n    \n    public MapLikeType constructMapLikeType(Class<?> mapClass, JavaType keyType, JavaType valueType) {\n        \n        \n        JavaType type = _fromClass(null, mapClass,\n                TypeBindings.createIfNeeded(mapClass, new JavaType[] { keyType, valueType }));\n        if (type instanceof MapLikeType) {\n            return (MapLikeType) type;\n        }\n        return MapLikeType.upgradeFrom(type, keyType, valueType);\n    }\n\n    \n    public JavaType constructSimpleType(Class<?> rawType, JavaType[] parameterTypes) {\n        return _fromClass(null, rawType, TypeBindings.create(rawType, parameterTypes));\n    }\n\n    \n    @Deprecated\n    public JavaType constructSimpleType(Class<?> rawType, Class<?> parameterTarget, JavaType[] parameterTypes) {\n        return constructSimpleType(rawType, parameterTypes);\n    } \n\n    \n    public JavaType constructReferenceType(Class<?> rawType, JavaType referredType) {\n        return ReferenceType.construct(rawType, null, \n                null, null, \n                referredType);\n    }\n\n    \n    public JavaType uncheckedSimpleType(Class<?> cls) {\n        \n        return _constructSimple(cls, EMPTY_BINDINGS, null, null);\n    }\n\n    \n    public JavaType constructParametricType(Class<?> parametrized, Class<?>... parameterClasses) {\n        int len = parameterClasses.length;\n        JavaType[] pt = new JavaType[len];\n        for (int i = 0; i < len; ++i) {\n            pt[i] = _fromClass(null, parameterClasses[i], null);\n        }\n        return constructParametricType(parametrized, pt);\n    }\n\n    \n    public JavaType constructParametricType(Class<?> rawType, JavaType... parameterTypes) {\n        return _fromClass(null, rawType, TypeBindings.create(rawType, parameterTypes));\n    }\n\n    \n    public JavaType constructParametrizedType(Class<?> parametrized, Class<?> parametersFor, JavaType... parameterTypes) {\n        return constructParametricType(parametrized, parameterTypes);\n    }\n\n    \n    public JavaType constructParametrizedType(Class<?> parametrized, Class<?> parametersFor, Class<?>... parameterClasses) {\n        return constructParametricType(parametrized, parameterClasses);\n    }\n\n    \n\n    \n    public CollectionType constructRawCollectionType(Class<? extends Collection> collectionClass) {\n        return constructCollectionType(collectionClass, unknownType());\n    }\n\n    \n    public CollectionLikeType constructRawCollectionLikeType(Class<?> collectionClass) {\n        return constructCollectionLikeType(collectionClass, unknownType());\n    }\n\n    \n    public MapType constructRawMapType(Class<? extends Map> mapClass) {\n        return constructMapType(mapClass, unknownType(), unknownType());\n    }\n\n    \n    public MapLikeType constructRawMapLikeType(Class<?> mapClass) {\n        return constructMapLikeType(mapClass, unknownType(), unknownType());\n    }\n\n    \n\n    private JavaType _mapType(Class<?> rawClass, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) {\n        JavaType kt, vt;\n        \n        \n        if (rawClass == Properties.class) {\n            kt = vt = CORE_TYPE_STRING;\n        } else {\n            List<JavaType> typeParams = bindings.getTypeParameters();\n            \n            switch (typeParams.size()) {\n            case 0: \n                kt = vt = _unknownType();\n                break;\n            case 2:\n                kt = typeParams.get(0);\n                vt = typeParams.get(1);\n                break;\n            default:\n                throw new IllegalArgumentException(\"Strange Map type \"+rawClass.getName()+\": can not determine type parameters\");\n            }\n        }\n        return MapType.construct(rawClass, bindings, superClass, superInterfaces, kt, vt);\n    }\n\n    private JavaType _collectionType(Class<?> rawClass, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) {\n        List<JavaType> typeParams = bindings.getTypeParameters();\n        \n        JavaType ct;\n        if (typeParams.isEmpty()) {\n            ct = _unknownType();\n        } else if (typeParams.size() == 1) {\n            ct = typeParams.get(0);\n        } else {\n            throw new IllegalArgumentException(\"Strange Collection type \"+rawClass.getName()+\": can not determine type parameters\");\n        }\n        return CollectionType.construct(rawClass, bindings, superClass, superInterfaces, ct);\n    }\n\n    private JavaType _referenceType(Class<?> rawClass, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) {\n        List<JavaType> typeParams = bindings.getTypeParameters();\n        \n        JavaType ct;\n        if (typeParams.isEmpty()) {\n            ct = _unknownType();\n        } else if (typeParams.size() == 1) {\n            ct = typeParams.get(0);\n        } else {\n            throw new IllegalArgumentException(\"Strange Reference type \"+rawClass.getName()+\": can not determine type parameters\");\n        }\n        return ReferenceType.construct(rawClass, bindings, superClass, superInterfaces, ct);\n    }\n\n    \n    protected JavaType _constructSimple(Class<?> raw, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) {\n        if (bindings.isEmpty()) {\n            JavaType result = _findWellKnownSimple(raw);\n            if (result != null) {\n                return result;\n            }\n        }\n        return _newSimpleType(raw, bindings, superClass, superInterfaces);\n    }\n\n    \n    protected JavaType _newSimpleType(Class<?> raw, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) {\n        return new SimpleType(raw, bindings, superClass, superInterfaces);\n    }\n\n    protected JavaType _unknownType() {\n        \n        return CORE_TYPE_OBJECT;\n    }\n\n    \n    protected JavaType _findWellKnownSimple(Class<?> clz) {\n        if (clz.isPrimitive()) {\n            if (clz == CLS_BOOL) return CORE_TYPE_BOOL;\n            if (clz == CLS_INT) return CORE_TYPE_INT;\n            if (clz == CLS_LONG) return CORE_TYPE_LONG;\n        } else {\n            if (clz == CLS_STRING) return CORE_TYPE_STRING;\n            if (clz == CLS_OBJECT) return CORE_TYPE_OBJECT; \n        }\n        return null;\n    }\n\n    \n\n    \n    protected JavaType _fromAny(ClassStack context, Type type, TypeBindings bindings) {\n        JavaType resultType;\n\n        \n        if (type instanceof Class<?>) {\n            \n            resultType = _fromClass(context, (Class<?>) type, EMPTY_BINDINGS);\n        }\n        \n        else if (type instanceof ParameterizedType) {\n            resultType = _fromParamType(context, (ParameterizedType) type, bindings);\n        }\n        else if (type instanceof JavaType) { \n            \n            return (JavaType) type;\n        }\n        else if (type instanceof GenericArrayType) {\n            resultType = _fromArrayType(context, (GenericArrayType) type, bindings);\n        }\n        else if (type instanceof TypeVariable<?>) {\n            resultType = _fromVariable(context, (TypeVariable<?>) type, bindings);\n        }\n        else if (type instanceof WildcardType) {\n            resultType = _fromWildcard(context, (WildcardType) type, bindings);\n        } else {\n            \n            throw new IllegalArgumentException(\"Unrecognized Type: \"+((type == null) ? \"[null]\" : type.toString()));\n        }\n        \n        if (_modifiers != null) {\n            TypeBindings b = resultType.getBindings();\n            if (b == null) {\n                b = EMPTY_BINDINGS;\n            }\n            for (TypeModifier mod : _modifiers) {\n                JavaType t = mod.modifyType(resultType, type, b, this);\n                if (t == null) {\n                    throw new IllegalStateException(String.format(\n                            \"TypeModifier %s (of type %s) return null for type %s\",\n                            mod, mod.getClass().getName(), resultType));\n                }\n                resultType = t;\n            }\n        }\n        return resultType;\n    }\n\n    \n    protected JavaType _fromClass(ClassStack context, Class<?> rawType, TypeBindings bindings) {\n        \n        JavaType result = _findWellKnownSimple(rawType);\n        if (result != null) {\n            return result;\n        }\n        \n        final Object key;\n        if ((bindings == null) || bindings.isEmpty()) {\n            key = rawType;\n            result = _typeCache.get(key); \n        } else {\n            key = bindings.asKey(rawType);\n        }\n        result = _typeCache.get(key); \n        if (result != null) {\n            return result;\n        }\n\n        \n        if (context == null) {\n            context = new ClassStack(rawType);\n        } else {\n            ClassStack prev = context.find(rawType);\n            if (prev != null) {\n                \n                ResolvedRecursiveType selfRef = new ResolvedRecursiveType(rawType, EMPTY_BINDINGS);\n                prev.addSelfReference(selfRef);\n                return selfRef;\n            }\n            \n            context = context.child(rawType);\n        }\n\n        \n        if (rawType.isArray()) {\n            result = ArrayType.construct(_fromAny(context, rawType.getComponentType(), bindings),\n                    bindings);\n        } else {\n            \n            \n            JavaType superClass;\n            JavaType[] superInterfaces;\n\n            if (rawType.isInterface()) {\n                superClass = null;\n                superInterfaces = _resolveSuperInterfaces(context, rawType, bindings);\n            } else {\n                \n                superClass = _resolveSuperClass(context, rawType, bindings);\n                superInterfaces = _resolveSuperInterfaces(context, rawType, bindings);\n            }\n\n            \n            if (rawType == Properties.class) {\n                result = MapType.construct(rawType, bindings, superClass, superInterfaces,\n                        CORE_TYPE_STRING, CORE_TYPE_STRING);\n            }\n            \n            \n            else if (superClass != null) {\n                result = superClass.refine(rawType, bindings, superClass, superInterfaces);\n            }\n            \n            if (result == null) {\n                result = _fromWellKnownClass(context, rawType, bindings, superClass, superInterfaces); \n                if (result == null) {\n                    result = _fromWellKnownInterface(context, rawType, bindings, superClass, superInterfaces);\n                    if (result == null) {\n                        \n                        result = _newSimpleType(rawType, bindings, superClass, superInterfaces);\n                    }\n                }\n            }\n        }\n        context.resolveSelfReferences(result);\n        _typeCache.putIfAbsent(key, result); \n        return result;\n    }\n\n    protected JavaType _resolveSuperClass(ClassStack context, Class<?> rawType, TypeBindings parentBindings) {\n        Type parent = ClassUtil.getGenericSuperclass(rawType);\n        if (parent == null) {\n            return null;\n        }\n        return _fromAny(context, parent, parentBindings);\n    }\n\n    protected JavaType[] _resolveSuperInterfaces(ClassStack context, Class<?> rawType, TypeBindings parentBindings) {\n        Type[] types = ClassUtil.getGenericInterfaces(rawType);\n        if (types == null || types.length == 0) {\n            return NO_TYPES;\n        }\n        int len = types.length;\n        JavaType[] resolved = new JavaType[len];\n        for (int i = 0; i < len; ++i) {\n            Type type = types[i];\n            resolved[i] = _fromAny(context, type, parentBindings);\n        }\n        return resolved;\n    }\n\n    \n    protected JavaType _fromWellKnownClass(ClassStack context, Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) {\n        \n        if (rawType == Map.class) {\n            return _mapType(rawType, bindings, superClass, superInterfaces);\n        }\n        if (rawType == Collection.class) {\n            return _collectionType(rawType, bindings, superClass, superInterfaces);\n        }\n        \n        if (rawType == AtomicReference.class) {\n            return _referenceType(rawType, bindings, superClass, superInterfaces);\n        }\n        \n        \n        \n        \n        return null;\n    }\n\n    protected JavaType _fromWellKnownInterface(ClassStack context, Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) {\n        \n        \n        final int intCount = superInterfaces.length;\n\n        for (int i = 0; i < intCount; ++i) {\n            JavaType result = superInterfaces[i].refine(rawType, bindings, superClass, superInterfaces);\n            if (result != null) {\n                return result;\n            }\n        }\n        return null;\n    }\n\n    \n    protected JavaType _fromParamType(ClassStack context, ParameterizedType ptype, TypeBindings parentBindings) {\n        \n        Class<?> rawType = (Class<?>) ptype.getRawType();\n\n        \n        \n        if (rawType == CLS_ENUM) {\n            return CORE_TYPE_ENUM;\n        }\n        if (rawType == CLS_COMPARABLE) {\n            return CORE_TYPE_COMPARABLE;\n        }\n        if (rawType == CLS_CLASS) {\n            return CORE_TYPE_CLASS;\n        }\n\n        \n        \n        \n        Type[] args = ptype.getActualTypeArguments();\n        int paramCount = (args == null) ? 0 : args.length;\n        JavaType[] pt;\n        TypeBindings newBindings;        \n\n        if (paramCount == 0) {\n            newBindings = EMPTY_BINDINGS;\n        } else {\n            pt = new JavaType[paramCount];\n            for (int i = 0; i < paramCount; ++i) {\n                pt[i] = _fromAny(context, args[i], parentBindings);\n            }\n            newBindings = TypeBindings.create(rawType, pt);\n        }\n        return _fromClass(context, rawType, newBindings);\n    }\n\n    protected JavaType _fromArrayType(ClassStack context, GenericArrayType type, TypeBindings bindings) {\n        JavaType elementType = _fromAny(context, type.getGenericComponentType(), bindings);\n        return ArrayType.construct(elementType, bindings);\n    }\n\n    protected JavaType _fromVariable(ClassStack context, TypeVariable<?> var, TypeBindings bindings) {\n        \n        final String name = var.getName();\n        JavaType type = bindings.findBoundType(name);\n        if (type != null) {\n            return type;\n        }\n        \n        \n        if (bindings.hasUnbound(name)) {\n            return CORE_TYPE_OBJECT;\n        }\n        bindings = bindings.withUnboundVariable(name);\n\n        Type[] bounds = var.getBounds();\n        return _fromAny(context, bounds[0], bindings);\n    }\n\n    protected JavaType _fromWildcard(ClassStack context, WildcardType type, TypeBindings bindings) {\n        \n        return _fromAny(context, type.getUpperBounds()[0], bindings);\n    }\n}\n",
      "buggy_signatures": [
        "protected TypeFactory(TypeParser p, TypeModifier[] mods)",
        "protected TypeFactory(TypeParser p, TypeModifier[] mods, ClassLoader classLoader)",
        "public TypeFactory withModifier(TypeModifier mod)",
        "public TypeFactory withClassLoader(ClassLoader classLoader)",
        "public static TypeFactory defaultInstance()",
        "public void clearCache()",
        "public ClassLoader getClassLoader()",
        "public static JavaType unknownType()",
        "public static Class<?> rawClass(Type t)",
        "public Class<?> findClass(String className) throws ClassNotFoundException",
        "protected Class<?> classForName(String name, boolean initialize, ClassLoader loader) throws ClassNotFoundException",
        "protected Class<?> classForName(String name) throws ClassNotFoundException",
        "protected Class<?> _findPrimitive(String className)",
        "public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass)",
        "public JavaType constructGeneralizedType(JavaType baseType, Class<?> superClass)",
        "public JavaType constructFromCanonical(String canonical) throws IllegalArgumentException",
        "public JavaType[] findTypeParameters(JavaType type, Class<?> expType)",
        "public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType, TypeBindings bindings)",
        "public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType)",
        "public JavaType moreSpecificType(JavaType type1, JavaType type2)",
        "public JavaType constructType(Type type)",
        "public JavaType constructType(Type type, TypeBindings bindings)",
        "public JavaType constructType(TypeReference<?> typeRef)",
        "public JavaType constructType(Type type, Class<?> contextClass)",
        "public JavaType constructType(Type type, JavaType contextType)",
        "public ArrayType constructArrayType(Class<?> elementType)",
        "public ArrayType constructArrayType(JavaType elementType)",
        "public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, Class<?> elementClass)",
        "public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, JavaType elementType)",
        "public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, Class<?> elementClass)",
        "public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, JavaType elementType)",
        "public MapType constructMapType(Class<? extends Map> mapClass, Class<?> keyClass, Class<?> valueClass)",
        "public MapType constructMapType(Class<? extends Map> mapClass, JavaType keyType, JavaType valueType)",
        "public MapLikeType constructMapLikeType(Class<?> mapClass, Class<?> keyClass, Class<?> valueClass)",
        "public MapLikeType constructMapLikeType(Class<?> mapClass, JavaType keyType, JavaType valueType)",
        "public JavaType constructSimpleType(Class<?> rawType, JavaType[] parameterTypes)",
        "public JavaType constructSimpleType(Class<?> rawType, Class<?> parameterTarget, JavaType[] parameterTypes)",
        "public JavaType constructReferenceType(Class<?> rawType, JavaType referredType)",
        "public JavaType uncheckedSimpleType(Class<?> cls)",
        "public JavaType constructParametricType(Class<?> parametrized, Class<?>... parameterClasses)",
        "public JavaType constructParametricType(Class<?> rawType, JavaType... parameterTypes)",
        "public JavaType constructParametrizedType(Class<?> parametrized, Class<?> parametersFor, JavaType... parameterTypes)",
        "public JavaType constructParametrizedType(Class<?> parametrized, Class<?> parametersFor, Class<?>... parameterClasses)",
        "public CollectionType constructRawCollectionType(Class<? extends Collection> collectionClass)",
        "public CollectionLikeType constructRawCollectionLikeType(Class<?> collectionClass)",
        "public MapType constructRawMapType(Class<? extends Map> mapClass)",
        "public MapLikeType constructRawMapLikeType(Class<?> mapClass)",
        "private JavaType _mapType(Class<?> rawClass, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces)",
        "private JavaType _collectionType(Class<?> rawClass, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces)",
        "private JavaType _referenceType(Class<?> rawClass, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces)",
        "protected JavaType _constructSimple(Class<?> raw, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces)",
        "protected JavaType _newSimpleType(Class<?> raw, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces)",
        "protected JavaType _unknownType()",
        "protected JavaType _findWellKnownSimple(Class<?> clz)",
        "protected JavaType _fromAny(ClassStack context, Type type, TypeBindings bindings)",
        "protected JavaType _fromClass(ClassStack context, Class<?> rawType, TypeBindings bindings)",
        "protected JavaType _resolveSuperClass(ClassStack context, Class<?> rawType, TypeBindings parentBindings)",
        "protected JavaType[] _resolveSuperInterfaces(ClassStack context, Class<?> rawType, TypeBindings parentBindings)",
        "protected JavaType _fromWellKnownClass(ClassStack context, Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces)",
        "protected JavaType _fromWellKnownInterface(ClassStack context, Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces)",
        "protected JavaType _fromParamType(ClassStack context, ParameterizedType ptype, TypeBindings parentBindings)",
        "protected JavaType _fromArrayType(ClassStack context, GenericArrayType type, TypeBindings bindings)",
        "protected JavaType _fromVariable(ClassStack context, TypeVariable<?> var, TypeBindings bindings)",
        "protected JavaType _fromWildcard(ClassStack context, WildcardType type, TypeBindings bindings)"
      ],
      "fixed_signatures": [
        "protected TypeFactory(TypeParser p, TypeModifier[] mods)",
        "protected TypeFactory(TypeParser p, TypeModifier[] mods, ClassLoader classLoader)",
        "public TypeFactory withModifier(TypeModifier mod)",
        "public TypeFactory withClassLoader(ClassLoader classLoader)",
        "public static TypeFactory defaultInstance()",
        "public void clearCache()",
        "public ClassLoader getClassLoader()",
        "public static JavaType unknownType()",
        "public static Class<?> rawClass(Type t)",
        "public Class<?> findClass(String className) throws ClassNotFoundException",
        "protected Class<?> classForName(String name, boolean initialize, ClassLoader loader) throws ClassNotFoundException",
        "protected Class<?> classForName(String name) throws ClassNotFoundException",
        "protected Class<?> _findPrimitive(String className)",
        "public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass)",
        "private TypeBindings _bindingsForSubtype(JavaType baseType, int typeParamCount, Class<?> subclass)",
        "public JavaType constructGeneralizedType(JavaType baseType, Class<?> superClass)",
        "public JavaType constructFromCanonical(String canonical) throws IllegalArgumentException",
        "public JavaType[] findTypeParameters(JavaType type, Class<?> expType)",
        "public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType, TypeBindings bindings)",
        "public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType)",
        "public JavaType moreSpecificType(JavaType type1, JavaType type2)",
        "public JavaType constructType(Type type)",
        "public JavaType constructType(Type type, TypeBindings bindings)",
        "public JavaType constructType(TypeReference<?> typeRef)",
        "public JavaType constructType(Type type, Class<?> contextClass)",
        "public JavaType constructType(Type type, JavaType contextType)",
        "public ArrayType constructArrayType(Class<?> elementType)",
        "public ArrayType constructArrayType(JavaType elementType)",
        "public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, Class<?> elementClass)",
        "public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, JavaType elementType)",
        "public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, Class<?> elementClass)",
        "public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, JavaType elementType)",
        "public MapType constructMapType(Class<? extends Map> mapClass, Class<?> keyClass, Class<?> valueClass)",
        "public MapType constructMapType(Class<? extends Map> mapClass, JavaType keyType, JavaType valueType)",
        "public MapLikeType constructMapLikeType(Class<?> mapClass, Class<?> keyClass, Class<?> valueClass)",
        "public MapLikeType constructMapLikeType(Class<?> mapClass, JavaType keyType, JavaType valueType)",
        "public JavaType constructSimpleType(Class<?> rawType, JavaType[] parameterTypes)",
        "public JavaType constructSimpleType(Class<?> rawType, Class<?> parameterTarget, JavaType[] parameterTypes)",
        "public JavaType constructReferenceType(Class<?> rawType, JavaType referredType)",
        "public JavaType uncheckedSimpleType(Class<?> cls)",
        "public JavaType constructParametricType(Class<?> parametrized, Class<?>... parameterClasses)",
        "public JavaType constructParametricType(Class<?> rawType, JavaType... parameterTypes)",
        "public JavaType constructParametrizedType(Class<?> parametrized, Class<?> parametersFor, JavaType... parameterTypes)",
        "public JavaType constructParametrizedType(Class<?> parametrized, Class<?> parametersFor, Class<?>... parameterClasses)",
        "public CollectionType constructRawCollectionType(Class<? extends Collection> collectionClass)",
        "public CollectionLikeType constructRawCollectionLikeType(Class<?> collectionClass)",
        "public MapType constructRawMapType(Class<? extends Map> mapClass)",
        "public MapLikeType constructRawMapLikeType(Class<?> mapClass)",
        "private JavaType _mapType(Class<?> rawClass, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces)",
        "private JavaType _collectionType(Class<?> rawClass, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces)",
        "private JavaType _referenceType(Class<?> rawClass, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces)",
        "protected JavaType _constructSimple(Class<?> raw, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces)",
        "protected JavaType _newSimpleType(Class<?> raw, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces)",
        "protected JavaType _unknownType()",
        "protected JavaType _findWellKnownSimple(Class<?> clz)",
        "protected JavaType _fromAny(ClassStack context, Type type, TypeBindings bindings)",
        "protected JavaType _fromClass(ClassStack context, Class<?> rawType, TypeBindings bindings)",
        "protected JavaType _resolveSuperClass(ClassStack context, Class<?> rawType, TypeBindings parentBindings)",
        "protected JavaType[] _resolveSuperInterfaces(ClassStack context, Class<?> rawType, TypeBindings parentBindings)",
        "protected JavaType _fromWellKnownClass(ClassStack context, Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces)",
        "protected JavaType _fromWellKnownInterface(ClassStack context, Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces)",
        "protected JavaType _fromParamType(ClassStack context, ParameterizedType ptype, TypeBindings parentBindings)",
        "protected JavaType _fromArrayType(ClassStack context, GenericArrayType type, TypeBindings bindings)",
        "protected JavaType _fromVariable(ClassStack context, TypeVariable<?> var, TypeBindings bindings)",
        "protected JavaType _fromWildcard(ClassStack context, WildcardType type, TypeBindings bindings)"
      ],
      "methods": [
        {
          "buggy_method": "  protected final LRUMap<Class<?>, JavaType> _typeCache = new LRUMap<Class<?>, JavaType>(16, 100); /** * Registered {@link TypeModifier}s: objects that can change details",
          "fixed_method": "  protected final LRUMap<Object,JavaType> _typeCache = new LRUMap<Object,JavaType>(16, 100); /** * Registered {@link TypeModifier}s: objects that can change details",
          "diff": [
            "@@ -114,7 +114,7 @@",
            "      * actual generic types), we will use small cache to avoid repetitive\n",
            "      * resolution of core types\n",
            "      */\n",
            "-    protected final LRUMap<Class<?>, JavaType> _typeCache = new LRUMap<Class<?>, JavaType>(16, 100);\n",
            "+    protected final LRUMap<Object,JavaType> _typeCache = new LRUMap<Object,JavaType>(16, 100);\n",
            " \n",
            "     /*\n",
            "     /**********************************************************\n"
          ],
          "changed_lines": 2
        },
        {
          "buggy_method": "  public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass) {\n  \n  final Class<?> rawBase = baseType.getRawClass();\n  if (rawBase == subclass) {\n  return baseType;\n  }\n\n  JavaType newType;\n\n  \n  do { \n  if (rawBase == Object.class) {\n  newType = _fromClass(null, subclass, TypeBindings.emptyBindings());\n  break;\n  }\n  if (!rawBase.isAssignableFrom(subclass)) {\n  throw new IllegalArgumentException(String.format(\n  \"Class %s not subtype of %s\", subclass.getName(), baseType));\n  }\n  \n\n  \n  if (baseType.getBindings().isEmpty()) {\n  newType = _fromClass(null, subclass, TypeBindings.emptyBindings());  \n  break;\n  }\n  \n  if (baseType.isContainerType()) {\n  if (baseType.isMapLikeType()) {\n  if ((subclass == HashMap.class)\n  || (subclass == LinkedHashMap.class)\n  || (subclass == EnumMap.class)\n  || (subclass == TreeMap.class)) {\n  newType = _fromClass(null, subclass,\n  TypeBindings.create(subclass, baseType.getKeyType(), baseType.getContentType()));\n  break;\n  }\n  } else if (baseType.isCollectionLikeType()) {\n  if ((subclass == ArrayList.class)\n  || (subclass == LinkedList.class)\n  || (subclass == HashSet.class)\n  || (subclass == TreeSet.class)) {\n  newType = _fromClass(null, subclass,\n  TypeBindings.create(subclass, baseType.getContentType()));\n  break;\n  }\n  \n  \n  if (rawBase == EnumSet.class) {\n  return baseType;\n  }\n  }\n  }\n  \n  int typeParamCount = subclass.getTypeParameters().length;\n  if (typeParamCount == 0) {\n  newType = _fromClass(null, subclass, TypeBindings.emptyBindings());  \n  break;\n  }\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if (baseType.isInterface()) {\n  newType = baseType.refine(subclass, TypeBindings.emptyBindings(), null, new JavaType[] { baseType });\n  } else {\n  newType = baseType.refine(subclass, TypeBindings.emptyBindings(), baseType, NO_TYPES);\n  }\n  \n  if (newType == null) {\n  TypeBindings tb = null;\n  if (baseType.containedTypeCount() == typeParamCount) {\n  if (typeParamCount == 1) {\n  tb = TypeBindings.create(subclass, baseType.containedType(0));\n  } else if (typeParamCount == 2) {\n  tb = TypeBindings.create(subclass, baseType.containedType(0),\n  baseType.containedType(1));\n  }\n  }\n  newType = _fromClass(null, subclass,\n  (tb == null) ? TypeBindings.emptyBindings() : tb);\n  }\n  } while (false);\n\n  \n\n  return newType;\n\n  \n  \n  \n  }",
          "fixed_method": "  public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass) {\n  \n  final Class<?> rawBase = baseType.getRawClass();\n  if (rawBase == subclass) {\n  return baseType;\n  }\n\n  JavaType newType;\n\n  \n  do { \n  if (rawBase == Object.class) {\n  newType = _fromClass(null, subclass, TypeBindings.emptyBindings());\n  break;\n  }\n  if (!rawBase.isAssignableFrom(subclass)) {\n  throw new IllegalArgumentException(String.format(\n  \"Class %s not subtype of %s\", subclass.getName(), baseType));\n  }\n  \n\n  \n  if (baseType.getBindings().isEmpty()) {\n  newType = _fromClass(null, subclass, TypeBindings.emptyBindings());  \n  break;\n  }\n  \n  if (baseType.isContainerType()) {\n  if (baseType.isMapLikeType()) {\n  if ((subclass == HashMap.class)\n  || (subclass == LinkedHashMap.class)\n  || (subclass == EnumMap.class)\n  || (subclass == TreeMap.class)) {\n  newType = _fromClass(null, subclass,\n  TypeBindings.create(subclass, baseType.getKeyType(), baseType.getContentType()));\n  break;\n  }\n  } else if (baseType.isCollectionLikeType()) {\n  if ((subclass == ArrayList.class)\n  || (subclass == LinkedList.class)\n  || (subclass == HashSet.class)\n  || (subclass == TreeSet.class)) {\n  newType = _fromClass(null, subclass,\n  TypeBindings.create(subclass, baseType.getContentType()));\n  break;\n  }\n  \n  \n  if (rawBase == EnumSet.class) {\n  return baseType;\n  }\n  }\n  }\n  \n  int typeParamCount = subclass.getTypeParameters().length;\n  if (typeParamCount == 0) {\n  newType = _fromClass(null, subclass, TypeBindings.emptyBindings());  \n  break;\n  }\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  TypeBindings tb = _bindingsForSubtype(baseType, typeParamCount, subclass);\n  if (baseType.isInterface()) {\n  newType = baseType.refine(subclass, tb, null, new JavaType[] { baseType });\n  } else {\n  newType = baseType.refine(subclass, tb, baseType, NO_TYPES);\n  }\n  \n  if (newType == null) {\n  newType = _fromClass(null, subclass, tb);\n  }\n  } while (false);\n\n  \n\n  return newType;\n\n  \n  \n  \n  }",
          "diff": [
            "@@ -382,24 +382,15 @@",
            "             //  for a case where this code does get invoked: not ideal\n",
            "             // 29-Jun-2016, tatu: As to bindings, this works for [databind#1215], but\n",
            "             //  not certain it would reliably work... but let's hope for best for now\n",
            "+            TypeBindings tb = _bindingsForSubtype(baseType, typeParamCount, subclass);\n",
            "             if (baseType.isInterface()) {\n",
            "-                newType = baseType.refine(subclass, TypeBindings.emptyBindings(), null, new JavaType[] { baseType });\n",
            "+                newType = baseType.refine(subclass, tb, null, new JavaType[] { baseType });\n",
            "             } else {\n",
            "-                newType = baseType.refine(subclass, TypeBindings.emptyBindings(), baseType, NO_TYPES);\n",
            "+                newType = baseType.refine(subclass, tb, baseType, NO_TYPES);\n",
            "             }\n",
            "             // Only SimpleType returns null, but if so just resolve regularly\n",
            "             if (newType == null) {\n",
            "-                TypeBindings tb = null;\n",
            "-                if (baseType.containedTypeCount() == typeParamCount) {\n",
            "-                    if (typeParamCount == 1) {\n",
            "-                        tb = TypeBindings.create(subclass, baseType.containedType(0));\n",
            "-                    } else if (typeParamCount == 2) {\n",
            "-                        tb = TypeBindings.create(subclass, baseType.containedType(0),\n",
            "-                                baseType.containedType(1));\n",
            "-                    }\n",
            "-                }\n",
            "-                newType = _fromClass(null, subclass,\n",
            "-                        (tb == null) ? TypeBindings.emptyBindings() : tb);\n",
            "+                newType = _fromClass(null, subclass, tb);\n",
            "             }\n",
            "         } while (false);\n",
            " \n",
            "@@ -453,9 +444,28 @@",
            "         */\n",
            "     }\n",
            " \n",
            "+    private TypeBindings _bindingsForSubtype(JavaType baseType, int typeParamCount, Class<?> subclass)\n",
            "+    {\n",
            "         // But otherwise gets bit tricky, as we need to partially resolve the type hierarchy\n",
            "         // (hopefully passing null Class for root is ok)\n",
            "+        int baseCount = baseType.containedTypeCount();\n",
            "+        if (baseCount == typeParamCount) {\n",
            "+            if (typeParamCount == 1) {\n",
            "+                return TypeBindings.create(subclass, baseType.containedType(0));\n",
            "+            }\n",
            "+            if (typeParamCount == 2) {\n",
            "+                return TypeBindings.create(subclass, baseType.containedType(0),\n",
            "+                        baseType.containedType(1));\n",
            "+            }\n",
            "+            List<JavaType> types = new ArrayList<JavaType>(baseCount);\n",
            "+            for (int i = 0; i < baseCount; ++i) {\n",
            "+                types.add(baseType.containedType(i));\n",
            "+            }\n",
            "+            return TypeBindings.create(subclass, types);\n",
            "+        }\n",
            "         // Otherwise, two choices: match N first, or empty. Do latter, for now\n",
            "+        return TypeBindings.emptyBindings();\n",
            "+    }\n",
            " \n",
            "     /**\n",
            "      * Method similar to {@link #constructSpecializedType}, but that creates a\n"
          ],
          "changed_lines": 36
        },
        {
          "buggy_method": "  protected JavaType _fromClass(ClassStack context, Class<?> rawType, TypeBindings bindings) {\n  \n  JavaType result = _findWellKnownSimple(rawType);\n  if (result != null) {\n  return result;\n  }\n  \n  boolean cachable = (bindings == null) || bindings.isEmpty();\n  if (cachable) {\n  result = _typeCache.get(rawType);\n  if (result != null) {\n  return result;\n  }\n  }\n\n  \n  if (context == null) {\n  context = new ClassStack(rawType);\n  } else {\n  ClassStack prev = context.find(rawType);\n  if (prev != null) {\n  \n  ResolvedRecursiveType selfRef = new ResolvedRecursiveType(rawType, EMPTY_BINDINGS);\n  prev.addSelfReference(selfRef);\n  return selfRef;\n  }\n  \n  context = context.child(rawType);\n  }\n\n  \n  if (rawType.isArray()) {\n  result = ArrayType.construct(_fromAny(context, rawType.getComponentType(), bindings),\n  bindings);\n  } else {\n  \n  \n  JavaType superClass;\n  JavaType[] superInterfaces;\n\n  if (rawType.isInterface()) {\n  superClass = null;\n  superInterfaces = _resolveSuperInterfaces(context, rawType, bindings);\n  } else {\n  \n  superClass = _resolveSuperClass(context, rawType, bindings);\n  superInterfaces = _resolveSuperInterfaces(context, rawType, bindings);\n  }\n\n  \n  if (rawType == Properties.class) {\n  result = MapType.construct(rawType, bindings, superClass, superInterfaces,\n  CORE_TYPE_STRING, CORE_TYPE_STRING);\n  }\n  \n  \n  else if (superClass != null) {\n  result = superClass.refine(rawType, bindings, superClass, superInterfaces);\n  }\n  \n  if (result == null) {\n  result = _fromWellKnownClass(context, rawType, bindings, superClass, superInterfaces); \n  if (result == null) {\n  result = _fromWellKnownInterface(context, rawType, bindings, superClass, superInterfaces);\n  if (result == null) {\n  \n  result = _newSimpleType(rawType, bindings, superClass, superInterfaces);\n  }\n  }\n  }\n  }\n  context.resolveSelfReferences(result);\n  if (cachable) {\n  _typeCache.putIfAbsent(rawType, result);\n  }\n  return result;\n  }",
          "fixed_method": "  protected JavaType _fromClass(ClassStack context, Class<?> rawType, TypeBindings bindings) {\n  \n  JavaType result = _findWellKnownSimple(rawType);\n  if (result != null) {\n  return result;\n  }\n  \n  final Object key;\n  if ((bindings == null) || bindings.isEmpty()) {\n  key = rawType;\n  result = _typeCache.get(key); \n  } else {\n  key = bindings.asKey(rawType);\n  }\n  result = _typeCache.get(key); \n  if (result != null) {\n  return result;\n  }\n\n  \n  if (context == null) {\n  context = new ClassStack(rawType);\n  } else {\n  ClassStack prev = context.find(rawType);\n  if (prev != null) {\n  \n  ResolvedRecursiveType selfRef = new ResolvedRecursiveType(rawType, EMPTY_BINDINGS);\n  prev.addSelfReference(selfRef);\n  return selfRef;\n  }\n  \n  context = context.child(rawType);\n  }\n\n  \n  if (rawType.isArray()) {\n  result = ArrayType.construct(_fromAny(context, rawType.getComponentType(), bindings),\n  bindings);\n  } else {\n  \n  \n  JavaType superClass;\n  JavaType[] superInterfaces;\n\n  if (rawType.isInterface()) {\n  superClass = null;\n  superInterfaces = _resolveSuperInterfaces(context, rawType, bindings);\n  } else {\n  \n  superClass = _resolveSuperClass(context, rawType, bindings);\n  superInterfaces = _resolveSuperInterfaces(context, rawType, bindings);\n  }\n\n  \n  if (rawType == Properties.class) {\n  result = MapType.construct(rawType, bindings, superClass, superInterfaces,\n  CORE_TYPE_STRING, CORE_TYPE_STRING);\n  }\n  \n  \n  else if (superClass != null) {\n  result = superClass.refine(rawType, bindings, superClass, superInterfaces);\n  }\n  \n  if (result == null) {\n  result = _fromWellKnownClass(context, rawType, bindings, superClass, superInterfaces); \n  if (result == null) {\n  result = _fromWellKnownInterface(context, rawType, bindings, superClass, superInterfaces);\n  if (result == null) {\n  \n  result = _newSimpleType(rawType, bindings, superClass, superInterfaces);\n  }\n  }\n  }\n  }\n  context.resolveSelfReferences(result);\n  _typeCache.putIfAbsent(key, result); \n  return result;\n  }",
          "diff": [
            "@@ -1157,12 +1167,16 @@",
            "             return result;\n",
            "         }\n",
            "         // Barring that, we may have recently constructed an instance\n",
            "-        boolean cachable = (bindings == null) || bindings.isEmpty();\n",
            "-        if (cachable) {\n",
            "-            result = _typeCache.get(rawType);\n",
            "+        final Object key;\n",
            "+        if ((bindings == null) || bindings.isEmpty()) {\n",
            "+            key = rawType;\n",
            "+            result = _typeCache.get(key); // ok, cache object is synced\n",
            "+        } else {\n",
            "+            key = bindings.asKey(rawType);\n",
            "+        }\n",
            "+        result = _typeCache.get(key); // ok, cache object is synced\n",
            "         if (result != null) {\n",
            "             return result;\n",
            "-            }\n",
            "         }\n",
            " \n",
            "         // 15-Oct-2015, tatu: recursive reference?\n",
            "@@ -1222,9 +1236,7 @@",
            "             }\n",
            "         }\n",
            "         context.resolveSelfReferences(result);\n",
            "-        if (cachable) {\n",
            "-            _typeCache.putIfAbsent(rawType, result);\n",
            "-        }\n",
            "+        _typeCache.putIfAbsent(key, result); // cache object syncs\n",
            "         return result;\n",
            "     }\n",
            " \n"
          ],
          "changed_lines": 16
        }
      ]
    }
  ]
}
