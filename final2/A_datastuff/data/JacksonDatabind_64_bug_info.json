{
  "bug_id": "64",
  "failed_tests": {
    "com.fasterxml.jackson.databind.filter.JsonIncludeTest": [
      {
        "methodName": "testIssue1351",
        "error": "junit.framework.ComparisonFailure",
        "message": "expected:<{[]}> but was:<{[\"str\":null]}>",
        "fail_line": "        assertEquals(aposToQuotes(\"{}\"),",
        "test_source": "  public void testIssue1351() throws Exception {\n  ObjectMapper mapper = new ObjectMapper();\n  mapper.setSerializationInclusion(JsonInclude.Include.NON_DEFAULT);\n  assertEquals(aposToQuotes(\"{}\"),\n  mapper.writeValueAsString(new Issue1351Bean(null, (double) 0)));\n  // [databind#1417]\n  assertEquals(aposToQuotes(\"{}\"),\n  mapper.writeValueAsString(new Issue1351NonBean(0)));\n  }",
        "stack": [
          "JsonIncludeTest.testIssue1351 line 320"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "com/fasterxml/jackson/databind/ser/PropertyBuilder.java",
      "buggy_full_code": "package com.fasterxml.jackson.databind.ser;\n\nimport com.fasterxml.jackson.annotation.JsonInclude;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.annotation.JsonSerialize;\nimport com.fasterxml.jackson.databind.introspect.*;\nimport com.fasterxml.jackson.databind.jsontype.TypeSerializer;\nimport com.fasterxml.jackson.databind.util.*;\n\n\npublic class PropertyBuilder { private final static Object NO_DEFAULT_MARKER = Boolean.FALSE; final protected SerializationConfig _config; final protected BeanDescription _beanDesc; final protected AnnotationIntrospector _annotationIntrospector; protected Object _defaultBean; final protected JsonInclude.Value _defaultInclusion; final protected boolean _useRealPropertyDefaults; public PropertyBuilder(SerializationConfig config, BeanDescription beanDesc) {\n        _config = config;\n        _beanDesc = beanDesc;\n        \n        \n        \n        \n        \n        \n        \n        \n        JsonInclude.Value inclPerType = JsonInclude.Value.merge(\n                beanDesc.findPropertyInclusion(JsonInclude.Value.empty()),\n                config.getDefaultPropertyInclusion(beanDesc.getBeanClass(),\n                        JsonInclude.Value.empty()));\n        _defaultInclusion = JsonInclude.Value.merge(config.getDefaultPropertyInclusion(),\n                inclPerType);\n        _useRealPropertyDefaults = inclPerType.getValueInclusion() == JsonInclude.Include.NON_DEFAULT;\n        _annotationIntrospector = _config.getAnnotationIntrospector();\n    }\n\n    \n\n    public Annotations getClassAnnotations() {\n        return _beanDesc.getClassAnnotations();\n    }\n\n    \n    @SuppressWarnings(\"deprecation\")\n    protected BeanPropertyWriter buildWriter(SerializerProvider prov, BeanPropertyDefinition propDef, JavaType declaredType, JsonSerializer<?> ser, TypeSerializer typeSer, TypeSerializer contentTypeSer, AnnotatedMember am, boolean defaultUseStaticTyping) throws JsonMappingException {\n        \n        JavaType serializationType;\n        try {\n            serializationType = findSerializationType(am, defaultUseStaticTyping, declaredType);\n        } catch (JsonMappingException e) {\n            return prov.reportBadPropertyDefinition(_beanDesc, propDef, e.getMessage());\n        }\n\n        \n        if (contentTypeSer != null) {\n            \n            if (serializationType == null) {\n\n                serializationType = declaredType;\n            }\n            JavaType ct = serializationType.getContentType();\n            \n            if (ct == null) {\n                prov.reportBadPropertyDefinition(_beanDesc, propDef,\n                        \"serialization type \"+serializationType+\" has no content\");\n            }\n            serializationType = serializationType.withContentTypeHandler(contentTypeSer);\n            ct = serializationType.getContentType();\n        }\n\n        Object valueToSuppress = null;\n        boolean suppressNulls = false;\n\n        \n        JavaType actualType = (serializationType == null) ? declaredType : serializationType;\n        \n        \n        \n        \n        JsonInclude.Value inclV = _config.getDefaultPropertyInclusion(actualType.getRawClass(),\n                _defaultInclusion);\n\n        \n        \n        inclV = inclV.withOverrides(propDef.findInclusion());\n        JsonInclude.Include inclusion = inclV.getValueInclusion();\n\n        if (inclusion == JsonInclude.Include.USE_DEFAULTS) { \n            inclusion = JsonInclude.Include.ALWAYS;\n        }\n        \n        switch (inclusion) {\n        case NON_DEFAULT:\n            \n            \n            \n            \n            \n\n            \n            \n            \n            \n            if (_useRealPropertyDefaults) {\n                \n                if (prov.isEnabled(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS)) {\n                    am.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n                }\n                valueToSuppress = getPropertyDefaultValue(propDef.getName(), am, actualType);\n            } else {\n                valueToSuppress = getDefaultValue(actualType);\n                suppressNulls = true;\n            }\n            if (valueToSuppress == null) {\n                suppressNulls = true;\n            } else {\n                if (valueToSuppress.getClass().isArray()) {\n                    valueToSuppress = ArrayBuilders.getArrayComparator(valueToSuppress);\n                }\n            }\n            break;\n        case NON_ABSENT: \n            \n            suppressNulls = true;\n            \n            if (actualType.isReferenceType()) {\n                valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n            }\n            break;\n        case NON_EMPTY:\n            \n            suppressNulls = true;\n            \n            valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n            break;\n        case NON_NULL:\n            suppressNulls = true;\n            \n        case ALWAYS: \n        default:\n            \n            if (actualType.isContainerType()\n                    && !_config.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)) {\n                valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n            }\n            break;\n        }\n        BeanPropertyWriter bpw = new BeanPropertyWriter(propDef,\n                am, _beanDesc.getClassAnnotations(), declaredType,\n                ser, typeSer, serializationType, suppressNulls, valueToSuppress);\n\n        \n        Object serDef = _annotationIntrospector.findNullSerializer(am);\n        if (serDef != null) {\n            bpw.assignNullSerializer(prov.serializerInstance(am, serDef));\n        }\n        \n        NameTransformer unwrapper = _annotationIntrospector.findUnwrappingNameTransformer(am);\n        if (unwrapper != null) {\n            bpw = bpw.unwrappingWriter(unwrapper);\n        }\n        return bpw;\n    }\n\n    \n\n    \n    protected JavaType findSerializationType(Annotated a, boolean useStaticTyping, JavaType declaredType) throws JsonMappingException {\n        JavaType secondary = _annotationIntrospector.refineSerializationType(_config, a, declaredType);\n\n        \n        \n        if (secondary != declaredType) {\n            Class<?> serClass = secondary.getRawClass();\n            \n            Class<?> rawDeclared = declaredType.getRawClass();\n            if (serClass.isAssignableFrom(rawDeclared)) {\n                ; \n            } else {\n                \n                if (!rawDeclared.isAssignableFrom(serClass)) {\n                    throw new IllegalArgumentException(\"Illegal concrete-type annotation for method '\"+a.getName()+\"': class \"+serClass.getName()+\" not a super-type of (declared) class \"+rawDeclared.getName());\n                }\n                \n            }\n            useStaticTyping = true;\n            declaredType = secondary;\n        }\n        \n        JsonSerialize.Typing typing = _annotationIntrospector.findSerializationTyping(a);\n        if ((typing != null) && (typing != JsonSerialize.Typing.DEFAULT_TYPING)) {\n            useStaticTyping = (typing == JsonSerialize.Typing.STATIC);\n        }\n        if (useStaticTyping) {\n            \n            return declaredType.withStaticTyping();\n            \n        }\n        return null;\n    }\n\n    \n\n    protected Object getDefaultBean() {\n        Object def = _defaultBean;\n        if (def == null) {\n            \n            def = _beanDesc.instantiateBean(_config.canOverrideAccessModifiers());\n            if (def == null) {\n                \n                \n\n                \n                def = NO_DEFAULT_MARKER;\n            }\n            _defaultBean = def;\n        }\n        return (def == NO_DEFAULT_MARKER) ? null : _defaultBean;\n    }\n\n    \n    @Deprecated \n    protected Object getPropertyDefaultValue(String name, AnnotatedMember member, JavaType type) {\n        Object defaultBean = getDefaultBean();\n        if (defaultBean == null) {\n            return getDefaultValue(type);\n        }\n        try {\n            return member.getValue(defaultBean);\n        } catch (Exception e) {\n            return _throwWrapped(e, name, defaultBean);\n        }\n    }\n\n    \n    protected Object getDefaultValue(JavaType type) {\n        \n        \n        Class<?> cls = type.getRawClass();\n\n        Class<?> prim = ClassUtil.primitiveType(cls);\n        if (prim != null) {\n            return ClassUtil.defaultValue(prim);\n        }\n        if (type.isContainerType() || type.isReferenceType()) {\n            return JsonInclude.Include.NON_EMPTY;\n        }\n        if (cls == String.class) {\n            return \"\";\n        }\n        return null;\n    }\n    \n    \n    \n    protected Object _throwWrapped(Exception e, String propName, Object defaultBean) {\n        Throwable t = e;\n        while (t.getCause() != null) {\n            t = t.getCause();\n        }\n        if (t instanceof Error) throw (Error) t;\n        if (t instanceof RuntimeException) throw (RuntimeException) t;\n        throw new IllegalArgumentException(\"Failed to get property '\"+propName+\"' of default \"+defaultBean.getClass().getName()+\" instance\");\n    }\n}\n",
      "fixed_full_code": "package com.fasterxml.jackson.databind.ser;\n\nimport com.fasterxml.jackson.annotation.JsonInclude;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.annotation.JsonSerialize;\nimport com.fasterxml.jackson.databind.introspect.*;\nimport com.fasterxml.jackson.databind.jsontype.TypeSerializer;\nimport com.fasterxml.jackson.databind.util.*;\n\n\npublic class PropertyBuilder { private final static Object NO_DEFAULT_MARKER = Boolean.FALSE; final protected SerializationConfig _config; final protected BeanDescription _beanDesc; final protected AnnotationIntrospector _annotationIntrospector; protected Object _defaultBean; final protected JsonInclude.Value _defaultInclusion; final protected boolean _useRealPropertyDefaults; public PropertyBuilder(SerializationConfig config, BeanDescription beanDesc) {\n        _config = config;\n        _beanDesc = beanDesc;\n        \n        \n        \n        \n        \n        \n        \n        \n        JsonInclude.Value inclPerType = JsonInclude.Value.merge(\n                beanDesc.findPropertyInclusion(JsonInclude.Value.empty()),\n                config.getDefaultPropertyInclusion(beanDesc.getBeanClass(),\n                        JsonInclude.Value.empty()));\n        _defaultInclusion = JsonInclude.Value.merge(config.getDefaultPropertyInclusion(),\n                inclPerType);\n        _useRealPropertyDefaults = inclPerType.getValueInclusion() == JsonInclude.Include.NON_DEFAULT;\n        _annotationIntrospector = _config.getAnnotationIntrospector();\n    }\n\n    \n\n    public Annotations getClassAnnotations() {\n        return _beanDesc.getClassAnnotations();\n    }\n\n    \n    @SuppressWarnings(\"deprecation\")\n    protected BeanPropertyWriter buildWriter(SerializerProvider prov, BeanPropertyDefinition propDef, JavaType declaredType, JsonSerializer<?> ser, TypeSerializer typeSer, TypeSerializer contentTypeSer, AnnotatedMember am, boolean defaultUseStaticTyping) throws JsonMappingException {\n        \n        JavaType serializationType;\n        try {\n            serializationType = findSerializationType(am, defaultUseStaticTyping, declaredType);\n        } catch (JsonMappingException e) {\n            return prov.reportBadPropertyDefinition(_beanDesc, propDef, e.getMessage());\n        }\n\n        \n        if (contentTypeSer != null) {\n            \n            if (serializationType == null) {\n\n                serializationType = declaredType;\n            }\n            JavaType ct = serializationType.getContentType();\n            \n            if (ct == null) {\n                prov.reportBadPropertyDefinition(_beanDesc, propDef,\n                        \"serialization type \"+serializationType+\" has no content\");\n            }\n            serializationType = serializationType.withContentTypeHandler(contentTypeSer);\n            ct = serializationType.getContentType();\n        }\n\n        Object valueToSuppress = null;\n        boolean suppressNulls = false;\n\n        \n        JavaType actualType = (serializationType == null) ? declaredType : serializationType;\n        \n        \n        \n        \n        JsonInclude.Value inclV = _config.getDefaultPropertyInclusion(actualType.getRawClass(),\n                _defaultInclusion);\n\n        \n        \n        inclV = inclV.withOverrides(propDef.findInclusion());\n        JsonInclude.Include inclusion = inclV.getValueInclusion();\n\n        if (inclusion == JsonInclude.Include.USE_DEFAULTS) { \n            inclusion = JsonInclude.Include.ALWAYS;\n        }\n        \n        switch (inclusion) {\n        case NON_DEFAULT:\n            \n            \n            \n            \n            \n            Object defaultBean;\n\n            \n            \n            \n            \n            if (_useRealPropertyDefaults && (defaultBean = getDefaultBean()) != null) {\n                \n                if (prov.isEnabled(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS)) {\n                    am.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n                }\n                try {\n                    valueToSuppress = am.getValue(defaultBean);\n                } catch (Exception e) {\n                    _throwWrapped(e, propDef.getName(), defaultBean);\n                }\n            } else {\n                valueToSuppress = getDefaultValue(actualType);\n                suppressNulls = true;\n            }\n            if (valueToSuppress == null) {\n                suppressNulls = true;\n            } else {\n                if (valueToSuppress.getClass().isArray()) {\n                    valueToSuppress = ArrayBuilders.getArrayComparator(valueToSuppress);\n                }\n            }\n            break;\n        case NON_ABSENT: \n            \n            suppressNulls = true;\n            \n            if (actualType.isReferenceType()) {\n                valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n            }\n            break;\n        case NON_EMPTY:\n            \n            suppressNulls = true;\n            \n            valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n            break;\n        case NON_NULL:\n            suppressNulls = true;\n            \n        case ALWAYS: \n        default:\n            \n            if (actualType.isContainerType()\n                    && !_config.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)) {\n                valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n            }\n            break;\n        }\n        BeanPropertyWriter bpw = new BeanPropertyWriter(propDef,\n                am, _beanDesc.getClassAnnotations(), declaredType,\n                ser, typeSer, serializationType, suppressNulls, valueToSuppress);\n\n        \n        Object serDef = _annotationIntrospector.findNullSerializer(am);\n        if (serDef != null) {\n            bpw.assignNullSerializer(prov.serializerInstance(am, serDef));\n        }\n        \n        NameTransformer unwrapper = _annotationIntrospector.findUnwrappingNameTransformer(am);\n        if (unwrapper != null) {\n            bpw = bpw.unwrappingWriter(unwrapper);\n        }\n        return bpw;\n    }\n\n    \n\n    \n    protected JavaType findSerializationType(Annotated a, boolean useStaticTyping, JavaType declaredType) throws JsonMappingException {\n        JavaType secondary = _annotationIntrospector.refineSerializationType(_config, a, declaredType);\n\n        \n        \n        if (secondary != declaredType) {\n            Class<?> serClass = secondary.getRawClass();\n            \n            Class<?> rawDeclared = declaredType.getRawClass();\n            if (serClass.isAssignableFrom(rawDeclared)) {\n                ; \n            } else {\n                \n                if (!rawDeclared.isAssignableFrom(serClass)) {\n                    throw new IllegalArgumentException(\"Illegal concrete-type annotation for method '\"+a.getName()+\"': class \"+serClass.getName()+\" not a super-type of (declared) class \"+rawDeclared.getName());\n                }\n                \n            }\n            useStaticTyping = true;\n            declaredType = secondary;\n        }\n        \n        JsonSerialize.Typing typing = _annotationIntrospector.findSerializationTyping(a);\n        if ((typing != null) && (typing != JsonSerialize.Typing.DEFAULT_TYPING)) {\n            useStaticTyping = (typing == JsonSerialize.Typing.STATIC);\n        }\n        if (useStaticTyping) {\n            \n            return declaredType.withStaticTyping();\n            \n        }\n        return null;\n    }\n\n    \n\n    protected Object getDefaultBean() {\n        Object def = _defaultBean;\n        if (def == null) {\n            \n            def = _beanDesc.instantiateBean(_config.canOverrideAccessModifiers());\n            if (def == null) {\n                \n                \n\n                \n                def = NO_DEFAULT_MARKER;\n            }\n            _defaultBean = def;\n        }\n        return (def == NO_DEFAULT_MARKER) ? null : _defaultBean;\n    }\n\n    \n    @Deprecated \n    protected Object getPropertyDefaultValue(String name, AnnotatedMember member, JavaType type) {\n        Object defaultBean = getDefaultBean();\n        if (defaultBean == null) {\n            return getDefaultValue(type);\n        }\n        try {\n            return member.getValue(defaultBean);\n        } catch (Exception e) {\n            return _throwWrapped(e, name, defaultBean);\n        }\n    }\n\n    \n    protected Object getDefaultValue(JavaType type) {\n        \n        \n        Class<?> cls = type.getRawClass();\n\n        Class<?> prim = ClassUtil.primitiveType(cls);\n        if (prim != null) {\n            return ClassUtil.defaultValue(prim);\n        }\n        if (type.isContainerType() || type.isReferenceType()) {\n            return JsonInclude.Include.NON_EMPTY;\n        }\n        if (cls == String.class) {\n            return \"\";\n        }\n        return null;\n    }\n    \n    \n    \n    protected Object _throwWrapped(Exception e, String propName, Object defaultBean) {\n        Throwable t = e;\n        while (t.getCause() != null) {\n            t = t.getCause();\n        }\n        if (t instanceof Error) throw (Error) t;\n        if (t instanceof RuntimeException) throw (RuntimeException) t;\n        throw new IllegalArgumentException(\"Failed to get property '\"+propName+\"' of default \"+defaultBean.getClass().getName()+\" instance\");\n    }\n}\n",
      "buggy_signatures": [
        "public Annotations getClassAnnotations()",
        "protected BeanPropertyWriter buildWriter(SerializerProvider prov, BeanPropertyDefinition propDef, JavaType declaredType, JsonSerializer<?> ser, TypeSerializer typeSer, TypeSerializer contentTypeSer, AnnotatedMember am, boolean defaultUseStaticTyping) throws JsonMappingException",
        "protected JavaType findSerializationType(Annotated a, boolean useStaticTyping, JavaType declaredType) throws JsonMappingException",
        "protected Object getDefaultBean()",
        "protected Object getPropertyDefaultValue(String name, AnnotatedMember member, JavaType type)",
        "protected Object getDefaultValue(JavaType type)",
        "protected Object _throwWrapped(Exception e, String propName, Object defaultBean)"
      ],
      "fixed_signatures": [
        "public Annotations getClassAnnotations()",
        "protected BeanPropertyWriter buildWriter(SerializerProvider prov, BeanPropertyDefinition propDef, JavaType declaredType, JsonSerializer<?> ser, TypeSerializer typeSer, TypeSerializer contentTypeSer, AnnotatedMember am, boolean defaultUseStaticTyping) throws JsonMappingException",
        "protected JavaType findSerializationType(Annotated a, boolean useStaticTyping, JavaType declaredType) throws JsonMappingException",
        "protected Object getDefaultBean()",
        "protected Object getPropertyDefaultValue(String name, AnnotatedMember member, JavaType type)",
        "protected Object getDefaultValue(JavaType type)",
        "protected Object _throwWrapped(Exception e, String propName, Object defaultBean)"
      ],
      "methods": [
        {
          "buggy_method": "  protected BeanPropertyWriter buildWriter(SerializerProvider prov, BeanPropertyDefinition propDef, JavaType declaredType, JsonSerializer<?> ser, TypeSerializer typeSer, TypeSerializer contentTypeSer, AnnotatedMember am, boolean defaultUseStaticTyping) throws JsonMappingException {\n  \n  JavaType serializationType;\n  try {\n  serializationType = findSerializationType(am, defaultUseStaticTyping, declaredType);\n  } catch (JsonMappingException e) {\n  return prov.reportBadPropertyDefinition(_beanDesc, propDef, e.getMessage());\n  }\n\n  \n  if (contentTypeSer != null) {\n  \n  if (serializationType == null) {\n\n  serializationType = declaredType;\n  }\n  JavaType ct = serializationType.getContentType();\n  \n  if (ct == null) {\n  prov.reportBadPropertyDefinition(_beanDesc, propDef,\n  \"serialization type \"+serializationType+\" has no content\");\n  }\n  serializationType = serializationType.withContentTypeHandler(contentTypeSer);\n  ct = serializationType.getContentType();\n  }\n\n  Object valueToSuppress = null;\n  boolean suppressNulls = false;\n\n  \n  JavaType actualType = (serializationType == null) ? declaredType : serializationType;\n  \n  \n  \n  \n  JsonInclude.Value inclV = _config.getDefaultPropertyInclusion(actualType.getRawClass(),\n  _defaultInclusion);\n\n  \n  \n  inclV = inclV.withOverrides(propDef.findInclusion());\n  JsonInclude.Include inclusion = inclV.getValueInclusion();\n\n  if (inclusion == JsonInclude.Include.USE_DEFAULTS) { \n  inclusion = JsonInclude.Include.ALWAYS;\n  }\n  \n  switch (inclusion) {\n  case NON_DEFAULT:\n  \n  \n  \n  \n  \n\n  \n  \n  \n  \n  if (_useRealPropertyDefaults) {\n  \n  if (prov.isEnabled(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS)) {\n  am.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n  }\n  valueToSuppress = getPropertyDefaultValue(propDef.getName(), am, actualType);\n  } else {\n  valueToSuppress = getDefaultValue(actualType);\n  suppressNulls = true;\n  }\n  if (valueToSuppress == null) {\n  suppressNulls = true;\n  } else {\n  if (valueToSuppress.getClass().isArray()) {\n  valueToSuppress = ArrayBuilders.getArrayComparator(valueToSuppress);\n  }\n  }\n  break;\n  case NON_ABSENT: \n  \n  suppressNulls = true;\n  \n  if (actualType.isReferenceType()) {\n  valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n  }\n  break;\n  case NON_EMPTY:\n  \n  suppressNulls = true;\n  \n  valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n  break;\n  case NON_NULL:\n  suppressNulls = true;\n  \n  case ALWAYS: \n  default:\n  \n  if (actualType.isContainerType()\n  && !_config.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)) {\n  valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n  }\n  break;\n  }\n  BeanPropertyWriter bpw = new BeanPropertyWriter(propDef,\n  am, _beanDesc.getClassAnnotations(), declaredType,\n  ser, typeSer, serializationType, suppressNulls, valueToSuppress);\n\n  \n  Object serDef = _annotationIntrospector.findNullSerializer(am);\n  if (serDef != null) {\n  bpw.assignNullSerializer(prov.serializerInstance(am, serDef));\n  }\n  \n  NameTransformer unwrapper = _annotationIntrospector.findUnwrappingNameTransformer(am);\n  if (unwrapper != null) {\n  bpw = bpw.unwrappingWriter(unwrapper);\n  }\n  return bpw;\n  }",
          "fixed_method": "  protected BeanPropertyWriter buildWriter(SerializerProvider prov, BeanPropertyDefinition propDef, JavaType declaredType, JsonSerializer<?> ser, TypeSerializer typeSer, TypeSerializer contentTypeSer, AnnotatedMember am, boolean defaultUseStaticTyping) throws JsonMappingException {\n  \n  JavaType serializationType;\n  try {\n  serializationType = findSerializationType(am, defaultUseStaticTyping, declaredType);\n  } catch (JsonMappingException e) {\n  return prov.reportBadPropertyDefinition(_beanDesc, propDef, e.getMessage());\n  }\n\n  \n  if (contentTypeSer != null) {\n  \n  if (serializationType == null) {\n\n  serializationType = declaredType;\n  }\n  JavaType ct = serializationType.getContentType();\n  \n  if (ct == null) {\n  prov.reportBadPropertyDefinition(_beanDesc, propDef,\n  \"serialization type \"+serializationType+\" has no content\");\n  }\n  serializationType = serializationType.withContentTypeHandler(contentTypeSer);\n  ct = serializationType.getContentType();\n  }\n\n  Object valueToSuppress = null;\n  boolean suppressNulls = false;\n\n  \n  JavaType actualType = (serializationType == null) ? declaredType : serializationType;\n  \n  \n  \n  \n  JsonInclude.Value inclV = _config.getDefaultPropertyInclusion(actualType.getRawClass(),\n  _defaultInclusion);\n\n  \n  \n  inclV = inclV.withOverrides(propDef.findInclusion());\n  JsonInclude.Include inclusion = inclV.getValueInclusion();\n\n  if (inclusion == JsonInclude.Include.USE_DEFAULTS) { \n  inclusion = JsonInclude.Include.ALWAYS;\n  }\n  \n  switch (inclusion) {\n  case NON_DEFAULT:\n  \n  \n  \n  \n  \n  Object defaultBean;\n\n  \n  \n  \n  \n  if (_useRealPropertyDefaults && (defaultBean = getDefaultBean()) != null) {\n  \n  if (prov.isEnabled(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS)) {\n  am.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n  }\n  try {\n  valueToSuppress = am.getValue(defaultBean);\n  } catch (Exception e) {\n  _throwWrapped(e, propDef.getName(), defaultBean);\n  }\n  } else {\n  valueToSuppress = getDefaultValue(actualType);\n  suppressNulls = true;\n  }\n  if (valueToSuppress == null) {\n  suppressNulls = true;\n  } else {\n  if (valueToSuppress.getClass().isArray()) {\n  valueToSuppress = ArrayBuilders.getArrayComparator(valueToSuppress);\n  }\n  }\n  break;\n  case NON_ABSENT: \n  \n  suppressNulls = true;\n  \n  if (actualType.isReferenceType()) {\n  valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n  }\n  break;\n  case NON_EMPTY:\n  \n  suppressNulls = true;\n  \n  valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n  break;\n  case NON_NULL:\n  suppressNulls = true;\n  \n  case ALWAYS: \n  default:\n  \n  if (actualType.isContainerType()\n  && !_config.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)) {\n  valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n  }\n  break;\n  }\n  BeanPropertyWriter bpw = new BeanPropertyWriter(propDef,\n  am, _beanDesc.getClassAnnotations(), declaredType,\n  ser, typeSer, serializationType, suppressNulls, valueToSuppress);\n\n  \n  Object serDef = _annotationIntrospector.findNullSerializer(am);\n  if (serDef != null) {\n  bpw.assignNullSerializer(prov.serializerInstance(am, serDef));\n  }\n  \n  NameTransformer unwrapper = _annotationIntrospector.findUnwrappingNameTransformer(am);\n  if (unwrapper != null) {\n  bpw = bpw.unwrappingWriter(unwrapper);\n  }\n  return bpw;\n  }",
          "diff": [
            "@@ -149,17 +149,22 @@",
            "             //    whereas for global defaults OR per-property overrides, we have more\n",
            "             //    static definition. Sigh.\n",
            "             // First: case of class/type specifying it; try to find POJO property defaults\n",
            "+            Object defaultBean;\n",
            " \n",
            "             // 16-Oct-2016, tatu: Note: if we can not for some reason create \"default instance\",\n",
            "             //    revert logic to the case of general/per-property handling, so both\n",
            "             //    type-default AND null are to be excluded.\n",
            "             //    (as per [databind#1417]\n",
            "-            if (_useRealPropertyDefaults) {\n",
            "+            if (_useRealPropertyDefaults && (defaultBean = getDefaultBean()) != null) {\n",
            "                 // 07-Sep-2016, tatu: may also need to front-load access forcing now\n",
            "                 if (prov.isEnabled(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS)) {\n",
            "                     am.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n",
            "                 }\n",
            "-                valueToSuppress = getPropertyDefaultValue(propDef.getName(), am, actualType);\n",
            "+                try {\n",
            "+                    valueToSuppress = am.getValue(defaultBean);\n",
            "+                } catch (Exception e) {\n",
            "+                    _throwWrapped(e, propDef.getName(), defaultBean);\n",
            "+                }\n",
            "             } else {\n",
            "                 valueToSuppress = getDefaultValue(actualType);\n",
            "                 suppressNulls = true;\n"
          ],
          "changed_lines": 9
        }
      ]
    }
  ]
}
