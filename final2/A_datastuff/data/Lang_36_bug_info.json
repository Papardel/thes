{
  "bug_id": "36",
  "failed_tests": {
    "org.apache.commons.lang3.math.NumberUtilsTest": [
      {
        "methodName": "testCreateNumber",
        "error": "java.lang.NumberFormatException",
        "message": "2. is not a valid number.",
        "fail_line": "        assertEquals(\"createNumber(String) LANG-521 failed\", new Float(\"2.\"), NumberUtils.createNumber(\"2.\"));",
        "test_source": "  public void testCreateNumber() {\n  // a lot of things can go wrong\n  assertEquals(\"createNumber(String) 1 failed\", new Float(\"1234.5\"), NumberUtils.createNumber(\"1234.5\"));\n  assertEquals(\"createNumber(String) 2 failed\", new Integer(\"12345\"), NumberUtils.createNumber(\"12345\"));\n  assertEquals(\"createNumber(String) 3 failed\", new Double(\"1234.5\"), NumberUtils.createNumber(\"1234.5D\"));\n  assertEquals(\"createNumber(String) 3 failed\", new Double(\"1234.5\"), NumberUtils.createNumber(\"1234.5d\"));\n  assertEquals(\"createNumber(String) 4 failed\", new Float(\"1234.5\"), NumberUtils.createNumber(\"1234.5F\"));\n  assertEquals(\"createNumber(String) 4 failed\", new Float(\"1234.5\"), NumberUtils.createNumber(\"1234.5f\"));\n  assertEquals(\"createNumber(String) 5 failed\", new Long(Integer.MAX_VALUE + 1L), NumberUtils.createNumber(\"\"\n  + (Integer.MAX_VALUE + 1L)));\n  assertEquals(\"createNumber(String) 6 failed\", new Long(12345), NumberUtils.createNumber(\"12345L\"));\n  assertEquals(\"createNumber(String) 6 failed\", new Long(12345), NumberUtils.createNumber(\"12345l\"));\n  assertEquals(\"createNumber(String) 7 failed\", new Float(\"-1234.5\"), NumberUtils.createNumber(\"-1234.5\"));\n  assertEquals(\"createNumber(String) 8 failed\", new Integer(\"-12345\"), NumberUtils.createNumber(\"-12345\"));\n  assertTrue(\"createNumber(String) 9 failed\", 0xFADE == NumberUtils.createNumber(\"0xFADE\").intValue());\n  assertTrue(\"createNumber(String) 10 failed\", -0xFADE == NumberUtils.createNumber(\"-0xFADE\").intValue());\n  assertEquals(\"createNumber(String) 11 failed\", new Double(\"1.1E200\"), NumberUtils.createNumber(\"1.1E200\"));\n  assertEquals(\"createNumber(String) 12 failed\", new Float(\"1.1E20\"), NumberUtils.createNumber(\"1.1E20\"));\n  assertEquals(\"createNumber(String) 13 failed\", new Double(\"-1.1E200\"), NumberUtils.createNumber(\"-1.1E200\"));\n  assertEquals(\"createNumber(String) 14 failed\", new Double(\"1.1E-200\"), NumberUtils.createNumber(\"1.1E-200\"));\n  assertEquals(\"createNumber(null) failed\", null, NumberUtils.createNumber(null));\n  assertEquals(\"createNumber(String) failed\", new BigInteger(\"12345678901234567890\"), NumberUtils\n  .createNumber(\"12345678901234567890L\"));\n\n  // jdk 1.2 doesn't support this. unsure about jdk 1.2.2\n  if (SystemUtils.isJavaVersionAtLeast(1.3f)) {\n  assertEquals(\"createNumber(String) 15 failed\", new BigDecimal(\"1.1E-700\"), NumberUtils\n  .createNumber(\"1.1E-700F\"));\n  }\n  assertEquals(\"createNumber(String) 16 failed\", new Long(\"10\" + Integer.MAX_VALUE), NumberUtils\n  .createNumber(\"10\" + Integer.MAX_VALUE + \"L\"));\n  assertEquals(\"createNumber(String) 17 failed\", new Long(\"10\" + Integer.MAX_VALUE), NumberUtils\n  .createNumber(\"10\" + Integer.MAX_VALUE));\n  assertEquals(\"createNumber(String) 18 failed\", new BigInteger(\"10\" + Long.MAX_VALUE), NumberUtils\n  .createNumber(\"10\" + Long.MAX_VALUE));\n\n  // LANG-521\n  assertEquals(\"createNumber(String) LANG-521 failed\", new Float(\"2.\"), NumberUtils.createNumber(\"2.\"));\n  }",
        "stack": [
          "NumberUtils.createNumber line 546, NumberUtilsTest.testCreateNumber line 213"
        ]
      },
      {
        "methodName": "testIsNumber",
        "error": "junit.framework.AssertionFailedError",
        "message": "isNumber(String) LANG-521 failed",
        "fail_line": "        assertTrue(\"isNumber(String) LANG-521 failed\", NumberUtils.isNumber(val));",
        "test_source": "  public void testIsNumber() {\n  String val = \"12345\";\n  assertTrue(\"isNumber(String) 1 failed\", NumberUtils.isNumber(val));\n  assertTrue(\"isNumber(String)/createNumber(String) 1 failed\", checkCreateNumber(val));\n  val = \"1234.5\";\n  assertTrue(\"isNumber(String) 2 failed\", NumberUtils.isNumber(val));\n  assertTrue(\"isNumber(String)/createNumber(String) 2 failed\", checkCreateNumber(val));\n  val = \".12345\";\n  assertTrue(\"isNumber(String) 3 failed\", NumberUtils.isNumber(val));\n  assertTrue(\"isNumber(String)/createNumber(String) 3 failed\", checkCreateNumber(val));\n  val = \"1234E5\";\n  assertTrue(\"isNumber(String) 4 failed\", NumberUtils.isNumber(val));\n  assertTrue(\"isNumber(String)/createNumber(String) 4 failed\", checkCreateNumber(val));\n  val = \"1234E+5\";\n  assertTrue(\"isNumber(String) 5 failed\", NumberUtils.isNumber(val));\n  assertTrue(\"isNumber(String)/createNumber(String) 5 failed\", checkCreateNumber(val));\n  val = \"1234E-5\";\n  assertTrue(\"isNumber(String) 6 failed\", NumberUtils.isNumber(val));\n  assertTrue(\"isNumber(String)/createNumber(String) 6 failed\", checkCreateNumber(val));\n  val = \"123.4E5\";\n  assertTrue(\"isNumber(String) 7 failed\", NumberUtils.isNumber(val));\n  assertTrue(\"isNumber(String)/createNumber(String) 7 failed\", checkCreateNumber(val));\n  val = \"-1234\";\n  assertTrue(\"isNumber(String) 8 failed\", NumberUtils.isNumber(val));\n  assertTrue(\"isNumber(String)/createNumber(String) 8 failed\", checkCreateNumber(val));\n  val = \"-1234.5\";\n  assertTrue(\"isNumber(String) 9 failed\", NumberUtils.isNumber(val));\n  assertTrue(\"isNumber(String)/createNumber(String) 9 failed\", checkCreateNumber(val));\n  val = \"-.12345\";\n  assertTrue(\"isNumber(String) 10 failed\", NumberUtils.isNumber(val));\n  assertTrue(\"isNumber(String)/createNumber(String) 10 failed\", checkCreateNumber(val));\n  val = \"-1234E5\";\n  assertTrue(\"isNumber(String) 11 failed\", NumberUtils.isNumber(val));\n  assertTrue(\"isNumber(String)/createNumber(String) 11 failed\", checkCreateNumber(val));\n  val = \"0\";\n  assertTrue(\"isNumber(String) 12 failed\", NumberUtils.isNumber(val));\n  assertTrue(\"isNumber(String)/createNumber(String) 12 failed\", checkCreateNumber(val));\n  val = \"-0\";\n  assertTrue(\"isNumber(String) 13 failed\", NumberUtils.isNumber(val));\n  assertTrue(\"isNumber(String)/createNumber(String) 13 failed\", checkCreateNumber(val));\n  val = \"01234\";\n  assertTrue(\"isNumber(String) 14 failed\", NumberUtils.isNumber(val));\n  assertTrue(\"isNumber(String)/createNumber(String) 14 failed\", checkCreateNumber(val));\n  val = \"-01234\";\n  assertTrue(\"isNumber(String) 15 failed\", NumberUtils.isNumber(val));\n  assertTrue(\"isNumber(String)/createNumber(String) 15 failed\", checkCreateNumber(val));\n  val = \"0xABC123\";\n  assertTrue(\"isNumber(String) 16 failed\", NumberUtils.isNumber(val));\n  assertTrue(\"isNumber(String)/createNumber(String) 16 failed\", checkCreateNumber(val));\n  val = \"0x0\";\n  assertTrue(\"isNumber(String) 17 failed\", NumberUtils.isNumber(val));\n  assertTrue(\"isNumber(String)/createNumber(String) 17 failed\", checkCreateNumber(val));\n  val = \"123.4E21D\";\n  assertTrue(\"isNumber(String) 19 failed\", NumberUtils.isNumber(val));\n  assertTrue(\"isNumber(String)/createNumber(String) 19 failed\", checkCreateNumber(val));\n  val = \"-221.23F\";\n  assertTrue(\"isNumber(String) 20 failed\", NumberUtils.isNumber(val));\n  assertTrue(\"isNumber(String)/createNumber(String) 20 failed\", checkCreateNumber(val));\n  val = \"22338L\";\n  assertTrue(\"isNumber(String) 21 failed\", NumberUtils.isNumber(val));\n  assertTrue(\"isNumber(String)/createNumber(String) 21 failed\", checkCreateNumber(val));\n  val = null;\n  assertTrue(\"isNumber(String) 1 Neg failed\", !NumberUtils.isNumber(val));\n  assertTrue(\"isNumber(String)/createNumber(String) 1 Neg failed\", !checkCreateNumber(val));\n  val = \"\";\n  assertTrue(\"isNumber(String) 2 Neg failed\", !NumberUtils.isNumber(val));\n  assertTrue(\"isNumber(String)/createNumber(String) 2 Neg failed\", !checkCreateNumber(val));\n  val = \"--2.3\";\n  assertTrue(\"isNumber(String) 3 Neg failed\", !NumberUtils.isNumber(val));\n  assertTrue(\"isNumber(String)/createNumber(String) 3 Neg failed\", !checkCreateNumber(val));\n  val = \".12.3\";\n  assertTrue(\"isNumber(String) 4 Neg failed\", !NumberUtils.isNumber(val));\n  assertTrue(\"isNumber(String)/createNumber(String) 4 Neg failed\", !checkCreateNumber(val));\n  val = \"-123E\";\n  assertTrue(\"isNumber(String) 5 Neg failed\", !NumberUtils.isNumber(val));\n  assertTrue(\"isNumber(String)/createNumber(String) 5 Neg failed\", !checkCreateNumber(val));\n  val = \"-123E+-212\";\n  assertTrue(\"isNumber(String) 6 Neg failed\", !NumberUtils.isNumber(val));\n  assertTrue(\"isNumber(String)/createNumber(String) 6 Neg failed\", !checkCreateNumber(val));\n  val = \"-123E2.12\";\n  assertTrue(\"isNumber(String) 7 Neg failed\", !NumberUtils.isNumber(val));\n  assertTrue(\"isNumber(String)/createNumber(String) 7 Neg failed\", !checkCreateNumber(val));\n  val = \"0xGF\";\n  assertTrue(\"isNumber(String) 8 Neg failed\", !NumberUtils.isNumber(val));\n  assertTrue(\"isNumber(String)/createNumber(String) 8 Neg failed\", !checkCreateNumber(val));\n  val = \"0xFAE-1\";\n  assertTrue(\"isNumber(String) 9 Neg failed\", !NumberUtils.isNumber(val));\n  assertTrue(\"isNumber(String)/createNumber(String) 9 Neg failed\", !checkCreateNumber(val));\n  val = \".\";\n  assertTrue(\"isNumber(String) 10 Neg failed\", !NumberUtils.isNumber(val));\n  assertTrue(\"isNumber(String)/createNumber(String) 10 Neg failed\", !checkCreateNumber(val));\n  val = \"-0ABC123\";\n  assertTrue(\"isNumber(String) 11 Neg failed\", !NumberUtils.isNumber(val));\n  assertTrue(\"isNumber(String)/createNumber(String) 11 Neg failed\", !checkCreateNumber(val));\n  val = \"123.4E-D\";\n  assertTrue(\"isNumber(String) 12 Neg failed\", !NumberUtils.isNumber(val));\n  assertTrue(\"isNumber(String)/createNumber(String) 12 Neg failed\", !checkCreateNumber(val));\n  val = \"123.4ED\";\n  assertTrue(\"isNumber(String) 13 Neg failed\", !NumberUtils.isNumber(val));\n  assertTrue(\"isNumber(String)/createNumber(String) 13 Neg failed\", !checkCreateNumber(val));\n  val = \"1234E5l\";\n  assertTrue(\"isNumber(String) 14 Neg failed\", !NumberUtils.isNumber(val));\n  assertTrue(\"isNumber(String)/createNumber(String) 14 Neg failed\", !checkCreateNumber(val));\n  val = \"11a\";\n  assertTrue(\"isNumber(String) 15 Neg failed\", !NumberUtils.isNumber(val));\n  assertTrue(\"isNumber(String)/createNumber(String) 15 Neg failed\", !checkCreateNumber(val)); \n  val = \"1a\";\n  assertTrue(\"isNumber(String) 16 Neg failed\", !NumberUtils.isNumber(val));\n  assertTrue(\"isNumber(String)/createNumber(String) 16 Neg failed\", !checkCreateNumber(val)); \n  val = \"a\";\n  assertTrue(\"isNumber(String) 17 Neg failed\", !NumberUtils.isNumber(val));\n  assertTrue(\"isNumber(String)/createNumber(String) 17 Neg failed\", !checkCreateNumber(val)); \n  val = \"11g\";\n  assertTrue(\"isNumber(String) 18 Neg failed\", !NumberUtils.isNumber(val));\n  assertTrue(\"isNumber(String)/createNumber(String) 18 Neg failed\", !checkCreateNumber(val)); \n  val = \"11z\";\n  assertTrue(\"isNumber(String) 19 Neg failed\", !NumberUtils.isNumber(val));\n  assertTrue(\"isNumber(String)/createNumber(String) 19 Neg failed\", !checkCreateNumber(val)); \n  val = \"11def\";\n  assertTrue(\"isNumber(String) 20 Neg failed\", !NumberUtils.isNumber(val));\n  assertTrue(\"isNumber(String)/createNumber(String) 20 Neg failed\", !checkCreateNumber(val)); \n  val = \"11d11\";\n  assertTrue(\"isNumber(String) 21 Neg failed\", !NumberUtils.isNumber(val));\n  assertTrue(\"isNumber(String)/createNumber(String) 21 Neg failed\", !checkCreateNumber(val)); \n  val = \"11 11\";\n  assertTrue(\"isNumber(String) 22 Neg failed\", !NumberUtils.isNumber(val));\n  assertTrue(\"isNumber(String)/createNumber(String) 22 Neg failed\", !checkCreateNumber(val));\n  val = \" 1111\";\n  assertTrue(\"isNumber(String) 23 Neg failed\", !NumberUtils.isNumber(val));\n  assertTrue(\"isNumber(String)/createNumber(String) 23 Neg failed\", !checkCreateNumber(val));\n  val = \"1111 \";\n  assertTrue(\"isNumber(String) 24 Neg failed\", !NumberUtils.isNumber(val));\n  assertTrue(\"isNumber(String)/createNumber(String) 24 Neg failed\", !checkCreateNumber(val));\n\n  // LANG-521\n  val = \"2.\";\n  assertTrue(\"isNumber(String) LANG-521 failed\", NumberUtils.isNumber(val));\n  }",
        "stack": [
          "NumberUtilsTest.testIsNumber line 1138"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/lang3/math/NumberUtils.java",
      "buggy_full_code": "\npackage org.apache.commons.lang3.math;\n\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\n\nimport org.apache.commons.lang3.StringUtils;\n\n\npublic class NumberUtils { public static final Long LONG_ZERO = new Long(0L); public static final Long LONG_ONE = new Long(1L); public static final Long LONG_MINUS_ONE = new Long(-1L); public static final Integer INTEGER_ZERO = new Integer(0); public static final Integer INTEGER_ONE = new Integer(1); public static final Integer INTEGER_MINUS_ONE = new Integer(-1); public static final Short SHORT_ZERO = new Short((short) 0); public static final Short SHORT_ONE = new Short((short) 1); public static final Short SHORT_MINUS_ONE = new Short((short) -1); public static final Byte BYTE_ZERO = Byte.valueOf((byte) 0); public static final Byte BYTE_ONE = Byte.valueOf((byte) 1); public static final Byte BYTE_MINUS_ONE = Byte.valueOf((byte) -1); public static final Double DOUBLE_ZERO = new Double(0.0d); public static final Double DOUBLE_ONE = new Double(1.0d); public static final Double DOUBLE_MINUS_ONE = new Double(-1.0d); public static final Float FLOAT_ZERO = new Float(0.0f); public static final Float FLOAT_ONE = new Float(1.0f); public static final Float FLOAT_MINUS_ONE = new Float(-1.0f); public NumberUtils() {\n        super();\n    }\n\n    \n    \n    public static int toInt(String str) {\n        return toInt(str, 0);\n    }\n\n    \n    public static int toInt(String str, int defaultValue) {\n        if(str == null) {\n            return defaultValue;\n        }\n        try {\n            return Integer.parseInt(str);\n        } catch (NumberFormatException nfe) {\n            return defaultValue;\n        }\n    }\n\n    \n    public static long toLong(String str) {\n        return toLong(str, 0L);\n    }\n\n    \n    public static long toLong(String str, long defaultValue) {\n        if (str == null) {\n            return defaultValue;\n        }\n        try {\n            return Long.parseLong(str);\n        } catch (NumberFormatException nfe) {\n            return defaultValue;\n        }\n    }\n\n    \n    public static float toFloat(String str) {\n        return toFloat(str, 0.0f);\n    }\n\n    \n    public static float toFloat(String str, float defaultValue) {\n      if (str == null) {\n          return defaultValue;\n      }     \n      try {\n          return Float.parseFloat(str);\n      } catch (NumberFormatException nfe) {\n          return defaultValue;\n      }\n    }\n\n    \n    public static double toDouble(String str) {\n        return toDouble(str, 0.0d);\n    }\n\n    \n    public static double toDouble(String str, double defaultValue) {\n      if (str == null) {\n          return defaultValue;\n      }\n      try {\n          return Double.parseDouble(str);\n      } catch (NumberFormatException nfe) {\n          return defaultValue;\n      }\n    }\n\n     \n     \n    public static byte toByte(String str) {\n        return toByte(str, (byte) 0);\n    }\n\n    \n    public static byte toByte(String str, byte defaultValue) {\n        if(str == null) {\n            return defaultValue;\n        }\n        try {\n            return Byte.parseByte(str);\n        } catch (NumberFormatException nfe) {\n            return defaultValue;\n        }\n    }\n\n    \n    public static short toShort(String str) {\n        return toShort(str, (short) 0);\n    }\n\n    \n    public static short toShort(String str, short defaultValue) {\n        if(str == null) {\n            return defaultValue;\n        }\n        try {\n            return Short.parseShort(str);\n        } catch (NumberFormatException nfe) {\n            return defaultValue;\n        }\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\n    \n    public static Number createNumber(String str) throws NumberFormatException {\n        if (str == null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }  \n        if (str.startsWith(\"--\")) {\n            \n            \n            \n            \n            return null;\n        }\n        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n            return createInteger(str);\n        }   \n        char lastChar = str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        int decPos = str.indexOf('.');\n        int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n\n        if (decPos > -1) {\n\n            if (expPos > -1) {\n                if (expPos < decPos) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec = str.substring(decPos + 1, expPos);\n            } else {\n                dec = str.substring(decPos + 1);\n            }\n            mant = str.substring(0, decPos);\n        } else {\n            if (expPos > -1) {\n                mant = str.substring(0, expPos);\n            } else {\n                mant = str;\n            }\n            dec = null;\n        }\n        if (!Character.isDigit(lastChar)) {\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length() - 1);\n            } else {\n                exp = null;\n            }\n            \n            String numeric = str.substring(0, str.length() - 1);\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            switch (lastChar) {\n                case 'l' :\n                case 'L' :\n                    if (dec == null\n                        && exp == null\n                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            \n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case 'f' :\n                case 'F' :\n                    try {\n                        Float f = NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                            \n                            \n                            return f;\n                        }\n\n                    } catch (NumberFormatException nfe) {\n                        \n                    }\n                    \n                case 'd' :\n                case 'D' :\n                    try {\n                        Double d = NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                            return d;\n                        }\n                    } catch (NumberFormatException nfe) {\n                        \n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (NumberFormatException e) {\n                        \n                    }\n                    \n                default :\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n\n            }\n        } else {\n            \n            \n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length());\n            } else {\n                exp = null;\n            }\n            if (dec == null && exp == null) {\n                \n                try {\n                    return createInteger(str);\n                } catch (NumberFormatException nfe) {\n                    \n                }\n                try {\n                    return createLong(str);\n                } catch (NumberFormatException nfe) {\n                    \n                }\n                return createBigInteger(str);\n\n            } else {\n                \n                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n                try {\n                    Float f = createFloat(str);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                    \n                }\n                try {\n                    Double d = createDouble(str);\n                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                    \n                }\n\n                return createBigDecimal(str);\n\n            }\n        }\n    }\n\n    \n    private static boolean isAllZeros(String str) {\n        if (str == null) {\n            return true;\n        }\n        for (int i = str.length() - 1; i >= 0; i--) {\n            if (str.charAt(i) != '0') {\n                return false;\n            }\n        }\n        return str.length() > 0;\n    }\n\n    \n    \n    public static Float createFloat(String str) {\n        if (str == null) {\n            return null;\n        }\n        return Float.valueOf(str);\n    }\n\n    \n    public static Double createDouble(String str) {\n        if (str == null) {\n            return null;\n        }\n        return Double.valueOf(str);\n    }\n\n    \n    public static Integer createInteger(String str) {\n        if (str == null) {\n            return null;\n        }\n        \n        return Integer.decode(str);\n    }\n\n    \n    public static Long createLong(String str) {\n        if (str == null) {\n            return null;\n        }\n        return Long.valueOf(str);\n    }\n\n    \n    public static BigInteger createBigInteger(String str) {\n        if (str == null) {\n            return null;\n        }\n        return new BigInteger(str);\n    }\n\n    \n    public static BigDecimal createBigDecimal(String str) {\n        if (str == null) {\n            return null;\n        }\n        \n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }  \n        return new BigDecimal(str);\n    }\n\n    \n    \n    \n    public static long min(long[] array) {\n        \n        if (array == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        } else if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array cannot be empty.\");\n        }\n    \n        \n        long min = array[0];\n        for (int i = 1; i < array.length; i++) {\n            if (array[i] < min) {\n                min = array[i];\n            }\n        }\n    \n        return min;\n    }\n\n    \n    public static int min(int[] array) {\n        \n        if (array == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        } else if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array cannot be empty.\");\n        }\n    \n        \n        int min = array[0];\n        for (int j = 1; j < array.length; j++) {\n            if (array[j] < min) {\n                min = array[j];\n            }\n        }\n    \n        return min;\n    }\n\n    \n    public static short min(short[] array) {\n        \n        if (array == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        } else if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array cannot be empty.\");\n        }\n    \n        \n        short min = array[0];\n        for (int i = 1; i < array.length; i++) {\n            if (array[i] < min) {\n                min = array[i];\n            }\n        }\n    \n        return min;\n    }\n\n    \n    public static byte min(byte[] array) {\n        \n        if (array == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        } else if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array cannot be empty.\");\n        }\n    \n        \n        byte min = array[0];\n        for (int i = 1; i < array.length; i++) {\n            if (array[i] < min) {\n                min = array[i];\n            }\n        }\n    \n        return min;\n    }\n\n     \n    public static double min(double[] array) {\n        \n        if (array == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        } else if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array cannot be empty.\");\n        }\n    \n        \n        double min = array[0];\n        for (int i = 1; i < array.length; i++) {\n            if (Double.isNaN(array[i])) {\n                return Double.NaN;\n            }\n            if (array[i] < min) {\n                min = array[i];\n            }\n        }\n    \n        return min;\n    }\n\n    \n    public static float min(float[] array) {\n        \n        if (array == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        } else if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array cannot be empty.\");\n        }\n    \n        \n        float min = array[0];\n        for (int i = 1; i < array.length; i++) {\n            if (Float.isNaN(array[i])) {\n                return Float.NaN;\n            }\n            if (array[i] < min) {\n                min = array[i];\n            }\n        }\n    \n        return min;\n    }\n\n    \n    \n    \n    public static long max(long[] array) {\n        \n        if (array == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        } else if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array cannot be empty.\");\n        }\n\n        \n        long max = array[0];\n        for (int j = 1; j < array.length; j++) {\n            if (array[j] > max) {\n                max = array[j];\n            }\n        }\n\n        return max;\n    }\n\n    \n    public static int max(int[] array) {\n        \n        if (array == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        } else if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array cannot be empty.\");\n        }\n    \n        \n        int max = array[0];\n        for (int j = 1; j < array.length; j++) {\n            if (array[j] > max) {\n                max = array[j];\n            }\n        }\n    \n        return max;\n    }\n\n    \n    public static short max(short[] array) {\n        \n        if (array == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        } else if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array cannot be empty.\");\n        }\n    \n        \n        short max = array[0];\n        for (int i = 1; i < array.length; i++) {\n            if (array[i] > max) {\n                max = array[i];\n            }\n        }\n    \n        return max;\n    }\n\n    \n    public static byte max(byte[] array) {\n        \n        if (array == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        } else if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array cannot be empty.\");\n        }\n    \n        \n        byte max = array[0];\n        for (int i = 1; i < array.length; i++) {\n            if (array[i] > max) {\n                max = array[i];\n            }\n        }\n    \n        return max;\n    }\n\n    \n    public static double max(double[] array) {\n        \n        if (array== null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        } else if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array cannot be empty.\");\n        }\n    \n        \n        double max = array[0];\n        for (int j = 1; j < array.length; j++) {\n            if (Double.isNaN(array[j])) {\n                return Double.NaN;\n            }\n            if (array[j] > max) {\n                max = array[j];\n            }\n        }\n    \n        return max;\n    }\n\n    \n    public static float max(float[] array) {\n        \n        if (array == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        } else if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array cannot be empty.\");\n        }\n\n        \n        float max = array[0];\n        for (int j = 1; j < array.length; j++) {\n            if (Float.isNaN(array[j])) {\n                return Float.NaN;\n            }\n            if (array[j] > max) {\n                max = array[j];\n            }\n        }\n\n        return max;\n    }\n     \n    \n    \n    \n    public static long min(long a, long b, long c) {\n        if (b < a) {\n            a = b;\n        }\n        if (c < a) {\n            a = c;\n        }\n        return a;\n    }\n\n    \n    public static int min(int a, int b, int c) {\n        if (b < a) {\n            a = b;\n        }\n        if (c < a) {\n            a = c;\n        }\n        return a;\n    }\n\n    \n    public static short min(short a, short b, short c) {\n        if (b < a) {\n            a = b;\n        }\n        if (c < a) {\n            a = c;\n        }\n        return a;\n    }\n\n    \n    public static byte min(byte a, byte b, byte c) {\n        if (b < a) {\n            a = b;\n        }\n        if (c < a) {\n            a = c;\n        }\n        return a;\n    }\n\n    \n    public static double min(double a, double b, double c) {\n        return Math.min(Math.min(a, b), c);\n    }\n\n    \n    public static float min(float a, float b, float c) {\n        return Math.min(Math.min(a, b), c);\n    }\n\n    \n    \n    \n    public static long max(long a, long b, long c) {\n        if (b > a) {\n            a = b;\n        }\n        if (c > a) {\n            a = c;\n        }\n        return a;\n    }\n\n    \n    public static int max(int a, int b, int c) {\n        if (b > a) {\n            a = b;\n        }\n        if (c > a) {\n            a = c;\n        }\n        return a;\n    }\n\n    \n    public static short max(short a, short b, short c) {\n        if (b > a) {\n            a = b;\n        }\n        if (c > a) {\n            a = c;\n        }\n        return a;\n    }\n\n    \n    public static byte max(byte a, byte b, byte c) {\n        if (b > a) {\n            a = b;\n        }\n        if (c > a) {\n            a = c;\n        }\n        return a;\n    }\n\n    \n    public static double max(double a, double b, double c) {\n        return Math.max(Math.max(a, b), c);\n    }\n\n    \n    public static float max(float a, float b, float c) {\n        return Math.max(Math.max(a, b), c);\n    }\n\n    \n    \n    public static boolean isDigits(String str) {\n        if (StringUtils.isEmpty(str)) {\n            return false;\n        }\n        for (int i = 0; i < str.length(); i++) {\n            if (!Character.isDigit(str.charAt(i))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public static boolean isNumber(String str) {\n        if (StringUtils.isEmpty(str)) {\n            return false;\n        }\n        char[] chars = str.toCharArray();\n        int sz = chars.length;\n        boolean hasExp = false;\n        boolean hasDecPoint = false;\n        boolean allowSigns = false;\n        boolean foundDigit = false;\n        \n        int start = (chars[0] == '-') ? 1 : 0;\n        if (sz > start + 1) {\n            if (chars[start] == '0' && chars[start + 1] == 'x') {\n                int i = start + 2;\n                if (i == sz) {\n                    return false; \n                }\n                \n                for (; i < chars.length; i++) {\n                    if ((chars[i] < '0' || chars[i] > '9')\n                        && (chars[i] < 'a' || chars[i] > 'f')\n                        && (chars[i] < 'A' || chars[i] > 'F')) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n        }\n        sz--; \n              \n        int i = start;\n        \n        \n        while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) {\n            if (chars[i] >= '0' && chars[i] <= '9') {\n                foundDigit = true;\n                allowSigns = false;\n\n            } else if (chars[i] == '.') {\n                if (hasDecPoint || hasExp) {\n                    \n                    return false;\n                }\n                hasDecPoint = true;\n            } else if (chars[i] == 'e' || chars[i] == 'E') {\n                \n                if (hasExp) {\n                    \n                    return false;\n                }\n                if (!foundDigit) {\n                    return false;\n                }\n                hasExp = true;\n                allowSigns = true;\n            } else if (chars[i] == '+' || chars[i] == '-') {\n                if (!allowSigns) {\n                    return false;\n                }\n                allowSigns = false;\n                foundDigit = false; \n            } else {\n                return false;\n            }\n            i++;\n        }\n        if (i < chars.length) {\n            if (chars[i] >= '0' && chars[i] <= '9') {\n                \n                return true;\n            }\n            if (chars[i] == 'e' || chars[i] == 'E') {\n                \n                return false;\n            }\n            if (!allowSigns\n                && (chars[i] == 'd'\n                    || chars[i] == 'D'\n                    || chars[i] == 'f'\n                    || chars[i] == 'F')) {\n                return foundDigit;\n            }\n            if (chars[i] == 'l'\n                || chars[i] == 'L') {\n                \n                return foundDigit && !hasExp;\n            }\n            \n            return false;\n        }\n        \n        \n        return !allowSigns && foundDigit;\n    }\n    \n}\n",
      "fixed_full_code": "\npackage org.apache.commons.lang3.math;\n\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\n\nimport org.apache.commons.lang3.StringUtils;\n\n\npublic class NumberUtils { public static final Long LONG_ZERO = new Long(0L); public static final Long LONG_ONE = new Long(1L); public static final Long LONG_MINUS_ONE = new Long(-1L); public static final Integer INTEGER_ZERO = new Integer(0); public static final Integer INTEGER_ONE = new Integer(1); public static final Integer INTEGER_MINUS_ONE = new Integer(-1); public static final Short SHORT_ZERO = new Short((short) 0); public static final Short SHORT_ONE = new Short((short) 1); public static final Short SHORT_MINUS_ONE = new Short((short) -1); public static final Byte BYTE_ZERO = Byte.valueOf((byte) 0); public static final Byte BYTE_ONE = Byte.valueOf((byte) 1); public static final Byte BYTE_MINUS_ONE = Byte.valueOf((byte) -1); public static final Double DOUBLE_ZERO = new Double(0.0d); public static final Double DOUBLE_ONE = new Double(1.0d); public static final Double DOUBLE_MINUS_ONE = new Double(-1.0d); public static final Float FLOAT_ZERO = new Float(0.0f); public static final Float FLOAT_ONE = new Float(1.0f); public static final Float FLOAT_MINUS_ONE = new Float(-1.0f); public NumberUtils() {\n        super();\n    }\n\n    \n    \n    public static int toInt(String str) {\n        return toInt(str, 0);\n    }\n\n    \n    public static int toInt(String str, int defaultValue) {\n        if(str == null) {\n            return defaultValue;\n        }\n        try {\n            return Integer.parseInt(str);\n        } catch (NumberFormatException nfe) {\n            return defaultValue;\n        }\n    }\n\n    \n    public static long toLong(String str) {\n        return toLong(str, 0L);\n    }\n\n    \n    public static long toLong(String str, long defaultValue) {\n        if (str == null) {\n            return defaultValue;\n        }\n        try {\n            return Long.parseLong(str);\n        } catch (NumberFormatException nfe) {\n            return defaultValue;\n        }\n    }\n\n    \n    public static float toFloat(String str) {\n        return toFloat(str, 0.0f);\n    }\n\n    \n    public static float toFloat(String str, float defaultValue) {\n      if (str == null) {\n          return defaultValue;\n      }     \n      try {\n          return Float.parseFloat(str);\n      } catch (NumberFormatException nfe) {\n          return defaultValue;\n      }\n    }\n\n    \n    public static double toDouble(String str) {\n        return toDouble(str, 0.0d);\n    }\n\n    \n    public static double toDouble(String str, double defaultValue) {\n      if (str == null) {\n          return defaultValue;\n      }\n      try {\n          return Double.parseDouble(str);\n      } catch (NumberFormatException nfe) {\n          return defaultValue;\n      }\n    }\n\n     \n     \n    public static byte toByte(String str) {\n        return toByte(str, (byte) 0);\n    }\n\n    \n    public static byte toByte(String str, byte defaultValue) {\n        if(str == null) {\n            return defaultValue;\n        }\n        try {\n            return Byte.parseByte(str);\n        } catch (NumberFormatException nfe) {\n            return defaultValue;\n        }\n    }\n\n    \n    public static short toShort(String str) {\n        return toShort(str, (short) 0);\n    }\n\n    \n    public static short toShort(String str, short defaultValue) {\n        if(str == null) {\n            return defaultValue;\n        }\n        try {\n            return Short.parseShort(str);\n        } catch (NumberFormatException nfe) {\n            return defaultValue;\n        }\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\n    \n    public static Number createNumber(String str) throws NumberFormatException {\n        if (str == null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }  \n        if (str.startsWith(\"--\")) {\n            \n            \n            \n            \n            return null;\n        }\n        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n            return createInteger(str);\n        }   \n        char lastChar = str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        int decPos = str.indexOf('.');\n        int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n\n        if (decPos > -1) {\n\n            if (expPos > -1) {\n                if (expPos < decPos) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec = str.substring(decPos + 1, expPos);\n            } else {\n                dec = str.substring(decPos + 1);\n            }\n            mant = str.substring(0, decPos);\n        } else {\n            if (expPos > -1) {\n                mant = str.substring(0, expPos);\n            } else {\n                mant = str;\n            }\n            dec = null;\n        }\n        if (!Character.isDigit(lastChar) && lastChar != '.') {\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length() - 1);\n            } else {\n                exp = null;\n            }\n            \n            String numeric = str.substring(0, str.length() - 1);\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            switch (lastChar) {\n                case 'l' :\n                case 'L' :\n                    if (dec == null\n                        && exp == null\n                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            \n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case 'f' :\n                case 'F' :\n                    try {\n                        Float f = NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                            \n                            \n                            return f;\n                        }\n\n                    } catch (NumberFormatException nfe) {\n                        \n                    }\n                    \n                case 'd' :\n                case 'D' :\n                    try {\n                        Double d = NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                            return d;\n                        }\n                    } catch (NumberFormatException nfe) {\n                        \n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (NumberFormatException e) {\n                        \n                    }\n                    \n                default :\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n\n            }\n        } else {\n            \n            \n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length());\n            } else {\n                exp = null;\n            }\n            if (dec == null && exp == null) {\n                \n                try {\n                    return createInteger(str);\n                } catch (NumberFormatException nfe) {\n                    \n                }\n                try {\n                    return createLong(str);\n                } catch (NumberFormatException nfe) {\n                    \n                }\n                return createBigInteger(str);\n\n            } else {\n                \n                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n                try {\n                    Float f = createFloat(str);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                    \n                }\n                try {\n                    Double d = createDouble(str);\n                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                    \n                }\n\n                return createBigDecimal(str);\n\n            }\n        }\n    }\n\n    \n    private static boolean isAllZeros(String str) {\n        if (str == null) {\n            return true;\n        }\n        for (int i = str.length() - 1; i >= 0; i--) {\n            if (str.charAt(i) != '0') {\n                return false;\n            }\n        }\n        return str.length() > 0;\n    }\n\n    \n    \n    public static Float createFloat(String str) {\n        if (str == null) {\n            return null;\n        }\n        return Float.valueOf(str);\n    }\n\n    \n    public static Double createDouble(String str) {\n        if (str == null) {\n            return null;\n        }\n        return Double.valueOf(str);\n    }\n\n    \n    public static Integer createInteger(String str) {\n        if (str == null) {\n            return null;\n        }\n        \n        return Integer.decode(str);\n    }\n\n    \n    public static Long createLong(String str) {\n        if (str == null) {\n            return null;\n        }\n        return Long.valueOf(str);\n    }\n\n    \n    public static BigInteger createBigInteger(String str) {\n        if (str == null) {\n            return null;\n        }\n        return new BigInteger(str);\n    }\n\n    \n    public static BigDecimal createBigDecimal(String str) {\n        if (str == null) {\n            return null;\n        }\n        \n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }  \n        return new BigDecimal(str);\n    }\n\n    \n    \n    \n    public static long min(long[] array) {\n        \n        if (array == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        } else if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array cannot be empty.\");\n        }\n    \n        \n        long min = array[0];\n        for (int i = 1; i < array.length; i++) {\n            if (array[i] < min) {\n                min = array[i];\n            }\n        }\n    \n        return min;\n    }\n\n    \n    public static int min(int[] array) {\n        \n        if (array == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        } else if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array cannot be empty.\");\n        }\n    \n        \n        int min = array[0];\n        for (int j = 1; j < array.length; j++) {\n            if (array[j] < min) {\n                min = array[j];\n            }\n        }\n    \n        return min;\n    }\n\n    \n    public static short min(short[] array) {\n        \n        if (array == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        } else if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array cannot be empty.\");\n        }\n    \n        \n        short min = array[0];\n        for (int i = 1; i < array.length; i++) {\n            if (array[i] < min) {\n                min = array[i];\n            }\n        }\n    \n        return min;\n    }\n\n    \n    public static byte min(byte[] array) {\n        \n        if (array == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        } else if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array cannot be empty.\");\n        }\n    \n        \n        byte min = array[0];\n        for (int i = 1; i < array.length; i++) {\n            if (array[i] < min) {\n                min = array[i];\n            }\n        }\n    \n        return min;\n    }\n\n     \n    public static double min(double[] array) {\n        \n        if (array == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        } else if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array cannot be empty.\");\n        }\n    \n        \n        double min = array[0];\n        for (int i = 1; i < array.length; i++) {\n            if (Double.isNaN(array[i])) {\n                return Double.NaN;\n            }\n            if (array[i] < min) {\n                min = array[i];\n            }\n        }\n    \n        return min;\n    }\n\n    \n    public static float min(float[] array) {\n        \n        if (array == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        } else if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array cannot be empty.\");\n        }\n    \n        \n        float min = array[0];\n        for (int i = 1; i < array.length; i++) {\n            if (Float.isNaN(array[i])) {\n                return Float.NaN;\n            }\n            if (array[i] < min) {\n                min = array[i];\n            }\n        }\n    \n        return min;\n    }\n\n    \n    \n    \n    public static long max(long[] array) {\n        \n        if (array == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        } else if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array cannot be empty.\");\n        }\n\n        \n        long max = array[0];\n        for (int j = 1; j < array.length; j++) {\n            if (array[j] > max) {\n                max = array[j];\n            }\n        }\n\n        return max;\n    }\n\n    \n    public static int max(int[] array) {\n        \n        if (array == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        } else if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array cannot be empty.\");\n        }\n    \n        \n        int max = array[0];\n        for (int j = 1; j < array.length; j++) {\n            if (array[j] > max) {\n                max = array[j];\n            }\n        }\n    \n        return max;\n    }\n\n    \n    public static short max(short[] array) {\n        \n        if (array == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        } else if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array cannot be empty.\");\n        }\n    \n        \n        short max = array[0];\n        for (int i = 1; i < array.length; i++) {\n            if (array[i] > max) {\n                max = array[i];\n            }\n        }\n    \n        return max;\n    }\n\n    \n    public static byte max(byte[] array) {\n        \n        if (array == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        } else if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array cannot be empty.\");\n        }\n    \n        \n        byte max = array[0];\n        for (int i = 1; i < array.length; i++) {\n            if (array[i] > max) {\n                max = array[i];\n            }\n        }\n    \n        return max;\n    }\n\n    \n    public static double max(double[] array) {\n        \n        if (array== null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        } else if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array cannot be empty.\");\n        }\n    \n        \n        double max = array[0];\n        for (int j = 1; j < array.length; j++) {\n            if (Double.isNaN(array[j])) {\n                return Double.NaN;\n            }\n            if (array[j] > max) {\n                max = array[j];\n            }\n        }\n    \n        return max;\n    }\n\n    \n    public static float max(float[] array) {\n        \n        if (array == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        } else if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array cannot be empty.\");\n        }\n\n        \n        float max = array[0];\n        for (int j = 1; j < array.length; j++) {\n            if (Float.isNaN(array[j])) {\n                return Float.NaN;\n            }\n            if (array[j] > max) {\n                max = array[j];\n            }\n        }\n\n        return max;\n    }\n     \n    \n    \n    \n    public static long min(long a, long b, long c) {\n        if (b < a) {\n            a = b;\n        }\n        if (c < a) {\n            a = c;\n        }\n        return a;\n    }\n\n    \n    public static int min(int a, int b, int c) {\n        if (b < a) {\n            a = b;\n        }\n        if (c < a) {\n            a = c;\n        }\n        return a;\n    }\n\n    \n    public static short min(short a, short b, short c) {\n        if (b < a) {\n            a = b;\n        }\n        if (c < a) {\n            a = c;\n        }\n        return a;\n    }\n\n    \n    public static byte min(byte a, byte b, byte c) {\n        if (b < a) {\n            a = b;\n        }\n        if (c < a) {\n            a = c;\n        }\n        return a;\n    }\n\n    \n    public static double min(double a, double b, double c) {\n        return Math.min(Math.min(a, b), c);\n    }\n\n    \n    public static float min(float a, float b, float c) {\n        return Math.min(Math.min(a, b), c);\n    }\n\n    \n    \n    \n    public static long max(long a, long b, long c) {\n        if (b > a) {\n            a = b;\n        }\n        if (c > a) {\n            a = c;\n        }\n        return a;\n    }\n\n    \n    public static int max(int a, int b, int c) {\n        if (b > a) {\n            a = b;\n        }\n        if (c > a) {\n            a = c;\n        }\n        return a;\n    }\n\n    \n    public static short max(short a, short b, short c) {\n        if (b > a) {\n            a = b;\n        }\n        if (c > a) {\n            a = c;\n        }\n        return a;\n    }\n\n    \n    public static byte max(byte a, byte b, byte c) {\n        if (b > a) {\n            a = b;\n        }\n        if (c > a) {\n            a = c;\n        }\n        return a;\n    }\n\n    \n    public static double max(double a, double b, double c) {\n        return Math.max(Math.max(a, b), c);\n    }\n\n    \n    public static float max(float a, float b, float c) {\n        return Math.max(Math.max(a, b), c);\n    }\n\n    \n    \n    public static boolean isDigits(String str) {\n        if (StringUtils.isEmpty(str)) {\n            return false;\n        }\n        for (int i = 0; i < str.length(); i++) {\n            if (!Character.isDigit(str.charAt(i))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public static boolean isNumber(String str) {\n        if (StringUtils.isEmpty(str)) {\n            return false;\n        }\n        char[] chars = str.toCharArray();\n        int sz = chars.length;\n        boolean hasExp = false;\n        boolean hasDecPoint = false;\n        boolean allowSigns = false;\n        boolean foundDigit = false;\n        \n        int start = (chars[0] == '-') ? 1 : 0;\n        if (sz > start + 1) {\n            if (chars[start] == '0' && chars[start + 1] == 'x') {\n                int i = start + 2;\n                if (i == sz) {\n                    return false; \n                }\n                \n                for (; i < chars.length; i++) {\n                    if ((chars[i] < '0' || chars[i] > '9')\n                        && (chars[i] < 'a' || chars[i] > 'f')\n                        && (chars[i] < 'A' || chars[i] > 'F')) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n        }\n        sz--; \n              \n        int i = start;\n        \n        \n        while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) {\n            if (chars[i] >= '0' && chars[i] <= '9') {\n                foundDigit = true;\n                allowSigns = false;\n\n            } else if (chars[i] == '.') {\n                if (hasDecPoint || hasExp) {\n                    \n                    return false;\n                }\n                hasDecPoint = true;\n            } else if (chars[i] == 'e' || chars[i] == 'E') {\n                \n                if (hasExp) {\n                    \n                    return false;\n                }\n                if (!foundDigit) {\n                    return false;\n                }\n                hasExp = true;\n                allowSigns = true;\n            } else if (chars[i] == '+' || chars[i] == '-') {\n                if (!allowSigns) {\n                    return false;\n                }\n                allowSigns = false;\n                foundDigit = false; \n            } else {\n                return false;\n            }\n            i++;\n        }\n        if (i < chars.length) {\n            if (chars[i] >= '0' && chars[i] <= '9') {\n                \n                return true;\n            }\n            if (chars[i] == 'e' || chars[i] == 'E') {\n                \n                return false;\n            }\n            if (chars[i] == '.') {\n                if (hasDecPoint || hasExp) {\n                    \n                    return false;\n                }\n                \n                return foundDigit;\n            }\n            if (!allowSigns\n                && (chars[i] == 'd'\n                    || chars[i] == 'D'\n                    || chars[i] == 'f'\n                    || chars[i] == 'F')) {\n                return foundDigit;\n            }\n            if (chars[i] == 'l'\n                || chars[i] == 'L') {\n                \n                return foundDigit && !hasExp;\n            }\n            \n            return false;\n        }\n        \n        \n        return !allowSigns && foundDigit;\n    }\n    \n}\n",
      "buggy_signatures": [
        "public static int toInt(String str)",
        "public static int toInt(String str, int defaultValue)",
        "public static long toLong(String str)",
        "public static long toLong(String str, long defaultValue)",
        "public static float toFloat(String str)",
        "public static float toFloat(String str, float defaultValue)",
        "public static double toDouble(String str)",
        "public static double toDouble(String str, double defaultValue)",
        "public static byte toByte(String str)",
        "public static byte toByte(String str, byte defaultValue)",
        "public static short toShort(String str)",
        "public static short toShort(String str, short defaultValue)",
        "public static Number createNumber(String str) throws NumberFormatException",
        "private static boolean isAllZeros(String str)",
        "public static Float createFloat(String str)",
        "public static Double createDouble(String str)",
        "public static Integer createInteger(String str)",
        "public static Long createLong(String str)",
        "public static BigInteger createBigInteger(String str)",
        "public static BigDecimal createBigDecimal(String str)",
        "public static long min(long[] array)",
        "public static int min(int[] array)",
        "public static short min(short[] array)",
        "public static byte min(byte[] array)",
        "public static double min(double[] array)",
        "public static float min(float[] array)",
        "public static long max(long[] array)",
        "public static int max(int[] array)",
        "public static short max(short[] array)",
        "public static byte max(byte[] array)",
        "public static double max(double[] array)",
        "public static float max(float[] array)",
        "public static long min(long a, long b, long c)",
        "public static int min(int a, int b, int c)",
        "public static short min(short a, short b, short c)",
        "public static byte min(byte a, byte b, byte c)",
        "public static double min(double a, double b, double c)",
        "public static float min(float a, float b, float c)",
        "public static long max(long a, long b, long c)",
        "public static int max(int a, int b, int c)",
        "public static short max(short a, short b, short c)",
        "public static byte max(byte a, byte b, byte c)",
        "public static double max(double a, double b, double c)",
        "public static float max(float a, float b, float c)",
        "public static boolean isDigits(String str)",
        "public static boolean isNumber(String str)"
      ],
      "fixed_signatures": [
        "public static int toInt(String str)",
        "public static int toInt(String str, int defaultValue)",
        "public static long toLong(String str)",
        "public static long toLong(String str, long defaultValue)",
        "public static float toFloat(String str)",
        "public static float toFloat(String str, float defaultValue)",
        "public static double toDouble(String str)",
        "public static double toDouble(String str, double defaultValue)",
        "public static byte toByte(String str)",
        "public static byte toByte(String str, byte defaultValue)",
        "public static short toShort(String str)",
        "public static short toShort(String str, short defaultValue)",
        "public static Number createNumber(String str) throws NumberFormatException",
        "private static boolean isAllZeros(String str)",
        "public static Float createFloat(String str)",
        "public static Double createDouble(String str)",
        "public static Integer createInteger(String str)",
        "public static Long createLong(String str)",
        "public static BigInteger createBigInteger(String str)",
        "public static BigDecimal createBigDecimal(String str)",
        "public static long min(long[] array)",
        "public static int min(int[] array)",
        "public static short min(short[] array)",
        "public static byte min(byte[] array)",
        "public static double min(double[] array)",
        "public static float min(float[] array)",
        "public static long max(long[] array)",
        "public static int max(int[] array)",
        "public static short max(short[] array)",
        "public static byte max(byte[] array)",
        "public static double max(double[] array)",
        "public static float max(float[] array)",
        "public static long min(long a, long b, long c)",
        "public static int min(int a, int b, int c)",
        "public static short min(short a, short b, short c)",
        "public static byte min(byte a, byte b, byte c)",
        "public static double min(double a, double b, double c)",
        "public static float min(float a, float b, float c)",
        "public static long max(long a, long b, long c)",
        "public static int max(int a, int b, int c)",
        "public static short max(short a, short b, short c)",
        "public static byte max(byte a, byte b, byte c)",
        "public static double max(double a, double b, double c)",
        "public static float max(float a, float b, float c)",
        "public static boolean isDigits(String str)",
        "public static boolean isNumber(String str)"
      ],
      "methods": [
        {
          "buggy_method": "  public static Number createNumber(String str) throws NumberFormatException {\n  if (str == null) {\n  return null;\n  }\n  if (StringUtils.isBlank(str)) {\n  throw new NumberFormatException(\"A blank string is not a valid number\");\n  }  \n  if (str.startsWith(\"--\")) {\n  \n  \n  \n  \n  return null;\n  }\n  if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n  return createInteger(str);\n  }  \n  char lastChar = str.charAt(str.length() - 1);\n  String mant;\n  String dec;\n  String exp;\n  int decPos = str.indexOf('.');\n  int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n\n  if (decPos > -1) {\n\n  if (expPos > -1) {\n  if (expPos < decPos) {\n  throw new NumberFormatException(str + \" is not a valid number.\");\n  }\n  dec = str.substring(decPos + 1, expPos);\n  } else {\n  dec = str.substring(decPos + 1);\n  }\n  mant = str.substring(0, decPos);\n  } else {\n  if (expPos > -1) {\n  mant = str.substring(0, expPos);\n  } else {\n  mant = str;\n  }\n  dec = null;\n  }\n  if (!Character.isDigit(lastChar)) {\n  if (expPos > -1 && expPos < str.length() - 1) {\n  exp = str.substring(expPos + 1, str.length() - 1);\n  } else {\n  exp = null;\n  }\n  \n  String numeric = str.substring(0, str.length() - 1);\n  boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n  switch (lastChar) {\n  case 'l' :\n  case 'L' :\n  if (dec == null\n  && exp == null\n  && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n  try {\n  return createLong(numeric);\n  } catch (NumberFormatException nfe) {\n  \n  }\n  return createBigInteger(numeric);\n\n  }\n  throw new NumberFormatException(str + \" is not a valid number.\");\n  case 'f' :\n  case 'F' :\n  try {\n  Float f = NumberUtils.createFloat(numeric);\n  if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n  \n  \n  return f;\n  }\n\n  } catch (NumberFormatException nfe) {\n  \n  }\n  \n  case 'd' :\n  case 'D' :\n  try {\n  Double d = NumberUtils.createDouble(numeric);\n  if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n  return d;\n  }\n  } catch (NumberFormatException nfe) {\n  \n  }\n  try {\n  return createBigDecimal(numeric);\n  } catch (NumberFormatException e) {\n  \n  }\n  \n  default :\n  throw new NumberFormatException(str + \" is not a valid number.\");\n\n  }\n  } else {\n  \n  \n  if (expPos > -1 && expPos < str.length() - 1) {\n  exp = str.substring(expPos + 1, str.length());\n  } else {\n  exp = null;\n  }\n  if (dec == null && exp == null) {\n  \n  try {\n  return createInteger(str);\n  } catch (NumberFormatException nfe) {\n  \n  }\n  try {\n  return createLong(str);\n  } catch (NumberFormatException nfe) {\n  \n  }\n  return createBigInteger(str);\n\n  } else {\n  \n  boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n  try {\n  Float f = createFloat(str);\n  if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n  return f;\n  }\n  } catch (NumberFormatException nfe) {\n  \n  }\n  try {\n  Double d = createDouble(str);\n  if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n  return d;\n  }\n  } catch (NumberFormatException nfe) {\n  \n  }\n\n  return createBigDecimal(str);\n\n  }\n  }\n  }",
          "fixed_method": "  public static Number createNumber(String str) throws NumberFormatException {\n  if (str == null) {\n  return null;\n  }\n  if (StringUtils.isBlank(str)) {\n  throw new NumberFormatException(\"A blank string is not a valid number\");\n  }  \n  if (str.startsWith(\"--\")) {\n  \n  \n  \n  \n  return null;\n  }\n  if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n  return createInteger(str);\n  }  \n  char lastChar = str.charAt(str.length() - 1);\n  String mant;\n  String dec;\n  String exp;\n  int decPos = str.indexOf('.');\n  int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n\n  if (decPos > -1) {\n\n  if (expPos > -1) {\n  if (expPos < decPos) {\n  throw new NumberFormatException(str + \" is not a valid number.\");\n  }\n  dec = str.substring(decPos + 1, expPos);\n  } else {\n  dec = str.substring(decPos + 1);\n  }\n  mant = str.substring(0, decPos);\n  } else {\n  if (expPos > -1) {\n  mant = str.substring(0, expPos);\n  } else {\n  mant = str;\n  }\n  dec = null;\n  }\n  if (!Character.isDigit(lastChar) && lastChar != '.') {\n  if (expPos > -1 && expPos < str.length() - 1) {\n  exp = str.substring(expPos + 1, str.length() - 1);\n  } else {\n  exp = null;\n  }\n  \n  String numeric = str.substring(0, str.length() - 1);\n  boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n  switch (lastChar) {\n  case 'l' :\n  case 'L' :\n  if (dec == null\n  && exp == null\n  && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n  try {\n  return createLong(numeric);\n  } catch (NumberFormatException nfe) {\n  \n  }\n  return createBigInteger(numeric);\n\n  }\n  throw new NumberFormatException(str + \" is not a valid number.\");\n  case 'f' :\n  case 'F' :\n  try {\n  Float f = NumberUtils.createFloat(numeric);\n  if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n  \n  \n  return f;\n  }\n\n  } catch (NumberFormatException nfe) {\n  \n  }\n  \n  case 'd' :\n  case 'D' :\n  try {\n  Double d = NumberUtils.createDouble(numeric);\n  if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n  return d;\n  }\n  } catch (NumberFormatException nfe) {\n  \n  }\n  try {\n  return createBigDecimal(numeric);\n  } catch (NumberFormatException e) {\n  \n  }\n  \n  default :\n  throw new NumberFormatException(str + \" is not a valid number.\");\n\n  }\n  } else {\n  \n  \n  if (expPos > -1 && expPos < str.length() - 1) {\n  exp = str.substring(expPos + 1, str.length());\n  } else {\n  exp = null;\n  }\n  if (dec == null && exp == null) {\n  \n  try {\n  return createInteger(str);\n  } catch (NumberFormatException nfe) {\n  \n  }\n  try {\n  return createLong(str);\n  } catch (NumberFormatException nfe) {\n  \n  }\n  return createBigInteger(str);\n\n  } else {\n  \n  boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n  try {\n  Float f = createFloat(str);\n  if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n  return f;\n  }\n  } catch (NumberFormatException nfe) {\n  \n  }\n  try {\n  Double d = createDouble(str);\n  if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n  return d;\n  }\n  } catch (NumberFormatException nfe) {\n  \n  }\n\n  return createBigDecimal(str);\n\n  }\n  }\n  }",
          "diff": [
            "@@ -488,7 +488,7 @@",
            "             }\n",
            "             dec = null;\n",
            "         }\n",
            "-        if (!Character.isDigit(lastChar)) {\n",
            "+        if (!Character.isDigit(lastChar) && lastChar != '.') {\n",
            "             if (expPos > -1 && expPos < str.length() - 1) {\n",
            "                 exp = str.substring(expPos + 1, str.length() - 1);\n",
            "             } else {\n"
          ],
          "changed_lines": 2
        },
        {
          "buggy_method": "  public static boolean isNumber(String str) {\n  if (StringUtils.isEmpty(str)) {\n  return false;\n  }\n  char[] chars = str.toCharArray();\n  int sz = chars.length;\n  boolean hasExp = false;\n  boolean hasDecPoint = false;\n  boolean allowSigns = false;\n  boolean foundDigit = false;\n  \n  int start = (chars[0] == '-') ? 1 : 0;\n  if (sz > start + 1) {\n  if (chars[start] == '0' && chars[start + 1] == 'x') {\n  int i = start + 2;\n  if (i == sz) {\n  return false; \n  }\n  \n  for (; i < chars.length; i++) {\n  if ((chars[i] < '0' || chars[i] > '9')\n  && (chars[i] < 'a' || chars[i] > 'f')\n  && (chars[i] < 'A' || chars[i] > 'F')) {\n  return false;\n  }\n  }\n  return true;\n  }\n  }\n  sz--; \n  \n  int i = start;\n  \n  \n  while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) {\n  if (chars[i] >= '0' && chars[i] <= '9') {\n  foundDigit = true;\n  allowSigns = false;\n\n  } else if (chars[i] == '.') {\n  if (hasDecPoint || hasExp) {\n  \n  return false;\n  }\n  hasDecPoint = true;\n  } else if (chars[i] == 'e' || chars[i] == 'E') {\n  \n  if (hasExp) {\n  \n  return false;\n  }\n  if (!foundDigit) {\n  return false;\n  }\n  hasExp = true;\n  allowSigns = true;\n  } else if (chars[i] == '+' || chars[i] == '-') {\n  if (!allowSigns) {\n  return false;\n  }\n  allowSigns = false;\n  foundDigit = false; \n  } else {\n  return false;\n  }\n  i++;\n  }\n  if (i < chars.length) {\n  if (chars[i] >= '0' && chars[i] <= '9') {\n  \n  return true;\n  }\n  if (chars[i] == 'e' || chars[i] == 'E') {\n  \n  return false;\n  }\n  if (!allowSigns\n  && (chars[i] == 'd'\n  || chars[i] == 'D'\n  || chars[i] == 'f'\n  || chars[i] == 'F')) {\n  return foundDigit;\n  }\n  if (chars[i] == 'l'\n  || chars[i] == 'L') {\n  \n  return foundDigit && !hasExp;\n  }\n  \n  return false;\n  }\n  \n  \n  return !allowSigns && foundDigit;\n  }",
          "fixed_method": "  public static boolean isNumber(String str) {\n  if (StringUtils.isEmpty(str)) {\n  return false;\n  }\n  char[] chars = str.toCharArray();\n  int sz = chars.length;\n  boolean hasExp = false;\n  boolean hasDecPoint = false;\n  boolean allowSigns = false;\n  boolean foundDigit = false;\n  \n  int start = (chars[0] == '-') ? 1 : 0;\n  if (sz > start + 1) {\n  if (chars[start] == '0' && chars[start + 1] == 'x') {\n  int i = start + 2;\n  if (i == sz) {\n  return false; \n  }\n  \n  for (; i < chars.length; i++) {\n  if ((chars[i] < '0' || chars[i] > '9')\n  && (chars[i] < 'a' || chars[i] > 'f')\n  && (chars[i] < 'A' || chars[i] > 'F')) {\n  return false;\n  }\n  }\n  return true;\n  }\n  }\n  sz--; \n  \n  int i = start;\n  \n  \n  while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) {\n  if (chars[i] >= '0' && chars[i] <= '9') {\n  foundDigit = true;\n  allowSigns = false;\n\n  } else if (chars[i] == '.') {\n  if (hasDecPoint || hasExp) {\n  \n  return false;\n  }\n  hasDecPoint = true;\n  } else if (chars[i] == 'e' || chars[i] == 'E') {\n  \n  if (hasExp) {\n  \n  return false;\n  }\n  if (!foundDigit) {\n  return false;\n  }\n  hasExp = true;\n  allowSigns = true;\n  } else if (chars[i] == '+' || chars[i] == '-') {\n  if (!allowSigns) {\n  return false;\n  }\n  allowSigns = false;\n  foundDigit = false; \n  } else {\n  return false;\n  }\n  i++;\n  }\n  if (i < chars.length) {\n  if (chars[i] >= '0' && chars[i] <= '9') {\n  \n  return true;\n  }\n  if (chars[i] == 'e' || chars[i] == 'E') {\n  \n  return false;\n  }\n  if (chars[i] == '.') {\n  if (hasDecPoint || hasExp) {\n  \n  return false;\n  }\n  \n  return foundDigit;\n  }\n  if (!allowSigns\n  && (chars[i] == 'd'\n  || chars[i] == 'D'\n  || chars[i] == 'f'\n  || chars[i] == 'F')) {\n  return foundDigit;\n  }\n  if (chars[i] == 'l'\n  || chars[i] == 'L') {\n  \n  return foundDigit && !hasExp;\n  }\n  \n  return false;\n  }\n  \n  \n  return !allowSigns && foundDigit;\n  }",
          "diff": [
            "@@ -1385,6 +1385,14 @@",
            "                 // can't have an E at the last byte\n",
            "                 return false;\n",
            "             }\n",
            "+            if (chars[i] == '.') {\n",
            "+                if (hasDecPoint || hasExp) {\n",
            "+                    // two decimal points or dec in exponent\n",
            "+                    return false;\n",
            "+                }\n",
            "+                // single trailing decimal point after non-exponent is ok\n",
            "+                return foundDigit;\n",
            "+            }\n",
            "             if (!allowSigns\n",
            "                 && (chars[i] == 'd'\n",
            "                     || chars[i] == 'D'\n"
          ],
          "changed_lines": 8
        }
      ]
    }
  ]
}
