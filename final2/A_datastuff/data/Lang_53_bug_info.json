{
  "bug_id": "53",
  "failed_tests": {
    "org.apache.commons.lang.time.DateUtilsTest": [
      {
        "methodName": "testRoundLang346",
        "error": "junit.framework.AssertionFailedError",
        "message": "Minute Round Up Failed expected:<Mon Jul 02 08:09:00 PDT 2007> but was:<Mon Jul 02 08:01:00 PDT 2007>",
        "fail_line": "        assertEquals(\"Minute Round Up Failed\",",
        "test_source": "  public void testRoundLang346() throws Exception {\n  TimeZone.setDefault(defaultZone);\n  dateTimeParser.setTimeZone(defaultZone);\n  Calendar testCalendar = Calendar.getInstance();\n  testCalendar.set(2007, 6, 2, 8, 8, 50);\n  Date date = testCalendar.getTime();\n  assertEquals(\"Minute Round Up Failed\",\n  dateTimeParser.parse(\"July 2, 2007 08:09:00.000\"),\n  DateUtils.round(date, Calendar.MINUTE));\n\n  testCalendar.set(2007, 6, 2, 8, 8, 20);\n  date = testCalendar.getTime();\n  assertEquals(\"Minute No Round Failed\",\n  dateTimeParser.parse(\"July 2, 2007 08:08:00.000\"),\n  DateUtils.round(date, Calendar.MINUTE));\n\n  testCalendar.set(2007, 6, 2, 8, 8, 50);\n  testCalendar.set(Calendar.MILLISECOND, 600);\n  date = testCalendar.getTime();\n\n  assertEquals(\"Second Round Up with 600 Milli Seconds Failed\",\n  dateTimeParser.parse(\"July 2, 2007 08:08:51.000\"),\n  DateUtils.round(date, Calendar.SECOND));\n\n  testCalendar.set(2007, 6, 2, 8, 8, 50);\n  testCalendar.set(Calendar.MILLISECOND, 200);\n  date = testCalendar.getTime();\n  assertEquals(\"Second Round Down with 200 Milli Seconds Failed\",\n  dateTimeParser.parse(\"July 2, 2007 08:08:50.000\"),\n  DateUtils.round(date, Calendar.SECOND));\n\n  testCalendar.set(2007, 6, 2, 8, 8, 20);\n  testCalendar.set(Calendar.MILLISECOND, 600);\n  date = testCalendar.getTime();\n  assertEquals(\"Second Round Up with 200 Milli Seconds Failed\",\n  dateTimeParser.parse(\"July 2, 2007 08:08:21.000\"),\n  DateUtils.round(date, Calendar.SECOND));\n\n  testCalendar.set(2007, 6, 2, 8, 8, 20);\n  testCalendar.set(Calendar.MILLISECOND, 200);\n  date = testCalendar.getTime();\n  assertEquals(\"Second Round Down with 200 Milli Seconds Failed\",\n  dateTimeParser.parse(\"July 2, 2007 08:08:20.000\"),\n  DateUtils.round(date, Calendar.SECOND));\n\n  testCalendar.set(2007, 6, 2, 8, 8, 50);\n  date = testCalendar.getTime();\n  assertEquals(\"Hour Round Down Failed\",\n  dateTimeParser.parse(\"July 2, 2007 08:00:00.000\"),\n  DateUtils.round(date, Calendar.HOUR));\n\n  testCalendar.set(2007, 6, 2, 8, 31, 50);\n  date = testCalendar.getTime();\n  assertEquals(\"Hour Round Up Failed\",\n  dateTimeParser.parse(\"July 2, 2007 09:00:00.000\"),\n  DateUtils.round(date, Calendar.HOUR));\n  }",
        "stack": [
          "DateUtilsTest.testRoundLang346 line 710"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/lang/time/DateUtils.java",
      "buggy_full_code": "\npackage org.apache.commons.lang.time;\n\nimport java.text.ParseException;\nimport java.text.ParsePosition;\nimport java.text.SimpleDateFormat;\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\nimport java.util.TimeZone;\n\n\npublic class DateUtils { public static final TimeZone UTC_TIME_ZONE = TimeZone.getTimeZone(\"GMT\"); public static final long MILLIS_PER_SECOND = 1000; public static final long MILLIS_PER_MINUTE = 60 * MILLIS_PER_SECOND; public static final long MILLIS_PER_HOUR = 60 * MILLIS_PER_MINUTE; public static final long MILLIS_PER_DAY = 24 * MILLIS_PER_HOUR; public final static int SEMI_MONTH = 1001; private static final int[][] fields = {\n            {Calendar.MILLISECOND},\n            {Calendar.SECOND},\n            {Calendar.MINUTE},\n            {Calendar.HOUR_OF_DAY, Calendar.HOUR},\n            {Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM \n                \n            },\n            {Calendar.MONTH, DateUtils.SEMI_MONTH},\n            {Calendar.YEAR},\n            {Calendar.ERA}};\n\n    \n    public final static int RANGE_WEEK_SUNDAY = 1; public final static int RANGE_WEEK_MONDAY = 2; public final static int RANGE_WEEK_RELATIVE = 3; public final static int RANGE_WEEK_CENTER = 4; public final static int RANGE_MONTH_SUNDAY = 5; public final static int RANGE_MONTH_MONDAY = 6; public DateUtils() {\n        super();\n    }\n\n    \n    \n    public static boolean isSameDay(Date date1, Date date2) {\n        if (date1 == null || date2 == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        Calendar cal1 = Calendar.getInstance();\n        cal1.setTime(date1);\n        Calendar cal2 = Calendar.getInstance();\n        cal2.setTime(date2);\n        return isSameDay(cal1, cal2);\n    }\n\n    \n    public static boolean isSameDay(Calendar cal1, Calendar cal2) {\n        if (cal1 == null || cal2 == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        return (cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR));\n    }\n\n    \n    \n    public static boolean isSameInstant(Date date1, Date date2) {\n        if (date1 == null || date2 == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        return date1.getTime() == date2.getTime();\n    }\n\n    \n    public static boolean isSameInstant(Calendar cal1, Calendar cal2) {\n        if (cal1 == null || cal2 == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        return cal1.getTime().getTime() == cal2.getTime().getTime();\n    }\n\n    \n    \n    public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {\n        if (cal1 == null || cal2 == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());\n    }\n\n    \n    \n    public static Date parseDate(String str, String[] parsePatterns) throws ParseException {\n        if (str == null || parsePatterns == null) {\n            throw new IllegalArgumentException(\"Date and Patterns must not be null\");\n        }\n        \n        SimpleDateFormat parser = null;\n        ParsePosition pos = new ParsePosition(0);\n        for (int i = 0; i < parsePatterns.length; i++) {\n            if (i == 0) {\n                parser = new SimpleDateFormat(parsePatterns[0]);\n            } else {\n                parser.applyPattern(parsePatterns[i]);\n            }\n            pos.setIndex(0);\n            Date date = parser.parse(str, pos);\n            if (date != null && pos.getIndex() == str.length()) {\n                return date;\n            }\n        }\n        throw new ParseException(\"Unable to parse the date: \" + str, -1);\n    }\n\n    \n    \n    public static Date addYears(Date date, int amount) {\n        return add(date, Calendar.YEAR, amount);\n    }\n\n    \n    \n    public static Date addMonths(Date date, int amount) {\n        return add(date, Calendar.MONTH, amount);\n    }\n\n    \n    \n    public static Date addWeeks(Date date, int amount) {\n        return add(date, Calendar.WEEK_OF_YEAR, amount);\n    }\n\n    \n    \n    public static Date addDays(Date date, int amount) {\n        return add(date, Calendar.DAY_OF_MONTH, amount);\n    }\n\n    \n    \n    public static Date addHours(Date date, int amount) {\n        return add(date, Calendar.HOUR_OF_DAY, amount);\n    }\n\n    \n    \n    public static Date addMinutes(Date date, int amount) {\n        return add(date, Calendar.MINUTE, amount);\n    }\n\n    \n    \n    public static Date addSeconds(Date date, int amount) {\n        return add(date, Calendar.SECOND, amount);\n    }\n\n    \n    \n    public static Date addMilliseconds(Date date, int amount) {\n        return add(date, Calendar.MILLISECOND, amount);\n    }\n\n    \n    \n    public static Date add(Date date, int calendarField, int amount) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        Calendar c = Calendar.getInstance();\n        c.setTime(date);\n        c.add(calendarField, amount);\n        return c.getTime();\n    }\n\n    \n    \n    public static Date round(Date date, int field) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        Calendar gval = Calendar.getInstance();\n        gval.setTime(date);\n        modify(gval, field, true);\n        return gval.getTime();\n    }\n\n    \n    public static Calendar round(Calendar date, int field) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        Calendar rounded = (Calendar) date.clone();\n        modify(rounded, field, true);\n        return rounded;\n    }\n\n    \n    public static Date round(Object date, int field) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        if (date instanceof Date) {\n            return round((Date) date, field);\n        } else if (date instanceof Calendar) {\n            return round((Calendar) date, field).getTime();\n        } else {\n            throw new ClassCastException(\"Could not round \" + date);\n        }\n    }\n\n    \n    \n    public static Date truncate(Date date, int field) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        Calendar gval = Calendar.getInstance();\n        gval.setTime(date);\n        modify(gval, field, false);\n        return gval.getTime();\n    }\n\n    \n    public static Calendar truncate(Calendar date, int field) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        Calendar truncated = (Calendar) date.clone();\n        modify(truncated, field, false);\n        return truncated;\n    }\n\n    \n    public static Date truncate(Object date, int field) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        if (date instanceof Date) {\n            return truncate((Date) date, field);\n        } else if (date instanceof Calendar) {\n            return truncate((Calendar) date, field).getTime();\n        } else {\n            throw new ClassCastException(\"Could not truncate \" + date);\n        }\n    }\n\n    \n    \n    private static void modify(Calendar val, int field, boolean round) {\n        if (val.get(Calendar.YEAR) > 280000000) {\n            throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n        }\n        \n        if (field == Calendar.MILLISECOND) {\n            return;\n        }\n\n        \n        \n        \n        \n        \n\n        Date date = val.getTime();\n        long time = date.getTime();\n        boolean done = false;\n\n        \n        int millisecs = val.get(Calendar.MILLISECOND);\n        if (!round || millisecs < 500) {\n            time = time - millisecs;\n        if (field == Calendar.SECOND) {\n            done = true;\n            }\n        }\n\n        \n        int seconds = val.get(Calendar.SECOND);\n        if (!done && (!round || seconds < 30)) {\n            time = time - (seconds * 1000L);\n        if (field == Calendar.MINUTE) {\n            done = true;\n            }\n        }\n\n        \n        int minutes = val.get(Calendar.MINUTE);\n        if (!done && (!round || minutes < 30)) {\n            time = time - (minutes * 60000L);\n        }\n\n        \n        if (date.getTime() != time) {\n            date.setTime(time);\n            val.setTime(date);\n        }\n        \n\n        boolean roundUp = false;\n        for (int i = 0; i < fields.length; i++) {\n            for (int j = 0; j < fields[i].length; j++) {\n                if (fields[i][j] == field) {\n                    \n                    if (round && roundUp) {\n                        if (field == DateUtils.SEMI_MONTH) {\n                            \n                            \n                            \n                            if (val.get(Calendar.DATE) == 1) {\n                                val.add(Calendar.DATE, 15);\n                            } else {\n                                val.add(Calendar.DATE, -15);\n                                val.add(Calendar.MONTH, 1);\n                            }\n                        } else {\n                            \n                            \n                            val.add(fields[i][0], 1);\n                        }\n                    }\n                    return;\n                }\n            }\n            \n            int offset = 0;\n            boolean offsetSet = false;\n            \n            switch (field) {\n                case DateUtils.SEMI_MONTH:\n                    if (fields[i][0] == Calendar.DATE) {\n                        \n                        \n                        \n                        offset = val.get(Calendar.DATE) - 1;\n                        \n                        \n                        if (offset >= 15) {\n                            offset -= 15;\n                        }\n                        \n                        roundUp = offset > 7;\n                        offsetSet = true;\n                    }\n                    break;\n                case Calendar.AM_PM:\n                    if (fields[i][0] == Calendar.HOUR_OF_DAY) {\n                        \n                        \n                        offset = val.get(Calendar.HOUR_OF_DAY);\n                        if (offset >= 12) {\n                            offset -= 12;\n                        }\n                        roundUp = offset > 6;\n                        offsetSet = true;\n                    }\n                    break;\n            }\n            if (!offsetSet) {\n                int min = val.getActualMinimum(fields[i][0]);\n                int max = val.getActualMaximum(fields[i][0]);\n                \n                offset = val.get(fields[i][0]) - min;\n                \n                roundUp = offset > ((max - min) / 2);\n            }\n            \n            if (offset != 0) {\n                val.set(fields[i][0], val.get(fields[i][0]) - offset);\n            }\n        }\n        throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n\n    }\n\n    \n    \n    public static Iterator iterator(Date focus, int rangeStyle) {\n        if (focus == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        Calendar gval = Calendar.getInstance();\n        gval.setTime(focus);\n        return iterator(gval, rangeStyle);\n    }\n\n    \n    public static Iterator iterator(Calendar focus, int rangeStyle) {\n        if (focus == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        Calendar start = null;\n        Calendar end = null;\n        int startCutoff = Calendar.SUNDAY;\n        int endCutoff = Calendar.SATURDAY;\n        switch (rangeStyle) {\n            case RANGE_MONTH_SUNDAY:\n            case RANGE_MONTH_MONDAY:\n                \n                start = truncate(focus, Calendar.MONTH);\n                \n                end = (Calendar) start.clone();\n                end.add(Calendar.MONTH, 1);\n                end.add(Calendar.DATE, -1);\n                \n                if (rangeStyle == RANGE_MONTH_MONDAY) {\n                    startCutoff = Calendar.MONDAY;\n                    endCutoff = Calendar.SUNDAY;\n                }\n                break;\n            case RANGE_WEEK_SUNDAY:\n            case RANGE_WEEK_MONDAY:\n            case RANGE_WEEK_RELATIVE:\n            case RANGE_WEEK_CENTER:\n                \n                start = truncate(focus, Calendar.DATE);\n                end = truncate(focus, Calendar.DATE);\n                switch (rangeStyle) {\n                    case RANGE_WEEK_SUNDAY:\n                        \n                        break;\n                    case RANGE_WEEK_MONDAY:\n                        startCutoff = Calendar.MONDAY;\n                        endCutoff = Calendar.SUNDAY;\n                        break;\n                    case RANGE_WEEK_RELATIVE:\n                        startCutoff = focus.get(Calendar.DAY_OF_WEEK);\n                        endCutoff = startCutoff - 1;\n                        break;\n                    case RANGE_WEEK_CENTER:\n                        startCutoff = focus.get(Calendar.DAY_OF_WEEK) - 3;\n                        endCutoff = focus.get(Calendar.DAY_OF_WEEK) + 3;\n                        break;\n                }\n                break;\n            default:\n                throw new IllegalArgumentException(\"The range style \" + rangeStyle + \" is not valid.\");\n        }\n        if (startCutoff < Calendar.SUNDAY) {\n            startCutoff += 7;\n        }\n        if (startCutoff > Calendar.SATURDAY) {\n            startCutoff -= 7;\n        }\n        if (endCutoff < Calendar.SUNDAY) {\n            endCutoff += 7;\n        }\n        if (endCutoff > Calendar.SATURDAY) {\n            endCutoff -= 7;\n        }\n        while (start.get(Calendar.DAY_OF_WEEK) != startCutoff) {\n            start.add(Calendar.DATE, -1);\n        }\n        while (end.get(Calendar.DAY_OF_WEEK) != endCutoff) {\n            end.add(Calendar.DATE, 1);\n        }\n        return new DateIterator(start, end);\n    }\n\n    \n    public static Iterator iterator(Object focus, int rangeStyle) {\n        if (focus == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        if (focus instanceof Date) {\n            return iterator((Date) focus, rangeStyle);\n        } else if (focus instanceof Calendar) {\n            return iterator((Calendar) focus, rangeStyle);\n        } else {\n            throw new ClassCastException(\"Could not iterate based on \" + focus);\n        }\n    }\n\n    \n    static class DateIterator implements Iterator { private final Calendar endFinal; private final Calendar spot; DateIterator(Calendar startFinal, Calendar endFinal) {\n            super();\n            this.endFinal = endFinal;\n            spot = startFinal;\n            spot.add(Calendar.DATE, -1);\n        }\n\n        \n        public boolean hasNext() {\n            return spot.before(endFinal);\n        }\n\n        \n        public Object next() {\n            if (spot.equals(endFinal)) {\n                throw new NoSuchElementException();\n            }\n            spot.add(Calendar.DATE, 1);\n            return spot.clone();\n        }\n\n        \n        public void remove() {\n            throw new UnsupportedOperationException();\n        }\n    }\n    \n    \n    \n    \n    \n    \n    public static final int MILLIS_IN_SECOND = 1000;\n    \n    public static final int MILLIS_IN_MINUTE = 60 * 1000;\n    \n    public static final int MILLIS_IN_HOUR = 60 * 60 * 1000;\n    \n    public static final int MILLIS_IN_DAY = 24 * 60 * 60 * 1000;\n    \n}\n",
      "fixed_full_code": "\npackage org.apache.commons.lang.time;\n\nimport java.text.ParseException;\nimport java.text.ParsePosition;\nimport java.text.SimpleDateFormat;\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\nimport java.util.TimeZone;\n\n\npublic class DateUtils { public static final TimeZone UTC_TIME_ZONE = TimeZone.getTimeZone(\"GMT\"); public static final long MILLIS_PER_SECOND = 1000; public static final long MILLIS_PER_MINUTE = 60 * MILLIS_PER_SECOND; public static final long MILLIS_PER_HOUR = 60 * MILLIS_PER_MINUTE; public static final long MILLIS_PER_DAY = 24 * MILLIS_PER_HOUR; public final static int SEMI_MONTH = 1001; private static final int[][] fields = {\n            {Calendar.MILLISECOND},\n            {Calendar.SECOND},\n            {Calendar.MINUTE},\n            {Calendar.HOUR_OF_DAY, Calendar.HOUR},\n            {Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM \n                \n            },\n            {Calendar.MONTH, DateUtils.SEMI_MONTH},\n            {Calendar.YEAR},\n            {Calendar.ERA}};\n\n    \n    public final static int RANGE_WEEK_SUNDAY = 1; public final static int RANGE_WEEK_MONDAY = 2; public final static int RANGE_WEEK_RELATIVE = 3; public final static int RANGE_WEEK_CENTER = 4; public final static int RANGE_MONTH_SUNDAY = 5; public final static int RANGE_MONTH_MONDAY = 6; public DateUtils() {\n        super();\n    }\n\n    \n    \n    public static boolean isSameDay(Date date1, Date date2) {\n        if (date1 == null || date2 == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        Calendar cal1 = Calendar.getInstance();\n        cal1.setTime(date1);\n        Calendar cal2 = Calendar.getInstance();\n        cal2.setTime(date2);\n        return isSameDay(cal1, cal2);\n    }\n\n    \n    public static boolean isSameDay(Calendar cal1, Calendar cal2) {\n        if (cal1 == null || cal2 == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        return (cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR));\n    }\n\n    \n    \n    public static boolean isSameInstant(Date date1, Date date2) {\n        if (date1 == null || date2 == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        return date1.getTime() == date2.getTime();\n    }\n\n    \n    public static boolean isSameInstant(Calendar cal1, Calendar cal2) {\n        if (cal1 == null || cal2 == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        return cal1.getTime().getTime() == cal2.getTime().getTime();\n    }\n\n    \n    \n    public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {\n        if (cal1 == null || cal2 == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());\n    }\n\n    \n    \n    public static Date parseDate(String str, String[] parsePatterns) throws ParseException {\n        if (str == null || parsePatterns == null) {\n            throw new IllegalArgumentException(\"Date and Patterns must not be null\");\n        }\n        \n        SimpleDateFormat parser = null;\n        ParsePosition pos = new ParsePosition(0);\n        for (int i = 0; i < parsePatterns.length; i++) {\n            if (i == 0) {\n                parser = new SimpleDateFormat(parsePatterns[0]);\n            } else {\n                parser.applyPattern(parsePatterns[i]);\n            }\n            pos.setIndex(0);\n            Date date = parser.parse(str, pos);\n            if (date != null && pos.getIndex() == str.length()) {\n                return date;\n            }\n        }\n        throw new ParseException(\"Unable to parse the date: \" + str, -1);\n    }\n\n    \n    \n    public static Date addYears(Date date, int amount) {\n        return add(date, Calendar.YEAR, amount);\n    }\n\n    \n    \n    public static Date addMonths(Date date, int amount) {\n        return add(date, Calendar.MONTH, amount);\n    }\n\n    \n    \n    public static Date addWeeks(Date date, int amount) {\n        return add(date, Calendar.WEEK_OF_YEAR, amount);\n    }\n\n    \n    \n    public static Date addDays(Date date, int amount) {\n        return add(date, Calendar.DAY_OF_MONTH, amount);\n    }\n\n    \n    \n    public static Date addHours(Date date, int amount) {\n        return add(date, Calendar.HOUR_OF_DAY, amount);\n    }\n\n    \n    \n    public static Date addMinutes(Date date, int amount) {\n        return add(date, Calendar.MINUTE, amount);\n    }\n\n    \n    \n    public static Date addSeconds(Date date, int amount) {\n        return add(date, Calendar.SECOND, amount);\n    }\n\n    \n    \n    public static Date addMilliseconds(Date date, int amount) {\n        return add(date, Calendar.MILLISECOND, amount);\n    }\n\n    \n    \n    public static Date add(Date date, int calendarField, int amount) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        Calendar c = Calendar.getInstance();\n        c.setTime(date);\n        c.add(calendarField, amount);\n        return c.getTime();\n    }\n\n    \n    \n    public static Date round(Date date, int field) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        Calendar gval = Calendar.getInstance();\n        gval.setTime(date);\n        modify(gval, field, true);\n        return gval.getTime();\n    }\n\n    \n    public static Calendar round(Calendar date, int field) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        Calendar rounded = (Calendar) date.clone();\n        modify(rounded, field, true);\n        return rounded;\n    }\n\n    \n    public static Date round(Object date, int field) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        if (date instanceof Date) {\n            return round((Date) date, field);\n        } else if (date instanceof Calendar) {\n            return round((Calendar) date, field).getTime();\n        } else {\n            throw new ClassCastException(\"Could not round \" + date);\n        }\n    }\n\n    \n    \n    public static Date truncate(Date date, int field) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        Calendar gval = Calendar.getInstance();\n        gval.setTime(date);\n        modify(gval, field, false);\n        return gval.getTime();\n    }\n\n    \n    public static Calendar truncate(Calendar date, int field) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        Calendar truncated = (Calendar) date.clone();\n        modify(truncated, field, false);\n        return truncated;\n    }\n\n    \n    public static Date truncate(Object date, int field) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        if (date instanceof Date) {\n            return truncate((Date) date, field);\n        } else if (date instanceof Calendar) {\n            return truncate((Calendar) date, field).getTime();\n        } else {\n            throw new ClassCastException(\"Could not truncate \" + date);\n        }\n    }\n\n    \n    \n    private static void modify(Calendar val, int field, boolean round) {\n        if (val.get(Calendar.YEAR) > 280000000) {\n            throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n        }\n        \n        if (field == Calendar.MILLISECOND) {\n            return;\n        }\n\n        \n        \n        \n        \n        \n\n        Date date = val.getTime();\n        long time = date.getTime();\n        boolean done = false;\n\n        \n        int millisecs = val.get(Calendar.MILLISECOND);\n        if (!round || millisecs < 500) {\n            time = time - millisecs;\n        }\n        if (field == Calendar.SECOND) {\n            done = true;\n        }\n\n        \n        int seconds = val.get(Calendar.SECOND);\n        if (!done && (!round || seconds < 30)) {\n            time = time - (seconds * 1000L);\n        }\n        if (field == Calendar.MINUTE) {\n            done = true;\n        }\n\n        \n        int minutes = val.get(Calendar.MINUTE);\n        if (!done && (!round || minutes < 30)) {\n            time = time - (minutes * 60000L);\n        }\n\n        \n        if (date.getTime() != time) {\n            date.setTime(time);\n            val.setTime(date);\n        }\n        \n\n        boolean roundUp = false;\n        for (int i = 0; i < fields.length; i++) {\n            for (int j = 0; j < fields[i].length; j++) {\n                if (fields[i][j] == field) {\n                    \n                    if (round && roundUp) {\n                        if (field == DateUtils.SEMI_MONTH) {\n                            \n                            \n                            \n                            if (val.get(Calendar.DATE) == 1) {\n                                val.add(Calendar.DATE, 15);\n                            } else {\n                                val.add(Calendar.DATE, -15);\n                                val.add(Calendar.MONTH, 1);\n                            }\n                        } else {\n                            \n                            \n                            val.add(fields[i][0], 1);\n                        }\n                    }\n                    return;\n                }\n            }\n            \n            int offset = 0;\n            boolean offsetSet = false;\n            \n            switch (field) {\n                case DateUtils.SEMI_MONTH:\n                    if (fields[i][0] == Calendar.DATE) {\n                        \n                        \n                        \n                        offset = val.get(Calendar.DATE) - 1;\n                        \n                        \n                        if (offset >= 15) {\n                            offset -= 15;\n                        }\n                        \n                        roundUp = offset > 7;\n                        offsetSet = true;\n                    }\n                    break;\n                case Calendar.AM_PM:\n                    if (fields[i][0] == Calendar.HOUR_OF_DAY) {\n                        \n                        \n                        offset = val.get(Calendar.HOUR_OF_DAY);\n                        if (offset >= 12) {\n                            offset -= 12;\n                        }\n                        roundUp = offset > 6;\n                        offsetSet = true;\n                    }\n                    break;\n            }\n            if (!offsetSet) {\n                int min = val.getActualMinimum(fields[i][0]);\n                int max = val.getActualMaximum(fields[i][0]);\n                \n                offset = val.get(fields[i][0]) - min;\n                \n                roundUp = offset > ((max - min) / 2);\n            }\n            \n            if (offset != 0) {\n                val.set(fields[i][0], val.get(fields[i][0]) - offset);\n            }\n        }\n        throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n\n    }\n\n    \n    \n    public static Iterator iterator(Date focus, int rangeStyle) {\n        if (focus == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        Calendar gval = Calendar.getInstance();\n        gval.setTime(focus);\n        return iterator(gval, rangeStyle);\n    }\n\n    \n    public static Iterator iterator(Calendar focus, int rangeStyle) {\n        if (focus == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        Calendar start = null;\n        Calendar end = null;\n        int startCutoff = Calendar.SUNDAY;\n        int endCutoff = Calendar.SATURDAY;\n        switch (rangeStyle) {\n            case RANGE_MONTH_SUNDAY:\n            case RANGE_MONTH_MONDAY:\n                \n                start = truncate(focus, Calendar.MONTH);\n                \n                end = (Calendar) start.clone();\n                end.add(Calendar.MONTH, 1);\n                end.add(Calendar.DATE, -1);\n                \n                if (rangeStyle == RANGE_MONTH_MONDAY) {\n                    startCutoff = Calendar.MONDAY;\n                    endCutoff = Calendar.SUNDAY;\n                }\n                break;\n            case RANGE_WEEK_SUNDAY:\n            case RANGE_WEEK_MONDAY:\n            case RANGE_WEEK_RELATIVE:\n            case RANGE_WEEK_CENTER:\n                \n                start = truncate(focus, Calendar.DATE);\n                end = truncate(focus, Calendar.DATE);\n                switch (rangeStyle) {\n                    case RANGE_WEEK_SUNDAY:\n                        \n                        break;\n                    case RANGE_WEEK_MONDAY:\n                        startCutoff = Calendar.MONDAY;\n                        endCutoff = Calendar.SUNDAY;\n                        break;\n                    case RANGE_WEEK_RELATIVE:\n                        startCutoff = focus.get(Calendar.DAY_OF_WEEK);\n                        endCutoff = startCutoff - 1;\n                        break;\n                    case RANGE_WEEK_CENTER:\n                        startCutoff = focus.get(Calendar.DAY_OF_WEEK) - 3;\n                        endCutoff = focus.get(Calendar.DAY_OF_WEEK) + 3;\n                        break;\n                }\n                break;\n            default:\n                throw new IllegalArgumentException(\"The range style \" + rangeStyle + \" is not valid.\");\n        }\n        if (startCutoff < Calendar.SUNDAY) {\n            startCutoff += 7;\n        }\n        if (startCutoff > Calendar.SATURDAY) {\n            startCutoff -= 7;\n        }\n        if (endCutoff < Calendar.SUNDAY) {\n            endCutoff += 7;\n        }\n        if (endCutoff > Calendar.SATURDAY) {\n            endCutoff -= 7;\n        }\n        while (start.get(Calendar.DAY_OF_WEEK) != startCutoff) {\n            start.add(Calendar.DATE, -1);\n        }\n        while (end.get(Calendar.DAY_OF_WEEK) != endCutoff) {\n            end.add(Calendar.DATE, 1);\n        }\n        return new DateIterator(start, end);\n    }\n\n    \n    public static Iterator iterator(Object focus, int rangeStyle) {\n        if (focus == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        if (focus instanceof Date) {\n            return iterator((Date) focus, rangeStyle);\n        } else if (focus instanceof Calendar) {\n            return iterator((Calendar) focus, rangeStyle);\n        } else {\n            throw new ClassCastException(\"Could not iterate based on \" + focus);\n        }\n    }\n\n    \n    static class DateIterator implements Iterator { private final Calendar endFinal; private final Calendar spot; DateIterator(Calendar startFinal, Calendar endFinal) {\n            super();\n            this.endFinal = endFinal;\n            spot = startFinal;\n            spot.add(Calendar.DATE, -1);\n        }\n\n        \n        public boolean hasNext() {\n            return spot.before(endFinal);\n        }\n\n        \n        public Object next() {\n            if (spot.equals(endFinal)) {\n                throw new NoSuchElementException();\n            }\n            spot.add(Calendar.DATE, 1);\n            return spot.clone();\n        }\n\n        \n        public void remove() {\n            throw new UnsupportedOperationException();\n        }\n    }\n    \n    \n    \n    \n    \n    \n    public static final int MILLIS_IN_SECOND = 1000;\n    \n    public static final int MILLIS_IN_MINUTE = 60 * 1000;\n    \n    public static final int MILLIS_IN_HOUR = 60 * 60 * 1000;\n    \n    public static final int MILLIS_IN_DAY = 24 * 60 * 60 * 1000;\n    \n}\n",
      "buggy_signatures": [
        "public static boolean isSameDay(Date date1, Date date2)",
        "public static boolean isSameDay(Calendar cal1, Calendar cal2)",
        "public static boolean isSameInstant(Date date1, Date date2)",
        "public static boolean isSameInstant(Calendar cal1, Calendar cal2)",
        "public static boolean isSameLocalTime(Calendar cal1, Calendar cal2)",
        "public static Date parseDate(String str, String[] parsePatterns) throws ParseException",
        "public static Date addYears(Date date, int amount)",
        "public static Date addMonths(Date date, int amount)",
        "public static Date addWeeks(Date date, int amount)",
        "public static Date addDays(Date date, int amount)",
        "public static Date addHours(Date date, int amount)",
        "public static Date addMinutes(Date date, int amount)",
        "public static Date addSeconds(Date date, int amount)",
        "public static Date addMilliseconds(Date date, int amount)",
        "public static Date add(Date date, int calendarField, int amount)",
        "public static Date round(Date date, int field)",
        "public static Calendar round(Calendar date, int field)",
        "public static Date round(Object date, int field)",
        "public static Date truncate(Date date, int field)",
        "public static Calendar truncate(Calendar date, int field)",
        "public static Date truncate(Object date, int field)",
        "private static void modify(Calendar val, int field, boolean round)",
        "public static Iterator iterator(Date focus, int rangeStyle)",
        "public static Iterator iterator(Calendar focus, int rangeStyle)",
        "public static Iterator iterator(Object focus, int rangeStyle)",
        "static class DateIterator implements Iterator { private final Calendar endFinal; private final Calendar spot; DateIterator(Calendar startFinal, Calendar endFinal)",
        "public boolean hasNext()",
        "public Object next()",
        "public void remove()"
      ],
      "fixed_signatures": [
        "public static boolean isSameDay(Date date1, Date date2)",
        "public static boolean isSameDay(Calendar cal1, Calendar cal2)",
        "public static boolean isSameInstant(Date date1, Date date2)",
        "public static boolean isSameInstant(Calendar cal1, Calendar cal2)",
        "public static boolean isSameLocalTime(Calendar cal1, Calendar cal2)",
        "public static Date parseDate(String str, String[] parsePatterns) throws ParseException",
        "public static Date addYears(Date date, int amount)",
        "public static Date addMonths(Date date, int amount)",
        "public static Date addWeeks(Date date, int amount)",
        "public static Date addDays(Date date, int amount)",
        "public static Date addHours(Date date, int amount)",
        "public static Date addMinutes(Date date, int amount)",
        "public static Date addSeconds(Date date, int amount)",
        "public static Date addMilliseconds(Date date, int amount)",
        "public static Date add(Date date, int calendarField, int amount)",
        "public static Date round(Date date, int field)",
        "public static Calendar round(Calendar date, int field)",
        "public static Date round(Object date, int field)",
        "public static Date truncate(Date date, int field)",
        "public static Calendar truncate(Calendar date, int field)",
        "public static Date truncate(Object date, int field)",
        "private static void modify(Calendar val, int field, boolean round)",
        "public static Iterator iterator(Date focus, int rangeStyle)",
        "public static Iterator iterator(Calendar focus, int rangeStyle)",
        "public static Iterator iterator(Object focus, int rangeStyle)",
        "static class DateIterator implements Iterator { private final Calendar endFinal; private final Calendar spot; DateIterator(Calendar startFinal, Calendar endFinal)",
        "public boolean hasNext()",
        "public Object next()",
        "public void remove()"
      ],
      "methods": [
        {
          "buggy_method": "  private static void modify(Calendar val, int field, boolean round) {\n  if (val.get(Calendar.YEAR) > 280000000) {\n  throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n  }\n  \n  if (field == Calendar.MILLISECOND) {\n  return;\n  }\n\n  \n  \n  \n  \n  \n\n  Date date = val.getTime();\n  long time = date.getTime();\n  boolean done = false;\n\n  \n  int millisecs = val.get(Calendar.MILLISECOND);\n  if (!round || millisecs < 500) {\n  time = time - millisecs;\n  if (field == Calendar.SECOND) {\n  done = true;\n  }\n  }\n\n  \n  int seconds = val.get(Calendar.SECOND);\n  if (!done && (!round || seconds < 30)) {\n  time = time - (seconds * 1000L);\n  if (field == Calendar.MINUTE) {\n  done = true;\n  }\n  }\n\n  \n  int minutes = val.get(Calendar.MINUTE);\n  if (!done && (!round || minutes < 30)) {\n  time = time - (minutes * 60000L);\n  }\n\n  \n  if (date.getTime() != time) {\n  date.setTime(time);\n  val.setTime(date);\n  }\n  \n\n  boolean roundUp = false;\n  for (int i = 0; i < fields.length; i++) {\n  for (int j = 0; j < fields[i].length; j++) {\n  if (fields[i][j] == field) {\n  \n  if (round && roundUp) {\n  if (field == DateUtils.SEMI_MONTH) {\n  \n  \n  \n  if (val.get(Calendar.DATE) == 1) {\n  val.add(Calendar.DATE, 15);\n  } else {\n  val.add(Calendar.DATE, -15);\n  val.add(Calendar.MONTH, 1);\n  }\n  } else {\n  \n  \n  val.add(fields[i][0], 1);\n  }\n  }\n  return;\n  }\n  }\n  \n  int offset = 0;\n  boolean offsetSet = false;\n  \n  switch (field) {\n  case DateUtils.SEMI_MONTH:\n  if (fields[i][0] == Calendar.DATE) {\n  \n  \n  \n  offset = val.get(Calendar.DATE) - 1;\n  \n  \n  if (offset >= 15) {\n  offset -= 15;\n  }\n  \n  roundUp = offset > 7;\n  offsetSet = true;\n  }\n  break;\n  case Calendar.AM_PM:\n  if (fields[i][0] == Calendar.HOUR_OF_DAY) {\n  \n  \n  offset = val.get(Calendar.HOUR_OF_DAY);\n  if (offset >= 12) {\n  offset -= 12;\n  }\n  roundUp = offset > 6;\n  offsetSet = true;\n  }\n  break;\n  }\n  if (!offsetSet) {\n  int min = val.getActualMinimum(fields[i][0]);\n  int max = val.getActualMaximum(fields[i][0]);\n  \n  offset = val.get(fields[i][0]) - min;\n  \n  roundUp = offset > ((max - min) / 2);\n  }\n  \n  if (offset != 0) {\n  val.set(fields[i][0], val.get(fields[i][0]) - offset);\n  }\n  }\n  throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n\n  }",
          "fixed_method": "  private static void modify(Calendar val, int field, boolean round) {\n  if (val.get(Calendar.YEAR) > 280000000) {\n  throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n  }\n  \n  if (field == Calendar.MILLISECOND) {\n  return;\n  }\n\n  \n  \n  \n  \n  \n\n  Date date = val.getTime();\n  long time = date.getTime();\n  boolean done = false;\n\n  \n  int millisecs = val.get(Calendar.MILLISECOND);\n  if (!round || millisecs < 500) {\n  time = time - millisecs;\n  }\n  if (field == Calendar.SECOND) {\n  done = true;\n  }\n\n  \n  int seconds = val.get(Calendar.SECOND);\n  if (!done && (!round || seconds < 30)) {\n  time = time - (seconds * 1000L);\n  }\n  if (field == Calendar.MINUTE) {\n  done = true;\n  }\n\n  \n  int minutes = val.get(Calendar.MINUTE);\n  if (!done && (!round || minutes < 30)) {\n  time = time - (minutes * 60000L);\n  }\n\n  \n  if (date.getTime() != time) {\n  date.setTime(time);\n  val.setTime(date);\n  }\n  \n\n  boolean roundUp = false;\n  for (int i = 0; i < fields.length; i++) {\n  for (int j = 0; j < fields[i].length; j++) {\n  if (fields[i][j] == field) {\n  \n  if (round && roundUp) {\n  if (field == DateUtils.SEMI_MONTH) {\n  \n  \n  \n  if (val.get(Calendar.DATE) == 1) {\n  val.add(Calendar.DATE, 15);\n  } else {\n  val.add(Calendar.DATE, -15);\n  val.add(Calendar.MONTH, 1);\n  }\n  } else {\n  \n  \n  val.add(fields[i][0], 1);\n  }\n  }\n  return;\n  }\n  }\n  \n  int offset = 0;\n  boolean offsetSet = false;\n  \n  switch (field) {\n  case DateUtils.SEMI_MONTH:\n  if (fields[i][0] == Calendar.DATE) {\n  \n  \n  \n  offset = val.get(Calendar.DATE) - 1;\n  \n  \n  if (offset >= 15) {\n  offset -= 15;\n  }\n  \n  roundUp = offset > 7;\n  offsetSet = true;\n  }\n  break;\n  case Calendar.AM_PM:\n  if (fields[i][0] == Calendar.HOUR_OF_DAY) {\n  \n  \n  offset = val.get(Calendar.HOUR_OF_DAY);\n  if (offset >= 12) {\n  offset -= 12;\n  }\n  roundUp = offset > 6;\n  offsetSet = true;\n  }\n  break;\n  }\n  if (!offsetSet) {\n  int min = val.getActualMinimum(fields[i][0]);\n  int max = val.getActualMaximum(fields[i][0]);\n  \n  offset = val.get(fields[i][0]) - min;\n  \n  roundUp = offset > ((max - min) / 2);\n  }\n  \n  if (offset != 0) {\n  val.set(fields[i][0], val.get(fields[i][0]) - offset);\n  }\n  }\n  throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n\n  }",
          "diff": [
            "@@ -640,18 +640,18 @@",
            "         int millisecs = val.get(Calendar.MILLISECOND);\n",
            "         if (!round || millisecs < 500) {\n",
            "             time = time - millisecs;\n",
            "+        }\n",
            "         if (field == Calendar.SECOND) {\n",
            "             done = true;\n",
            "-            }\n",
            "         }\n",
            " \n",
            "         // truncate seconds\n",
            "         int seconds = val.get(Calendar.SECOND);\n",
            "         if (!done && (!round || seconds < 30)) {\n",
            "             time = time - (seconds * 1000L);\n",
            "+        }\n",
            "         if (field == Calendar.MINUTE) {\n",
            "             done = true;\n",
            "-            }\n",
            "         }\n",
            " \n",
            "         // truncate minutes\n"
          ],
          "changed_lines": 4
        }
      ]
    }
  ]
}
