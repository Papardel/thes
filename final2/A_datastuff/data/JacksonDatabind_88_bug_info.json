{
  "bug_id": "88",
  "failed_tests": {
    "com.fasterxml.jackson.databind.jsontype.GenericTypeId1735Test": [
      {
        "methodName": "testNestedTypeCheck1735",
        "error": "junit.framework.AssertionFailedError",
        "message": "Expected an exception with one of substrings ([not subtype of]): got one (of type com.fasterxml.jackson.databind.JsonMappingException) with message \"Problem deserializing property 'w' (expected type: [simple type, class com.fasterxml.jackson.databind.jsontype.GenericTypeId1735Test$Payload1735]; actual type: java.util.HashMap), problem: Can not set com.fasterxml.jackson.databind.jsontype.GenericTypeId1735Test$Payload1735 field com.fasterxml.jackson.databind.jsontype.GenericTypeId1735Test$Wrapper1735.w to java.util.HashMap",
        "fail_line": "            verifyException(e, \"not subtype of\");",
        "test_source": "  public void testNestedTypeCheck1735() throws Exception {\n  try {\n  MAPPER.readValue(aposToQuotes(\n\"{'w':{'type':'java.util.HashMap<java.lang.String,java.lang.String>'}}\"),\n  Wrapper1735.class);\n  fail(\"Should not pass\");\n  } catch (JsonMappingException e) {\n  verifyException(e, \"not subtype of\");\n  }\n  }",
        "stack": [
          "BaseTest.verifyException line 367, GenericTypeId1735Test.testNestedTypeCheck1735 line 61"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "com/fasterxml/jackson/databind/jsontype/impl/ClassNameIdResolver.java",
      "buggy_full_code": "package com.fasterxml.jackson.databind.jsontype.impl;\n\nimport java.io.IOException;\nimport java.util.*;\n\nimport com.fasterxml.jackson.annotation.JsonTypeInfo;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.type.TypeFactory;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\n\n\npublic class ClassNameIdResolver extends TypeIdResolverBase { public ClassNameIdResolver(JavaType baseType, TypeFactory typeFactory) {\n        super(baseType, typeFactory);\n    }\n\n    @Override\n    public JsonTypeInfo.Id getMechanism() { return JsonTypeInfo.Id.CLASS; }\n\n    public void registerSubtype(Class<?> type, String name) {\n        \n    }\n    \n    @Override\n    public String idFromValue(Object value) {\n        return _idFrom(value, value.getClass(), _typeFactory);\n    }\n\n    @Override\n    public String idFromValueAndType(Object value, Class<?> type) {\n        return _idFrom(value, type, _typeFactory);\n    }\n\n    @Override\n    public JavaType typeFromId(DatabindContext context, String id) throws IOException {\n        return _typeFromId(id, context);\n    }\n\n    protected JavaType _typeFromId(String id, DatabindContext ctxt) throws IOException {\n        \n        TypeFactory tf = ctxt.getTypeFactory();\n        if (id.indexOf('<') > 0) {\n            \n            \n            \n            \n            JavaType t = tf.constructFromCanonical(id);\n                \n            return t;\n        }\n        Class<?> cls;\n        try {\n            cls =  tf.findClass(id);\n        } catch (ClassNotFoundException e) {\n            \n            \n            if (ctxt instanceof DeserializationContext) {\n                DeserializationContext dctxt = (DeserializationContext) ctxt;\n                \n                return dctxt.handleUnknownTypeId(_baseType, id, this, \"no such class found\");\n            }\n            \n            return null;\n        } catch (Exception e) {\n            throw new IllegalArgumentException(\"Invalid type id '\"+id+\"' (for id type 'Id.class'): \"+e.getMessage(), e);\n        }\n        return tf.constructSpecializedType(_baseType, cls);\n    }\n    \n    \n    \n    protected final String _idFrom(Object value, Class<?> cls, TypeFactory typeFactory) {\n        \n        if (Enum.class.isAssignableFrom(cls)) {\n            if (!cls.isEnum()) { \n                cls = cls.getSuperclass();\n            }\n        }\n        String str = cls.getName();\n        if (str.startsWith(\"java.util\")) {\n            \n            \n\n            \n            \n            \n            if (value instanceof EnumSet<?>) { \n                Class<?> enumClass = ClassUtil.findEnumType((EnumSet<?>) value);\n                \n               str = typeFactory.constructCollectionType(EnumSet.class, enumClass).toCanonical();\n            } else if (value instanceof EnumMap<?,?>) {\n                Class<?> enumClass = ClassUtil.findEnumType((EnumMap<?,?>) value);\n                Class<?> valueClass = Object.class;\n                \n                str = typeFactory.constructMapType(EnumMap.class, enumClass, valueClass).toCanonical();\n            } else {\n                String end = str.substring(9);\n                if ((end.startsWith(\".Arrays$\") || end.startsWith(\".Collections$\"))\n                       && str.indexOf(\"List\") >= 0) {\n                    \n                    str = \"java.util.ArrayList\";\n                }\n            }\n        } else if (str.indexOf('$') >= 0) {\n            \n            Class<?> outer = ClassUtil.getOuterClass(cls);\n            if (outer != null) {\n                \n                Class<?> staticType = _baseType.getRawClass();\n                if (ClassUtil.getOuterClass(staticType) == null) {\n                    \n                    cls = _baseType.getRawClass();\n                    str = cls.getName();\n                }\n            }\n        }\n        return str;\n    }\n\n    @Override\n    public String getDescForKnownTypeIds() {\n        return \"class name used as type id\";\n    }\n}\n",
      "fixed_full_code": "package com.fasterxml.jackson.databind.jsontype.impl;\n\nimport java.io.IOException;\nimport java.util.*;\n\nimport com.fasterxml.jackson.annotation.JsonTypeInfo;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.type.TypeFactory;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\n\n\npublic class ClassNameIdResolver extends TypeIdResolverBase { public ClassNameIdResolver(JavaType baseType, TypeFactory typeFactory) {\n        super(baseType, typeFactory);\n    }\n\n    @Override\n    public JsonTypeInfo.Id getMechanism() { return JsonTypeInfo.Id.CLASS; }\n\n    public void registerSubtype(Class<?> type, String name) {\n        \n    }\n    \n    @Override\n    public String idFromValue(Object value) {\n        return _idFrom(value, value.getClass(), _typeFactory);\n    }\n\n    @Override\n    public String idFromValueAndType(Object value, Class<?> type) {\n        return _idFrom(value, type, _typeFactory);\n    }\n\n    @Override\n    public JavaType typeFromId(DatabindContext context, String id) throws IOException {\n        return _typeFromId(id, context);\n    }\n\n    protected JavaType _typeFromId(String id, DatabindContext ctxt) throws IOException {\n        \n        TypeFactory tf = ctxt.getTypeFactory();\n        if (id.indexOf('<') > 0) {\n            \n            \n            \n            \n            JavaType t = tf.constructFromCanonical(id);\n            if (!t.isTypeOrSubTypeOf(_baseType.getRawClass())) {\n                \n                throw new IllegalArgumentException(String.format(\n                        \"Class %s not subtype of %s\", t.getRawClass().getName(), _baseType));\n            }\n            return t;\n        }\n        Class<?> cls;\n        try {\n            cls =  tf.findClass(id);\n        } catch (ClassNotFoundException e) {\n            \n            \n            if (ctxt instanceof DeserializationContext) {\n                DeserializationContext dctxt = (DeserializationContext) ctxt;\n                \n                return dctxt.handleUnknownTypeId(_baseType, id, this, \"no such class found\");\n            }\n            \n            return null;\n        } catch (Exception e) {\n            throw new IllegalArgumentException(\"Invalid type id '\"+id+\"' (for id type 'Id.class'): \"+e.getMessage(), e);\n        }\n        return tf.constructSpecializedType(_baseType, cls);\n    }\n    \n    \n    \n    protected final String _idFrom(Object value, Class<?> cls, TypeFactory typeFactory) {\n        \n        if (Enum.class.isAssignableFrom(cls)) {\n            if (!cls.isEnum()) { \n                cls = cls.getSuperclass();\n            }\n        }\n        String str = cls.getName();\n        if (str.startsWith(\"java.util\")) {\n            \n            \n\n            \n            \n            \n            if (value instanceof EnumSet<?>) { \n                Class<?> enumClass = ClassUtil.findEnumType((EnumSet<?>) value);\n                \n               str = typeFactory.constructCollectionType(EnumSet.class, enumClass).toCanonical();\n            } else if (value instanceof EnumMap<?,?>) {\n                Class<?> enumClass = ClassUtil.findEnumType((EnumMap<?,?>) value);\n                Class<?> valueClass = Object.class;\n                \n                str = typeFactory.constructMapType(EnumMap.class, enumClass, valueClass).toCanonical();\n            } else {\n                String end = str.substring(9);\n                if ((end.startsWith(\".Arrays$\") || end.startsWith(\".Collections$\"))\n                       && str.indexOf(\"List\") >= 0) {\n                    \n                    str = \"java.util.ArrayList\";\n                }\n            }\n        } else if (str.indexOf('$') >= 0) {\n            \n            Class<?> outer = ClassUtil.getOuterClass(cls);\n            if (outer != null) {\n                \n                Class<?> staticType = _baseType.getRawClass();\n                if (ClassUtil.getOuterClass(staticType) == null) {\n                    \n                    cls = _baseType.getRawClass();\n                    str = cls.getName();\n                }\n            }\n        }\n        return str;\n    }\n\n    @Override\n    public String getDescForKnownTypeIds() {\n        return \"class name used as type id\";\n    }\n}\n",
      "buggy_signatures": [
        "public class ClassNameIdResolver extends TypeIdResolverBase { public ClassNameIdResolver(JavaType baseType, TypeFactory typeFactory)",
        "public JsonTypeInfo.Id getMechanism()",
        "public void registerSubtype(Class<?> type, String name)",
        "public String idFromValue(Object value)",
        "public String idFromValueAndType(Object value, Class<?> type)",
        "public JavaType typeFromId(DatabindContext context, String id) throws IOException",
        "protected JavaType _typeFromId(String id, DatabindContext ctxt) throws IOException",
        "protected final String _idFrom(Object value, Class<?> cls, TypeFactory typeFactory)",
        "public String getDescForKnownTypeIds()"
      ],
      "fixed_signatures": [
        "public class ClassNameIdResolver extends TypeIdResolverBase { public ClassNameIdResolver(JavaType baseType, TypeFactory typeFactory)",
        "public JsonTypeInfo.Id getMechanism()",
        "public void registerSubtype(Class<?> type, String name)",
        "public String idFromValue(Object value)",
        "public String idFromValueAndType(Object value, Class<?> type)",
        "public JavaType typeFromId(DatabindContext context, String id) throws IOException",
        "protected JavaType _typeFromId(String id, DatabindContext ctxt) throws IOException",
        "protected final String _idFrom(Object value, Class<?> cls, TypeFactory typeFactory)",
        "public String getDescForKnownTypeIds()"
      ],
      "methods": [
        {
          "buggy_method": "  protected JavaType _typeFromId(String id, DatabindContext ctxt) throws IOException {\n  \n  TypeFactory tf = ctxt.getTypeFactory();\n  if (id.indexOf('<') > 0) {\n  \n  \n  \n  \n  JavaType t = tf.constructFromCanonical(id);\n  \n  return t;\n  }\n  Class<?> cls;\n  try {\n  cls =  tf.findClass(id);\n  } catch (ClassNotFoundException e) {\n  \n  \n  if (ctxt instanceof DeserializationContext) {\n  DeserializationContext dctxt = (DeserializationContext) ctxt;\n  \n  return dctxt.handleUnknownTypeId(_baseType, id, this, \"no such class found\");\n  }\n  \n  return null;\n  } catch (Exception e) {\n  throw new IllegalArgumentException(\"Invalid type id '\"+id+\"' (for id type 'Id.class'): \"+e.getMessage(), e);\n  }\n  return tf.constructSpecializedType(_baseType, cls);\n  }",
          "fixed_method": "  protected JavaType _typeFromId(String id, DatabindContext ctxt) throws IOException {\n  \n  TypeFactory tf = ctxt.getTypeFactory();\n  if (id.indexOf('<') > 0) {\n  \n  \n  \n  \n  JavaType t = tf.constructFromCanonical(id);\n  if (!t.isTypeOrSubTypeOf(_baseType.getRawClass())) {\n  \n  throw new IllegalArgumentException(String.format(\n  \"Class %s not subtype of %s\", t.getRawClass().getName(), _baseType));\n  }\n  return t;\n  }\n  Class<?> cls;\n  try {\n  cls =  tf.findClass(id);\n  } catch (ClassNotFoundException e) {\n  \n  \n  if (ctxt instanceof DeserializationContext) {\n  DeserializationContext dctxt = (DeserializationContext) ctxt;\n  \n  return dctxt.handleUnknownTypeId(_baseType, id, this, \"no such class found\");\n  }\n  \n  return null;\n  } catch (Exception e) {\n  throw new IllegalArgumentException(\"Invalid type id '\"+id+\"' (for id type 'Id.class'): \"+e.getMessage(), e);\n  }\n  return tf.constructSpecializedType(_baseType, cls);\n  }",
          "diff": [
            "@@ -55,7 +55,11 @@",
            "             //    compatibility -- needed later anyway, and not doing so may open\n",
            "             //    security issues.\n",
            "             JavaType t = tf.constructFromCanonical(id);\n",
            "+            if (!t.isTypeOrSubTypeOf(_baseType.getRawClass())) {\n",
            "                 // Probably cleaner to have a method in `TypeFactory` but can't add in patch\n",
            "+                throw new IllegalArgumentException(String.format(\n",
            "+                        \"Class %s not subtype of %s\", t.getRawClass().getName(), _baseType));\n",
            "+            }\n",
            "             return t;\n",
            "         }\n",
            "         Class<?> cls;\n"
          ],
          "changed_lines": 4
        }
      ]
    }
  ]
}
