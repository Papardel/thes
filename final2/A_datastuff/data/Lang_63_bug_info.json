{
  "bug_id": "63",
  "failed_tests": {
    "org.apache.commons.lang.time.DurationFormatUtilsTest": [
      {
        "methodName": "testJiraLang281",
        "error": "junit.framework.ComparisonFailure",
        "message": "expected:<[09]> but was:<[-2]>",
        "fail_line": "        assertEquals(\"09\", result);",
        "test_source": "  public void testJiraLang281() {\n  Calendar cal = Calendar.getInstance();\n  cal.set(Calendar.MONTH, Calendar.DECEMBER);\n  cal.set(Calendar.DAY_OF_MONTH, 31);\n  cal.set(Calendar.YEAR, 2005);\n  cal.set(Calendar.HOUR_OF_DAY, 0);\n  cal.set(Calendar.MINUTE, 0);\n  cal.set(Calendar.SECOND, 0);\n  cal.set(Calendar.MILLISECOND, 0);\n\n  Calendar cal2 = Calendar.getInstance();\n  cal2.set(Calendar.MONTH, Calendar.OCTOBER);\n  cal2.set(Calendar.DAY_OF_MONTH, 6);\n  cal2.set(Calendar.YEAR, 2006);\n  cal2.set(Calendar.HOUR_OF_DAY, 0);\n  cal2.set(Calendar.MINUTE, 0);\n  cal2.set(Calendar.SECOND, 0);\n  cal2.set(Calendar.MILLISECOND, 0);\n  String result = DurationFormatUtils.formatPeriod(cal.getTime().getTime(), cal2.getTime().getTime(), \"MM\");\n  assertEquals(\"09\", result);\n  }",
        "stack": [
          "DurationFormatUtilsTest.testJiraLang281 line 436"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/lang/time/DurationFormatUtils.java",
      "buggy_full_code": "\npackage org.apache.commons.lang.time;\n\nimport org.apache.commons.lang.StringUtils;\n\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.TimeZone;\n\n\npublic class DurationFormatUtils { public DurationFormatUtils() {\n        super();\n    }\n\n    \n    public static final String ISO_EXTENDED_FORMAT_PATTERN = \"'P'yyyy'Y'M'M'd'DT'H'H'm'M's.S'S'\"; public static String formatDurationHMS(long durationMillis) {\n        return formatDuration(durationMillis, \"H:mm:ss.SSS\");\n    }\n\n    \n    public static String formatDurationISO(long durationMillis) {\n        return formatDuration(durationMillis, ISO_EXTENDED_FORMAT_PATTERN, false);\n    }\n\n    \n    public static String formatDuration(long durationMillis, String format) {\n        return formatDuration(durationMillis, format, true);\n    }\n\n    \n    public static String formatDuration(long durationMillis, String format, boolean padWithZeros) {\n\n        Token[] tokens = lexx(format);\n\n        int days         = 0;\n        int hours        = 0;\n        int minutes      = 0;\n        int seconds      = 0;\n        int milliseconds = 0;\n        \n        if (Token.containsTokenWithValue(tokens, d) ) {\n            days = (int) (durationMillis / DateUtils.MILLIS_PER_DAY);\n            durationMillis = durationMillis - (days * DateUtils.MILLIS_PER_DAY);\n        }\n        if (Token.containsTokenWithValue(tokens, H) ) {\n            hours = (int) (durationMillis / DateUtils.MILLIS_PER_HOUR);\n            durationMillis = durationMillis - (hours * DateUtils.MILLIS_PER_HOUR);\n        }\n        if (Token.containsTokenWithValue(tokens, m) ) {\n            minutes = (int) (durationMillis / DateUtils.MILLIS_PER_MINUTE);\n            durationMillis = durationMillis - (minutes * DateUtils.MILLIS_PER_MINUTE);\n        }\n        if (Token.containsTokenWithValue(tokens, s) ) {\n            seconds = (int) (durationMillis / DateUtils.MILLIS_PER_SECOND);\n            durationMillis = durationMillis - (seconds * DateUtils.MILLIS_PER_SECOND);\n        }\n        if (Token.containsTokenWithValue(tokens, S) ) {\n            milliseconds = (int) durationMillis;\n        }\n\n        return format(tokens, 0, 0, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }\n\n    \n    public static String formatDurationWords( long durationMillis, boolean suppressLeadingZeroElements, boolean suppressTrailingZeroElements) {\n\n        \n        \n        \n        String duration = formatDuration(durationMillis, \"d' days 'H' hours 'm' minutes 's' seconds'\");\n        if (suppressLeadingZeroElements) {\n            \n            duration = \" \" + duration;\n            String tmp = StringUtils.replaceOnce(duration, \" 0 days\", \"\");\n            if (tmp.length() != duration.length()) {\n                duration = tmp;\n                tmp = StringUtils.replaceOnce(duration, \" 0 hours\", \"\");\n                if (tmp.length() != duration.length()) {\n                    duration = tmp;\n                    tmp = StringUtils.replaceOnce(duration, \" 0 minutes\", \"\");\n                    duration = tmp;\n                    if (tmp.length() != duration.length()) {\n                        duration = StringUtils.replaceOnce(tmp, \" 0 seconds\", \"\");\n                    }\n                }\n            }\n            if (duration.length() != 0) {\n                \n                duration = duration.substring(1);\n            }\n        }\n        if (suppressTrailingZeroElements) {\n            String tmp = StringUtils.replaceOnce(duration, \" 0 seconds\", \"\");\n            if (tmp.length() != duration.length()) {\n                duration = tmp;\n                tmp = StringUtils.replaceOnce(duration, \" 0 minutes\", \"\");\n                if (tmp.length() != duration.length()) {\n                    duration = tmp;\n                    tmp = StringUtils.replaceOnce(duration, \" 0 hours\", \"\");\n                    if (tmp.length() != duration.length()) {\n                        duration = StringUtils.replaceOnce(tmp, \" 0 days\", \"\");\n                    }\n                }\n            }\n        }\n        \n        duration = \" \" + duration;\n        duration = StringUtils.replaceOnce(duration, \" 1 seconds\", \" 1 second\");\n        duration = StringUtils.replaceOnce(duration, \" 1 minutes\", \" 1 minute\");\n        duration = StringUtils.replaceOnce(duration, \" 1 hours\", \" 1 hour\");\n        duration = StringUtils.replaceOnce(duration, \" 1 days\", \" 1 day\");\n        return duration.trim();\n    }\n\n    \n    \n    public static String formatPeriodISO(long startMillis, long endMillis) {\n        return formatPeriod(startMillis, endMillis, ISO_EXTENDED_FORMAT_PATTERN, false, TimeZone.getDefault());\n    }\n\n    \n    public static String formatPeriod(long startMillis, long endMillis, String format) {\n        return formatPeriod(startMillis, endMillis, format, true, TimeZone.getDefault());\n    }\n\n    \n    public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, TimeZone timezone) {\n\n        long millis = endMillis - startMillis;\n        if (millis < 28 * DateUtils.MILLIS_PER_DAY) {\n            return formatDuration(millis, format, padWithZeros);\n        }\n\n        Token[] tokens = lexx(format);\n\n        \n        \n        Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        \n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n        int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        \n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n        while (days < 0) {\n            days += 31;\n\n\n\n\n\n            months -= 1;\n        }\n        while (months < 0) {\n            months += 12;\n            years -= 1;\n        }\n        milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n        seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n        minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n        hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n        days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n        months -= reduceAndCorrect(start, end, Calendar.MONTH, months);\n        years -= reduceAndCorrect(start, end, Calendar.YEAR, years);\n\n        \n        \n        \n        if (!Token.containsTokenWithValue(tokens, y)) {\n            if (Token.containsTokenWithValue(tokens, M)) {\n                months += 12 * years;\n                years = 0;\n            } else {\n                \n                days += 365 * years;\n                years = 0;\n            }\n        }\n        if (!Token.containsTokenWithValue(tokens, M)) {\n            days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n            months = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\n            minutes += 60 * hours;\n            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }\n\n    \n    \n    static String format(Token[] tokens, int years, int months, int days, int hours, int minutes, int seconds, int milliseconds, boolean padWithZeros) {\n        StringBuffer buffer = new StringBuffer();\n        boolean lastOutputSeconds = false;\n        int sz = tokens.length;\n        for (int i = 0; i < sz; i++) {\n            Token token = tokens[i];\n            Object value = token.getValue();\n            int count = token.getCount();\n            if (value instanceof StringBuffer) {\n                buffer.append(value.toString());\n            } else {\n                if (value == y) {\n                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(years), count, '0') : Integer\n                            .toString(years));\n                    lastOutputSeconds = false;\n                } else if (value == M) {\n                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(months), count, '0') : Integer\n                            .toString(months));\n                    lastOutputSeconds = false;\n                } else if (value == d) {\n                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(days), count, '0') : Integer\n                            .toString(days));\n                    lastOutputSeconds = false;\n                } else if (value == H) {\n                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(hours), count, '0') : Integer\n                            .toString(hours));\n                    lastOutputSeconds = false;\n                } else if (value == m) {\n                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(minutes), count, '0') : Integer\n                            .toString(minutes));\n                    lastOutputSeconds = false;\n                } else if (value == s) {\n                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(seconds), count, '0') : Integer\n                            .toString(seconds));\n                    lastOutputSeconds = true;\n                } else if (value == S) {\n                    if (lastOutputSeconds) {\n                        milliseconds += 1000;\n                        String str = padWithZeros\n                                ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0')\n                                : Integer.toString(milliseconds);\n                        buffer.append(str.substring(1));\n                    } else {\n                        buffer.append(padWithZeros\n                                ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0')\n                                : Integer.toString(milliseconds));\n                    }\n                    lastOutputSeconds = false;\n                }\n            }\n        }\n        return buffer.toString();\n    }\n    static int reduceAndCorrect(Calendar start, Calendar end, int field, int difference) {\n        end.add( field, -1 * difference );\n        int endValue = end.get(field);\n        int startValue = start.get(field);\n        if (endValue < startValue) {\n            int newdiff = startValue - endValue;\n            end.add( field, newdiff );\n            return newdiff;\n        } else {\n            return 0;\n        }\n    }\n\n    static final Object y = \"y\"; static final Object M = \"M\"; static final Object d = \"d\"; static final Object H = \"H\"; static final Object m = \"m\"; static final Object s = \"s\"; static final Object S = \"S\"; static Token[] lexx(String format) {\n        char[] array = format.toCharArray();\n        java.util.ArrayList list = new java.util.ArrayList(array.length);\n\n        boolean inLiteral = false;\n        StringBuffer buffer = null;\n        Token previous = null;\n        int sz = array.length;\n        for(int i=0; i<sz; i++) {\n            char ch = array[i];\n            if(inLiteral && ch != '\\'') {\n                buffer.append(ch);\n                continue;\n            }\n            Object value = null;\n            switch(ch) {\n                \n                case '\\'' : \n                  if(inLiteral) {\n                      buffer = null;\n                      inLiteral = false;\n                  } else {\n                      buffer = new StringBuffer();\n                      list.add(new Token(buffer));\n                      inLiteral = true;\n                  }\n                  break;\n                case 'y'  : value = y; break;\n                case 'M'  : value = M; break;\n                case 'd'  : value = d; break;\n                case 'H'  : value = H; break;\n                case 'm'  : value = m; break;\n                case 's'  : value = s; break;\n                case 'S'  : value = S; break;\n                default   : \n                  if(buffer == null) {\n                      buffer = new StringBuffer();\n                      list.add(new Token(buffer));\n                  }\n                  buffer.append(ch);\n            }\n\n            if(value != null) {\n                if(previous != null && previous.getValue() == value) {\n                    previous.increment();\n                } else {\n                    Token token = new Token(value);\n                    list.add(token); \n                    previous = token;\n                }\n                buffer = null; \n            }\n        }\n        return (Token[]) list.toArray( new Token[0] );\n    }\n\n    \n    static class Token { static boolean containsTokenWithValue(Token[] tokens, Object value) {\n            int sz = tokens.length;\n            for (int i = 0; i < sz; i++) {\n                if (tokens[i].getValue() == value) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        private Object value; private int count; Token(Object value) {\n            this.value = value;\n            this.count = 1;\n        }\n\n        \n        Token(Object value, int count) {\n            this.value = value;\n            this.count = count;\n        }\n\n        \n        void increment() { \n            count++;\n        }\n\n        \n        int getCount() {\n            return count;\n        }\n\n        \n        Object getValue() {\n            return value;\n        }\n\n        \n        public boolean equals(Object obj2) {\n            if (obj2 instanceof Token) {\n                Token tok2 = (Token) obj2;\n                if (this.value.getClass() != tok2.value.getClass()) {\n                    return false;\n                }\n                if (this.count != tok2.count) {\n                    return false;\n                }\n                if (this.value instanceof StringBuffer) {\n                    return this.value.toString().equals(tok2.value.toString());\n                } else if (this.value instanceof Number) {\n                    return this.value.equals(tok2.value);\n                } else {\n                    return this.value == tok2.value;\n                }\n            } else {\n                return false;\n            }\n        }\n\n        \n        public int hashCode() {\n            return this.value.hashCode();\n        }\n\n        \n        public String toString() {\n            return StringUtils.repeat(this.value.toString(), this.count);\n        }\n    }\n\n}\n",
      "fixed_full_code": "\npackage org.apache.commons.lang.time;\n\nimport org.apache.commons.lang.StringUtils;\n\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.TimeZone;\n\n\npublic class DurationFormatUtils { public DurationFormatUtils() {\n        super();\n    }\n\n    \n    public static final String ISO_EXTENDED_FORMAT_PATTERN = \"'P'yyyy'Y'M'M'd'DT'H'H'm'M's.S'S'\"; public static String formatDurationHMS(long durationMillis) {\n        return formatDuration(durationMillis, \"H:mm:ss.SSS\");\n    }\n\n    \n    public static String formatDurationISO(long durationMillis) {\n        return formatDuration(durationMillis, ISO_EXTENDED_FORMAT_PATTERN, false);\n    }\n\n    \n    public static String formatDuration(long durationMillis, String format) {\n        return formatDuration(durationMillis, format, true);\n    }\n\n    \n    public static String formatDuration(long durationMillis, String format, boolean padWithZeros) {\n\n        Token[] tokens = lexx(format);\n\n        int days         = 0;\n        int hours        = 0;\n        int minutes      = 0;\n        int seconds      = 0;\n        int milliseconds = 0;\n        \n        if (Token.containsTokenWithValue(tokens, d) ) {\n            days = (int) (durationMillis / DateUtils.MILLIS_PER_DAY);\n            durationMillis = durationMillis - (days * DateUtils.MILLIS_PER_DAY);\n        }\n        if (Token.containsTokenWithValue(tokens, H) ) {\n            hours = (int) (durationMillis / DateUtils.MILLIS_PER_HOUR);\n            durationMillis = durationMillis - (hours * DateUtils.MILLIS_PER_HOUR);\n        }\n        if (Token.containsTokenWithValue(tokens, m) ) {\n            minutes = (int) (durationMillis / DateUtils.MILLIS_PER_MINUTE);\n            durationMillis = durationMillis - (minutes * DateUtils.MILLIS_PER_MINUTE);\n        }\n        if (Token.containsTokenWithValue(tokens, s) ) {\n            seconds = (int) (durationMillis / DateUtils.MILLIS_PER_SECOND);\n            durationMillis = durationMillis - (seconds * DateUtils.MILLIS_PER_SECOND);\n        }\n        if (Token.containsTokenWithValue(tokens, S) ) {\n            milliseconds = (int) durationMillis;\n        }\n\n        return format(tokens, 0, 0, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }\n\n    \n    public static String formatDurationWords( long durationMillis, boolean suppressLeadingZeroElements, boolean suppressTrailingZeroElements) {\n\n        \n        \n        \n        String duration = formatDuration(durationMillis, \"d' days 'H' hours 'm' minutes 's' seconds'\");\n        if (suppressLeadingZeroElements) {\n            \n            duration = \" \" + duration;\n            String tmp = StringUtils.replaceOnce(duration, \" 0 days\", \"\");\n            if (tmp.length() != duration.length()) {\n                duration = tmp;\n                tmp = StringUtils.replaceOnce(duration, \" 0 hours\", \"\");\n                if (tmp.length() != duration.length()) {\n                    duration = tmp;\n                    tmp = StringUtils.replaceOnce(duration, \" 0 minutes\", \"\");\n                    duration = tmp;\n                    if (tmp.length() != duration.length()) {\n                        duration = StringUtils.replaceOnce(tmp, \" 0 seconds\", \"\");\n                    }\n                }\n            }\n            if (duration.length() != 0) {\n                \n                duration = duration.substring(1);\n            }\n        }\n        if (suppressTrailingZeroElements) {\n            String tmp = StringUtils.replaceOnce(duration, \" 0 seconds\", \"\");\n            if (tmp.length() != duration.length()) {\n                duration = tmp;\n                tmp = StringUtils.replaceOnce(duration, \" 0 minutes\", \"\");\n                if (tmp.length() != duration.length()) {\n                    duration = tmp;\n                    tmp = StringUtils.replaceOnce(duration, \" 0 hours\", \"\");\n                    if (tmp.length() != duration.length()) {\n                        duration = StringUtils.replaceOnce(tmp, \" 0 days\", \"\");\n                    }\n                }\n            }\n        }\n        \n        duration = \" \" + duration;\n        duration = StringUtils.replaceOnce(duration, \" 1 seconds\", \" 1 second\");\n        duration = StringUtils.replaceOnce(duration, \" 1 minutes\", \" 1 minute\");\n        duration = StringUtils.replaceOnce(duration, \" 1 hours\", \" 1 hour\");\n        duration = StringUtils.replaceOnce(duration, \" 1 days\", \" 1 day\");\n        return duration.trim();\n    }\n\n    \n    \n    public static String formatPeriodISO(long startMillis, long endMillis) {\n        return formatPeriod(startMillis, endMillis, ISO_EXTENDED_FORMAT_PATTERN, false, TimeZone.getDefault());\n    }\n\n    \n    public static String formatPeriod(long startMillis, long endMillis, String format) {\n        return formatPeriod(startMillis, endMillis, format, true, TimeZone.getDefault());\n    }\n\n    \n    public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, TimeZone timezone) {\n\n        long millis = endMillis - startMillis;\n        if (millis < 28 * DateUtils.MILLIS_PER_DAY) {\n            return formatDuration(millis, format, padWithZeros);\n        }\n\n        Token[] tokens = lexx(format);\n\n        \n        \n        Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        \n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n        int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        \n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n        while (days < 0) {\n            end.add(Calendar.MONTH, -1);\n            days += end.getActualMaximum(Calendar.DAY_OF_MONTH);\n\n\n\n\n\n            months -= 1;\n            end.add(Calendar.MONTH, 1);\n        }\n        while (months < 0) {\n            months += 12;\n            years -= 1;\n        }\n\n        \n        \n        \n        if (!Token.containsTokenWithValue(tokens, y)) {\n            if (Token.containsTokenWithValue(tokens, M)) {\n                months += 12 * years;\n                years = 0;\n            } else {\n                \n                days += 365 * years;\n                years = 0;\n            }\n        }\n        if (!Token.containsTokenWithValue(tokens, M)) {\n            days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n            months = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\n            minutes += 60 * hours;\n            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }\n\n    \n    \n    static String format(Token[] tokens, int years, int months, int days, int hours, int minutes, int seconds, int milliseconds, boolean padWithZeros) {\n        StringBuffer buffer = new StringBuffer();\n        boolean lastOutputSeconds = false;\n        int sz = tokens.length;\n        for (int i = 0; i < sz; i++) {\n            Token token = tokens[i];\n            Object value = token.getValue();\n            int count = token.getCount();\n            if (value instanceof StringBuffer) {\n                buffer.append(value.toString());\n            } else {\n                if (value == y) {\n                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(years), count, '0') : Integer\n                            .toString(years));\n                    lastOutputSeconds = false;\n                } else if (value == M) {\n                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(months), count, '0') : Integer\n                            .toString(months));\n                    lastOutputSeconds = false;\n                } else if (value == d) {\n                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(days), count, '0') : Integer\n                            .toString(days));\n                    lastOutputSeconds = false;\n                } else if (value == H) {\n                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(hours), count, '0') : Integer\n                            .toString(hours));\n                    lastOutputSeconds = false;\n                } else if (value == m) {\n                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(minutes), count, '0') : Integer\n                            .toString(minutes));\n                    lastOutputSeconds = false;\n                } else if (value == s) {\n                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(seconds), count, '0') : Integer\n                            .toString(seconds));\n                    lastOutputSeconds = true;\n                } else if (value == S) {\n                    if (lastOutputSeconds) {\n                        milliseconds += 1000;\n                        String str = padWithZeros\n                                ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0')\n                                : Integer.toString(milliseconds);\n                        buffer.append(str.substring(1));\n                    } else {\n                        buffer.append(padWithZeros\n                                ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0')\n                                : Integer.toString(milliseconds));\n                    }\n                    lastOutputSeconds = false;\n                }\n            }\n        }\n        return buffer.toString();\n    }\n\n    static final Object y = \"y\"; static final Object M = \"M\"; static final Object d = \"d\"; static final Object H = \"H\"; static final Object m = \"m\"; static final Object s = \"s\"; static final Object S = \"S\"; static Token[] lexx(String format) {\n        char[] array = format.toCharArray();\n        java.util.ArrayList list = new java.util.ArrayList(array.length);\n\n        boolean inLiteral = false;\n        StringBuffer buffer = null;\n        Token previous = null;\n        int sz = array.length;\n        for(int i=0; i<sz; i++) {\n            char ch = array[i];\n            if(inLiteral && ch != '\\'') {\n                buffer.append(ch);\n                continue;\n            }\n            Object value = null;\n            switch(ch) {\n                \n                case '\\'' : \n                  if(inLiteral) {\n                      buffer = null;\n                      inLiteral = false;\n                  } else {\n                      buffer = new StringBuffer();\n                      list.add(new Token(buffer));\n                      inLiteral = true;\n                  }\n                  break;\n                case 'y'  : value = y; break;\n                case 'M'  : value = M; break;\n                case 'd'  : value = d; break;\n                case 'H'  : value = H; break;\n                case 'm'  : value = m; break;\n                case 's'  : value = s; break;\n                case 'S'  : value = S; break;\n                default   : \n                  if(buffer == null) {\n                      buffer = new StringBuffer();\n                      list.add(new Token(buffer));\n                  }\n                  buffer.append(ch);\n            }\n\n            if(value != null) {\n                if(previous != null && previous.getValue() == value) {\n                    previous.increment();\n                } else {\n                    Token token = new Token(value);\n                    list.add(token); \n                    previous = token;\n                }\n                buffer = null; \n            }\n        }\n        return (Token[]) list.toArray( new Token[0] );\n    }\n\n    \n    static class Token { static boolean containsTokenWithValue(Token[] tokens, Object value) {\n            int sz = tokens.length;\n            for (int i = 0; i < sz; i++) {\n                if (tokens[i].getValue() == value) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        private Object value; private int count; Token(Object value) {\n            this.value = value;\n            this.count = 1;\n        }\n\n        \n        Token(Object value, int count) {\n            this.value = value;\n            this.count = count;\n        }\n\n        \n        void increment() { \n            count++;\n        }\n\n        \n        int getCount() {\n            return count;\n        }\n\n        \n        Object getValue() {\n            return value;\n        }\n\n        \n        public boolean equals(Object obj2) {\n            if (obj2 instanceof Token) {\n                Token tok2 = (Token) obj2;\n                if (this.value.getClass() != tok2.value.getClass()) {\n                    return false;\n                }\n                if (this.count != tok2.count) {\n                    return false;\n                }\n                if (this.value instanceof StringBuffer) {\n                    return this.value.toString().equals(tok2.value.toString());\n                } else if (this.value instanceof Number) {\n                    return this.value.equals(tok2.value);\n                } else {\n                    return this.value == tok2.value;\n                }\n            } else {\n                return false;\n            }\n        }\n\n        \n        public int hashCode() {\n            return this.value.hashCode();\n        }\n\n        \n        public String toString() {\n            return StringUtils.repeat(this.value.toString(), this.count);\n        }\n    }\n\n}\n",
      "buggy_signatures": [
        "public class DurationFormatUtils { public DurationFormatUtils()",
        "public static String formatDurationISO(long durationMillis)",
        "public static String formatDuration(long durationMillis, String format)",
        "public static String formatDuration(long durationMillis, String format, boolean padWithZeros)",
        "public static String formatDurationWords( long durationMillis, boolean suppressLeadingZeroElements, boolean suppressTrailingZeroElements)",
        "public static String formatPeriodISO(long startMillis, long endMillis)",
        "public static String formatPeriod(long startMillis, long endMillis, String format)",
        "public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, TimeZone timezone)",
        "static String format(Token[] tokens, int years, int months, int days, int hours, int minutes, int seconds, int milliseconds, boolean padWithZeros)",
        "static int reduceAndCorrect(Calendar start, Calendar end, int field, int difference)",
        "static class Token { static boolean containsTokenWithValue(Token[] tokens, Object value)",
        "private Object value; private int count; Token(Object value)",
        "public boolean equals(Object obj2)",
        "public int hashCode()",
        "public String toString()"
      ],
      "fixed_signatures": [
        "public class DurationFormatUtils { public DurationFormatUtils()",
        "public static String formatDurationISO(long durationMillis)",
        "public static String formatDuration(long durationMillis, String format)",
        "public static String formatDuration(long durationMillis, String format, boolean padWithZeros)",
        "public static String formatDurationWords( long durationMillis, boolean suppressLeadingZeroElements, boolean suppressTrailingZeroElements)",
        "public static String formatPeriodISO(long startMillis, long endMillis)",
        "public static String formatPeriod(long startMillis, long endMillis, String format)",
        "public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, TimeZone timezone)",
        "static String format(Token[] tokens, int years, int months, int days, int hours, int minutes, int seconds, int milliseconds, boolean padWithZeros)",
        "static class Token { static boolean containsTokenWithValue(Token[] tokens, Object value)",
        "private Object value; private int count; Token(Object value)",
        "public boolean equals(Object obj2)",
        "public int hashCode()",
        "public String toString()"
      ],
      "methods": [
        {
          "buggy_method": "  public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, TimeZone timezone) {\n\n  long millis = endMillis - startMillis;\n  if (millis < 28 * DateUtils.MILLIS_PER_DAY) {\n  return formatDuration(millis, format, padWithZeros);\n  }\n\n  Token[] tokens = lexx(format);\n\n  \n  \n  Calendar start = Calendar.getInstance(timezone);\n  start.setTime(new Date(startMillis));\n  Calendar end = Calendar.getInstance(timezone);\n  end.setTime(new Date(endMillis));\n\n  \n  int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n  int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n  int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n  int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n  int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n  int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n  int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n  \n  while (milliseconds < 0) {\n  milliseconds += 1000;\n  seconds -= 1;\n  }\n  while (seconds < 0) {\n  seconds += 60;\n  minutes -= 1;\n  }\n  while (minutes < 0) {\n  minutes += 60;\n  hours -= 1;\n  }\n  while (hours < 0) {\n  hours += 24;\n  days -= 1;\n  }\n  while (days < 0) {\n  days += 31;\n\n\n\n\n\n  months -= 1;\n  }\n  while (months < 0) {\n  months += 12;\n  years -= 1;\n  }\n  milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n  seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n  minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n  hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n  days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n  months -= reduceAndCorrect(start, end, Calendar.MONTH, months);\n  years -= reduceAndCorrect(start, end, Calendar.YEAR, years);\n\n  \n  \n  \n  if (!Token.containsTokenWithValue(tokens, y)) {\n  if (Token.containsTokenWithValue(tokens, M)) {\n  months += 12 * years;\n  years = 0;\n  } else {\n  \n  days += 365 * years;\n  years = 0;\n  }\n  }\n  if (!Token.containsTokenWithValue(tokens, M)) {\n  days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n  months = 0;\n  }\n  if (!Token.containsTokenWithValue(tokens, d)) {\n  hours += 24 * days;\n  days = 0;\n  }\n  if (!Token.containsTokenWithValue(tokens, H)) {\n  minutes += 60 * hours;\n  hours = 0;\n  }\n  if (!Token.containsTokenWithValue(tokens, m)) {\n  seconds += 60 * minutes;\n  minutes = 0;\n  }\n  if (!Token.containsTokenWithValue(tokens, s)) {\n  milliseconds += 1000 * seconds;\n  seconds = 0;\n  }\n\n  return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n  }",
          "fixed_method": "  public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, TimeZone timezone) {\n\n  long millis = endMillis - startMillis;\n  if (millis < 28 * DateUtils.MILLIS_PER_DAY) {\n  return formatDuration(millis, format, padWithZeros);\n  }\n\n  Token[] tokens = lexx(format);\n\n  \n  \n  Calendar start = Calendar.getInstance(timezone);\n  start.setTime(new Date(startMillis));\n  Calendar end = Calendar.getInstance(timezone);\n  end.setTime(new Date(endMillis));\n\n  \n  int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n  int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n  int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n  int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n  int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n  int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n  int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n  \n  while (milliseconds < 0) {\n  milliseconds += 1000;\n  seconds -= 1;\n  }\n  while (seconds < 0) {\n  seconds += 60;\n  minutes -= 1;\n  }\n  while (minutes < 0) {\n  minutes += 60;\n  hours -= 1;\n  }\n  while (hours < 0) {\n  hours += 24;\n  days -= 1;\n  }\n  while (days < 0) {\n  end.add(Calendar.MONTH, -1);\n  days += end.getActualMaximum(Calendar.DAY_OF_MONTH);\n\n\n\n\n\n  months -= 1;\n  end.add(Calendar.MONTH, 1);\n  }\n  while (months < 0) {\n  months += 12;\n  years -= 1;\n  }\n\n  \n  \n  \n  if (!Token.containsTokenWithValue(tokens, y)) {\n  if (Token.containsTokenWithValue(tokens, M)) {\n  months += 12 * years;\n  years = 0;\n  } else {\n  \n  days += 365 * years;\n  years = 0;\n  }\n  }\n  if (!Token.containsTokenWithValue(tokens, M)) {\n  days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n  months = 0;\n  }\n  if (!Token.containsTokenWithValue(tokens, d)) {\n  hours += 24 * days;\n  days = 0;\n  }\n  if (!Token.containsTokenWithValue(tokens, H)) {\n  minutes += 60 * hours;\n  hours = 0;\n  }\n  if (!Token.containsTokenWithValue(tokens, m)) {\n  seconds += 60 * minutes;\n  minutes = 0;\n  }\n  if (!Token.containsTokenWithValue(tokens, s)) {\n  milliseconds += 1000 * seconds;\n  seconds = 0;\n  }\n\n  return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n  }",
          "diff": [
            "@@ -303,25 +303,20 @@",
            "             days -= 1;\n",
            "         }\n",
            "         while (days < 0) {\n",
            "-            days += 31;\n",
            "+            end.add(Calendar.MONTH, -1);\n",
            "+            days += end.getActualMaximum(Calendar.DAY_OF_MONTH);\n",
            " //days += 31; // TODO: Need tests to show this is bad and the new code is good.\n",
            " // HEN: It's a tricky subject. Jan 15th to March 10th. If I count days-first it is \n",
            " // 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.\n",
            " // Also it's contextual - if asked for no M in the format then I should probably \n",
            " // be doing no calculating here.\n",
            "             months -= 1;\n",
            "+            end.add(Calendar.MONTH, 1);\n",
            "         }\n",
            "         while (months < 0) {\n",
            "             months += 12;\n",
            "             years -= 1;\n",
            "         }\n",
            "-        milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n",
            "-        seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n",
            "-        minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n",
            "-        hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n",
            "-        days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n",
            "-        months -= reduceAndCorrect(start, end, Calendar.MONTH, months);\n",
            "-        years -= reduceAndCorrect(start, end, Calendar.YEAR, years);\n",
            " \n",
            "         // This next block of code adds in values that \n",
            "         // aren't requested. This allows the user to ask for the \n"
          ],
          "changed_lines": 11
        },
        {
          "buggy_method": "  static int reduceAndCorrect(Calendar start, Calendar end, int field, int difference) {\n  end.add( field, -1 * difference );\n  int endValue = end.get(field);\n  int startValue = start.get(field);\n  if (endValue < startValue) {\n  int newdiff = startValue - endValue;\n  end.add( field, newdiff );\n  return newdiff;\n  } else {\n  return 0;\n  }\n  }",
          "fixed_method": "  static String format(Token[] tokens, int years, int months, int days, int hours, int minutes, int seconds, int milliseconds, boolean padWithZeros) {\n  StringBuffer buffer = new StringBuffer();\n  boolean lastOutputSeconds = false;\n  int sz = tokens.length;\n  for (int i = 0; i < sz; i++) {\n  Token token = tokens[i];\n  Object value = token.getValue();\n  int count = token.getCount();\n  if (value instanceof StringBuffer) {\n  buffer.append(value.toString());\n  } else {\n  if (value == y) {\n  buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(years), count, '0') : Integer\n  .toString(years));\n  lastOutputSeconds = false;\n  } else if (value == M) {\n  buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(months), count, '0') : Integer\n  .toString(months));\n  lastOutputSeconds = false;\n  } else if (value == d) {\n  buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(days), count, '0') : Integer\n  .toString(days));\n  lastOutputSeconds = false;\n  } else if (value == H) {\n  buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(hours), count, '0') : Integer\n  .toString(hours));\n  lastOutputSeconds = false;\n  } else if (value == m) {\n  buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(minutes), count, '0') : Integer\n  .toString(minutes));\n  lastOutputSeconds = false;\n  } else if (value == s) {\n  buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(seconds), count, '0') : Integer\n  .toString(seconds));\n  lastOutputSeconds = true;\n  } else if (value == S) {\n  if (lastOutputSeconds) {\n  milliseconds += 1000;\n  String str = padWithZeros\n  ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0')\n  : Integer.toString(milliseconds);\n  buffer.append(str.substring(1));\n  } else {\n  buffer.append(padWithZeros\n  ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0')\n  : Integer.toString(milliseconds));\n  }\n  lastOutputSeconds = false;\n  }\n  }\n  }\n  return buffer.toString();\n  }",
          "diff": [
            "@@ -429,18 +424,6 @@",
            "         }\n",
            "         return buffer.toString();\n",
            "     }\n",
            "-    static int reduceAndCorrect(Calendar start, Calendar end, int field, int difference) {\n",
            "-        end.add( field, -1 * difference );\n",
            "-        int endValue = end.get(field);\n",
            "-        int startValue = start.get(field);\n",
            "-        if (endValue < startValue) {\n",
            "-            int newdiff = startValue - endValue;\n",
            "-            end.add( field, newdiff );\n",
            "-            return newdiff;\n",
            "-        } else {\n",
            "-            return 0;\n",
            "-        }\n",
            "-    }\n",
            " \n",
            "     static final Object y = \"y\";\n",
            "     static final Object M = \"M\";\n"
          ],
          "changed_lines": 12
        }
      ]
    }
  ]
}
