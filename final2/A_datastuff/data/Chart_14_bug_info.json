{
  "bug_id": "14",
  "failed_tests": {
    "org.jfree.chart.plot.junit.CategoryPlotTests": [
      {
        "methodName": "testRemoveRangeMarker",
        "error": "java.lang.NullPointerException",
        "message": "",
        "fail_line": "    \tassertFalse(plot.removeRangeMarker(new ValueMarker(0.5)));",
        "test_source": "  public void testRemoveRangeMarker() {\n  \tCategoryPlot plot = new CategoryPlot();\n  \tassertFalse(plot.removeRangeMarker(new ValueMarker(0.5)));\n  }",
        "stack": [
          "CategoryPlot.removeRangeMarker line 2448, CategoryPlot.removeRangeMarker line 2415, CategoryPlot.removeRangeMarker line 2396, CategoryPlot.removeRangeMarker line 2378, CategoryPlotTests.testRemoveRangeMarker line 780"
        ]
      },
      {
        "methodName": "testRemoveDomainMarker",
        "error": "java.lang.NullPointerException",
        "message": "",
        "fail_line": "    \tassertFalse(plot.removeDomainMarker(new CategoryMarker(\"Category 1\")));",
        "test_source": "  public void testRemoveDomainMarker() {\n  \tCategoryPlot plot = new CategoryPlot();\n  \tassertFalse(plot.removeDomainMarker(new CategoryMarker(\"Category 1\")));\n  }",
        "stack": [
          "CategoryPlot.removeDomainMarker line 2166, CategoryPlot.removeDomainMarker line 2139, CategoryPlot.removeDomainMarker line 2122, CategoryPlot.removeDomainMarker line 2106, CategoryPlotTests.testRemoveDomainMarker line 771"
        ]
      }
    ],
    "org.jfree.chart.plot.junit.XYPlotTests": [
      {
        "methodName": "testRemoveRangeMarker",
        "error": "java.lang.NullPointerException",
        "message": "",
        "fail_line": "    \tassertFalse(plot.removeRangeMarker(new ValueMarker(0.5)));",
        "test_source": "  public void testRemoveRangeMarker() {\n  \tXYPlot plot = new XYPlot();\n  \tassertFalse(plot.removeRangeMarker(new ValueMarker(0.5)));\n  }",
        "stack": [
          "XYPlot.removeRangeMarker line 2529, XYPlot.removeRangeMarker line 2498, XYPlot.removeRangeMarker line 2481, XYPlot.removeRangeMarker line 2465, XYPlotTests.testRemoveRangeMarker line 1037"
        ]
      },
      {
        "methodName": "testRemoveDomainMarker",
        "error": "java.lang.NullPointerException",
        "message": "",
        "fail_line": "    \tassertFalse(plot.removeDomainMarker(new ValueMarker(0.5)));",
        "test_source": "  public void testRemoveDomainMarker() {\n  \tXYPlot plot = new XYPlot();\n  \tassertFalse(plot.removeDomainMarker(new ValueMarker(0.5)));\n  }",
        "stack": [
          "XYPlot.removeDomainMarker line 2293, XYPlot.removeDomainMarker line 2265, XYPlot.removeDomainMarker line 2248, XYPlot.removeDomainMarker line 2232, XYPlotTests.testRemoveDomainMarker line 1028"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/jfree/chart/plot/CategoryPlot.java",
      "buggy_full_code": "\n\npackage org.jfree.chart.plot;\n\nimport java.awt.AlphaComposite;\nimport java.awt.BasicStroke;\nimport java.awt.Color;\nimport java.awt.Composite;\nimport java.awt.Font;\nimport java.awt.Graphics2D;\nimport java.awt.Paint;\nimport java.awt.Shape;\nimport java.awt.Stroke;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.ResourceBundle;\nimport java.util.Set;\n\nimport org.jfree.chart.LegendItem;\nimport org.jfree.chart.LegendItemCollection;\nimport org.jfree.chart.annotations.CategoryAnnotation;\nimport org.jfree.chart.axis.Axis;\nimport org.jfree.chart.axis.AxisCollection;\nimport org.jfree.chart.axis.AxisLocation;\nimport org.jfree.chart.axis.AxisSpace;\nimport org.jfree.chart.axis.AxisState;\nimport org.jfree.chart.axis.CategoryAnchor;\nimport org.jfree.chart.axis.CategoryAxis;\nimport org.jfree.chart.axis.ValueAxis;\nimport org.jfree.chart.axis.ValueTick;\nimport org.jfree.chart.event.ChartChangeEventType;\nimport org.jfree.chart.event.PlotChangeEvent;\nimport org.jfree.chart.event.RendererChangeEvent;\nimport org.jfree.chart.event.RendererChangeListener;\nimport org.jfree.chart.renderer.category.CategoryItemRenderer;\nimport org.jfree.chart.renderer.category.CategoryItemRendererState;\nimport org.jfree.chart.util.Layer;\nimport org.jfree.chart.util.ObjectList;\nimport org.jfree.chart.util.ObjectUtilities;\nimport org.jfree.chart.util.PaintUtilities;\nimport org.jfree.chart.util.PublicCloneable;\nimport org.jfree.chart.util.RectangleEdge;\nimport org.jfree.chart.util.RectangleInsets;\nimport org.jfree.chart.util.SerialUtilities;\nimport org.jfree.chart.util.SortOrder;\nimport org.jfree.data.Range;\nimport org.jfree.data.category.CategoryDataset;\nimport org.jfree.data.general.Dataset;\nimport org.jfree.data.general.DatasetChangeEvent;\nimport org.jfree.data.general.DatasetUtilities;\n\n\npublic class CategoryPlot extends Plot implements ValueAxisPlot, Zoomable, RendererChangeListener, Cloneable, PublicCloneable, Serializable { private static final long serialVersionUID = -3537691700434728188L; public static final boolean DEFAULT_DOMAIN_GRIDLINES_VISIBLE = false; public static final boolean DEFAULT_RANGE_GRIDLINES_VISIBLE = true; public static final Stroke DEFAULT_GRIDLINE_STROKE = new BasicStroke(0.5f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL, 0.0f, new float[] {2.0f, 2.0f}, 0.0f); public static final Paint DEFAULT_GRIDLINE_PAINT = Color.WHITE; public static final Font DEFAULT_VALUE_LABEL_FONT = new Font(\"SansSerif\", Font.PLAIN, 10); public static final boolean DEFAULT_CROSSHAIR_VISIBLE = false; public static final Stroke DEFAULT_CROSSHAIR_STROKE = DEFAULT_GRIDLINE_STROKE; public static final Paint DEFAULT_CROSSHAIR_PAINT = Color.blue; protected static ResourceBundle localizationResources = ResourceBundle.getBundle( \"org.jfree.chart.plot.LocalizationBundle\"); private PlotOrientation orientation; private RectangleInsets axisOffset; private ObjectList domainAxes; private ObjectList domainAxisLocations; private boolean drawSharedDomainAxis; private ObjectList rangeAxes; private ObjectList rangeAxisLocations; private ObjectList datasets; private ObjectList datasetToDomainAxisMap; private ObjectList datasetToRangeAxisMap; private ObjectList renderers; private DatasetRenderingOrder renderingOrder = DatasetRenderingOrder.REVERSE; private SortOrder columnRenderingOrder = SortOrder.ASCENDING; private SortOrder rowRenderingOrder = SortOrder.ASCENDING; private boolean domainGridlinesVisible; private CategoryAnchor domainGridlinePosition; private transient Stroke domainGridlineStroke; private transient Paint domainGridlinePaint; private boolean rangeGridlinesVisible; private transient Stroke rangeGridlineStroke; private transient Paint rangeGridlinePaint; private double anchorValue; private boolean rangeCrosshairVisible; private double rangeCrosshairValue; private transient Stroke rangeCrosshairStroke; private transient Paint rangeCrosshairPaint; private boolean rangeCrosshairLockedOnData = true; private Map foregroundDomainMarkers; private Map backgroundDomainMarkers; private Map foregroundRangeMarkers; private Map backgroundRangeMarkers; private List annotations; private int weight; private AxisSpace fixedDomainAxisSpace; private AxisSpace fixedRangeAxisSpace; private LegendItemCollection fixedLegendItems; public CategoryPlot() {\n        this(null, null, null, null);\n    }\n\n    \n    public CategoryPlot(CategoryDataset dataset, CategoryAxis domainAxis, ValueAxis rangeAxis, CategoryItemRenderer renderer) {\n\n        super();\n\n        this.orientation = PlotOrientation.VERTICAL;\n\n        \n        this.domainAxes = new ObjectList();\n        this.domainAxisLocations = new ObjectList();\n        this.rangeAxes = new ObjectList();\n        this.rangeAxisLocations = new ObjectList();\n        \n        this.datasetToDomainAxisMap = new ObjectList();\n        this.datasetToRangeAxisMap = new ObjectList();\n\n        this.renderers = new ObjectList();\n\n        this.datasets = new ObjectList();\n        this.datasets.set(0, dataset);\n        if (dataset != null) {\n            dataset.addChangeListener(this);\n        }\n\n        this.axisOffset = new RectangleInsets(4.0, 4.0, 4.0, 4.0);\n\n        setDomainAxisLocation(AxisLocation.BOTTOM_OR_LEFT, false);\n        setRangeAxisLocation(AxisLocation.TOP_OR_LEFT, false);\n\n        this.renderers.set(0, renderer);\n        if (renderer != null) {\n            renderer.setPlot(this);\n            renderer.addChangeListener(this);\n        }\n\n        this.domainAxes.set(0, domainAxis);\n        this.mapDatasetToDomainAxis(0, 0);\n        if (domainAxis != null) {\n            domainAxis.setPlot(this);\n            domainAxis.addChangeListener(this);\n        }\n        this.drawSharedDomainAxis = false;\n\n        this.rangeAxes.set(0, rangeAxis);\n        this.mapDatasetToRangeAxis(0, 0);\n        if (rangeAxis != null) {\n            rangeAxis.setPlot(this);\n            rangeAxis.addChangeListener(this);\n        }\n        \n        configureDomainAxes();\n        configureRangeAxes();\n\n        this.domainGridlinesVisible = DEFAULT_DOMAIN_GRIDLINES_VISIBLE;\n        this.domainGridlinePosition = CategoryAnchor.MIDDLE;\n        this.domainGridlineStroke = DEFAULT_GRIDLINE_STROKE;\n        this.domainGridlinePaint = DEFAULT_GRIDLINE_PAINT;\n\n        this.rangeGridlinesVisible = DEFAULT_RANGE_GRIDLINES_VISIBLE;\n        this.rangeGridlineStroke = DEFAULT_GRIDLINE_STROKE;\n        this.rangeGridlinePaint = DEFAULT_GRIDLINE_PAINT;\n\n        this.foregroundDomainMarkers = new HashMap();\n        this.backgroundDomainMarkers = new HashMap();\n        this.foregroundRangeMarkers = new HashMap();\n        this.backgroundRangeMarkers = new HashMap();\n\n        Marker baseline = new ValueMarker(0.0, new Color(0.8f, 0.8f, 0.8f, \n                0.5f), new BasicStroke(1.0f), new Color(0.85f, 0.85f, 0.95f, \n                0.5f), new BasicStroke(1.0f), 0.6f);\n        addRangeMarker(baseline, Layer.BACKGROUND);\n\n        this.anchorValue = 0.0;\n\n        this.rangeCrosshairVisible = DEFAULT_CROSSHAIR_VISIBLE;\n        this.rangeCrosshairValue = 0.0;\n        this.rangeCrosshairStroke = DEFAULT_CROSSHAIR_STROKE;\n        this.rangeCrosshairPaint = DEFAULT_CROSSHAIR_PAINT;\n        \n        this.annotations = new java.util.ArrayList();\n\n    }\n    \n    \n    public String getPlotType() {\n        return localizationResources.getString(\"Category_Plot\");\n    }\n\n    \n    public PlotOrientation getOrientation() {\n        return this.orientation;\n    }\n\n    \n    public void setOrientation(PlotOrientation orientation) {\n        if (orientation == null) {\n            throw new IllegalArgumentException(\"Null 'orientation' argument.\");\n        }\n        this.orientation = orientation;\n        fireChangeEvent();\n    }\n\n    \n    public RectangleInsets getAxisOffset() {\n        return this.axisOffset;\n    }\n\n    \n    public void setAxisOffset(RectangleInsets offset) {\n        if (offset == null) {\n            throw new IllegalArgumentException(\"Null 'offset' argument.\");   \n        }\n        this.axisOffset = offset;\n        fireChangeEvent();\n    }\n\n    \n    public CategoryAxis getDomainAxis() {\n        return getDomainAxis(0);\n    }\n\n    \n    public CategoryAxis getDomainAxis(int index) {\n        CategoryAxis result = null;\n        if (index < this.domainAxes.size()) {\n            result = (CategoryAxis) this.domainAxes.get(index);\n        }\n        if (result == null) {\n            Plot parent = getParent();\n            if (parent instanceof CategoryPlot) {\n                CategoryPlot cp = (CategoryPlot) parent;\n                result = cp.getDomainAxis(index);\n            }\n        }\n        return result;\n    }\n\n    \n    public void setDomainAxis(CategoryAxis axis) {\n        setDomainAxis(0, axis);\n    }\n\n    \n    public void setDomainAxis(int index, CategoryAxis axis) {\n        setDomainAxis(index, axis, true);\n    }\n \n    \n    public void setDomainAxis(int index, CategoryAxis axis, boolean notify) {\n        CategoryAxis existing = (CategoryAxis) this.domainAxes.get(index);\n        if (existing != null) {\n            existing.removeChangeListener(this);\n        }\n        if (axis != null) {\n            axis.setPlot(this);\n        }\n        this.domainAxes.set(index, axis);\n        if (axis != null) {\n            axis.configure();\n            axis.addChangeListener(this);\n        }\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    \n    public void setDomainAxes(CategoryAxis[] axes) {\n        for (int i = 0; i < axes.length; i++) {\n            setDomainAxis(i, axes[i], false);   \n        }\n        fireChangeEvent();\n    }\n    \n    \n    public int getDomainAxisIndex(CategoryAxis axis) {\n        if (axis == null) {\n            throw new IllegalArgumentException(\"Null 'axis' argument.\");\n        }\n        return this.domainAxes.indexOf(axis);\n    }\n    \n    \n    public AxisLocation getDomainAxisLocation() {\n        return getDomainAxisLocation(0);\n    }\n\n    \n    public AxisLocation getDomainAxisLocation(int index) {\n        AxisLocation result = null;\n        if (index < this.domainAxisLocations.size()) {\n            result = (AxisLocation) this.domainAxisLocations.get(index);\n        }\n        if (result == null) {\n            result = AxisLocation.getOpposite(getDomainAxisLocation(0));\n        }\n        return result;\n    }\n\n    \n    public void setDomainAxisLocation(AxisLocation location) {\n        \n        setDomainAxisLocation(0, location, true);\n    }\n\n    \n    public void setDomainAxisLocation(AxisLocation location, boolean notify) {\n        \n        setDomainAxisLocation(0, location, notify);\n    }\n\n    \n    public void setDomainAxisLocation(int index, AxisLocation location) {\n        \n        setDomainAxisLocation(index, location, true);\n    }\n    \n    \n    public void setDomainAxisLocation(int index, AxisLocation location, boolean notify) {\n        if (index == 0 && location == null) {\n            throw new IllegalArgumentException(\n                    \"Null 'location' for index 0 not permitted.\");\n        }\n        this.domainAxisLocations.set(index, location);\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    \n    public RectangleEdge getDomainAxisEdge() {\n        return getDomainAxisEdge(0);\n    }\n\n    \n    public RectangleEdge getDomainAxisEdge(int index) {\n        RectangleEdge result = null;\n        AxisLocation location = getDomainAxisLocation(index);\n        if (location != null) {\n            result = Plot.resolveDomainAxisLocation(location, this.orientation);\n        }\n        else {\n            result = RectangleEdge.opposite(getDomainAxisEdge(0));\n        }\n        return result;\n    }\n\n    \n    public int getDomainAxisCount() {\n        return this.domainAxes.size();\n    }\n\n    \n    public void clearDomainAxes() {\n        for (int i = 0; i < this.domainAxes.size(); i++) {\n            CategoryAxis axis = (CategoryAxis) this.domainAxes.get(i);\n            if (axis != null) {\n                axis.removeChangeListener(this);\n            }\n        }\n        this.domainAxes.clear();\n        fireChangeEvent();\n    }\n\n    \n    public void configureDomainAxes() {\n        for (int i = 0; i < this.domainAxes.size(); i++) {\n            CategoryAxis axis = (CategoryAxis) this.domainAxes.get(i);\n            if (axis != null) {\n                axis.configure();\n            }\n        }\n    }\n\n    \n    public ValueAxis getRangeAxis() {\n        return getRangeAxis(0);\n    }\n\n    \n    public ValueAxis getRangeAxis(int index) {\n        ValueAxis result = null;\n        if (index < this.rangeAxes.size()) {\n            result = (ValueAxis) this.rangeAxes.get(index);\n        }\n        if (result == null) {\n            Plot parent = getParent();\n            if (parent instanceof CategoryPlot) {\n                CategoryPlot cp = (CategoryPlot) parent;\n                result = cp.getRangeAxis(index);\n            }\n        }\n        return result;\n    }\n\n    \n    public void setRangeAxis(ValueAxis axis) {\n        setRangeAxis(0, axis);\n    }\n\n    \n    public void setRangeAxis(int index, ValueAxis axis) {\n        setRangeAxis(index, axis, true);\n    }\n        \n    \n    public void setRangeAxis(int index, ValueAxis axis, boolean notify) {\n        ValueAxis existing = (ValueAxis) this.rangeAxes.get(index);\n        if (existing != null) {\n            existing.removeChangeListener(this);\n        }\n        if (axis != null) {\n            axis.setPlot(this);\n        }\n        this.rangeAxes.set(index, axis);\n        if (axis != null) {\n            axis.configure();\n            axis.addChangeListener(this);\n        }\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    \n    public void setRangeAxes(ValueAxis[] axes) {\n        for (int i = 0; i < axes.length; i++) {\n            setRangeAxis(i, axes[i], false);   \n        }\n        fireChangeEvent();\n    }\n\n    \n    public int getRangeAxisIndex(ValueAxis axis) {\n        if (axis == null) {\n            throw new IllegalArgumentException(\"Null 'axis' argument.\");\n        }\n        int result = this.rangeAxes.indexOf(axis);\n        if (result < 0) { \n            Plot parent = getParent();\n            if (parent instanceof CategoryPlot) {\n                CategoryPlot p = (CategoryPlot) parent;\n                result = p.getRangeAxisIndex(axis);\n            }\n        }\n        return result;\n    }\n\n    \n    public AxisLocation getRangeAxisLocation() {\n        return getRangeAxisLocation(0);\n    }\n\n    \n    public AxisLocation getRangeAxisLocation(int index) {\n        AxisLocation result = null;\n        if (index < this.rangeAxisLocations.size()) {\n            result = (AxisLocation) this.rangeAxisLocations.get(index);\n        }\n        if (result == null) {\n            result = AxisLocation.getOpposite(getRangeAxisLocation(0));\n        }\n        return result;\n    }\n\n    \n    public void setRangeAxisLocation(AxisLocation location) {\n        \n        setRangeAxisLocation(location, true);\n    }\n\n    \n    public void setRangeAxisLocation(AxisLocation location, boolean notify) {\n        setRangeAxisLocation(0, location, notify);\n    }\n\n    \n    public void setRangeAxisLocation(int index, AxisLocation location) {\n        setRangeAxisLocation(index, location, true);\n    }\n\n    \n    public void setRangeAxisLocation(int index, AxisLocation location, boolean notify) {\n        if (index == 0 && location == null) {\n            throw new IllegalArgumentException(\n                    \"Null 'location' for index 0 not permitted.\");\n        }\n        this.rangeAxisLocations.set(index, location);\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    \n    public RectangleEdge getRangeAxisEdge() {\n        return getRangeAxisEdge(0);\n    }\n\n    \n    public RectangleEdge getRangeAxisEdge(int index) {\n        AxisLocation location = getRangeAxisLocation(index);\n        RectangleEdge result = Plot.resolveRangeAxisLocation(location, \n                this.orientation);\n        if (result == null) {\n            result = RectangleEdge.opposite(getRangeAxisEdge(0));\n        }\n        return result;\n    }\n\n    \n    public int getRangeAxisCount() {\n        return this.rangeAxes.size();\n    }\n\n    \n    public void clearRangeAxes() {\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis axis = (ValueAxis) this.rangeAxes.get(i);\n            if (axis != null) {\n                axis.removeChangeListener(this);\n            }\n        }\n        this.rangeAxes.clear();\n        fireChangeEvent();\n    }\n\n    \n    public void configureRangeAxes() {\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis axis = (ValueAxis) this.rangeAxes.get(i);\n            if (axis != null) {\n                axis.configure();\n            }\n        }\n    }\n\n    \n    public CategoryDataset getDataset() {\n        return getDataset(0);\n    }\n\n    \n    public CategoryDataset getDataset(int index) {\n        CategoryDataset result = null;\n        if (this.datasets.size() > index) {\n            result = (CategoryDataset) this.datasets.get(index);\n        }\n        return result;\n    }\n\n    \n    public void setDataset(CategoryDataset dataset) {\n        setDataset(0, dataset);\n    }\n\n    \n    public void setDataset(int index, CategoryDataset dataset) {\n        \n        CategoryDataset existing = (CategoryDataset) this.datasets.get(index);\n        if (existing != null) {\n            existing.removeChangeListener(this);\n        }\n        this.datasets.set(index, dataset);\n        if (dataset != null) {\n            dataset.addChangeListener(this);\n        }\n        \n        \n        DatasetChangeEvent event = new DatasetChangeEvent(this, dataset);\n        datasetChanged(event);\n        \n    }\n\n    \n    public int getDatasetCount() {\n        return this.datasets.size();\n    }\n\n    \n    public void mapDatasetToDomainAxis(int index, int axisIndex) {\n        this.datasetToDomainAxisMap.set(index, new Integer(axisIndex));  \n        \n        datasetChanged(new DatasetChangeEvent(this, getDataset(index)));  \n    }\n\n    \n    public CategoryAxis getDomainAxisForDataset(int index) {\n        CategoryAxis result = getDomainAxis();\n        Integer axisIndex = (Integer) this.datasetToDomainAxisMap.get(index);\n        if (axisIndex != null) {\n            result = getDomainAxis(axisIndex.intValue());\n        }\n        return result;    \n    }\n    \n    \n    public void mapDatasetToRangeAxis(int index, int axisIndex) {\n        this.datasetToRangeAxisMap.set(index, new Integer(axisIndex));\n        \n        datasetChanged(new DatasetChangeEvent(this, getDataset(index)));  \n    }\n\n    \n    public ValueAxis getRangeAxisForDataset(int index) {\n        ValueAxis result = getRangeAxis();\n        Integer axisIndex = (Integer) this.datasetToRangeAxisMap.get(index);\n        if (axisIndex != null) {\n            result = getRangeAxis(axisIndex.intValue());\n        }\n        return result;    \n    }\n    \n    \n    public CategoryItemRenderer getRenderer() {\n        return getRenderer(0);\n    }\n\n    \n    public CategoryItemRenderer getRenderer(int index) {\n        CategoryItemRenderer result = null;\n        if (this.renderers.size() > index) {\n            result = (CategoryItemRenderer) this.renderers.get(index);\n        }\n        return result;\n    }\n    \n    \n    public void setRenderer(CategoryItemRenderer renderer) {\n        setRenderer(0, renderer, true);\n    }\n\n    \n    public void setRenderer(CategoryItemRenderer renderer, boolean notify) {\n        setRenderer(0, renderer, notify);\n    }\n\n    \n    public void setRenderer(int index, CategoryItemRenderer renderer) {\n        setRenderer(index, renderer, true);   \n    }\n\n    \n    public void setRenderer(int index, CategoryItemRenderer renderer, boolean notify) {\n        \n        \n        CategoryItemRenderer existing \n            = (CategoryItemRenderer) this.renderers.get(index);\n        if (existing != null) {\n            existing.removeChangeListener(this);\n        }\n        \n        \n        this.renderers.set(index, renderer);\n        if (renderer != null) {\n            renderer.setPlot(this);\n            renderer.addChangeListener(this);\n        }\n        \n        configureDomainAxes();\n        configureRangeAxes();\n        \n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    \n    public void setRenderers(CategoryItemRenderer[] renderers) {\n        for (int i = 0; i < renderers.length; i++) {\n            setRenderer(i, renderers[i], false);   \n        }\n        fireChangeEvent();\n    }\n    \n    \n    public CategoryItemRenderer getRendererForDataset(CategoryDataset dataset) {\n        CategoryItemRenderer result = null;\n        for (int i = 0; i < this.datasets.size(); i++) {\n            if (this.datasets.get(i) == dataset) {\n                result = (CategoryItemRenderer) this.renderers.get(i);   \n                break;\n            }\n        }\n        return result;\n    }\n    \n    \n    public int getIndexOf(CategoryItemRenderer renderer) {\n        return this.renderers.indexOf(renderer);\n    }\n\n    \n    public DatasetRenderingOrder getDatasetRenderingOrder() {\n        return this.renderingOrder;\n    }\n\n    \n    public void setDatasetRenderingOrder(DatasetRenderingOrder order) {\n        if (order == null) {\n            throw new IllegalArgumentException(\"Null 'order' argument.\");   \n        }\n        this.renderingOrder = order;\n        fireChangeEvent();\n    }\n\n        \n    public SortOrder getColumnRenderingOrder() {\n        return this.columnRenderingOrder;\n    }\n    \n    \n    public void setColumnRenderingOrder(SortOrder order) {\n        if (order == null) {\n            throw new IllegalArgumentException(\"Null 'order' argument.\");\n        }\n        this.columnRenderingOrder = order;\n        fireChangeEvent();\n    }\n    \n    \n    public SortOrder getRowRenderingOrder() {\n        return this.rowRenderingOrder;\n    }\n\n    \n    public void setRowRenderingOrder(SortOrder order) {\n        if (order == null) {\n            throw new IllegalArgumentException(\"Null 'order' argument.\");\n        }\n        this.rowRenderingOrder = order;\n        fireChangeEvent();\n    }\n    \n    \n    public boolean isDomainGridlinesVisible() {\n        return this.domainGridlinesVisible;\n    }\n\n    \n    public void setDomainGridlinesVisible(boolean visible) {\n        if (this.domainGridlinesVisible != visible) {\n            this.domainGridlinesVisible = visible;\n            fireChangeEvent();\n        }\n    }\n\n    \n    public CategoryAnchor getDomainGridlinePosition() {\n        return this.domainGridlinePosition;\n    }\n\n    \n    public void setDomainGridlinePosition(CategoryAnchor position) {\n        if (position == null) {\n            throw new IllegalArgumentException(\"Null 'position' argument.\");   \n        }\n        this.domainGridlinePosition = position;\n        fireChangeEvent();\n    }\n\n    \n    public Stroke getDomainGridlineStroke() {\n        return this.domainGridlineStroke;\n    }\n\n    \n    public void setDomainGridlineStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' not permitted.\");\n        }\n        this.domainGridlineStroke = stroke;\n        fireChangeEvent();\n    }\n\n    \n    public Paint getDomainGridlinePaint() {\n        return this.domainGridlinePaint;\n    }\n\n    \n    public void setDomainGridlinePaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");   \n        }\n        this.domainGridlinePaint = paint;\n        fireChangeEvent();\n    }\n\n    \n    public boolean isRangeGridlinesVisible() {\n        return this.rangeGridlinesVisible;\n    }\n\n    \n    public void setRangeGridlinesVisible(boolean visible) {\n        if (this.rangeGridlinesVisible != visible) {\n            this.rangeGridlinesVisible = visible;\n            fireChangeEvent();\n        }\n    }\n\n    \n    public Stroke getRangeGridlineStroke() {\n        return this.rangeGridlineStroke;\n    }\n\n    \n    public void setRangeGridlineStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");   \n        }\n        this.rangeGridlineStroke = stroke;\n        fireChangeEvent();\n    }\n\n    \n    public Paint getRangeGridlinePaint() {\n        return this.rangeGridlinePaint;\n    }\n\n    \n    public void setRangeGridlinePaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");   \n        }\n        this.rangeGridlinePaint = paint;\n        fireChangeEvent();\n    }\n    \n    \n    public LegendItemCollection getFixedLegendItems() {\n        return this.fixedLegendItems;   \n    }\n\n    \n    public void setFixedLegendItems(LegendItemCollection items) {\n        this.fixedLegendItems = items;\n        fireChangeEvent();\n    }\n    \n    \n    public LegendItemCollection getLegendItems() {\n        LegendItemCollection result = this.fixedLegendItems;\n        if (result == null) {\n            result = new LegendItemCollection();\n            \n            int count = this.datasets.size();\n            for (int datasetIndex = 0; datasetIndex < count; datasetIndex++) {\n                CategoryDataset dataset = getDataset(datasetIndex);\n                if (dataset != null) {\n                    CategoryItemRenderer renderer = getRenderer(datasetIndex);\n                    if (renderer != null) {\n                        int seriesCount = dataset.getRowCount();\n                        for (int i = 0; i < seriesCount; i++) {\n                            LegendItem item = renderer.getLegendItem(\n                                    datasetIndex, i);\n                            if (item != null) {\n                                result.add(item);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return result;\n    }\n\n    \n    public void handleClick(int x, int y, PlotRenderingInfo info) {\n\n        Rectangle2D dataArea = info.getDataArea();\n        if (dataArea.contains(x, y)) {\n            \n            double java2D = 0.0;\n            if (this.orientation == PlotOrientation.HORIZONTAL) {\n                java2D = x;\n            }\n            else if (this.orientation == PlotOrientation.VERTICAL) {\n                java2D = y;\n            }\n            RectangleEdge edge = Plot.resolveRangeAxisLocation(\n                    getRangeAxisLocation(), this.orientation);\n            double value = getRangeAxis().java2DToValue(\n                    java2D, info.getDataArea(), edge);\n            setAnchorValue(value);\n            setRangeCrosshairValue(value);\n        }\n\n    }\n\n    \n    public void zoom(double percent) {\n\n        if (percent > 0.0) {\n            double range = getRangeAxis().getRange().getLength();\n            double scaledRange = range * percent;\n            getRangeAxis().setRange(this.anchorValue - scaledRange / 2.0,\n                    this.anchorValue + scaledRange / 2.0);\n        }\n        else {\n            getRangeAxis().setAutoRange(true);\n        }\n\n    }\n\n    \n    public void datasetChanged(DatasetChangeEvent event) {\n\n        int count = this.rangeAxes.size();\n        for (int axisIndex = 0; axisIndex < count; axisIndex++) {\n            ValueAxis yAxis = getRangeAxis(axisIndex);\n            if (yAxis != null) {\n                yAxis.configure();\n            }\n        }\n        if (getParent() != null) {\n            getParent().datasetChanged(event);\n        }\n        else {\n            PlotChangeEvent e = new PlotChangeEvent(this);\n            e.setType(ChartChangeEventType.DATASET_UPDATED);\n            notifyListeners(e);\n        }\n\n    }\n\n    \n    public void rendererChanged(RendererChangeEvent event) {\n        Plot parent = getParent();\n        if (parent != null) {\n            if (parent instanceof RendererChangeListener) {\n                RendererChangeListener rcl = (RendererChangeListener) parent;\n                rcl.rendererChanged(event);\n            }\n            else {\n                \n                \n                throw new RuntimeException(\n                    \"The renderer has changed and I don't know what to do!\");\n            }\n        }\n        else {\n            configureRangeAxes();\n            PlotChangeEvent e = new PlotChangeEvent(this);\n            notifyListeners(e);\n        }\n    }\n    \n    \n    public void addDomainMarker(CategoryMarker marker) {\n        addDomainMarker(marker, Layer.FOREGROUND); \n    }\n        \n    \n    public void addDomainMarker(CategoryMarker marker, Layer layer) {\n        addDomainMarker(0, marker, layer);\n    }\n\n    \n    public void addDomainMarker(int index, CategoryMarker marker, Layer layer) {\n        addDomainMarker(index, marker, layer, true);\n    }\n    \t\n    \n    public void addDomainMarker(int index, CategoryMarker marker, Layer layer, boolean notify) {\n        if (marker == null) {\n            throw new IllegalArgumentException(\"Null 'marker' not permitted.\");\n        }\n        if (layer == null) {\n            throw new IllegalArgumentException(\"Null 'layer' not permitted.\");\n        }\n        Collection markers;\n        if (layer == Layer.FOREGROUND) {\n            markers = (Collection) this.foregroundDomainMarkers.get(\n                    new Integer(index));\n            if (markers == null) {\n                markers = new java.util.ArrayList();\n                this.foregroundDomainMarkers.put(new Integer(index), markers);\n            }\n            markers.add(marker);\n        }\n        else if (layer == Layer.BACKGROUND) {\n            markers = (Collection) this.backgroundDomainMarkers.get(\n                    new Integer(index));\n            if (markers == null) {\n                markers = new java.util.ArrayList();\n                this.backgroundDomainMarkers.put(new Integer(index), markers);\n            }\n            markers.add(marker);            \n        }\n        marker.addChangeListener(this);\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    \n    public void clearDomainMarkers() {\n        if (this.backgroundDomainMarkers != null) {\n            Set keys = this.backgroundDomainMarkers.keySet();\n            Iterator iterator = keys.iterator();\n            while (iterator.hasNext()) {\n                Integer key = (Integer) iterator.next();\n                clearDomainMarkers(key.intValue());\n            }\n            this.backgroundDomainMarkers.clear();\n        }\n        if (this.foregroundDomainMarkers != null) {\n            Set keys = this.foregroundDomainMarkers.keySet();\n            Iterator iterator = keys.iterator();\n            while (iterator.hasNext()) {\n                Integer key = (Integer) iterator.next();\n                clearDomainMarkers(key.intValue());\n            }\n            this.foregroundDomainMarkers.clear();\n        }\n        fireChangeEvent();\n    }\n\n    \n    public Collection getDomainMarkers(Layer layer) {\n        return getDomainMarkers(0, layer);\n    }\n\n    \n    public Collection getDomainMarkers(int index, Layer layer) {\n        Collection result = null;\n        Integer key = new Integer(index);\n        if (layer == Layer.FOREGROUND) {\n            result = (Collection) this.foregroundDomainMarkers.get(key);\n        }    \n        else if (layer == Layer.BACKGROUND) {\n            result = (Collection) this.backgroundDomainMarkers.get(key);\n        }\n        if (result != null) {\n            result = Collections.unmodifiableCollection(result);\n        }\n        return result;\n    }\n    \n    \n    public void clearDomainMarkers(int index) {\n        Integer key = new Integer(index);\n        if (this.backgroundDomainMarkers != null) {\n            Collection markers \n                = (Collection) this.backgroundDomainMarkers.get(key);\n            if (markers != null) {\n                Iterator iterator = markers.iterator();\n                while (iterator.hasNext()) {\n                    Marker m = (Marker) iterator.next();\n                    m.removeChangeListener(this);\n                }\n                markers.clear();\n            }\n        }\n        if (this.foregroundDomainMarkers != null) {\n            Collection markers \n                = (Collection) this.foregroundDomainMarkers.get(key);\n            if (markers != null) {\n                Iterator iterator = markers.iterator();\n                while (iterator.hasNext()) {\n                    Marker m = (Marker) iterator.next();\n                    m.removeChangeListener(this);\n                }\n                markers.clear();\n            }\n        }\n        fireChangeEvent();\n    }\n    \n    \n    public boolean removeDomainMarker(Marker marker) {\n        return removeDomainMarker(marker, Layer.FOREGROUND);\n    }\n\n    \n    public boolean removeDomainMarker(Marker marker, Layer layer) {\n        return removeDomainMarker(0, marker, layer);\n    }\n\n    \n    public boolean removeDomainMarker(int index, Marker marker, Layer layer) {\n    \treturn removeDomainMarker(index, marker, layer, true);\n    }\n\n    \n    public boolean removeDomainMarker(int index, Marker marker, Layer layer, boolean notify) {\n        ArrayList markers;\n        if (layer == Layer.FOREGROUND) {\n            markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer(\n                    index));\n        }\n        else {\n            markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                    index));\n        }\n        boolean removed = markers.remove(marker);\n        if (removed && notify) {\n            fireChangeEvent();\n        }\n        return removed;\n    }\n    \n    \n    public void addRangeMarker(Marker marker) {\n        addRangeMarker(marker, Layer.FOREGROUND); \n    }\n        \n    \n    public void addRangeMarker(Marker marker, Layer layer) {\n        addRangeMarker(0, marker, layer);\n    }\n\n    \n    public void addRangeMarker(int index, Marker marker, Layer layer) {\n    \taddRangeMarker(index, marker, layer, true);\n    }\n\n    \n    public void addRangeMarker(int index, Marker marker, Layer layer, boolean notify) {\n        Collection markers;\n        if (layer == Layer.FOREGROUND) {\n            markers = (Collection) this.foregroundRangeMarkers.get(\n                    new Integer(index));\n            if (markers == null) {\n                markers = new java.util.ArrayList();\n                this.foregroundRangeMarkers.put(new Integer(index), markers);\n            }\n            markers.add(marker);\n        }\n        else if (layer == Layer.BACKGROUND) {\n            markers = (Collection) this.backgroundRangeMarkers.get(\n                    new Integer(index));\n            if (markers == null) {\n                markers = new java.util.ArrayList();\n                this.backgroundRangeMarkers.put(new Integer(index), markers);\n            }\n            markers.add(marker);            \n        }\n        marker.addChangeListener(this);\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    \n    public void clearRangeMarkers() {\n        if (this.backgroundRangeMarkers != null) {\n            Set keys = this.backgroundRangeMarkers.keySet();\n            Iterator iterator = keys.iterator();\n            while (iterator.hasNext()) {\n                Integer key = (Integer) iterator.next();\n                clearRangeMarkers(key.intValue());\n            }\n            this.backgroundRangeMarkers.clear();\n        }\n        if (this.foregroundRangeMarkers != null) {\n            Set keys = this.foregroundRangeMarkers.keySet();\n            Iterator iterator = keys.iterator();\n            while (iterator.hasNext()) {\n                Integer key = (Integer) iterator.next();\n                clearRangeMarkers(key.intValue());\n            }\n            this.foregroundRangeMarkers.clear();\n        }\n        fireChangeEvent();\n    }\n\n    \n    public Collection getRangeMarkers(Layer layer) {\n        return getRangeMarkers(0, layer);\n    }\n\n    \n    public Collection getRangeMarkers(int index, Layer layer) {\n        Collection result = null;\n        Integer key = new Integer(index);\n        if (layer == Layer.FOREGROUND) {\n            result = (Collection) this.foregroundRangeMarkers.get(key);\n        }    \n        else if (layer == Layer.BACKGROUND) {\n            result = (Collection) this.backgroundRangeMarkers.get(key);\n        }\n        if (result != null) {\n            result = Collections.unmodifiableCollection(result);\n        }\n        return result;\n    }\n    \n    \n    public void clearRangeMarkers(int index) {\n        Integer key = new Integer(index);\n        if (this.backgroundRangeMarkers != null) {\n            Collection markers \n                = (Collection) this.backgroundRangeMarkers.get(key);\n            if (markers != null) {\n                Iterator iterator = markers.iterator();\n                while (iterator.hasNext()) {\n                    Marker m = (Marker) iterator.next();\n                    m.removeChangeListener(this);\n                }\n                markers.clear();\n            }\n        }\n        if (this.foregroundRangeMarkers != null) {\n            Collection markers \n                = (Collection) this.foregroundRangeMarkers.get(key);\n            if (markers != null) {\n                Iterator iterator = markers.iterator();\n                while (iterator.hasNext()) {\n                    Marker m = (Marker) iterator.next();\n                    m.removeChangeListener(this);\n                }\n                markers.clear();\n            }\n        }\n        fireChangeEvent();\n    }\n\n    \n    public boolean removeRangeMarker(Marker marker) {\n        return removeRangeMarker(marker, Layer.FOREGROUND);\n    }\n\n    \n    public boolean removeRangeMarker(Marker marker, Layer layer) {\n        return removeRangeMarker(0, marker, layer);\n    }\n\n    \n    public boolean removeRangeMarker(int index, Marker marker, Layer layer) {\n    \treturn removeRangeMarker(index, marker, layer, true);\n    }\n\n    \n    public boolean removeRangeMarker(int index, Marker marker, Layer layer, boolean notify) {\n        if (marker == null) {\n            throw new IllegalArgumentException(\"Null 'marker' argument.\");\n        }\n        ArrayList markers;\n        if (layer == Layer.FOREGROUND) {\n            markers = (ArrayList) this.foregroundRangeMarkers.get(new Integer(\n                    index));\n        }\n        else {\n            markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(\n                    index));\n        }\n        boolean removed = markers.remove(marker);\n        if (removed && notify) {\n            fireChangeEvent();\n        }\n        return removed;\n    }\n\n    \n    public boolean isRangeCrosshairVisible() {\n        return this.rangeCrosshairVisible;\n    }\n\n    \n    public void setRangeCrosshairVisible(boolean flag) {\n        if (this.rangeCrosshairVisible != flag) {\n            this.rangeCrosshairVisible = flag;\n            fireChangeEvent();\n        }\n    }\n\n    \n    public boolean isRangeCrosshairLockedOnData() {\n        return this.rangeCrosshairLockedOnData;\n    }\n\n    \n    public void setRangeCrosshairLockedOnData(boolean flag) {\n        if (this.rangeCrosshairLockedOnData != flag) {\n            this.rangeCrosshairLockedOnData = flag;\n            fireChangeEvent();\n        }\n    }\n\n    \n    public double getRangeCrosshairValue() {\n        return this.rangeCrosshairValue;\n    }\n\n    \n    public void setRangeCrosshairValue(double value) {\n        setRangeCrosshairValue(value, true);\n    }\n\n    \n    public void setRangeCrosshairValue(double value, boolean notify) {\n        this.rangeCrosshairValue = value;\n        if (isRangeCrosshairVisible() && notify) {\n            fireChangeEvent();\n        }\n    }\n\n    \n    public Stroke getRangeCrosshairStroke() {\n        return this.rangeCrosshairStroke;\n    }\n\n    \n    public void setRangeCrosshairStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");\n        }\n        this.rangeCrosshairStroke = stroke;\n        fireChangeEvent();\n    }\n\n    \n    public Paint getRangeCrosshairPaint() {\n        return this.rangeCrosshairPaint;\n    }\n\n    \n    public void setRangeCrosshairPaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.rangeCrosshairPaint = paint;\n        fireChangeEvent();\n    }\n\n    \n    public List getAnnotations() {\n        return this.annotations;\n    }\n\n    \n    public void addAnnotation(CategoryAnnotation annotation) {\n    \taddAnnotation(annotation, true);\n    }\n    \n    \n    public void addAnnotation(CategoryAnnotation annotation, boolean notify) {\n        if (annotation == null) {\n            throw new IllegalArgumentException(\"Null 'annotation' argument.\");\n        }\n        this.annotations.add(annotation);\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    \n    public boolean removeAnnotation(CategoryAnnotation annotation) {\n    \treturn removeAnnotation(annotation, true);\n    }\n\n    \n    public boolean removeAnnotation(CategoryAnnotation annotation, boolean notify) {\n        if (annotation == null) {\n            throw new IllegalArgumentException(\"Null 'annotation' argument.\");\n        }\n        boolean removed = this.annotations.remove(annotation);\n        if (removed && notify) {\n            fireChangeEvent();\n        }\n        return removed;\n    }\n\n    \n    public void clearAnnotations() {\n        this.annotations.clear();\n        fireChangeEvent();\n    }\n\n    \n    protected AxisSpace calculateDomainAxisSpace(Graphics2D g2, Rectangle2D plotArea, AxisSpace space) {\n                                                     \n        if (space == null) {\n            space = new AxisSpace();\n        }\n        \n        \n        if (this.fixedDomainAxisSpace != null) {\n            if (this.orientation == PlotOrientation.HORIZONTAL) {\n                space.ensureAtLeast(\n                    this.fixedDomainAxisSpace.getLeft(), RectangleEdge.LEFT);\n                space.ensureAtLeast(this.fixedDomainAxisSpace.getRight(), \n                        RectangleEdge.RIGHT);\n            }\n            else if (this.orientation == PlotOrientation.VERTICAL) {\n                space.ensureAtLeast(this.fixedDomainAxisSpace.getTop(), \n                        RectangleEdge.TOP);\n                space.ensureAtLeast(this.fixedDomainAxisSpace.getBottom(), \n                        RectangleEdge.BOTTOM);\n            }\n        }\n        else {\n            \n            RectangleEdge domainEdge = Plot.resolveDomainAxisLocation(\n                    getDomainAxisLocation(), this.orientation);\n            if (this.drawSharedDomainAxis) {\n                space = getDomainAxis().reserveSpace(g2, this, plotArea, \n                        domainEdge, space);\n            }\n            \n            \n            for (int i = 0; i < this.domainAxes.size(); i++) {\n                Axis xAxis = (Axis) this.domainAxes.get(i);\n                if (xAxis != null) {\n                    RectangleEdge edge = getDomainAxisEdge(i);\n                    space = xAxis.reserveSpace(g2, this, plotArea, edge, space);\n                }\n            }\n        }\n\n        return space;\n                                                     \n    }\n    \n    \n    protected AxisSpace calculateRangeAxisSpace(Graphics2D g2, Rectangle2D plotArea, AxisSpace space) {\n                                                  \n        if (space == null) {\n            space = new AxisSpace(); \n        }\n        \n        \n        if (this.fixedRangeAxisSpace != null) {\n            if (this.orientation == PlotOrientation.HORIZONTAL) {\n                space.ensureAtLeast(this.fixedRangeAxisSpace.getTop(), \n                        RectangleEdge.TOP);\n                space.ensureAtLeast(this.fixedRangeAxisSpace.getBottom(), \n                        RectangleEdge.BOTTOM);\n            }\n            else if (this.orientation == PlotOrientation.VERTICAL) {\n                space.ensureAtLeast(this.fixedRangeAxisSpace.getLeft(), \n                        RectangleEdge.LEFT);\n                space.ensureAtLeast(this.fixedRangeAxisSpace.getRight(), \n                        RectangleEdge.RIGHT);\n            }\n        }\n        else {\n            \n            for (int i = 0; i < this.rangeAxes.size(); i++) {\n                Axis yAxis = (Axis) this.rangeAxes.get(i);\n                if (yAxis != null) {\n                    RectangleEdge edge = getRangeAxisEdge(i);\n                    space = yAxis.reserveSpace(g2, this, plotArea, edge, space);\n                }\n            }\n        }\n        return space;\n                                                    \n    }\n\n    \n    protected AxisSpace calculateAxisSpace(Graphics2D g2, Rectangle2D plotArea) {\n        AxisSpace space = new AxisSpace();\n        space = calculateRangeAxisSpace(g2, plotArea, space);\n        space = calculateDomainAxisSpace(g2, plotArea, space);\n        return space;\n    }\n    \n    \n    public void draw(Graphics2D g2, Rectangle2D area, Point2D anchor, PlotState parentState, PlotRenderingInfo state) {\n\n        \n        boolean b1 = (area.getWidth() <= MINIMUM_WIDTH_TO_DRAW);\n        boolean b2 = (area.getHeight() <= MINIMUM_HEIGHT_TO_DRAW);\n        if (b1 || b2) {\n            return;\n        }\n\n        \n        if (state == null) {\n            \n            \n            \n            state = new PlotRenderingInfo(null);\n        }\n        state.setPlotArea(area);\n\n        \n        RectangleInsets insets = getInsets();\n        insets.trim(area);\n\n        \n        AxisSpace space = calculateAxisSpace(g2, area);\n        Rectangle2D dataArea = space.shrink(area, null);\n        this.axisOffset.trim(dataArea);\n\n        state.setDataArea(dataArea);\n\n        \n        \n        if (getRenderer() != null) {\n            getRenderer().drawBackground(g2, this, dataArea);\n        }\n        else {\n            drawBackground(g2, dataArea);\n        }\n       \n        Map axisStateMap = drawAxes(g2, area, dataArea, state);\n\n        \n        Shape savedClip = g2.getClip();\n        g2.clip(dataArea);\n\n        drawDomainGridlines(g2, dataArea);\n\n        AxisState rangeAxisState = (AxisState) axisStateMap.get(getRangeAxis());\n        if (rangeAxisState == null) {\n            if (parentState != null) {\n                rangeAxisState = (AxisState) parentState.getSharedAxisStates()\n                        .get(getRangeAxis());\n            }\n        }\n        if (rangeAxisState != null) {\n            drawRangeGridlines(g2, dataArea, rangeAxisState.getTicks());\n        }\n        \n        \n        for (int i = 0; i < this.renderers.size(); i++) {\n            drawDomainMarkers(g2, dataArea, i, Layer.BACKGROUND);\n        }        \n        for (int i = 0; i < this.renderers.size(); i++) {\n            drawRangeMarkers(g2, dataArea, i, Layer.BACKGROUND);\n        }\n\n        \n        boolean foundData = false;\n\n        \n        Composite originalComposite = g2.getComposite();\n        g2.setComposite(AlphaComposite.getInstance(\n                AlphaComposite.SRC_OVER, getForegroundAlpha()));\n\n        DatasetRenderingOrder order = getDatasetRenderingOrder();\n        if (order == DatasetRenderingOrder.FORWARD) {\n\n            \n            int datasetCount = this.datasets.size();\n            for (int i = 0; i < datasetCount; i++) {\n                CategoryItemRenderer r = getRenderer(i);\n                if (r != null) {\n                    CategoryAxis domainAxis = getDomainAxisForDataset(i);\n                    ValueAxis rangeAxis = getRangeAxisForDataset(i);\n                    r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis,\n                            Layer.BACKGROUND, state);\n                }\n            }\n\n            for (int i = 0; i < datasetCount; i++) {\n                foundData = render(g2, dataArea, i, state) || foundData;\n            }\n\n            \n            for (int i = 0; i < datasetCount; i++) {\n                CategoryItemRenderer r = getRenderer(i);\n                if (r != null) {\n                    CategoryAxis domainAxis = getDomainAxisForDataset(i);\n                    ValueAxis rangeAxis = getRangeAxisForDataset(i);\n                    r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis,\n                            Layer.FOREGROUND, state);\n                }\n            }\n        }\n        else {  \n            \n            \n            int datasetCount = this.datasets.size();\n            for (int i = datasetCount - 1; i >= 0; i--) {\n                CategoryItemRenderer r = getRenderer(i);\n                if (r != null) {\n                    CategoryAxis domainAxis = getDomainAxisForDataset(i);\n                    ValueAxis rangeAxis = getRangeAxisForDataset(i);\n                    r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis,\n                            Layer.BACKGROUND, state);\n                }\n            }\n            \n            for (int i = this.datasets.size() - 1; i >= 0; i--) {\n                foundData = render(g2, dataArea, i, state) || foundData;   \n            }\n\n            \n            for (int i = datasetCount - 1; i >= 0; i--) {\n                CategoryItemRenderer r = getRenderer(i);\n                if (r != null) {\n                    CategoryAxis domainAxis = getDomainAxisForDataset(i);\n                    ValueAxis rangeAxis = getRangeAxisForDataset(i);\n                    r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis,\n                            Layer.FOREGROUND, state);\n                }\n            }\n        }\n        \n        \n        for (int i = 0; i < this.renderers.size(); i++) {\n            drawDomainMarkers(g2, dataArea, i, Layer.FOREGROUND);\n        }\n        for (int i = 0; i < this.renderers.size(); i++) {\n            drawRangeMarkers(g2, dataArea, i, Layer.FOREGROUND);\n        }\n\n        \n        drawAnnotations(g2, dataArea, state);\n\n        g2.setClip(savedClip);\n        g2.setComposite(originalComposite);\n\n        if (!foundData) {\n            drawNoDataMessage(g2, dataArea);\n        }\n\n        \n        if (isRangeCrosshairVisible()) {\n            \n            drawRangeCrosshair(g2, dataArea, getOrientation(), \n                    getRangeCrosshairValue(), getRangeAxis(),\n                    getRangeCrosshairStroke(), getRangeCrosshairPaint());\n        }\n\n        \n        if (getRenderer() != null) {\n            getRenderer().drawOutline(g2, this, dataArea);\n        }\n        else {\n            drawOutline(g2, dataArea);\n        }\n\n    }\n\n    \n    public void drawBackground(Graphics2D g2, Rectangle2D area) {\n        fillBackground(g2, area, this.orientation);\n        drawBackgroundImage(g2, area);\n    }\n\n    \n    protected Map drawAxes(Graphics2D g2, Rectangle2D plotArea, Rectangle2D dataArea, PlotRenderingInfo plotState) {\n\n        AxisCollection axisCollection = new AxisCollection();\n\n        \n        for (int index = 0; index < this.domainAxes.size(); index++) {\n            CategoryAxis xAxis = (CategoryAxis) this.domainAxes.get(index);\n            if (xAxis != null) {\n                axisCollection.add(xAxis, getDomainAxisEdge(index));\n            }\n        }\n\n        \n        for (int index = 0; index < this.rangeAxes.size(); index++) {\n            ValueAxis yAxis = (ValueAxis) this.rangeAxes.get(index);\n            if (yAxis != null) {\n                axisCollection.add(yAxis, getRangeAxisEdge(index));\n            }\n        }\n\n        Map axisStateMap = new HashMap();\n        \n        \n        double cursor = dataArea.getMinY() - this.axisOffset.calculateTopOutset(\n                dataArea.getHeight());\n        Iterator iterator = axisCollection.getAxesAtTop().iterator();\n        while (iterator.hasNext()) {\n            Axis axis = (Axis) iterator.next();\n            if (axis != null) {\n                AxisState axisState = axis.draw(g2, cursor, plotArea, dataArea, \n                        RectangleEdge.TOP, plotState);\n                cursor = axisState.getCursor();\n                axisStateMap.put(axis, axisState);\n            }\n        }\n\n        \n        cursor = dataArea.getMaxY() \n                 + this.axisOffset.calculateBottomOutset(dataArea.getHeight());\n        iterator = axisCollection.getAxesAtBottom().iterator();\n        while (iterator.hasNext()) {\n            Axis axis = (Axis) iterator.next();\n            if (axis != null) {\n                AxisState axisState = axis.draw(g2, cursor, plotArea, dataArea,\n                        RectangleEdge.BOTTOM, plotState);\n                cursor = axisState.getCursor();\n                axisStateMap.put(axis, axisState);\n            }\n        }\n\n        \n        cursor = dataArea.getMinX() \n                 - this.axisOffset.calculateLeftOutset(dataArea.getWidth());\n        iterator = axisCollection.getAxesAtLeft().iterator();\n        while (iterator.hasNext()) {\n            Axis axis = (Axis) iterator.next();\n            if (axis != null) {\n                AxisState axisState = axis.draw(g2, cursor, plotArea, dataArea,\n                        RectangleEdge.LEFT, plotState);\n                cursor = axisState.getCursor();\n                axisStateMap.put(axis, axisState);\n            }\n        }\n\n        \n        cursor = dataArea.getMaxX() \n                 + this.axisOffset.calculateRightOutset(dataArea.getWidth());\n        iterator = axisCollection.getAxesAtRight().iterator();\n        while (iterator.hasNext()) {\n            Axis axis = (Axis) iterator.next();\n            if (axis != null) {\n                AxisState axisState = axis.draw(g2, cursor, plotArea, dataArea, \n                        RectangleEdge.RIGHT, plotState);\n                cursor = axisState.getCursor();\n                axisStateMap.put(axis, axisState);\n            }\n        }\n        \n        return axisStateMap;\n        \n    }\n\n    \n    public boolean render(Graphics2D g2, Rectangle2D dataArea, int index, PlotRenderingInfo info) {\n\n        boolean foundData = false;\n        CategoryDataset currentDataset = getDataset(index);\n        CategoryItemRenderer renderer = getRenderer(index);\n        CategoryAxis domainAxis = getDomainAxisForDataset(index);\n        ValueAxis rangeAxis = getRangeAxisForDataset(index);\n        boolean hasData = !DatasetUtilities.isEmptyOrNull(currentDataset);\n        if (hasData && renderer != null) {\n            \n            foundData = true;\n            CategoryItemRendererState state = renderer.initialise(g2, dataArea,\n                    this, index, info);\n            int columnCount = currentDataset.getColumnCount();\n            int rowCount = currentDataset.getRowCount();\n            int passCount = renderer.getPassCount();\n            for (int pass = 0; pass < passCount; pass++) {            \n                if (this.columnRenderingOrder == SortOrder.ASCENDING) {\n                    for (int column = 0; column < columnCount; column++) {\n                        if (this.rowRenderingOrder == SortOrder.ASCENDING) {\n                            for (int row = 0; row < rowCount; row++) {\n                                renderer.drawItem(g2, state, dataArea, this, \n                                        domainAxis, rangeAxis, currentDataset, \n                                        row, column, pass);\n                            }\n                        }\n                        else {\n                            for (int row = rowCount - 1; row >= 0; row--) {\n                                renderer.drawItem(g2, state, dataArea, this, \n                                        domainAxis, rangeAxis, currentDataset, \n                                        row, column, pass);\n                            }                        \n                        }\n                    }\n                }\n                else {\n                    for (int column = columnCount - 1; column >= 0; column--) {\n                        if (this.rowRenderingOrder == SortOrder.ASCENDING) {\n                            for (int row = 0; row < rowCount; row++) {\n                                renderer.drawItem(g2, state, dataArea, this, \n                                        domainAxis, rangeAxis, currentDataset, \n                                        row, column, pass);\n                            }\n                        }\n                        else {\n                            for (int row = rowCount - 1; row >= 0; row--) {\n                                renderer.drawItem(g2, state, dataArea, this, \n                                        domainAxis, rangeAxis, currentDataset, \n                                        row, column, pass);\n                            }                        \n                        }\n                    }\n                }\n            }\n        }\n        return foundData;\n        \n    }\n\n    \n    protected void drawDomainGridlines(Graphics2D g2, Rectangle2D dataArea) {\n\n        \n        if (isDomainGridlinesVisible()) {\n            CategoryAnchor anchor = getDomainGridlinePosition();\n            RectangleEdge domainAxisEdge = getDomainAxisEdge();\n            Stroke gridStroke = getDomainGridlineStroke();\n            Paint gridPaint = getDomainGridlinePaint();\n            if ((gridStroke != null) && (gridPaint != null)) {\n                \n                CategoryDataset data = getDataset();\n                if (data != null) {\n                    CategoryAxis axis = getDomainAxis();\n                    if (axis != null) {\n                        int columnCount = data.getColumnCount();\n                        for (int c = 0; c < columnCount; c++) {\n                            double xx = axis.getCategoryJava2DCoordinate(\n                                    anchor, c, columnCount, dataArea, \n                                    domainAxisEdge);\n                            CategoryItemRenderer renderer1 = getRenderer();\n                            if (renderer1 != null) {\n                                renderer1.drawDomainGridline(g2, this, \n                                        dataArea, xx);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n \n    \n    protected void drawRangeGridlines(Graphics2D g2, Rectangle2D dataArea, List ticks) {\n        \n        if (isRangeGridlinesVisible()) {\n            Stroke gridStroke = getRangeGridlineStroke();\n            Paint gridPaint = getRangeGridlinePaint();\n            if ((gridStroke != null) && (gridPaint != null)) {\n                ValueAxis axis = getRangeAxis();\n                if (axis != null) {\n                    Iterator iterator = ticks.iterator();\n                    while (iterator.hasNext()) {\n                        ValueTick tick = (ValueTick) iterator.next();\n                        CategoryItemRenderer renderer1 = getRenderer();\n                        if (renderer1 != null) {\n                            renderer1.drawRangeGridline(g2, this, \n                                    getRangeAxis(), dataArea, tick.getValue());\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    \n    protected void drawAnnotations(Graphics2D g2, Rectangle2D dataArea, PlotRenderingInfo info) {\n\n        Iterator iterator = getAnnotations().iterator();\n        while (iterator.hasNext()) {\n            CategoryAnnotation annotation \n                    = (CategoryAnnotation) iterator.next();\n            annotation.draw(g2, this, dataArea, getDomainAxis(), \n                    getRangeAxis(), 0, info);\n        }\n\n    }\n\n    \n    protected void drawDomainMarkers(Graphics2D g2, Rectangle2D dataArea, int index, Layer layer) {\n                                                 \n        CategoryItemRenderer r = getRenderer(index);\n        if (r == null) {\n            return;\n        }\n        \n        Collection markers = getDomainMarkers(index, layer);\n        CategoryAxis axis = getDomainAxisForDataset(index);\n        if (markers != null && axis != null) {\n            Iterator iterator = markers.iterator();\n            while (iterator.hasNext()) {\n                CategoryMarker marker = (CategoryMarker) iterator.next();\n                r.drawDomainMarker(g2, this, axis, marker, dataArea);\n            }\n        }\n        \n    }\n\n    \n    protected void drawRangeMarkers(Graphics2D g2, Rectangle2D dataArea, int index, Layer layer) {\n                                                 \n        CategoryItemRenderer r = getRenderer(index);\n        if (r == null) {\n            return;\n        }\n        \n        Collection markers = getRangeMarkers(index, layer);\n        ValueAxis axis = getRangeAxisForDataset(index);\n        if (markers != null && axis != null) {\n            Iterator iterator = markers.iterator();\n            while (iterator.hasNext()) {\n                Marker marker = (Marker) iterator.next();\n                r.drawRangeMarker(g2, this, axis, marker, dataArea);\n            }\n        }\n        \n    }\n\n    \n    protected void drawRangeLine(Graphics2D g2, Rectangle2D dataArea, double value, Stroke stroke, Paint paint) {\n\n        double java2D = getRangeAxis().valueToJava2D(value, dataArea, \n                getRangeAxisEdge());\n        Line2D line = null;\n        if (this.orientation == PlotOrientation.HORIZONTAL) {\n            line = new Line2D.Double(java2D, dataArea.getMinY(), java2D, \n                    dataArea.getMaxY());\n        }\n        else if (this.orientation == PlotOrientation.VERTICAL) {\n            line = new Line2D.Double(dataArea.getMinX(), java2D, \n                    dataArea.getMaxX(), java2D);\n        }\n        g2.setStroke(stroke);\n        g2.setPaint(paint);\n        g2.draw(line);\n\n    }\n\n    \n    protected void drawRangeCrosshair(Graphics2D g2, Rectangle2D dataArea, PlotOrientation orientation, double value, ValueAxis axis, Stroke stroke, Paint paint) {\n        \n        if (!axis.getRange().contains(value)) {\n            return;\n        }\n        Line2D line = null;\n        if (orientation == PlotOrientation.HORIZONTAL) {\n            double xx = axis.valueToJava2D(value, dataArea, \n                    RectangleEdge.BOTTOM);\n            line = new Line2D.Double(xx, dataArea.getMinY(), xx, \n                    dataArea.getMaxY());\n        }\n        else {\n            double yy = axis.valueToJava2D(value, dataArea, \n                    RectangleEdge.LEFT);\n            line = new Line2D.Double(dataArea.getMinX(), yy, \n                    dataArea.getMaxX(), yy);\n        }\n        g2.setStroke(stroke);\n        g2.setPaint(paint);\n        g2.draw(line);\n       \n    }\n    \n    \n    public Range getDataRange(ValueAxis axis) {\n\n        Range result = null;\n        List mappedDatasets = new ArrayList();\n        \n        int rangeIndex = this.rangeAxes.indexOf(axis);\n        if (rangeIndex >= 0) {\n            mappedDatasets.addAll(datasetsMappedToRangeAxis(rangeIndex));\n        }\n        else if (axis == getRangeAxis()) {\n            mappedDatasets.addAll(datasetsMappedToRangeAxis(0));\n        }\n\n        \n        \n        Iterator iterator = mappedDatasets.iterator();\n        while (iterator.hasNext()) {\n            CategoryDataset d = (CategoryDataset) iterator.next();\n            CategoryItemRenderer r = getRendererForDataset(d);\n            if (r != null) {\n                result = Range.combine(result, r.findRangeBounds(d));\n            }\n        }\n        return result;\n\n    }\n\n    \n    private List datasetsMappedToDomainAxis(int axisIndex) {\n        List result = new ArrayList();\n        for (int datasetIndex = 0; datasetIndex < this.datasets.size(); \n                datasetIndex++) {\n            Object dataset = this.datasets.get(datasetIndex);\n            if (dataset != null) {\n                Integer m = (Integer) this.datasetToDomainAxisMap.get(\n                        datasetIndex);\n                if (m == null) {  \n                                  \n                    if (axisIndex == 0) {\n                        result.add(dataset);\n                    }\n                }\n                else {\n                    if (m.intValue() == axisIndex) {\n                        result.add(dataset);\n                    }\n                }\n            }\n        }\n        return result;\n    }\n    \n    \n    private List datasetsMappedToRangeAxis(int index) {\n        List result = new ArrayList();\n        for (int i = 0; i < this.datasets.size(); i++) {\n            Object dataset = this.datasets.get(i);\n            if (dataset != null) {\n                Integer m = (Integer) this.datasetToRangeAxisMap.get(i);\n                if (m == null) {  \n                                  \n                    if (index == 0) { \n                        result.add(dataset);\n                    }\n                }\n                else {\n                    if (m.intValue() == index) {\n                        result.add(dataset);\n                    }\n                }\n            }\n        }\n        return result;    \n    }\n\n    \n    public int getWeight() {\n        return this.weight;\n    }\n\n    \n    public void setWeight(int weight) {\n        this.weight = weight;\n        fireChangeEvent();\n    }\n    \n    \n    public AxisSpace getFixedDomainAxisSpace() {\n        return this.fixedDomainAxisSpace;\n    }\n\n    \n    public void setFixedDomainAxisSpace(AxisSpace space) {\n        setFixedDomainAxisSpace(space, true);\n    }\n\n    \n    public void setFixedDomainAxisSpace(AxisSpace space, boolean notify) {\n        this.fixedDomainAxisSpace = space;\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    \n    public AxisSpace getFixedRangeAxisSpace() {\n        return this.fixedRangeAxisSpace;\n    }\n\n    \n    public void setFixedRangeAxisSpace(AxisSpace space) {\n        setFixedRangeAxisSpace(space, true);\n    }\n\n    \n    public void setFixedRangeAxisSpace(AxisSpace space, boolean notify) {\n        this.fixedRangeAxisSpace = space;\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    \n    public List getCategories() {\n        List result = null;\n        if (getDataset() != null) {\n            result = Collections.unmodifiableList(getDataset().getColumnKeys());\n        }\n        return result;\n    }\n    \n    \n    public List getCategoriesForAxis(CategoryAxis axis) {\n        List result = new ArrayList();\n        int axisIndex = this.domainAxes.indexOf(axis);\n        List datasets = datasetsMappedToDomainAxis(axisIndex);\n        Iterator iterator = datasets.iterator();\n        while (iterator.hasNext()) {\n            CategoryDataset dataset = (CategoryDataset) iterator.next();\n            \n            for (int i = 0; i < dataset.getColumnCount(); i++) {\n                Comparable category = dataset.getColumnKey(i);\n                if (!result.contains(category)) {\n                    result.add(category);\n                }\n            }\n        }\n        return result;\n    }\n\n    \n    public boolean getDrawSharedDomainAxis() {\n        return this.drawSharedDomainAxis;\n    }\n    \n    \n    public void setDrawSharedDomainAxis(boolean draw) {\n        this.drawSharedDomainAxis = draw;\n        fireChangeEvent();\n    }\n\n    \n    public boolean isDomainZoomable() {\n        return false;\n    }\n    \n    \n    public boolean isRangeZoomable() {\n        return true;\n    }\n\n    \n    public void zoomDomainAxes(double factor, PlotRenderingInfo state, Point2D source) {\n        \n    }\n\n    \n    public void zoomDomainAxes(double lowerPercent, double upperPercent, PlotRenderingInfo state, Point2D source) {\n        \n    }\n    \n    \n    public void zoomDomainAxes(double factor, PlotRenderingInfo info, Point2D source, boolean useAnchor) {\n        \n    }\n\n    \n    public void zoomRangeAxes(double factor, PlotRenderingInfo state, Point2D source) {\n        \n        zoomRangeAxes(factor, state, source, false);    \n    }\n\n    \n    public void zoomRangeAxes(double factor, PlotRenderingInfo info, Point2D source, boolean useAnchor) {\n                \n        \n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis rangeAxis = (ValueAxis) this.rangeAxes.get(i);\n            if (rangeAxis != null) {\n                if (useAnchor) {\n                    \n                    \n                    double sourceY = source.getY();\n                    if (this.orientation == PlotOrientation.HORIZONTAL) {\n                        sourceY = source.getX();\n                    }\n                    double anchorY = rangeAxis.java2DToValue(sourceY, \n                            info.getDataArea(), getRangeAxisEdge());\n                    rangeAxis.resizeRange(factor, anchorY);\n                }\n                else {\n                    rangeAxis.resizeRange(factor);\n                }\n            }\n        }\n    }\n\n    \n    public void zoomRangeAxes(double lowerPercent, double upperPercent, PlotRenderingInfo state, Point2D source) {\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis rangeAxis = (ValueAxis) this.rangeAxes.get(i);\n            if (rangeAxis != null) {\n                rangeAxis.zoomRange(lowerPercent, upperPercent);\n            }\n        }\n    }\n    \n    \n    public double getAnchorValue() {\n        return this.anchorValue;\n    }\n\n    \n    public void setAnchorValue(double value) {\n        setAnchorValue(value, true);\n    }\n\n    \n    public void setAnchorValue(double value, boolean notify) {\n        this.anchorValue = value;\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n    \n    \n    public boolean equals(Object obj) {\n    \n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof CategoryPlot)) {\n            return false;\n        }\n        if (!super.equals(obj)) {\n            return false;\n        }\n\n        CategoryPlot that = (CategoryPlot) obj;\n            \n        if (this.orientation != that.orientation) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.axisOffset, that.axisOffset)) {\n            return false;\n        }\n        if (!this.domainAxes.equals(that.domainAxes)) {\n            return false;\n        }\n        if (!this.domainAxisLocations.equals(that.domainAxisLocations)) {\n            return false;\n        }\n        if (this.drawSharedDomainAxis != that.drawSharedDomainAxis) {\n            return false;\n        }\n        if (!this.rangeAxes.equals(that.rangeAxes)) {\n            return false;\n        }\n        if (!this.rangeAxisLocations.equals(that.rangeAxisLocations)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.datasetToDomainAxisMap, \n                that.datasetToDomainAxisMap)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.datasetToRangeAxisMap, \n                that.datasetToRangeAxisMap)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.renderers, that.renderers)) {\n            return false;\n        }\n        if (this.renderingOrder != that.renderingOrder) {\n            return false;\n        }\n        if (this.columnRenderingOrder != that.columnRenderingOrder) {\n            return false;\n        }\n        if (this.rowRenderingOrder != that.rowRenderingOrder) {\n            return false;\n        }\n        if (this.domainGridlinesVisible != that.domainGridlinesVisible) {\n            return false;\n        }\n        if (this.domainGridlinePosition != that.domainGridlinePosition) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.domainGridlineStroke, \n                that.domainGridlineStroke)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.domainGridlinePaint, \n                that.domainGridlinePaint)) {\n            return false;\n        }\n        if (this.rangeGridlinesVisible != that.rangeGridlinesVisible) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.rangeGridlineStroke, \n                that.rangeGridlineStroke)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.rangeGridlinePaint, \n                that.rangeGridlinePaint)) {\n            return false;\n        }\n        if (this.anchorValue != that.anchorValue) {\n            return false;\n        }\n        if (this.rangeCrosshairVisible != that.rangeCrosshairVisible) {\n            return false;\n        }\n        if (this.rangeCrosshairValue != that.rangeCrosshairValue) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.rangeCrosshairStroke, \n                that.rangeCrosshairStroke)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.rangeCrosshairPaint, \n                that.rangeCrosshairPaint)) {\n            return false;\n        }\n        if (this.rangeCrosshairLockedOnData \n                != that.rangeCrosshairLockedOnData) {\n            return false;\n        }      \n        if (!ObjectUtilities.equal(this.foregroundRangeMarkers, \n                that.foregroundRangeMarkers)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.backgroundRangeMarkers, \n                that.backgroundRangeMarkers)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.annotations, that.annotations)) {\n            return false;\n        }\n        if (this.weight != that.weight) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.fixedDomainAxisSpace, \n                that.fixedDomainAxisSpace)) {\n            return false;\n        }    \n        if (!ObjectUtilities.equal(this.fixedRangeAxisSpace, \n                that.fixedRangeAxisSpace)) {\n            return false;\n        }    \n        \n        return true;\n        \n    }\n    \n    \n    public Object clone() throws CloneNotSupportedException {\n        \n        CategoryPlot clone = (CategoryPlot) super.clone();\n        \n        clone.domainAxes = new ObjectList();\n        for (int i = 0; i < this.domainAxes.size(); i++) {\n            CategoryAxis xAxis = (CategoryAxis) this.domainAxes.get(i);\n            if (xAxis != null) {\n                CategoryAxis clonedAxis = (CategoryAxis) xAxis.clone();\n                clone.setDomainAxis(i, clonedAxis);\n            }\n        }\n        clone.domainAxisLocations \n            = (ObjectList) this.domainAxisLocations.clone();\n\n        clone.rangeAxes = new ObjectList();\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis yAxis = (ValueAxis) this.rangeAxes.get(i);\n            if (yAxis != null) {\n                ValueAxis clonedAxis = (ValueAxis) yAxis.clone();\n                clone.setRangeAxis(i, clonedAxis);\n            }\n        }\n        clone.rangeAxisLocations = (ObjectList) this.rangeAxisLocations.clone();\n\n        clone.datasets = (ObjectList) this.datasets.clone();\n        for (int i = 0; i < clone.datasets.size(); i++) {\n            CategoryDataset dataset = clone.getDataset(i);\n            if (dataset != null) {\n                dataset.addChangeListener(clone);\n            }\n        }\n        clone.datasetToDomainAxisMap \n            = (ObjectList) this.datasetToDomainAxisMap.clone();\n        clone.datasetToRangeAxisMap \n            = (ObjectList) this.datasetToRangeAxisMap.clone();\n        clone.renderers = (ObjectList) this.renderers.clone();\n        if (this.fixedDomainAxisSpace != null) {\n            clone.fixedDomainAxisSpace = (AxisSpace) ObjectUtilities.clone(\n                    this.fixedDomainAxisSpace);\n        }\n        if (this.fixedRangeAxisSpace != null) {\n            clone.fixedRangeAxisSpace = (AxisSpace) ObjectUtilities.clone(\n                    this.fixedRangeAxisSpace);\n        }\n        \n        return clone;\n            \n    }\n    \n    \n    private void writeObject(ObjectOutputStream stream) throws IOException {\n        stream.defaultWriteObject();\n        SerialUtilities.writeStroke(this.domainGridlineStroke, stream);\n        SerialUtilities.writePaint(this.domainGridlinePaint, stream);\n        SerialUtilities.writeStroke(this.rangeGridlineStroke, stream);\n        SerialUtilities.writePaint(this.rangeGridlinePaint, stream);\n        SerialUtilities.writeStroke(this.rangeCrosshairStroke, stream);\n        SerialUtilities.writePaint(this.rangeCrosshairPaint, stream);\n    }\n\n    \n    private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {\n\n        stream.defaultReadObject();\n        this.domainGridlineStroke = SerialUtilities.readStroke(stream);\n        this.domainGridlinePaint = SerialUtilities.readPaint(stream);\n        this.rangeGridlineStroke = SerialUtilities.readStroke(stream);\n        this.rangeGridlinePaint = SerialUtilities.readPaint(stream);\n        this.rangeCrosshairStroke = SerialUtilities.readStroke(stream);\n        this.rangeCrosshairPaint = SerialUtilities.readPaint(stream);\n\n        for (int i = 0; i < this.domainAxes.size(); i++) {\n            CategoryAxis xAxis = (CategoryAxis) this.domainAxes.get(i);\n            if (xAxis != null) {\n                xAxis.setPlot(this);\n                xAxis.addChangeListener(this);\n            }\n        } \n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis yAxis = (ValueAxis) this.rangeAxes.get(i);\n            if (yAxis != null) {\n                yAxis.setPlot(this);   \n                yAxis.addChangeListener(this);\n            }\n        }\n        int datasetCount = this.datasets.size();\n        for (int i = 0; i < datasetCount; i++) {\n            Dataset dataset = (Dataset) this.datasets.get(i);\n            if (dataset != null) {\n                dataset.addChangeListener(this);\n            }\n        }\n        int rendererCount = this.renderers.size();\n        for (int i = 0; i < rendererCount; i++) {\n            CategoryItemRenderer renderer \n                = (CategoryItemRenderer) this.renderers.get(i);\n            if (renderer != null) {\n                renderer.addChangeListener(this);\n            }\n        }\n\n    }\n\n}\n",
      "fixed_full_code": "\n\npackage org.jfree.chart.plot;\n\nimport java.awt.AlphaComposite;\nimport java.awt.BasicStroke;\nimport java.awt.Color;\nimport java.awt.Composite;\nimport java.awt.Font;\nimport java.awt.Graphics2D;\nimport java.awt.Paint;\nimport java.awt.Shape;\nimport java.awt.Stroke;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.ResourceBundle;\nimport java.util.Set;\n\nimport org.jfree.chart.LegendItem;\nimport org.jfree.chart.LegendItemCollection;\nimport org.jfree.chart.annotations.CategoryAnnotation;\nimport org.jfree.chart.axis.Axis;\nimport org.jfree.chart.axis.AxisCollection;\nimport org.jfree.chart.axis.AxisLocation;\nimport org.jfree.chart.axis.AxisSpace;\nimport org.jfree.chart.axis.AxisState;\nimport org.jfree.chart.axis.CategoryAnchor;\nimport org.jfree.chart.axis.CategoryAxis;\nimport org.jfree.chart.axis.ValueAxis;\nimport org.jfree.chart.axis.ValueTick;\nimport org.jfree.chart.event.ChartChangeEventType;\nimport org.jfree.chart.event.PlotChangeEvent;\nimport org.jfree.chart.event.RendererChangeEvent;\nimport org.jfree.chart.event.RendererChangeListener;\nimport org.jfree.chart.renderer.category.CategoryItemRenderer;\nimport org.jfree.chart.renderer.category.CategoryItemRendererState;\nimport org.jfree.chart.util.Layer;\nimport org.jfree.chart.util.ObjectList;\nimport org.jfree.chart.util.ObjectUtilities;\nimport org.jfree.chart.util.PaintUtilities;\nimport org.jfree.chart.util.PublicCloneable;\nimport org.jfree.chart.util.RectangleEdge;\nimport org.jfree.chart.util.RectangleInsets;\nimport org.jfree.chart.util.SerialUtilities;\nimport org.jfree.chart.util.SortOrder;\nimport org.jfree.data.Range;\nimport org.jfree.data.category.CategoryDataset;\nimport org.jfree.data.general.Dataset;\nimport org.jfree.data.general.DatasetChangeEvent;\nimport org.jfree.data.general.DatasetUtilities;\n\n\npublic class CategoryPlot extends Plot implements ValueAxisPlot, Zoomable, RendererChangeListener, Cloneable, PublicCloneable, Serializable { private static final long serialVersionUID = -3537691700434728188L; public static final boolean DEFAULT_DOMAIN_GRIDLINES_VISIBLE = false; public static final boolean DEFAULT_RANGE_GRIDLINES_VISIBLE = true; public static final Stroke DEFAULT_GRIDLINE_STROKE = new BasicStroke(0.5f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL, 0.0f, new float[] {2.0f, 2.0f}, 0.0f); public static final Paint DEFAULT_GRIDLINE_PAINT = Color.WHITE; public static final Font DEFAULT_VALUE_LABEL_FONT = new Font(\"SansSerif\", Font.PLAIN, 10); public static final boolean DEFAULT_CROSSHAIR_VISIBLE = false; public static final Stroke DEFAULT_CROSSHAIR_STROKE = DEFAULT_GRIDLINE_STROKE; public static final Paint DEFAULT_CROSSHAIR_PAINT = Color.blue; protected static ResourceBundle localizationResources = ResourceBundle.getBundle( \"org.jfree.chart.plot.LocalizationBundle\"); private PlotOrientation orientation; private RectangleInsets axisOffset; private ObjectList domainAxes; private ObjectList domainAxisLocations; private boolean drawSharedDomainAxis; private ObjectList rangeAxes; private ObjectList rangeAxisLocations; private ObjectList datasets; private ObjectList datasetToDomainAxisMap; private ObjectList datasetToRangeAxisMap; private ObjectList renderers; private DatasetRenderingOrder renderingOrder = DatasetRenderingOrder.REVERSE; private SortOrder columnRenderingOrder = SortOrder.ASCENDING; private SortOrder rowRenderingOrder = SortOrder.ASCENDING; private boolean domainGridlinesVisible; private CategoryAnchor domainGridlinePosition; private transient Stroke domainGridlineStroke; private transient Paint domainGridlinePaint; private boolean rangeGridlinesVisible; private transient Stroke rangeGridlineStroke; private transient Paint rangeGridlinePaint; private double anchorValue; private boolean rangeCrosshairVisible; private double rangeCrosshairValue; private transient Stroke rangeCrosshairStroke; private transient Paint rangeCrosshairPaint; private boolean rangeCrosshairLockedOnData = true; private Map foregroundDomainMarkers; private Map backgroundDomainMarkers; private Map foregroundRangeMarkers; private Map backgroundRangeMarkers; private List annotations; private int weight; private AxisSpace fixedDomainAxisSpace; private AxisSpace fixedRangeAxisSpace; private LegendItemCollection fixedLegendItems; public CategoryPlot() {\n        this(null, null, null, null);\n    }\n\n    \n    public CategoryPlot(CategoryDataset dataset, CategoryAxis domainAxis, ValueAxis rangeAxis, CategoryItemRenderer renderer) {\n\n        super();\n\n        this.orientation = PlotOrientation.VERTICAL;\n\n        \n        this.domainAxes = new ObjectList();\n        this.domainAxisLocations = new ObjectList();\n        this.rangeAxes = new ObjectList();\n        this.rangeAxisLocations = new ObjectList();\n        \n        this.datasetToDomainAxisMap = new ObjectList();\n        this.datasetToRangeAxisMap = new ObjectList();\n\n        this.renderers = new ObjectList();\n\n        this.datasets = new ObjectList();\n        this.datasets.set(0, dataset);\n        if (dataset != null) {\n            dataset.addChangeListener(this);\n        }\n\n        this.axisOffset = new RectangleInsets(4.0, 4.0, 4.0, 4.0);\n\n        setDomainAxisLocation(AxisLocation.BOTTOM_OR_LEFT, false);\n        setRangeAxisLocation(AxisLocation.TOP_OR_LEFT, false);\n\n        this.renderers.set(0, renderer);\n        if (renderer != null) {\n            renderer.setPlot(this);\n            renderer.addChangeListener(this);\n        }\n\n        this.domainAxes.set(0, domainAxis);\n        this.mapDatasetToDomainAxis(0, 0);\n        if (domainAxis != null) {\n            domainAxis.setPlot(this);\n            domainAxis.addChangeListener(this);\n        }\n        this.drawSharedDomainAxis = false;\n\n        this.rangeAxes.set(0, rangeAxis);\n        this.mapDatasetToRangeAxis(0, 0);\n        if (rangeAxis != null) {\n            rangeAxis.setPlot(this);\n            rangeAxis.addChangeListener(this);\n        }\n        \n        configureDomainAxes();\n        configureRangeAxes();\n\n        this.domainGridlinesVisible = DEFAULT_DOMAIN_GRIDLINES_VISIBLE;\n        this.domainGridlinePosition = CategoryAnchor.MIDDLE;\n        this.domainGridlineStroke = DEFAULT_GRIDLINE_STROKE;\n        this.domainGridlinePaint = DEFAULT_GRIDLINE_PAINT;\n\n        this.rangeGridlinesVisible = DEFAULT_RANGE_GRIDLINES_VISIBLE;\n        this.rangeGridlineStroke = DEFAULT_GRIDLINE_STROKE;\n        this.rangeGridlinePaint = DEFAULT_GRIDLINE_PAINT;\n\n        this.foregroundDomainMarkers = new HashMap();\n        this.backgroundDomainMarkers = new HashMap();\n        this.foregroundRangeMarkers = new HashMap();\n        this.backgroundRangeMarkers = new HashMap();\n\n        Marker baseline = new ValueMarker(0.0, new Color(0.8f, 0.8f, 0.8f, \n                0.5f), new BasicStroke(1.0f), new Color(0.85f, 0.85f, 0.95f, \n                0.5f), new BasicStroke(1.0f), 0.6f);\n        addRangeMarker(baseline, Layer.BACKGROUND);\n\n        this.anchorValue = 0.0;\n\n        this.rangeCrosshairVisible = DEFAULT_CROSSHAIR_VISIBLE;\n        this.rangeCrosshairValue = 0.0;\n        this.rangeCrosshairStroke = DEFAULT_CROSSHAIR_STROKE;\n        this.rangeCrosshairPaint = DEFAULT_CROSSHAIR_PAINT;\n        \n        this.annotations = new java.util.ArrayList();\n\n    }\n    \n    \n    public String getPlotType() {\n        return localizationResources.getString(\"Category_Plot\");\n    }\n\n    \n    public PlotOrientation getOrientation() {\n        return this.orientation;\n    }\n\n    \n    public void setOrientation(PlotOrientation orientation) {\n        if (orientation == null) {\n            throw new IllegalArgumentException(\"Null 'orientation' argument.\");\n        }\n        this.orientation = orientation;\n        fireChangeEvent();\n    }\n\n    \n    public RectangleInsets getAxisOffset() {\n        return this.axisOffset;\n    }\n\n    \n    public void setAxisOffset(RectangleInsets offset) {\n        if (offset == null) {\n            throw new IllegalArgumentException(\"Null 'offset' argument.\");   \n        }\n        this.axisOffset = offset;\n        fireChangeEvent();\n    }\n\n    \n    public CategoryAxis getDomainAxis() {\n        return getDomainAxis(0);\n    }\n\n    \n    public CategoryAxis getDomainAxis(int index) {\n        CategoryAxis result = null;\n        if (index < this.domainAxes.size()) {\n            result = (CategoryAxis) this.domainAxes.get(index);\n        }\n        if (result == null) {\n            Plot parent = getParent();\n            if (parent instanceof CategoryPlot) {\n                CategoryPlot cp = (CategoryPlot) parent;\n                result = cp.getDomainAxis(index);\n            }\n        }\n        return result;\n    }\n\n    \n    public void setDomainAxis(CategoryAxis axis) {\n        setDomainAxis(0, axis);\n    }\n\n    \n    public void setDomainAxis(int index, CategoryAxis axis) {\n        setDomainAxis(index, axis, true);\n    }\n \n    \n    public void setDomainAxis(int index, CategoryAxis axis, boolean notify) {\n        CategoryAxis existing = (CategoryAxis) this.domainAxes.get(index);\n        if (existing != null) {\n            existing.removeChangeListener(this);\n        }\n        if (axis != null) {\n            axis.setPlot(this);\n        }\n        this.domainAxes.set(index, axis);\n        if (axis != null) {\n            axis.configure();\n            axis.addChangeListener(this);\n        }\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    \n    public void setDomainAxes(CategoryAxis[] axes) {\n        for (int i = 0; i < axes.length; i++) {\n            setDomainAxis(i, axes[i], false);   \n        }\n        fireChangeEvent();\n    }\n    \n    \n    public int getDomainAxisIndex(CategoryAxis axis) {\n        if (axis == null) {\n            throw new IllegalArgumentException(\"Null 'axis' argument.\");\n        }\n        return this.domainAxes.indexOf(axis);\n    }\n    \n    \n    public AxisLocation getDomainAxisLocation() {\n        return getDomainAxisLocation(0);\n    }\n\n    \n    public AxisLocation getDomainAxisLocation(int index) {\n        AxisLocation result = null;\n        if (index < this.domainAxisLocations.size()) {\n            result = (AxisLocation) this.domainAxisLocations.get(index);\n        }\n        if (result == null) {\n            result = AxisLocation.getOpposite(getDomainAxisLocation(0));\n        }\n        return result;\n    }\n\n    \n    public void setDomainAxisLocation(AxisLocation location) {\n        \n        setDomainAxisLocation(0, location, true);\n    }\n\n    \n    public void setDomainAxisLocation(AxisLocation location, boolean notify) {\n        \n        setDomainAxisLocation(0, location, notify);\n    }\n\n    \n    public void setDomainAxisLocation(int index, AxisLocation location) {\n        \n        setDomainAxisLocation(index, location, true);\n    }\n    \n    \n    public void setDomainAxisLocation(int index, AxisLocation location, boolean notify) {\n        if (index == 0 && location == null) {\n            throw new IllegalArgumentException(\n                    \"Null 'location' for index 0 not permitted.\");\n        }\n        this.domainAxisLocations.set(index, location);\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    \n    public RectangleEdge getDomainAxisEdge() {\n        return getDomainAxisEdge(0);\n    }\n\n    \n    public RectangleEdge getDomainAxisEdge(int index) {\n        RectangleEdge result = null;\n        AxisLocation location = getDomainAxisLocation(index);\n        if (location != null) {\n            result = Plot.resolveDomainAxisLocation(location, this.orientation);\n        }\n        else {\n            result = RectangleEdge.opposite(getDomainAxisEdge(0));\n        }\n        return result;\n    }\n\n    \n    public int getDomainAxisCount() {\n        return this.domainAxes.size();\n    }\n\n    \n    public void clearDomainAxes() {\n        for (int i = 0; i < this.domainAxes.size(); i++) {\n            CategoryAxis axis = (CategoryAxis) this.domainAxes.get(i);\n            if (axis != null) {\n                axis.removeChangeListener(this);\n            }\n        }\n        this.domainAxes.clear();\n        fireChangeEvent();\n    }\n\n    \n    public void configureDomainAxes() {\n        for (int i = 0; i < this.domainAxes.size(); i++) {\n            CategoryAxis axis = (CategoryAxis) this.domainAxes.get(i);\n            if (axis != null) {\n                axis.configure();\n            }\n        }\n    }\n\n    \n    public ValueAxis getRangeAxis() {\n        return getRangeAxis(0);\n    }\n\n    \n    public ValueAxis getRangeAxis(int index) {\n        ValueAxis result = null;\n        if (index < this.rangeAxes.size()) {\n            result = (ValueAxis) this.rangeAxes.get(index);\n        }\n        if (result == null) {\n            Plot parent = getParent();\n            if (parent instanceof CategoryPlot) {\n                CategoryPlot cp = (CategoryPlot) parent;\n                result = cp.getRangeAxis(index);\n            }\n        }\n        return result;\n    }\n\n    \n    public void setRangeAxis(ValueAxis axis) {\n        setRangeAxis(0, axis);\n    }\n\n    \n    public void setRangeAxis(int index, ValueAxis axis) {\n        setRangeAxis(index, axis, true);\n    }\n        \n    \n    public void setRangeAxis(int index, ValueAxis axis, boolean notify) {\n        ValueAxis existing = (ValueAxis) this.rangeAxes.get(index);\n        if (existing != null) {\n            existing.removeChangeListener(this);\n        }\n        if (axis != null) {\n            axis.setPlot(this);\n        }\n        this.rangeAxes.set(index, axis);\n        if (axis != null) {\n            axis.configure();\n            axis.addChangeListener(this);\n        }\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    \n    public void setRangeAxes(ValueAxis[] axes) {\n        for (int i = 0; i < axes.length; i++) {\n            setRangeAxis(i, axes[i], false);   \n        }\n        fireChangeEvent();\n    }\n\n    \n    public int getRangeAxisIndex(ValueAxis axis) {\n        if (axis == null) {\n            throw new IllegalArgumentException(\"Null 'axis' argument.\");\n        }\n        int result = this.rangeAxes.indexOf(axis);\n        if (result < 0) { \n            Plot parent = getParent();\n            if (parent instanceof CategoryPlot) {\n                CategoryPlot p = (CategoryPlot) parent;\n                result = p.getRangeAxisIndex(axis);\n            }\n        }\n        return result;\n    }\n\n    \n    public AxisLocation getRangeAxisLocation() {\n        return getRangeAxisLocation(0);\n    }\n\n    \n    public AxisLocation getRangeAxisLocation(int index) {\n        AxisLocation result = null;\n        if (index < this.rangeAxisLocations.size()) {\n            result = (AxisLocation) this.rangeAxisLocations.get(index);\n        }\n        if (result == null) {\n            result = AxisLocation.getOpposite(getRangeAxisLocation(0));\n        }\n        return result;\n    }\n\n    \n    public void setRangeAxisLocation(AxisLocation location) {\n        \n        setRangeAxisLocation(location, true);\n    }\n\n    \n    public void setRangeAxisLocation(AxisLocation location, boolean notify) {\n        setRangeAxisLocation(0, location, notify);\n    }\n\n    \n    public void setRangeAxisLocation(int index, AxisLocation location) {\n        setRangeAxisLocation(index, location, true);\n    }\n\n    \n    public void setRangeAxisLocation(int index, AxisLocation location, boolean notify) {\n        if (index == 0 && location == null) {\n            throw new IllegalArgumentException(\n                    \"Null 'location' for index 0 not permitted.\");\n        }\n        this.rangeAxisLocations.set(index, location);\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    \n    public RectangleEdge getRangeAxisEdge() {\n        return getRangeAxisEdge(0);\n    }\n\n    \n    public RectangleEdge getRangeAxisEdge(int index) {\n        AxisLocation location = getRangeAxisLocation(index);\n        RectangleEdge result = Plot.resolveRangeAxisLocation(location, \n                this.orientation);\n        if (result == null) {\n            result = RectangleEdge.opposite(getRangeAxisEdge(0));\n        }\n        return result;\n    }\n\n    \n    public int getRangeAxisCount() {\n        return this.rangeAxes.size();\n    }\n\n    \n    public void clearRangeAxes() {\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis axis = (ValueAxis) this.rangeAxes.get(i);\n            if (axis != null) {\n                axis.removeChangeListener(this);\n            }\n        }\n        this.rangeAxes.clear();\n        fireChangeEvent();\n    }\n\n    \n    public void configureRangeAxes() {\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis axis = (ValueAxis) this.rangeAxes.get(i);\n            if (axis != null) {\n                axis.configure();\n            }\n        }\n    }\n\n    \n    public CategoryDataset getDataset() {\n        return getDataset(0);\n    }\n\n    \n    public CategoryDataset getDataset(int index) {\n        CategoryDataset result = null;\n        if (this.datasets.size() > index) {\n            result = (CategoryDataset) this.datasets.get(index);\n        }\n        return result;\n    }\n\n    \n    public void setDataset(CategoryDataset dataset) {\n        setDataset(0, dataset);\n    }\n\n    \n    public void setDataset(int index, CategoryDataset dataset) {\n        \n        CategoryDataset existing = (CategoryDataset) this.datasets.get(index);\n        if (existing != null) {\n            existing.removeChangeListener(this);\n        }\n        this.datasets.set(index, dataset);\n        if (dataset != null) {\n            dataset.addChangeListener(this);\n        }\n        \n        \n        DatasetChangeEvent event = new DatasetChangeEvent(this, dataset);\n        datasetChanged(event);\n        \n    }\n\n    \n    public int getDatasetCount() {\n        return this.datasets.size();\n    }\n\n    \n    public void mapDatasetToDomainAxis(int index, int axisIndex) {\n        this.datasetToDomainAxisMap.set(index, new Integer(axisIndex));  \n        \n        datasetChanged(new DatasetChangeEvent(this, getDataset(index)));  \n    }\n\n    \n    public CategoryAxis getDomainAxisForDataset(int index) {\n        CategoryAxis result = getDomainAxis();\n        Integer axisIndex = (Integer) this.datasetToDomainAxisMap.get(index);\n        if (axisIndex != null) {\n            result = getDomainAxis(axisIndex.intValue());\n        }\n        return result;    \n    }\n    \n    \n    public void mapDatasetToRangeAxis(int index, int axisIndex) {\n        this.datasetToRangeAxisMap.set(index, new Integer(axisIndex));\n        \n        datasetChanged(new DatasetChangeEvent(this, getDataset(index)));  \n    }\n\n    \n    public ValueAxis getRangeAxisForDataset(int index) {\n        ValueAxis result = getRangeAxis();\n        Integer axisIndex = (Integer) this.datasetToRangeAxisMap.get(index);\n        if (axisIndex != null) {\n            result = getRangeAxis(axisIndex.intValue());\n        }\n        return result;    \n    }\n    \n    \n    public CategoryItemRenderer getRenderer() {\n        return getRenderer(0);\n    }\n\n    \n    public CategoryItemRenderer getRenderer(int index) {\n        CategoryItemRenderer result = null;\n        if (this.renderers.size() > index) {\n            result = (CategoryItemRenderer) this.renderers.get(index);\n        }\n        return result;\n    }\n    \n    \n    public void setRenderer(CategoryItemRenderer renderer) {\n        setRenderer(0, renderer, true);\n    }\n\n    \n    public void setRenderer(CategoryItemRenderer renderer, boolean notify) {\n        setRenderer(0, renderer, notify);\n    }\n\n    \n    public void setRenderer(int index, CategoryItemRenderer renderer) {\n        setRenderer(index, renderer, true);   \n    }\n\n    \n    public void setRenderer(int index, CategoryItemRenderer renderer, boolean notify) {\n        \n        \n        CategoryItemRenderer existing \n            = (CategoryItemRenderer) this.renderers.get(index);\n        if (existing != null) {\n            existing.removeChangeListener(this);\n        }\n        \n        \n        this.renderers.set(index, renderer);\n        if (renderer != null) {\n            renderer.setPlot(this);\n            renderer.addChangeListener(this);\n        }\n        \n        configureDomainAxes();\n        configureRangeAxes();\n        \n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    \n    public void setRenderers(CategoryItemRenderer[] renderers) {\n        for (int i = 0; i < renderers.length; i++) {\n            setRenderer(i, renderers[i], false);   \n        }\n        fireChangeEvent();\n    }\n    \n    \n    public CategoryItemRenderer getRendererForDataset(CategoryDataset dataset) {\n        CategoryItemRenderer result = null;\n        for (int i = 0; i < this.datasets.size(); i++) {\n            if (this.datasets.get(i) == dataset) {\n                result = (CategoryItemRenderer) this.renderers.get(i);   \n                break;\n            }\n        }\n        return result;\n    }\n    \n    \n    public int getIndexOf(CategoryItemRenderer renderer) {\n        return this.renderers.indexOf(renderer);\n    }\n\n    \n    public DatasetRenderingOrder getDatasetRenderingOrder() {\n        return this.renderingOrder;\n    }\n\n    \n    public void setDatasetRenderingOrder(DatasetRenderingOrder order) {\n        if (order == null) {\n            throw new IllegalArgumentException(\"Null 'order' argument.\");   \n        }\n        this.renderingOrder = order;\n        fireChangeEvent();\n    }\n\n        \n    public SortOrder getColumnRenderingOrder() {\n        return this.columnRenderingOrder;\n    }\n    \n    \n    public void setColumnRenderingOrder(SortOrder order) {\n        if (order == null) {\n            throw new IllegalArgumentException(\"Null 'order' argument.\");\n        }\n        this.columnRenderingOrder = order;\n        fireChangeEvent();\n    }\n    \n    \n    public SortOrder getRowRenderingOrder() {\n        return this.rowRenderingOrder;\n    }\n\n    \n    public void setRowRenderingOrder(SortOrder order) {\n        if (order == null) {\n            throw new IllegalArgumentException(\"Null 'order' argument.\");\n        }\n        this.rowRenderingOrder = order;\n        fireChangeEvent();\n    }\n    \n    \n    public boolean isDomainGridlinesVisible() {\n        return this.domainGridlinesVisible;\n    }\n\n    \n    public void setDomainGridlinesVisible(boolean visible) {\n        if (this.domainGridlinesVisible != visible) {\n            this.domainGridlinesVisible = visible;\n            fireChangeEvent();\n        }\n    }\n\n    \n    public CategoryAnchor getDomainGridlinePosition() {\n        return this.domainGridlinePosition;\n    }\n\n    \n    public void setDomainGridlinePosition(CategoryAnchor position) {\n        if (position == null) {\n            throw new IllegalArgumentException(\"Null 'position' argument.\");   \n        }\n        this.domainGridlinePosition = position;\n        fireChangeEvent();\n    }\n\n    \n    public Stroke getDomainGridlineStroke() {\n        return this.domainGridlineStroke;\n    }\n\n    \n    public void setDomainGridlineStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' not permitted.\");\n        }\n        this.domainGridlineStroke = stroke;\n        fireChangeEvent();\n    }\n\n    \n    public Paint getDomainGridlinePaint() {\n        return this.domainGridlinePaint;\n    }\n\n    \n    public void setDomainGridlinePaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");   \n        }\n        this.domainGridlinePaint = paint;\n        fireChangeEvent();\n    }\n\n    \n    public boolean isRangeGridlinesVisible() {\n        return this.rangeGridlinesVisible;\n    }\n\n    \n    public void setRangeGridlinesVisible(boolean visible) {\n        if (this.rangeGridlinesVisible != visible) {\n            this.rangeGridlinesVisible = visible;\n            fireChangeEvent();\n        }\n    }\n\n    \n    public Stroke getRangeGridlineStroke() {\n        return this.rangeGridlineStroke;\n    }\n\n    \n    public void setRangeGridlineStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");   \n        }\n        this.rangeGridlineStroke = stroke;\n        fireChangeEvent();\n    }\n\n    \n    public Paint getRangeGridlinePaint() {\n        return this.rangeGridlinePaint;\n    }\n\n    \n    public void setRangeGridlinePaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");   \n        }\n        this.rangeGridlinePaint = paint;\n        fireChangeEvent();\n    }\n    \n    \n    public LegendItemCollection getFixedLegendItems() {\n        return this.fixedLegendItems;   \n    }\n\n    \n    public void setFixedLegendItems(LegendItemCollection items) {\n        this.fixedLegendItems = items;\n        fireChangeEvent();\n    }\n    \n    \n    public LegendItemCollection getLegendItems() {\n        LegendItemCollection result = this.fixedLegendItems;\n        if (result == null) {\n            result = new LegendItemCollection();\n            \n            int count = this.datasets.size();\n            for (int datasetIndex = 0; datasetIndex < count; datasetIndex++) {\n                CategoryDataset dataset = getDataset(datasetIndex);\n                if (dataset != null) {\n                    CategoryItemRenderer renderer = getRenderer(datasetIndex);\n                    if (renderer != null) {\n                        int seriesCount = dataset.getRowCount();\n                        for (int i = 0; i < seriesCount; i++) {\n                            LegendItem item = renderer.getLegendItem(\n                                    datasetIndex, i);\n                            if (item != null) {\n                                result.add(item);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return result;\n    }\n\n    \n    public void handleClick(int x, int y, PlotRenderingInfo info) {\n\n        Rectangle2D dataArea = info.getDataArea();\n        if (dataArea.contains(x, y)) {\n            \n            double java2D = 0.0;\n            if (this.orientation == PlotOrientation.HORIZONTAL) {\n                java2D = x;\n            }\n            else if (this.orientation == PlotOrientation.VERTICAL) {\n                java2D = y;\n            }\n            RectangleEdge edge = Plot.resolveRangeAxisLocation(\n                    getRangeAxisLocation(), this.orientation);\n            double value = getRangeAxis().java2DToValue(\n                    java2D, info.getDataArea(), edge);\n            setAnchorValue(value);\n            setRangeCrosshairValue(value);\n        }\n\n    }\n\n    \n    public void zoom(double percent) {\n\n        if (percent > 0.0) {\n            double range = getRangeAxis().getRange().getLength();\n            double scaledRange = range * percent;\n            getRangeAxis().setRange(this.anchorValue - scaledRange / 2.0,\n                    this.anchorValue + scaledRange / 2.0);\n        }\n        else {\n            getRangeAxis().setAutoRange(true);\n        }\n\n    }\n\n    \n    public void datasetChanged(DatasetChangeEvent event) {\n\n        int count = this.rangeAxes.size();\n        for (int axisIndex = 0; axisIndex < count; axisIndex++) {\n            ValueAxis yAxis = getRangeAxis(axisIndex);\n            if (yAxis != null) {\n                yAxis.configure();\n            }\n        }\n        if (getParent() != null) {\n            getParent().datasetChanged(event);\n        }\n        else {\n            PlotChangeEvent e = new PlotChangeEvent(this);\n            e.setType(ChartChangeEventType.DATASET_UPDATED);\n            notifyListeners(e);\n        }\n\n    }\n\n    \n    public void rendererChanged(RendererChangeEvent event) {\n        Plot parent = getParent();\n        if (parent != null) {\n            if (parent instanceof RendererChangeListener) {\n                RendererChangeListener rcl = (RendererChangeListener) parent;\n                rcl.rendererChanged(event);\n            }\n            else {\n                \n                \n                throw new RuntimeException(\n                    \"The renderer has changed and I don't know what to do!\");\n            }\n        }\n        else {\n            configureRangeAxes();\n            PlotChangeEvent e = new PlotChangeEvent(this);\n            notifyListeners(e);\n        }\n    }\n    \n    \n    public void addDomainMarker(CategoryMarker marker) {\n        addDomainMarker(marker, Layer.FOREGROUND); \n    }\n        \n    \n    public void addDomainMarker(CategoryMarker marker, Layer layer) {\n        addDomainMarker(0, marker, layer);\n    }\n\n    \n    public void addDomainMarker(int index, CategoryMarker marker, Layer layer) {\n        addDomainMarker(index, marker, layer, true);\n    }\n    \t\n    \n    public void addDomainMarker(int index, CategoryMarker marker, Layer layer, boolean notify) {\n        if (marker == null) {\n            throw new IllegalArgumentException(\"Null 'marker' not permitted.\");\n        }\n        if (layer == null) {\n            throw new IllegalArgumentException(\"Null 'layer' not permitted.\");\n        }\n        Collection markers;\n        if (layer == Layer.FOREGROUND) {\n            markers = (Collection) this.foregroundDomainMarkers.get(\n                    new Integer(index));\n            if (markers == null) {\n                markers = new java.util.ArrayList();\n                this.foregroundDomainMarkers.put(new Integer(index), markers);\n            }\n            markers.add(marker);\n        }\n        else if (layer == Layer.BACKGROUND) {\n            markers = (Collection) this.backgroundDomainMarkers.get(\n                    new Integer(index));\n            if (markers == null) {\n                markers = new java.util.ArrayList();\n                this.backgroundDomainMarkers.put(new Integer(index), markers);\n            }\n            markers.add(marker);            \n        }\n        marker.addChangeListener(this);\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    \n    public void clearDomainMarkers() {\n        if (this.backgroundDomainMarkers != null) {\n            Set keys = this.backgroundDomainMarkers.keySet();\n            Iterator iterator = keys.iterator();\n            while (iterator.hasNext()) {\n                Integer key = (Integer) iterator.next();\n                clearDomainMarkers(key.intValue());\n            }\n            this.backgroundDomainMarkers.clear();\n        }\n        if (this.foregroundDomainMarkers != null) {\n            Set keys = this.foregroundDomainMarkers.keySet();\n            Iterator iterator = keys.iterator();\n            while (iterator.hasNext()) {\n                Integer key = (Integer) iterator.next();\n                clearDomainMarkers(key.intValue());\n            }\n            this.foregroundDomainMarkers.clear();\n        }\n        fireChangeEvent();\n    }\n\n    \n    public Collection getDomainMarkers(Layer layer) {\n        return getDomainMarkers(0, layer);\n    }\n\n    \n    public Collection getDomainMarkers(int index, Layer layer) {\n        Collection result = null;\n        Integer key = new Integer(index);\n        if (layer == Layer.FOREGROUND) {\n            result = (Collection) this.foregroundDomainMarkers.get(key);\n        }    \n        else if (layer == Layer.BACKGROUND) {\n            result = (Collection) this.backgroundDomainMarkers.get(key);\n        }\n        if (result != null) {\n            result = Collections.unmodifiableCollection(result);\n        }\n        return result;\n    }\n    \n    \n    public void clearDomainMarkers(int index) {\n        Integer key = new Integer(index);\n        if (this.backgroundDomainMarkers != null) {\n            Collection markers \n                = (Collection) this.backgroundDomainMarkers.get(key);\n            if (markers != null) {\n                Iterator iterator = markers.iterator();\n                while (iterator.hasNext()) {\n                    Marker m = (Marker) iterator.next();\n                    m.removeChangeListener(this);\n                }\n                markers.clear();\n            }\n        }\n        if (this.foregroundDomainMarkers != null) {\n            Collection markers \n                = (Collection) this.foregroundDomainMarkers.get(key);\n            if (markers != null) {\n                Iterator iterator = markers.iterator();\n                while (iterator.hasNext()) {\n                    Marker m = (Marker) iterator.next();\n                    m.removeChangeListener(this);\n                }\n                markers.clear();\n            }\n        }\n        fireChangeEvent();\n    }\n    \n    \n    public boolean removeDomainMarker(Marker marker) {\n        return removeDomainMarker(marker, Layer.FOREGROUND);\n    }\n\n    \n    public boolean removeDomainMarker(Marker marker, Layer layer) {\n        return removeDomainMarker(0, marker, layer);\n    }\n\n    \n    public boolean removeDomainMarker(int index, Marker marker, Layer layer) {\n    \treturn removeDomainMarker(index, marker, layer, true);\n    }\n\n    \n    public boolean removeDomainMarker(int index, Marker marker, Layer layer, boolean notify) {\n        ArrayList markers;\n        if (layer == Layer.FOREGROUND) {\n            markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer(\n                    index));\n        }\n        else {\n            markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                    index));\n        }\n        if (markers == null) {\n            return false;\n        }\n        boolean removed = markers.remove(marker);\n        if (removed && notify) {\n            fireChangeEvent();\n        }\n        return removed;\n    }\n    \n    \n    public void addRangeMarker(Marker marker) {\n        addRangeMarker(marker, Layer.FOREGROUND); \n    }\n        \n    \n    public void addRangeMarker(Marker marker, Layer layer) {\n        addRangeMarker(0, marker, layer);\n    }\n\n    \n    public void addRangeMarker(int index, Marker marker, Layer layer) {\n    \taddRangeMarker(index, marker, layer, true);\n    }\n\n    \n    public void addRangeMarker(int index, Marker marker, Layer layer, boolean notify) {\n        Collection markers;\n        if (layer == Layer.FOREGROUND) {\n            markers = (Collection) this.foregroundRangeMarkers.get(\n                    new Integer(index));\n            if (markers == null) {\n                markers = new java.util.ArrayList();\n                this.foregroundRangeMarkers.put(new Integer(index), markers);\n            }\n            markers.add(marker);\n        }\n        else if (layer == Layer.BACKGROUND) {\n            markers = (Collection) this.backgroundRangeMarkers.get(\n                    new Integer(index));\n            if (markers == null) {\n                markers = new java.util.ArrayList();\n                this.backgroundRangeMarkers.put(new Integer(index), markers);\n            }\n            markers.add(marker);            \n        }\n        marker.addChangeListener(this);\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    \n    public void clearRangeMarkers() {\n        if (this.backgroundRangeMarkers != null) {\n            Set keys = this.backgroundRangeMarkers.keySet();\n            Iterator iterator = keys.iterator();\n            while (iterator.hasNext()) {\n                Integer key = (Integer) iterator.next();\n                clearRangeMarkers(key.intValue());\n            }\n            this.backgroundRangeMarkers.clear();\n        }\n        if (this.foregroundRangeMarkers != null) {\n            Set keys = this.foregroundRangeMarkers.keySet();\n            Iterator iterator = keys.iterator();\n            while (iterator.hasNext()) {\n                Integer key = (Integer) iterator.next();\n                clearRangeMarkers(key.intValue());\n            }\n            this.foregroundRangeMarkers.clear();\n        }\n        fireChangeEvent();\n    }\n\n    \n    public Collection getRangeMarkers(Layer layer) {\n        return getRangeMarkers(0, layer);\n    }\n\n    \n    public Collection getRangeMarkers(int index, Layer layer) {\n        Collection result = null;\n        Integer key = new Integer(index);\n        if (layer == Layer.FOREGROUND) {\n            result = (Collection) this.foregroundRangeMarkers.get(key);\n        }    \n        else if (layer == Layer.BACKGROUND) {\n            result = (Collection) this.backgroundRangeMarkers.get(key);\n        }\n        if (result != null) {\n            result = Collections.unmodifiableCollection(result);\n        }\n        return result;\n    }\n    \n    \n    public void clearRangeMarkers(int index) {\n        Integer key = new Integer(index);\n        if (this.backgroundRangeMarkers != null) {\n            Collection markers \n                = (Collection) this.backgroundRangeMarkers.get(key);\n            if (markers != null) {\n                Iterator iterator = markers.iterator();\n                while (iterator.hasNext()) {\n                    Marker m = (Marker) iterator.next();\n                    m.removeChangeListener(this);\n                }\n                markers.clear();\n            }\n        }\n        if (this.foregroundRangeMarkers != null) {\n            Collection markers \n                = (Collection) this.foregroundRangeMarkers.get(key);\n            if (markers != null) {\n                Iterator iterator = markers.iterator();\n                while (iterator.hasNext()) {\n                    Marker m = (Marker) iterator.next();\n                    m.removeChangeListener(this);\n                }\n                markers.clear();\n            }\n        }\n        fireChangeEvent();\n    }\n\n    \n    public boolean removeRangeMarker(Marker marker) {\n        return removeRangeMarker(marker, Layer.FOREGROUND);\n    }\n\n    \n    public boolean removeRangeMarker(Marker marker, Layer layer) {\n        return removeRangeMarker(0, marker, layer);\n    }\n\n    \n    public boolean removeRangeMarker(int index, Marker marker, Layer layer) {\n    \treturn removeRangeMarker(index, marker, layer, true);\n    }\n\n    \n    public boolean removeRangeMarker(int index, Marker marker, Layer layer, boolean notify) {\n        if (marker == null) {\n            throw new IllegalArgumentException(\"Null 'marker' argument.\");\n        }\n        ArrayList markers;\n        if (layer == Layer.FOREGROUND) {\n            markers = (ArrayList) this.foregroundRangeMarkers.get(new Integer(\n                    index));\n        }\n        else {\n            markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(\n                    index));\n        }\n        if (markers == null) {\n            return false;\n        }\n        boolean removed = markers.remove(marker);\n        if (removed && notify) {\n            fireChangeEvent();\n        }\n        return removed;\n    }\n\n    \n    public boolean isRangeCrosshairVisible() {\n        return this.rangeCrosshairVisible;\n    }\n\n    \n    public void setRangeCrosshairVisible(boolean flag) {\n        if (this.rangeCrosshairVisible != flag) {\n            this.rangeCrosshairVisible = flag;\n            fireChangeEvent();\n        }\n    }\n\n    \n    public boolean isRangeCrosshairLockedOnData() {\n        return this.rangeCrosshairLockedOnData;\n    }\n\n    \n    public void setRangeCrosshairLockedOnData(boolean flag) {\n        if (this.rangeCrosshairLockedOnData != flag) {\n            this.rangeCrosshairLockedOnData = flag;\n            fireChangeEvent();\n        }\n    }\n\n    \n    public double getRangeCrosshairValue() {\n        return this.rangeCrosshairValue;\n    }\n\n    \n    public void setRangeCrosshairValue(double value) {\n        setRangeCrosshairValue(value, true);\n    }\n\n    \n    public void setRangeCrosshairValue(double value, boolean notify) {\n        this.rangeCrosshairValue = value;\n        if (isRangeCrosshairVisible() && notify) {\n            fireChangeEvent();\n        }\n    }\n\n    \n    public Stroke getRangeCrosshairStroke() {\n        return this.rangeCrosshairStroke;\n    }\n\n    \n    public void setRangeCrosshairStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");\n        }\n        this.rangeCrosshairStroke = stroke;\n        fireChangeEvent();\n    }\n\n    \n    public Paint getRangeCrosshairPaint() {\n        return this.rangeCrosshairPaint;\n    }\n\n    \n    public void setRangeCrosshairPaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.rangeCrosshairPaint = paint;\n        fireChangeEvent();\n    }\n\n    \n    public List getAnnotations() {\n        return this.annotations;\n    }\n\n    \n    public void addAnnotation(CategoryAnnotation annotation) {\n    \taddAnnotation(annotation, true);\n    }\n    \n    \n    public void addAnnotation(CategoryAnnotation annotation, boolean notify) {\n        if (annotation == null) {\n            throw new IllegalArgumentException(\"Null 'annotation' argument.\");\n        }\n        this.annotations.add(annotation);\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    \n    public boolean removeAnnotation(CategoryAnnotation annotation) {\n    \treturn removeAnnotation(annotation, true);\n    }\n\n    \n    public boolean removeAnnotation(CategoryAnnotation annotation, boolean notify) {\n        if (annotation == null) {\n            throw new IllegalArgumentException(\"Null 'annotation' argument.\");\n        }\n        boolean removed = this.annotations.remove(annotation);\n        if (removed && notify) {\n            fireChangeEvent();\n        }\n        return removed;\n    }\n\n    \n    public void clearAnnotations() {\n        this.annotations.clear();\n        fireChangeEvent();\n    }\n\n    \n    protected AxisSpace calculateDomainAxisSpace(Graphics2D g2, Rectangle2D plotArea, AxisSpace space) {\n                                                     \n        if (space == null) {\n            space = new AxisSpace();\n        }\n        \n        \n        if (this.fixedDomainAxisSpace != null) {\n            if (this.orientation == PlotOrientation.HORIZONTAL) {\n                space.ensureAtLeast(\n                    this.fixedDomainAxisSpace.getLeft(), RectangleEdge.LEFT);\n                space.ensureAtLeast(this.fixedDomainAxisSpace.getRight(), \n                        RectangleEdge.RIGHT);\n            }\n            else if (this.orientation == PlotOrientation.VERTICAL) {\n                space.ensureAtLeast(this.fixedDomainAxisSpace.getTop(), \n                        RectangleEdge.TOP);\n                space.ensureAtLeast(this.fixedDomainAxisSpace.getBottom(), \n                        RectangleEdge.BOTTOM);\n            }\n        }\n        else {\n            \n            RectangleEdge domainEdge = Plot.resolveDomainAxisLocation(\n                    getDomainAxisLocation(), this.orientation);\n            if (this.drawSharedDomainAxis) {\n                space = getDomainAxis().reserveSpace(g2, this, plotArea, \n                        domainEdge, space);\n            }\n            \n            \n            for (int i = 0; i < this.domainAxes.size(); i++) {\n                Axis xAxis = (Axis) this.domainAxes.get(i);\n                if (xAxis != null) {\n                    RectangleEdge edge = getDomainAxisEdge(i);\n                    space = xAxis.reserveSpace(g2, this, plotArea, edge, space);\n                }\n            }\n        }\n\n        return space;\n                                                     \n    }\n    \n    \n    protected AxisSpace calculateRangeAxisSpace(Graphics2D g2, Rectangle2D plotArea, AxisSpace space) {\n                                                  \n        if (space == null) {\n            space = new AxisSpace(); \n        }\n        \n        \n        if (this.fixedRangeAxisSpace != null) {\n            if (this.orientation == PlotOrientation.HORIZONTAL) {\n                space.ensureAtLeast(this.fixedRangeAxisSpace.getTop(), \n                        RectangleEdge.TOP);\n                space.ensureAtLeast(this.fixedRangeAxisSpace.getBottom(), \n                        RectangleEdge.BOTTOM);\n            }\n            else if (this.orientation == PlotOrientation.VERTICAL) {\n                space.ensureAtLeast(this.fixedRangeAxisSpace.getLeft(), \n                        RectangleEdge.LEFT);\n                space.ensureAtLeast(this.fixedRangeAxisSpace.getRight(), \n                        RectangleEdge.RIGHT);\n            }\n        }\n        else {\n            \n            for (int i = 0; i < this.rangeAxes.size(); i++) {\n                Axis yAxis = (Axis) this.rangeAxes.get(i);\n                if (yAxis != null) {\n                    RectangleEdge edge = getRangeAxisEdge(i);\n                    space = yAxis.reserveSpace(g2, this, plotArea, edge, space);\n                }\n            }\n        }\n        return space;\n                                                    \n    }\n\n    \n    protected AxisSpace calculateAxisSpace(Graphics2D g2, Rectangle2D plotArea) {\n        AxisSpace space = new AxisSpace();\n        space = calculateRangeAxisSpace(g2, plotArea, space);\n        space = calculateDomainAxisSpace(g2, plotArea, space);\n        return space;\n    }\n    \n    \n    public void draw(Graphics2D g2, Rectangle2D area, Point2D anchor, PlotState parentState, PlotRenderingInfo state) {\n\n        \n        boolean b1 = (area.getWidth() <= MINIMUM_WIDTH_TO_DRAW);\n        boolean b2 = (area.getHeight() <= MINIMUM_HEIGHT_TO_DRAW);\n        if (b1 || b2) {\n            return;\n        }\n\n        \n        if (state == null) {\n            \n            \n            \n            state = new PlotRenderingInfo(null);\n        }\n        state.setPlotArea(area);\n\n        \n        RectangleInsets insets = getInsets();\n        insets.trim(area);\n\n        \n        AxisSpace space = calculateAxisSpace(g2, area);\n        Rectangle2D dataArea = space.shrink(area, null);\n        this.axisOffset.trim(dataArea);\n\n        state.setDataArea(dataArea);\n\n        \n        \n        if (getRenderer() != null) {\n            getRenderer().drawBackground(g2, this, dataArea);\n        }\n        else {\n            drawBackground(g2, dataArea);\n        }\n       \n        Map axisStateMap = drawAxes(g2, area, dataArea, state);\n\n        \n        Shape savedClip = g2.getClip();\n        g2.clip(dataArea);\n\n        drawDomainGridlines(g2, dataArea);\n\n        AxisState rangeAxisState = (AxisState) axisStateMap.get(getRangeAxis());\n        if (rangeAxisState == null) {\n            if (parentState != null) {\n                rangeAxisState = (AxisState) parentState.getSharedAxisStates()\n                        .get(getRangeAxis());\n            }\n        }\n        if (rangeAxisState != null) {\n            drawRangeGridlines(g2, dataArea, rangeAxisState.getTicks());\n        }\n        \n        \n        for (int i = 0; i < this.renderers.size(); i++) {\n            drawDomainMarkers(g2, dataArea, i, Layer.BACKGROUND);\n        }        \n        for (int i = 0; i < this.renderers.size(); i++) {\n            drawRangeMarkers(g2, dataArea, i, Layer.BACKGROUND);\n        }\n\n        \n        boolean foundData = false;\n\n        \n        Composite originalComposite = g2.getComposite();\n        g2.setComposite(AlphaComposite.getInstance(\n                AlphaComposite.SRC_OVER, getForegroundAlpha()));\n\n        DatasetRenderingOrder order = getDatasetRenderingOrder();\n        if (order == DatasetRenderingOrder.FORWARD) {\n\n            \n            int datasetCount = this.datasets.size();\n            for (int i = 0; i < datasetCount; i++) {\n                CategoryItemRenderer r = getRenderer(i);\n                if (r != null) {\n                    CategoryAxis domainAxis = getDomainAxisForDataset(i);\n                    ValueAxis rangeAxis = getRangeAxisForDataset(i);\n                    r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis,\n                            Layer.BACKGROUND, state);\n                }\n            }\n\n            for (int i = 0; i < datasetCount; i++) {\n                foundData = render(g2, dataArea, i, state) || foundData;\n            }\n\n            \n            for (int i = 0; i < datasetCount; i++) {\n                CategoryItemRenderer r = getRenderer(i);\n                if (r != null) {\n                    CategoryAxis domainAxis = getDomainAxisForDataset(i);\n                    ValueAxis rangeAxis = getRangeAxisForDataset(i);\n                    r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis,\n                            Layer.FOREGROUND, state);\n                }\n            }\n        }\n        else {  \n            \n            \n            int datasetCount = this.datasets.size();\n            for (int i = datasetCount - 1; i >= 0; i--) {\n                CategoryItemRenderer r = getRenderer(i);\n                if (r != null) {\n                    CategoryAxis domainAxis = getDomainAxisForDataset(i);\n                    ValueAxis rangeAxis = getRangeAxisForDataset(i);\n                    r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis,\n                            Layer.BACKGROUND, state);\n                }\n            }\n            \n            for (int i = this.datasets.size() - 1; i >= 0; i--) {\n                foundData = render(g2, dataArea, i, state) || foundData;   \n            }\n\n            \n            for (int i = datasetCount - 1; i >= 0; i--) {\n                CategoryItemRenderer r = getRenderer(i);\n                if (r != null) {\n                    CategoryAxis domainAxis = getDomainAxisForDataset(i);\n                    ValueAxis rangeAxis = getRangeAxisForDataset(i);\n                    r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis,\n                            Layer.FOREGROUND, state);\n                }\n            }\n        }\n        \n        \n        for (int i = 0; i < this.renderers.size(); i++) {\n            drawDomainMarkers(g2, dataArea, i, Layer.FOREGROUND);\n        }\n        for (int i = 0; i < this.renderers.size(); i++) {\n            drawRangeMarkers(g2, dataArea, i, Layer.FOREGROUND);\n        }\n\n        \n        drawAnnotations(g2, dataArea, state);\n\n        g2.setClip(savedClip);\n        g2.setComposite(originalComposite);\n\n        if (!foundData) {\n            drawNoDataMessage(g2, dataArea);\n        }\n\n        \n        if (isRangeCrosshairVisible()) {\n            \n            drawRangeCrosshair(g2, dataArea, getOrientation(), \n                    getRangeCrosshairValue(), getRangeAxis(),\n                    getRangeCrosshairStroke(), getRangeCrosshairPaint());\n        }\n\n        \n        if (getRenderer() != null) {\n            getRenderer().drawOutline(g2, this, dataArea);\n        }\n        else {\n            drawOutline(g2, dataArea);\n        }\n\n    }\n\n    \n    public void drawBackground(Graphics2D g2, Rectangle2D area) {\n        fillBackground(g2, area, this.orientation);\n        drawBackgroundImage(g2, area);\n    }\n\n    \n    protected Map drawAxes(Graphics2D g2, Rectangle2D plotArea, Rectangle2D dataArea, PlotRenderingInfo plotState) {\n\n        AxisCollection axisCollection = new AxisCollection();\n\n        \n        for (int index = 0; index < this.domainAxes.size(); index++) {\n            CategoryAxis xAxis = (CategoryAxis) this.domainAxes.get(index);\n            if (xAxis != null) {\n                axisCollection.add(xAxis, getDomainAxisEdge(index));\n            }\n        }\n\n        \n        for (int index = 0; index < this.rangeAxes.size(); index++) {\n            ValueAxis yAxis = (ValueAxis) this.rangeAxes.get(index);\n            if (yAxis != null) {\n                axisCollection.add(yAxis, getRangeAxisEdge(index));\n            }\n        }\n\n        Map axisStateMap = new HashMap();\n        \n        \n        double cursor = dataArea.getMinY() - this.axisOffset.calculateTopOutset(\n                dataArea.getHeight());\n        Iterator iterator = axisCollection.getAxesAtTop().iterator();\n        while (iterator.hasNext()) {\n            Axis axis = (Axis) iterator.next();\n            if (axis != null) {\n                AxisState axisState = axis.draw(g2, cursor, plotArea, dataArea, \n                        RectangleEdge.TOP, plotState);\n                cursor = axisState.getCursor();\n                axisStateMap.put(axis, axisState);\n            }\n        }\n\n        \n        cursor = dataArea.getMaxY() \n                 + this.axisOffset.calculateBottomOutset(dataArea.getHeight());\n        iterator = axisCollection.getAxesAtBottom().iterator();\n        while (iterator.hasNext()) {\n            Axis axis = (Axis) iterator.next();\n            if (axis != null) {\n                AxisState axisState = axis.draw(g2, cursor, plotArea, dataArea,\n                        RectangleEdge.BOTTOM, plotState);\n                cursor = axisState.getCursor();\n                axisStateMap.put(axis, axisState);\n            }\n        }\n\n        \n        cursor = dataArea.getMinX() \n                 - this.axisOffset.calculateLeftOutset(dataArea.getWidth());\n        iterator = axisCollection.getAxesAtLeft().iterator();\n        while (iterator.hasNext()) {\n            Axis axis = (Axis) iterator.next();\n            if (axis != null) {\n                AxisState axisState = axis.draw(g2, cursor, plotArea, dataArea,\n                        RectangleEdge.LEFT, plotState);\n                cursor = axisState.getCursor();\n                axisStateMap.put(axis, axisState);\n            }\n        }\n\n        \n        cursor = dataArea.getMaxX() \n                 + this.axisOffset.calculateRightOutset(dataArea.getWidth());\n        iterator = axisCollection.getAxesAtRight().iterator();\n        while (iterator.hasNext()) {\n            Axis axis = (Axis) iterator.next();\n            if (axis != null) {\n                AxisState axisState = axis.draw(g2, cursor, plotArea, dataArea, \n                        RectangleEdge.RIGHT, plotState);\n                cursor = axisState.getCursor();\n                axisStateMap.put(axis, axisState);\n            }\n        }\n        \n        return axisStateMap;\n        \n    }\n\n    \n    public boolean render(Graphics2D g2, Rectangle2D dataArea, int index, PlotRenderingInfo info) {\n\n        boolean foundData = false;\n        CategoryDataset currentDataset = getDataset(index);\n        CategoryItemRenderer renderer = getRenderer(index);\n        CategoryAxis domainAxis = getDomainAxisForDataset(index);\n        ValueAxis rangeAxis = getRangeAxisForDataset(index);\n        boolean hasData = !DatasetUtilities.isEmptyOrNull(currentDataset);\n        if (hasData && renderer != null) {\n            \n            foundData = true;\n            CategoryItemRendererState state = renderer.initialise(g2, dataArea,\n                    this, index, info);\n            int columnCount = currentDataset.getColumnCount();\n            int rowCount = currentDataset.getRowCount();\n            int passCount = renderer.getPassCount();\n            for (int pass = 0; pass < passCount; pass++) {            \n                if (this.columnRenderingOrder == SortOrder.ASCENDING) {\n                    for (int column = 0; column < columnCount; column++) {\n                        if (this.rowRenderingOrder == SortOrder.ASCENDING) {\n                            for (int row = 0; row < rowCount; row++) {\n                                renderer.drawItem(g2, state, dataArea, this, \n                                        domainAxis, rangeAxis, currentDataset, \n                                        row, column, pass);\n                            }\n                        }\n                        else {\n                            for (int row = rowCount - 1; row >= 0; row--) {\n                                renderer.drawItem(g2, state, dataArea, this, \n                                        domainAxis, rangeAxis, currentDataset, \n                                        row, column, pass);\n                            }                        \n                        }\n                    }\n                }\n                else {\n                    for (int column = columnCount - 1; column >= 0; column--) {\n                        if (this.rowRenderingOrder == SortOrder.ASCENDING) {\n                            for (int row = 0; row < rowCount; row++) {\n                                renderer.drawItem(g2, state, dataArea, this, \n                                        domainAxis, rangeAxis, currentDataset, \n                                        row, column, pass);\n                            }\n                        }\n                        else {\n                            for (int row = rowCount - 1; row >= 0; row--) {\n                                renderer.drawItem(g2, state, dataArea, this, \n                                        domainAxis, rangeAxis, currentDataset, \n                                        row, column, pass);\n                            }                        \n                        }\n                    }\n                }\n            }\n        }\n        return foundData;\n        \n    }\n\n    \n    protected void drawDomainGridlines(Graphics2D g2, Rectangle2D dataArea) {\n\n        \n        if (isDomainGridlinesVisible()) {\n            CategoryAnchor anchor = getDomainGridlinePosition();\n            RectangleEdge domainAxisEdge = getDomainAxisEdge();\n            Stroke gridStroke = getDomainGridlineStroke();\n            Paint gridPaint = getDomainGridlinePaint();\n            if ((gridStroke != null) && (gridPaint != null)) {\n                \n                CategoryDataset data = getDataset();\n                if (data != null) {\n                    CategoryAxis axis = getDomainAxis();\n                    if (axis != null) {\n                        int columnCount = data.getColumnCount();\n                        for (int c = 0; c < columnCount; c++) {\n                            double xx = axis.getCategoryJava2DCoordinate(\n                                    anchor, c, columnCount, dataArea, \n                                    domainAxisEdge);\n                            CategoryItemRenderer renderer1 = getRenderer();\n                            if (renderer1 != null) {\n                                renderer1.drawDomainGridline(g2, this, \n                                        dataArea, xx);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n \n    \n    protected void drawRangeGridlines(Graphics2D g2, Rectangle2D dataArea, List ticks) {\n        \n        if (isRangeGridlinesVisible()) {\n            Stroke gridStroke = getRangeGridlineStroke();\n            Paint gridPaint = getRangeGridlinePaint();\n            if ((gridStroke != null) && (gridPaint != null)) {\n                ValueAxis axis = getRangeAxis();\n                if (axis != null) {\n                    Iterator iterator = ticks.iterator();\n                    while (iterator.hasNext()) {\n                        ValueTick tick = (ValueTick) iterator.next();\n                        CategoryItemRenderer renderer1 = getRenderer();\n                        if (renderer1 != null) {\n                            renderer1.drawRangeGridline(g2, this, \n                                    getRangeAxis(), dataArea, tick.getValue());\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    \n    protected void drawAnnotations(Graphics2D g2, Rectangle2D dataArea, PlotRenderingInfo info) {\n\n        Iterator iterator = getAnnotations().iterator();\n        while (iterator.hasNext()) {\n            CategoryAnnotation annotation \n                    = (CategoryAnnotation) iterator.next();\n            annotation.draw(g2, this, dataArea, getDomainAxis(), \n                    getRangeAxis(), 0, info);\n        }\n\n    }\n\n    \n    protected void drawDomainMarkers(Graphics2D g2, Rectangle2D dataArea, int index, Layer layer) {\n                                                 \n        CategoryItemRenderer r = getRenderer(index);\n        if (r == null) {\n            return;\n        }\n        \n        Collection markers = getDomainMarkers(index, layer);\n        CategoryAxis axis = getDomainAxisForDataset(index);\n        if (markers != null && axis != null) {\n            Iterator iterator = markers.iterator();\n            while (iterator.hasNext()) {\n                CategoryMarker marker = (CategoryMarker) iterator.next();\n                r.drawDomainMarker(g2, this, axis, marker, dataArea);\n            }\n        }\n        \n    }\n\n    \n    protected void drawRangeMarkers(Graphics2D g2, Rectangle2D dataArea, int index, Layer layer) {\n                                                 \n        CategoryItemRenderer r = getRenderer(index);\n        if (r == null) {\n            return;\n        }\n        \n        Collection markers = getRangeMarkers(index, layer);\n        ValueAxis axis = getRangeAxisForDataset(index);\n        if (markers != null && axis != null) {\n            Iterator iterator = markers.iterator();\n            while (iterator.hasNext()) {\n                Marker marker = (Marker) iterator.next();\n                r.drawRangeMarker(g2, this, axis, marker, dataArea);\n            }\n        }\n        \n    }\n\n    \n    protected void drawRangeLine(Graphics2D g2, Rectangle2D dataArea, double value, Stroke stroke, Paint paint) {\n\n        double java2D = getRangeAxis().valueToJava2D(value, dataArea, \n                getRangeAxisEdge());\n        Line2D line = null;\n        if (this.orientation == PlotOrientation.HORIZONTAL) {\n            line = new Line2D.Double(java2D, dataArea.getMinY(), java2D, \n                    dataArea.getMaxY());\n        }\n        else if (this.orientation == PlotOrientation.VERTICAL) {\n            line = new Line2D.Double(dataArea.getMinX(), java2D, \n                    dataArea.getMaxX(), java2D);\n        }\n        g2.setStroke(stroke);\n        g2.setPaint(paint);\n        g2.draw(line);\n\n    }\n\n    \n    protected void drawRangeCrosshair(Graphics2D g2, Rectangle2D dataArea, PlotOrientation orientation, double value, ValueAxis axis, Stroke stroke, Paint paint) {\n        \n        if (!axis.getRange().contains(value)) {\n            return;\n        }\n        Line2D line = null;\n        if (orientation == PlotOrientation.HORIZONTAL) {\n            double xx = axis.valueToJava2D(value, dataArea, \n                    RectangleEdge.BOTTOM);\n            line = new Line2D.Double(xx, dataArea.getMinY(), xx, \n                    dataArea.getMaxY());\n        }\n        else {\n            double yy = axis.valueToJava2D(value, dataArea, \n                    RectangleEdge.LEFT);\n            line = new Line2D.Double(dataArea.getMinX(), yy, \n                    dataArea.getMaxX(), yy);\n        }\n        g2.setStroke(stroke);\n        g2.setPaint(paint);\n        g2.draw(line);\n       \n    }\n    \n    \n    public Range getDataRange(ValueAxis axis) {\n\n        Range result = null;\n        List mappedDatasets = new ArrayList();\n        \n        int rangeIndex = this.rangeAxes.indexOf(axis);\n        if (rangeIndex >= 0) {\n            mappedDatasets.addAll(datasetsMappedToRangeAxis(rangeIndex));\n        }\n        else if (axis == getRangeAxis()) {\n            mappedDatasets.addAll(datasetsMappedToRangeAxis(0));\n        }\n\n        \n        \n        Iterator iterator = mappedDatasets.iterator();\n        while (iterator.hasNext()) {\n            CategoryDataset d = (CategoryDataset) iterator.next();\n            CategoryItemRenderer r = getRendererForDataset(d);\n            if (r != null) {\n                result = Range.combine(result, r.findRangeBounds(d));\n            }\n        }\n        return result;\n\n    }\n\n    \n    private List datasetsMappedToDomainAxis(int axisIndex) {\n        List result = new ArrayList();\n        for (int datasetIndex = 0; datasetIndex < this.datasets.size(); \n                datasetIndex++) {\n            Object dataset = this.datasets.get(datasetIndex);\n            if (dataset != null) {\n                Integer m = (Integer) this.datasetToDomainAxisMap.get(\n                        datasetIndex);\n                if (m == null) {  \n                                  \n                    if (axisIndex == 0) {\n                        result.add(dataset);\n                    }\n                }\n                else {\n                    if (m.intValue() == axisIndex) {\n                        result.add(dataset);\n                    }\n                }\n            }\n        }\n        return result;\n    }\n    \n    \n    private List datasetsMappedToRangeAxis(int index) {\n        List result = new ArrayList();\n        for (int i = 0; i < this.datasets.size(); i++) {\n            Object dataset = this.datasets.get(i);\n            if (dataset != null) {\n                Integer m = (Integer) this.datasetToRangeAxisMap.get(i);\n                if (m == null) {  \n                                  \n                    if (index == 0) { \n                        result.add(dataset);\n                    }\n                }\n                else {\n                    if (m.intValue() == index) {\n                        result.add(dataset);\n                    }\n                }\n            }\n        }\n        return result;    \n    }\n\n    \n    public int getWeight() {\n        return this.weight;\n    }\n\n    \n    public void setWeight(int weight) {\n        this.weight = weight;\n        fireChangeEvent();\n    }\n    \n    \n    public AxisSpace getFixedDomainAxisSpace() {\n        return this.fixedDomainAxisSpace;\n    }\n\n    \n    public void setFixedDomainAxisSpace(AxisSpace space) {\n        setFixedDomainAxisSpace(space, true);\n    }\n\n    \n    public void setFixedDomainAxisSpace(AxisSpace space, boolean notify) {\n        this.fixedDomainAxisSpace = space;\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    \n    public AxisSpace getFixedRangeAxisSpace() {\n        return this.fixedRangeAxisSpace;\n    }\n\n    \n    public void setFixedRangeAxisSpace(AxisSpace space) {\n        setFixedRangeAxisSpace(space, true);\n    }\n\n    \n    public void setFixedRangeAxisSpace(AxisSpace space, boolean notify) {\n        this.fixedRangeAxisSpace = space;\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    \n    public List getCategories() {\n        List result = null;\n        if (getDataset() != null) {\n            result = Collections.unmodifiableList(getDataset().getColumnKeys());\n        }\n        return result;\n    }\n    \n    \n    public List getCategoriesForAxis(CategoryAxis axis) {\n        List result = new ArrayList();\n        int axisIndex = this.domainAxes.indexOf(axis);\n        List datasets = datasetsMappedToDomainAxis(axisIndex);\n        Iterator iterator = datasets.iterator();\n        while (iterator.hasNext()) {\n            CategoryDataset dataset = (CategoryDataset) iterator.next();\n            \n            for (int i = 0; i < dataset.getColumnCount(); i++) {\n                Comparable category = dataset.getColumnKey(i);\n                if (!result.contains(category)) {\n                    result.add(category);\n                }\n            }\n        }\n        return result;\n    }\n\n    \n    public boolean getDrawSharedDomainAxis() {\n        return this.drawSharedDomainAxis;\n    }\n    \n    \n    public void setDrawSharedDomainAxis(boolean draw) {\n        this.drawSharedDomainAxis = draw;\n        fireChangeEvent();\n    }\n\n    \n    public boolean isDomainZoomable() {\n        return false;\n    }\n    \n    \n    public boolean isRangeZoomable() {\n        return true;\n    }\n\n    \n    public void zoomDomainAxes(double factor, PlotRenderingInfo state, Point2D source) {\n        \n    }\n\n    \n    public void zoomDomainAxes(double lowerPercent, double upperPercent, PlotRenderingInfo state, Point2D source) {\n        \n    }\n    \n    \n    public void zoomDomainAxes(double factor, PlotRenderingInfo info, Point2D source, boolean useAnchor) {\n        \n    }\n\n    \n    public void zoomRangeAxes(double factor, PlotRenderingInfo state, Point2D source) {\n        \n        zoomRangeAxes(factor, state, source, false);    \n    }\n\n    \n    public void zoomRangeAxes(double factor, PlotRenderingInfo info, Point2D source, boolean useAnchor) {\n                \n        \n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis rangeAxis = (ValueAxis) this.rangeAxes.get(i);\n            if (rangeAxis != null) {\n                if (useAnchor) {\n                    \n                    \n                    double sourceY = source.getY();\n                    if (this.orientation == PlotOrientation.HORIZONTAL) {\n                        sourceY = source.getX();\n                    }\n                    double anchorY = rangeAxis.java2DToValue(sourceY, \n                            info.getDataArea(), getRangeAxisEdge());\n                    rangeAxis.resizeRange(factor, anchorY);\n                }\n                else {\n                    rangeAxis.resizeRange(factor);\n                }\n            }\n        }\n    }\n\n    \n    public void zoomRangeAxes(double lowerPercent, double upperPercent, PlotRenderingInfo state, Point2D source) {\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis rangeAxis = (ValueAxis) this.rangeAxes.get(i);\n            if (rangeAxis != null) {\n                rangeAxis.zoomRange(lowerPercent, upperPercent);\n            }\n        }\n    }\n    \n    \n    public double getAnchorValue() {\n        return this.anchorValue;\n    }\n\n    \n    public void setAnchorValue(double value) {\n        setAnchorValue(value, true);\n    }\n\n    \n    public void setAnchorValue(double value, boolean notify) {\n        this.anchorValue = value;\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n    \n    \n    public boolean equals(Object obj) {\n    \n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof CategoryPlot)) {\n            return false;\n        }\n        if (!super.equals(obj)) {\n            return false;\n        }\n\n        CategoryPlot that = (CategoryPlot) obj;\n            \n        if (this.orientation != that.orientation) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.axisOffset, that.axisOffset)) {\n            return false;\n        }\n        if (!this.domainAxes.equals(that.domainAxes)) {\n            return false;\n        }\n        if (!this.domainAxisLocations.equals(that.domainAxisLocations)) {\n            return false;\n        }\n        if (this.drawSharedDomainAxis != that.drawSharedDomainAxis) {\n            return false;\n        }\n        if (!this.rangeAxes.equals(that.rangeAxes)) {\n            return false;\n        }\n        if (!this.rangeAxisLocations.equals(that.rangeAxisLocations)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.datasetToDomainAxisMap, \n                that.datasetToDomainAxisMap)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.datasetToRangeAxisMap, \n                that.datasetToRangeAxisMap)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.renderers, that.renderers)) {\n            return false;\n        }\n        if (this.renderingOrder != that.renderingOrder) {\n            return false;\n        }\n        if (this.columnRenderingOrder != that.columnRenderingOrder) {\n            return false;\n        }\n        if (this.rowRenderingOrder != that.rowRenderingOrder) {\n            return false;\n        }\n        if (this.domainGridlinesVisible != that.domainGridlinesVisible) {\n            return false;\n        }\n        if (this.domainGridlinePosition != that.domainGridlinePosition) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.domainGridlineStroke, \n                that.domainGridlineStroke)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.domainGridlinePaint, \n                that.domainGridlinePaint)) {\n            return false;\n        }\n        if (this.rangeGridlinesVisible != that.rangeGridlinesVisible) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.rangeGridlineStroke, \n                that.rangeGridlineStroke)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.rangeGridlinePaint, \n                that.rangeGridlinePaint)) {\n            return false;\n        }\n        if (this.anchorValue != that.anchorValue) {\n            return false;\n        }\n        if (this.rangeCrosshairVisible != that.rangeCrosshairVisible) {\n            return false;\n        }\n        if (this.rangeCrosshairValue != that.rangeCrosshairValue) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.rangeCrosshairStroke, \n                that.rangeCrosshairStroke)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.rangeCrosshairPaint, \n                that.rangeCrosshairPaint)) {\n            return false;\n        }\n        if (this.rangeCrosshairLockedOnData \n                != that.rangeCrosshairLockedOnData) {\n            return false;\n        }      \n        if (!ObjectUtilities.equal(this.foregroundRangeMarkers, \n                that.foregroundRangeMarkers)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.backgroundRangeMarkers, \n                that.backgroundRangeMarkers)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.annotations, that.annotations)) {\n            return false;\n        }\n        if (this.weight != that.weight) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.fixedDomainAxisSpace, \n                that.fixedDomainAxisSpace)) {\n            return false;\n        }    \n        if (!ObjectUtilities.equal(this.fixedRangeAxisSpace, \n                that.fixedRangeAxisSpace)) {\n            return false;\n        }    \n        \n        return true;\n        \n    }\n    \n    \n    public Object clone() throws CloneNotSupportedException {\n        \n        CategoryPlot clone = (CategoryPlot) super.clone();\n        \n        clone.domainAxes = new ObjectList();\n        for (int i = 0; i < this.domainAxes.size(); i++) {\n            CategoryAxis xAxis = (CategoryAxis) this.domainAxes.get(i);\n            if (xAxis != null) {\n                CategoryAxis clonedAxis = (CategoryAxis) xAxis.clone();\n                clone.setDomainAxis(i, clonedAxis);\n            }\n        }\n        clone.domainAxisLocations \n            = (ObjectList) this.domainAxisLocations.clone();\n\n        clone.rangeAxes = new ObjectList();\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis yAxis = (ValueAxis) this.rangeAxes.get(i);\n            if (yAxis != null) {\n                ValueAxis clonedAxis = (ValueAxis) yAxis.clone();\n                clone.setRangeAxis(i, clonedAxis);\n            }\n        }\n        clone.rangeAxisLocations = (ObjectList) this.rangeAxisLocations.clone();\n\n        clone.datasets = (ObjectList) this.datasets.clone();\n        for (int i = 0; i < clone.datasets.size(); i++) {\n            CategoryDataset dataset = clone.getDataset(i);\n            if (dataset != null) {\n                dataset.addChangeListener(clone);\n            }\n        }\n        clone.datasetToDomainAxisMap \n            = (ObjectList) this.datasetToDomainAxisMap.clone();\n        clone.datasetToRangeAxisMap \n            = (ObjectList) this.datasetToRangeAxisMap.clone();\n        clone.renderers = (ObjectList) this.renderers.clone();\n        if (this.fixedDomainAxisSpace != null) {\n            clone.fixedDomainAxisSpace = (AxisSpace) ObjectUtilities.clone(\n                    this.fixedDomainAxisSpace);\n        }\n        if (this.fixedRangeAxisSpace != null) {\n            clone.fixedRangeAxisSpace = (AxisSpace) ObjectUtilities.clone(\n                    this.fixedRangeAxisSpace);\n        }\n        \n        return clone;\n            \n    }\n    \n    \n    private void writeObject(ObjectOutputStream stream) throws IOException {\n        stream.defaultWriteObject();\n        SerialUtilities.writeStroke(this.domainGridlineStroke, stream);\n        SerialUtilities.writePaint(this.domainGridlinePaint, stream);\n        SerialUtilities.writeStroke(this.rangeGridlineStroke, stream);\n        SerialUtilities.writePaint(this.rangeGridlinePaint, stream);\n        SerialUtilities.writeStroke(this.rangeCrosshairStroke, stream);\n        SerialUtilities.writePaint(this.rangeCrosshairPaint, stream);\n    }\n\n    \n    private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {\n\n        stream.defaultReadObject();\n        this.domainGridlineStroke = SerialUtilities.readStroke(stream);\n        this.domainGridlinePaint = SerialUtilities.readPaint(stream);\n        this.rangeGridlineStroke = SerialUtilities.readStroke(stream);\n        this.rangeGridlinePaint = SerialUtilities.readPaint(stream);\n        this.rangeCrosshairStroke = SerialUtilities.readStroke(stream);\n        this.rangeCrosshairPaint = SerialUtilities.readPaint(stream);\n\n        for (int i = 0; i < this.domainAxes.size(); i++) {\n            CategoryAxis xAxis = (CategoryAxis) this.domainAxes.get(i);\n            if (xAxis != null) {\n                xAxis.setPlot(this);\n                xAxis.addChangeListener(this);\n            }\n        } \n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis yAxis = (ValueAxis) this.rangeAxes.get(i);\n            if (yAxis != null) {\n                yAxis.setPlot(this);   \n                yAxis.addChangeListener(this);\n            }\n        }\n        int datasetCount = this.datasets.size();\n        for (int i = 0; i < datasetCount; i++) {\n            Dataset dataset = (Dataset) this.datasets.get(i);\n            if (dataset != null) {\n                dataset.addChangeListener(this);\n            }\n        }\n        int rendererCount = this.renderers.size();\n        for (int i = 0; i < rendererCount; i++) {\n            CategoryItemRenderer renderer \n                = (CategoryItemRenderer) this.renderers.get(i);\n            if (renderer != null) {\n                renderer.addChangeListener(this);\n            }\n        }\n\n    }\n\n}\n",
      "buggy_signatures": [
        "public CategoryPlot(CategoryDataset dataset, CategoryAxis domainAxis, ValueAxis rangeAxis, CategoryItemRenderer renderer)",
        "public String getPlotType()",
        "public PlotOrientation getOrientation()",
        "public void setOrientation(PlotOrientation orientation)",
        "public RectangleInsets getAxisOffset()",
        "public void setAxisOffset(RectangleInsets offset)",
        "public CategoryAxis getDomainAxis()",
        "public CategoryAxis getDomainAxis(int index)",
        "public void setDomainAxis(CategoryAxis axis)",
        "public void setDomainAxis(int index, CategoryAxis axis)",
        "public void setDomainAxis(int index, CategoryAxis axis, boolean notify)",
        "public void setDomainAxes(CategoryAxis[] axes)",
        "public int getDomainAxisIndex(CategoryAxis axis)",
        "public AxisLocation getDomainAxisLocation()",
        "public AxisLocation getDomainAxisLocation(int index)",
        "public void setDomainAxisLocation(AxisLocation location)",
        "public void setDomainAxisLocation(AxisLocation location, boolean notify)",
        "public void setDomainAxisLocation(int index, AxisLocation location)",
        "public void setDomainAxisLocation(int index, AxisLocation location, boolean notify)",
        "public RectangleEdge getDomainAxisEdge()",
        "public RectangleEdge getDomainAxisEdge(int index)",
        "public int getDomainAxisCount()",
        "public void clearDomainAxes()",
        "public void configureDomainAxes()",
        "public ValueAxis getRangeAxis()",
        "public ValueAxis getRangeAxis(int index)",
        "public void setRangeAxis(ValueAxis axis)",
        "public void setRangeAxis(int index, ValueAxis axis)",
        "public void setRangeAxis(int index, ValueAxis axis, boolean notify)",
        "public void setRangeAxes(ValueAxis[] axes)",
        "public int getRangeAxisIndex(ValueAxis axis)",
        "public AxisLocation getRangeAxisLocation()",
        "public AxisLocation getRangeAxisLocation(int index)",
        "public void setRangeAxisLocation(AxisLocation location)",
        "public void setRangeAxisLocation(AxisLocation location, boolean notify)",
        "public void setRangeAxisLocation(int index, AxisLocation location)",
        "public void setRangeAxisLocation(int index, AxisLocation location, boolean notify)",
        "public RectangleEdge getRangeAxisEdge()",
        "public RectangleEdge getRangeAxisEdge(int index)",
        "public int getRangeAxisCount()",
        "public void clearRangeAxes()",
        "public void configureRangeAxes()",
        "public CategoryDataset getDataset()",
        "public CategoryDataset getDataset(int index)",
        "public void setDataset(CategoryDataset dataset)",
        "public void setDataset(int index, CategoryDataset dataset)",
        "public int getDatasetCount()",
        "public void mapDatasetToDomainAxis(int index, int axisIndex)",
        "public CategoryAxis getDomainAxisForDataset(int index)",
        "public void mapDatasetToRangeAxis(int index, int axisIndex)",
        "public ValueAxis getRangeAxisForDataset(int index)",
        "public CategoryItemRenderer getRenderer()",
        "public CategoryItemRenderer getRenderer(int index)",
        "public void setRenderer(CategoryItemRenderer renderer)",
        "public void setRenderer(CategoryItemRenderer renderer, boolean notify)",
        "public void setRenderer(int index, CategoryItemRenderer renderer)",
        "public void setRenderer(int index, CategoryItemRenderer renderer, boolean notify)",
        "public void setRenderers(CategoryItemRenderer[] renderers)",
        "public CategoryItemRenderer getRendererForDataset(CategoryDataset dataset)",
        "public int getIndexOf(CategoryItemRenderer renderer)",
        "public DatasetRenderingOrder getDatasetRenderingOrder()",
        "public void setDatasetRenderingOrder(DatasetRenderingOrder order)",
        "public SortOrder getColumnRenderingOrder()",
        "public void setColumnRenderingOrder(SortOrder order)",
        "public SortOrder getRowRenderingOrder()",
        "public void setRowRenderingOrder(SortOrder order)",
        "public boolean isDomainGridlinesVisible()",
        "public void setDomainGridlinesVisible(boolean visible)",
        "public CategoryAnchor getDomainGridlinePosition()",
        "public void setDomainGridlinePosition(CategoryAnchor position)",
        "public Stroke getDomainGridlineStroke()",
        "public void setDomainGridlineStroke(Stroke stroke)",
        "public Paint getDomainGridlinePaint()",
        "public void setDomainGridlinePaint(Paint paint)",
        "public boolean isRangeGridlinesVisible()",
        "public void setRangeGridlinesVisible(boolean visible)",
        "public Stroke getRangeGridlineStroke()",
        "public void setRangeGridlineStroke(Stroke stroke)",
        "public Paint getRangeGridlinePaint()",
        "public void setRangeGridlinePaint(Paint paint)",
        "public LegendItemCollection getFixedLegendItems()",
        "public void setFixedLegendItems(LegendItemCollection items)",
        "public LegendItemCollection getLegendItems()",
        "public void handleClick(int x, int y, PlotRenderingInfo info)",
        "public void zoom(double percent)",
        "public void datasetChanged(DatasetChangeEvent event)",
        "public void rendererChanged(RendererChangeEvent event)",
        "public void addDomainMarker(CategoryMarker marker)",
        "public void addDomainMarker(CategoryMarker marker, Layer layer)",
        "public void addDomainMarker(int index, CategoryMarker marker, Layer layer)",
        "public void addDomainMarker(int index, CategoryMarker marker, Layer layer, boolean notify)",
        "public void clearDomainMarkers()",
        "public Collection getDomainMarkers(Layer layer)",
        "public Collection getDomainMarkers(int index, Layer layer)",
        "public void clearDomainMarkers(int index)",
        "public boolean removeDomainMarker(Marker marker)",
        "public boolean removeDomainMarker(Marker marker, Layer layer)",
        "public boolean removeDomainMarker(int index, Marker marker, Layer layer)",
        "public boolean removeDomainMarker(int index, Marker marker, Layer layer, boolean notify)",
        "public void addRangeMarker(Marker marker)",
        "public void addRangeMarker(Marker marker, Layer layer)",
        "public void addRangeMarker(int index, Marker marker, Layer layer)",
        "public void addRangeMarker(int index, Marker marker, Layer layer, boolean notify)",
        "public void clearRangeMarkers()",
        "public Collection getRangeMarkers(Layer layer)",
        "public Collection getRangeMarkers(int index, Layer layer)",
        "public void clearRangeMarkers(int index)",
        "public boolean removeRangeMarker(Marker marker)",
        "public boolean removeRangeMarker(Marker marker, Layer layer)",
        "public boolean removeRangeMarker(int index, Marker marker, Layer layer)",
        "public boolean removeRangeMarker(int index, Marker marker, Layer layer, boolean notify)",
        "public boolean isRangeCrosshairVisible()",
        "public void setRangeCrosshairVisible(boolean flag)",
        "public boolean isRangeCrosshairLockedOnData()",
        "public void setRangeCrosshairLockedOnData(boolean flag)",
        "public double getRangeCrosshairValue()",
        "public void setRangeCrosshairValue(double value)",
        "public void setRangeCrosshairValue(double value, boolean notify)",
        "public Stroke getRangeCrosshairStroke()",
        "public void setRangeCrosshairStroke(Stroke stroke)",
        "public Paint getRangeCrosshairPaint()",
        "public void setRangeCrosshairPaint(Paint paint)",
        "public List getAnnotations()",
        "public void addAnnotation(CategoryAnnotation annotation)",
        "public void addAnnotation(CategoryAnnotation annotation, boolean notify)",
        "public boolean removeAnnotation(CategoryAnnotation annotation)",
        "public boolean removeAnnotation(CategoryAnnotation annotation, boolean notify)",
        "public void clearAnnotations()",
        "protected AxisSpace calculateDomainAxisSpace(Graphics2D g2, Rectangle2D plotArea, AxisSpace space)",
        "protected AxisSpace calculateRangeAxisSpace(Graphics2D g2, Rectangle2D plotArea, AxisSpace space)",
        "protected AxisSpace calculateAxisSpace(Graphics2D g2, Rectangle2D plotArea)",
        "public void draw(Graphics2D g2, Rectangle2D area, Point2D anchor, PlotState parentState, PlotRenderingInfo state)",
        "public void drawBackground(Graphics2D g2, Rectangle2D area)",
        "protected Map drawAxes(Graphics2D g2, Rectangle2D plotArea, Rectangle2D dataArea, PlotRenderingInfo plotState)",
        "public boolean render(Graphics2D g2, Rectangle2D dataArea, int index, PlotRenderingInfo info)",
        "protected void drawDomainGridlines(Graphics2D g2, Rectangle2D dataArea)",
        "protected void drawRangeGridlines(Graphics2D g2, Rectangle2D dataArea, List ticks)",
        "protected void drawAnnotations(Graphics2D g2, Rectangle2D dataArea, PlotRenderingInfo info)",
        "protected void drawDomainMarkers(Graphics2D g2, Rectangle2D dataArea, int index, Layer layer)",
        "protected void drawRangeMarkers(Graphics2D g2, Rectangle2D dataArea, int index, Layer layer)",
        "protected void drawRangeLine(Graphics2D g2, Rectangle2D dataArea, double value, Stroke stroke, Paint paint)",
        "protected void drawRangeCrosshair(Graphics2D g2, Rectangle2D dataArea, PlotOrientation orientation, double value, ValueAxis axis, Stroke stroke, Paint paint)",
        "public Range getDataRange(ValueAxis axis)",
        "private List datasetsMappedToDomainAxis(int axisIndex)",
        "private List datasetsMappedToRangeAxis(int index)",
        "public int getWeight()",
        "public void setWeight(int weight)",
        "public AxisSpace getFixedDomainAxisSpace()",
        "public void setFixedDomainAxisSpace(AxisSpace space)",
        "public void setFixedDomainAxisSpace(AxisSpace space, boolean notify)",
        "public AxisSpace getFixedRangeAxisSpace()",
        "public void setFixedRangeAxisSpace(AxisSpace space)",
        "public void setFixedRangeAxisSpace(AxisSpace space, boolean notify)",
        "public List getCategories()",
        "public List getCategoriesForAxis(CategoryAxis axis)",
        "public boolean getDrawSharedDomainAxis()",
        "public void setDrawSharedDomainAxis(boolean draw)",
        "public boolean isDomainZoomable()",
        "public boolean isRangeZoomable()",
        "public void zoomDomainAxes(double factor, PlotRenderingInfo state, Point2D source)",
        "public void zoomDomainAxes(double lowerPercent, double upperPercent, PlotRenderingInfo state, Point2D source)",
        "public void zoomDomainAxes(double factor, PlotRenderingInfo info, Point2D source, boolean useAnchor)",
        "public void zoomRangeAxes(double factor, PlotRenderingInfo state, Point2D source)",
        "public void zoomRangeAxes(double factor, PlotRenderingInfo info, Point2D source, boolean useAnchor)",
        "public void zoomRangeAxes(double lowerPercent, double upperPercent, PlotRenderingInfo state, Point2D source)",
        "public double getAnchorValue()",
        "public void setAnchorValue(double value)",
        "public void setAnchorValue(double value, boolean notify)",
        "public boolean equals(Object obj)",
        "public Object clone() throws CloneNotSupportedException",
        "private void writeObject(ObjectOutputStream stream) throws IOException",
        "private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException"
      ],
      "fixed_signatures": [
        "public CategoryPlot(CategoryDataset dataset, CategoryAxis domainAxis, ValueAxis rangeAxis, CategoryItemRenderer renderer)",
        "public String getPlotType()",
        "public PlotOrientation getOrientation()",
        "public void setOrientation(PlotOrientation orientation)",
        "public RectangleInsets getAxisOffset()",
        "public void setAxisOffset(RectangleInsets offset)",
        "public CategoryAxis getDomainAxis()",
        "public CategoryAxis getDomainAxis(int index)",
        "public void setDomainAxis(CategoryAxis axis)",
        "public void setDomainAxis(int index, CategoryAxis axis)",
        "public void setDomainAxis(int index, CategoryAxis axis, boolean notify)",
        "public void setDomainAxes(CategoryAxis[] axes)",
        "public int getDomainAxisIndex(CategoryAxis axis)",
        "public AxisLocation getDomainAxisLocation()",
        "public AxisLocation getDomainAxisLocation(int index)",
        "public void setDomainAxisLocation(AxisLocation location)",
        "public void setDomainAxisLocation(AxisLocation location, boolean notify)",
        "public void setDomainAxisLocation(int index, AxisLocation location)",
        "public void setDomainAxisLocation(int index, AxisLocation location, boolean notify)",
        "public RectangleEdge getDomainAxisEdge()",
        "public RectangleEdge getDomainAxisEdge(int index)",
        "public int getDomainAxisCount()",
        "public void clearDomainAxes()",
        "public void configureDomainAxes()",
        "public ValueAxis getRangeAxis()",
        "public ValueAxis getRangeAxis(int index)",
        "public void setRangeAxis(ValueAxis axis)",
        "public void setRangeAxis(int index, ValueAxis axis)",
        "public void setRangeAxis(int index, ValueAxis axis, boolean notify)",
        "public void setRangeAxes(ValueAxis[] axes)",
        "public int getRangeAxisIndex(ValueAxis axis)",
        "public AxisLocation getRangeAxisLocation()",
        "public AxisLocation getRangeAxisLocation(int index)",
        "public void setRangeAxisLocation(AxisLocation location)",
        "public void setRangeAxisLocation(AxisLocation location, boolean notify)",
        "public void setRangeAxisLocation(int index, AxisLocation location)",
        "public void setRangeAxisLocation(int index, AxisLocation location, boolean notify)",
        "public RectangleEdge getRangeAxisEdge()",
        "public RectangleEdge getRangeAxisEdge(int index)",
        "public int getRangeAxisCount()",
        "public void clearRangeAxes()",
        "public void configureRangeAxes()",
        "public CategoryDataset getDataset()",
        "public CategoryDataset getDataset(int index)",
        "public void setDataset(CategoryDataset dataset)",
        "public void setDataset(int index, CategoryDataset dataset)",
        "public int getDatasetCount()",
        "public void mapDatasetToDomainAxis(int index, int axisIndex)",
        "public CategoryAxis getDomainAxisForDataset(int index)",
        "public void mapDatasetToRangeAxis(int index, int axisIndex)",
        "public ValueAxis getRangeAxisForDataset(int index)",
        "public CategoryItemRenderer getRenderer()",
        "public CategoryItemRenderer getRenderer(int index)",
        "public void setRenderer(CategoryItemRenderer renderer)",
        "public void setRenderer(CategoryItemRenderer renderer, boolean notify)",
        "public void setRenderer(int index, CategoryItemRenderer renderer)",
        "public void setRenderer(int index, CategoryItemRenderer renderer, boolean notify)",
        "public void setRenderers(CategoryItemRenderer[] renderers)",
        "public CategoryItemRenderer getRendererForDataset(CategoryDataset dataset)",
        "public int getIndexOf(CategoryItemRenderer renderer)",
        "public DatasetRenderingOrder getDatasetRenderingOrder()",
        "public void setDatasetRenderingOrder(DatasetRenderingOrder order)",
        "public SortOrder getColumnRenderingOrder()",
        "public void setColumnRenderingOrder(SortOrder order)",
        "public SortOrder getRowRenderingOrder()",
        "public void setRowRenderingOrder(SortOrder order)",
        "public boolean isDomainGridlinesVisible()",
        "public void setDomainGridlinesVisible(boolean visible)",
        "public CategoryAnchor getDomainGridlinePosition()",
        "public void setDomainGridlinePosition(CategoryAnchor position)",
        "public Stroke getDomainGridlineStroke()",
        "public void setDomainGridlineStroke(Stroke stroke)",
        "public Paint getDomainGridlinePaint()",
        "public void setDomainGridlinePaint(Paint paint)",
        "public boolean isRangeGridlinesVisible()",
        "public void setRangeGridlinesVisible(boolean visible)",
        "public Stroke getRangeGridlineStroke()",
        "public void setRangeGridlineStroke(Stroke stroke)",
        "public Paint getRangeGridlinePaint()",
        "public void setRangeGridlinePaint(Paint paint)",
        "public LegendItemCollection getFixedLegendItems()",
        "public void setFixedLegendItems(LegendItemCollection items)",
        "public LegendItemCollection getLegendItems()",
        "public void handleClick(int x, int y, PlotRenderingInfo info)",
        "public void zoom(double percent)",
        "public void datasetChanged(DatasetChangeEvent event)",
        "public void rendererChanged(RendererChangeEvent event)",
        "public void addDomainMarker(CategoryMarker marker)",
        "public void addDomainMarker(CategoryMarker marker, Layer layer)",
        "public void addDomainMarker(int index, CategoryMarker marker, Layer layer)",
        "public void addDomainMarker(int index, CategoryMarker marker, Layer layer, boolean notify)",
        "public void clearDomainMarkers()",
        "public Collection getDomainMarkers(Layer layer)",
        "public Collection getDomainMarkers(int index, Layer layer)",
        "public void clearDomainMarkers(int index)",
        "public boolean removeDomainMarker(Marker marker)",
        "public boolean removeDomainMarker(Marker marker, Layer layer)",
        "public boolean removeDomainMarker(int index, Marker marker, Layer layer)",
        "public boolean removeDomainMarker(int index, Marker marker, Layer layer, boolean notify)",
        "public void addRangeMarker(Marker marker)",
        "public void addRangeMarker(Marker marker, Layer layer)",
        "public void addRangeMarker(int index, Marker marker, Layer layer)",
        "public void addRangeMarker(int index, Marker marker, Layer layer, boolean notify)",
        "public void clearRangeMarkers()",
        "public Collection getRangeMarkers(Layer layer)",
        "public Collection getRangeMarkers(int index, Layer layer)",
        "public void clearRangeMarkers(int index)",
        "public boolean removeRangeMarker(Marker marker)",
        "public boolean removeRangeMarker(Marker marker, Layer layer)",
        "public boolean removeRangeMarker(int index, Marker marker, Layer layer)",
        "public boolean removeRangeMarker(int index, Marker marker, Layer layer, boolean notify)",
        "public boolean isRangeCrosshairVisible()",
        "public void setRangeCrosshairVisible(boolean flag)",
        "public boolean isRangeCrosshairLockedOnData()",
        "public void setRangeCrosshairLockedOnData(boolean flag)",
        "public double getRangeCrosshairValue()",
        "public void setRangeCrosshairValue(double value)",
        "public void setRangeCrosshairValue(double value, boolean notify)",
        "public Stroke getRangeCrosshairStroke()",
        "public void setRangeCrosshairStroke(Stroke stroke)",
        "public Paint getRangeCrosshairPaint()",
        "public void setRangeCrosshairPaint(Paint paint)",
        "public List getAnnotations()",
        "public void addAnnotation(CategoryAnnotation annotation)",
        "public void addAnnotation(CategoryAnnotation annotation, boolean notify)",
        "public boolean removeAnnotation(CategoryAnnotation annotation)",
        "public boolean removeAnnotation(CategoryAnnotation annotation, boolean notify)",
        "public void clearAnnotations()",
        "protected AxisSpace calculateDomainAxisSpace(Graphics2D g2, Rectangle2D plotArea, AxisSpace space)",
        "protected AxisSpace calculateRangeAxisSpace(Graphics2D g2, Rectangle2D plotArea, AxisSpace space)",
        "protected AxisSpace calculateAxisSpace(Graphics2D g2, Rectangle2D plotArea)",
        "public void draw(Graphics2D g2, Rectangle2D area, Point2D anchor, PlotState parentState, PlotRenderingInfo state)",
        "public void drawBackground(Graphics2D g2, Rectangle2D area)",
        "protected Map drawAxes(Graphics2D g2, Rectangle2D plotArea, Rectangle2D dataArea, PlotRenderingInfo plotState)",
        "public boolean render(Graphics2D g2, Rectangle2D dataArea, int index, PlotRenderingInfo info)",
        "protected void drawDomainGridlines(Graphics2D g2, Rectangle2D dataArea)",
        "protected void drawRangeGridlines(Graphics2D g2, Rectangle2D dataArea, List ticks)",
        "protected void drawAnnotations(Graphics2D g2, Rectangle2D dataArea, PlotRenderingInfo info)",
        "protected void drawDomainMarkers(Graphics2D g2, Rectangle2D dataArea, int index, Layer layer)",
        "protected void drawRangeMarkers(Graphics2D g2, Rectangle2D dataArea, int index, Layer layer)",
        "protected void drawRangeLine(Graphics2D g2, Rectangle2D dataArea, double value, Stroke stroke, Paint paint)",
        "protected void drawRangeCrosshair(Graphics2D g2, Rectangle2D dataArea, PlotOrientation orientation, double value, ValueAxis axis, Stroke stroke, Paint paint)",
        "public Range getDataRange(ValueAxis axis)",
        "private List datasetsMappedToDomainAxis(int axisIndex)",
        "private List datasetsMappedToRangeAxis(int index)",
        "public int getWeight()",
        "public void setWeight(int weight)",
        "public AxisSpace getFixedDomainAxisSpace()",
        "public void setFixedDomainAxisSpace(AxisSpace space)",
        "public void setFixedDomainAxisSpace(AxisSpace space, boolean notify)",
        "public AxisSpace getFixedRangeAxisSpace()",
        "public void setFixedRangeAxisSpace(AxisSpace space)",
        "public void setFixedRangeAxisSpace(AxisSpace space, boolean notify)",
        "public List getCategories()",
        "public List getCategoriesForAxis(CategoryAxis axis)",
        "public boolean getDrawSharedDomainAxis()",
        "public void setDrawSharedDomainAxis(boolean draw)",
        "public boolean isDomainZoomable()",
        "public boolean isRangeZoomable()",
        "public void zoomDomainAxes(double factor, PlotRenderingInfo state, Point2D source)",
        "public void zoomDomainAxes(double lowerPercent, double upperPercent, PlotRenderingInfo state, Point2D source)",
        "public void zoomDomainAxes(double factor, PlotRenderingInfo info, Point2D source, boolean useAnchor)",
        "public void zoomRangeAxes(double factor, PlotRenderingInfo state, Point2D source)",
        "public void zoomRangeAxes(double factor, PlotRenderingInfo info, Point2D source, boolean useAnchor)",
        "public void zoomRangeAxes(double lowerPercent, double upperPercent, PlotRenderingInfo state, Point2D source)",
        "public double getAnchorValue()",
        "public void setAnchorValue(double value)",
        "public void setAnchorValue(double value, boolean notify)",
        "public boolean equals(Object obj)",
        "public Object clone() throws CloneNotSupportedException",
        "private void writeObject(ObjectOutputStream stream) throws IOException",
        "private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException"
      ],
      "methods": [
        {
          "buggy_method": "  public boolean removeDomainMarker(int index, Marker marker, Layer layer, boolean notify) {\n  ArrayList markers;\n  if (layer == Layer.FOREGROUND) {\n  markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer(\n  index));\n  }\n  else {\n  markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n  index));\n  }\n  boolean removed = markers.remove(marker);\n  if (removed && notify) {\n  fireChangeEvent();\n  }\n  return removed;\n  }",
          "fixed_method": "  public boolean removeDomainMarker(int index, Marker marker, Layer layer, boolean notify) {\n  ArrayList markers;\n  if (layer == Layer.FOREGROUND) {\n  markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer(\n  index));\n  }\n  else {\n  markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n  index));\n  }\n  if (markers == null) {\n  return false;\n  }\n  boolean removed = markers.remove(marker);\n  if (removed && notify) {\n  fireChangeEvent();\n  }\n  return removed;\n  }",
          "diff": [
            "@@ -2163,6 +2163,9 @@",
            "             markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n",
            "                     index));\n",
            "         }\n",
            "+        if (markers == null) {\n",
            "+            return false;\n",
            "+        }\n",
            "         boolean removed = markers.remove(marker);\n",
            "         if (removed && notify) {\n",
            "             fireChangeEvent();\n"
          ],
          "changed_lines": 3
        },
        {
          "buggy_method": "  public boolean removeRangeMarker(int index, Marker marker, Layer layer, boolean notify) {\n  if (marker == null) {\n  throw new IllegalArgumentException(\"Null 'marker' argument.\");\n  }\n  ArrayList markers;\n  if (layer == Layer.FOREGROUND) {\n  markers = (ArrayList) this.foregroundRangeMarkers.get(new Integer(\n  index));\n  }\n  else {\n  markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(\n  index));\n  }\n  boolean removed = markers.remove(marker);\n  if (removed && notify) {\n  fireChangeEvent();\n  }\n  return removed;\n  }",
          "fixed_method": "  public boolean removeRangeMarker(int index, Marker marker, Layer layer, boolean notify) {\n  if (marker == null) {\n  throw new IllegalArgumentException(\"Null 'marker' argument.\");\n  }\n  ArrayList markers;\n  if (layer == Layer.FOREGROUND) {\n  markers = (ArrayList) this.foregroundRangeMarkers.get(new Integer(\n  index));\n  }\n  else {\n  markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(\n  index));\n  }\n  if (markers == null) {\n  return false;\n  }\n  boolean removed = markers.remove(marker);\n  if (removed && notify) {\n  fireChangeEvent();\n  }\n  return removed;\n  }",
          "diff": [
            "@@ -2444,6 +2447,9 @@",
            "         else {\n",
            "             markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(\n",
            "                     index));\n",
            "+        }\n",
            "+        if (markers == null) {\n",
            "+            return false;\n",
            "         }\n",
            "         boolean removed = markers.remove(marker);\n",
            "         if (removed && notify) {\n"
          ],
          "changed_lines": 3
        }
      ]
    },
    {
      "name": "org/jfree/chart/plot/XYPlot.java",
      "buggy_full_code": "\n\npackage org.jfree.chart.plot;\n\nimport java.awt.AlphaComposite;\nimport java.awt.BasicStroke;\nimport java.awt.Color;\nimport java.awt.Composite;\nimport java.awt.Graphics2D;\nimport java.awt.Paint;\nimport java.awt.Shape;\nimport java.awt.Stroke;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.ResourceBundle;\nimport java.util.Set;\nimport java.util.TreeMap;\n\nimport org.jfree.chart.LegendItem;\nimport org.jfree.chart.LegendItemCollection;\nimport org.jfree.chart.annotations.XYAnnotation;\nimport org.jfree.chart.axis.Axis;\nimport org.jfree.chart.axis.AxisCollection;\nimport org.jfree.chart.axis.AxisLocation;\nimport org.jfree.chart.axis.AxisSpace;\nimport org.jfree.chart.axis.AxisState;\nimport org.jfree.chart.axis.ValueAxis;\nimport org.jfree.chart.axis.ValueTick;\nimport org.jfree.chart.event.ChartChangeEventType;\nimport org.jfree.chart.event.PlotChangeEvent;\nimport org.jfree.chart.event.RendererChangeEvent;\nimport org.jfree.chart.event.RendererChangeListener;\nimport org.jfree.chart.renderer.RendererUtilities;\nimport org.jfree.chart.renderer.xy.XYItemRenderer;\nimport org.jfree.chart.renderer.xy.XYItemRendererState;\nimport org.jfree.chart.util.Layer;\nimport org.jfree.chart.util.ObjectList;\nimport org.jfree.chart.util.ObjectUtilities;\nimport org.jfree.chart.util.PaintUtilities;\nimport org.jfree.chart.util.PublicCloneable;\nimport org.jfree.chart.util.RectangleEdge;\nimport org.jfree.chart.util.RectangleInsets;\nimport org.jfree.chart.util.SerialUtilities;\nimport org.jfree.data.Range;\nimport org.jfree.data.general.Dataset;\nimport org.jfree.data.general.DatasetChangeEvent;\nimport org.jfree.data.general.DatasetUtilities;\nimport org.jfree.data.xy.XYDataset;\n\n\npublic class XYPlot extends Plot implements ValueAxisPlot, Zoomable, RendererChangeListener, Cloneable, PublicCloneable, Serializable { private static final long serialVersionUID = 7044148245716569264L; public static final Stroke DEFAULT_GRIDLINE_STROKE = new BasicStroke(0.5f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL, 0.0f, new float[] {2.0f, 2.0f}, 0.0f); public static final Paint DEFAULT_GRIDLINE_PAINT = Color.WHITE; public static final boolean DEFAULT_CROSSHAIR_VISIBLE = false; public static final Stroke DEFAULT_CROSSHAIR_STROKE = DEFAULT_GRIDLINE_STROKE; public static final Paint DEFAULT_CROSSHAIR_PAINT = Color.blue; protected static ResourceBundle localizationResources = ResourceBundle.getBundle( \"org.jfree.chart.plot.LocalizationBundle\"); private PlotOrientation orientation; private RectangleInsets axisOffset; private ObjectList domainAxes; private ObjectList domainAxisLocations; private ObjectList rangeAxes; private ObjectList rangeAxisLocations; private ObjectList datasets; private ObjectList renderers; private Map datasetToDomainAxisMap; private Map datasetToRangeAxisMap; private transient Point2D quadrantOrigin = new Point2D.Double(0.0, 0.0); private transient Paint[] quadrantPaint = new Paint[] {null, null, null, null};\n\n    \n    private boolean domainGridlinesVisible; private transient Stroke domainGridlineStroke; private transient Paint domainGridlinePaint; private boolean rangeGridlinesVisible; private transient Stroke rangeGridlineStroke; private transient Paint rangeGridlinePaint; private boolean domainZeroBaselineVisible; private transient Stroke domainZeroBaselineStroke; private transient Paint domainZeroBaselinePaint; private boolean rangeZeroBaselineVisible; private transient Stroke rangeZeroBaselineStroke; private transient Paint rangeZeroBaselinePaint; private boolean domainCrosshairVisible; private double domainCrosshairValue; private transient Stroke domainCrosshairStroke; private transient Paint domainCrosshairPaint; private boolean domainCrosshairLockedOnData = true; private boolean rangeCrosshairVisible; private double rangeCrosshairValue; private transient Stroke rangeCrosshairStroke; private transient Paint rangeCrosshairPaint; private boolean rangeCrosshairLockedOnData = true; private Map foregroundDomainMarkers; private Map backgroundDomainMarkers; private Map foregroundRangeMarkers; private Map backgroundRangeMarkers; private List annotations; private transient Paint domainTickBandPaint; private transient Paint rangeTickBandPaint; private AxisSpace fixedDomainAxisSpace; private AxisSpace fixedRangeAxisSpace; private DatasetRenderingOrder datasetRenderingOrder = DatasetRenderingOrder.REVERSE; private SeriesRenderingOrder seriesRenderingOrder = SeriesRenderingOrder.REVERSE; private int weight; private LegendItemCollection fixedLegendItems; public XYPlot() {\n        this(null, null, null, null);\n    }\n\n    \n    public XYPlot(XYDataset dataset, ValueAxis domainAxis, ValueAxis rangeAxis, XYItemRenderer renderer) {\n\n        super();\n\n        this.orientation = PlotOrientation.VERTICAL;\n        this.weight = 1;  \n        this.axisOffset = new RectangleInsets(4.0, 4.0, 4.0, 4.0);\n\n        \n        this.domainAxes = new ObjectList();\n        this.domainAxisLocations = new ObjectList();\n        this.foregroundDomainMarkers = new HashMap();\n        this.backgroundDomainMarkers = new HashMap();\n\n        this.rangeAxes = new ObjectList();\n        this.rangeAxisLocations = new ObjectList();\n        this.foregroundRangeMarkers = new HashMap();\n        this.backgroundRangeMarkers = new HashMap();\n\n        this.datasets = new ObjectList();\n        this.renderers = new ObjectList();\n\n        this.datasetToDomainAxisMap = new TreeMap();\n        this.datasetToRangeAxisMap = new TreeMap();\n\n        this.datasets.set(0, dataset);\n        if (dataset != null) {\n            dataset.addChangeListener(this);\n        }\n\n        this.renderers.set(0, renderer);\n        if (renderer != null) {\n            renderer.setPlot(this);\n            renderer.addChangeListener(this);\n        }\n\n        this.domainAxes.set(0, domainAxis);\n        this.mapDatasetToDomainAxis(0, 0);\n        if (domainAxis != null) {\n            domainAxis.setPlot(this);\n            domainAxis.addChangeListener(this);\n        }\n        this.domainAxisLocations.set(0, AxisLocation.BOTTOM_OR_LEFT);\n\n        this.rangeAxes.set(0, rangeAxis);\n        this.mapDatasetToRangeAxis(0, 0);\n        if (rangeAxis != null) {\n            rangeAxis.setPlot(this);\n            rangeAxis.addChangeListener(this);\n        }\n        this.rangeAxisLocations.set(0, AxisLocation.BOTTOM_OR_LEFT);\n\n        configureDomainAxes();\n        configureRangeAxes();\n\n        this.domainGridlinesVisible = true;\n        this.domainGridlineStroke = DEFAULT_GRIDLINE_STROKE;\n        this.domainGridlinePaint = DEFAULT_GRIDLINE_PAINT;\n\n        this.domainZeroBaselineVisible = false;\n        this.domainZeroBaselinePaint = Color.black;\n        this.domainZeroBaselineStroke = new BasicStroke(0.5f);\n\n        this.rangeGridlinesVisible = true;\n        this.rangeGridlineStroke = DEFAULT_GRIDLINE_STROKE;\n        this.rangeGridlinePaint = DEFAULT_GRIDLINE_PAINT;\n\n        this.rangeZeroBaselineVisible = false;\n        this.rangeZeroBaselinePaint = Color.black;\n        this.rangeZeroBaselineStroke = new BasicStroke(0.5f);\n\n        this.domainCrosshairVisible = false;\n        this.domainCrosshairValue = 0.0;\n        this.domainCrosshairStroke = DEFAULT_CROSSHAIR_STROKE;\n        this.domainCrosshairPaint = DEFAULT_CROSSHAIR_PAINT;\n\n        this.rangeCrosshairVisible = false;\n        this.rangeCrosshairValue = 0.0;\n        this.rangeCrosshairStroke = DEFAULT_CROSSHAIR_STROKE;\n        this.rangeCrosshairPaint = DEFAULT_CROSSHAIR_PAINT;\n\n        this.annotations = new java.util.ArrayList();\n\n    }\n\n    \n    public String getPlotType() {\n        return localizationResources.getString(\"XY_Plot\");\n    }\n\n    \n    public PlotOrientation getOrientation() {\n        return this.orientation;\n    }\n\n    \n    public void setOrientation(PlotOrientation orientation) {\n        if (orientation == null) {\n            throw new IllegalArgumentException(\"Null 'orientation' argument.\");\n        }\n        if (orientation != this.orientation) {\n            this.orientation = orientation;\n            fireChangeEvent();\n        }\n    }\n\n    \n    public RectangleInsets getAxisOffset() {\n        return this.axisOffset;\n    }\n\n    \n    public void setAxisOffset(RectangleInsets offset) {\n        if (offset == null) {\n            throw new IllegalArgumentException(\"Null 'offset' argument.\");\n        }\n        this.axisOffset = offset;\n        fireChangeEvent();\n    }\n\n    \n    public ValueAxis getDomainAxis() {\n        return getDomainAxis(0);\n    }\n\n    \n    public ValueAxis getDomainAxis(int index) {\n        ValueAxis result = null;\n        if (index < this.domainAxes.size()) {\n            result = (ValueAxis) this.domainAxes.get(index);\n        }\n        if (result == null) {\n            Plot parent = getParent();\n            if (parent instanceof XYPlot) {\n                XYPlot xy = (XYPlot) parent;\n                result = xy.getDomainAxis(index);\n            }\n        }\n        return result;\n    }\n\n    \n    public void setDomainAxis(ValueAxis axis) {\n        setDomainAxis(0, axis);\n    }\n\n    \n    public void setDomainAxis(int index, ValueAxis axis) {\n        setDomainAxis(index, axis, true);\n    }\n    \n    \n    public void setDomainAxis(int index, ValueAxis axis, boolean notify) {\n        ValueAxis existing = getDomainAxis(index);\n        if (existing != null) {\n            existing.removeChangeListener(this);\n        }\n        if (axis != null) {\n            axis.setPlot(this);\n        }\n        this.domainAxes.set(index, axis);\n        if (axis != null) {\n            axis.configure();\n            axis.addChangeListener(this);\n        }\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    \n    public void setDomainAxes(ValueAxis[] axes) {\n        for (int i = 0; i < axes.length; i++) {\n            setDomainAxis(i, axes[i], false);   \n        }\n        fireChangeEvent();\n    }\n    \n    \n    public AxisLocation getDomainAxisLocation() {\n        return (AxisLocation) this.domainAxisLocations.get(0);\n    }\n\n    \n    public void setDomainAxisLocation(AxisLocation location) {\n        \n        setDomainAxisLocation(0, location, true);\n    }\n\n    \n    public void setDomainAxisLocation(AxisLocation location, boolean notify) {\n        \n        setDomainAxisLocation(0, location, notify);\n    }\n\n    \n    public RectangleEdge getDomainAxisEdge() {\n        return Plot.resolveDomainAxisLocation(getDomainAxisLocation(), \n                this.orientation);\n    }\n\n    \n    public int getDomainAxisCount() {\n        return this.domainAxes.size();\n    }\n\n    \n    public void clearDomainAxes() {\n        for (int i = 0; i < this.domainAxes.size(); i++) {\n            ValueAxis axis = (ValueAxis) this.domainAxes.get(i);\n            if (axis != null) {\n                axis.removeChangeListener(this);\n            }\n        }\n        this.domainAxes.clear();\n        fireChangeEvent();\n    }\n\n    \n    public void configureDomainAxes() {\n        for (int i = 0; i < this.domainAxes.size(); i++) {\n            ValueAxis axis = (ValueAxis) this.domainAxes.get(i);\n            if (axis != null) {\n                axis.configure();\n            }\n        }\n    }\n\n    \n    public AxisLocation getDomainAxisLocation(int index) {\n        AxisLocation result = null;\n        if (index < this.domainAxisLocations.size()) {\n            result = (AxisLocation) this.domainAxisLocations.get(index);\n        }\n        if (result == null) {\n            result = AxisLocation.getOpposite(getDomainAxisLocation());\n        }\n        return result;\n    }\n\n    \n    public void setDomainAxisLocation(int index, AxisLocation location) {\n        \n        setDomainAxisLocation(index, location, true);\n    }\n\n    \n    public void setDomainAxisLocation(int index, AxisLocation location, boolean notify) {\n        \n        if (index == 0 && location == null) {\n            throw new IllegalArgumentException(\n                    \"Null 'location' for index 0 not permitted.\");\n        }\n        this.domainAxisLocations.set(index, location);\n        if (notify) {\n            fireChangeEvent();\n        }        \n    }\n\n    \n    public RectangleEdge getDomainAxisEdge(int index) {\n        AxisLocation location = getDomainAxisLocation(index);\n        RectangleEdge result = Plot.resolveDomainAxisLocation(location, \n                this.orientation);\n        if (result == null) {\n            result = RectangleEdge.opposite(getDomainAxisEdge());\n        }\n        return result;\n    }\n\n    \n    public ValueAxis getRangeAxis() {\n        return getRangeAxis(0);\n    }\n\n    \n    public void setRangeAxis(ValueAxis axis) {\n\n        if (axis != null) {\n            axis.setPlot(this);\n        }\n\n        \n        ValueAxis existing = getRangeAxis();\n        if (existing != null) {\n            existing.removeChangeListener(this);\n        }\n\n        this.rangeAxes.set(0, axis);\n        if (axis != null) {\n            axis.configure();\n            axis.addChangeListener(this);\n        }\n        fireChangeEvent();\n\n    }\n\n    \n    public AxisLocation getRangeAxisLocation() {\n        return (AxisLocation) this.rangeAxisLocations.get(0);\n    }\n\n    \n    public void setRangeAxisLocation(AxisLocation location) {\n        \n        setRangeAxisLocation(0, location, true);\n    }\n\n    \n    public void setRangeAxisLocation(AxisLocation location, boolean notify) {\n        \n        setRangeAxisLocation(0, location, notify);\n    }\n\n    \n    public RectangleEdge getRangeAxisEdge() {\n        return Plot.resolveRangeAxisLocation(getRangeAxisLocation(), \n                this.orientation);\n    }\n\n    \n    public ValueAxis getRangeAxis(int index) {\n        ValueAxis result = null;\n        if (index < this.rangeAxes.size()) {\n            result = (ValueAxis) this.rangeAxes.get(index);\n        }\n        if (result == null) {\n            Plot parent = getParent();\n            if (parent instanceof XYPlot) {\n                XYPlot xy = (XYPlot) parent;\n                result = xy.getRangeAxis(index);\n            }\n        }\n        return result;\n    }\n\n    \n    public void setRangeAxis(int index, ValueAxis axis) {\n        setRangeAxis(index, axis, true);\n    } \n    \n    \n    public void setRangeAxis(int index, ValueAxis axis, boolean notify) {\n        ValueAxis existing = getRangeAxis(index);\n        if (existing != null) {\n            existing.removeChangeListener(this);\n        }\n        if (axis != null) {\n            axis.setPlot(this);\n        }\n        this.rangeAxes.set(index, axis);\n        if (axis != null) {\n            axis.configure();\n            axis.addChangeListener(this);\n        }\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    \n    public void setRangeAxes(ValueAxis[] axes) {\n        for (int i = 0; i < axes.length; i++) {\n            setRangeAxis(i, axes[i], false);   \n        }\n        fireChangeEvent();\n    }\n    \n    \n    public int getRangeAxisCount() {\n        return this.rangeAxes.size();\n    }\n\n    \n    public void clearRangeAxes() {\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis axis = (ValueAxis) this.rangeAxes.get(i);\n            if (axis != null) {\n                axis.removeChangeListener(this);\n            }\n        }\n        this.rangeAxes.clear();\n        fireChangeEvent();\n    }\n\n    \n    public void configureRangeAxes() {\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis axis = (ValueAxis) this.rangeAxes.get(i);\n            if (axis != null) {\n                axis.configure();\n            }\n        }\n    }\n\n    \n    public AxisLocation getRangeAxisLocation(int index) {\n        AxisLocation result = null;\n        if (index < this.rangeAxisLocations.size()) {\n            result = (AxisLocation) this.rangeAxisLocations.get(index);\n        }\n        if (result == null) {\n            result = AxisLocation.getOpposite(getRangeAxisLocation());\n        }\n        return result;\n    }\n\n    \n    public void setRangeAxisLocation(int index, AxisLocation location) {\n        \n        setRangeAxisLocation(index, location, true);\n    }\n    \n    \n    public void setRangeAxisLocation(int index, AxisLocation location, boolean notify) {\n        \n        if (index == 0 && location == null) {\n            throw new IllegalArgumentException(\n                    \"Null 'location' for index 0 not permitted.\");\n        }\n        this.rangeAxisLocations.set(index, location);\n        if (notify) {\n            fireChangeEvent();\n        }   \n    }\n\n    \n    public RectangleEdge getRangeAxisEdge(int index) {\n        AxisLocation location = getRangeAxisLocation(index);\n        RectangleEdge result = Plot.resolveRangeAxisLocation(location, \n                this.orientation);\n        if (result == null) {\n            result = RectangleEdge.opposite(getRangeAxisEdge());\n        }\n        return result;\n    }\n\n    \n    public XYDataset getDataset() {\n        return getDataset(0);\n    }\n\n    \n    public XYDataset getDataset(int index) {\n        XYDataset result = null;\n        if (this.datasets.size() > index) {\n            result = (XYDataset) this.datasets.get(index);\n        }\n        return result;\n    }\n\n    \n    public void setDataset(XYDataset dataset) {\n        setDataset(0, dataset);\n    }\n\n    \n    public void setDataset(int index, XYDataset dataset) {\n        XYDataset existing = getDataset(index);\n        if (existing != null) {\n            existing.removeChangeListener(this);\n        }\n        this.datasets.set(index, dataset);\n        if (dataset != null) {\n            dataset.addChangeListener(this);\n        }\n\n        \n        DatasetChangeEvent event = new DatasetChangeEvent(this, dataset);\n        datasetChanged(event);\n    }\n\n    \n    public int getDatasetCount() {\n        return this.datasets.size();\n    }\n\n    \n    public int indexOf(XYDataset dataset) {\n        int result = -1;\n        for (int i = 0; i < this.datasets.size(); i++) {\n            if (dataset == this.datasets.get(i)) {\n                result = i;\n                break;\n            }\n        }\n        return result;\n    }\n\n    \n    public void mapDatasetToDomainAxis(int index, int axisIndex) {\n        this.datasetToDomainAxisMap.put(new Integer(index), \n                new Integer(axisIndex));\n        \n        datasetChanged(new DatasetChangeEvent(this, getDataset(index)));\n    }\n\n    \n    public void mapDatasetToRangeAxis(int index, int axisIndex) {\n        this.datasetToRangeAxisMap.put(new Integer(index), \n                new Integer(axisIndex));\n        \n        datasetChanged(new DatasetChangeEvent(this, getDataset(index)));\n    }\n\n    \n    public XYItemRenderer getRenderer() {\n        return getRenderer(0);\n    }\n\n    \n    public XYItemRenderer getRenderer(int index) {\n        XYItemRenderer result = null;\n        if (this.renderers.size() > index) {\n            result = (XYItemRenderer) this.renderers.get(index);\n        }\n        return result;\n\n    }\n\n    \n    public void setRenderer(XYItemRenderer renderer) {\n        setRenderer(0, renderer);\n    }\n\n    \n    public void setRenderer(int index, XYItemRenderer renderer) {\n        setRenderer(index, renderer, true);\n    }\n\n    \n    public void setRenderer(int index, XYItemRenderer renderer, boolean notify) {\n        XYItemRenderer existing = getRenderer(index);\n        if (existing != null) {\n            existing.removeChangeListener(this);\n        }\n        this.renderers.set(index, renderer);\n        if (renderer != null) {\n            renderer.setPlot(this);\n            renderer.addChangeListener(this);\n        }\n        configureDomainAxes();\n        configureRangeAxes();\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    \n    public void setRenderers(XYItemRenderer[] renderers) {\n        for (int i = 0; i < renderers.length; i++) {\n            setRenderer(i, renderers[i], false);   \n        }\n        fireChangeEvent();\n    }\n    \n    \n    public DatasetRenderingOrder getDatasetRenderingOrder() {\n        return this.datasetRenderingOrder;\n    }\n\n    \n    public void setDatasetRenderingOrder(DatasetRenderingOrder order) {\n        if (order == null) {\n            throw new IllegalArgumentException(\"Null 'order' argument.\");\n        }\n        this.datasetRenderingOrder = order;\n        fireChangeEvent();\n    }\n\n    \n    public SeriesRenderingOrder getSeriesRenderingOrder() {\n        return this.seriesRenderingOrder;\n    }\n\n    \n    public void setSeriesRenderingOrder(SeriesRenderingOrder order) {\n        if (order == null) {\n            throw new IllegalArgumentException(\"Null 'order' argument.\");\n        }\n        this.seriesRenderingOrder = order;\n        fireChangeEvent();\n    }\n\n    \n    public int getIndexOf(XYItemRenderer renderer) {\n        return this.renderers.indexOf(renderer);\n    }\n\n    \n    public XYItemRenderer getRendererForDataset(XYDataset dataset) {\n        XYItemRenderer result = null;\n        for (int i = 0; i < this.datasets.size(); i++) {\n            if (this.datasets.get(i) == dataset) {\n                result = (XYItemRenderer) this.renderers.get(i);\n                if (result == null) {\n                    result = getRenderer();\n                }\n                break;\n            }\n        }\n        return result;\n    }\n\n    \n    public int getWeight() {\n        return this.weight;\n    }\n\n    \n    public void setWeight(int weight) {\n        this.weight = weight;\n        fireChangeEvent();\n    }\n\n    \n    public boolean isDomainGridlinesVisible() {\n        return this.domainGridlinesVisible;\n    }\n\n    \n    public void setDomainGridlinesVisible(boolean visible) {\n        if (this.domainGridlinesVisible != visible) {\n            this.domainGridlinesVisible = visible;\n            fireChangeEvent();\n        }\n    }\n\n    \n    public Stroke getDomainGridlineStroke() {\n        return this.domainGridlineStroke;\n    }\n\n    \n    public void setDomainGridlineStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");\n        }\n        this.domainGridlineStroke = stroke;\n        fireChangeEvent();\n    }\n\n    \n    public Paint getDomainGridlinePaint() {\n        return this.domainGridlinePaint;\n    }\n\n    \n    public void setDomainGridlinePaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.domainGridlinePaint = paint;\n        fireChangeEvent();\n    }\n\n    \n    public boolean isRangeGridlinesVisible() {\n        return this.rangeGridlinesVisible;\n    }\n\n    \n    public void setRangeGridlinesVisible(boolean visible) {\n        if (this.rangeGridlinesVisible != visible) {\n            this.rangeGridlinesVisible = visible;\n            fireChangeEvent();\n        }\n    }\n\n    \n    public Stroke getRangeGridlineStroke() {\n        return this.rangeGridlineStroke;\n    }\n\n    \n    public void setRangeGridlineStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");\n        }\n        this.rangeGridlineStroke = stroke;\n        fireChangeEvent();\n    }\n\n    \n    public Paint getRangeGridlinePaint() {\n        return this.rangeGridlinePaint;\n    }\n\n    \n    public void setRangeGridlinePaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.rangeGridlinePaint = paint;\n        fireChangeEvent();\n    }\n\n    \n    public boolean isDomainZeroBaselineVisible() {\n        return this.domainZeroBaselineVisible;\n    }\n\n    \n    public void setDomainZeroBaselineVisible(boolean visible) {\n        this.domainZeroBaselineVisible = visible;\n        fireChangeEvent();\n    }\n\n    \n    public Stroke getDomainZeroBaselineStroke() {\n        return this.domainZeroBaselineStroke;\n    }\n\n    \n    public void setDomainZeroBaselineStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");\n        }\n        this.domainZeroBaselineStroke = stroke;\n        fireChangeEvent();\n    }\n\n    \n    public Paint getDomainZeroBaselinePaint() {\n        return this.domainZeroBaselinePaint;\n    }\n\n    \n    public void setDomainZeroBaselinePaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.domainZeroBaselinePaint = paint;\n        fireChangeEvent();\n    }\n    \n    \n    public boolean isRangeZeroBaselineVisible() {\n        return this.rangeZeroBaselineVisible;\n    }\n\n    \n    public void setRangeZeroBaselineVisible(boolean visible) {\n        this.rangeZeroBaselineVisible = visible;\n        fireChangeEvent();\n    }\n\n    \n    public Stroke getRangeZeroBaselineStroke() {\n        return this.rangeZeroBaselineStroke;\n    }\n\n    \n    public void setRangeZeroBaselineStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");\n        }\n        this.rangeZeroBaselineStroke = stroke;\n        fireChangeEvent();\n    }\n\n    \n    public Paint getRangeZeroBaselinePaint() {\n        return this.rangeZeroBaselinePaint;\n    }\n\n    \n    public void setRangeZeroBaselinePaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.rangeZeroBaselinePaint = paint;\n        fireChangeEvent();\n    }\n\n    \n    public Paint getDomainTickBandPaint() {\n        return this.domainTickBandPaint;\n    }\n\n    \n    public void setDomainTickBandPaint(Paint paint) {\n        this.domainTickBandPaint = paint;\n        fireChangeEvent();\n    }\n\n    \n    public Paint getRangeTickBandPaint() {\n        return this.rangeTickBandPaint;\n    }\n\n    \n    public void setRangeTickBandPaint(Paint paint) {\n        this.rangeTickBandPaint = paint;\n        fireChangeEvent();\n    }\n\n    \n    public Point2D getQuadrantOrigin() {\n        return this.quadrantOrigin;\n    }\n\n    \n    public void setQuadrantOrigin(Point2D origin) {\n        if (origin == null) {\n            throw new IllegalArgumentException(\"Null 'origin' argument.\");\n        }\n        this.quadrantOrigin = origin;\n        fireChangeEvent();\n    }\n\n    \n    public Paint getQuadrantPaint(int index) {\n        if (index < 0 || index > 3) {\n            throw new IllegalArgumentException(\"The index value (\" + index \n                    + \") should be in the range 0 to 3.\");\n        }\n        return this.quadrantPaint[index];\n    }\n\n    \n    public void setQuadrantPaint(int index, Paint paint) {\n        if (index < 0 || index > 3) {\n            throw new IllegalArgumentException(\"The index value (\" + index \n                    + \") should be in the range 0 to 3.\");\n        }\n        this.quadrantPaint[index] = paint;\n        fireChangeEvent();\n    }\n\n    \n    public void addDomainMarker(Marker marker) {\n        \n        addDomainMarker(marker, Layer.FOREGROUND);\n    }\n\n    \n    public void addDomainMarker(Marker marker, Layer layer) {\n        addDomainMarker(0, marker, layer);\n    }\n\n    \n    public void clearDomainMarkers() {\n        if (this.backgroundDomainMarkers != null) {\n            Set keys = this.backgroundDomainMarkers.keySet();\n            Iterator iterator = keys.iterator();\n            while (iterator.hasNext()) {\n                Integer key = (Integer) iterator.next();\n                clearDomainMarkers(key.intValue());\n            }\n            this.backgroundDomainMarkers.clear();\n        }\n        if (this.foregroundDomainMarkers != null) {\n            Set keys = this.foregroundDomainMarkers.keySet();\n            Iterator iterator = keys.iterator();\n            while (iterator.hasNext()) {\n                Integer key = (Integer) iterator.next();\n                clearDomainMarkers(key.intValue());\n            }\n            this.foregroundDomainMarkers.clear();\n        }\n        fireChangeEvent();\n    }\n\n    \n    public void clearDomainMarkers(int index) {\n        Integer key = new Integer(index);\n        if (this.backgroundDomainMarkers != null) {\n            Collection markers\n                = (Collection) this.backgroundDomainMarkers.get(key);\n            if (markers != null) {\n                Iterator iterator = markers.iterator();\n                while (iterator.hasNext()) {\n                    Marker m = (Marker) iterator.next();\n                    m.removeChangeListener(this);\n                }\n                markers.clear();\n            }\n        }\n        if (this.foregroundRangeMarkers != null) {\n            Collection markers\n                = (Collection) this.foregroundDomainMarkers.get(key);\n            if (markers != null) {\n                Iterator iterator = markers.iterator();\n                while (iterator.hasNext()) {\n                    Marker m = (Marker) iterator.next();\n                    m.removeChangeListener(this);\n                }\n                markers.clear();\n            }\n        }\n        fireChangeEvent();\n    }\n\n    \n    public void addDomainMarker(int index, Marker marker, Layer layer) {\n    \taddDomainMarker(index, marker, layer, true);\n    }\n\n    \n    public void addDomainMarker(int index, Marker marker, Layer layer, boolean notify) {\n        if (marker == null) {\n            throw new IllegalArgumentException(\"Null 'marker' not permitted.\");\n        }\n        if (layer == null) {\n            throw new IllegalArgumentException(\"Null 'layer' not permitted.\");\n        }\n        Collection markers;\n        if (layer == Layer.FOREGROUND) {\n            markers = (Collection) this.foregroundDomainMarkers.get(\n                    new Integer(index));\n            if (markers == null) {\n                markers = new java.util.ArrayList();\n                this.foregroundDomainMarkers.put(new Integer(index), markers);\n            }\n            markers.add(marker);\n        }\n        else if (layer == Layer.BACKGROUND) {\n            markers = (Collection) this.backgroundDomainMarkers.get(\n                    new Integer(index));\n            if (markers == null) {\n                markers = new java.util.ArrayList();\n                this.backgroundDomainMarkers.put(new Integer(index), markers);\n            }\n            markers.add(marker);\n        }\n        marker.addChangeListener(this);\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    \n    public boolean removeDomainMarker(Marker marker) {\n        return removeDomainMarker(marker, Layer.FOREGROUND);\n    }\n\n    \n    public boolean removeDomainMarker(Marker marker, Layer layer) {\n        return removeDomainMarker(0, marker, layer);\n    }\n\n    \n    public boolean removeDomainMarker(int index, Marker marker, Layer layer) {\n    \treturn removeDomainMarker(index, marker, layer, true);\n    }\n\n    \n    public boolean removeDomainMarker(int index, Marker marker, Layer layer, boolean notify) {\n        ArrayList markers;\n        if (layer == Layer.FOREGROUND) {\n            markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer(\n                    index));\n        }\n        else {\n            markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                    index));\n        }\n        boolean removed = markers.remove(marker);\n        if (removed && notify) {\n            fireChangeEvent();\n        }\n        return removed;\n    }\n    \n    \n    public void addRangeMarker(Marker marker) {\n        addRangeMarker(marker, Layer.FOREGROUND);\n    }\n\n    \n    public void addRangeMarker(Marker marker, Layer layer) {\n        addRangeMarker(0, marker, layer);\n    }\n\n    \n    public void clearRangeMarkers() {\n        if (this.backgroundRangeMarkers != null) {\n            Set keys = this.backgroundRangeMarkers.keySet();\n            Iterator iterator = keys.iterator();\n            while (iterator.hasNext()) {\n                Integer key = (Integer) iterator.next();\n                clearRangeMarkers(key.intValue());\n            }\n            this.backgroundRangeMarkers.clear();\n        }\n        if (this.foregroundRangeMarkers != null) {\n            Set keys = this.foregroundRangeMarkers.keySet();\n            Iterator iterator = keys.iterator();\n            while (iterator.hasNext()) {\n                Integer key = (Integer) iterator.next();\n                clearRangeMarkers(key.intValue());\n            }\n            this.foregroundRangeMarkers.clear();\n        }\n        fireChangeEvent();\n    }\n\n    \n    public void addRangeMarker(int index, Marker marker, Layer layer) {\n    \taddRangeMarker(index, marker, layer, true);\n    }\n    \n    \n    public void addRangeMarker(int index, Marker marker, Layer layer, boolean notify) {\n        Collection markers;\n        if (layer == Layer.FOREGROUND) {\n            markers = (Collection) this.foregroundRangeMarkers.get(\n                    new Integer(index));\n            if (markers == null) {\n                markers = new java.util.ArrayList();\n                this.foregroundRangeMarkers.put(new Integer(index), markers);\n            }\n            markers.add(marker);\n        }\n        else if (layer == Layer.BACKGROUND) {\n            markers = (Collection) this.backgroundRangeMarkers.get(\n                    new Integer(index));\n            if (markers == null) {\n                markers = new java.util.ArrayList();\n                this.backgroundRangeMarkers.put(new Integer(index), markers);\n            }\n            markers.add(marker);\n        }\n        marker.addChangeListener(this);\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    \n    public void clearRangeMarkers(int index) {\n        Integer key = new Integer(index);\n        if (this.backgroundRangeMarkers != null) {\n            Collection markers\n                = (Collection) this.backgroundRangeMarkers.get(key);\n            if (markers != null) {\n                Iterator iterator = markers.iterator();\n                while (iterator.hasNext()) {\n                    Marker m = (Marker) iterator.next();\n                    m.removeChangeListener(this);\n                }\n                markers.clear();\n            }\n        }\n        if (this.foregroundRangeMarkers != null) {\n            Collection markers\n                = (Collection) this.foregroundRangeMarkers.get(key);\n            if (markers != null) {\n                Iterator iterator = markers.iterator();\n                while (iterator.hasNext()) {\n                    Marker m = (Marker) iterator.next();\n                    m.removeChangeListener(this);\n                }\n                markers.clear();\n            }\n        }\n        fireChangeEvent();\n    }\n\n    \n    public boolean removeRangeMarker(Marker marker) {\n        return removeRangeMarker(marker, Layer.FOREGROUND);\n    }\n\n    \n    public boolean removeRangeMarker(Marker marker, Layer layer) {\n        return removeRangeMarker(0, marker, layer);\n    }\n\n    \n    public boolean removeRangeMarker(int index, Marker marker, Layer layer) {\n    \treturn removeRangeMarker(index, marker, layer, true);\n    }\n    \n    \n    public boolean removeRangeMarker(int index, Marker marker, Layer layer, boolean notify) {\n        if (marker == null) {\n            throw new IllegalArgumentException(\"Null 'marker' argument.\");\n        }\n        ArrayList markers;\n        if (layer == Layer.FOREGROUND) {\n            markers = (ArrayList) this.foregroundRangeMarkers.get(new Integer(\n                    index));\n        }\n        else {\n            markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(\n                    index));\n        }\n        boolean removed = markers.remove(marker);\n        if (removed && notify) {\n            fireChangeEvent();\n        }\n        return removed;\n    }\n\n    \n    public void addAnnotation(XYAnnotation annotation) {\n        addAnnotation(annotation, true);\t\n    }\n    \n    \n    public void addAnnotation(XYAnnotation annotation, boolean notify) {\n        if (annotation == null) {\n            throw new IllegalArgumentException(\"Null 'annotation' argument.\");\n        }\n        this.annotations.add(annotation);\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    \n    public boolean removeAnnotation(XYAnnotation annotation) {\n    \treturn removeAnnotation(annotation, true);\n    }\n\n    \n    public boolean removeAnnotation(XYAnnotation annotation, boolean notify) {\n        if (annotation == null) {\n            throw new IllegalArgumentException(\"Null 'annotation' argument.\");\n        }\n        boolean removed = this.annotations.remove(annotation);\n        if (removed && notify) {\n            fireChangeEvent();\n        }\n        return removed;\n    }\n\n    \n    public List getAnnotations() {\n        return new ArrayList(this.annotations);\n    }\n\n    \n    public void clearAnnotations() {\n        this.annotations.clear();\n        fireChangeEvent();\n    }\n    \n    \n    protected AxisSpace calculateAxisSpace(Graphics2D g2, Rectangle2D plotArea) {\n        AxisSpace space = new AxisSpace();\n        space = calculateDomainAxisSpace(g2, plotArea, space);\n        space = calculateRangeAxisSpace(g2, plotArea, space);\n        return space;\n    }\n\n    \n    protected AxisSpace calculateDomainAxisSpace(Graphics2D g2, Rectangle2D plotArea, AxisSpace space) {\n\n        if (space == null) {\n            space = new AxisSpace();\n        }\n\n        \n        if (this.fixedDomainAxisSpace != null) {\n            if (this.orientation == PlotOrientation.HORIZONTAL) {\n                space.ensureAtLeast(this.fixedDomainAxisSpace.getLeft(), \n                        RectangleEdge.LEFT);\n                space.ensureAtLeast(this.fixedDomainAxisSpace.getRight(), \n                        RectangleEdge.RIGHT);\n            }\n            else if (this.orientation == PlotOrientation.VERTICAL) {\n                space.ensureAtLeast(this.fixedDomainAxisSpace.getTop(), \n                        RectangleEdge.TOP);\n                space.ensureAtLeast(this.fixedDomainAxisSpace.getBottom(), \n                        RectangleEdge.BOTTOM);\n            }\n        }\n        else {\n            \n            for (int i = 0; i < this.domainAxes.size(); i++) {\n                Axis axis = (Axis) this.domainAxes.get(i);\n                if (axis != null) {\n                    RectangleEdge edge = getDomainAxisEdge(i);\n                    space = axis.reserveSpace(g2, this, plotArea, edge, space);\n                }\n            }\n        }\n\n        return space;\n\n    }\n\n    \n    protected AxisSpace calculateRangeAxisSpace(Graphics2D g2, Rectangle2D plotArea, AxisSpace space) {\n\n        if (space == null) {\n            space = new AxisSpace();\n        }\n\n        \n        if (this.fixedRangeAxisSpace != null) {\n            if (this.orientation == PlotOrientation.HORIZONTAL) {\n                space.ensureAtLeast(this.fixedRangeAxisSpace.getTop(), \n                        RectangleEdge.TOP);\n                space.ensureAtLeast(this.fixedRangeAxisSpace.getBottom(), \n                        RectangleEdge.BOTTOM);\n            }\n            else if (this.orientation == PlotOrientation.VERTICAL) {\n                space.ensureAtLeast(this.fixedRangeAxisSpace.getLeft(), \n                        RectangleEdge.LEFT);\n                space.ensureAtLeast(this.fixedRangeAxisSpace.getRight(), \n                        RectangleEdge.RIGHT);\n            }\n        }\n        else {\n            \n            for (int i = 0; i < this.rangeAxes.size(); i++) {\n                Axis axis = (Axis) this.rangeAxes.get(i);\n                if (axis != null) {\n                    RectangleEdge edge = getRangeAxisEdge(i);\n                    space = axis.reserveSpace(g2, this, plotArea, edge, space);\n                }\n            }\n        }\n        return space;\n\n    }\n\n    \n    public void draw(Graphics2D g2, Rectangle2D area, Point2D anchor, PlotState parentState, PlotRenderingInfo info) {\n\n        \n        boolean b1 = (area.getWidth() <= MINIMUM_WIDTH_TO_DRAW);\n        boolean b2 = (area.getHeight() <= MINIMUM_HEIGHT_TO_DRAW);\n        if (b1 || b2) {\n            return;\n        }\n\n        \n        if (info != null) {\n            info.setPlotArea(area);\n        }\n\n        \n        RectangleInsets insets = getInsets();\n        insets.trim(area);\n\n        AxisSpace space = calculateAxisSpace(g2, area);\n        Rectangle2D dataArea = space.shrink(area, null);\n        this.axisOffset.trim(dataArea);\n\n        if (info != null) {\n            info.setDataArea(dataArea);\n        }\n\n        \n        drawBackground(g2, dataArea);\n        Map axisStateMap = drawAxes(g2, area, dataArea, info);\n\n        PlotOrientation orient = getOrientation();\n\n        \n        \n        if (anchor != null && !dataArea.contains(anchor)) {\n            anchor = null;\n        }\n        CrosshairState crosshairState = new CrosshairState();\n        crosshairState.setCrosshairDistance(Double.POSITIVE_INFINITY);\n        crosshairState.setAnchor(anchor);\n        \n        crosshairState.setAnchorX(Double.NaN);\n        crosshairState.setAnchorY(Double.NaN);            \n        if (anchor != null) {\n            ValueAxis domainAxis = getDomainAxis();\n            if (domainAxis != null) {\n                double x;\n                if (orient == PlotOrientation.VERTICAL) {\n                    x = domainAxis.java2DToValue(anchor.getX(), dataArea, \n                            getDomainAxisEdge());\n                } \n                else {\n                    x = domainAxis.java2DToValue(anchor.getY(), dataArea, \n                            getDomainAxisEdge());\n                }\n                crosshairState.setAnchorX(x);\n            }\n            ValueAxis rangeAxis = getRangeAxis();\n            if (rangeAxis != null) {\n                double y;\n                if (orient == PlotOrientation.VERTICAL) {\n                    y = rangeAxis.java2DToValue(anchor.getY(), dataArea, \n                            getRangeAxisEdge());\n                } \n                else {\n                    y = rangeAxis.java2DToValue(anchor.getX(), dataArea, \n                            getRangeAxisEdge());\n                }\n                crosshairState.setAnchorY(y);                \n            }\n        }\n        crosshairState.setCrosshairX(getDomainCrosshairValue());\n        crosshairState.setCrosshairY(getRangeCrosshairValue());\n        Shape originalClip = g2.getClip();\n        Composite originalComposite = g2.getComposite();\n\n        g2.clip(dataArea);\n        g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, \n                getForegroundAlpha()));\n\n        AxisState domainAxisState = (AxisState) axisStateMap.get(\n                getDomainAxis());\n        if (domainAxisState == null) {\n            if (parentState != null) {\n                domainAxisState = (AxisState) parentState.getSharedAxisStates()\n                        .get(getDomainAxis());\n            }\n        }\n\n        AxisState rangeAxisState = (AxisState) axisStateMap.get(getRangeAxis());\n        if (rangeAxisState == null) {\n            if (parentState != null) {\n                rangeAxisState = (AxisState) parentState.getSharedAxisStates()\n                        .get(getRangeAxis());\n            }\n        }\n        if (domainAxisState != null) {\n            drawDomainTickBands(g2, dataArea, domainAxisState.getTicks());\n        }\n        if (rangeAxisState != null) {\n            drawRangeTickBands(g2, dataArea, rangeAxisState.getTicks());\n        }\n        if (domainAxisState != null) {\n            drawDomainGridlines(g2, dataArea, domainAxisState.getTicks());\n            drawZeroDomainBaseline(g2, dataArea);\n        }\n        if (rangeAxisState != null) {\n            drawRangeGridlines(g2, dataArea, rangeAxisState.getTicks());\n            drawZeroRangeBaseline(g2, dataArea);\n        }\n\n        \n        for (int i = 0; i < this.renderers.size(); i++) {\n            drawDomainMarkers(g2, dataArea, i, Layer.BACKGROUND);\n        }\n        for (int i = 0; i < this.renderers.size(); i++) {\n            drawRangeMarkers(g2, dataArea, i, Layer.BACKGROUND);\n        }\n\n        \n        boolean foundData = false;\n        DatasetRenderingOrder order = getDatasetRenderingOrder();\n        if (order == DatasetRenderingOrder.FORWARD) {\n\n            \n            int rendererCount = this.renderers.size();\n            for (int i = 0; i < rendererCount; i++) {\n                XYItemRenderer r = getRenderer(i);\n                if (r != null) {\n                    ValueAxis domainAxis = getDomainAxisForDataset(i);\n                    ValueAxis rangeAxis = getRangeAxisForDataset(i);\n                    r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis,\n                            Layer.BACKGROUND, info);\n                }\n            }\n\n            \n            for (int i = 0; i < getDatasetCount(); i++) {\n                foundData = render(g2, dataArea, i, info, crosshairState)\n                    || foundData;\n            }\n\n            \n            for (int i = 0; i < rendererCount; i++) {\n                XYItemRenderer r = getRenderer(i);\n                if (r != null) {\n                    ValueAxis domainAxis = getDomainAxisForDataset(i);\n                    ValueAxis rangeAxis = getRangeAxisForDataset(i);\n                    r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis,\n                            Layer.FOREGROUND, info);\n                }\n            }\n\n        }\n        else if (order == DatasetRenderingOrder.REVERSE) {\n\n            \n            int rendererCount = this.renderers.size();\n            for (int i = rendererCount - 1; i >= 0; i--) {\n                XYItemRenderer r = getRenderer(i);\n                if (i >= getDatasetCount()) { \n                    continue;                 \n                }\n                if (r != null) {\n                    ValueAxis domainAxis = getDomainAxisForDataset(i);\n                    ValueAxis rangeAxis = getRangeAxisForDataset(i);\n                    r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis,\n                            Layer.BACKGROUND, info);\n                }\n            }\n\n            for (int i = getDatasetCount() - 1; i >= 0; i--) {\n                foundData = render(g2, dataArea, i, info, crosshairState)\n                    || foundData;\n            }\n\n            \n            for (int i = rendererCount - 1; i >= 0; i--) {\n                XYItemRenderer r = getRenderer(i);\n                if (i >= getDatasetCount()) { \n                    continue;                 \n                }\n                if (r != null) {\n                    ValueAxis domainAxis = getDomainAxisForDataset(i);\n                    ValueAxis rangeAxis = getRangeAxisForDataset(i);\n                    r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis,\n                            Layer.FOREGROUND, info);\n                }\n            }\n\n        }\n\n        \n        int xAxisIndex = crosshairState.getDomainAxisIndex();\n        ValueAxis xAxis = getDomainAxis(xAxisIndex);\n        RectangleEdge xAxisEdge = getDomainAxisEdge(xAxisIndex);\n        if (!this.domainCrosshairLockedOnData && anchor != null) {\n            double xx;\n            if (orient == PlotOrientation.VERTICAL) {\n                xx = xAxis.java2DToValue(anchor.getX(), dataArea, xAxisEdge);\n            } \n            else {\n                xx = xAxis.java2DToValue(anchor.getY(), dataArea, xAxisEdge);\n            }\n            crosshairState.setCrosshairX(xx);\n        }\n        setDomainCrosshairValue(crosshairState.getCrosshairX(), false);\n        if (isDomainCrosshairVisible()) {\n            double x = getDomainCrosshairValue();\n            Paint paint = getDomainCrosshairPaint();\n            Stroke stroke = getDomainCrosshairStroke();\n            drawDomainCrosshair(g2, dataArea, orient, x, xAxis, stroke, paint);\n        }\n\n        \n        int yAxisIndex = crosshairState.getRangeAxisIndex();\n        ValueAxis yAxis = getRangeAxis(yAxisIndex);\n        RectangleEdge yAxisEdge = getRangeAxisEdge(yAxisIndex);\n        if (!this.rangeCrosshairLockedOnData && anchor != null) {\n            double yy;\n            if (orient == PlotOrientation.VERTICAL) {\n                yy = yAxis.java2DToValue(anchor.getY(), dataArea, yAxisEdge);\n            } else {\n                yy = yAxis.java2DToValue(anchor.getX(), dataArea, yAxisEdge);\n            }\n            crosshairState.setCrosshairY(yy);\n        }\n        setRangeCrosshairValue(crosshairState.getCrosshairY(), false);\n        if (isRangeCrosshairVisible()) {\n            double y = getRangeCrosshairValue();\n            Paint paint = getRangeCrosshairPaint();\n            Stroke stroke = getRangeCrosshairStroke();\n            drawRangeCrosshair(g2, dataArea, orient, y, yAxis, stroke, paint);\n        }\n\n        if (!foundData) {\n            drawNoDataMessage(g2, dataArea);\n        }\n\n        for (int i = 0; i < this.renderers.size(); i++) {\n            drawDomainMarkers(g2, dataArea, i, Layer.FOREGROUND);\n        }\n        for (int i = 0; i < this.renderers.size(); i++) {\n            drawRangeMarkers(g2, dataArea, i, Layer.FOREGROUND);\n        }\n\n        drawAnnotations(g2, dataArea, info);\n        g2.setClip(originalClip);\n        g2.setComposite(originalComposite);\n\n        drawOutline(g2, dataArea);\n\n    }\n\n    \n    public void drawBackground(Graphics2D g2, Rectangle2D area) {\n        fillBackground(g2, area, this.orientation);\n        drawQuadrants(g2, area);\n        drawBackgroundImage(g2, area);\n    }\n\n    \n    protected void drawQuadrants(Graphics2D g2, Rectangle2D area) {\n        \n        \n        \n        boolean somethingToDraw = false;\n\n        ValueAxis xAxis = getDomainAxis();\n        double x = xAxis.getRange().constrain(this.quadrantOrigin.getX());\n        double xx = xAxis.valueToJava2D(x, area, getDomainAxisEdge());\n\n        ValueAxis yAxis = getRangeAxis();\n        double y = yAxis.getRange().constrain(this.quadrantOrigin.getY());\n        double yy = yAxis.valueToJava2D(y, area, getRangeAxisEdge());\n\n        double xmin = xAxis.getLowerBound();\n        double xxmin = xAxis.valueToJava2D(xmin, area, getDomainAxisEdge());\n\n        double xmax = xAxis.getUpperBound();\n        double xxmax = xAxis.valueToJava2D(xmax, area, getDomainAxisEdge());\n\n        double ymin = yAxis.getLowerBound();\n        double yymin = yAxis.valueToJava2D(ymin, area, getRangeAxisEdge());\n\n        double ymax = yAxis.getUpperBound();\n        double yymax = yAxis.valueToJava2D(ymax, area, getRangeAxisEdge());\n\n        Rectangle2D[] r = new Rectangle2D[] {null, null, null, null};\n        if (this.quadrantPaint[0] != null) {\n            if (x > xmin && y < ymax) {\n                if (this.orientation == PlotOrientation.HORIZONTAL) {\n                    r[0] = new Rectangle2D.Double(Math.min(yymax, yy), \n                            Math.min(xxmin, xx), Math.abs(yy - yymax), \n                            Math.abs(xx - xxmin)\n                    );\n                }\n                else {  \n                    r[0] = new Rectangle2D.Double(Math.min(xxmin, xx), \n                            Math.min(yymax, yy), Math.abs(xx - xxmin), \n                            Math.abs(yy - yymax));\n                }\n                somethingToDraw = true;\n            }\n        }\n        if (this.quadrantPaint[1] != null) {\n            if (x < xmax && y < ymax) {\n                if (this.orientation == PlotOrientation.HORIZONTAL) {\n                    r[1] = new Rectangle2D.Double(Math.min(yymax, yy), \n                            Math.min(xxmax, xx), Math.abs(yy - yymax), \n                            Math.abs(xx - xxmax));\n                }\n                else {  \n                    r[1] = new Rectangle2D.Double(Math.min(xx, xxmax), \n                            Math.min(yymax, yy), Math.abs(xx - xxmax), \n                            Math.abs(yy - yymax));\n                }\n                somethingToDraw = true;\n            }\n        }\n        if (this.quadrantPaint[2] != null) {\n            if (x > xmin && y > ymin) {\n                if (this.orientation == PlotOrientation.HORIZONTAL) {\n                    r[2] = new Rectangle2D.Double(Math.min(yymin, yy), \n                            Math.min(xxmin, xx), Math.abs(yy - yymin), \n                            Math.abs(xx - xxmin));\n                }\n                else {  \n                    r[2] = new Rectangle2D.Double(Math.min(xxmin, xx), \n                            Math.min(yymin, yy), Math.abs(xx - xxmin), \n                            Math.abs(yy - yymin));\n                }\n                somethingToDraw = true;\n            }\n        }\n        if (this.quadrantPaint[3] != null) {\n            if (x < xmax && y > ymin) {\n                if (this.orientation == PlotOrientation.HORIZONTAL) {\n                    r[3] = new Rectangle2D.Double(Math.min(yymin, yy), \n                            Math.min(xxmax, xx), Math.abs(yy - yymin), \n                            Math.abs(xx - xxmax));\n                }\n                else {  \n                    r[3] = new Rectangle2D.Double(Math.min(xx, xxmax), \n                            Math.min(yymin, yy), Math.abs(xx - xxmax), \n                            Math.abs(yy - yymin));\n                }\n                somethingToDraw = true;\n            }\n        }\n        if (somethingToDraw) {\n            Composite originalComposite = g2.getComposite();\n            g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER,\n                    getBackgroundAlpha()));\n            for (int i = 0; i < 4; i++) {\n                if (this.quadrantPaint[i] != null && r[i] != null) {\n                    g2.setPaint(this.quadrantPaint[i]);\n                    g2.fill(r[i]);\n                }\n            }\n            g2.setComposite(originalComposite);\n        }\n    }\n\n    \n    public void drawDomainTickBands(Graphics2D g2, Rectangle2D dataArea, List ticks) {\n        Paint bandPaint = getDomainTickBandPaint();\n        if (bandPaint != null) {\n            boolean fillBand = false;\n            ValueAxis xAxis = getDomainAxis();\n            double previous = xAxis.getLowerBound();\n            Iterator iterator = ticks.iterator();\n            while (iterator.hasNext()) {\n                ValueTick tick = (ValueTick) iterator.next();\n                double current = tick.getValue();\n                if (fillBand) {\n                    getRenderer().fillDomainGridBand(g2, this, xAxis, dataArea,\n                            previous, current);\n                }\n                previous = current;\n                fillBand = !fillBand;\n            }\n            double end = xAxis.getUpperBound();\n            if (fillBand) {\n                getRenderer().fillDomainGridBand(g2, this, xAxis, dataArea, \n                        previous, end);\n            }\n        }\n    }\n\n    \n    public void drawRangeTickBands(Graphics2D g2, Rectangle2D dataArea, List ticks) {\n        Paint bandPaint = getRangeTickBandPaint();\n        if (bandPaint != null) {\n            boolean fillBand = false;\n            ValueAxis axis = getRangeAxis();\n            double previous = axis.getLowerBound();\n            Iterator iterator = ticks.iterator();\n            while (iterator.hasNext()) {\n                ValueTick tick = (ValueTick) iterator.next();\n                double current = tick.getValue();\n                if (fillBand) {\n                    getRenderer().fillRangeGridBand(g2, this, axis, dataArea, \n                            previous, current);\n                }\n                previous = current;\n                fillBand = !fillBand;\n            }\n            double end = axis.getUpperBound();\n            if (fillBand) {\n                getRenderer().fillRangeGridBand(g2, this, axis, dataArea, \n                        previous, end);\n            }\n        }\n    }\n\n    \n    protected Map drawAxes(Graphics2D g2, Rectangle2D plotArea, Rectangle2D dataArea, PlotRenderingInfo plotState) {\n\n        AxisCollection axisCollection = new AxisCollection();\n\n        \n        for (int index = 0; index < this.domainAxes.size(); index++) {\n            ValueAxis axis = (ValueAxis) this.domainAxes.get(index);\n            if (axis != null) {\n                axisCollection.add(axis, getDomainAxisEdge(index));\n            }\n        }\n\n        \n        for (int index = 0; index < this.rangeAxes.size(); index++) {\n            ValueAxis yAxis = (ValueAxis) this.rangeAxes.get(index);\n            if (yAxis != null) {\n                axisCollection.add(yAxis, getRangeAxisEdge(index));\n            }\n        }\n\n        Map axisStateMap = new HashMap();\n\n        \n        double cursor = dataArea.getMinY() - this.axisOffset.calculateTopOutset(\n                dataArea.getHeight());\n        Iterator iterator = axisCollection.getAxesAtTop().iterator();\n        while (iterator.hasNext()) {\n            ValueAxis axis = (ValueAxis) iterator.next();\n            AxisState info = axis.draw(g2, cursor, plotArea, dataArea, \n                    RectangleEdge.TOP, plotState);\n            cursor = info.getCursor();\n            axisStateMap.put(axis, info);\n        }\n\n        \n        cursor = dataArea.getMaxY()\n                 + this.axisOffset.calculateBottomOutset(dataArea.getHeight());\n        iterator = axisCollection.getAxesAtBottom().iterator();\n        while (iterator.hasNext()) {\n            ValueAxis axis = (ValueAxis) iterator.next();\n            AxisState info = axis.draw(g2, cursor, plotArea, dataArea, \n                    RectangleEdge.BOTTOM, plotState);\n            cursor = info.getCursor();\n            axisStateMap.put(axis, info);\n        }\n\n        \n        cursor = dataArea.getMinX()\n                 - this.axisOffset.calculateLeftOutset(dataArea.getWidth());\n        iterator = axisCollection.getAxesAtLeft().iterator();\n        while (iterator.hasNext()) {\n            ValueAxis axis = (ValueAxis) iterator.next();\n            AxisState info = axis.draw(g2, cursor, plotArea, dataArea, \n                    RectangleEdge.LEFT, plotState);\n            cursor = info.getCursor();\n            axisStateMap.put(axis, info);\n        }\n\n        \n        cursor = dataArea.getMaxX()\n                 + this.axisOffset.calculateRightOutset(dataArea.getWidth());\n        iterator = axisCollection.getAxesAtRight().iterator();\n        while (iterator.hasNext()) {\n            ValueAxis axis = (ValueAxis) iterator.next();\n            AxisState info = axis.draw(g2, cursor, plotArea, dataArea, \n                    RectangleEdge.RIGHT, plotState);\n            cursor = info.getCursor();\n            axisStateMap.put(axis, info);\n        }\n\n        return axisStateMap;\n    }\n\n    \n    public boolean render(Graphics2D g2, Rectangle2D dataArea, int index, PlotRenderingInfo info, CrosshairState crosshairState) {\n\n        boolean foundData = false;\n        XYDataset dataset = getDataset(index);\n        if (!DatasetUtilities.isEmptyOrNull(dataset)) {\n            foundData = true;\n            ValueAxis xAxis = getDomainAxisForDataset(index);\n            ValueAxis yAxis = getRangeAxisForDataset(index);\n            XYItemRenderer renderer = getRenderer(index);\n            if (renderer == null) {\n                renderer = getRenderer();\n                if (renderer == null) { \n                    return foundData;\n                }\n            }\n\n            XYItemRendererState state = renderer.initialise(g2, dataArea, this,\n                    dataset, info);\n            int passCount = renderer.getPassCount();\n\n            SeriesRenderingOrder seriesOrder = getSeriesRenderingOrder();\n            if (seriesOrder == SeriesRenderingOrder.REVERSE) {\n                \n                for (int pass = 0; pass < passCount; pass++) {\n                    int seriesCount = dataset.getSeriesCount();\n                    for (int series = seriesCount - 1; series >= 0; series--) {\n                        int firstItem = 0;\n                        int lastItem = dataset.getItemCount(series) - 1;\n                        if (lastItem == -1) {\n                            continue;\n                        }\n                        if (state.getProcessVisibleItemsOnly()) {\n                            int[] itemBounds = RendererUtilities.findLiveItems(\n                                    dataset, series, xAxis.getLowerBound(), \n                                    xAxis.getUpperBound());\n                            firstItem = itemBounds[0];\n                            lastItem = itemBounds[1];\n                        }\n                        for (int item = firstItem; item <= lastItem; item++) {\n                            renderer.drawItem(g2, state, dataArea, info,\n                                    this, xAxis, yAxis, dataset, series, item,\n                                    crosshairState, pass);\n                        }\n                    }\n                }\n            }\n            else {\n                \n                for (int pass = 0; pass < passCount; pass++) {\n                    int seriesCount = dataset.getSeriesCount();\n                    for (int series = 0; series < seriesCount; series++) {\n                        int firstItem = 0;\n                        int lastItem = dataset.getItemCount(series) - 1;\n                        if (state.getProcessVisibleItemsOnly()) {\n                            int[] itemBounds = RendererUtilities.findLiveItems(\n                                    dataset, series, xAxis.getLowerBound(), \n                                    xAxis.getUpperBound());\n                            firstItem = itemBounds[0];\n                            lastItem = itemBounds[1];\n                        }\n                        for (int item = firstItem; item <= lastItem; item++) {\n                            renderer.drawItem(g2, state, dataArea, info,\n                                    this, xAxis, yAxis, dataset, series, item,\n                                    crosshairState, pass);\n                        }\n                    }\n                }\n            }\n        }\n        return foundData;\n    }\n\n    \n    public ValueAxis getDomainAxisForDataset(int index) {\n\n        if (index < 0 || index >= getDatasetCount()) {\n            throw new IllegalArgumentException(\"Index \" + index \n                    + \" out of bounds.\");\n        }\n\n        ValueAxis valueAxis = null;\n        Integer axisIndex = (Integer) this.datasetToDomainAxisMap.get(\n                new Integer(index));\n        if (axisIndex != null) {\n            valueAxis = getDomainAxis(axisIndex.intValue());\n        }\n        else {\n            valueAxis = getDomainAxis(0);\n        }\n        return valueAxis;\n\n    }\n\n    \n    public ValueAxis getRangeAxisForDataset(int index) {\n\n        if (index < 0 || index >= getDatasetCount()) {\n            throw new IllegalArgumentException(\"Index \" + index \n                    + \" out of bounds.\");\n        }\n\n        ValueAxis valueAxis = null;\n        Integer axisIndex\n            = (Integer) this.datasetToRangeAxisMap.get(new Integer(index));\n        if (axisIndex != null) {\n            valueAxis = getRangeAxis(axisIndex.intValue());\n        }\n        else {\n            valueAxis = getRangeAxis(0);\n        }\n        return valueAxis;\n\n    }\n\n    \n    protected void drawDomainGridlines(Graphics2D g2, Rectangle2D dataArea, List ticks) {\n\n        \n        if (getRenderer() == null) {\n            return;\n        }\n\n        \n        if (isDomainGridlinesVisible()) {\n            Stroke gridStroke = getDomainGridlineStroke();\n            Paint gridPaint = getDomainGridlinePaint();\n            Iterator iterator = ticks.iterator();\n            while (iterator.hasNext()) {\n                ValueTick tick = (ValueTick) iterator.next();\n                getRenderer().drawDomainLine(g2, this, getDomainAxis(),\n                        dataArea, tick.getValue(), gridPaint, gridStroke);\n            }\n        }\n    }\n\n    \n    protected void drawRangeGridlines(Graphics2D g2, Rectangle2D area, List ticks) {\n\n        \n        if (getRenderer() == null) {\n            return;\n        }\n\n        \n        if (isRangeGridlinesVisible()) {\n            Stroke gridStroke = getRangeGridlineStroke();\n            Paint gridPaint = getRangeGridlinePaint();\n            ValueAxis axis = getRangeAxis();\n            if (axis != null) {\n                Iterator iterator = ticks.iterator();\n                while (iterator.hasNext()) {\n                    ValueTick tick = (ValueTick) iterator.next();\n                    if (tick.getValue() != 0.0\n                            || !isRangeZeroBaselineVisible()) {\n                        getRenderer().drawRangeLine(g2, this, getRangeAxis(), \n                                area, tick.getValue(), gridPaint, gridStroke);\n                    }\n                }\n            }\n        }\n    }\n\n    \n    protected void drawZeroDomainBaseline(Graphics2D g2, Rectangle2D area) {\n        if (isDomainZeroBaselineVisible()) {\n            XYItemRenderer r = getRenderer();\n            r.drawDomainLine(g2, this, getDomainAxis(), area, 0.0, \n                    this.domainZeroBaselinePaint, \n                    this.domainZeroBaselineStroke);\n        }\n    }\n\n    \n    protected void drawZeroRangeBaseline(Graphics2D g2, Rectangle2D area) {\n        if (isRangeZeroBaselineVisible()) {\n            getRenderer().drawRangeLine(g2, this, getRangeAxis(), area, 0.0, \n                    this.rangeZeroBaselinePaint, this.rangeZeroBaselineStroke);\n        }\n    }\n\n    \n    public void drawAnnotations(Graphics2D g2, Rectangle2D dataArea, PlotRenderingInfo info) {\n\n        Iterator iterator = this.annotations.iterator();\n        while (iterator.hasNext()) {\n            XYAnnotation annotation = (XYAnnotation) iterator.next();\n            ValueAxis xAxis = getDomainAxis();\n            ValueAxis yAxis = getRangeAxis();\n            annotation.draw(g2, this, dataArea, xAxis, yAxis, 0, info);\n        }\n\n    }\n\n    \n    protected void drawDomainMarkers(Graphics2D g2, Rectangle2D dataArea, int index, Layer layer) {\n\n        XYItemRenderer r = getRenderer(index);\n        if (r == null) {\n            return;\n        }\n        \n        \n        if (index >= getDatasetCount()) {\n            return;\n        }    \n        Collection markers = getDomainMarkers(index, layer);\n        ValueAxis axis = getDomainAxisForDataset(index);\n        if (markers != null && axis != null) {\n            Iterator iterator = markers.iterator();\n            while (iterator.hasNext()) {\n                Marker marker = (Marker) iterator.next();\n                r.drawDomainMarker(g2, this, axis, marker, dataArea);\n            }\n        }\n\n    }\n\n    \n    protected void drawRangeMarkers(Graphics2D g2, Rectangle2D dataArea, int index, Layer layer) {\n\n        XYItemRenderer r = getRenderer(index);\n        if (r == null) {\n            return;\n        }\n        \n        \n        if (index >= getDatasetCount()) {\n            return;\n        }\n        Collection markers = getRangeMarkers(index, layer);\n        ValueAxis axis = getRangeAxisForDataset(index);\n        if (markers != null && axis != null) {\n            Iterator iterator = markers.iterator();\n            while (iterator.hasNext()) {\n                Marker marker = (Marker) iterator.next();\n                r.drawRangeMarker(g2, this, axis, marker, dataArea);\n            }\n        }\n    }\n\n    \n    public Collection getDomainMarkers(Layer layer) {\n        return getDomainMarkers(0, layer);\n    }\n\n    \n    public Collection getRangeMarkers(Layer layer) {\n        return getRangeMarkers(0, layer);\n    }\n\n    \n    public Collection getDomainMarkers(int index, Layer layer) {\n        Collection result = null;\n        Integer key = new Integer(index);\n        if (layer == Layer.FOREGROUND) {\n            result = (Collection) this.foregroundDomainMarkers.get(key);\n        }\n        else if (layer == Layer.BACKGROUND) {\n            result = (Collection) this.backgroundDomainMarkers.get(key);\n        }\n        if (result != null) {\n            result = Collections.unmodifiableCollection(result);\n        }\n        return result;\n    }\n\n    \n    public Collection getRangeMarkers(int index, Layer layer) {\n        Collection result = null;\n        Integer key = new Integer(index);\n        if (layer == Layer.FOREGROUND) {\n            result = (Collection) this.foregroundRangeMarkers.get(key);\n        }\n        else if (layer == Layer.BACKGROUND) {\n            result = (Collection) this.backgroundRangeMarkers.get(key);\n        }\n        if (result != null) {\n            result = Collections.unmodifiableCollection(result);\n        }\n        return result;\n    }\n\n    \n    protected void drawHorizontalLine(Graphics2D g2, Rectangle2D dataArea, double value, Stroke stroke, Paint paint) {\n\n        ValueAxis axis = getRangeAxis();\n        if (getOrientation() == PlotOrientation.HORIZONTAL) {\n            axis = getDomainAxis();\n        }\n        if (axis.getRange().contains(value)) {\n            double yy = axis.valueToJava2D(value, dataArea, RectangleEdge.LEFT);\n            Line2D line = new Line2D.Double(dataArea.getMinX(), yy, \n                    dataArea.getMaxX(), yy);\n            g2.setStroke(stroke);\n            g2.setPaint(paint);\n            g2.draw(line);\n        }\n\n    }\n    \n    \n    protected void drawDomainCrosshair(Graphics2D g2, Rectangle2D dataArea, PlotOrientation orientation, double value, ValueAxis axis, Stroke stroke, Paint paint) {\n        \n        if (axis.getRange().contains(value)) {\n            Line2D line = null;\n            if (orientation == PlotOrientation.VERTICAL) {\n                double xx = axis.valueToJava2D(value, dataArea, \n                        RectangleEdge.BOTTOM);\n                line = new Line2D.Double(xx, dataArea.getMinY(), xx, \n                        dataArea.getMaxY());\n            }\n            else {\n                double yy = axis.valueToJava2D(value, dataArea, \n                        RectangleEdge.LEFT);\n                line = new Line2D.Double(dataArea.getMinX(), yy, \n                        dataArea.getMaxX(), yy);\n            }\n            g2.setStroke(stroke);\n            g2.setPaint(paint);\n            g2.draw(line);\n        }\n        \n    }\n\n    \n    protected void drawVerticalLine(Graphics2D g2, Rectangle2D dataArea, double value, Stroke stroke, Paint paint) {\n\n        ValueAxis axis = getDomainAxis();\n        if (getOrientation() == PlotOrientation.HORIZONTAL) {\n            axis = getRangeAxis();\n        }\n        if (axis.getRange().contains(value)) {\n            double xx = axis.valueToJava2D(value, dataArea, \n                    RectangleEdge.BOTTOM);\n            Line2D line = new Line2D.Double(xx, dataArea.getMinY(), xx, \n                    dataArea.getMaxY());\n            g2.setStroke(stroke);\n            g2.setPaint(paint);\n            g2.draw(line);\n        }\n\n    }\n\n    \n    protected void drawRangeCrosshair(Graphics2D g2, Rectangle2D dataArea, PlotOrientation orientation, double value, ValueAxis axis, Stroke stroke, Paint paint) {\n        \n        if (axis.getRange().contains(value)) {\n            Line2D line = null;\n            if (orientation == PlotOrientation.HORIZONTAL) {\n                double xx = axis.valueToJava2D(value, dataArea, \n                        RectangleEdge.BOTTOM);\n                line = new Line2D.Double(xx, dataArea.getMinY(), xx, \n                        dataArea.getMaxY());\n            }\n            else {\n                double yy = axis.valueToJava2D(value, dataArea, \n                        RectangleEdge.LEFT);\n                line = new Line2D.Double(dataArea.getMinX(), yy, \n                        dataArea.getMaxX(), yy);\n            }\n            g2.setStroke(stroke);\n            g2.setPaint(paint);\n            g2.draw(line);\n        }\n        \n    }\n\n    \n    public void handleClick(int x, int y, PlotRenderingInfo info) {\n\n        Rectangle2D dataArea = info.getDataArea();\n        if (dataArea.contains(x, y)) {\n            \n            ValueAxis da = getDomainAxis();\n            if (da != null) {\n                double hvalue = da.java2DToValue(x, info.getDataArea(), \n                        getDomainAxisEdge());\n                setDomainCrosshairValue(hvalue);\n            }\n\n            \n            ValueAxis ra = getRangeAxis();\n            if (ra != null) {\n                double vvalue = ra.java2DToValue(y, info.getDataArea(), \n                        getRangeAxisEdge());\n                setRangeCrosshairValue(vvalue);\n            }\n        }\n    }\n\n    \n    private List getDatasetsMappedToDomainAxis(Integer axisIndex) {\n        if (axisIndex == null) {\n            throw new IllegalArgumentException(\"Null 'axisIndex' argument.\");\n        }\n        List result = new ArrayList();\n        for (int i = 0; i < this.datasets.size(); i++) {\n            Integer mappedAxis = (Integer) this.datasetToDomainAxisMap.get(\n                    new Integer(i));\n            if (mappedAxis == null) {\n                if (axisIndex.equals(ZERO)) {\n                    result.add(this.datasets.get(i));\n                }\n            }\n            else {\n                if (mappedAxis.equals(axisIndex)) {\n                    result.add(this.datasets.get(i));\n                }\n            }\n        }\n        return result;\n    }\n\n    \n    private List getDatasetsMappedToRangeAxis(Integer axisIndex) {\n        if (axisIndex == null) {\n            throw new IllegalArgumentException(\"Null 'axisIndex' argument.\");\n        }\n        List result = new ArrayList();\n        for (int i = 0; i < this.datasets.size(); i++) {\n            Integer mappedAxis = (Integer) this.datasetToRangeAxisMap.get(\n                    new Integer(i));\n            if (mappedAxis == null) {\n                if (axisIndex.equals(ZERO)) {\n                    result.add(this.datasets.get(i));\n                }\n            }\n            else {\n                if (mappedAxis.equals(axisIndex)) {\n                    result.add(this.datasets.get(i));\n                }\n            }\n        }\n        return result;\n    }\n\n    \n    public int getDomainAxisIndex(ValueAxis axis) {\n        int result = this.domainAxes.indexOf(axis);\n        if (result < 0) {\n            \n            Plot parent = getParent();\n            if (parent instanceof XYPlot) {\n                XYPlot p = (XYPlot) parent;\n                result = p.getDomainAxisIndex(axis);\n            }\n        }\n        return result;\n    }\n\n    \n    public int getRangeAxisIndex(ValueAxis axis) {\n        int result = this.rangeAxes.indexOf(axis);\n        if (result < 0) {\n            \n            Plot parent = getParent();\n            if (parent instanceof XYPlot) {\n                XYPlot p = (XYPlot) parent;\n                result = p.getRangeAxisIndex(axis);\n            }\n        }\n        return result;\n    }\n\n    \n    public Range getDataRange(ValueAxis axis) {\n\n        Range result = null;\n        List mappedDatasets = new ArrayList();\n        boolean isDomainAxis = true;\n\n        \n        int domainIndex = getDomainAxisIndex(axis);\n        if (domainIndex >= 0) {\n            isDomainAxis = true;\n            mappedDatasets.addAll(getDatasetsMappedToDomainAxis(\n                    new Integer(domainIndex)));\n        }\n\n        \n        int rangeIndex = getRangeAxisIndex(axis);\n        if (rangeIndex >= 0) {\n            isDomainAxis = false;\n            mappedDatasets.addAll(getDatasetsMappedToRangeAxis(\n                    new Integer(rangeIndex)));\n        }\n\n        \n        \n        Iterator iterator = mappedDatasets.iterator();\n        while (iterator.hasNext()) {\n            XYDataset d = (XYDataset) iterator.next();\n            if (d != null) {\n                XYItemRenderer r = getRendererForDataset(d);\n                if (isDomainAxis) {\n                    if (r != null) {\n                        result = Range.combine(result, r.findDomainBounds(d));\n                    }\n                    else {\n                        result = Range.combine(result, \n                                DatasetUtilities.findDomainBounds(d));\n                    }\n                }\n                else {\n                    if (r != null) {\n                        result = Range.combine(result, r.findRangeBounds(d));\n                    }\n                    else {\n                        result = Range.combine(result, \n                                DatasetUtilities.findRangeBounds(d));\n                    }\n                }\n            }\n        }\n        return result;\n\n    }\n\n    \n    public void datasetChanged(DatasetChangeEvent event) {\n        configureDomainAxes();\n        configureRangeAxes();\n        if (getParent() != null) {\n            getParent().datasetChanged(event);\n        }\n        else {\n            PlotChangeEvent e = new PlotChangeEvent(this);\n            e.setType(ChartChangeEventType.DATASET_UPDATED);\n            notifyListeners(e);\n        }\n    }\n\n    \n    public void rendererChanged(RendererChangeEvent event) {\n        fireChangeEvent();\n    }\n\n    \n    public boolean isDomainCrosshairVisible() {\n        return this.domainCrosshairVisible;\n    }\n\n    \n    public void setDomainCrosshairVisible(boolean flag) {\n        if (this.domainCrosshairVisible != flag) {\n            this.domainCrosshairVisible = flag;\n            fireChangeEvent();\n        }\n    }\n\n    \n    public boolean isDomainCrosshairLockedOnData() {\n        return this.domainCrosshairLockedOnData;\n    }\n\n    \n    public void setDomainCrosshairLockedOnData(boolean flag) {\n        if (this.domainCrosshairLockedOnData != flag) {\n            this.domainCrosshairLockedOnData = flag;\n            fireChangeEvent();\n        }\n    }\n\n    \n    public double getDomainCrosshairValue() {\n        return this.domainCrosshairValue;\n    }\n\n    \n    public void setDomainCrosshairValue(double value) {\n        setDomainCrosshairValue(value, true);\n    }\n\n    \n    public void setDomainCrosshairValue(double value, boolean notify) {\n        this.domainCrosshairValue = value;\n        if (isDomainCrosshairVisible() && notify) {\n            fireChangeEvent();\n        }\n    }\n\n    \n    public Stroke getDomainCrosshairStroke() {\n        return this.domainCrosshairStroke;\n    }\n\n    \n    public void setDomainCrosshairStroke(Stroke stroke) {\n        if (stroke == null) { \n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");\n        }\n        this.domainCrosshairStroke = stroke;\n        fireChangeEvent();\n    }\n\n    \n    public Paint getDomainCrosshairPaint() {\n        return this.domainCrosshairPaint;\n    }\n\n    \n    public void setDomainCrosshairPaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.domainCrosshairPaint = paint;\n        fireChangeEvent();\n    }\n\n    \n    public boolean isRangeCrosshairVisible() {\n        return this.rangeCrosshairVisible;\n    }\n\n    \n    public void setRangeCrosshairVisible(boolean flag) {\n        if (this.rangeCrosshairVisible != flag) {\n            this.rangeCrosshairVisible = flag;\n            fireChangeEvent();\n        }\n    }\n\n    \n    public boolean isRangeCrosshairLockedOnData() {\n        return this.rangeCrosshairLockedOnData;\n    }\n\n    \n    public void setRangeCrosshairLockedOnData(boolean flag) {\n        if (this.rangeCrosshairLockedOnData != flag) {\n            this.rangeCrosshairLockedOnData = flag;\n            fireChangeEvent();\n        }\n    }\n\n    \n    public double getRangeCrosshairValue() {\n        return this.rangeCrosshairValue;\n    }\n\n    \n    public void setRangeCrosshairValue(double value) {\n        setRangeCrosshairValue(value, true);\n    }\n\n    \n    public void setRangeCrosshairValue(double value, boolean notify) {\n        this.rangeCrosshairValue = value;\n        if (isRangeCrosshairVisible() && notify) {\n            fireChangeEvent();\n        }\n    }\n\n    \n    public Stroke getRangeCrosshairStroke() {\n        return this.rangeCrosshairStroke;\n    }\n\n    \n    public void setRangeCrosshairStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");\n        }\n        this.rangeCrosshairStroke = stroke;\n        fireChangeEvent();\n    }\n\n    \n    public Paint getRangeCrosshairPaint() {\n        return this.rangeCrosshairPaint;\n    }\n\n    \n    public void setRangeCrosshairPaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.rangeCrosshairPaint = paint;\n        fireChangeEvent();\n    }\n\n    \n    public AxisSpace getFixedDomainAxisSpace() {\n        return this.fixedDomainAxisSpace;\n    }\n\n    \n    public void setFixedDomainAxisSpace(AxisSpace space) {\n        setFixedDomainAxisSpace(space, true);\n    }\n\n    \n    public void setFixedDomainAxisSpace(AxisSpace space, boolean notify) {\n        this.fixedDomainAxisSpace = space;\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    \n    public AxisSpace getFixedRangeAxisSpace() {\n        return this.fixedRangeAxisSpace;\n    }\n\n    \n    public void setFixedRangeAxisSpace(AxisSpace space) {\n        setFixedRangeAxisSpace(space, true);\n    }\n\n    \n    public void setFixedRangeAxisSpace(AxisSpace space, boolean notify) {\n        this.fixedRangeAxisSpace = space;\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    \n    public void zoomDomainAxes(double factor, PlotRenderingInfo info, Point2D source) {\n        \n        zoomDomainAxes(factor, info, source, false);\n    }\n\n    \n    public void zoomDomainAxes(double factor, PlotRenderingInfo info, Point2D source, boolean useAnchor) {\n                \n        \n        for (int i = 0; i < this.domainAxes.size(); i++) {\n            ValueAxis domainAxis = (ValueAxis) this.domainAxes.get(i);\n            if (domainAxis != null) {\n                if (useAnchor) {\n                    \n                    \n                    double sourceX = source.getX();\n                    if (this.orientation == PlotOrientation.HORIZONTAL) {\n                        sourceX = source.getY();\n                    }\n                    double anchorX = domainAxis.java2DToValue(sourceX, \n                            info.getDataArea(), getDomainAxisEdge());\n                    domainAxis.resizeRange(factor, anchorX);\n                }\n                else {\n                    domainAxis.resizeRange(factor);\n                }\n            }\n        }\n    }\n\n    \n    public void zoomDomainAxes(double lowerPercent, double upperPercent, PlotRenderingInfo info, Point2D source) {\n        for (int i = 0; i < this.domainAxes.size(); i++) {\n            ValueAxis domainAxis = (ValueAxis) this.domainAxes.get(i);\n            if (domainAxis != null) {\n                domainAxis.zoomRange(lowerPercent, upperPercent);\n            }\n        }\n    }\n\n    \n    public void zoomRangeAxes(double factor, PlotRenderingInfo info, Point2D source) {\n        \n        zoomRangeAxes(factor, info, source, false);    \n    }\n    \n    \n    public void zoomRangeAxes(double factor, PlotRenderingInfo info, Point2D source, boolean useAnchor) {\n                \n        \n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis rangeAxis = (ValueAxis) this.rangeAxes.get(i);\n            if (rangeAxis != null) {\n                if (useAnchor) {\n                    \n                    \n                    double sourceY = source.getY();\n                    if (this.orientation == PlotOrientation.HORIZONTAL) {\n                        sourceY = source.getX();\n                    }\n                    double anchorY = rangeAxis.java2DToValue(sourceY, \n                            info.getDataArea(), getRangeAxisEdge());\n                    rangeAxis.resizeRange(factor, anchorY);\n                }\n                else {\n                    rangeAxis.resizeRange(factor);\n                }\n            }\n        }\n    }\n\n    \n    public void zoomRangeAxes(double lowerPercent, double upperPercent, PlotRenderingInfo info, Point2D source) {\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis rangeAxis = (ValueAxis) this.rangeAxes.get(i);\n            if (rangeAxis != null) {\n                rangeAxis.zoomRange(lowerPercent, upperPercent);\n            }\n        }\n    }\n\n    \n    public boolean isDomainZoomable() {\n        return true;\n    }\n\n    \n    public boolean isRangeZoomable() {\n        return true;\n    }\n\n    \n    public int getSeriesCount() {\n        int result = 0;\n        XYDataset dataset = getDataset();\n        if (dataset != null) {\n            result = dataset.getSeriesCount();\n        }\n        return result;\n    }\n\n    \n    public LegendItemCollection getFixedLegendItems() {\n        return this.fixedLegendItems;\n    }\n\n    \n    public void setFixedLegendItems(LegendItemCollection items) {\n        this.fixedLegendItems = items;\n        fireChangeEvent();\n    }\n\n    \n    public LegendItemCollection getLegendItems() {\n        if (this.fixedLegendItems != null) {\n            return this.fixedLegendItems;\n        }\n        LegendItemCollection result = new LegendItemCollection();\n        int count = this.datasets.size();\n        for (int datasetIndex = 0; datasetIndex < count; datasetIndex++) {\n            XYDataset dataset = getDataset(datasetIndex);\n            if (dataset != null) {\n                XYItemRenderer renderer = getRenderer(datasetIndex);\n                if (renderer == null) {\n                    renderer = getRenderer(0);\n                }\n                if (renderer != null) {\n                    int seriesCount = dataset.getSeriesCount();\n                    for (int i = 0; i < seriesCount; i++) {\n                        if (renderer.isSeriesVisible(i)\n                                && renderer.isSeriesVisibleInLegend(i)) {\n                            LegendItem item = renderer.getLegendItem(\n                                    datasetIndex, i);\n                            if (item != null) {\n                                result.add(item);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return result;\n    }\n\n    \n    public boolean equals(Object obj) {\n\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof XYPlot)) {\n            return false;\n        }\n\n        XYPlot that = (XYPlot) obj;\n        if (this.weight != that.weight) {\n            return false;\n        }\n        if (this.orientation != that.orientation) {\n            return false;\n        }\n        if (!this.domainAxes.equals(that.domainAxes)) {\n            return false;\n        }\n        if (!this.domainAxisLocations.equals(that.domainAxisLocations)) {\n            return false;\n        }\n        if (this.rangeCrosshairLockedOnData\n                != that.rangeCrosshairLockedOnData) {\n            return false;\n        }\n        if (this.domainGridlinesVisible != that.domainGridlinesVisible) {\n            return false;\n        }\n        if (this.rangeGridlinesVisible != that.rangeGridlinesVisible) {\n            return false;\n        }\n        if (this.domainZeroBaselineVisible != that.domainZeroBaselineVisible) {\n            return false;\n        }\n        if (this.rangeZeroBaselineVisible != that.rangeZeroBaselineVisible) {\n            return false;\n        }\n        if (this.domainCrosshairVisible != that.domainCrosshairVisible) {\n            return false;\n        }\n        if (this.domainCrosshairValue != that.domainCrosshairValue) {\n            return false;\n        }\n        if (this.domainCrosshairLockedOnData\n                != that.domainCrosshairLockedOnData) {\n            return false;\n        }\n        if (this.rangeCrosshairVisible != that.rangeCrosshairVisible) {\n            return false;\n        }\n        if (this.rangeCrosshairValue != that.rangeCrosshairValue) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.axisOffset, that.axisOffset)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.renderers, that.renderers)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.rangeAxes, that.rangeAxes)) {\n            return false;\n        }\n        if (!this.rangeAxisLocations.equals(that.rangeAxisLocations)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.datasetToDomainAxisMap, \n                that.datasetToDomainAxisMap)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.datasetToRangeAxisMap, \n                that.datasetToRangeAxisMap)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.domainGridlineStroke, \n                that.domainGridlineStroke)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.domainGridlinePaint, \n                that.domainGridlinePaint)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.rangeGridlineStroke, \n                that.rangeGridlineStroke)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.rangeGridlinePaint, \n                that.rangeGridlinePaint)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.domainZeroBaselinePaint, \n                that.domainZeroBaselinePaint)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.domainZeroBaselineStroke, \n                that.domainZeroBaselineStroke)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.rangeZeroBaselinePaint, \n                that.rangeZeroBaselinePaint)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.rangeZeroBaselineStroke, \n                that.rangeZeroBaselineStroke)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.domainCrosshairStroke, \n                that.domainCrosshairStroke)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.domainCrosshairPaint, \n                that.domainCrosshairPaint)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.rangeCrosshairStroke, \n                that.rangeCrosshairStroke)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.rangeCrosshairPaint, \n                that.rangeCrosshairPaint)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.foregroundDomainMarkers, \n                that.foregroundDomainMarkers)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.backgroundDomainMarkers, \n                that.backgroundDomainMarkers)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.foregroundRangeMarkers, \n                that.foregroundRangeMarkers)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.backgroundRangeMarkers, \n                that.backgroundRangeMarkers)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.foregroundDomainMarkers, \n                that.foregroundDomainMarkers)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.backgroundDomainMarkers, \n                that.backgroundDomainMarkers)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.foregroundRangeMarkers, \n                that.foregroundRangeMarkers)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.backgroundRangeMarkers, \n                that.backgroundRangeMarkers)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.annotations, that.annotations)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.domainTickBandPaint, \n                that.domainTickBandPaint)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.rangeTickBandPaint, \n                that.rangeTickBandPaint)) {\n            return false;\n        }\n        if (!this.quadrantOrigin.equals(that.quadrantOrigin)) {\n            return false;\n        }\n        for (int i = 0; i < 4; i++) {\n            if (!PaintUtilities.equal(this.quadrantPaint[i], \n                    that.quadrantPaint[i])) {\n                return false;\n            }\n        }\n        return super.equals(obj);\n    }\n\n    \n    public Object clone() throws CloneNotSupportedException {\n\n        XYPlot clone = (XYPlot) super.clone();\n        clone.domainAxes = (ObjectList) ObjectUtilities.clone(this.domainAxes);\n        for (int i = 0; i < this.domainAxes.size(); i++) {\n            ValueAxis axis = (ValueAxis) this.domainAxes.get(i);\n            if (axis != null) {\n                ValueAxis clonedAxis = (ValueAxis) axis.clone();\n                clone.domainAxes.set(i, clonedAxis);\n                clonedAxis.setPlot(clone);\n                clonedAxis.addChangeListener(clone);\n            }\n        }\n        clone.domainAxisLocations = (ObjectList) \n                this.domainAxisLocations.clone();\n\n        clone.rangeAxes = (ObjectList) ObjectUtilities.clone(this.rangeAxes);\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis axis = (ValueAxis) this.rangeAxes.get(i);\n            if (axis != null) {\n                ValueAxis clonedAxis = (ValueAxis) axis.clone();\n                clone.rangeAxes.set(i, clonedAxis);\n                clonedAxis.setPlot(clone);\n                clonedAxis.addChangeListener(clone);\n            }\n        }\n        clone.rangeAxisLocations = (ObjectList) ObjectUtilities.clone(\n                this.rangeAxisLocations);\n\n        \n        clone.datasets = (ObjectList) ObjectUtilities.clone(this.datasets);\n        for (int i = 0; i < clone.datasets.size(); ++i) {\n            XYDataset d = getDataset(i);\n            if (d != null) {\n                d.addChangeListener(clone);\n            }\n        }\n\n        clone.datasetToDomainAxisMap = new TreeMap();\n        clone.datasetToDomainAxisMap.putAll(this.datasetToDomainAxisMap);\n        clone.datasetToRangeAxisMap = new TreeMap();\n        clone.datasetToRangeAxisMap.putAll(this.datasetToRangeAxisMap);\n\n        clone.renderers = (ObjectList) ObjectUtilities.clone(this.renderers);\n        for (int i = 0; i < this.renderers.size(); i++) {\n            XYItemRenderer renderer2 = (XYItemRenderer) this.renderers.get(i);\n            if (renderer2 instanceof PublicCloneable) {\n                PublicCloneable pc = (PublicCloneable) renderer2;\n                clone.renderers.set(i, pc.clone());\n            }\n        }\n        clone.foregroundDomainMarkers = (Map) ObjectUtilities.clone(\n                this.foregroundDomainMarkers);\n        clone.backgroundDomainMarkers = (Map) ObjectUtilities.clone(\n                this.backgroundDomainMarkers);\n        clone.foregroundRangeMarkers = (Map) ObjectUtilities.clone(\n                this.foregroundRangeMarkers);\n        clone.backgroundRangeMarkers = (Map) ObjectUtilities.clone(\n                this.backgroundRangeMarkers);\n        clone.annotations = (List) ObjectUtilities.deepClone(this.annotations);\n        if (this.fixedDomainAxisSpace != null) {\n            clone.fixedDomainAxisSpace = (AxisSpace) ObjectUtilities.clone(\n                    this.fixedDomainAxisSpace);\n        }\n        if (this.fixedRangeAxisSpace != null) {\n            clone.fixedRangeAxisSpace = (AxisSpace) ObjectUtilities.clone(\n                    this.fixedRangeAxisSpace);\n        }\n\n        clone.quadrantOrigin = (Point2D) ObjectUtilities.clone(\n                this.quadrantOrigin);\n        clone.quadrantPaint = (Paint[]) this.quadrantPaint.clone();\n        return clone;\n\n    }\n\n    \n    private void writeObject(ObjectOutputStream stream) throws IOException {\n        stream.defaultWriteObject();\n        SerialUtilities.writeStroke(this.domainGridlineStroke, stream);\n        SerialUtilities.writePaint(this.domainGridlinePaint, stream);\n        SerialUtilities.writeStroke(this.rangeGridlineStroke, stream);\n        SerialUtilities.writePaint(this.rangeGridlinePaint, stream);\n        SerialUtilities.writeStroke(this.rangeZeroBaselineStroke, stream);\n        SerialUtilities.writePaint(this.rangeZeroBaselinePaint, stream);\n        SerialUtilities.writeStroke(this.domainCrosshairStroke, stream);\n        SerialUtilities.writePaint(this.domainCrosshairPaint, stream);\n        SerialUtilities.writeStroke(this.rangeCrosshairStroke, stream);\n        SerialUtilities.writePaint(this.rangeCrosshairPaint, stream);\n        SerialUtilities.writePaint(this.domainTickBandPaint, stream);\n        SerialUtilities.writePaint(this.rangeTickBandPaint, stream);\n        SerialUtilities.writePoint2D(this.quadrantOrigin, stream);\n        for (int i = 0; i < 4; i++) {\n            SerialUtilities.writePaint(this.quadrantPaint[i], stream);\n        }\n        SerialUtilities.writeStroke(this.domainZeroBaselineStroke, stream);\n        SerialUtilities.writePaint(this.domainZeroBaselinePaint, stream);\n    }\n\n    \n    private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {\n\n        stream.defaultReadObject();\n        this.domainGridlineStroke = SerialUtilities.readStroke(stream);\n        this.domainGridlinePaint = SerialUtilities.readPaint(stream);\n        this.rangeGridlineStroke = SerialUtilities.readStroke(stream);\n        this.rangeGridlinePaint = SerialUtilities.readPaint(stream);\n        this.rangeZeroBaselineStroke = SerialUtilities.readStroke(stream);\n        this.rangeZeroBaselinePaint = SerialUtilities.readPaint(stream);\n        this.domainCrosshairStroke = SerialUtilities.readStroke(stream);\n        this.domainCrosshairPaint = SerialUtilities.readPaint(stream);\n        this.rangeCrosshairStroke = SerialUtilities.readStroke(stream);\n        this.rangeCrosshairPaint = SerialUtilities.readPaint(stream);\n        this.domainTickBandPaint = SerialUtilities.readPaint(stream);\n        this.rangeTickBandPaint = SerialUtilities.readPaint(stream);\n        this.quadrantOrigin = SerialUtilities.readPoint2D(stream);\n        this.quadrantPaint = new Paint[4];\n        for (int i = 0; i < 4; i++) {\n            this.quadrantPaint[i] = SerialUtilities.readPaint(stream);\n        }\n\n        this.domainZeroBaselineStroke = SerialUtilities.readStroke(stream);\n        this.domainZeroBaselinePaint = SerialUtilities.readPaint(stream);\n\n        \n        \n        int domainAxisCount = this.domainAxes.size();\n        for (int i = 0; i < domainAxisCount; i++) {\n            Axis axis = (Axis) this.domainAxes.get(i);\n            if (axis != null) {\n                axis.setPlot(this);\n                axis.addChangeListener(this);\n            }\n        }\n        int rangeAxisCount = this.rangeAxes.size();\n        for (int i = 0; i < rangeAxisCount; i++) {\n            Axis axis = (Axis) this.rangeAxes.get(i);\n            if (axis != null) {\n                axis.setPlot(this);\n                axis.addChangeListener(this);\n            }\n        }\n        int datasetCount = this.datasets.size();\n        for (int i = 0; i < datasetCount; i++) {\n            Dataset dataset = (Dataset) this.datasets.get(i);\n            if (dataset != null) {\n                dataset.addChangeListener(this);\n            }\n        }\n        int rendererCount = this.renderers.size();\n        for (int i = 0; i < rendererCount; i++) {\n            XYItemRenderer renderer = (XYItemRenderer) this.renderers.get(i);\n            if (renderer != null) {\n                renderer.addChangeListener(this);\n            }\n        }\n    \n    }\n\n}\n",
      "fixed_full_code": "\n\npackage org.jfree.chart.plot;\n\nimport java.awt.AlphaComposite;\nimport java.awt.BasicStroke;\nimport java.awt.Color;\nimport java.awt.Composite;\nimport java.awt.Graphics2D;\nimport java.awt.Paint;\nimport java.awt.Shape;\nimport java.awt.Stroke;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.ResourceBundle;\nimport java.util.Set;\nimport java.util.TreeMap;\n\nimport org.jfree.chart.LegendItem;\nimport org.jfree.chart.LegendItemCollection;\nimport org.jfree.chart.annotations.XYAnnotation;\nimport org.jfree.chart.axis.Axis;\nimport org.jfree.chart.axis.AxisCollection;\nimport org.jfree.chart.axis.AxisLocation;\nimport org.jfree.chart.axis.AxisSpace;\nimport org.jfree.chart.axis.AxisState;\nimport org.jfree.chart.axis.ValueAxis;\nimport org.jfree.chart.axis.ValueTick;\nimport org.jfree.chart.event.ChartChangeEventType;\nimport org.jfree.chart.event.PlotChangeEvent;\nimport org.jfree.chart.event.RendererChangeEvent;\nimport org.jfree.chart.event.RendererChangeListener;\nimport org.jfree.chart.renderer.RendererUtilities;\nimport org.jfree.chart.renderer.xy.XYItemRenderer;\nimport org.jfree.chart.renderer.xy.XYItemRendererState;\nimport org.jfree.chart.util.Layer;\nimport org.jfree.chart.util.ObjectList;\nimport org.jfree.chart.util.ObjectUtilities;\nimport org.jfree.chart.util.PaintUtilities;\nimport org.jfree.chart.util.PublicCloneable;\nimport org.jfree.chart.util.RectangleEdge;\nimport org.jfree.chart.util.RectangleInsets;\nimport org.jfree.chart.util.SerialUtilities;\nimport org.jfree.data.Range;\nimport org.jfree.data.general.Dataset;\nimport org.jfree.data.general.DatasetChangeEvent;\nimport org.jfree.data.general.DatasetUtilities;\nimport org.jfree.data.xy.XYDataset;\n\n\npublic class XYPlot extends Plot implements ValueAxisPlot, Zoomable, RendererChangeListener, Cloneable, PublicCloneable, Serializable { private static final long serialVersionUID = 7044148245716569264L; public static final Stroke DEFAULT_GRIDLINE_STROKE = new BasicStroke(0.5f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL, 0.0f, new float[] {2.0f, 2.0f}, 0.0f); public static final Paint DEFAULT_GRIDLINE_PAINT = Color.WHITE; public static final boolean DEFAULT_CROSSHAIR_VISIBLE = false; public static final Stroke DEFAULT_CROSSHAIR_STROKE = DEFAULT_GRIDLINE_STROKE; public static final Paint DEFAULT_CROSSHAIR_PAINT = Color.blue; protected static ResourceBundle localizationResources = ResourceBundle.getBundle( \"org.jfree.chart.plot.LocalizationBundle\"); private PlotOrientation orientation; private RectangleInsets axisOffset; private ObjectList domainAxes; private ObjectList domainAxisLocations; private ObjectList rangeAxes; private ObjectList rangeAxisLocations; private ObjectList datasets; private ObjectList renderers; private Map datasetToDomainAxisMap; private Map datasetToRangeAxisMap; private transient Point2D quadrantOrigin = new Point2D.Double(0.0, 0.0); private transient Paint[] quadrantPaint = new Paint[] {null, null, null, null};\n\n    \n    private boolean domainGridlinesVisible; private transient Stroke domainGridlineStroke; private transient Paint domainGridlinePaint; private boolean rangeGridlinesVisible; private transient Stroke rangeGridlineStroke; private transient Paint rangeGridlinePaint; private boolean domainZeroBaselineVisible; private transient Stroke domainZeroBaselineStroke; private transient Paint domainZeroBaselinePaint; private boolean rangeZeroBaselineVisible; private transient Stroke rangeZeroBaselineStroke; private transient Paint rangeZeroBaselinePaint; private boolean domainCrosshairVisible; private double domainCrosshairValue; private transient Stroke domainCrosshairStroke; private transient Paint domainCrosshairPaint; private boolean domainCrosshairLockedOnData = true; private boolean rangeCrosshairVisible; private double rangeCrosshairValue; private transient Stroke rangeCrosshairStroke; private transient Paint rangeCrosshairPaint; private boolean rangeCrosshairLockedOnData = true; private Map foregroundDomainMarkers; private Map backgroundDomainMarkers; private Map foregroundRangeMarkers; private Map backgroundRangeMarkers; private List annotations; private transient Paint domainTickBandPaint; private transient Paint rangeTickBandPaint; private AxisSpace fixedDomainAxisSpace; private AxisSpace fixedRangeAxisSpace; private DatasetRenderingOrder datasetRenderingOrder = DatasetRenderingOrder.REVERSE; private SeriesRenderingOrder seriesRenderingOrder = SeriesRenderingOrder.REVERSE; private int weight; private LegendItemCollection fixedLegendItems; public XYPlot() {\n        this(null, null, null, null);\n    }\n\n    \n    public XYPlot(XYDataset dataset, ValueAxis domainAxis, ValueAxis rangeAxis, XYItemRenderer renderer) {\n\n        super();\n\n        this.orientation = PlotOrientation.VERTICAL;\n        this.weight = 1;  \n        this.axisOffset = new RectangleInsets(4.0, 4.0, 4.0, 4.0);\n\n        \n        this.domainAxes = new ObjectList();\n        this.domainAxisLocations = new ObjectList();\n        this.foregroundDomainMarkers = new HashMap();\n        this.backgroundDomainMarkers = new HashMap();\n\n        this.rangeAxes = new ObjectList();\n        this.rangeAxisLocations = new ObjectList();\n        this.foregroundRangeMarkers = new HashMap();\n        this.backgroundRangeMarkers = new HashMap();\n\n        this.datasets = new ObjectList();\n        this.renderers = new ObjectList();\n\n        this.datasetToDomainAxisMap = new TreeMap();\n        this.datasetToRangeAxisMap = new TreeMap();\n\n        this.datasets.set(0, dataset);\n        if (dataset != null) {\n            dataset.addChangeListener(this);\n        }\n\n        this.renderers.set(0, renderer);\n        if (renderer != null) {\n            renderer.setPlot(this);\n            renderer.addChangeListener(this);\n        }\n\n        this.domainAxes.set(0, domainAxis);\n        this.mapDatasetToDomainAxis(0, 0);\n        if (domainAxis != null) {\n            domainAxis.setPlot(this);\n            domainAxis.addChangeListener(this);\n        }\n        this.domainAxisLocations.set(0, AxisLocation.BOTTOM_OR_LEFT);\n\n        this.rangeAxes.set(0, rangeAxis);\n        this.mapDatasetToRangeAxis(0, 0);\n        if (rangeAxis != null) {\n            rangeAxis.setPlot(this);\n            rangeAxis.addChangeListener(this);\n        }\n        this.rangeAxisLocations.set(0, AxisLocation.BOTTOM_OR_LEFT);\n\n        configureDomainAxes();\n        configureRangeAxes();\n\n        this.domainGridlinesVisible = true;\n        this.domainGridlineStroke = DEFAULT_GRIDLINE_STROKE;\n        this.domainGridlinePaint = DEFAULT_GRIDLINE_PAINT;\n\n        this.domainZeroBaselineVisible = false;\n        this.domainZeroBaselinePaint = Color.black;\n        this.domainZeroBaselineStroke = new BasicStroke(0.5f);\n\n        this.rangeGridlinesVisible = true;\n        this.rangeGridlineStroke = DEFAULT_GRIDLINE_STROKE;\n        this.rangeGridlinePaint = DEFAULT_GRIDLINE_PAINT;\n\n        this.rangeZeroBaselineVisible = false;\n        this.rangeZeroBaselinePaint = Color.black;\n        this.rangeZeroBaselineStroke = new BasicStroke(0.5f);\n\n        this.domainCrosshairVisible = false;\n        this.domainCrosshairValue = 0.0;\n        this.domainCrosshairStroke = DEFAULT_CROSSHAIR_STROKE;\n        this.domainCrosshairPaint = DEFAULT_CROSSHAIR_PAINT;\n\n        this.rangeCrosshairVisible = false;\n        this.rangeCrosshairValue = 0.0;\n        this.rangeCrosshairStroke = DEFAULT_CROSSHAIR_STROKE;\n        this.rangeCrosshairPaint = DEFAULT_CROSSHAIR_PAINT;\n\n        this.annotations = new java.util.ArrayList();\n\n    }\n\n    \n    public String getPlotType() {\n        return localizationResources.getString(\"XY_Plot\");\n    }\n\n    \n    public PlotOrientation getOrientation() {\n        return this.orientation;\n    }\n\n    \n    public void setOrientation(PlotOrientation orientation) {\n        if (orientation == null) {\n            throw new IllegalArgumentException(\"Null 'orientation' argument.\");\n        }\n        if (orientation != this.orientation) {\n            this.orientation = orientation;\n            fireChangeEvent();\n        }\n    }\n\n    \n    public RectangleInsets getAxisOffset() {\n        return this.axisOffset;\n    }\n\n    \n    public void setAxisOffset(RectangleInsets offset) {\n        if (offset == null) {\n            throw new IllegalArgumentException(\"Null 'offset' argument.\");\n        }\n        this.axisOffset = offset;\n        fireChangeEvent();\n    }\n\n    \n    public ValueAxis getDomainAxis() {\n        return getDomainAxis(0);\n    }\n\n    \n    public ValueAxis getDomainAxis(int index) {\n        ValueAxis result = null;\n        if (index < this.domainAxes.size()) {\n            result = (ValueAxis) this.domainAxes.get(index);\n        }\n        if (result == null) {\n            Plot parent = getParent();\n            if (parent instanceof XYPlot) {\n                XYPlot xy = (XYPlot) parent;\n                result = xy.getDomainAxis(index);\n            }\n        }\n        return result;\n    }\n\n    \n    public void setDomainAxis(ValueAxis axis) {\n        setDomainAxis(0, axis);\n    }\n\n    \n    public void setDomainAxis(int index, ValueAxis axis) {\n        setDomainAxis(index, axis, true);\n    }\n    \n    \n    public void setDomainAxis(int index, ValueAxis axis, boolean notify) {\n        ValueAxis existing = getDomainAxis(index);\n        if (existing != null) {\n            existing.removeChangeListener(this);\n        }\n        if (axis != null) {\n            axis.setPlot(this);\n        }\n        this.domainAxes.set(index, axis);\n        if (axis != null) {\n            axis.configure();\n            axis.addChangeListener(this);\n        }\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    \n    public void setDomainAxes(ValueAxis[] axes) {\n        for (int i = 0; i < axes.length; i++) {\n            setDomainAxis(i, axes[i], false);   \n        }\n        fireChangeEvent();\n    }\n    \n    \n    public AxisLocation getDomainAxisLocation() {\n        return (AxisLocation) this.domainAxisLocations.get(0);\n    }\n\n    \n    public void setDomainAxisLocation(AxisLocation location) {\n        \n        setDomainAxisLocation(0, location, true);\n    }\n\n    \n    public void setDomainAxisLocation(AxisLocation location, boolean notify) {\n        \n        setDomainAxisLocation(0, location, notify);\n    }\n\n    \n    public RectangleEdge getDomainAxisEdge() {\n        return Plot.resolveDomainAxisLocation(getDomainAxisLocation(), \n                this.orientation);\n    }\n\n    \n    public int getDomainAxisCount() {\n        return this.domainAxes.size();\n    }\n\n    \n    public void clearDomainAxes() {\n        for (int i = 0; i < this.domainAxes.size(); i++) {\n            ValueAxis axis = (ValueAxis) this.domainAxes.get(i);\n            if (axis != null) {\n                axis.removeChangeListener(this);\n            }\n        }\n        this.domainAxes.clear();\n        fireChangeEvent();\n    }\n\n    \n    public void configureDomainAxes() {\n        for (int i = 0; i < this.domainAxes.size(); i++) {\n            ValueAxis axis = (ValueAxis) this.domainAxes.get(i);\n            if (axis != null) {\n                axis.configure();\n            }\n        }\n    }\n\n    \n    public AxisLocation getDomainAxisLocation(int index) {\n        AxisLocation result = null;\n        if (index < this.domainAxisLocations.size()) {\n            result = (AxisLocation) this.domainAxisLocations.get(index);\n        }\n        if (result == null) {\n            result = AxisLocation.getOpposite(getDomainAxisLocation());\n        }\n        return result;\n    }\n\n    \n    public void setDomainAxisLocation(int index, AxisLocation location) {\n        \n        setDomainAxisLocation(index, location, true);\n    }\n\n    \n    public void setDomainAxisLocation(int index, AxisLocation location, boolean notify) {\n        \n        if (index == 0 && location == null) {\n            throw new IllegalArgumentException(\n                    \"Null 'location' for index 0 not permitted.\");\n        }\n        this.domainAxisLocations.set(index, location);\n        if (notify) {\n            fireChangeEvent();\n        }        \n    }\n\n    \n    public RectangleEdge getDomainAxisEdge(int index) {\n        AxisLocation location = getDomainAxisLocation(index);\n        RectangleEdge result = Plot.resolveDomainAxisLocation(location, \n                this.orientation);\n        if (result == null) {\n            result = RectangleEdge.opposite(getDomainAxisEdge());\n        }\n        return result;\n    }\n\n    \n    public ValueAxis getRangeAxis() {\n        return getRangeAxis(0);\n    }\n\n    \n    public void setRangeAxis(ValueAxis axis) {\n\n        if (axis != null) {\n            axis.setPlot(this);\n        }\n\n        \n        ValueAxis existing = getRangeAxis();\n        if (existing != null) {\n            existing.removeChangeListener(this);\n        }\n\n        this.rangeAxes.set(0, axis);\n        if (axis != null) {\n            axis.configure();\n            axis.addChangeListener(this);\n        }\n        fireChangeEvent();\n\n    }\n\n    \n    public AxisLocation getRangeAxisLocation() {\n        return (AxisLocation) this.rangeAxisLocations.get(0);\n    }\n\n    \n    public void setRangeAxisLocation(AxisLocation location) {\n        \n        setRangeAxisLocation(0, location, true);\n    }\n\n    \n    public void setRangeAxisLocation(AxisLocation location, boolean notify) {\n        \n        setRangeAxisLocation(0, location, notify);\n    }\n\n    \n    public RectangleEdge getRangeAxisEdge() {\n        return Plot.resolveRangeAxisLocation(getRangeAxisLocation(), \n                this.orientation);\n    }\n\n    \n    public ValueAxis getRangeAxis(int index) {\n        ValueAxis result = null;\n        if (index < this.rangeAxes.size()) {\n            result = (ValueAxis) this.rangeAxes.get(index);\n        }\n        if (result == null) {\n            Plot parent = getParent();\n            if (parent instanceof XYPlot) {\n                XYPlot xy = (XYPlot) parent;\n                result = xy.getRangeAxis(index);\n            }\n        }\n        return result;\n    }\n\n    \n    public void setRangeAxis(int index, ValueAxis axis) {\n        setRangeAxis(index, axis, true);\n    } \n    \n    \n    public void setRangeAxis(int index, ValueAxis axis, boolean notify) {\n        ValueAxis existing = getRangeAxis(index);\n        if (existing != null) {\n            existing.removeChangeListener(this);\n        }\n        if (axis != null) {\n            axis.setPlot(this);\n        }\n        this.rangeAxes.set(index, axis);\n        if (axis != null) {\n            axis.configure();\n            axis.addChangeListener(this);\n        }\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    \n    public void setRangeAxes(ValueAxis[] axes) {\n        for (int i = 0; i < axes.length; i++) {\n            setRangeAxis(i, axes[i], false);   \n        }\n        fireChangeEvent();\n    }\n    \n    \n    public int getRangeAxisCount() {\n        return this.rangeAxes.size();\n    }\n\n    \n    public void clearRangeAxes() {\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis axis = (ValueAxis) this.rangeAxes.get(i);\n            if (axis != null) {\n                axis.removeChangeListener(this);\n            }\n        }\n        this.rangeAxes.clear();\n        fireChangeEvent();\n    }\n\n    \n    public void configureRangeAxes() {\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis axis = (ValueAxis) this.rangeAxes.get(i);\n            if (axis != null) {\n                axis.configure();\n            }\n        }\n    }\n\n    \n    public AxisLocation getRangeAxisLocation(int index) {\n        AxisLocation result = null;\n        if (index < this.rangeAxisLocations.size()) {\n            result = (AxisLocation) this.rangeAxisLocations.get(index);\n        }\n        if (result == null) {\n            result = AxisLocation.getOpposite(getRangeAxisLocation());\n        }\n        return result;\n    }\n\n    \n    public void setRangeAxisLocation(int index, AxisLocation location) {\n        \n        setRangeAxisLocation(index, location, true);\n    }\n    \n    \n    public void setRangeAxisLocation(int index, AxisLocation location, boolean notify) {\n        \n        if (index == 0 && location == null) {\n            throw new IllegalArgumentException(\n                    \"Null 'location' for index 0 not permitted.\");\n        }\n        this.rangeAxisLocations.set(index, location);\n        if (notify) {\n            fireChangeEvent();\n        }   \n    }\n\n    \n    public RectangleEdge getRangeAxisEdge(int index) {\n        AxisLocation location = getRangeAxisLocation(index);\n        RectangleEdge result = Plot.resolveRangeAxisLocation(location, \n                this.orientation);\n        if (result == null) {\n            result = RectangleEdge.opposite(getRangeAxisEdge());\n        }\n        return result;\n    }\n\n    \n    public XYDataset getDataset() {\n        return getDataset(0);\n    }\n\n    \n    public XYDataset getDataset(int index) {\n        XYDataset result = null;\n        if (this.datasets.size() > index) {\n            result = (XYDataset) this.datasets.get(index);\n        }\n        return result;\n    }\n\n    \n    public void setDataset(XYDataset dataset) {\n        setDataset(0, dataset);\n    }\n\n    \n    public void setDataset(int index, XYDataset dataset) {\n        XYDataset existing = getDataset(index);\n        if (existing != null) {\n            existing.removeChangeListener(this);\n        }\n        this.datasets.set(index, dataset);\n        if (dataset != null) {\n            dataset.addChangeListener(this);\n        }\n\n        \n        DatasetChangeEvent event = new DatasetChangeEvent(this, dataset);\n        datasetChanged(event);\n    }\n\n    \n    public int getDatasetCount() {\n        return this.datasets.size();\n    }\n\n    \n    public int indexOf(XYDataset dataset) {\n        int result = -1;\n        for (int i = 0; i < this.datasets.size(); i++) {\n            if (dataset == this.datasets.get(i)) {\n                result = i;\n                break;\n            }\n        }\n        return result;\n    }\n\n    \n    public void mapDatasetToDomainAxis(int index, int axisIndex) {\n        this.datasetToDomainAxisMap.put(new Integer(index), \n                new Integer(axisIndex));\n        \n        datasetChanged(new DatasetChangeEvent(this, getDataset(index)));\n    }\n\n    \n    public void mapDatasetToRangeAxis(int index, int axisIndex) {\n        this.datasetToRangeAxisMap.put(new Integer(index), \n                new Integer(axisIndex));\n        \n        datasetChanged(new DatasetChangeEvent(this, getDataset(index)));\n    }\n\n    \n    public XYItemRenderer getRenderer() {\n        return getRenderer(0);\n    }\n\n    \n    public XYItemRenderer getRenderer(int index) {\n        XYItemRenderer result = null;\n        if (this.renderers.size() > index) {\n            result = (XYItemRenderer) this.renderers.get(index);\n        }\n        return result;\n\n    }\n\n    \n    public void setRenderer(XYItemRenderer renderer) {\n        setRenderer(0, renderer);\n    }\n\n    \n    public void setRenderer(int index, XYItemRenderer renderer) {\n        setRenderer(index, renderer, true);\n    }\n\n    \n    public void setRenderer(int index, XYItemRenderer renderer, boolean notify) {\n        XYItemRenderer existing = getRenderer(index);\n        if (existing != null) {\n            existing.removeChangeListener(this);\n        }\n        this.renderers.set(index, renderer);\n        if (renderer != null) {\n            renderer.setPlot(this);\n            renderer.addChangeListener(this);\n        }\n        configureDomainAxes();\n        configureRangeAxes();\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    \n    public void setRenderers(XYItemRenderer[] renderers) {\n        for (int i = 0; i < renderers.length; i++) {\n            setRenderer(i, renderers[i], false);   \n        }\n        fireChangeEvent();\n    }\n    \n    \n    public DatasetRenderingOrder getDatasetRenderingOrder() {\n        return this.datasetRenderingOrder;\n    }\n\n    \n    public void setDatasetRenderingOrder(DatasetRenderingOrder order) {\n        if (order == null) {\n            throw new IllegalArgumentException(\"Null 'order' argument.\");\n        }\n        this.datasetRenderingOrder = order;\n        fireChangeEvent();\n    }\n\n    \n    public SeriesRenderingOrder getSeriesRenderingOrder() {\n        return this.seriesRenderingOrder;\n    }\n\n    \n    public void setSeriesRenderingOrder(SeriesRenderingOrder order) {\n        if (order == null) {\n            throw new IllegalArgumentException(\"Null 'order' argument.\");\n        }\n        this.seriesRenderingOrder = order;\n        fireChangeEvent();\n    }\n\n    \n    public int getIndexOf(XYItemRenderer renderer) {\n        return this.renderers.indexOf(renderer);\n    }\n\n    \n    public XYItemRenderer getRendererForDataset(XYDataset dataset) {\n        XYItemRenderer result = null;\n        for (int i = 0; i < this.datasets.size(); i++) {\n            if (this.datasets.get(i) == dataset) {\n                result = (XYItemRenderer) this.renderers.get(i);\n                if (result == null) {\n                    result = getRenderer();\n                }\n                break;\n            }\n        }\n        return result;\n    }\n\n    \n    public int getWeight() {\n        return this.weight;\n    }\n\n    \n    public void setWeight(int weight) {\n        this.weight = weight;\n        fireChangeEvent();\n    }\n\n    \n    public boolean isDomainGridlinesVisible() {\n        return this.domainGridlinesVisible;\n    }\n\n    \n    public void setDomainGridlinesVisible(boolean visible) {\n        if (this.domainGridlinesVisible != visible) {\n            this.domainGridlinesVisible = visible;\n            fireChangeEvent();\n        }\n    }\n\n    \n    public Stroke getDomainGridlineStroke() {\n        return this.domainGridlineStroke;\n    }\n\n    \n    public void setDomainGridlineStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");\n        }\n        this.domainGridlineStroke = stroke;\n        fireChangeEvent();\n    }\n\n    \n    public Paint getDomainGridlinePaint() {\n        return this.domainGridlinePaint;\n    }\n\n    \n    public void setDomainGridlinePaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.domainGridlinePaint = paint;\n        fireChangeEvent();\n    }\n\n    \n    public boolean isRangeGridlinesVisible() {\n        return this.rangeGridlinesVisible;\n    }\n\n    \n    public void setRangeGridlinesVisible(boolean visible) {\n        if (this.rangeGridlinesVisible != visible) {\n            this.rangeGridlinesVisible = visible;\n            fireChangeEvent();\n        }\n    }\n\n    \n    public Stroke getRangeGridlineStroke() {\n        return this.rangeGridlineStroke;\n    }\n\n    \n    public void setRangeGridlineStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");\n        }\n        this.rangeGridlineStroke = stroke;\n        fireChangeEvent();\n    }\n\n    \n    public Paint getRangeGridlinePaint() {\n        return this.rangeGridlinePaint;\n    }\n\n    \n    public void setRangeGridlinePaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.rangeGridlinePaint = paint;\n        fireChangeEvent();\n    }\n\n    \n    public boolean isDomainZeroBaselineVisible() {\n        return this.domainZeroBaselineVisible;\n    }\n\n    \n    public void setDomainZeroBaselineVisible(boolean visible) {\n        this.domainZeroBaselineVisible = visible;\n        fireChangeEvent();\n    }\n\n    \n    public Stroke getDomainZeroBaselineStroke() {\n        return this.domainZeroBaselineStroke;\n    }\n\n    \n    public void setDomainZeroBaselineStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");\n        }\n        this.domainZeroBaselineStroke = stroke;\n        fireChangeEvent();\n    }\n\n    \n    public Paint getDomainZeroBaselinePaint() {\n        return this.domainZeroBaselinePaint;\n    }\n\n    \n    public void setDomainZeroBaselinePaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.domainZeroBaselinePaint = paint;\n        fireChangeEvent();\n    }\n    \n    \n    public boolean isRangeZeroBaselineVisible() {\n        return this.rangeZeroBaselineVisible;\n    }\n\n    \n    public void setRangeZeroBaselineVisible(boolean visible) {\n        this.rangeZeroBaselineVisible = visible;\n        fireChangeEvent();\n    }\n\n    \n    public Stroke getRangeZeroBaselineStroke() {\n        return this.rangeZeroBaselineStroke;\n    }\n\n    \n    public void setRangeZeroBaselineStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");\n        }\n        this.rangeZeroBaselineStroke = stroke;\n        fireChangeEvent();\n    }\n\n    \n    public Paint getRangeZeroBaselinePaint() {\n        return this.rangeZeroBaselinePaint;\n    }\n\n    \n    public void setRangeZeroBaselinePaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.rangeZeroBaselinePaint = paint;\n        fireChangeEvent();\n    }\n\n    \n    public Paint getDomainTickBandPaint() {\n        return this.domainTickBandPaint;\n    }\n\n    \n    public void setDomainTickBandPaint(Paint paint) {\n        this.domainTickBandPaint = paint;\n        fireChangeEvent();\n    }\n\n    \n    public Paint getRangeTickBandPaint() {\n        return this.rangeTickBandPaint;\n    }\n\n    \n    public void setRangeTickBandPaint(Paint paint) {\n        this.rangeTickBandPaint = paint;\n        fireChangeEvent();\n    }\n\n    \n    public Point2D getQuadrantOrigin() {\n        return this.quadrantOrigin;\n    }\n\n    \n    public void setQuadrantOrigin(Point2D origin) {\n        if (origin == null) {\n            throw new IllegalArgumentException(\"Null 'origin' argument.\");\n        }\n        this.quadrantOrigin = origin;\n        fireChangeEvent();\n    }\n\n    \n    public Paint getQuadrantPaint(int index) {\n        if (index < 0 || index > 3) {\n            throw new IllegalArgumentException(\"The index value (\" + index \n                    + \") should be in the range 0 to 3.\");\n        }\n        return this.quadrantPaint[index];\n    }\n\n    \n    public void setQuadrantPaint(int index, Paint paint) {\n        if (index < 0 || index > 3) {\n            throw new IllegalArgumentException(\"The index value (\" + index \n                    + \") should be in the range 0 to 3.\");\n        }\n        this.quadrantPaint[index] = paint;\n        fireChangeEvent();\n    }\n\n    \n    public void addDomainMarker(Marker marker) {\n        \n        addDomainMarker(marker, Layer.FOREGROUND);\n    }\n\n    \n    public void addDomainMarker(Marker marker, Layer layer) {\n        addDomainMarker(0, marker, layer);\n    }\n\n    \n    public void clearDomainMarkers() {\n        if (this.backgroundDomainMarkers != null) {\n            Set keys = this.backgroundDomainMarkers.keySet();\n            Iterator iterator = keys.iterator();\n            while (iterator.hasNext()) {\n                Integer key = (Integer) iterator.next();\n                clearDomainMarkers(key.intValue());\n            }\n            this.backgroundDomainMarkers.clear();\n        }\n        if (this.foregroundDomainMarkers != null) {\n            Set keys = this.foregroundDomainMarkers.keySet();\n            Iterator iterator = keys.iterator();\n            while (iterator.hasNext()) {\n                Integer key = (Integer) iterator.next();\n                clearDomainMarkers(key.intValue());\n            }\n            this.foregroundDomainMarkers.clear();\n        }\n        fireChangeEvent();\n    }\n\n    \n    public void clearDomainMarkers(int index) {\n        Integer key = new Integer(index);\n        if (this.backgroundDomainMarkers != null) {\n            Collection markers\n                = (Collection) this.backgroundDomainMarkers.get(key);\n            if (markers != null) {\n                Iterator iterator = markers.iterator();\n                while (iterator.hasNext()) {\n                    Marker m = (Marker) iterator.next();\n                    m.removeChangeListener(this);\n                }\n                markers.clear();\n            }\n        }\n        if (this.foregroundRangeMarkers != null) {\n            Collection markers\n                = (Collection) this.foregroundDomainMarkers.get(key);\n            if (markers != null) {\n                Iterator iterator = markers.iterator();\n                while (iterator.hasNext()) {\n                    Marker m = (Marker) iterator.next();\n                    m.removeChangeListener(this);\n                }\n                markers.clear();\n            }\n        }\n        fireChangeEvent();\n    }\n\n    \n    public void addDomainMarker(int index, Marker marker, Layer layer) {\n    \taddDomainMarker(index, marker, layer, true);\n    }\n\n    \n    public void addDomainMarker(int index, Marker marker, Layer layer, boolean notify) {\n        if (marker == null) {\n            throw new IllegalArgumentException(\"Null 'marker' not permitted.\");\n        }\n        if (layer == null) {\n            throw new IllegalArgumentException(\"Null 'layer' not permitted.\");\n        }\n        Collection markers;\n        if (layer == Layer.FOREGROUND) {\n            markers = (Collection) this.foregroundDomainMarkers.get(\n                    new Integer(index));\n            if (markers == null) {\n                markers = new java.util.ArrayList();\n                this.foregroundDomainMarkers.put(new Integer(index), markers);\n            }\n            markers.add(marker);\n        }\n        else if (layer == Layer.BACKGROUND) {\n            markers = (Collection) this.backgroundDomainMarkers.get(\n                    new Integer(index));\n            if (markers == null) {\n                markers = new java.util.ArrayList();\n                this.backgroundDomainMarkers.put(new Integer(index), markers);\n            }\n            markers.add(marker);\n        }\n        marker.addChangeListener(this);\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    \n    public boolean removeDomainMarker(Marker marker) {\n        return removeDomainMarker(marker, Layer.FOREGROUND);\n    }\n\n    \n    public boolean removeDomainMarker(Marker marker, Layer layer) {\n        return removeDomainMarker(0, marker, layer);\n    }\n\n    \n    public boolean removeDomainMarker(int index, Marker marker, Layer layer) {\n    \treturn removeDomainMarker(index, marker, layer, true);\n    }\n\n    \n    public boolean removeDomainMarker(int index, Marker marker, Layer layer, boolean notify) {\n        ArrayList markers;\n        if (layer == Layer.FOREGROUND) {\n            markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer(\n                    index));\n        }\n        else {\n            markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                    index));\n        }\n        if (markers == null) {\n            return false;\n        }\n        boolean removed = markers.remove(marker);\n        if (removed && notify) {\n            fireChangeEvent();\n        }\n        return removed;\n    }\n    \n    \n    public void addRangeMarker(Marker marker) {\n        addRangeMarker(marker, Layer.FOREGROUND);\n    }\n\n    \n    public void addRangeMarker(Marker marker, Layer layer) {\n        addRangeMarker(0, marker, layer);\n    }\n\n    \n    public void clearRangeMarkers() {\n        if (this.backgroundRangeMarkers != null) {\n            Set keys = this.backgroundRangeMarkers.keySet();\n            Iterator iterator = keys.iterator();\n            while (iterator.hasNext()) {\n                Integer key = (Integer) iterator.next();\n                clearRangeMarkers(key.intValue());\n            }\n            this.backgroundRangeMarkers.clear();\n        }\n        if (this.foregroundRangeMarkers != null) {\n            Set keys = this.foregroundRangeMarkers.keySet();\n            Iterator iterator = keys.iterator();\n            while (iterator.hasNext()) {\n                Integer key = (Integer) iterator.next();\n                clearRangeMarkers(key.intValue());\n            }\n            this.foregroundRangeMarkers.clear();\n        }\n        fireChangeEvent();\n    }\n\n    \n    public void addRangeMarker(int index, Marker marker, Layer layer) {\n    \taddRangeMarker(index, marker, layer, true);\n    }\n    \n    \n    public void addRangeMarker(int index, Marker marker, Layer layer, boolean notify) {\n        Collection markers;\n        if (layer == Layer.FOREGROUND) {\n            markers = (Collection) this.foregroundRangeMarkers.get(\n                    new Integer(index));\n            if (markers == null) {\n                markers = new java.util.ArrayList();\n                this.foregroundRangeMarkers.put(new Integer(index), markers);\n            }\n            markers.add(marker);\n        }\n        else if (layer == Layer.BACKGROUND) {\n            markers = (Collection) this.backgroundRangeMarkers.get(\n                    new Integer(index));\n            if (markers == null) {\n                markers = new java.util.ArrayList();\n                this.backgroundRangeMarkers.put(new Integer(index), markers);\n            }\n            markers.add(marker);\n        }\n        marker.addChangeListener(this);\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    \n    public void clearRangeMarkers(int index) {\n        Integer key = new Integer(index);\n        if (this.backgroundRangeMarkers != null) {\n            Collection markers\n                = (Collection) this.backgroundRangeMarkers.get(key);\n            if (markers != null) {\n                Iterator iterator = markers.iterator();\n                while (iterator.hasNext()) {\n                    Marker m = (Marker) iterator.next();\n                    m.removeChangeListener(this);\n                }\n                markers.clear();\n            }\n        }\n        if (this.foregroundRangeMarkers != null) {\n            Collection markers\n                = (Collection) this.foregroundRangeMarkers.get(key);\n            if (markers != null) {\n                Iterator iterator = markers.iterator();\n                while (iterator.hasNext()) {\n                    Marker m = (Marker) iterator.next();\n                    m.removeChangeListener(this);\n                }\n                markers.clear();\n            }\n        }\n        fireChangeEvent();\n    }\n\n    \n    public boolean removeRangeMarker(Marker marker) {\n        return removeRangeMarker(marker, Layer.FOREGROUND);\n    }\n\n    \n    public boolean removeRangeMarker(Marker marker, Layer layer) {\n        return removeRangeMarker(0, marker, layer);\n    }\n\n    \n    public boolean removeRangeMarker(int index, Marker marker, Layer layer) {\n    \treturn removeRangeMarker(index, marker, layer, true);\n    }\n    \n    \n    public boolean removeRangeMarker(int index, Marker marker, Layer layer, boolean notify) {\n        if (marker == null) {\n            throw new IllegalArgumentException(\"Null 'marker' argument.\");\n        }\n        ArrayList markers;\n        if (layer == Layer.FOREGROUND) {\n            markers = (ArrayList) this.foregroundRangeMarkers.get(new Integer(\n                    index));\n        }\n        else {\n            markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(\n                    index));\n        }\n        if (markers == null) {\n            return false;\n        }\n        boolean removed = markers.remove(marker);\n        if (removed && notify) {\n            fireChangeEvent();\n        }\n        return removed;\n    }\n\n    \n    public void addAnnotation(XYAnnotation annotation) {\n        addAnnotation(annotation, true);\t\n    }\n    \n    \n    public void addAnnotation(XYAnnotation annotation, boolean notify) {\n        if (annotation == null) {\n            throw new IllegalArgumentException(\"Null 'annotation' argument.\");\n        }\n        this.annotations.add(annotation);\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    \n    public boolean removeAnnotation(XYAnnotation annotation) {\n    \treturn removeAnnotation(annotation, true);\n    }\n\n    \n    public boolean removeAnnotation(XYAnnotation annotation, boolean notify) {\n        if (annotation == null) {\n            throw new IllegalArgumentException(\"Null 'annotation' argument.\");\n        }\n        boolean removed = this.annotations.remove(annotation);\n        if (removed && notify) {\n            fireChangeEvent();\n        }\n        return removed;\n    }\n\n    \n    public List getAnnotations() {\n        return new ArrayList(this.annotations);\n    }\n\n    \n    public void clearAnnotations() {\n        this.annotations.clear();\n        fireChangeEvent();\n    }\n    \n    \n    protected AxisSpace calculateAxisSpace(Graphics2D g2, Rectangle2D plotArea) {\n        AxisSpace space = new AxisSpace();\n        space = calculateDomainAxisSpace(g2, plotArea, space);\n        space = calculateRangeAxisSpace(g2, plotArea, space);\n        return space;\n    }\n\n    \n    protected AxisSpace calculateDomainAxisSpace(Graphics2D g2, Rectangle2D plotArea, AxisSpace space) {\n\n        if (space == null) {\n            space = new AxisSpace();\n        }\n\n        \n        if (this.fixedDomainAxisSpace != null) {\n            if (this.orientation == PlotOrientation.HORIZONTAL) {\n                space.ensureAtLeast(this.fixedDomainAxisSpace.getLeft(), \n                        RectangleEdge.LEFT);\n                space.ensureAtLeast(this.fixedDomainAxisSpace.getRight(), \n                        RectangleEdge.RIGHT);\n            }\n            else if (this.orientation == PlotOrientation.VERTICAL) {\n                space.ensureAtLeast(this.fixedDomainAxisSpace.getTop(), \n                        RectangleEdge.TOP);\n                space.ensureAtLeast(this.fixedDomainAxisSpace.getBottom(), \n                        RectangleEdge.BOTTOM);\n            }\n        }\n        else {\n            \n            for (int i = 0; i < this.domainAxes.size(); i++) {\n                Axis axis = (Axis) this.domainAxes.get(i);\n                if (axis != null) {\n                    RectangleEdge edge = getDomainAxisEdge(i);\n                    space = axis.reserveSpace(g2, this, plotArea, edge, space);\n                }\n            }\n        }\n\n        return space;\n\n    }\n\n    \n    protected AxisSpace calculateRangeAxisSpace(Graphics2D g2, Rectangle2D plotArea, AxisSpace space) {\n\n        if (space == null) {\n            space = new AxisSpace();\n        }\n\n        \n        if (this.fixedRangeAxisSpace != null) {\n            if (this.orientation == PlotOrientation.HORIZONTAL) {\n                space.ensureAtLeast(this.fixedRangeAxisSpace.getTop(), \n                        RectangleEdge.TOP);\n                space.ensureAtLeast(this.fixedRangeAxisSpace.getBottom(), \n                        RectangleEdge.BOTTOM);\n            }\n            else if (this.orientation == PlotOrientation.VERTICAL) {\n                space.ensureAtLeast(this.fixedRangeAxisSpace.getLeft(), \n                        RectangleEdge.LEFT);\n                space.ensureAtLeast(this.fixedRangeAxisSpace.getRight(), \n                        RectangleEdge.RIGHT);\n            }\n        }\n        else {\n            \n            for (int i = 0; i < this.rangeAxes.size(); i++) {\n                Axis axis = (Axis) this.rangeAxes.get(i);\n                if (axis != null) {\n                    RectangleEdge edge = getRangeAxisEdge(i);\n                    space = axis.reserveSpace(g2, this, plotArea, edge, space);\n                }\n            }\n        }\n        return space;\n\n    }\n\n    \n    public void draw(Graphics2D g2, Rectangle2D area, Point2D anchor, PlotState parentState, PlotRenderingInfo info) {\n\n        \n        boolean b1 = (area.getWidth() <= MINIMUM_WIDTH_TO_DRAW);\n        boolean b2 = (area.getHeight() <= MINIMUM_HEIGHT_TO_DRAW);\n        if (b1 || b2) {\n            return;\n        }\n\n        \n        if (info != null) {\n            info.setPlotArea(area);\n        }\n\n        \n        RectangleInsets insets = getInsets();\n        insets.trim(area);\n\n        AxisSpace space = calculateAxisSpace(g2, area);\n        Rectangle2D dataArea = space.shrink(area, null);\n        this.axisOffset.trim(dataArea);\n\n        if (info != null) {\n            info.setDataArea(dataArea);\n        }\n\n        \n        drawBackground(g2, dataArea);\n        Map axisStateMap = drawAxes(g2, area, dataArea, info);\n\n        PlotOrientation orient = getOrientation();\n\n        \n        \n        if (anchor != null && !dataArea.contains(anchor)) {\n            anchor = null;\n        }\n        CrosshairState crosshairState = new CrosshairState();\n        crosshairState.setCrosshairDistance(Double.POSITIVE_INFINITY);\n        crosshairState.setAnchor(anchor);\n        \n        crosshairState.setAnchorX(Double.NaN);\n        crosshairState.setAnchorY(Double.NaN);            \n        if (anchor != null) {\n            ValueAxis domainAxis = getDomainAxis();\n            if (domainAxis != null) {\n                double x;\n                if (orient == PlotOrientation.VERTICAL) {\n                    x = domainAxis.java2DToValue(anchor.getX(), dataArea, \n                            getDomainAxisEdge());\n                } \n                else {\n                    x = domainAxis.java2DToValue(anchor.getY(), dataArea, \n                            getDomainAxisEdge());\n                }\n                crosshairState.setAnchorX(x);\n            }\n            ValueAxis rangeAxis = getRangeAxis();\n            if (rangeAxis != null) {\n                double y;\n                if (orient == PlotOrientation.VERTICAL) {\n                    y = rangeAxis.java2DToValue(anchor.getY(), dataArea, \n                            getRangeAxisEdge());\n                } \n                else {\n                    y = rangeAxis.java2DToValue(anchor.getX(), dataArea, \n                            getRangeAxisEdge());\n                }\n                crosshairState.setAnchorY(y);                \n            }\n        }\n        crosshairState.setCrosshairX(getDomainCrosshairValue());\n        crosshairState.setCrosshairY(getRangeCrosshairValue());\n        Shape originalClip = g2.getClip();\n        Composite originalComposite = g2.getComposite();\n\n        g2.clip(dataArea);\n        g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, \n                getForegroundAlpha()));\n\n        AxisState domainAxisState = (AxisState) axisStateMap.get(\n                getDomainAxis());\n        if (domainAxisState == null) {\n            if (parentState != null) {\n                domainAxisState = (AxisState) parentState.getSharedAxisStates()\n                        .get(getDomainAxis());\n            }\n        }\n\n        AxisState rangeAxisState = (AxisState) axisStateMap.get(getRangeAxis());\n        if (rangeAxisState == null) {\n            if (parentState != null) {\n                rangeAxisState = (AxisState) parentState.getSharedAxisStates()\n                        .get(getRangeAxis());\n            }\n        }\n        if (domainAxisState != null) {\n            drawDomainTickBands(g2, dataArea, domainAxisState.getTicks());\n        }\n        if (rangeAxisState != null) {\n            drawRangeTickBands(g2, dataArea, rangeAxisState.getTicks());\n        }\n        if (domainAxisState != null) {\n            drawDomainGridlines(g2, dataArea, domainAxisState.getTicks());\n            drawZeroDomainBaseline(g2, dataArea);\n        }\n        if (rangeAxisState != null) {\n            drawRangeGridlines(g2, dataArea, rangeAxisState.getTicks());\n            drawZeroRangeBaseline(g2, dataArea);\n        }\n\n        \n        for (int i = 0; i < this.renderers.size(); i++) {\n            drawDomainMarkers(g2, dataArea, i, Layer.BACKGROUND);\n        }\n        for (int i = 0; i < this.renderers.size(); i++) {\n            drawRangeMarkers(g2, dataArea, i, Layer.BACKGROUND);\n        }\n\n        \n        boolean foundData = false;\n        DatasetRenderingOrder order = getDatasetRenderingOrder();\n        if (order == DatasetRenderingOrder.FORWARD) {\n\n            \n            int rendererCount = this.renderers.size();\n            for (int i = 0; i < rendererCount; i++) {\n                XYItemRenderer r = getRenderer(i);\n                if (r != null) {\n                    ValueAxis domainAxis = getDomainAxisForDataset(i);\n                    ValueAxis rangeAxis = getRangeAxisForDataset(i);\n                    r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis,\n                            Layer.BACKGROUND, info);\n                }\n            }\n\n            \n            for (int i = 0; i < getDatasetCount(); i++) {\n                foundData = render(g2, dataArea, i, info, crosshairState)\n                    || foundData;\n            }\n\n            \n            for (int i = 0; i < rendererCount; i++) {\n                XYItemRenderer r = getRenderer(i);\n                if (r != null) {\n                    ValueAxis domainAxis = getDomainAxisForDataset(i);\n                    ValueAxis rangeAxis = getRangeAxisForDataset(i);\n                    r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis,\n                            Layer.FOREGROUND, info);\n                }\n            }\n\n        }\n        else if (order == DatasetRenderingOrder.REVERSE) {\n\n            \n            int rendererCount = this.renderers.size();\n            for (int i = rendererCount - 1; i >= 0; i--) {\n                XYItemRenderer r = getRenderer(i);\n                if (i >= getDatasetCount()) { \n                    continue;                 \n                }\n                if (r != null) {\n                    ValueAxis domainAxis = getDomainAxisForDataset(i);\n                    ValueAxis rangeAxis = getRangeAxisForDataset(i);\n                    r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis,\n                            Layer.BACKGROUND, info);\n                }\n            }\n\n            for (int i = getDatasetCount() - 1; i >= 0; i--) {\n                foundData = render(g2, dataArea, i, info, crosshairState)\n                    || foundData;\n            }\n\n            \n            for (int i = rendererCount - 1; i >= 0; i--) {\n                XYItemRenderer r = getRenderer(i);\n                if (i >= getDatasetCount()) { \n                    continue;                 \n                }\n                if (r != null) {\n                    ValueAxis domainAxis = getDomainAxisForDataset(i);\n                    ValueAxis rangeAxis = getRangeAxisForDataset(i);\n                    r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis,\n                            Layer.FOREGROUND, info);\n                }\n            }\n\n        }\n\n        \n        int xAxisIndex = crosshairState.getDomainAxisIndex();\n        ValueAxis xAxis = getDomainAxis(xAxisIndex);\n        RectangleEdge xAxisEdge = getDomainAxisEdge(xAxisIndex);\n        if (!this.domainCrosshairLockedOnData && anchor != null) {\n            double xx;\n            if (orient == PlotOrientation.VERTICAL) {\n                xx = xAxis.java2DToValue(anchor.getX(), dataArea, xAxisEdge);\n            } \n            else {\n                xx = xAxis.java2DToValue(anchor.getY(), dataArea, xAxisEdge);\n            }\n            crosshairState.setCrosshairX(xx);\n        }\n        setDomainCrosshairValue(crosshairState.getCrosshairX(), false);\n        if (isDomainCrosshairVisible()) {\n            double x = getDomainCrosshairValue();\n            Paint paint = getDomainCrosshairPaint();\n            Stroke stroke = getDomainCrosshairStroke();\n            drawDomainCrosshair(g2, dataArea, orient, x, xAxis, stroke, paint);\n        }\n\n        \n        int yAxisIndex = crosshairState.getRangeAxisIndex();\n        ValueAxis yAxis = getRangeAxis(yAxisIndex);\n        RectangleEdge yAxisEdge = getRangeAxisEdge(yAxisIndex);\n        if (!this.rangeCrosshairLockedOnData && anchor != null) {\n            double yy;\n            if (orient == PlotOrientation.VERTICAL) {\n                yy = yAxis.java2DToValue(anchor.getY(), dataArea, yAxisEdge);\n            } else {\n                yy = yAxis.java2DToValue(anchor.getX(), dataArea, yAxisEdge);\n            }\n            crosshairState.setCrosshairY(yy);\n        }\n        setRangeCrosshairValue(crosshairState.getCrosshairY(), false);\n        if (isRangeCrosshairVisible()) {\n            double y = getRangeCrosshairValue();\n            Paint paint = getRangeCrosshairPaint();\n            Stroke stroke = getRangeCrosshairStroke();\n            drawRangeCrosshair(g2, dataArea, orient, y, yAxis, stroke, paint);\n        }\n\n        if (!foundData) {\n            drawNoDataMessage(g2, dataArea);\n        }\n\n        for (int i = 0; i < this.renderers.size(); i++) {\n            drawDomainMarkers(g2, dataArea, i, Layer.FOREGROUND);\n        }\n        for (int i = 0; i < this.renderers.size(); i++) {\n            drawRangeMarkers(g2, dataArea, i, Layer.FOREGROUND);\n        }\n\n        drawAnnotations(g2, dataArea, info);\n        g2.setClip(originalClip);\n        g2.setComposite(originalComposite);\n\n        drawOutline(g2, dataArea);\n\n    }\n\n    \n    public void drawBackground(Graphics2D g2, Rectangle2D area) {\n        fillBackground(g2, area, this.orientation);\n        drawQuadrants(g2, area);\n        drawBackgroundImage(g2, area);\n    }\n\n    \n    protected void drawQuadrants(Graphics2D g2, Rectangle2D area) {\n        \n        \n        \n        boolean somethingToDraw = false;\n\n        ValueAxis xAxis = getDomainAxis();\n        double x = xAxis.getRange().constrain(this.quadrantOrigin.getX());\n        double xx = xAxis.valueToJava2D(x, area, getDomainAxisEdge());\n\n        ValueAxis yAxis = getRangeAxis();\n        double y = yAxis.getRange().constrain(this.quadrantOrigin.getY());\n        double yy = yAxis.valueToJava2D(y, area, getRangeAxisEdge());\n\n        double xmin = xAxis.getLowerBound();\n        double xxmin = xAxis.valueToJava2D(xmin, area, getDomainAxisEdge());\n\n        double xmax = xAxis.getUpperBound();\n        double xxmax = xAxis.valueToJava2D(xmax, area, getDomainAxisEdge());\n\n        double ymin = yAxis.getLowerBound();\n        double yymin = yAxis.valueToJava2D(ymin, area, getRangeAxisEdge());\n\n        double ymax = yAxis.getUpperBound();\n        double yymax = yAxis.valueToJava2D(ymax, area, getRangeAxisEdge());\n\n        Rectangle2D[] r = new Rectangle2D[] {null, null, null, null};\n        if (this.quadrantPaint[0] != null) {\n            if (x > xmin && y < ymax) {\n                if (this.orientation == PlotOrientation.HORIZONTAL) {\n                    r[0] = new Rectangle2D.Double(Math.min(yymax, yy), \n                            Math.min(xxmin, xx), Math.abs(yy - yymax), \n                            Math.abs(xx - xxmin)\n                    );\n                }\n                else {  \n                    r[0] = new Rectangle2D.Double(Math.min(xxmin, xx), \n                            Math.min(yymax, yy), Math.abs(xx - xxmin), \n                            Math.abs(yy - yymax));\n                }\n                somethingToDraw = true;\n            }\n        }\n        if (this.quadrantPaint[1] != null) {\n            if (x < xmax && y < ymax) {\n                if (this.orientation == PlotOrientation.HORIZONTAL) {\n                    r[1] = new Rectangle2D.Double(Math.min(yymax, yy), \n                            Math.min(xxmax, xx), Math.abs(yy - yymax), \n                            Math.abs(xx - xxmax));\n                }\n                else {  \n                    r[1] = new Rectangle2D.Double(Math.min(xx, xxmax), \n                            Math.min(yymax, yy), Math.abs(xx - xxmax), \n                            Math.abs(yy - yymax));\n                }\n                somethingToDraw = true;\n            }\n        }\n        if (this.quadrantPaint[2] != null) {\n            if (x > xmin && y > ymin) {\n                if (this.orientation == PlotOrientation.HORIZONTAL) {\n                    r[2] = new Rectangle2D.Double(Math.min(yymin, yy), \n                            Math.min(xxmin, xx), Math.abs(yy - yymin), \n                            Math.abs(xx - xxmin));\n                }\n                else {  \n                    r[2] = new Rectangle2D.Double(Math.min(xxmin, xx), \n                            Math.min(yymin, yy), Math.abs(xx - xxmin), \n                            Math.abs(yy - yymin));\n                }\n                somethingToDraw = true;\n            }\n        }\n        if (this.quadrantPaint[3] != null) {\n            if (x < xmax && y > ymin) {\n                if (this.orientation == PlotOrientation.HORIZONTAL) {\n                    r[3] = new Rectangle2D.Double(Math.min(yymin, yy), \n                            Math.min(xxmax, xx), Math.abs(yy - yymin), \n                            Math.abs(xx - xxmax));\n                }\n                else {  \n                    r[3] = new Rectangle2D.Double(Math.min(xx, xxmax), \n                            Math.min(yymin, yy), Math.abs(xx - xxmax), \n                            Math.abs(yy - yymin));\n                }\n                somethingToDraw = true;\n            }\n        }\n        if (somethingToDraw) {\n            Composite originalComposite = g2.getComposite();\n            g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER,\n                    getBackgroundAlpha()));\n            for (int i = 0; i < 4; i++) {\n                if (this.quadrantPaint[i] != null && r[i] != null) {\n                    g2.setPaint(this.quadrantPaint[i]);\n                    g2.fill(r[i]);\n                }\n            }\n            g2.setComposite(originalComposite);\n        }\n    }\n\n    \n    public void drawDomainTickBands(Graphics2D g2, Rectangle2D dataArea, List ticks) {\n        Paint bandPaint = getDomainTickBandPaint();\n        if (bandPaint != null) {\n            boolean fillBand = false;\n            ValueAxis xAxis = getDomainAxis();\n            double previous = xAxis.getLowerBound();\n            Iterator iterator = ticks.iterator();\n            while (iterator.hasNext()) {\n                ValueTick tick = (ValueTick) iterator.next();\n                double current = tick.getValue();\n                if (fillBand) {\n                    getRenderer().fillDomainGridBand(g2, this, xAxis, dataArea,\n                            previous, current);\n                }\n                previous = current;\n                fillBand = !fillBand;\n            }\n            double end = xAxis.getUpperBound();\n            if (fillBand) {\n                getRenderer().fillDomainGridBand(g2, this, xAxis, dataArea, \n                        previous, end);\n            }\n        }\n    }\n\n    \n    public void drawRangeTickBands(Graphics2D g2, Rectangle2D dataArea, List ticks) {\n        Paint bandPaint = getRangeTickBandPaint();\n        if (bandPaint != null) {\n            boolean fillBand = false;\n            ValueAxis axis = getRangeAxis();\n            double previous = axis.getLowerBound();\n            Iterator iterator = ticks.iterator();\n            while (iterator.hasNext()) {\n                ValueTick tick = (ValueTick) iterator.next();\n                double current = tick.getValue();\n                if (fillBand) {\n                    getRenderer().fillRangeGridBand(g2, this, axis, dataArea, \n                            previous, current);\n                }\n                previous = current;\n                fillBand = !fillBand;\n            }\n            double end = axis.getUpperBound();\n            if (fillBand) {\n                getRenderer().fillRangeGridBand(g2, this, axis, dataArea, \n                        previous, end);\n            }\n        }\n    }\n\n    \n    protected Map drawAxes(Graphics2D g2, Rectangle2D plotArea, Rectangle2D dataArea, PlotRenderingInfo plotState) {\n\n        AxisCollection axisCollection = new AxisCollection();\n\n        \n        for (int index = 0; index < this.domainAxes.size(); index++) {\n            ValueAxis axis = (ValueAxis) this.domainAxes.get(index);\n            if (axis != null) {\n                axisCollection.add(axis, getDomainAxisEdge(index));\n            }\n        }\n\n        \n        for (int index = 0; index < this.rangeAxes.size(); index++) {\n            ValueAxis yAxis = (ValueAxis) this.rangeAxes.get(index);\n            if (yAxis != null) {\n                axisCollection.add(yAxis, getRangeAxisEdge(index));\n            }\n        }\n\n        Map axisStateMap = new HashMap();\n\n        \n        double cursor = dataArea.getMinY() - this.axisOffset.calculateTopOutset(\n                dataArea.getHeight());\n        Iterator iterator = axisCollection.getAxesAtTop().iterator();\n        while (iterator.hasNext()) {\n            ValueAxis axis = (ValueAxis) iterator.next();\n            AxisState info = axis.draw(g2, cursor, plotArea, dataArea, \n                    RectangleEdge.TOP, plotState);\n            cursor = info.getCursor();\n            axisStateMap.put(axis, info);\n        }\n\n        \n        cursor = dataArea.getMaxY()\n                 + this.axisOffset.calculateBottomOutset(dataArea.getHeight());\n        iterator = axisCollection.getAxesAtBottom().iterator();\n        while (iterator.hasNext()) {\n            ValueAxis axis = (ValueAxis) iterator.next();\n            AxisState info = axis.draw(g2, cursor, plotArea, dataArea, \n                    RectangleEdge.BOTTOM, plotState);\n            cursor = info.getCursor();\n            axisStateMap.put(axis, info);\n        }\n\n        \n        cursor = dataArea.getMinX()\n                 - this.axisOffset.calculateLeftOutset(dataArea.getWidth());\n        iterator = axisCollection.getAxesAtLeft().iterator();\n        while (iterator.hasNext()) {\n            ValueAxis axis = (ValueAxis) iterator.next();\n            AxisState info = axis.draw(g2, cursor, plotArea, dataArea, \n                    RectangleEdge.LEFT, plotState);\n            cursor = info.getCursor();\n            axisStateMap.put(axis, info);\n        }\n\n        \n        cursor = dataArea.getMaxX()\n                 + this.axisOffset.calculateRightOutset(dataArea.getWidth());\n        iterator = axisCollection.getAxesAtRight().iterator();\n        while (iterator.hasNext()) {\n            ValueAxis axis = (ValueAxis) iterator.next();\n            AxisState info = axis.draw(g2, cursor, plotArea, dataArea, \n                    RectangleEdge.RIGHT, plotState);\n            cursor = info.getCursor();\n            axisStateMap.put(axis, info);\n        }\n\n        return axisStateMap;\n    }\n\n    \n    public boolean render(Graphics2D g2, Rectangle2D dataArea, int index, PlotRenderingInfo info, CrosshairState crosshairState) {\n\n        boolean foundData = false;\n        XYDataset dataset = getDataset(index);\n        if (!DatasetUtilities.isEmptyOrNull(dataset)) {\n            foundData = true;\n            ValueAxis xAxis = getDomainAxisForDataset(index);\n            ValueAxis yAxis = getRangeAxisForDataset(index);\n            XYItemRenderer renderer = getRenderer(index);\n            if (renderer == null) {\n                renderer = getRenderer();\n                if (renderer == null) { \n                    return foundData;\n                }\n            }\n\n            XYItemRendererState state = renderer.initialise(g2, dataArea, this,\n                    dataset, info);\n            int passCount = renderer.getPassCount();\n\n            SeriesRenderingOrder seriesOrder = getSeriesRenderingOrder();\n            if (seriesOrder == SeriesRenderingOrder.REVERSE) {\n                \n                for (int pass = 0; pass < passCount; pass++) {\n                    int seriesCount = dataset.getSeriesCount();\n                    for (int series = seriesCount - 1; series >= 0; series--) {\n                        int firstItem = 0;\n                        int lastItem = dataset.getItemCount(series) - 1;\n                        if (lastItem == -1) {\n                            continue;\n                        }\n                        if (state.getProcessVisibleItemsOnly()) {\n                            int[] itemBounds = RendererUtilities.findLiveItems(\n                                    dataset, series, xAxis.getLowerBound(), \n                                    xAxis.getUpperBound());\n                            firstItem = itemBounds[0];\n                            lastItem = itemBounds[1];\n                        }\n                        for (int item = firstItem; item <= lastItem; item++) {\n                            renderer.drawItem(g2, state, dataArea, info,\n                                    this, xAxis, yAxis, dataset, series, item,\n                                    crosshairState, pass);\n                        }\n                    }\n                }\n            }\n            else {\n                \n                for (int pass = 0; pass < passCount; pass++) {\n                    int seriesCount = dataset.getSeriesCount();\n                    for (int series = 0; series < seriesCount; series++) {\n                        int firstItem = 0;\n                        int lastItem = dataset.getItemCount(series) - 1;\n                        if (state.getProcessVisibleItemsOnly()) {\n                            int[] itemBounds = RendererUtilities.findLiveItems(\n                                    dataset, series, xAxis.getLowerBound(), \n                                    xAxis.getUpperBound());\n                            firstItem = itemBounds[0];\n                            lastItem = itemBounds[1];\n                        }\n                        for (int item = firstItem; item <= lastItem; item++) {\n                            renderer.drawItem(g2, state, dataArea, info,\n                                    this, xAxis, yAxis, dataset, series, item,\n                                    crosshairState, pass);\n                        }\n                    }\n                }\n            }\n        }\n        return foundData;\n    }\n\n    \n    public ValueAxis getDomainAxisForDataset(int index) {\n\n        if (index < 0 || index >= getDatasetCount()) {\n            throw new IllegalArgumentException(\"Index \" + index \n                    + \" out of bounds.\");\n        }\n\n        ValueAxis valueAxis = null;\n        Integer axisIndex = (Integer) this.datasetToDomainAxisMap.get(\n                new Integer(index));\n        if (axisIndex != null) {\n            valueAxis = getDomainAxis(axisIndex.intValue());\n        }\n        else {\n            valueAxis = getDomainAxis(0);\n        }\n        return valueAxis;\n\n    }\n\n    \n    public ValueAxis getRangeAxisForDataset(int index) {\n\n        if (index < 0 || index >= getDatasetCount()) {\n            throw new IllegalArgumentException(\"Index \" + index \n                    + \" out of bounds.\");\n        }\n\n        ValueAxis valueAxis = null;\n        Integer axisIndex\n            = (Integer) this.datasetToRangeAxisMap.get(new Integer(index));\n        if (axisIndex != null) {\n            valueAxis = getRangeAxis(axisIndex.intValue());\n        }\n        else {\n            valueAxis = getRangeAxis(0);\n        }\n        return valueAxis;\n\n    }\n\n    \n    protected void drawDomainGridlines(Graphics2D g2, Rectangle2D dataArea, List ticks) {\n\n        \n        if (getRenderer() == null) {\n            return;\n        }\n\n        \n        if (isDomainGridlinesVisible()) {\n            Stroke gridStroke = getDomainGridlineStroke();\n            Paint gridPaint = getDomainGridlinePaint();\n            Iterator iterator = ticks.iterator();\n            while (iterator.hasNext()) {\n                ValueTick tick = (ValueTick) iterator.next();\n                getRenderer().drawDomainLine(g2, this, getDomainAxis(),\n                        dataArea, tick.getValue(), gridPaint, gridStroke);\n            }\n        }\n    }\n\n    \n    protected void drawRangeGridlines(Graphics2D g2, Rectangle2D area, List ticks) {\n\n        \n        if (getRenderer() == null) {\n            return;\n        }\n\n        \n        if (isRangeGridlinesVisible()) {\n            Stroke gridStroke = getRangeGridlineStroke();\n            Paint gridPaint = getRangeGridlinePaint();\n            ValueAxis axis = getRangeAxis();\n            if (axis != null) {\n                Iterator iterator = ticks.iterator();\n                while (iterator.hasNext()) {\n                    ValueTick tick = (ValueTick) iterator.next();\n                    if (tick.getValue() != 0.0\n                            || !isRangeZeroBaselineVisible()) {\n                        getRenderer().drawRangeLine(g2, this, getRangeAxis(), \n                                area, tick.getValue(), gridPaint, gridStroke);\n                    }\n                }\n            }\n        }\n    }\n\n    \n    protected void drawZeroDomainBaseline(Graphics2D g2, Rectangle2D area) {\n        if (isDomainZeroBaselineVisible()) {\n            XYItemRenderer r = getRenderer();\n            r.drawDomainLine(g2, this, getDomainAxis(), area, 0.0, \n                    this.domainZeroBaselinePaint, \n                    this.domainZeroBaselineStroke);\n        }\n    }\n\n    \n    protected void drawZeroRangeBaseline(Graphics2D g2, Rectangle2D area) {\n        if (isRangeZeroBaselineVisible()) {\n            getRenderer().drawRangeLine(g2, this, getRangeAxis(), area, 0.0, \n                    this.rangeZeroBaselinePaint, this.rangeZeroBaselineStroke);\n        }\n    }\n\n    \n    public void drawAnnotations(Graphics2D g2, Rectangle2D dataArea, PlotRenderingInfo info) {\n\n        Iterator iterator = this.annotations.iterator();\n        while (iterator.hasNext()) {\n            XYAnnotation annotation = (XYAnnotation) iterator.next();\n            ValueAxis xAxis = getDomainAxis();\n            ValueAxis yAxis = getRangeAxis();\n            annotation.draw(g2, this, dataArea, xAxis, yAxis, 0, info);\n        }\n\n    }\n\n    \n    protected void drawDomainMarkers(Graphics2D g2, Rectangle2D dataArea, int index, Layer layer) {\n\n        XYItemRenderer r = getRenderer(index);\n        if (r == null) {\n            return;\n        }\n        \n        \n        if (index >= getDatasetCount()) {\n            return;\n        }    \n        Collection markers = getDomainMarkers(index, layer);\n        ValueAxis axis = getDomainAxisForDataset(index);\n        if (markers != null && axis != null) {\n            Iterator iterator = markers.iterator();\n            while (iterator.hasNext()) {\n                Marker marker = (Marker) iterator.next();\n                r.drawDomainMarker(g2, this, axis, marker, dataArea);\n            }\n        }\n\n    }\n\n    \n    protected void drawRangeMarkers(Graphics2D g2, Rectangle2D dataArea, int index, Layer layer) {\n\n        XYItemRenderer r = getRenderer(index);\n        if (r == null) {\n            return;\n        }\n        \n        \n        if (index >= getDatasetCount()) {\n            return;\n        }\n        Collection markers = getRangeMarkers(index, layer);\n        ValueAxis axis = getRangeAxisForDataset(index);\n        if (markers != null && axis != null) {\n            Iterator iterator = markers.iterator();\n            while (iterator.hasNext()) {\n                Marker marker = (Marker) iterator.next();\n                r.drawRangeMarker(g2, this, axis, marker, dataArea);\n            }\n        }\n    }\n\n    \n    public Collection getDomainMarkers(Layer layer) {\n        return getDomainMarkers(0, layer);\n    }\n\n    \n    public Collection getRangeMarkers(Layer layer) {\n        return getRangeMarkers(0, layer);\n    }\n\n    \n    public Collection getDomainMarkers(int index, Layer layer) {\n        Collection result = null;\n        Integer key = new Integer(index);\n        if (layer == Layer.FOREGROUND) {\n            result = (Collection) this.foregroundDomainMarkers.get(key);\n        }\n        else if (layer == Layer.BACKGROUND) {\n            result = (Collection) this.backgroundDomainMarkers.get(key);\n        }\n        if (result != null) {\n            result = Collections.unmodifiableCollection(result);\n        }\n        return result;\n    }\n\n    \n    public Collection getRangeMarkers(int index, Layer layer) {\n        Collection result = null;\n        Integer key = new Integer(index);\n        if (layer == Layer.FOREGROUND) {\n            result = (Collection) this.foregroundRangeMarkers.get(key);\n        }\n        else if (layer == Layer.BACKGROUND) {\n            result = (Collection) this.backgroundRangeMarkers.get(key);\n        }\n        if (result != null) {\n            result = Collections.unmodifiableCollection(result);\n        }\n        return result;\n    }\n\n    \n    protected void drawHorizontalLine(Graphics2D g2, Rectangle2D dataArea, double value, Stroke stroke, Paint paint) {\n\n        ValueAxis axis = getRangeAxis();\n        if (getOrientation() == PlotOrientation.HORIZONTAL) {\n            axis = getDomainAxis();\n        }\n        if (axis.getRange().contains(value)) {\n            double yy = axis.valueToJava2D(value, dataArea, RectangleEdge.LEFT);\n            Line2D line = new Line2D.Double(dataArea.getMinX(), yy, \n                    dataArea.getMaxX(), yy);\n            g2.setStroke(stroke);\n            g2.setPaint(paint);\n            g2.draw(line);\n        }\n\n    }\n    \n    \n    protected void drawDomainCrosshair(Graphics2D g2, Rectangle2D dataArea, PlotOrientation orientation, double value, ValueAxis axis, Stroke stroke, Paint paint) {\n        \n        if (axis.getRange().contains(value)) {\n            Line2D line = null;\n            if (orientation == PlotOrientation.VERTICAL) {\n                double xx = axis.valueToJava2D(value, dataArea, \n                        RectangleEdge.BOTTOM);\n                line = new Line2D.Double(xx, dataArea.getMinY(), xx, \n                        dataArea.getMaxY());\n            }\n            else {\n                double yy = axis.valueToJava2D(value, dataArea, \n                        RectangleEdge.LEFT);\n                line = new Line2D.Double(dataArea.getMinX(), yy, \n                        dataArea.getMaxX(), yy);\n            }\n            g2.setStroke(stroke);\n            g2.setPaint(paint);\n            g2.draw(line);\n        }\n        \n    }\n\n    \n    protected void drawVerticalLine(Graphics2D g2, Rectangle2D dataArea, double value, Stroke stroke, Paint paint) {\n\n        ValueAxis axis = getDomainAxis();\n        if (getOrientation() == PlotOrientation.HORIZONTAL) {\n            axis = getRangeAxis();\n        }\n        if (axis.getRange().contains(value)) {\n            double xx = axis.valueToJava2D(value, dataArea, \n                    RectangleEdge.BOTTOM);\n            Line2D line = new Line2D.Double(xx, dataArea.getMinY(), xx, \n                    dataArea.getMaxY());\n            g2.setStroke(stroke);\n            g2.setPaint(paint);\n            g2.draw(line);\n        }\n\n    }\n\n    \n    protected void drawRangeCrosshair(Graphics2D g2, Rectangle2D dataArea, PlotOrientation orientation, double value, ValueAxis axis, Stroke stroke, Paint paint) {\n        \n        if (axis.getRange().contains(value)) {\n            Line2D line = null;\n            if (orientation == PlotOrientation.HORIZONTAL) {\n                double xx = axis.valueToJava2D(value, dataArea, \n                        RectangleEdge.BOTTOM);\n                line = new Line2D.Double(xx, dataArea.getMinY(), xx, \n                        dataArea.getMaxY());\n            }\n            else {\n                double yy = axis.valueToJava2D(value, dataArea, \n                        RectangleEdge.LEFT);\n                line = new Line2D.Double(dataArea.getMinX(), yy, \n                        dataArea.getMaxX(), yy);\n            }\n            g2.setStroke(stroke);\n            g2.setPaint(paint);\n            g2.draw(line);\n        }\n        \n    }\n\n    \n    public void handleClick(int x, int y, PlotRenderingInfo info) {\n\n        Rectangle2D dataArea = info.getDataArea();\n        if (dataArea.contains(x, y)) {\n            \n            ValueAxis da = getDomainAxis();\n            if (da != null) {\n                double hvalue = da.java2DToValue(x, info.getDataArea(), \n                        getDomainAxisEdge());\n                setDomainCrosshairValue(hvalue);\n            }\n\n            \n            ValueAxis ra = getRangeAxis();\n            if (ra != null) {\n                double vvalue = ra.java2DToValue(y, info.getDataArea(), \n                        getRangeAxisEdge());\n                setRangeCrosshairValue(vvalue);\n            }\n        }\n    }\n\n    \n    private List getDatasetsMappedToDomainAxis(Integer axisIndex) {\n        if (axisIndex == null) {\n            throw new IllegalArgumentException(\"Null 'axisIndex' argument.\");\n        }\n        List result = new ArrayList();\n        for (int i = 0; i < this.datasets.size(); i++) {\n            Integer mappedAxis = (Integer) this.datasetToDomainAxisMap.get(\n                    new Integer(i));\n            if (mappedAxis == null) {\n                if (axisIndex.equals(ZERO)) {\n                    result.add(this.datasets.get(i));\n                }\n            }\n            else {\n                if (mappedAxis.equals(axisIndex)) {\n                    result.add(this.datasets.get(i));\n                }\n            }\n        }\n        return result;\n    }\n\n    \n    private List getDatasetsMappedToRangeAxis(Integer axisIndex) {\n        if (axisIndex == null) {\n            throw new IllegalArgumentException(\"Null 'axisIndex' argument.\");\n        }\n        List result = new ArrayList();\n        for (int i = 0; i < this.datasets.size(); i++) {\n            Integer mappedAxis = (Integer) this.datasetToRangeAxisMap.get(\n                    new Integer(i));\n            if (mappedAxis == null) {\n                if (axisIndex.equals(ZERO)) {\n                    result.add(this.datasets.get(i));\n                }\n            }\n            else {\n                if (mappedAxis.equals(axisIndex)) {\n                    result.add(this.datasets.get(i));\n                }\n            }\n        }\n        return result;\n    }\n\n    \n    public int getDomainAxisIndex(ValueAxis axis) {\n        int result = this.domainAxes.indexOf(axis);\n        if (result < 0) {\n            \n            Plot parent = getParent();\n            if (parent instanceof XYPlot) {\n                XYPlot p = (XYPlot) parent;\n                result = p.getDomainAxisIndex(axis);\n            }\n        }\n        return result;\n    }\n\n    \n    public int getRangeAxisIndex(ValueAxis axis) {\n        int result = this.rangeAxes.indexOf(axis);\n        if (result < 0) {\n            \n            Plot parent = getParent();\n            if (parent instanceof XYPlot) {\n                XYPlot p = (XYPlot) parent;\n                result = p.getRangeAxisIndex(axis);\n            }\n        }\n        return result;\n    }\n\n    \n    public Range getDataRange(ValueAxis axis) {\n\n        Range result = null;\n        List mappedDatasets = new ArrayList();\n        boolean isDomainAxis = true;\n\n        \n        int domainIndex = getDomainAxisIndex(axis);\n        if (domainIndex >= 0) {\n            isDomainAxis = true;\n            mappedDatasets.addAll(getDatasetsMappedToDomainAxis(\n                    new Integer(domainIndex)));\n        }\n\n        \n        int rangeIndex = getRangeAxisIndex(axis);\n        if (rangeIndex >= 0) {\n            isDomainAxis = false;\n            mappedDatasets.addAll(getDatasetsMappedToRangeAxis(\n                    new Integer(rangeIndex)));\n        }\n\n        \n        \n        Iterator iterator = mappedDatasets.iterator();\n        while (iterator.hasNext()) {\n            XYDataset d = (XYDataset) iterator.next();\n            if (d != null) {\n                XYItemRenderer r = getRendererForDataset(d);\n                if (isDomainAxis) {\n                    if (r != null) {\n                        result = Range.combine(result, r.findDomainBounds(d));\n                    }\n                    else {\n                        result = Range.combine(result, \n                                DatasetUtilities.findDomainBounds(d));\n                    }\n                }\n                else {\n                    if (r != null) {\n                        result = Range.combine(result, r.findRangeBounds(d));\n                    }\n                    else {\n                        result = Range.combine(result, \n                                DatasetUtilities.findRangeBounds(d));\n                    }\n                }\n            }\n        }\n        return result;\n\n    }\n\n    \n    public void datasetChanged(DatasetChangeEvent event) {\n        configureDomainAxes();\n        configureRangeAxes();\n        if (getParent() != null) {\n            getParent().datasetChanged(event);\n        }\n        else {\n            PlotChangeEvent e = new PlotChangeEvent(this);\n            e.setType(ChartChangeEventType.DATASET_UPDATED);\n            notifyListeners(e);\n        }\n    }\n\n    \n    public void rendererChanged(RendererChangeEvent event) {\n        fireChangeEvent();\n    }\n\n    \n    public boolean isDomainCrosshairVisible() {\n        return this.domainCrosshairVisible;\n    }\n\n    \n    public void setDomainCrosshairVisible(boolean flag) {\n        if (this.domainCrosshairVisible != flag) {\n            this.domainCrosshairVisible = flag;\n            fireChangeEvent();\n        }\n    }\n\n    \n    public boolean isDomainCrosshairLockedOnData() {\n        return this.domainCrosshairLockedOnData;\n    }\n\n    \n    public void setDomainCrosshairLockedOnData(boolean flag) {\n        if (this.domainCrosshairLockedOnData != flag) {\n            this.domainCrosshairLockedOnData = flag;\n            fireChangeEvent();\n        }\n    }\n\n    \n    public double getDomainCrosshairValue() {\n        return this.domainCrosshairValue;\n    }\n\n    \n    public void setDomainCrosshairValue(double value) {\n        setDomainCrosshairValue(value, true);\n    }\n\n    \n    public void setDomainCrosshairValue(double value, boolean notify) {\n        this.domainCrosshairValue = value;\n        if (isDomainCrosshairVisible() && notify) {\n            fireChangeEvent();\n        }\n    }\n\n    \n    public Stroke getDomainCrosshairStroke() {\n        return this.domainCrosshairStroke;\n    }\n\n    \n    public void setDomainCrosshairStroke(Stroke stroke) {\n        if (stroke == null) { \n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");\n        }\n        this.domainCrosshairStroke = stroke;\n        fireChangeEvent();\n    }\n\n    \n    public Paint getDomainCrosshairPaint() {\n        return this.domainCrosshairPaint;\n    }\n\n    \n    public void setDomainCrosshairPaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.domainCrosshairPaint = paint;\n        fireChangeEvent();\n    }\n\n    \n    public boolean isRangeCrosshairVisible() {\n        return this.rangeCrosshairVisible;\n    }\n\n    \n    public void setRangeCrosshairVisible(boolean flag) {\n        if (this.rangeCrosshairVisible != flag) {\n            this.rangeCrosshairVisible = flag;\n            fireChangeEvent();\n        }\n    }\n\n    \n    public boolean isRangeCrosshairLockedOnData() {\n        return this.rangeCrosshairLockedOnData;\n    }\n\n    \n    public void setRangeCrosshairLockedOnData(boolean flag) {\n        if (this.rangeCrosshairLockedOnData != flag) {\n            this.rangeCrosshairLockedOnData = flag;\n            fireChangeEvent();\n        }\n    }\n\n    \n    public double getRangeCrosshairValue() {\n        return this.rangeCrosshairValue;\n    }\n\n    \n    public void setRangeCrosshairValue(double value) {\n        setRangeCrosshairValue(value, true);\n    }\n\n    \n    public void setRangeCrosshairValue(double value, boolean notify) {\n        this.rangeCrosshairValue = value;\n        if (isRangeCrosshairVisible() && notify) {\n            fireChangeEvent();\n        }\n    }\n\n    \n    public Stroke getRangeCrosshairStroke() {\n        return this.rangeCrosshairStroke;\n    }\n\n    \n    public void setRangeCrosshairStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");\n        }\n        this.rangeCrosshairStroke = stroke;\n        fireChangeEvent();\n    }\n\n    \n    public Paint getRangeCrosshairPaint() {\n        return this.rangeCrosshairPaint;\n    }\n\n    \n    public void setRangeCrosshairPaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.rangeCrosshairPaint = paint;\n        fireChangeEvent();\n    }\n\n    \n    public AxisSpace getFixedDomainAxisSpace() {\n        return this.fixedDomainAxisSpace;\n    }\n\n    \n    public void setFixedDomainAxisSpace(AxisSpace space) {\n        setFixedDomainAxisSpace(space, true);\n    }\n\n    \n    public void setFixedDomainAxisSpace(AxisSpace space, boolean notify) {\n        this.fixedDomainAxisSpace = space;\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    \n    public AxisSpace getFixedRangeAxisSpace() {\n        return this.fixedRangeAxisSpace;\n    }\n\n    \n    public void setFixedRangeAxisSpace(AxisSpace space) {\n        setFixedRangeAxisSpace(space, true);\n    }\n\n    \n    public void setFixedRangeAxisSpace(AxisSpace space, boolean notify) {\n        this.fixedRangeAxisSpace = space;\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    \n    public void zoomDomainAxes(double factor, PlotRenderingInfo info, Point2D source) {\n        \n        zoomDomainAxes(factor, info, source, false);\n    }\n\n    \n    public void zoomDomainAxes(double factor, PlotRenderingInfo info, Point2D source, boolean useAnchor) {\n                \n        \n        for (int i = 0; i < this.domainAxes.size(); i++) {\n            ValueAxis domainAxis = (ValueAxis) this.domainAxes.get(i);\n            if (domainAxis != null) {\n                if (useAnchor) {\n                    \n                    \n                    double sourceX = source.getX();\n                    if (this.orientation == PlotOrientation.HORIZONTAL) {\n                        sourceX = source.getY();\n                    }\n                    double anchorX = domainAxis.java2DToValue(sourceX, \n                            info.getDataArea(), getDomainAxisEdge());\n                    domainAxis.resizeRange(factor, anchorX);\n                }\n                else {\n                    domainAxis.resizeRange(factor);\n                }\n            }\n        }\n    }\n\n    \n    public void zoomDomainAxes(double lowerPercent, double upperPercent, PlotRenderingInfo info, Point2D source) {\n        for (int i = 0; i < this.domainAxes.size(); i++) {\n            ValueAxis domainAxis = (ValueAxis) this.domainAxes.get(i);\n            if (domainAxis != null) {\n                domainAxis.zoomRange(lowerPercent, upperPercent);\n            }\n        }\n    }\n\n    \n    public void zoomRangeAxes(double factor, PlotRenderingInfo info, Point2D source) {\n        \n        zoomRangeAxes(factor, info, source, false);    \n    }\n    \n    \n    public void zoomRangeAxes(double factor, PlotRenderingInfo info, Point2D source, boolean useAnchor) {\n                \n        \n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis rangeAxis = (ValueAxis) this.rangeAxes.get(i);\n            if (rangeAxis != null) {\n                if (useAnchor) {\n                    \n                    \n                    double sourceY = source.getY();\n                    if (this.orientation == PlotOrientation.HORIZONTAL) {\n                        sourceY = source.getX();\n                    }\n                    double anchorY = rangeAxis.java2DToValue(sourceY, \n                            info.getDataArea(), getRangeAxisEdge());\n                    rangeAxis.resizeRange(factor, anchorY);\n                }\n                else {\n                    rangeAxis.resizeRange(factor);\n                }\n            }\n        }\n    }\n\n    \n    public void zoomRangeAxes(double lowerPercent, double upperPercent, PlotRenderingInfo info, Point2D source) {\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis rangeAxis = (ValueAxis) this.rangeAxes.get(i);\n            if (rangeAxis != null) {\n                rangeAxis.zoomRange(lowerPercent, upperPercent);\n            }\n        }\n    }\n\n    \n    public boolean isDomainZoomable() {\n        return true;\n    }\n\n    \n    public boolean isRangeZoomable() {\n        return true;\n    }\n\n    \n    public int getSeriesCount() {\n        int result = 0;\n        XYDataset dataset = getDataset();\n        if (dataset != null) {\n            result = dataset.getSeriesCount();\n        }\n        return result;\n    }\n\n    \n    public LegendItemCollection getFixedLegendItems() {\n        return this.fixedLegendItems;\n    }\n\n    \n    public void setFixedLegendItems(LegendItemCollection items) {\n        this.fixedLegendItems = items;\n        fireChangeEvent();\n    }\n\n    \n    public LegendItemCollection getLegendItems() {\n        if (this.fixedLegendItems != null) {\n            return this.fixedLegendItems;\n        }\n        LegendItemCollection result = new LegendItemCollection();\n        int count = this.datasets.size();\n        for (int datasetIndex = 0; datasetIndex < count; datasetIndex++) {\n            XYDataset dataset = getDataset(datasetIndex);\n            if (dataset != null) {\n                XYItemRenderer renderer = getRenderer(datasetIndex);\n                if (renderer == null) {\n                    renderer = getRenderer(0);\n                }\n                if (renderer != null) {\n                    int seriesCount = dataset.getSeriesCount();\n                    for (int i = 0; i < seriesCount; i++) {\n                        if (renderer.isSeriesVisible(i)\n                                && renderer.isSeriesVisibleInLegend(i)) {\n                            LegendItem item = renderer.getLegendItem(\n                                    datasetIndex, i);\n                            if (item != null) {\n                                result.add(item);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return result;\n    }\n\n    \n    public boolean equals(Object obj) {\n\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof XYPlot)) {\n            return false;\n        }\n\n        XYPlot that = (XYPlot) obj;\n        if (this.weight != that.weight) {\n            return false;\n        }\n        if (this.orientation != that.orientation) {\n            return false;\n        }\n        if (!this.domainAxes.equals(that.domainAxes)) {\n            return false;\n        }\n        if (!this.domainAxisLocations.equals(that.domainAxisLocations)) {\n            return false;\n        }\n        if (this.rangeCrosshairLockedOnData\n                != that.rangeCrosshairLockedOnData) {\n            return false;\n        }\n        if (this.domainGridlinesVisible != that.domainGridlinesVisible) {\n            return false;\n        }\n        if (this.rangeGridlinesVisible != that.rangeGridlinesVisible) {\n            return false;\n        }\n        if (this.domainZeroBaselineVisible != that.domainZeroBaselineVisible) {\n            return false;\n        }\n        if (this.rangeZeroBaselineVisible != that.rangeZeroBaselineVisible) {\n            return false;\n        }\n        if (this.domainCrosshairVisible != that.domainCrosshairVisible) {\n            return false;\n        }\n        if (this.domainCrosshairValue != that.domainCrosshairValue) {\n            return false;\n        }\n        if (this.domainCrosshairLockedOnData\n                != that.domainCrosshairLockedOnData) {\n            return false;\n        }\n        if (this.rangeCrosshairVisible != that.rangeCrosshairVisible) {\n            return false;\n        }\n        if (this.rangeCrosshairValue != that.rangeCrosshairValue) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.axisOffset, that.axisOffset)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.renderers, that.renderers)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.rangeAxes, that.rangeAxes)) {\n            return false;\n        }\n        if (!this.rangeAxisLocations.equals(that.rangeAxisLocations)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.datasetToDomainAxisMap, \n                that.datasetToDomainAxisMap)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.datasetToRangeAxisMap, \n                that.datasetToRangeAxisMap)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.domainGridlineStroke, \n                that.domainGridlineStroke)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.domainGridlinePaint, \n                that.domainGridlinePaint)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.rangeGridlineStroke, \n                that.rangeGridlineStroke)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.rangeGridlinePaint, \n                that.rangeGridlinePaint)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.domainZeroBaselinePaint, \n                that.domainZeroBaselinePaint)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.domainZeroBaselineStroke, \n                that.domainZeroBaselineStroke)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.rangeZeroBaselinePaint, \n                that.rangeZeroBaselinePaint)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.rangeZeroBaselineStroke, \n                that.rangeZeroBaselineStroke)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.domainCrosshairStroke, \n                that.domainCrosshairStroke)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.domainCrosshairPaint, \n                that.domainCrosshairPaint)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.rangeCrosshairStroke, \n                that.rangeCrosshairStroke)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.rangeCrosshairPaint, \n                that.rangeCrosshairPaint)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.foregroundDomainMarkers, \n                that.foregroundDomainMarkers)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.backgroundDomainMarkers, \n                that.backgroundDomainMarkers)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.foregroundRangeMarkers, \n                that.foregroundRangeMarkers)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.backgroundRangeMarkers, \n                that.backgroundRangeMarkers)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.foregroundDomainMarkers, \n                that.foregroundDomainMarkers)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.backgroundDomainMarkers, \n                that.backgroundDomainMarkers)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.foregroundRangeMarkers, \n                that.foregroundRangeMarkers)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.backgroundRangeMarkers, \n                that.backgroundRangeMarkers)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.annotations, that.annotations)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.domainTickBandPaint, \n                that.domainTickBandPaint)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.rangeTickBandPaint, \n                that.rangeTickBandPaint)) {\n            return false;\n        }\n        if (!this.quadrantOrigin.equals(that.quadrantOrigin)) {\n            return false;\n        }\n        for (int i = 0; i < 4; i++) {\n            if (!PaintUtilities.equal(this.quadrantPaint[i], \n                    that.quadrantPaint[i])) {\n                return false;\n            }\n        }\n        return super.equals(obj);\n    }\n\n    \n    public Object clone() throws CloneNotSupportedException {\n\n        XYPlot clone = (XYPlot) super.clone();\n        clone.domainAxes = (ObjectList) ObjectUtilities.clone(this.domainAxes);\n        for (int i = 0; i < this.domainAxes.size(); i++) {\n            ValueAxis axis = (ValueAxis) this.domainAxes.get(i);\n            if (axis != null) {\n                ValueAxis clonedAxis = (ValueAxis) axis.clone();\n                clone.domainAxes.set(i, clonedAxis);\n                clonedAxis.setPlot(clone);\n                clonedAxis.addChangeListener(clone);\n            }\n        }\n        clone.domainAxisLocations = (ObjectList) \n                this.domainAxisLocations.clone();\n\n        clone.rangeAxes = (ObjectList) ObjectUtilities.clone(this.rangeAxes);\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis axis = (ValueAxis) this.rangeAxes.get(i);\n            if (axis != null) {\n                ValueAxis clonedAxis = (ValueAxis) axis.clone();\n                clone.rangeAxes.set(i, clonedAxis);\n                clonedAxis.setPlot(clone);\n                clonedAxis.addChangeListener(clone);\n            }\n        }\n        clone.rangeAxisLocations = (ObjectList) ObjectUtilities.clone(\n                this.rangeAxisLocations);\n\n        \n        clone.datasets = (ObjectList) ObjectUtilities.clone(this.datasets);\n        for (int i = 0; i < clone.datasets.size(); ++i) {\n            XYDataset d = getDataset(i);\n            if (d != null) {\n                d.addChangeListener(clone);\n            }\n        }\n\n        clone.datasetToDomainAxisMap = new TreeMap();\n        clone.datasetToDomainAxisMap.putAll(this.datasetToDomainAxisMap);\n        clone.datasetToRangeAxisMap = new TreeMap();\n        clone.datasetToRangeAxisMap.putAll(this.datasetToRangeAxisMap);\n\n        clone.renderers = (ObjectList) ObjectUtilities.clone(this.renderers);\n        for (int i = 0; i < this.renderers.size(); i++) {\n            XYItemRenderer renderer2 = (XYItemRenderer) this.renderers.get(i);\n            if (renderer2 instanceof PublicCloneable) {\n                PublicCloneable pc = (PublicCloneable) renderer2;\n                clone.renderers.set(i, pc.clone());\n            }\n        }\n        clone.foregroundDomainMarkers = (Map) ObjectUtilities.clone(\n                this.foregroundDomainMarkers);\n        clone.backgroundDomainMarkers = (Map) ObjectUtilities.clone(\n                this.backgroundDomainMarkers);\n        clone.foregroundRangeMarkers = (Map) ObjectUtilities.clone(\n                this.foregroundRangeMarkers);\n        clone.backgroundRangeMarkers = (Map) ObjectUtilities.clone(\n                this.backgroundRangeMarkers);\n        clone.annotations = (List) ObjectUtilities.deepClone(this.annotations);\n        if (this.fixedDomainAxisSpace != null) {\n            clone.fixedDomainAxisSpace = (AxisSpace) ObjectUtilities.clone(\n                    this.fixedDomainAxisSpace);\n        }\n        if (this.fixedRangeAxisSpace != null) {\n            clone.fixedRangeAxisSpace = (AxisSpace) ObjectUtilities.clone(\n                    this.fixedRangeAxisSpace);\n        }\n\n        clone.quadrantOrigin = (Point2D) ObjectUtilities.clone(\n                this.quadrantOrigin);\n        clone.quadrantPaint = (Paint[]) this.quadrantPaint.clone();\n        return clone;\n\n    }\n\n    \n    private void writeObject(ObjectOutputStream stream) throws IOException {\n        stream.defaultWriteObject();\n        SerialUtilities.writeStroke(this.domainGridlineStroke, stream);\n        SerialUtilities.writePaint(this.domainGridlinePaint, stream);\n        SerialUtilities.writeStroke(this.rangeGridlineStroke, stream);\n        SerialUtilities.writePaint(this.rangeGridlinePaint, stream);\n        SerialUtilities.writeStroke(this.rangeZeroBaselineStroke, stream);\n        SerialUtilities.writePaint(this.rangeZeroBaselinePaint, stream);\n        SerialUtilities.writeStroke(this.domainCrosshairStroke, stream);\n        SerialUtilities.writePaint(this.domainCrosshairPaint, stream);\n        SerialUtilities.writeStroke(this.rangeCrosshairStroke, stream);\n        SerialUtilities.writePaint(this.rangeCrosshairPaint, stream);\n        SerialUtilities.writePaint(this.domainTickBandPaint, stream);\n        SerialUtilities.writePaint(this.rangeTickBandPaint, stream);\n        SerialUtilities.writePoint2D(this.quadrantOrigin, stream);\n        for (int i = 0; i < 4; i++) {\n            SerialUtilities.writePaint(this.quadrantPaint[i], stream);\n        }\n        SerialUtilities.writeStroke(this.domainZeroBaselineStroke, stream);\n        SerialUtilities.writePaint(this.domainZeroBaselinePaint, stream);\n    }\n\n    \n    private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {\n\n        stream.defaultReadObject();\n        this.domainGridlineStroke = SerialUtilities.readStroke(stream);\n        this.domainGridlinePaint = SerialUtilities.readPaint(stream);\n        this.rangeGridlineStroke = SerialUtilities.readStroke(stream);\n        this.rangeGridlinePaint = SerialUtilities.readPaint(stream);\n        this.rangeZeroBaselineStroke = SerialUtilities.readStroke(stream);\n        this.rangeZeroBaselinePaint = SerialUtilities.readPaint(stream);\n        this.domainCrosshairStroke = SerialUtilities.readStroke(stream);\n        this.domainCrosshairPaint = SerialUtilities.readPaint(stream);\n        this.rangeCrosshairStroke = SerialUtilities.readStroke(stream);\n        this.rangeCrosshairPaint = SerialUtilities.readPaint(stream);\n        this.domainTickBandPaint = SerialUtilities.readPaint(stream);\n        this.rangeTickBandPaint = SerialUtilities.readPaint(stream);\n        this.quadrantOrigin = SerialUtilities.readPoint2D(stream);\n        this.quadrantPaint = new Paint[4];\n        for (int i = 0; i < 4; i++) {\n            this.quadrantPaint[i] = SerialUtilities.readPaint(stream);\n        }\n\n        this.domainZeroBaselineStroke = SerialUtilities.readStroke(stream);\n        this.domainZeroBaselinePaint = SerialUtilities.readPaint(stream);\n\n        \n        \n        int domainAxisCount = this.domainAxes.size();\n        for (int i = 0; i < domainAxisCount; i++) {\n            Axis axis = (Axis) this.domainAxes.get(i);\n            if (axis != null) {\n                axis.setPlot(this);\n                axis.addChangeListener(this);\n            }\n        }\n        int rangeAxisCount = this.rangeAxes.size();\n        for (int i = 0; i < rangeAxisCount; i++) {\n            Axis axis = (Axis) this.rangeAxes.get(i);\n            if (axis != null) {\n                axis.setPlot(this);\n                axis.addChangeListener(this);\n            }\n        }\n        int datasetCount = this.datasets.size();\n        for (int i = 0; i < datasetCount; i++) {\n            Dataset dataset = (Dataset) this.datasets.get(i);\n            if (dataset != null) {\n                dataset.addChangeListener(this);\n            }\n        }\n        int rendererCount = this.renderers.size();\n        for (int i = 0; i < rendererCount; i++) {\n            XYItemRenderer renderer = (XYItemRenderer) this.renderers.get(i);\n            if (renderer != null) {\n                renderer.addChangeListener(this);\n            }\n        }\n    \n    }\n\n}\n",
      "buggy_signatures": [
        "public XYPlot(XYDataset dataset, ValueAxis domainAxis, ValueAxis rangeAxis, XYItemRenderer renderer)",
        "public String getPlotType()",
        "public PlotOrientation getOrientation()",
        "public void setOrientation(PlotOrientation orientation)",
        "public RectangleInsets getAxisOffset()",
        "public void setAxisOffset(RectangleInsets offset)",
        "public ValueAxis getDomainAxis()",
        "public ValueAxis getDomainAxis(int index)",
        "public void setDomainAxis(ValueAxis axis)",
        "public void setDomainAxis(int index, ValueAxis axis)",
        "public void setDomainAxis(int index, ValueAxis axis, boolean notify)",
        "public void setDomainAxes(ValueAxis[] axes)",
        "public AxisLocation getDomainAxisLocation()",
        "public void setDomainAxisLocation(AxisLocation location)",
        "public void setDomainAxisLocation(AxisLocation location, boolean notify)",
        "public RectangleEdge getDomainAxisEdge()",
        "public int getDomainAxisCount()",
        "public void clearDomainAxes()",
        "public void configureDomainAxes()",
        "public AxisLocation getDomainAxisLocation(int index)",
        "public void setDomainAxisLocation(int index, AxisLocation location)",
        "public void setDomainAxisLocation(int index, AxisLocation location, boolean notify)",
        "public RectangleEdge getDomainAxisEdge(int index)",
        "public ValueAxis getRangeAxis()",
        "public void setRangeAxis(ValueAxis axis)",
        "public AxisLocation getRangeAxisLocation()",
        "public void setRangeAxisLocation(AxisLocation location)",
        "public void setRangeAxisLocation(AxisLocation location, boolean notify)",
        "public RectangleEdge getRangeAxisEdge()",
        "public ValueAxis getRangeAxis(int index)",
        "public void setRangeAxis(int index, ValueAxis axis)",
        "public void setRangeAxis(int index, ValueAxis axis, boolean notify)",
        "public void setRangeAxes(ValueAxis[] axes)",
        "public int getRangeAxisCount()",
        "public void clearRangeAxes()",
        "public void configureRangeAxes()",
        "public AxisLocation getRangeAxisLocation(int index)",
        "public void setRangeAxisLocation(int index, AxisLocation location)",
        "public void setRangeAxisLocation(int index, AxisLocation location, boolean notify)",
        "public RectangleEdge getRangeAxisEdge(int index)",
        "public XYDataset getDataset()",
        "public XYDataset getDataset(int index)",
        "public void setDataset(XYDataset dataset)",
        "public void setDataset(int index, XYDataset dataset)",
        "public int getDatasetCount()",
        "public int indexOf(XYDataset dataset)",
        "public void mapDatasetToDomainAxis(int index, int axisIndex)",
        "public void mapDatasetToRangeAxis(int index, int axisIndex)",
        "public XYItemRenderer getRenderer()",
        "public XYItemRenderer getRenderer(int index)",
        "public void setRenderer(XYItemRenderer renderer)",
        "public void setRenderer(int index, XYItemRenderer renderer)",
        "public void setRenderer(int index, XYItemRenderer renderer, boolean notify)",
        "public void setRenderers(XYItemRenderer[] renderers)",
        "public DatasetRenderingOrder getDatasetRenderingOrder()",
        "public void setDatasetRenderingOrder(DatasetRenderingOrder order)",
        "public SeriesRenderingOrder getSeriesRenderingOrder()",
        "public void setSeriesRenderingOrder(SeriesRenderingOrder order)",
        "public int getIndexOf(XYItemRenderer renderer)",
        "public XYItemRenderer getRendererForDataset(XYDataset dataset)",
        "public int getWeight()",
        "public void setWeight(int weight)",
        "public boolean isDomainGridlinesVisible()",
        "public void setDomainGridlinesVisible(boolean visible)",
        "public Stroke getDomainGridlineStroke()",
        "public void setDomainGridlineStroke(Stroke stroke)",
        "public Paint getDomainGridlinePaint()",
        "public void setDomainGridlinePaint(Paint paint)",
        "public boolean isRangeGridlinesVisible()",
        "public void setRangeGridlinesVisible(boolean visible)",
        "public Stroke getRangeGridlineStroke()",
        "public void setRangeGridlineStroke(Stroke stroke)",
        "public Paint getRangeGridlinePaint()",
        "public void setRangeGridlinePaint(Paint paint)",
        "public boolean isDomainZeroBaselineVisible()",
        "public void setDomainZeroBaselineVisible(boolean visible)",
        "public Stroke getDomainZeroBaselineStroke()",
        "public void setDomainZeroBaselineStroke(Stroke stroke)",
        "public Paint getDomainZeroBaselinePaint()",
        "public void setDomainZeroBaselinePaint(Paint paint)",
        "public boolean isRangeZeroBaselineVisible()",
        "public void setRangeZeroBaselineVisible(boolean visible)",
        "public Stroke getRangeZeroBaselineStroke()",
        "public void setRangeZeroBaselineStroke(Stroke stroke)",
        "public Paint getRangeZeroBaselinePaint()",
        "public void setRangeZeroBaselinePaint(Paint paint)",
        "public Paint getDomainTickBandPaint()",
        "public void setDomainTickBandPaint(Paint paint)",
        "public Paint getRangeTickBandPaint()",
        "public void setRangeTickBandPaint(Paint paint)",
        "public Point2D getQuadrantOrigin()",
        "public void setQuadrantOrigin(Point2D origin)",
        "public Paint getQuadrantPaint(int index)",
        "public void setQuadrantPaint(int index, Paint paint)",
        "public void addDomainMarker(Marker marker)",
        "public void addDomainMarker(Marker marker, Layer layer)",
        "public void clearDomainMarkers()",
        "public void clearDomainMarkers(int index)",
        "public void addDomainMarker(int index, Marker marker, Layer layer)",
        "public void addDomainMarker(int index, Marker marker, Layer layer, boolean notify)",
        "public boolean removeDomainMarker(Marker marker)",
        "public boolean removeDomainMarker(Marker marker, Layer layer)",
        "public boolean removeDomainMarker(int index, Marker marker, Layer layer)",
        "public boolean removeDomainMarker(int index, Marker marker, Layer layer, boolean notify)",
        "public void addRangeMarker(Marker marker)",
        "public void addRangeMarker(Marker marker, Layer layer)",
        "public void clearRangeMarkers()",
        "public void addRangeMarker(int index, Marker marker, Layer layer)",
        "public void addRangeMarker(int index, Marker marker, Layer layer, boolean notify)",
        "public void clearRangeMarkers(int index)",
        "public boolean removeRangeMarker(Marker marker)",
        "public boolean removeRangeMarker(Marker marker, Layer layer)",
        "public boolean removeRangeMarker(int index, Marker marker, Layer layer)",
        "public boolean removeRangeMarker(int index, Marker marker, Layer layer, boolean notify)",
        "public void addAnnotation(XYAnnotation annotation)",
        "public void addAnnotation(XYAnnotation annotation, boolean notify)",
        "public boolean removeAnnotation(XYAnnotation annotation)",
        "public boolean removeAnnotation(XYAnnotation annotation, boolean notify)",
        "public List getAnnotations()",
        "public void clearAnnotations()",
        "protected AxisSpace calculateAxisSpace(Graphics2D g2, Rectangle2D plotArea)",
        "protected AxisSpace calculateDomainAxisSpace(Graphics2D g2, Rectangle2D plotArea, AxisSpace space)",
        "protected AxisSpace calculateRangeAxisSpace(Graphics2D g2, Rectangle2D plotArea, AxisSpace space)",
        "public void draw(Graphics2D g2, Rectangle2D area, Point2D anchor, PlotState parentState, PlotRenderingInfo info)",
        "public void drawBackground(Graphics2D g2, Rectangle2D area)",
        "protected void drawQuadrants(Graphics2D g2, Rectangle2D area)",
        "public void drawDomainTickBands(Graphics2D g2, Rectangle2D dataArea, List ticks)",
        "public void drawRangeTickBands(Graphics2D g2, Rectangle2D dataArea, List ticks)",
        "protected Map drawAxes(Graphics2D g2, Rectangle2D plotArea, Rectangle2D dataArea, PlotRenderingInfo plotState)",
        "public boolean render(Graphics2D g2, Rectangle2D dataArea, int index, PlotRenderingInfo info, CrosshairState crosshairState)",
        "public ValueAxis getDomainAxisForDataset(int index)",
        "public ValueAxis getRangeAxisForDataset(int index)",
        "protected void drawDomainGridlines(Graphics2D g2, Rectangle2D dataArea, List ticks)",
        "protected void drawRangeGridlines(Graphics2D g2, Rectangle2D area, List ticks)",
        "protected void drawZeroDomainBaseline(Graphics2D g2, Rectangle2D area)",
        "protected void drawZeroRangeBaseline(Graphics2D g2, Rectangle2D area)",
        "public void drawAnnotations(Graphics2D g2, Rectangle2D dataArea, PlotRenderingInfo info)",
        "protected void drawDomainMarkers(Graphics2D g2, Rectangle2D dataArea, int index, Layer layer)",
        "protected void drawRangeMarkers(Graphics2D g2, Rectangle2D dataArea, int index, Layer layer)",
        "public Collection getDomainMarkers(Layer layer)",
        "public Collection getRangeMarkers(Layer layer)",
        "public Collection getDomainMarkers(int index, Layer layer)",
        "public Collection getRangeMarkers(int index, Layer layer)",
        "protected void drawHorizontalLine(Graphics2D g2, Rectangle2D dataArea, double value, Stroke stroke, Paint paint)",
        "protected void drawDomainCrosshair(Graphics2D g2, Rectangle2D dataArea, PlotOrientation orientation, double value, ValueAxis axis, Stroke stroke, Paint paint)",
        "protected void drawVerticalLine(Graphics2D g2, Rectangle2D dataArea, double value, Stroke stroke, Paint paint)",
        "protected void drawRangeCrosshair(Graphics2D g2, Rectangle2D dataArea, PlotOrientation orientation, double value, ValueAxis axis, Stroke stroke, Paint paint)",
        "public void handleClick(int x, int y, PlotRenderingInfo info)",
        "private List getDatasetsMappedToDomainAxis(Integer axisIndex)",
        "private List getDatasetsMappedToRangeAxis(Integer axisIndex)",
        "public int getDomainAxisIndex(ValueAxis axis)",
        "public int getRangeAxisIndex(ValueAxis axis)",
        "public Range getDataRange(ValueAxis axis)",
        "public void datasetChanged(DatasetChangeEvent event)",
        "public void rendererChanged(RendererChangeEvent event)",
        "public boolean isDomainCrosshairVisible()",
        "public void setDomainCrosshairVisible(boolean flag)",
        "public boolean isDomainCrosshairLockedOnData()",
        "public void setDomainCrosshairLockedOnData(boolean flag)",
        "public double getDomainCrosshairValue()",
        "public void setDomainCrosshairValue(double value)",
        "public void setDomainCrosshairValue(double value, boolean notify)",
        "public Stroke getDomainCrosshairStroke()",
        "public void setDomainCrosshairStroke(Stroke stroke)",
        "public Paint getDomainCrosshairPaint()",
        "public void setDomainCrosshairPaint(Paint paint)",
        "public boolean isRangeCrosshairVisible()",
        "public void setRangeCrosshairVisible(boolean flag)",
        "public boolean isRangeCrosshairLockedOnData()",
        "public void setRangeCrosshairLockedOnData(boolean flag)",
        "public double getRangeCrosshairValue()",
        "public void setRangeCrosshairValue(double value)",
        "public void setRangeCrosshairValue(double value, boolean notify)",
        "public Stroke getRangeCrosshairStroke()",
        "public void setRangeCrosshairStroke(Stroke stroke)",
        "public Paint getRangeCrosshairPaint()",
        "public void setRangeCrosshairPaint(Paint paint)",
        "public AxisSpace getFixedDomainAxisSpace()",
        "public void setFixedDomainAxisSpace(AxisSpace space)",
        "public void setFixedDomainAxisSpace(AxisSpace space, boolean notify)",
        "public AxisSpace getFixedRangeAxisSpace()",
        "public void setFixedRangeAxisSpace(AxisSpace space)",
        "public void setFixedRangeAxisSpace(AxisSpace space, boolean notify)",
        "public void zoomDomainAxes(double factor, PlotRenderingInfo info, Point2D source)",
        "public void zoomDomainAxes(double factor, PlotRenderingInfo info, Point2D source, boolean useAnchor)",
        "public void zoomDomainAxes(double lowerPercent, double upperPercent, PlotRenderingInfo info, Point2D source)",
        "public void zoomRangeAxes(double factor, PlotRenderingInfo info, Point2D source)",
        "public void zoomRangeAxes(double factor, PlotRenderingInfo info, Point2D source, boolean useAnchor)",
        "public void zoomRangeAxes(double lowerPercent, double upperPercent, PlotRenderingInfo info, Point2D source)",
        "public boolean isDomainZoomable()",
        "public boolean isRangeZoomable()",
        "public int getSeriesCount()",
        "public LegendItemCollection getFixedLegendItems()",
        "public void setFixedLegendItems(LegendItemCollection items)",
        "public LegendItemCollection getLegendItems()",
        "public boolean equals(Object obj)",
        "public Object clone() throws CloneNotSupportedException",
        "private void writeObject(ObjectOutputStream stream) throws IOException",
        "private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException"
      ],
      "fixed_signatures": [
        "public XYPlot(XYDataset dataset, ValueAxis domainAxis, ValueAxis rangeAxis, XYItemRenderer renderer)",
        "public String getPlotType()",
        "public PlotOrientation getOrientation()",
        "public void setOrientation(PlotOrientation orientation)",
        "public RectangleInsets getAxisOffset()",
        "public void setAxisOffset(RectangleInsets offset)",
        "public ValueAxis getDomainAxis()",
        "public ValueAxis getDomainAxis(int index)",
        "public void setDomainAxis(ValueAxis axis)",
        "public void setDomainAxis(int index, ValueAxis axis)",
        "public void setDomainAxis(int index, ValueAxis axis, boolean notify)",
        "public void setDomainAxes(ValueAxis[] axes)",
        "public AxisLocation getDomainAxisLocation()",
        "public void setDomainAxisLocation(AxisLocation location)",
        "public void setDomainAxisLocation(AxisLocation location, boolean notify)",
        "public RectangleEdge getDomainAxisEdge()",
        "public int getDomainAxisCount()",
        "public void clearDomainAxes()",
        "public void configureDomainAxes()",
        "public AxisLocation getDomainAxisLocation(int index)",
        "public void setDomainAxisLocation(int index, AxisLocation location)",
        "public void setDomainAxisLocation(int index, AxisLocation location, boolean notify)",
        "public RectangleEdge getDomainAxisEdge(int index)",
        "public ValueAxis getRangeAxis()",
        "public void setRangeAxis(ValueAxis axis)",
        "public AxisLocation getRangeAxisLocation()",
        "public void setRangeAxisLocation(AxisLocation location)",
        "public void setRangeAxisLocation(AxisLocation location, boolean notify)",
        "public RectangleEdge getRangeAxisEdge()",
        "public ValueAxis getRangeAxis(int index)",
        "public void setRangeAxis(int index, ValueAxis axis)",
        "public void setRangeAxis(int index, ValueAxis axis, boolean notify)",
        "public void setRangeAxes(ValueAxis[] axes)",
        "public int getRangeAxisCount()",
        "public void clearRangeAxes()",
        "public void configureRangeAxes()",
        "public AxisLocation getRangeAxisLocation(int index)",
        "public void setRangeAxisLocation(int index, AxisLocation location)",
        "public void setRangeAxisLocation(int index, AxisLocation location, boolean notify)",
        "public RectangleEdge getRangeAxisEdge(int index)",
        "public XYDataset getDataset()",
        "public XYDataset getDataset(int index)",
        "public void setDataset(XYDataset dataset)",
        "public void setDataset(int index, XYDataset dataset)",
        "public int getDatasetCount()",
        "public int indexOf(XYDataset dataset)",
        "public void mapDatasetToDomainAxis(int index, int axisIndex)",
        "public void mapDatasetToRangeAxis(int index, int axisIndex)",
        "public XYItemRenderer getRenderer()",
        "public XYItemRenderer getRenderer(int index)",
        "public void setRenderer(XYItemRenderer renderer)",
        "public void setRenderer(int index, XYItemRenderer renderer)",
        "public void setRenderer(int index, XYItemRenderer renderer, boolean notify)",
        "public void setRenderers(XYItemRenderer[] renderers)",
        "public DatasetRenderingOrder getDatasetRenderingOrder()",
        "public void setDatasetRenderingOrder(DatasetRenderingOrder order)",
        "public SeriesRenderingOrder getSeriesRenderingOrder()",
        "public void setSeriesRenderingOrder(SeriesRenderingOrder order)",
        "public int getIndexOf(XYItemRenderer renderer)",
        "public XYItemRenderer getRendererForDataset(XYDataset dataset)",
        "public int getWeight()",
        "public void setWeight(int weight)",
        "public boolean isDomainGridlinesVisible()",
        "public void setDomainGridlinesVisible(boolean visible)",
        "public Stroke getDomainGridlineStroke()",
        "public void setDomainGridlineStroke(Stroke stroke)",
        "public Paint getDomainGridlinePaint()",
        "public void setDomainGridlinePaint(Paint paint)",
        "public boolean isRangeGridlinesVisible()",
        "public void setRangeGridlinesVisible(boolean visible)",
        "public Stroke getRangeGridlineStroke()",
        "public void setRangeGridlineStroke(Stroke stroke)",
        "public Paint getRangeGridlinePaint()",
        "public void setRangeGridlinePaint(Paint paint)",
        "public boolean isDomainZeroBaselineVisible()",
        "public void setDomainZeroBaselineVisible(boolean visible)",
        "public Stroke getDomainZeroBaselineStroke()",
        "public void setDomainZeroBaselineStroke(Stroke stroke)",
        "public Paint getDomainZeroBaselinePaint()",
        "public void setDomainZeroBaselinePaint(Paint paint)",
        "public boolean isRangeZeroBaselineVisible()",
        "public void setRangeZeroBaselineVisible(boolean visible)",
        "public Stroke getRangeZeroBaselineStroke()",
        "public void setRangeZeroBaselineStroke(Stroke stroke)",
        "public Paint getRangeZeroBaselinePaint()",
        "public void setRangeZeroBaselinePaint(Paint paint)",
        "public Paint getDomainTickBandPaint()",
        "public void setDomainTickBandPaint(Paint paint)",
        "public Paint getRangeTickBandPaint()",
        "public void setRangeTickBandPaint(Paint paint)",
        "public Point2D getQuadrantOrigin()",
        "public void setQuadrantOrigin(Point2D origin)",
        "public Paint getQuadrantPaint(int index)",
        "public void setQuadrantPaint(int index, Paint paint)",
        "public void addDomainMarker(Marker marker)",
        "public void addDomainMarker(Marker marker, Layer layer)",
        "public void clearDomainMarkers()",
        "public void clearDomainMarkers(int index)",
        "public void addDomainMarker(int index, Marker marker, Layer layer)",
        "public void addDomainMarker(int index, Marker marker, Layer layer, boolean notify)",
        "public boolean removeDomainMarker(Marker marker)",
        "public boolean removeDomainMarker(Marker marker, Layer layer)",
        "public boolean removeDomainMarker(int index, Marker marker, Layer layer)",
        "public boolean removeDomainMarker(int index, Marker marker, Layer layer, boolean notify)",
        "public void addRangeMarker(Marker marker)",
        "public void addRangeMarker(Marker marker, Layer layer)",
        "public void clearRangeMarkers()",
        "public void addRangeMarker(int index, Marker marker, Layer layer)",
        "public void addRangeMarker(int index, Marker marker, Layer layer, boolean notify)",
        "public void clearRangeMarkers(int index)",
        "public boolean removeRangeMarker(Marker marker)",
        "public boolean removeRangeMarker(Marker marker, Layer layer)",
        "public boolean removeRangeMarker(int index, Marker marker, Layer layer)",
        "public boolean removeRangeMarker(int index, Marker marker, Layer layer, boolean notify)",
        "public void addAnnotation(XYAnnotation annotation)",
        "public void addAnnotation(XYAnnotation annotation, boolean notify)",
        "public boolean removeAnnotation(XYAnnotation annotation)",
        "public boolean removeAnnotation(XYAnnotation annotation, boolean notify)",
        "public List getAnnotations()",
        "public void clearAnnotations()",
        "protected AxisSpace calculateAxisSpace(Graphics2D g2, Rectangle2D plotArea)",
        "protected AxisSpace calculateDomainAxisSpace(Graphics2D g2, Rectangle2D plotArea, AxisSpace space)",
        "protected AxisSpace calculateRangeAxisSpace(Graphics2D g2, Rectangle2D plotArea, AxisSpace space)",
        "public void draw(Graphics2D g2, Rectangle2D area, Point2D anchor, PlotState parentState, PlotRenderingInfo info)",
        "public void drawBackground(Graphics2D g2, Rectangle2D area)",
        "protected void drawQuadrants(Graphics2D g2, Rectangle2D area)",
        "public void drawDomainTickBands(Graphics2D g2, Rectangle2D dataArea, List ticks)",
        "public void drawRangeTickBands(Graphics2D g2, Rectangle2D dataArea, List ticks)",
        "protected Map drawAxes(Graphics2D g2, Rectangle2D plotArea, Rectangle2D dataArea, PlotRenderingInfo plotState)",
        "public boolean render(Graphics2D g2, Rectangle2D dataArea, int index, PlotRenderingInfo info, CrosshairState crosshairState)",
        "public ValueAxis getDomainAxisForDataset(int index)",
        "public ValueAxis getRangeAxisForDataset(int index)",
        "protected void drawDomainGridlines(Graphics2D g2, Rectangle2D dataArea, List ticks)",
        "protected void drawRangeGridlines(Graphics2D g2, Rectangle2D area, List ticks)",
        "protected void drawZeroDomainBaseline(Graphics2D g2, Rectangle2D area)",
        "protected void drawZeroRangeBaseline(Graphics2D g2, Rectangle2D area)",
        "public void drawAnnotations(Graphics2D g2, Rectangle2D dataArea, PlotRenderingInfo info)",
        "protected void drawDomainMarkers(Graphics2D g2, Rectangle2D dataArea, int index, Layer layer)",
        "protected void drawRangeMarkers(Graphics2D g2, Rectangle2D dataArea, int index, Layer layer)",
        "public Collection getDomainMarkers(Layer layer)",
        "public Collection getRangeMarkers(Layer layer)",
        "public Collection getDomainMarkers(int index, Layer layer)",
        "public Collection getRangeMarkers(int index, Layer layer)",
        "protected void drawHorizontalLine(Graphics2D g2, Rectangle2D dataArea, double value, Stroke stroke, Paint paint)",
        "protected void drawDomainCrosshair(Graphics2D g2, Rectangle2D dataArea, PlotOrientation orientation, double value, ValueAxis axis, Stroke stroke, Paint paint)",
        "protected void drawVerticalLine(Graphics2D g2, Rectangle2D dataArea, double value, Stroke stroke, Paint paint)",
        "protected void drawRangeCrosshair(Graphics2D g2, Rectangle2D dataArea, PlotOrientation orientation, double value, ValueAxis axis, Stroke stroke, Paint paint)",
        "public void handleClick(int x, int y, PlotRenderingInfo info)",
        "private List getDatasetsMappedToDomainAxis(Integer axisIndex)",
        "private List getDatasetsMappedToRangeAxis(Integer axisIndex)",
        "public int getDomainAxisIndex(ValueAxis axis)",
        "public int getRangeAxisIndex(ValueAxis axis)",
        "public Range getDataRange(ValueAxis axis)",
        "public void datasetChanged(DatasetChangeEvent event)",
        "public void rendererChanged(RendererChangeEvent event)",
        "public boolean isDomainCrosshairVisible()",
        "public void setDomainCrosshairVisible(boolean flag)",
        "public boolean isDomainCrosshairLockedOnData()",
        "public void setDomainCrosshairLockedOnData(boolean flag)",
        "public double getDomainCrosshairValue()",
        "public void setDomainCrosshairValue(double value)",
        "public void setDomainCrosshairValue(double value, boolean notify)",
        "public Stroke getDomainCrosshairStroke()",
        "public void setDomainCrosshairStroke(Stroke stroke)",
        "public Paint getDomainCrosshairPaint()",
        "public void setDomainCrosshairPaint(Paint paint)",
        "public boolean isRangeCrosshairVisible()",
        "public void setRangeCrosshairVisible(boolean flag)",
        "public boolean isRangeCrosshairLockedOnData()",
        "public void setRangeCrosshairLockedOnData(boolean flag)",
        "public double getRangeCrosshairValue()",
        "public void setRangeCrosshairValue(double value)",
        "public void setRangeCrosshairValue(double value, boolean notify)",
        "public Stroke getRangeCrosshairStroke()",
        "public void setRangeCrosshairStroke(Stroke stroke)",
        "public Paint getRangeCrosshairPaint()",
        "public void setRangeCrosshairPaint(Paint paint)",
        "public AxisSpace getFixedDomainAxisSpace()",
        "public void setFixedDomainAxisSpace(AxisSpace space)",
        "public void setFixedDomainAxisSpace(AxisSpace space, boolean notify)",
        "public AxisSpace getFixedRangeAxisSpace()",
        "public void setFixedRangeAxisSpace(AxisSpace space)",
        "public void setFixedRangeAxisSpace(AxisSpace space, boolean notify)",
        "public void zoomDomainAxes(double factor, PlotRenderingInfo info, Point2D source)",
        "public void zoomDomainAxes(double factor, PlotRenderingInfo info, Point2D source, boolean useAnchor)",
        "public void zoomDomainAxes(double lowerPercent, double upperPercent, PlotRenderingInfo info, Point2D source)",
        "public void zoomRangeAxes(double factor, PlotRenderingInfo info, Point2D source)",
        "public void zoomRangeAxes(double factor, PlotRenderingInfo info, Point2D source, boolean useAnchor)",
        "public void zoomRangeAxes(double lowerPercent, double upperPercent, PlotRenderingInfo info, Point2D source)",
        "public boolean isDomainZoomable()",
        "public boolean isRangeZoomable()",
        "public int getSeriesCount()",
        "public LegendItemCollection getFixedLegendItems()",
        "public void setFixedLegendItems(LegendItemCollection items)",
        "public LegendItemCollection getLegendItems()",
        "public boolean equals(Object obj)",
        "public Object clone() throws CloneNotSupportedException",
        "private void writeObject(ObjectOutputStream stream) throws IOException",
        "private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException"
      ],
      "methods": [
        {
          "buggy_method": "  public boolean removeDomainMarker(int index, Marker marker, Layer layer, boolean notify) {\n  ArrayList markers;\n  if (layer == Layer.FOREGROUND) {\n  markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer(\n  index));\n  }\n  else {\n  markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n  index));\n  }\n  boolean removed = markers.remove(marker);\n  if (removed && notify) {\n  fireChangeEvent();\n  }\n  return removed;\n  }",
          "fixed_method": "  public boolean removeDomainMarker(int index, Marker marker, Layer layer, boolean notify) {\n  ArrayList markers;\n  if (layer == Layer.FOREGROUND) {\n  markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer(\n  index));\n  }\n  else {\n  markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n  index));\n  }\n  if (markers == null) {\n  return false;\n  }\n  boolean removed = markers.remove(marker);\n  if (removed && notify) {\n  fireChangeEvent();\n  }\n  return removed;\n  }",
          "diff": [
            "@@ -2290,6 +2290,9 @@",
            "             markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n",
            "                     index));\n",
            "         }\n",
            "+        if (markers == null) {\n",
            "+            return false;\n",
            "+        }\n",
            "         boolean removed = markers.remove(marker);\n",
            "         if (removed && notify) {\n",
            "             fireChangeEvent();\n"
          ],
          "changed_lines": 3
        },
        {
          "buggy_method": "  public boolean removeRangeMarker(int index, Marker marker, Layer layer, boolean notify) {\n  if (marker == null) {\n  throw new IllegalArgumentException(\"Null 'marker' argument.\");\n  }\n  ArrayList markers;\n  if (layer == Layer.FOREGROUND) {\n  markers = (ArrayList) this.foregroundRangeMarkers.get(new Integer(\n  index));\n  }\n  else {\n  markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(\n  index));\n  }\n  boolean removed = markers.remove(marker);\n  if (removed && notify) {\n  fireChangeEvent();\n  }\n  return removed;\n  }",
          "fixed_method": "  public boolean removeRangeMarker(int index, Marker marker, Layer layer, boolean notify) {\n  if (marker == null) {\n  throw new IllegalArgumentException(\"Null 'marker' argument.\");\n  }\n  ArrayList markers;\n  if (layer == Layer.FOREGROUND) {\n  markers = (ArrayList) this.foregroundRangeMarkers.get(new Integer(\n  index));\n  }\n  else {\n  markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(\n  index));\n  }\n  if (markers == null) {\n  return false;\n  }\n  boolean removed = markers.remove(marker);\n  if (removed && notify) {\n  fireChangeEvent();\n  }\n  return removed;\n  }",
          "diff": [
            "@@ -2525,6 +2528,9 @@",
            "         else {\n",
            "             markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(\n",
            "                     index));\n",
            "+        }\n",
            "+        if (markers == null) {\n",
            "+            return false;\n",
            "         }\n",
            "         boolean removed = markers.remove(marker);\n",
            "         if (removed && notify) {\n"
          ],
          "changed_lines": 3
        }
      ]
    }
  ]
}
