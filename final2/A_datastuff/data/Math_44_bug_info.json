{
  "bug_id": "44",
  "failed_tests": {
    "org.apache.commons.math.ode.events.EventStateTest": [
      {
        "methodName": "testIssue695",
        "error": "junit.framework.AssertionFailedError",
        "message": "going backard in time! (7.796578226186635 < 10.99)",
        "fail_line": "        double tEnd = integrator.integrate(equation, 0.0, y, target, y);",
        "test_source": "  public void testIssue695() {\n\n  FirstOrderDifferentialEquations equation = new FirstOrderDifferentialEquations() {\n  \n  public int getDimension() {\n  return 1;\n  }\n  \n  public void computeDerivatives(double t, double[] y, double[] yDot) {\n  yDot[0] = 1.0;\n  }\n  };\n\n  DormandPrince853Integrator integrator = new DormandPrince853Integrator(0.001, 1000, 1.0e-14, 1.0e-14);\n  integrator.addEventHandler(new ResettingEvent(10.99), 0.1, 1.0e-9, 1000);\n  integrator.addEventHandler(new ResettingEvent(11.01), 0.1, 1.0e-9, 1000);\n  integrator.setInitialStepSize(3.0);\n\n  double target = 30.0;\n  double[] y = new double[1];\n  double tEnd = integrator.integrate(equation, 0.0, y, target, y);\n  Assert.assertEquals(target, tEnd, 1.0e-10);\n  Assert.assertEquals(32.0, y[0], 1.0e-10);\n\n  }",
        "stack": [
          "EventStateTest$ResettingEvent.g line 120, EventState.evaluateStep line 214, AbstractIntegrator.acceptStep line 302, EmbeddedRungeKuttaIntegrator.integrate line 296, AbstractIntegrator.integrate line 213, EventStateTest.testIssue695 line 100"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/math/ode/AbstractIntegrator.java",
      "buggy_full_code": "\n\npackage org.apache.commons.math.ode;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.SortedSet;\nimport java.util.TreeSet;\n\nimport org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolver;\nimport org.apache.commons.math.analysis.solvers.UnivariateRealSolver;\nimport org.apache.commons.math.exception.DimensionMismatchException;\nimport org.apache.commons.math.exception.MathIllegalArgumentException;\nimport org.apache.commons.math.exception.MathIllegalStateException;\nimport org.apache.commons.math.exception.MaxCountExceededException;\nimport org.apache.commons.math.exception.NumberIsTooSmallException;\nimport org.apache.commons.math.exception.util.LocalizedFormats;\nimport org.apache.commons.math.ode.events.EventHandler;\nimport org.apache.commons.math.ode.events.EventState;\nimport org.apache.commons.math.ode.sampling.AbstractStepInterpolator;\nimport org.apache.commons.math.ode.sampling.StepHandler;\nimport org.apache.commons.math.util.FastMath;\nimport org.apache.commons.math.util.Incrementor;\nimport org.apache.commons.math.util.Precision;\n\n\npublic abstract class AbstractIntegrator implements FirstOrderIntegrator { protected Collection<StepHandler> stepHandlers; protected double stepStart; protected double stepSize; protected boolean isLastStep; protected boolean resetOccurred; private Collection<EventState> eventsStates; private boolean statesInitialized; private final String name; private Incrementor evaluations; private transient ExpandableStatefulODE expandable; public AbstractIntegrator(final String name) {\n        this.name = name;\n        stepHandlers = new ArrayList<StepHandler>();\n        stepStart = Double.NaN;\n        stepSize  = Double.NaN;\n        eventsStates = new ArrayList<EventState>();\n        statesInitialized = false;\n        evaluations = new Incrementor();\n        setMaxEvaluations(-1);\n        resetEvaluations();\n    }\n\n    \n    protected AbstractIntegrator() {\n        this(null);\n    }\n\n    \n    public String getName() {\n        return name;\n    }\n\n    \n    public void addStepHandler(final StepHandler handler) {\n        stepHandlers.add(handler);\n    }\n\n    \n    public Collection<StepHandler> getStepHandlers() {\n        return Collections.unmodifiableCollection(stepHandlers);\n    }\n\n    \n    public void clearStepHandlers() {\n        stepHandlers.clear();\n    }\n\n    \n    public void addEventHandler(final EventHandler handler, final double maxCheckInterval, final double convergence, final int maxIterationCount) {\n        addEventHandler(handler, maxCheckInterval, convergence,\n                        maxIterationCount,\n                        new BracketingNthOrderBrentSolver(convergence, 5));\n    }\n\n    \n    public void addEventHandler(final EventHandler handler, final double maxCheckInterval, final double convergence, final int maxIterationCount, final UnivariateRealSolver solver) {\n        eventsStates.add(new EventState(handler, maxCheckInterval, convergence,\n                                        maxIterationCount, solver));\n    }\n\n    \n    public Collection<EventHandler> getEventHandlers() {\n        final List<EventHandler> list = new ArrayList<EventHandler>();\n        for (EventState state : eventsStates) {\n            list.add(state.getEventHandler());\n        }\n        return Collections.unmodifiableCollection(list);\n    }\n\n    \n    public void clearEventHandlers() {\n        eventsStates.clear();\n    }\n\n    \n    public double getCurrentStepStart() {\n        return stepStart;\n    }\n\n    \n    public double getCurrentSignedStepsize() {\n        return stepSize;\n    }\n\n    \n    public void setMaxEvaluations(int maxEvaluations) {\n        evaluations.setMaximalCount((maxEvaluations < 0) ? Integer.MAX_VALUE : maxEvaluations);\n    }\n\n    \n    public int getMaxEvaluations() {\n        return evaluations.getMaximalCount();\n    }\n\n    \n    public int getEvaluations() {\n        return evaluations.getCount();\n    }\n\n    \n    protected void resetEvaluations() {\n        evaluations.resetCount();\n    }\n\n    \n    protected void setEquations(final ExpandableStatefulODE equations) {\n        this.expandable = equations;\n    }\n\n    \n    public double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws MathIllegalStateException, MathIllegalArgumentException {\n\n        if (y0.length != equations.getDimension()) {\n            throw new DimensionMismatchException(y0.length, equations.getDimension());\n        }\n        if (y.length != equations.getDimension()) {\n            throw new DimensionMismatchException(y.length, equations.getDimension());\n        }\n\n        \n        final ExpandableStatefulODE expandableODE = new ExpandableStatefulODE(equations);\n        expandableODE.setTime(t0);\n        expandableODE.setPrimaryState(y0);\n\n        \n        integrate(expandableODE, t);\n\n        \n        System.arraycopy(expandableODE.getPrimaryState(), 0, y, 0, y.length);\n        return expandableODE.getTime();\n\n    }\n\n    \n    public abstract void integrate(ExpandableStatefulODE equations, double t) throws MathIllegalStateException, MathIllegalArgumentException; public void computeDerivatives(final double t, final double[] y, final double[] yDot) throws MaxCountExceededException {\n        evaluations.incrementCount();\n        expandable.computeDerivatives(t, y, yDot);\n    }\n\n    \n    protected void setStateInitialized(final boolean stateInitialized) {\n        this.statesInitialized = stateInitialized;\n    }\n\n    \n    protected double acceptStep(final AbstractStepInterpolator interpolator, final double[] y, final double[] yDot, final double tEnd) throws MathIllegalStateException {\n\n            double previousT = interpolator.getGlobalPreviousTime();\n            final double currentT = interpolator.getGlobalCurrentTime();\n            resetOccurred = false;\n\n            \n            if (! statesInitialized) {\n                for (EventState state : eventsStates) {\n                    state.reinitializeBegin(interpolator);\n                }\n                statesInitialized = true;\n            }\n\n            \n            final int orderingSign = interpolator.isForward() ? +1 : -1;\n            SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n\n                \n                public int compare(EventState es0, EventState es1) {\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n\n            });\n\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    \n                    occuringEvents.add(state);\n                }\n            }\n\n            while (!occuringEvents.isEmpty()) {\n\n                \n                final Iterator<EventState> iterator = occuringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove();\n\n                \n                final double eventT = currentEvent.getEventTime();\n                interpolator.setSoftPreviousTime(previousT);\n                interpolator.setSoftCurrentTime(eventT);\n\n                \n                interpolator.setInterpolatedTime(eventT);\n                final double[] eventY = interpolator.getInterpolatedState();\n                currentEvent.stepAccepted(eventT, eventY);\n                isLastStep = currentEvent.stop();\n\n                \n                for (final StepHandler handler : stepHandlers) {\n                    handler.handleStep(interpolator, isLastStep);\n                }\n\n                if (isLastStep) {\n                    \n                    System.arraycopy(eventY, 0, y, 0, y.length);\n                    return eventT;\n                }\n\n                if (currentEvent.reset(eventT, eventY)) {\n                    \n                    \n                    System.arraycopy(eventY, 0, y, 0, y.length);\n                    computeDerivatives(eventT, y, yDot);\n                    resetOccurred = true;\n                    return eventT;\n                }\n\n                \n                previousT = eventT;\n                interpolator.setSoftPreviousTime(eventT);\n                interpolator.setSoftCurrentTime(currentT);\n\n                \n                if (currentEvent.evaluateStep(interpolator)) {\n                    \n                    occuringEvents.add(currentEvent);\n                }\n\n            }\n\n            interpolator.setInterpolatedTime(currentT);\n            final double[] currentY = interpolator.getInterpolatedState();\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(currentT, currentY);\n                isLastStep = isLastStep || state.stop();\n            }\n            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n\n            \n            for (StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n\n            return currentT;\n\n    }\n\n    \n    protected void sanityChecks(final ExpandableStatefulODE equations, final double t) throws NumberIsTooSmallException {\n\n        final double threshold = 1000 * FastMath.ulp(FastMath.max(FastMath.abs(equations.getTime()),\n                                                                  FastMath.abs(t)));\n        final double dt = FastMath.abs(equations.getTime() - t);\n        if (dt <= threshold) {\n            throw new NumberIsTooSmallException(LocalizedFormats.TOO_SMALL_INTEGRATION_INTERVAL,\n                                                dt, threshold, false);\n        }\n\n    }\n\n}\n",
      "fixed_full_code": "\n\npackage org.apache.commons.math.ode;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.SortedSet;\nimport java.util.TreeSet;\n\nimport org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolver;\nimport org.apache.commons.math.analysis.solvers.UnivariateRealSolver;\nimport org.apache.commons.math.exception.DimensionMismatchException;\nimport org.apache.commons.math.exception.MathIllegalArgumentException;\nimport org.apache.commons.math.exception.MathIllegalStateException;\nimport org.apache.commons.math.exception.MaxCountExceededException;\nimport org.apache.commons.math.exception.NumberIsTooSmallException;\nimport org.apache.commons.math.exception.util.LocalizedFormats;\nimport org.apache.commons.math.ode.events.EventHandler;\nimport org.apache.commons.math.ode.events.EventState;\nimport org.apache.commons.math.ode.sampling.AbstractStepInterpolator;\nimport org.apache.commons.math.ode.sampling.StepHandler;\nimport org.apache.commons.math.util.FastMath;\nimport org.apache.commons.math.util.Incrementor;\nimport org.apache.commons.math.util.Precision;\n\n\npublic abstract class AbstractIntegrator implements FirstOrderIntegrator { protected Collection<StepHandler> stepHandlers; protected double stepStart; protected double stepSize; protected boolean isLastStep; protected boolean resetOccurred; private Collection<EventState> eventsStates; private boolean statesInitialized; private final String name; private Incrementor evaluations; private transient ExpandableStatefulODE expandable; public AbstractIntegrator(final String name) {\n        this.name = name;\n        stepHandlers = new ArrayList<StepHandler>();\n        stepStart = Double.NaN;\n        stepSize  = Double.NaN;\n        eventsStates = new ArrayList<EventState>();\n        statesInitialized = false;\n        evaluations = new Incrementor();\n        setMaxEvaluations(-1);\n        resetEvaluations();\n    }\n\n    \n    protected AbstractIntegrator() {\n        this(null);\n    }\n\n    \n    public String getName() {\n        return name;\n    }\n\n    \n    public void addStepHandler(final StepHandler handler) {\n        stepHandlers.add(handler);\n    }\n\n    \n    public Collection<StepHandler> getStepHandlers() {\n        return Collections.unmodifiableCollection(stepHandlers);\n    }\n\n    \n    public void clearStepHandlers() {\n        stepHandlers.clear();\n    }\n\n    \n    public void addEventHandler(final EventHandler handler, final double maxCheckInterval, final double convergence, final int maxIterationCount) {\n        addEventHandler(handler, maxCheckInterval, convergence,\n                        maxIterationCount,\n                        new BracketingNthOrderBrentSolver(convergence, 5));\n    }\n\n    \n    public void addEventHandler(final EventHandler handler, final double maxCheckInterval, final double convergence, final int maxIterationCount, final UnivariateRealSolver solver) {\n        eventsStates.add(new EventState(handler, maxCheckInterval, convergence,\n                                        maxIterationCount, solver));\n    }\n\n    \n    public Collection<EventHandler> getEventHandlers() {\n        final List<EventHandler> list = new ArrayList<EventHandler>();\n        for (EventState state : eventsStates) {\n            list.add(state.getEventHandler());\n        }\n        return Collections.unmodifiableCollection(list);\n    }\n\n    \n    public void clearEventHandlers() {\n        eventsStates.clear();\n    }\n\n    \n    public double getCurrentStepStart() {\n        return stepStart;\n    }\n\n    \n    public double getCurrentSignedStepsize() {\n        return stepSize;\n    }\n\n    \n    public void setMaxEvaluations(int maxEvaluations) {\n        evaluations.setMaximalCount((maxEvaluations < 0) ? Integer.MAX_VALUE : maxEvaluations);\n    }\n\n    \n    public int getMaxEvaluations() {\n        return evaluations.getMaximalCount();\n    }\n\n    \n    public int getEvaluations() {\n        return evaluations.getCount();\n    }\n\n    \n    protected void resetEvaluations() {\n        evaluations.resetCount();\n    }\n\n    \n    protected void setEquations(final ExpandableStatefulODE equations) {\n        this.expandable = equations;\n    }\n\n    \n    public double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws MathIllegalStateException, MathIllegalArgumentException {\n\n        if (y0.length != equations.getDimension()) {\n            throw new DimensionMismatchException(y0.length, equations.getDimension());\n        }\n        if (y.length != equations.getDimension()) {\n            throw new DimensionMismatchException(y.length, equations.getDimension());\n        }\n\n        \n        final ExpandableStatefulODE expandableODE = new ExpandableStatefulODE(equations);\n        expandableODE.setTime(t0);\n        expandableODE.setPrimaryState(y0);\n\n        \n        integrate(expandableODE, t);\n\n        \n        System.arraycopy(expandableODE.getPrimaryState(), 0, y, 0, y.length);\n        return expandableODE.getTime();\n\n    }\n\n    \n    public abstract void integrate(ExpandableStatefulODE equations, double t) throws MathIllegalStateException, MathIllegalArgumentException; public void computeDerivatives(final double t, final double[] y, final double[] yDot) throws MaxCountExceededException {\n        evaluations.incrementCount();\n        expandable.computeDerivatives(t, y, yDot);\n    }\n\n    \n    protected void setStateInitialized(final boolean stateInitialized) {\n        this.statesInitialized = stateInitialized;\n    }\n\n    \n    protected double acceptStep(final AbstractStepInterpolator interpolator, final double[] y, final double[] yDot, final double tEnd) throws MathIllegalStateException {\n\n            double previousT = interpolator.getGlobalPreviousTime();\n            final double currentT = interpolator.getGlobalCurrentTime();\n\n            \n            if (! statesInitialized) {\n                for (EventState state : eventsStates) {\n                    state.reinitializeBegin(interpolator);\n                }\n                statesInitialized = true;\n            }\n\n            \n            final int orderingSign = interpolator.isForward() ? +1 : -1;\n            SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n\n                \n                public int compare(EventState es0, EventState es1) {\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n\n            });\n\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    \n                    occuringEvents.add(state);\n                }\n            }\n\n            while (!occuringEvents.isEmpty()) {\n\n                \n                final Iterator<EventState> iterator = occuringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove();\n\n                \n                final double eventT = currentEvent.getEventTime();\n                interpolator.setSoftPreviousTime(previousT);\n                interpolator.setSoftCurrentTime(eventT);\n\n                \n                interpolator.setInterpolatedTime(eventT);\n                final double[] eventY = interpolator.getInterpolatedState();\n                currentEvent.stepAccepted(eventT, eventY);\n                isLastStep = currentEvent.stop();\n\n                \n                for (final StepHandler handler : stepHandlers) {\n                    handler.handleStep(interpolator, isLastStep);\n                }\n\n                if (isLastStep) {\n                    \n                    System.arraycopy(eventY, 0, y, 0, y.length);\n                    for (final EventState remaining : occuringEvents) {\n                        remaining.stepAccepted(eventT, eventY);\n                    }\n                    return eventT;\n                }\n\n                if (currentEvent.reset(eventT, eventY)) {\n                    \n                    \n                    System.arraycopy(eventY, 0, y, 0, y.length);\n                    computeDerivatives(eventT, y, yDot);\n                    resetOccurred = true;\n                    for (final EventState remaining : occuringEvents) {\n                        remaining.stepAccepted(eventT, eventY);\n                    }\n                    return eventT;\n                }\n\n                \n                previousT = eventT;\n                interpolator.setSoftPreviousTime(eventT);\n                interpolator.setSoftCurrentTime(currentT);\n\n                \n                if (currentEvent.evaluateStep(interpolator)) {\n                    \n                    occuringEvents.add(currentEvent);\n                }\n\n            }\n\n            interpolator.setInterpolatedTime(currentT);\n            final double[] currentY = interpolator.getInterpolatedState();\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(currentT, currentY);\n                isLastStep = isLastStep || state.stop();\n            }\n            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n\n            \n            for (StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n\n            return currentT;\n\n    }\n\n    \n    protected void sanityChecks(final ExpandableStatefulODE equations, final double t) throws NumberIsTooSmallException {\n\n        final double threshold = 1000 * FastMath.ulp(FastMath.max(FastMath.abs(equations.getTime()),\n                                                                  FastMath.abs(t)));\n        final double dt = FastMath.abs(equations.getTime() - t);\n        if (dt <= threshold) {\n            throw new NumberIsTooSmallException(LocalizedFormats.TOO_SMALL_INTEGRATION_INTERVAL,\n                                                dt, threshold, false);\n        }\n\n    }\n\n}\n",
      "buggy_signatures": [
        "public abstract class AbstractIntegrator implements FirstOrderIntegrator { protected Collection<StepHandler> stepHandlers; protected double stepStart; protected double stepSize; protected boolean isLastStep; protected boolean resetOccurred; private Collection<EventState> eventsStates; private boolean statesInitialized; private final String name; private Incrementor evaluations; private transient ExpandableStatefulODE expandable; public AbstractIntegrator(final String name)",
        "protected AbstractIntegrator()",
        "public String getName()",
        "public void addStepHandler(final StepHandler handler)",
        "public Collection<StepHandler> getStepHandlers()",
        "public void clearStepHandlers()",
        "public void addEventHandler(final EventHandler handler, final double maxCheckInterval, final double convergence, final int maxIterationCount)",
        "public void addEventHandler(final EventHandler handler, final double maxCheckInterval, final double convergence, final int maxIterationCount, final UnivariateRealSolver solver)",
        "public Collection<EventHandler> getEventHandlers()",
        "public void clearEventHandlers()",
        "public double getCurrentStepStart()",
        "public double getCurrentSignedStepsize()",
        "public void setMaxEvaluations(int maxEvaluations)",
        "public int getMaxEvaluations()",
        "public int getEvaluations()",
        "protected void resetEvaluations()",
        "protected void setEquations(final ExpandableStatefulODE equations)",
        "public double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws MathIllegalStateException, MathIllegalArgumentException",
        "public abstract void integrate(ExpandableStatefulODE equations, double t) throws MathIllegalStateException, MathIllegalArgumentException; public void computeDerivatives(final double t, final double[] y, final double[] yDot) throws MaxCountExceededException",
        "protected void setStateInitialized(final boolean stateInitialized)",
        "protected double acceptStep(final AbstractStepInterpolator interpolator, final double[] y, final double[] yDot, final double tEnd) throws MathIllegalStateException",
        "public int compare(EventState es0, EventState es1)",
        "protected void sanityChecks(final ExpandableStatefulODE equations, final double t) throws NumberIsTooSmallException"
      ],
      "fixed_signatures": [
        "public abstract class AbstractIntegrator implements FirstOrderIntegrator { protected Collection<StepHandler> stepHandlers; protected double stepStart; protected double stepSize; protected boolean isLastStep; protected boolean resetOccurred; private Collection<EventState> eventsStates; private boolean statesInitialized; private final String name; private Incrementor evaluations; private transient ExpandableStatefulODE expandable; public AbstractIntegrator(final String name)",
        "protected AbstractIntegrator()",
        "public String getName()",
        "public void addStepHandler(final StepHandler handler)",
        "public Collection<StepHandler> getStepHandlers()",
        "public void clearStepHandlers()",
        "public void addEventHandler(final EventHandler handler, final double maxCheckInterval, final double convergence, final int maxIterationCount)",
        "public void addEventHandler(final EventHandler handler, final double maxCheckInterval, final double convergence, final int maxIterationCount, final UnivariateRealSolver solver)",
        "public Collection<EventHandler> getEventHandlers()",
        "public void clearEventHandlers()",
        "public double getCurrentStepStart()",
        "public double getCurrentSignedStepsize()",
        "public void setMaxEvaluations(int maxEvaluations)",
        "public int getMaxEvaluations()",
        "public int getEvaluations()",
        "protected void resetEvaluations()",
        "protected void setEquations(final ExpandableStatefulODE equations)",
        "public double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws MathIllegalStateException, MathIllegalArgumentException",
        "public abstract void integrate(ExpandableStatefulODE equations, double t) throws MathIllegalStateException, MathIllegalArgumentException; public void computeDerivatives(final double t, final double[] y, final double[] yDot) throws MaxCountExceededException",
        "protected void setStateInitialized(final boolean stateInitialized)",
        "protected double acceptStep(final AbstractStepInterpolator interpolator, final double[] y, final double[] yDot, final double tEnd) throws MathIllegalStateException",
        "public int compare(EventState es0, EventState es1)",
        "protected void sanityChecks(final ExpandableStatefulODE equations, final double t) throws NumberIsTooSmallException"
      ],
      "methods": [
        {
          "buggy_method": "  protected double acceptStep(final AbstractStepInterpolator interpolator, final double[] y, final double[] yDot, final double tEnd) throws MathIllegalStateException {\n\n  double previousT = interpolator.getGlobalPreviousTime();\n  final double currentT = interpolator.getGlobalCurrentTime();\n  resetOccurred = false;\n\n  \n  if (! statesInitialized) {\n  for (EventState state : eventsStates) {\n  state.reinitializeBegin(interpolator);\n  }\n  statesInitialized = true;\n  }\n\n  \n  final int orderingSign = interpolator.isForward() ? +1 : -1;\n  SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n\n  \n  public int compare(EventState es0, EventState es1) {\n  return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n  }\n\n  });\n\n  for (final EventState state : eventsStates) {\n  if (state.evaluateStep(interpolator)) {\n  \n  occuringEvents.add(state);\n  }\n  }\n\n  while (!occuringEvents.isEmpty()) {\n\n  \n  final Iterator<EventState> iterator = occuringEvents.iterator();\n  final EventState currentEvent = iterator.next();\n  iterator.remove();\n\n  \n  final double eventT = currentEvent.getEventTime();\n  interpolator.setSoftPreviousTime(previousT);\n  interpolator.setSoftCurrentTime(eventT);\n\n  \n  interpolator.setInterpolatedTime(eventT);\n  final double[] eventY = interpolator.getInterpolatedState();\n  currentEvent.stepAccepted(eventT, eventY);\n  isLastStep = currentEvent.stop();\n\n  \n  for (final StepHandler handler : stepHandlers) {\n  handler.handleStep(interpolator, isLastStep);\n  }\n\n  if (isLastStep) {\n  \n  System.arraycopy(eventY, 0, y, 0, y.length);\n  return eventT;\n  }\n\n  if (currentEvent.reset(eventT, eventY)) {\n  \n  \n  System.arraycopy(eventY, 0, y, 0, y.length);\n  computeDerivatives(eventT, y, yDot);\n  resetOccurred = true;\n  return eventT;\n  }\n\n  \n  previousT = eventT;\n  interpolator.setSoftPreviousTime(eventT);\n  interpolator.setSoftCurrentTime(currentT);\n\n  \n  if (currentEvent.evaluateStep(interpolator)) {\n  \n  occuringEvents.add(currentEvent);\n  }\n\n  }\n\n  interpolator.setInterpolatedTime(currentT);\n  final double[] currentY = interpolator.getInterpolatedState();\n  for (final EventState state : eventsStates) {\n  state.stepAccepted(currentT, currentY);\n  isLastStep = isLastStep || state.stop();\n  }\n  isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n\n  \n  for (StepHandler handler : stepHandlers) {\n  handler.handleStep(interpolator, isLastStep);\n  }\n\n  return currentT;\n\n  }",
          "fixed_method": "  protected double acceptStep(final AbstractStepInterpolator interpolator, final double[] y, final double[] yDot, final double tEnd) throws MathIllegalStateException {\n\n  double previousT = interpolator.getGlobalPreviousTime();\n  final double currentT = interpolator.getGlobalCurrentTime();\n\n  \n  if (! statesInitialized) {\n  for (EventState state : eventsStates) {\n  state.reinitializeBegin(interpolator);\n  }\n  statesInitialized = true;\n  }\n\n  \n  final int orderingSign = interpolator.isForward() ? +1 : -1;\n  SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n\n  \n  public int compare(EventState es0, EventState es1) {\n  return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n  }\n\n  });\n\n  for (final EventState state : eventsStates) {\n  if (state.evaluateStep(interpolator)) {\n  \n  occuringEvents.add(state);\n  }\n  }\n\n  while (!occuringEvents.isEmpty()) {\n\n  \n  final Iterator<EventState> iterator = occuringEvents.iterator();\n  final EventState currentEvent = iterator.next();\n  iterator.remove();\n\n  \n  final double eventT = currentEvent.getEventTime();\n  interpolator.setSoftPreviousTime(previousT);\n  interpolator.setSoftCurrentTime(eventT);\n\n  \n  interpolator.setInterpolatedTime(eventT);\n  final double[] eventY = interpolator.getInterpolatedState();\n  currentEvent.stepAccepted(eventT, eventY);\n  isLastStep = currentEvent.stop();\n\n  \n  for (final StepHandler handler : stepHandlers) {\n  handler.handleStep(interpolator, isLastStep);\n  }\n\n  if (isLastStep) {\n  \n  System.arraycopy(eventY, 0, y, 0, y.length);\n  for (final EventState remaining : occuringEvents) {\n  remaining.stepAccepted(eventT, eventY);\n  }\n  return eventT;\n  }\n\n  if (currentEvent.reset(eventT, eventY)) {\n  \n  \n  System.arraycopy(eventY, 0, y, 0, y.length);\n  computeDerivatives(eventT, y, yDot);\n  resetOccurred = true;\n  for (final EventState remaining : occuringEvents) {\n  remaining.stepAccepted(eventT, eventY);\n  }\n  return eventT;\n  }\n\n  \n  previousT = eventT;\n  interpolator.setSoftPreviousTime(eventT);\n  interpolator.setSoftCurrentTime(currentT);\n\n  \n  if (currentEvent.evaluateStep(interpolator)) {\n  \n  occuringEvents.add(currentEvent);\n  }\n\n  }\n\n  interpolator.setInterpolatedTime(currentT);\n  final double[] currentY = interpolator.getInterpolatedState();\n  for (final EventState state : eventsStates) {\n  state.stepAccepted(currentT, currentY);\n  isLastStep = isLastStep || state.stop();\n  }\n  isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n\n  \n  for (StepHandler handler : stepHandlers) {\n  handler.handleStep(interpolator, isLastStep);\n  }\n\n  return currentT;\n\n  }",
          "diff": [
            "@@ -277,7 +277,6 @@",
            " \n",
            "             double previousT = interpolator.getGlobalPreviousTime();\n",
            "             final double currentT = interpolator.getGlobalCurrentTime();\n",
            "-            resetOccurred = false;\n",
            " \n",
            "             // initialize the events states if needed\n",
            "             if (! statesInitialized) {\n"
          ],
          "changed_lines": 1
        },
        {
          "buggy_method": "  public int compare(EventState es0, EventState es1) {\n  return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n  }",
          "fixed_method": "  public int compare(EventState es0, EventState es1) {\n  return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n  }",
          "diff": [
            "@@ -331,6 +330,9 @@",
            "                 if (isLastStep) {\n",
            "                     // the event asked to stop integration\n",
            "                     System.arraycopy(eventY, 0, y, 0, y.length);\n",
            "+                    for (final EventState remaining : occuringEvents) {\n",
            "+                        remaining.stepAccepted(eventT, eventY);\n",
            "+                    }\n",
            "                     return eventT;\n",
            "                 }\n",
            " \n",
            "@@ -340,6 +342,9 @@",
            "                     System.arraycopy(eventY, 0, y, 0, y.length);\n",
            "                     computeDerivatives(eventT, y, yDot);\n",
            "                     resetOccurred = true;\n",
            "+                    for (final EventState remaining : occuringEvents) {\n",
            "+                        remaining.stepAccepted(eventT, eventY);\n",
            "+                    }\n",
            "                     return eventT;\n",
            "                 }\n",
            " \n"
          ],
          "changed_lines": 6
        }
      ]
    }
  ]
}
