{
  "bug_id": "24",
  "failed_tests": {
    "org.joda.time.format.TestDateTimeFormatter": [
      {
        "methodName": "testParseLocalDate_weekyear_month_week_2010",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<2010-01-04> but was:<2008-12-29>",
        "fail_line": "        assertEquals(new LocalDate(2010, 1, 4, chrono), f.parseLocalDate(\"2010-01-01\"));",
        "test_source": "  public void testParseLocalDate_weekyear_month_week_2010() {\n  Chronology chrono = GJChronology.getInstanceUTC();\n  DateTimeFormatter f = DateTimeFormat.forPattern(\"xxxx-MM-ww\").withChronology(chrono);\n  assertEquals(new LocalDate(2010, 1, 4, chrono), f.parseLocalDate(\"2010-01-01\"));\n  }",
        "stack": [
          "TestDateTimeFormatter.testParseLocalDate_weekyear_month_week_2010 line 428"
        ]
      },
      {
        "methodName": "testParseLocalDate_weekyear_month_week_2011",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<2011-01-03> but was:<2010-01-04>",
        "fail_line": "        assertEquals(new LocalDate(2011, 1, 3, chrono), f.parseLocalDate(\"2011-01-01\"));",
        "test_source": "  public void testParseLocalDate_weekyear_month_week_2011() {\n  Chronology chrono = GJChronology.getInstanceUTC();\n  DateTimeFormatter f = DateTimeFormat.forPattern(\"xxxx-MM-ww\").withChronology(chrono);\n  assertEquals(new LocalDate(2011, 1, 3, chrono), f.parseLocalDate(\"2011-01-01\"));\n  }",
        "stack": [
          "TestDateTimeFormatter.testParseLocalDate_weekyear_month_week_2011 line 434"
        ]
      },
      {
        "methodName": "testParseLocalDate_weekyear_month_week_2012",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<2012-01-02> but was:<2011-01-03>",
        "fail_line": "        assertEquals(new LocalDate(2012, 1, 2, chrono), f.parseLocalDate(\"2012-01-01\"));",
        "test_source": "  public void testParseLocalDate_weekyear_month_week_2012() {\n  Chronology chrono = GJChronology.getInstanceUTC();\n  DateTimeFormatter f = DateTimeFormat.forPattern(\"xxxx-MM-ww\").withChronology(chrono);\n  assertEquals(new LocalDate(2012, 1, 2, chrono), f.parseLocalDate(\"2012-01-01\"));\n  }",
        "stack": [
          "TestDateTimeFormatter.testParseLocalDate_weekyear_month_week_2012 line 440"
        ]
      },
      {
        "methodName": "testParseLocalDate_year_month_week_2010",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<2010-01-04> but was:<2008-12-29>",
        "fail_line": "        assertEquals(new LocalDate(2010, 1, 4, chrono), f.parseLocalDate(\"2010-01-01\"));",
        "test_source": "  public void testParseLocalDate_year_month_week_2010() {\n  Chronology chrono = GJChronology.getInstanceUTC();\n  DateTimeFormatter f = DateTimeFormat.forPattern(\"yyyy-MM-ww\").withChronology(chrono);\n  assertEquals(new LocalDate(2010, 1, 4, chrono), f.parseLocalDate(\"2010-01-01\"));\n  }",
        "stack": [
          "TestDateTimeFormatter.testParseLocalDate_year_month_week_2010 line 454"
        ]
      },
      {
        "methodName": "testParseLocalDate_year_month_week_2011",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<2011-01-03> but was:<2010-01-04>",
        "fail_line": "        assertEquals(new LocalDate(2011, 1, 3, chrono), f.parseLocalDate(\"2011-01-01\"));",
        "test_source": "  public void testParseLocalDate_year_month_week_2011() {\n  Chronology chrono = GJChronology.getInstanceUTC();\n  DateTimeFormatter f = DateTimeFormat.forPattern(\"yyyy-MM-ww\").withChronology(chrono);\n  assertEquals(new LocalDate(2011, 1, 3, chrono), f.parseLocalDate(\"2011-01-01\"));\n  }",
        "stack": [
          "TestDateTimeFormatter.testParseLocalDate_year_month_week_2011 line 460"
        ]
      },
      {
        "methodName": "testParseLocalDate_year_month_week_2012",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<2012-01-02> but was:<2011-01-03>",
        "fail_line": "        assertEquals(new LocalDate(2012, 1, 2, chrono), f.parseLocalDate(\"2012-01-01\"));",
        "test_source": "  public void testParseLocalDate_year_month_week_2012() {\n  Chronology chrono = GJChronology.getInstanceUTC();\n  DateTimeFormatter f = DateTimeFormat.forPattern(\"yyyy-MM-ww\").withChronology(chrono);\n  assertEquals(new LocalDate(2012, 1, 2, chrono), f.parseLocalDate(\"2012-01-01\"));\n  }",
        "stack": [
          "TestDateTimeFormatter.testParseLocalDate_year_month_week_2012 line 466"
        ]
      },
      {
        "methodName": "testParseLocalDate_year_month_week_2016",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<2016-01-04> but was:<2014-12-29>",
        "fail_line": "        assertEquals(new LocalDate(2016, 1, 4, chrono), f.parseLocalDate(\"2016-01-01\"));",
        "test_source": "  public void testParseLocalDate_year_month_week_2016() {\n  Chronology chrono = GJChronology.getInstanceUTC();\n  DateTimeFormatter f = DateTimeFormat.forPattern(\"yyyy-MM-ww\").withChronology(chrono);\n  assertEquals(new LocalDate(2016, 1, 4, chrono), f.parseLocalDate(\"2016-01-01\"));\n  }",
        "stack": [
          "TestDateTimeFormatter.testParseLocalDate_year_month_week_2016 line 490"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/joda/time/format/DateTimeParserBucket.java",
      "buggy_full_code": "\npackage org.joda.time.format;\n\nimport java.util.Arrays;\nimport java.util.Locale;\n\nimport org.joda.time.Chronology;\nimport org.joda.time.DateTimeField;\nimport org.joda.time.DateTimeFieldType;\nimport org.joda.time.DateTimeUtils;\nimport org.joda.time.DateTimeZone;\nimport org.joda.time.DurationField;\nimport org.joda.time.DurationFieldType;\nimport org.joda.time.IllegalFieldValueException;\n\n\npublic class DateTimeParserBucket { private final Chronology iChrono; private final long iMillis; private DateTimeZone iZone; private int iOffset; private Locale iLocale; private Integer iPivotYear; private int iDefaultYear; private SavedField[] iSavedFields = new SavedField[8]; private int iSavedFieldsCount; private boolean iSavedFieldsShared; private Object iSavedState; @Deprecated public DateTimeParserBucket(long instantLocal, Chronology chrono, Locale locale) {\n        this(instantLocal, chrono, locale, null, 2000);\n    }\n\n    \n    @Deprecated\n    public DateTimeParserBucket(long instantLocal, Chronology chrono, Locale locale, Integer pivotYear) {\n        this(instantLocal, chrono, locale, pivotYear, 2000);\n    }\n\n    \n    public DateTimeParserBucket(long instantLocal, Chronology chrono, Locale locale, Integer pivotYear, int defaultYear) {\n        super();\n        chrono = DateTimeUtils.getChronology(chrono);\n        iMillis = instantLocal;\n        iChrono = chrono.withUTC();\n        iLocale = (locale == null ? Locale.getDefault() : locale);\n        setZone(chrono.getZone());\n        iPivotYear = pivotYear;\n        iDefaultYear = defaultYear;\n    }\n\n    \n    \n    public Chronology getChronology() {\n        return iChrono;\n    }\n\n    \n    \n    public Locale getLocale() {\n        return iLocale;\n    }\n\n    \n    \n    public DateTimeZone getZone() {\n        return iZone;\n    }\n    \n    \n    public void setZone(DateTimeZone zone) {\n        iSavedState = null;\n        iZone = zone == DateTimeZone.UTC ? null : zone;\n        iOffset = 0;\n    }\n    \n    \n    \n    public int getOffset() {\n        return iOffset;\n    }\n    \n    \n    public void setOffset(int offset) {\n        iSavedState = null;\n        iOffset = offset;\n        iZone = null;\n    }\n\n    \n    \n    public Integer getPivotYear() {\n        return iPivotYear;\n    }\n\n    \n    public void setPivotYear(Integer pivotYear) {\n        iPivotYear = pivotYear;\n    }\n\n    \n    \n    public void saveField(DateTimeField field, int value) {\n        saveField(new SavedField(field, value));\n    }\n    \n    \n    public void saveField(DateTimeFieldType fieldType, int value) {\n        saveField(new SavedField(fieldType.getField(iChrono), value));\n    }\n    \n    \n    public void saveField(DateTimeFieldType fieldType, String text, Locale locale) {\n        saveField(new SavedField(fieldType.getField(iChrono), text, locale));\n    }\n    \n    private void saveField(SavedField field) {\n        SavedField[] savedFields = iSavedFields;\n        int savedFieldsCount = iSavedFieldsCount;\n        \n        if (savedFieldsCount == savedFields.length || iSavedFieldsShared) {\n            \n            SavedField[] newArray = new SavedField\n                [savedFieldsCount == savedFields.length ? savedFieldsCount * 2 : savedFields.length];\n            System.arraycopy(savedFields, 0, newArray, 0, savedFieldsCount);\n            iSavedFields = savedFields = newArray;\n            iSavedFieldsShared = false;\n        }\n        \n        iSavedState = null;\n        savedFields[savedFieldsCount] = field;\n        iSavedFieldsCount = savedFieldsCount + 1;\n    }\n    \n    \n    public Object saveState() {\n        if (iSavedState == null) {\n            iSavedState = new SavedState();\n        }\n        return iSavedState;\n    }\n    \n    \n    public boolean restoreState(Object savedState) {\n        if (savedState instanceof SavedState) {\n            if (((SavedState) savedState).restoreState(this)) {\n                iSavedState = savedState;\n                return true;\n            }\n        }\n        return false;\n    }\n    \n    \n    public long computeMillis() {\n        return computeMillis(false, null);\n    }\n    \n    \n    public long computeMillis(boolean resetFields) {\n        return computeMillis(resetFields, null);\n    }\n\n    \n    public long computeMillis(boolean resetFields, String text) {\n        SavedField[] savedFields = iSavedFields;\n        int count = iSavedFieldsCount;\n        if (iSavedFieldsShared) {\n            iSavedFields = savedFields = (SavedField[])iSavedFields.clone();\n            iSavedFieldsShared = false;\n        }\n        sort(savedFields, count);\n        if (count > 0) {\n            \n            DurationField months = DurationFieldType.months().getField(iChrono);\n            DurationField days = DurationFieldType.days().getField(iChrono);\n            DurationField first = savedFields[0].iField.getDurationField();\n            if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) {\n                saveField(DateTimeFieldType.year(), iDefaultYear);\n                return computeMillis(resetFields, text);\n            }\n        }\n\n        long millis = iMillis;\n        try {\n            for (int i = 0; i < count; i++) {\n                millis = savedFields[i].set(millis, resetFields);\n            }\n        } catch (IllegalFieldValueException e) {\n            if (text != null) {\n                e.prependMessage(\"Cannot parse \\\"\" + text + '\"');\n            }\n            throw e;\n        }\n        \n        if (iZone == null) {\n            millis -= iOffset;\n        } else {\n            int offset = iZone.getOffsetFromLocal(millis);\n            millis -= offset;\n            if (offset != iZone.getOffset(millis)) {\n                String message =\n                    \"Illegal instant due to time zone offset transition (\" + iZone + ')';\n                if (text != null) {\n                    message = \"Cannot parse \\\"\" + text + \"\\\": \" + message;\n                }\n                throw new IllegalArgumentException(message);\n            }\n        }\n        \n        return millis;\n    }\n    \n    \n    private static void sort(SavedField[] array, int high) {\n        if (high > 10) {\n            Arrays.sort(array, 0, high);\n        } else {\n            for (int i=0; i<high; i++) {\n                for (int j=i; j>0 && (array[j-1]).compareTo(array[j])>0; j--) {\n                    SavedField t = array[j];\n                    array[j] = array[j-1];\n                    array[j-1] = t;\n                }\n            }\n        }\n    }\n\n    class SavedState {\n        final DateTimeZone iZone;\n        final int iOffset;\n        final SavedField[] iSavedFields;\n        final int iSavedFieldsCount;\n        \n        SavedState() {\n            this.iZone = DateTimeParserBucket.this.iZone;\n            this.iOffset = DateTimeParserBucket.this.iOffset;\n            this.iSavedFields = DateTimeParserBucket.this.iSavedFields;\n            this.iSavedFieldsCount = DateTimeParserBucket.this.iSavedFieldsCount;\n        }\n        \n        boolean restoreState(DateTimeParserBucket enclosing) {\n            if (enclosing != DateTimeParserBucket.this) {\n                return false;\n            }\n            enclosing.iZone = this.iZone;\n            enclosing.iOffset = this.iOffset;\n            enclosing.iSavedFields = this.iSavedFields;\n            if (this.iSavedFieldsCount < enclosing.iSavedFieldsCount) {\n                \n                \n                \n                \n                enclosing.iSavedFieldsShared = true;\n            }\n            enclosing.iSavedFieldsCount = this.iSavedFieldsCount;\n            return true;\n        }\n    }\n    \n    static class SavedField implements Comparable<SavedField> { final DateTimeField iField; final int iValue; final String iText; final Locale iLocale; SavedField(DateTimeField field, int value) {\n            iField = field;\n            iValue = value;\n            iText = null;\n            iLocale = null;\n        }\n        \n        SavedField(DateTimeField field, String text, Locale locale) {\n            iField = field;\n            iValue = 0;\n            iText = text;\n            iLocale = locale;\n        }\n        \n        long set(long millis, boolean reset) {\n            if (iText == null) {\n                millis = iField.set(millis, iValue);\n            } else {\n                millis = iField.set(millis, iText, iLocale);\n            }\n            if (reset) {\n                millis = iField.roundFloor(millis);\n            }\n            return millis;\n        }\n        \n        \n        public int compareTo(SavedField obj) {\n            DateTimeField other = obj.iField;\n            int result = compareReverse\n                (iField.getRangeDurationField(), other.getRangeDurationField());\n            if (result != 0) {\n                return result;\n            }\n            return compareReverse\n                (iField.getDurationField(), other.getDurationField());\n        }\n    }\n\n    static int compareReverse(DurationField a, DurationField b) {\n        if (a == null || !a.isSupported()) {\n            if (b == null || !b.isSupported()) {\n                return 0;\n            }\n            return -1;\n        }\n        if (b == null || !b.isSupported()) {\n            return 1;\n        }\n        return -a.compareTo(b);\n    }\n}\n",
      "fixed_full_code": "\npackage org.joda.time.format;\n\nimport java.util.Arrays;\nimport java.util.Locale;\n\nimport org.joda.time.Chronology;\nimport org.joda.time.DateTimeField;\nimport org.joda.time.DateTimeFieldType;\nimport org.joda.time.DateTimeUtils;\nimport org.joda.time.DateTimeZone;\nimport org.joda.time.DurationField;\nimport org.joda.time.DurationFieldType;\nimport org.joda.time.IllegalFieldValueException;\n\n\npublic class DateTimeParserBucket { private final Chronology iChrono; private final long iMillis; private DateTimeZone iZone; private int iOffset; private Locale iLocale; private Integer iPivotYear; private int iDefaultYear; private SavedField[] iSavedFields = new SavedField[8]; private int iSavedFieldsCount; private boolean iSavedFieldsShared; private Object iSavedState; @Deprecated public DateTimeParserBucket(long instantLocal, Chronology chrono, Locale locale) {\n        this(instantLocal, chrono, locale, null, 2000);\n    }\n\n    \n    @Deprecated\n    public DateTimeParserBucket(long instantLocal, Chronology chrono, Locale locale, Integer pivotYear) {\n        this(instantLocal, chrono, locale, pivotYear, 2000);\n    }\n\n    \n    public DateTimeParserBucket(long instantLocal, Chronology chrono, Locale locale, Integer pivotYear, int defaultYear) {\n        super();\n        chrono = DateTimeUtils.getChronology(chrono);\n        iMillis = instantLocal;\n        iChrono = chrono.withUTC();\n        iLocale = (locale == null ? Locale.getDefault() : locale);\n        setZone(chrono.getZone());\n        iPivotYear = pivotYear;\n        iDefaultYear = defaultYear;\n    }\n\n    \n    \n    public Chronology getChronology() {\n        return iChrono;\n    }\n\n    \n    \n    public Locale getLocale() {\n        return iLocale;\n    }\n\n    \n    \n    public DateTimeZone getZone() {\n        return iZone;\n    }\n    \n    \n    public void setZone(DateTimeZone zone) {\n        iSavedState = null;\n        iZone = zone == DateTimeZone.UTC ? null : zone;\n        iOffset = 0;\n    }\n    \n    \n    \n    public int getOffset() {\n        return iOffset;\n    }\n    \n    \n    public void setOffset(int offset) {\n        iSavedState = null;\n        iOffset = offset;\n        iZone = null;\n    }\n\n    \n    \n    public Integer getPivotYear() {\n        return iPivotYear;\n    }\n\n    \n    public void setPivotYear(Integer pivotYear) {\n        iPivotYear = pivotYear;\n    }\n\n    \n    \n    public void saveField(DateTimeField field, int value) {\n        saveField(new SavedField(field, value));\n    }\n    \n    \n    public void saveField(DateTimeFieldType fieldType, int value) {\n        saveField(new SavedField(fieldType.getField(iChrono), value));\n    }\n    \n    \n    public void saveField(DateTimeFieldType fieldType, String text, Locale locale) {\n        saveField(new SavedField(fieldType.getField(iChrono), text, locale));\n    }\n    \n    private void saveField(SavedField field) {\n        SavedField[] savedFields = iSavedFields;\n        int savedFieldsCount = iSavedFieldsCount;\n        \n        if (savedFieldsCount == savedFields.length || iSavedFieldsShared) {\n            \n            SavedField[] newArray = new SavedField\n                [savedFieldsCount == savedFields.length ? savedFieldsCount * 2 : savedFields.length];\n            System.arraycopy(savedFields, 0, newArray, 0, savedFieldsCount);\n            iSavedFields = savedFields = newArray;\n            iSavedFieldsShared = false;\n        }\n        \n        iSavedState = null;\n        savedFields[savedFieldsCount] = field;\n        iSavedFieldsCount = savedFieldsCount + 1;\n    }\n    \n    \n    public Object saveState() {\n        if (iSavedState == null) {\n            iSavedState = new SavedState();\n        }\n        return iSavedState;\n    }\n    \n    \n    public boolean restoreState(Object savedState) {\n        if (savedState instanceof SavedState) {\n            if (((SavedState) savedState).restoreState(this)) {\n                iSavedState = savedState;\n                return true;\n            }\n        }\n        return false;\n    }\n    \n    \n    public long computeMillis() {\n        return computeMillis(false, null);\n    }\n    \n    \n    public long computeMillis(boolean resetFields) {\n        return computeMillis(resetFields, null);\n    }\n\n    \n    public long computeMillis(boolean resetFields, String text) {\n        SavedField[] savedFields = iSavedFields;\n        int count = iSavedFieldsCount;\n        if (iSavedFieldsShared) {\n            iSavedFields = savedFields = (SavedField[])iSavedFields.clone();\n            iSavedFieldsShared = false;\n        }\n        sort(savedFields, count);\n        if (count > 0) {\n            \n            DurationField months = DurationFieldType.months().getField(iChrono);\n            DurationField days = DurationFieldType.days().getField(iChrono);\n            DurationField first = savedFields[0].iField.getDurationField();\n            if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) {\n                saveField(DateTimeFieldType.year(), iDefaultYear);\n                return computeMillis(resetFields, text);\n            }\n        }\n\n        long millis = iMillis;\n        try {\n            for (int i = 0; i < count; i++) {\n                millis = savedFields[i].set(millis, resetFields);\n            }\n            if (resetFields) {\n                for (int i = 0; i < count; i++) {\n                    millis = savedFields[i].set(millis, i == (count - 1));\n                }\n            }\n        } catch (IllegalFieldValueException e) {\n            if (text != null) {\n                e.prependMessage(\"Cannot parse \\\"\" + text + '\"');\n            }\n            throw e;\n        }\n        \n        if (iZone == null) {\n            millis -= iOffset;\n        } else {\n            int offset = iZone.getOffsetFromLocal(millis);\n            millis -= offset;\n            if (offset != iZone.getOffset(millis)) {\n                String message =\n                    \"Illegal instant due to time zone offset transition (\" + iZone + ')';\n                if (text != null) {\n                    message = \"Cannot parse \\\"\" + text + \"\\\": \" + message;\n                }\n                throw new IllegalArgumentException(message);\n            }\n        }\n        \n        return millis;\n    }\n    \n    \n    private static void sort(SavedField[] array, int high) {\n        if (high > 10) {\n            Arrays.sort(array, 0, high);\n        } else {\n            for (int i=0; i<high; i++) {\n                for (int j=i; j>0 && (array[j-1]).compareTo(array[j])>0; j--) {\n                    SavedField t = array[j];\n                    array[j] = array[j-1];\n                    array[j-1] = t;\n                }\n            }\n        }\n    }\n\n    class SavedState {\n        final DateTimeZone iZone;\n        final int iOffset;\n        final SavedField[] iSavedFields;\n        final int iSavedFieldsCount;\n        \n        SavedState() {\n            this.iZone = DateTimeParserBucket.this.iZone;\n            this.iOffset = DateTimeParserBucket.this.iOffset;\n            this.iSavedFields = DateTimeParserBucket.this.iSavedFields;\n            this.iSavedFieldsCount = DateTimeParserBucket.this.iSavedFieldsCount;\n        }\n        \n        boolean restoreState(DateTimeParserBucket enclosing) {\n            if (enclosing != DateTimeParserBucket.this) {\n                return false;\n            }\n            enclosing.iZone = this.iZone;\n            enclosing.iOffset = this.iOffset;\n            enclosing.iSavedFields = this.iSavedFields;\n            if (this.iSavedFieldsCount < enclosing.iSavedFieldsCount) {\n                \n                \n                \n                \n                enclosing.iSavedFieldsShared = true;\n            }\n            enclosing.iSavedFieldsCount = this.iSavedFieldsCount;\n            return true;\n        }\n    }\n    \n    static class SavedField implements Comparable<SavedField> { final DateTimeField iField; final int iValue; final String iText; final Locale iLocale; SavedField(DateTimeField field, int value) {\n            iField = field;\n            iValue = value;\n            iText = null;\n            iLocale = null;\n        }\n        \n        SavedField(DateTimeField field, String text, Locale locale) {\n            iField = field;\n            iValue = 0;\n            iText = text;\n            iLocale = locale;\n        }\n        \n        long set(long millis, boolean reset) {\n            if (iText == null) {\n                millis = iField.set(millis, iValue);\n            } else {\n                millis = iField.set(millis, iText, iLocale);\n            }\n            if (reset) {\n                millis = iField.roundFloor(millis);\n            }\n            return millis;\n        }\n        \n        \n        public int compareTo(SavedField obj) {\n            DateTimeField other = obj.iField;\n            int result = compareReverse\n                (iField.getRangeDurationField(), other.getRangeDurationField());\n            if (result != 0) {\n                return result;\n            }\n            return compareReverse\n                (iField.getDurationField(), other.getDurationField());\n        }\n    }\n\n    static int compareReverse(DurationField a, DurationField b) {\n        if (a == null || !a.isSupported()) {\n            if (b == null || !b.isSupported()) {\n                return 0;\n            }\n            return -1;\n        }\n        if (b == null || !b.isSupported()) {\n            return 1;\n        }\n        return -a.compareTo(b);\n    }\n}\n",
      "buggy_signatures": [
        "public DateTimeParserBucket(long instantLocal, Chronology chrono, Locale locale, Integer pivotYear)",
        "public DateTimeParserBucket(long instantLocal, Chronology chrono, Locale locale, Integer pivotYear, int defaultYear)",
        "public Chronology getChronology()",
        "public Locale getLocale()",
        "public DateTimeZone getZone()",
        "public void setZone(DateTimeZone zone)",
        "public int getOffset()",
        "public void setOffset(int offset)",
        "public Integer getPivotYear()",
        "public void setPivotYear(Integer pivotYear)",
        "public void saveField(DateTimeField field, int value)",
        "public void saveField(DateTimeFieldType fieldType, int value)",
        "public void saveField(DateTimeFieldType fieldType, String text, Locale locale)",
        "private void saveField(SavedField field)",
        "public Object saveState()",
        "public boolean restoreState(Object savedState)",
        "public long computeMillis()",
        "public long computeMillis(boolean resetFields)",
        "public long computeMillis(boolean resetFields, String text)",
        "private static void sort(SavedField[] array, int high)",
        "static class SavedField implements Comparable<SavedField> { final DateTimeField iField; final int iValue; final String iText; final Locale iLocale; SavedField(DateTimeField field, int value)",
        "public int compareTo(SavedField obj)",
        "static int compareReverse(DurationField a, DurationField b)"
      ],
      "fixed_signatures": [
        "public DateTimeParserBucket(long instantLocal, Chronology chrono, Locale locale, Integer pivotYear)",
        "public DateTimeParserBucket(long instantLocal, Chronology chrono, Locale locale, Integer pivotYear, int defaultYear)",
        "public Chronology getChronology()",
        "public Locale getLocale()",
        "public DateTimeZone getZone()",
        "public void setZone(DateTimeZone zone)",
        "public int getOffset()",
        "public void setOffset(int offset)",
        "public Integer getPivotYear()",
        "public void setPivotYear(Integer pivotYear)",
        "public void saveField(DateTimeField field, int value)",
        "public void saveField(DateTimeFieldType fieldType, int value)",
        "public void saveField(DateTimeFieldType fieldType, String text, Locale locale)",
        "private void saveField(SavedField field)",
        "public Object saveState()",
        "public boolean restoreState(Object savedState)",
        "public long computeMillis()",
        "public long computeMillis(boolean resetFields)",
        "public long computeMillis(boolean resetFields, String text)",
        "private static void sort(SavedField[] array, int high)",
        "static class SavedField implements Comparable<SavedField> { final DateTimeField iField; final int iValue; final String iText; final Locale iLocale; SavedField(DateTimeField field, int value)",
        "public int compareTo(SavedField obj)",
        "static int compareReverse(DurationField a, DurationField b)"
      ],
      "methods": [
        {
          "buggy_method": "  public long computeMillis(boolean resetFields, String text) {\n  SavedField[] savedFields = iSavedFields;\n  int count = iSavedFieldsCount;\n  if (iSavedFieldsShared) {\n  iSavedFields = savedFields = (SavedField[])iSavedFields.clone();\n  iSavedFieldsShared = false;\n  }\n  sort(savedFields, count);\n  if (count > 0) {\n  \n  DurationField months = DurationFieldType.months().getField(iChrono);\n  DurationField days = DurationFieldType.days().getField(iChrono);\n  DurationField first = savedFields[0].iField.getDurationField();\n  if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) {\n  saveField(DateTimeFieldType.year(), iDefaultYear);\n  return computeMillis(resetFields, text);\n  }\n  }\n\n  long millis = iMillis;\n  try {\n  for (int i = 0; i < count; i++) {\n  millis = savedFields[i].set(millis, resetFields);\n  }\n  } catch (IllegalFieldValueException e) {\n  if (text != null) {\n  e.prependMessage(\"Cannot parse \\\"\" + text + '\"');\n  }\n  throw e;\n  }\n  \n  if (iZone == null) {\n  millis -= iOffset;\n  } else {\n  int offset = iZone.getOffsetFromLocal(millis);\n  millis -= offset;\n  if (offset != iZone.getOffset(millis)) {\n  String message =\n  \"Illegal instant due to time zone offset transition (\" + iZone + ')';\n  if (text != null) {\n  message = \"Cannot parse \\\"\" + text + \"\\\": \" + message;\n  }\n  throw new IllegalArgumentException(message);\n  }\n  }\n  \n  return millis;\n  }",
          "fixed_method": "  public long computeMillis(boolean resetFields, String text) {\n  SavedField[] savedFields = iSavedFields;\n  int count = iSavedFieldsCount;\n  if (iSavedFieldsShared) {\n  iSavedFields = savedFields = (SavedField[])iSavedFields.clone();\n  iSavedFieldsShared = false;\n  }\n  sort(savedFields, count);\n  if (count > 0) {\n  \n  DurationField months = DurationFieldType.months().getField(iChrono);\n  DurationField days = DurationFieldType.days().getField(iChrono);\n  DurationField first = savedFields[0].iField.getDurationField();\n  if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) {\n  saveField(DateTimeFieldType.year(), iDefaultYear);\n  return computeMillis(resetFields, text);\n  }\n  }\n\n  long millis = iMillis;\n  try {\n  for (int i = 0; i < count; i++) {\n  millis = savedFields[i].set(millis, resetFields);\n  }\n  if (resetFields) {\n  for (int i = 0; i < count; i++) {\n  millis = savedFields[i].set(millis, i == (count - 1));\n  }\n  }\n  } catch (IllegalFieldValueException e) {\n  if (text != null) {\n  e.prependMessage(\"Cannot parse \\\"\" + text + '\"');\n  }\n  throw e;\n  }\n  \n  if (iZone == null) {\n  millis -= iOffset;\n  } else {\n  int offset = iZone.getOffsetFromLocal(millis);\n  millis -= offset;\n  if (offset != iZone.getOffset(millis)) {\n  String message =\n  \"Illegal instant due to time zone offset transition (\" + iZone + ')';\n  if (text != null) {\n  message = \"Cannot parse \\\"\" + text + \"\\\": \" + message;\n  }\n  throw new IllegalArgumentException(message);\n  }\n  }\n  \n  return millis;\n  }",
          "diff": [
            "@@ -352,6 +352,11 @@",
            "             for (int i = 0; i < count; i++) {\n",
            "                 millis = savedFields[i].set(millis, resetFields);\n",
            "             }\n",
            "+            if (resetFields) {\n",
            "+                for (int i = 0; i < count; i++) {\n",
            "+                    millis = savedFields[i].set(millis, i == (count - 1));\n",
            "+                }\n",
            "+            }\n",
            "         } catch (IllegalFieldValueException e) {\n",
            "             if (text != null) {\n",
            "                 e.prependMessage(\"Cannot parse \\\"\" + text + '\"');\n"
          ],
          "changed_lines": 5
        }
      ]
    }
  ]
}
