{
  "bug_id": "81",
  "failed_tests": {
    "org.jsoup.helper.DataUtilTest": [
      {
        "methodName": "supportsXmlCharsetDeclaration",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<Hell[ö Wö]rld!> but was:<Hell[� W�]rld!>",
        "fail_line": "        assertEquals(\"Hellö Wörld!\", doc.body().text());",
        "test_source": "  public void supportsXmlCharsetDeclaration() throws IOException {\n  String encoding = \"iso-8859-1\";\n  InputStream soup = new ByteArrayInputStream((\n  \"<?xml version=\\\"1.0\\\" encoding=\\\"iso-8859-1\\\"?>\" +\n  \"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Strict//EN\\\" \\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\\\">\" +\n  \"<html xmlns=\\\"http://www.w3.org/1999/xhtml\\\" lang=\\\"en\\\" xml:lang=\\\"en\\\">Hellö Wörld!</html>\"\n  ).getBytes(encoding));\n\n  Document doc = Jsoup.parse(soup, null, \"\");\n  assertEquals(\"Hellö Wörld!\", doc.body().text());\n  }",
        "stack": [
          "DataUtilTest.supportsXmlCharsetDeclaration line 178"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/jsoup/helper/DataUtil.java",
      "buggy_full_code": "package org.jsoup.helper;\n\nimport org.jsoup.UncheckedIOException;\nimport org.jsoup.internal.ConstrainableInputStream;\nimport org.jsoup.nodes.Document;\nimport org.jsoup.nodes.Element;\nimport org.jsoup.nodes.Node;\nimport org.jsoup.nodes.XmlDeclaration;\nimport org.jsoup.parser.Parser;\nimport org.jsoup.select.Elements;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.RandomAccessFile;\nimport java.nio.Buffer;\nimport java.nio.ByteBuffer;\nimport java.nio.charset.Charset;\nimport java.nio.charset.IllegalCharsetNameException;\nimport java.util.Locale;\nimport java.util.Random;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n\npublic final class DataUtil { private static final Pattern charsetPattern = Pattern.compile(\"(?i)\\\\bcharset=\\\\s*(?:[\\\"'])?([^\\\\s,;\\\"']*)\"); static final String defaultCharset = \"UTF-8\"; private static final int firstReadBufferSize = 1024 * 5; static final int bufferSize = 1024 * 32; private static final char[] mimeBoundaryChars = \"-_1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\".toCharArray(); static final int boundaryLength = 32; private DataUtil() {}\n\n    \n    public static Document load(File in, String charsetName, String baseUri) throws IOException {\n        return parseInputStream(new FileInputStream(in), charsetName, baseUri, Parser.htmlParser());\n    }\n\n    \n    public static Document load(InputStream in, String charsetName, String baseUri) throws IOException {\n        return parseInputStream(in, charsetName, baseUri, Parser.htmlParser());\n    }\n\n    \n    public static Document load(InputStream in, String charsetName, String baseUri, Parser parser) throws IOException {\n        return parseInputStream(in, charsetName, baseUri, parser);\n    }\n\n    \n    static void crossStreams(final InputStream in, final OutputStream out) throws IOException {\n        final byte[] buffer = new byte[bufferSize];\n        int len;\n        while ((len = in.read(buffer)) != -1) {\n            out.write(buffer, 0, len);\n        }\n    }\n\n    static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n        if (input == null) \n            return new Document(baseUri);\n        input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n\n        Document doc = null;\n        boolean fullyRead = false;\n\n        \n        input.mark(bufferSize);\n        ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1); \n        fullyRead = input.read() == -1;\n        input.reset();\n\n        \n        BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n        if (bomCharset != null)\n            charsetName = bomCharset.charset;\n\n        if (charsetName == null) { \n            String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n            doc = parser.parseInput(docData, baseUri);\n\n            \n            Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n            String foundCharset = null; \n            for (Element meta : metaElements) {\n                if (meta.hasAttr(\"http-equiv\"))\n                    foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n                if (foundCharset == null && meta.hasAttr(\"charset\"))\n                    foundCharset = meta.attr(\"charset\");\n                if (foundCharset != null)\n                    break;\n            }\n\n            \n            if (foundCharset == null && doc.childNodeSize() > 0) {\n                Node first = doc.childNode(0);\n                XmlDeclaration decl = null;\n                if (first instanceof XmlDeclaration)\n                    decl = (XmlDeclaration) first;\n                if (decl != null) {\n                    if (decl.name().equalsIgnoreCase(\"xml\"))\n                        foundCharset = decl.attr(\"encoding\");\n                }\n            }\n            foundCharset = validateCharset(foundCharset);\n            if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) { \n                foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                charsetName = foundCharset;\n                doc = null;\n            } else if (!fullyRead) {\n                doc = null;\n            }\n        } else { \n            Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        }\n        if (doc == null) {\n            if (charsetName == null)\n                charsetName = defaultCharset;\n            BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n            if (bomCharset != null && bomCharset.offset) \n                reader.skip(1);\n            try {\n                doc = parser.parseInput(reader, baseUri);\n            } catch (UncheckedIOException e) {\n                \n                throw e.ioException();\n            }\n            doc.outputSettings().charset(charsetName);\n        }\n        input.close();\n        return doc;\n    }\n\n    \n    public static ByteBuffer readToByteBuffer(InputStream inStream, int maxSize) throws IOException {\n        Validate.isTrue(maxSize >= 0, \"maxSize must be 0 (unlimited) or larger\");\n        final ConstrainableInputStream input = ConstrainableInputStream.wrap(inStream, bufferSize, maxSize);\n        return input.readToByteBuffer(maxSize);\n    }\n\n    static ByteBuffer readToByteBuffer(InputStream inStream) throws IOException {\n        return readToByteBuffer(inStream, 0);\n    }\n\n    static ByteBuffer readFileToByteBuffer(File file) throws IOException {\n        RandomAccessFile randomAccessFile = null;\n        try {\n            randomAccessFile = new RandomAccessFile(file, \"r\");\n            byte[] bytes = new byte[(int) randomAccessFile.length()];\n            randomAccessFile.readFully(bytes);\n            return ByteBuffer.wrap(bytes);\n        } finally {\n            if (randomAccessFile != null)\n                randomAccessFile.close();\n        }\n    }\n\n    static ByteBuffer emptyByteBuffer() {\n        return ByteBuffer.allocate(0);\n    }\n\n    \n    static String getCharsetFromContentType(String contentType) {\n        if (contentType == null) return null;\n        Matcher m = charsetPattern.matcher(contentType);\n        if (m.find()) {\n            String charset = m.group(1).trim();\n            charset = charset.replace(\"charset=\", \"\");\n            return validateCharset(charset);\n        }\n        return null;\n    }\n\n    private static String validateCharset(String cs) {\n        if (cs == null || cs.length() == 0) return null;\n        cs = cs.trim().replaceAll(\"[\\\"']\", \"\");\n        try {\n            if (Charset.isSupported(cs)) return cs;\n            cs = cs.toUpperCase(Locale.ENGLISH);\n            if (Charset.isSupported(cs)) return cs;\n        } catch (IllegalCharsetNameException e) {\n            \n        }\n        return null;\n    }\n\n    \n    static String mimeBoundary() {\n        final StringBuilder mime = new StringBuilder(boundaryLength);\n        final Random rand = new Random();\n        for (int i = 0; i < boundaryLength; i++) {\n            mime.append(mimeBoundaryChars[rand.nextInt(mimeBoundaryChars.length)]);\n        }\n        return mime.toString();\n    }\n\n    private static BomCharset detectCharsetFromBom(final ByteBuffer byteData) {\n        final Buffer buffer = byteData; \n        buffer.mark();\n        byte[] bom = new byte[4];\n        if (byteData.remaining() >= bom.length) {\n            byteData.get(bom);\n            buffer.rewind();\n        }\n        if (bom[0] == 0x00 && bom[1] == 0x00 && bom[2] == (byte) 0xFE && bom[3] == (byte) 0xFF || \n            bom[0] == (byte) 0xFF && bom[1] == (byte) 0xFE && bom[2] == 0x00 && bom[3] == 0x00) { \n            return new BomCharset(\"UTF-32\", false); \n        } else if (bom[0] == (byte) 0xFE && bom[1] == (byte) 0xFF || \n            bom[0] == (byte) 0xFF && bom[1] == (byte) 0xFE) {\n            return new BomCharset(\"UTF-16\", false); \n        } else if (bom[0] == (byte) 0xEF && bom[1] == (byte) 0xBB && bom[2] == (byte) 0xBF) {\n            return new BomCharset(\"UTF-8\", true); \n            \n        }\n        return null;\n    }\n\n    private static class BomCharset { private final String charset; private final boolean offset; public BomCharset(String charset, boolean offset) {\n            this.charset = charset;\n            this.offset = offset;\n        }\n    }\n}\n",
      "fixed_full_code": "package org.jsoup.helper;\n\nimport org.jsoup.UncheckedIOException;\nimport org.jsoup.internal.ConstrainableInputStream;\nimport org.jsoup.nodes.Comment;\nimport org.jsoup.nodes.Document;\nimport org.jsoup.nodes.Element;\nimport org.jsoup.nodes.Node;\nimport org.jsoup.nodes.XmlDeclaration;\nimport org.jsoup.parser.Parser;\nimport org.jsoup.select.Elements;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.RandomAccessFile;\nimport java.nio.Buffer;\nimport java.nio.ByteBuffer;\nimport java.nio.charset.Charset;\nimport java.nio.charset.IllegalCharsetNameException;\nimport java.util.Locale;\nimport java.util.Random;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n\npublic final class DataUtil { private static final Pattern charsetPattern = Pattern.compile(\"(?i)\\\\bcharset=\\\\s*(?:[\\\"'])?([^\\\\s,;\\\"']*)\"); static final String defaultCharset = \"UTF-8\"; private static final int firstReadBufferSize = 1024 * 5; static final int bufferSize = 1024 * 32; private static final char[] mimeBoundaryChars = \"-_1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\".toCharArray(); static final int boundaryLength = 32; private DataUtil() {}\n\n    \n    public static Document load(File in, String charsetName, String baseUri) throws IOException {\n        return parseInputStream(new FileInputStream(in), charsetName, baseUri, Parser.htmlParser());\n    }\n\n    \n    public static Document load(InputStream in, String charsetName, String baseUri) throws IOException {\n        return parseInputStream(in, charsetName, baseUri, Parser.htmlParser());\n    }\n\n    \n    public static Document load(InputStream in, String charsetName, String baseUri, Parser parser) throws IOException {\n        return parseInputStream(in, charsetName, baseUri, parser);\n    }\n\n    \n    static void crossStreams(final InputStream in, final OutputStream out) throws IOException {\n        final byte[] buffer = new byte[bufferSize];\n        int len;\n        while ((len = in.read(buffer)) != -1) {\n            out.write(buffer, 0, len);\n        }\n    }\n\n    static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n        if (input == null) \n            return new Document(baseUri);\n        input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n\n        Document doc = null;\n        boolean fullyRead = false;\n\n        \n        input.mark(bufferSize);\n        ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1); \n        fullyRead = input.read() == -1;\n        input.reset();\n\n        \n        BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n        if (bomCharset != null)\n            charsetName = bomCharset.charset;\n\n        if (charsetName == null) { \n            String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n            doc = parser.parseInput(docData, baseUri);\n\n            \n            Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n            String foundCharset = null; \n            for (Element meta : metaElements) {\n                if (meta.hasAttr(\"http-equiv\"))\n                    foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n                if (foundCharset == null && meta.hasAttr(\"charset\"))\n                    foundCharset = meta.attr(\"charset\");\n                if (foundCharset != null)\n                    break;\n            }\n\n            \n            if (foundCharset == null && doc.childNodeSize() > 0) {\n                Node first = doc.childNode(0);\n                XmlDeclaration decl = null;\n                if (first instanceof XmlDeclaration)\n                    decl = (XmlDeclaration) first;\n                else if (first instanceof Comment) {\n                    Comment comment = (Comment) first;\n                    if (comment.isXmlDeclaration())\n                        decl = comment.asXmlDeclaration();\n                }\n                if (decl != null) {\n                    if (decl.name().equalsIgnoreCase(\"xml\"))\n                        foundCharset = decl.attr(\"encoding\");\n                }\n            }\n            foundCharset = validateCharset(foundCharset);\n            if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) { \n                foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                charsetName = foundCharset;\n                doc = null;\n            } else if (!fullyRead) {\n                doc = null;\n            }\n        } else { \n            Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        }\n        if (doc == null) {\n            if (charsetName == null)\n                charsetName = defaultCharset;\n            BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n            if (bomCharset != null && bomCharset.offset) \n                reader.skip(1);\n            try {\n                doc = parser.parseInput(reader, baseUri);\n            } catch (UncheckedIOException e) {\n                \n                throw e.ioException();\n            }\n            doc.outputSettings().charset(charsetName);\n        }\n        input.close();\n        return doc;\n    }\n\n    \n    public static ByteBuffer readToByteBuffer(InputStream inStream, int maxSize) throws IOException {\n        Validate.isTrue(maxSize >= 0, \"maxSize must be 0 (unlimited) or larger\");\n        final ConstrainableInputStream input = ConstrainableInputStream.wrap(inStream, bufferSize, maxSize);\n        return input.readToByteBuffer(maxSize);\n    }\n\n    static ByteBuffer readToByteBuffer(InputStream inStream) throws IOException {\n        return readToByteBuffer(inStream, 0);\n    }\n\n    static ByteBuffer readFileToByteBuffer(File file) throws IOException {\n        RandomAccessFile randomAccessFile = null;\n        try {\n            randomAccessFile = new RandomAccessFile(file, \"r\");\n            byte[] bytes = new byte[(int) randomAccessFile.length()];\n            randomAccessFile.readFully(bytes);\n            return ByteBuffer.wrap(bytes);\n        } finally {\n            if (randomAccessFile != null)\n                randomAccessFile.close();\n        }\n    }\n\n    static ByteBuffer emptyByteBuffer() {\n        return ByteBuffer.allocate(0);\n    }\n\n    \n    static String getCharsetFromContentType(String contentType) {\n        if (contentType == null) return null;\n        Matcher m = charsetPattern.matcher(contentType);\n        if (m.find()) {\n            String charset = m.group(1).trim();\n            charset = charset.replace(\"charset=\", \"\");\n            return validateCharset(charset);\n        }\n        return null;\n    }\n\n    private static String validateCharset(String cs) {\n        if (cs == null || cs.length() == 0) return null;\n        cs = cs.trim().replaceAll(\"[\\\"']\", \"\");\n        try {\n            if (Charset.isSupported(cs)) return cs;\n            cs = cs.toUpperCase(Locale.ENGLISH);\n            if (Charset.isSupported(cs)) return cs;\n        } catch (IllegalCharsetNameException e) {\n            \n        }\n        return null;\n    }\n\n    \n    static String mimeBoundary() {\n        final StringBuilder mime = new StringBuilder(boundaryLength);\n        final Random rand = new Random();\n        for (int i = 0; i < boundaryLength; i++) {\n            mime.append(mimeBoundaryChars[rand.nextInt(mimeBoundaryChars.length)]);\n        }\n        return mime.toString();\n    }\n\n    private static BomCharset detectCharsetFromBom(final ByteBuffer byteData) {\n        final Buffer buffer = byteData; \n        buffer.mark();\n        byte[] bom = new byte[4];\n        if (byteData.remaining() >= bom.length) {\n            byteData.get(bom);\n            buffer.rewind();\n        }\n        if (bom[0] == 0x00 && bom[1] == 0x00 && bom[2] == (byte) 0xFE && bom[3] == (byte) 0xFF || \n            bom[0] == (byte) 0xFF && bom[1] == (byte) 0xFE && bom[2] == 0x00 && bom[3] == 0x00) { \n            return new BomCharset(\"UTF-32\", false); \n        } else if (bom[0] == (byte) 0xFE && bom[1] == (byte) 0xFF || \n            bom[0] == (byte) 0xFF && bom[1] == (byte) 0xFE) {\n            return new BomCharset(\"UTF-16\", false); \n        } else if (bom[0] == (byte) 0xEF && bom[1] == (byte) 0xBB && bom[2] == (byte) 0xBF) {\n            return new BomCharset(\"UTF-8\", true); \n            \n        }\n        return null;\n    }\n\n    private static class BomCharset { private final String charset; private final boolean offset; public BomCharset(String charset, boolean offset) {\n            this.charset = charset;\n            this.offset = offset;\n        }\n    }\n}\n",
      "buggy_signatures": [
        "public static Document load(File in, String charsetName, String baseUri) throws IOException",
        "public static Document load(InputStream in, String charsetName, String baseUri) throws IOException",
        "public static Document load(InputStream in, String charsetName, String baseUri, Parser parser) throws IOException",
        "static void crossStreams(final InputStream in, final OutputStream out) throws IOException",
        "static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException",
        "public static ByteBuffer readToByteBuffer(InputStream inStream, int maxSize) throws IOException",
        "static ByteBuffer readToByteBuffer(InputStream inStream) throws IOException",
        "static ByteBuffer readFileToByteBuffer(File file) throws IOException",
        "static ByteBuffer emptyByteBuffer()",
        "static String getCharsetFromContentType(String contentType)",
        "private static String validateCharset(String cs)",
        "static String mimeBoundary()",
        "private static BomCharset detectCharsetFromBom(final ByteBuffer byteData)",
        "private static class BomCharset { private final String charset; private final boolean offset; public BomCharset(String charset, boolean offset)"
      ],
      "fixed_signatures": [
        "public static Document load(File in, String charsetName, String baseUri) throws IOException",
        "public static Document load(InputStream in, String charsetName, String baseUri) throws IOException",
        "public static Document load(InputStream in, String charsetName, String baseUri, Parser parser) throws IOException",
        "static void crossStreams(final InputStream in, final OutputStream out) throws IOException",
        "static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException",
        "public static ByteBuffer readToByteBuffer(InputStream inStream, int maxSize) throws IOException",
        "static ByteBuffer readToByteBuffer(InputStream inStream) throws IOException",
        "static ByteBuffer readFileToByteBuffer(File file) throws IOException",
        "static ByteBuffer emptyByteBuffer()",
        "static String getCharsetFromContentType(String contentType)",
        "private static String validateCharset(String cs)",
        "static String mimeBoundary()",
        "private static BomCharset detectCharsetFromBom(final ByteBuffer byteData)",
        "private static class BomCharset { private final String charset; private final boolean offset; public BomCharset(String charset, boolean offset)"
      ],
      "methods": [
        {
          "buggy_method": "",
          "fixed_method": "",
          "diff": [
            "@@ -2,6 +2,7 @@",
            " \n",
            " import org.jsoup.UncheckedIOException;\n",
            " import org.jsoup.internal.ConstrainableInputStream;\n",
            "+import org.jsoup.nodes.Comment;\n",
            " import org.jsoup.nodes.Document;\n",
            " import org.jsoup.nodes.Element;\n",
            " import org.jsoup.nodes.Node;\n"
          ],
          "changed_lines": 1
        },
        {
          "buggy_method": "  static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n  if (input == null) \n  return new Document(baseUri);\n  input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n\n  Document doc = null;\n  boolean fullyRead = false;\n\n  \n  input.mark(bufferSize);\n  ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1); \n  fullyRead = input.read() == -1;\n  input.reset();\n\n  \n  BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n  if (bomCharset != null)\n  charsetName = bomCharset.charset;\n\n  if (charsetName == null) { \n  String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n  doc = parser.parseInput(docData, baseUri);\n\n  \n  Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n  String foundCharset = null; \n  for (Element meta : metaElements) {\n  if (meta.hasAttr(\"http-equiv\"))\n  foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n  if (foundCharset == null && meta.hasAttr(\"charset\"))\n  foundCharset = meta.attr(\"charset\");\n  if (foundCharset != null)\n  break;\n  }\n\n  \n  if (foundCharset == null && doc.childNodeSize() > 0) {\n  Node first = doc.childNode(0);\n  XmlDeclaration decl = null;\n  if (first instanceof XmlDeclaration)\n  decl = (XmlDeclaration) first;\n  if (decl != null) {\n  if (decl.name().equalsIgnoreCase(\"xml\"))\n  foundCharset = decl.attr(\"encoding\");\n  }\n  }\n  foundCharset = validateCharset(foundCharset);\n  if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) { \n  foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n  charsetName = foundCharset;\n  doc = null;\n  } else if (!fullyRead) {\n  doc = null;\n  }\n  } else { \n  Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n  }\n  if (doc == null) {\n  if (charsetName == null)\n  charsetName = defaultCharset;\n  BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n  if (bomCharset != null && bomCharset.offset) \n  reader.skip(1);\n  try {\n  doc = parser.parseInput(reader, baseUri);\n  } catch (UncheckedIOException e) {\n  \n  throw e.ioException();\n  }\n  doc.outputSettings().charset(charsetName);\n  }\n  input.close();\n  return doc;\n  }",
          "fixed_method": "  static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n  if (input == null) \n  return new Document(baseUri);\n  input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n\n  Document doc = null;\n  boolean fullyRead = false;\n\n  \n  input.mark(bufferSize);\n  ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1); \n  fullyRead = input.read() == -1;\n  input.reset();\n\n  \n  BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n  if (bomCharset != null)\n  charsetName = bomCharset.charset;\n\n  if (charsetName == null) { \n  String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n  doc = parser.parseInput(docData, baseUri);\n\n  \n  Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n  String foundCharset = null; \n  for (Element meta : metaElements) {\n  if (meta.hasAttr(\"http-equiv\"))\n  foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n  if (foundCharset == null && meta.hasAttr(\"charset\"))\n  foundCharset = meta.attr(\"charset\");\n  if (foundCharset != null)\n  break;\n  }\n\n  \n  if (foundCharset == null && doc.childNodeSize() > 0) {\n  Node first = doc.childNode(0);\n  XmlDeclaration decl = null;\n  if (first instanceof XmlDeclaration)\n  decl = (XmlDeclaration) first;\n  else if (first instanceof Comment) {\n  Comment comment = (Comment) first;\n  if (comment.isXmlDeclaration())\n  decl = comment.asXmlDeclaration();\n  }\n  if (decl != null) {\n  if (decl.name().equalsIgnoreCase(\"xml\"))\n  foundCharset = decl.attr(\"encoding\");\n  }\n  }\n  foundCharset = validateCharset(foundCharset);\n  if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) { \n  foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n  charsetName = foundCharset;\n  doc = null;\n  } else if (!fullyRead) {\n  doc = null;\n  }\n  } else { \n  Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n  }\n  if (doc == null) {\n  if (charsetName == null)\n  charsetName = defaultCharset;\n  BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n  if (bomCharset != null && bomCharset.offset) \n  reader.skip(1);\n  try {\n  doc = parser.parseInput(reader, baseUri);\n  } catch (UncheckedIOException e) {\n  \n  throw e.ioException();\n  }\n  doc.outputSettings().charset(charsetName);\n  }\n  input.close();\n  return doc;\n  }",
          "diff": [
            "@@ -133,6 +134,11 @@",
            "                 XmlDeclaration decl = null;\n",
            "                 if (first instanceof XmlDeclaration)\n",
            "                     decl = (XmlDeclaration) first;\n",
            "+                else if (first instanceof Comment) {\n",
            "+                    Comment comment = (Comment) first;\n",
            "+                    if (comment.isXmlDeclaration())\n",
            "+                        decl = comment.asXmlDeclaration();\n",
            "+                }\n",
            "                 if (decl != null) {\n",
            "                     if (decl.name().equalsIgnoreCase(\"xml\"))\n",
            "                         foundCharset = decl.attr(\"encoding\");\n"
          ],
          "changed_lines": 5
        }
      ]
    }
  ]
}
