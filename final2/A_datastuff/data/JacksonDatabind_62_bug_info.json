{
  "bug_id": "62",
  "failed_tests": {
    "com.fasterxml.jackson.databind.creators.ArrayDelegatorCreatorForCollectionTest": [
      {
        "methodName": "testUnmodifiable",
        "error": "java.lang.IllegalStateException",
        "message": "No default constructor for [collection type; class java.util.Collections$UnmodifiableSet, contains [simple type, class java.lang.Object]]",
        "fail_line": "        Set<?> foo = mapper.readValue(EXPECTED_JSON, Set.class);",
        "test_source": "  public void testUnmodifiable() throws Exception {\n  ObjectMapper mapper = new ObjectMapper();\n  Class<?> unmodSetType = Collections.unmodifiableSet(Collections.<String>emptySet()).getClass();\n  mapper.addMixIn(unmodSetType, UnmodifiableSetMixin.class);\n  mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY);\n\n  final String EXPECTED_JSON = \"[\\\"\"+unmodSetType.getName()+\"\\\",[]]\";\n\n  Set<?> foo = mapper.readValue(EXPECTED_JSON, Set.class);\n  assertTrue(foo.isEmpty());\n  }",
        "stack": [
          "StdValueInstantiator.createUsingDefault line 240, CollectionDeserializer.deserialize line 251, CollectionDeserializer.deserialize line 26, AsArrayTypeDeserializer._deserialize line 110, AsArrayTypeDeserializer.deserializeTypedFromArray line 50, CollectionDeserializer.deserializeWithType line 312, TypeWrappedDeserializer.deserialize line 63, ObjectMapper._readMapAndClose line 3807, ObjectMapper.readValue line 2797, ArrayDelegatorCreatorForCollectionTest.testUnmodifiable line 28"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java",
      "buggy_full_code": "package com.fasterxml.jackson.databind.deser.std;\n\nimport java.io.IOException;\nimport java.util.*;\n\nimport com.fasterxml.jackson.annotation.JsonFormat;\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\nimport com.fasterxml.jackson.databind.deser.ContextualDeserializer;\nimport com.fasterxml.jackson.databind.deser.UnresolvedForwardReference;\nimport com.fasterxml.jackson.databind.deser.ValueInstantiator;\nimport com.fasterxml.jackson.databind.deser.impl.ReadableObjectId.Referring;\nimport com.fasterxml.jackson.databind.deser.std.ContainerDeserializerBase;\nimport com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n\n\n@JacksonStdImpl\npublic class CollectionDeserializer extends ContainerDeserializerBase<Collection<Object>> implements ContextualDeserializer { private static final long serialVersionUID = -1L; protected final JavaType _collectionType; protected final JsonDeserializer<Object> _valueDeserializer; protected final TypeDeserializer _valueTypeDeserializer; protected final ValueInstantiator _valueInstantiator; protected final JsonDeserializer<Object> _delegateDeserializer; protected final Boolean _unwrapSingle; public CollectionDeserializer(JavaType collectionType, JsonDeserializer<Object> valueDeser, TypeDeserializer valueTypeDeser, ValueInstantiator valueInstantiator) {\n        this(collectionType, valueDeser, valueTypeDeser, valueInstantiator, null, null);\n    }\n\n    \n    protected CollectionDeserializer(JavaType collectionType, JsonDeserializer<Object> valueDeser, TypeDeserializer valueTypeDeser, ValueInstantiator valueInstantiator, JsonDeserializer<Object> delegateDeser, Boolean unwrapSingle) {\n        super(collectionType);\n        _collectionType = collectionType;\n        _valueDeserializer = valueDeser;\n        _valueTypeDeserializer = valueTypeDeser;\n        _valueInstantiator = valueInstantiator;\n        _delegateDeserializer = delegateDeser;\n        _unwrapSingle = unwrapSingle;\n    }\n\n    \n    protected CollectionDeserializer(CollectionDeserializer src) {\n        super(src._collectionType);\n        _collectionType = src._collectionType;\n        _valueDeserializer = src._valueDeserializer;\n        _valueTypeDeserializer = src._valueTypeDeserializer;\n        _valueInstantiator = src._valueInstantiator;\n        _delegateDeserializer = src._delegateDeserializer;\n        _unwrapSingle = src._unwrapSingle;\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    protected CollectionDeserializer withResolved(JsonDeserializer<?> dd, JsonDeserializer<?> vd, TypeDeserializer vtd, Boolean unwrapSingle) {\n        if ((dd == _delegateDeserializer) && (vd == _valueDeserializer) && (vtd == _valueTypeDeserializer)\n                && (_unwrapSingle == unwrapSingle)) {\n            return this;\n        }\n        return new CollectionDeserializer(_collectionType,\n                (JsonDeserializer<Object>) vd, vtd,\n                _valueInstantiator, (JsonDeserializer<Object>) dd, unwrapSingle);\n    }\n\n    \n    @Deprecated \n    protected CollectionDeserializer withResolved(JsonDeserializer<?> dd, JsonDeserializer<?> vd, TypeDeserializer vtd) {\n        return withResolved(dd, vd, vtd, _unwrapSingle);\n    }\n\n    \n    @Override \n    public boolean isCachable() {\n        \n        return (_valueDeserializer == null)\n                && (_valueTypeDeserializer == null)\n                && (_delegateDeserializer == null)\n                ;\n    }\n\n    \n\n    \n    @Override\n    public CollectionDeserializer createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException {\n        \n        JsonDeserializer<Object> delegateDeser = null;\n        if (_valueInstantiator != null) {\n            if (_valueInstantiator.canCreateUsingDelegate()) {\n                JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig());\n                if (delegateType == null) {\n                    throw new IllegalArgumentException(\"Invalid delegate-creator definition for \"+_collectionType\n                            +\": value instantiator (\"+_valueInstantiator.getClass().getName()\n                            +\") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'\");\n                }\n                delegateDeser = findDeserializer(ctxt, delegateType, property);\n            }\n        }\n        \n        \n        \n        Boolean unwrapSingle = findFormatFeature(ctxt, property, Collection.class,\n                JsonFormat.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY);\n        \n        JsonDeserializer<?> valueDeser = _valueDeserializer;\n        \n        \n        valueDeser = findConvertingContentDeserializer(ctxt, property, valueDeser);\n        final JavaType vt = _collectionType.getContentType();\n        if (valueDeser == null) {\n            valueDeser = ctxt.findContextualValueDeserializer(vt, property);\n        } else { \n            valueDeser = ctxt.handleSecondaryContextualization(valueDeser, property, vt);\n        }\n        \n        TypeDeserializer valueTypeDeser = _valueTypeDeserializer;\n        if (valueTypeDeser != null) {\n            valueTypeDeser = valueTypeDeser.forProperty(property);\n        }\n        return withResolved(delegateDeser, valueDeser, valueTypeDeser, unwrapSingle);\n    }\n\n    \n\n    @Override\n    public JavaType getContentType() {\n        return _collectionType.getContentType();\n    }\n\n    @Override\n    public JsonDeserializer<Object> getContentDeserializer() {\n        return _valueDeserializer;\n    }\n    \n    \n    \n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public Collection<Object> deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n        if (_delegateDeserializer != null) {\n            return (Collection<Object>) _valueInstantiator.createUsingDelegate(ctxt,\n                    _delegateDeserializer.deserialize(p, ctxt));\n        }\n        \n        if (p.hasToken(JsonToken.VALUE_STRING)) {\n            String str = p.getText();\n            if (str.length() == 0) {\n                return (Collection<Object>) _valueInstantiator.createFromString(ctxt, str);\n            }\n        }\n        return deserialize(p, ctxt, (Collection<Object>) _valueInstantiator.createUsingDefault(ctxt));\n    }\n\n    @Override\n    public Collection<Object> deserialize(JsonParser p, DeserializationContext ctxt, Collection<Object> result) throws IOException {\n        \n        if (!p.isExpectedStartArrayToken()) {\n            return handleNonArray(p, ctxt, result);\n        }\n        \n        p.setCurrentValue(result);\n\n        JsonDeserializer<Object> valueDes = _valueDeserializer;\n        final TypeDeserializer typeDeser = _valueTypeDeserializer;\n        CollectionReferringAccumulator referringAccumulator =\n            (valueDes.getObjectIdReader() == null) ? null :\n                new CollectionReferringAccumulator(_collectionType.getContentType().getRawClass(), result);\n\n        JsonToken t;\n        while ((t = p.nextToken()) != JsonToken.END_ARRAY) {\n            try {\n                Object value;\n                if (t == JsonToken.VALUE_NULL) {\n                    value = valueDes.getNullValue(ctxt);\n                } else if (typeDeser == null) {\n                    value = valueDes.deserialize(p, ctxt);\n                } else {\n                    value = valueDes.deserializeWithType(p, ctxt, typeDeser);\n                }\n                if (referringAccumulator != null) {\n                    referringAccumulator.add(value);\n                } else {\n                    result.add(value);\n                }\n            } catch (UnresolvedForwardReference reference) {\n                if (referringAccumulator == null) {\n                    throw JsonMappingException\n                            .from(p, \"Unresolved forward reference but no identity info\", reference);\n                }\n                Referring ref = referringAccumulator.handleUnresolvedReference(reference);\n                reference.getRoid().appendReferring(ref);\n            } catch (Exception e) {\n                boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n                if (!wrap && e instanceof RuntimeException) {\n                    throw (RuntimeException)e;\n                }\n                throw JsonMappingException.wrapWithPath(e, result, result.size());\n            }\n        }\n        return result;\n    }\n\n    @Override\n    public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException {\n        \n        return typeDeserializer.deserializeTypedFromArray(jp, ctxt);\n    }\n\n    \n    protected final Collection<Object> handleNonArray(JsonParser p, DeserializationContext ctxt, Collection<Object> result) throws IOException {\n        \n        boolean canWrap = (_unwrapSingle == Boolean.TRUE) ||\n                ((_unwrapSingle == null) &&\n                        ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY));\n        if (!canWrap) {\n            throw ctxt.mappingException(_collectionType.getRawClass());\n        }\n        JsonDeserializer<Object> valueDes = _valueDeserializer;\n        final TypeDeserializer typeDeser = _valueTypeDeserializer;\n        JsonToken t = p.getCurrentToken();\n\n        Object value;\n\n        try {\n            if (t == JsonToken.VALUE_NULL) {\n                value = valueDes.getNullValue(ctxt);\n            } else if (typeDeser == null) {\n                value = valueDes.deserialize(p, ctxt);\n            } else {\n                value = valueDes.deserializeWithType(p, ctxt, typeDeser);\n            }\n        } catch (Exception e) {\n            \n            throw JsonMappingException.wrapWithPath(e, Object.class, result.size());\n        }\n        result.add(value);\n        return result;\n    }\n\n    public final static class CollectionReferringAccumulator { private final Class<?> _elementType; private final Collection<Object> _result; private List<CollectionReferring> _accumulator = new ArrayList<CollectionReferring>(); public CollectionReferringAccumulator(Class<?> elementType, Collection<Object> result) {\n            _elementType = elementType;\n            _result = result;\n        }\n\n        public void add(Object value) {\n            if (_accumulator.isEmpty()) {\n                _result.add(value);\n            } else {\n                CollectionReferring ref = _accumulator.get(_accumulator.size() - 1);\n                ref.next.add(value);\n            }\n        }\n\n        public Referring handleUnresolvedReference(UnresolvedForwardReference reference) {\n            CollectionReferring id = new CollectionReferring(this, reference, _elementType);\n            _accumulator.add(id);\n            return id;\n        }\n\n        public void resolveForwardReference(Object id, Object value) throws IOException {\n            Iterator<CollectionReferring> iterator = _accumulator.iterator();\n            \n            \n            \n            Collection<Object> previous = _result;\n            while (iterator.hasNext()) {\n                CollectionReferring ref = iterator.next();\n                if (ref.hasId(id)) {\n                    iterator.remove();\n                    previous.add(value);\n                    previous.addAll(ref.next);\n                    return;\n                }\n                previous = ref.next;\n            }\n\n            throw new IllegalArgumentException(\"Trying to resolve a forward reference with id [\" + id\n                    + \"] that wasn't previously seen as unresolved.\");\n        }\n    }\n\n    \n    private final static class CollectionReferring extends Referring { private final CollectionReferringAccumulator _parent; public final List<Object> next = new ArrayList<Object>(); CollectionReferring(CollectionReferringAccumulator parent, UnresolvedForwardReference reference, Class<?> contentType) {\n            super(reference, contentType);\n            _parent = parent;\n        }\n        \n        @Override\n        public void handleResolvedForwardReference(Object id, Object value) throws IOException {\n            _parent.resolveForwardReference(id, value);\n        }\n    }\n}\n",
      "fixed_full_code": "package com.fasterxml.jackson.databind.deser.std;\n\nimport java.io.IOException;\nimport java.util.*;\n\nimport com.fasterxml.jackson.annotation.JsonFormat;\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\nimport com.fasterxml.jackson.databind.deser.ContextualDeserializer;\nimport com.fasterxml.jackson.databind.deser.UnresolvedForwardReference;\nimport com.fasterxml.jackson.databind.deser.ValueInstantiator;\nimport com.fasterxml.jackson.databind.deser.impl.ReadableObjectId.Referring;\nimport com.fasterxml.jackson.databind.deser.std.ContainerDeserializerBase;\nimport com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n\n\n@JacksonStdImpl\npublic class CollectionDeserializer extends ContainerDeserializerBase<Collection<Object>> implements ContextualDeserializer { private static final long serialVersionUID = -1L; protected final JavaType _collectionType; protected final JsonDeserializer<Object> _valueDeserializer; protected final TypeDeserializer _valueTypeDeserializer; protected final ValueInstantiator _valueInstantiator; protected final JsonDeserializer<Object> _delegateDeserializer; protected final Boolean _unwrapSingle; public CollectionDeserializer(JavaType collectionType, JsonDeserializer<Object> valueDeser, TypeDeserializer valueTypeDeser, ValueInstantiator valueInstantiator) {\n        this(collectionType, valueDeser, valueTypeDeser, valueInstantiator, null, null);\n    }\n\n    \n    protected CollectionDeserializer(JavaType collectionType, JsonDeserializer<Object> valueDeser, TypeDeserializer valueTypeDeser, ValueInstantiator valueInstantiator, JsonDeserializer<Object> delegateDeser, Boolean unwrapSingle) {\n        super(collectionType);\n        _collectionType = collectionType;\n        _valueDeserializer = valueDeser;\n        _valueTypeDeserializer = valueTypeDeser;\n        _valueInstantiator = valueInstantiator;\n        _delegateDeserializer = delegateDeser;\n        _unwrapSingle = unwrapSingle;\n    }\n\n    \n    protected CollectionDeserializer(CollectionDeserializer src) {\n        super(src._collectionType);\n        _collectionType = src._collectionType;\n        _valueDeserializer = src._valueDeserializer;\n        _valueTypeDeserializer = src._valueTypeDeserializer;\n        _valueInstantiator = src._valueInstantiator;\n        _delegateDeserializer = src._delegateDeserializer;\n        _unwrapSingle = src._unwrapSingle;\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    protected CollectionDeserializer withResolved(JsonDeserializer<?> dd, JsonDeserializer<?> vd, TypeDeserializer vtd, Boolean unwrapSingle) {\n        if ((dd == _delegateDeserializer) && (vd == _valueDeserializer) && (vtd == _valueTypeDeserializer)\n                && (_unwrapSingle == unwrapSingle)) {\n            return this;\n        }\n        return new CollectionDeserializer(_collectionType,\n                (JsonDeserializer<Object>) vd, vtd,\n                _valueInstantiator, (JsonDeserializer<Object>) dd, unwrapSingle);\n    }\n\n    \n    @Deprecated \n    protected CollectionDeserializer withResolved(JsonDeserializer<?> dd, JsonDeserializer<?> vd, TypeDeserializer vtd) {\n        return withResolved(dd, vd, vtd, _unwrapSingle);\n    }\n\n    \n    @Override \n    public boolean isCachable() {\n        \n        return (_valueDeserializer == null)\n                && (_valueTypeDeserializer == null)\n                && (_delegateDeserializer == null)\n                ;\n    }\n\n    \n\n    \n    @Override\n    public CollectionDeserializer createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException {\n        \n        JsonDeserializer<Object> delegateDeser = null;\n        if (_valueInstantiator != null) {\n            if (_valueInstantiator.canCreateUsingDelegate()) {\n                JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig());\n                if (delegateType == null) {\n                    throw new IllegalArgumentException(\"Invalid delegate-creator definition for \"+_collectionType\n                            +\": value instantiator (\"+_valueInstantiator.getClass().getName()\n                            +\") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'\");\n                }\n                delegateDeser = findDeserializer(ctxt, delegateType, property);\n            } else if (_valueInstantiator.canCreateUsingArrayDelegate()) {\n                JavaType delegateType = _valueInstantiator.getArrayDelegateType(ctxt.getConfig());\n                if (delegateType == null) {\n                    throw new IllegalArgumentException(\"Invalid array-delegate-creator definition for \"+_collectionType\n                            +\": value instantiator (\"+_valueInstantiator.getClass().getName()\n                            +\") returned true for 'canCreateUsingArrayDelegate()', but null for 'getArrayDelegateType()'\");\n                }\n                delegateDeser = findDeserializer(ctxt, delegateType, property);\n            }\n        }\n        \n        \n        \n        Boolean unwrapSingle = findFormatFeature(ctxt, property, Collection.class,\n                JsonFormat.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY);\n        \n        JsonDeserializer<?> valueDeser = _valueDeserializer;\n        \n        \n        valueDeser = findConvertingContentDeserializer(ctxt, property, valueDeser);\n        final JavaType vt = _collectionType.getContentType();\n        if (valueDeser == null) {\n            valueDeser = ctxt.findContextualValueDeserializer(vt, property);\n        } else { \n            valueDeser = ctxt.handleSecondaryContextualization(valueDeser, property, vt);\n        }\n        \n        TypeDeserializer valueTypeDeser = _valueTypeDeserializer;\n        if (valueTypeDeser != null) {\n            valueTypeDeser = valueTypeDeser.forProperty(property);\n        }\n        return withResolved(delegateDeser, valueDeser, valueTypeDeser, unwrapSingle);\n    }\n\n    \n\n    @Override\n    public JavaType getContentType() {\n        return _collectionType.getContentType();\n    }\n\n    @Override\n    public JsonDeserializer<Object> getContentDeserializer() {\n        return _valueDeserializer;\n    }\n    \n    \n    \n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public Collection<Object> deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n        if (_delegateDeserializer != null) {\n            return (Collection<Object>) _valueInstantiator.createUsingDelegate(ctxt,\n                    _delegateDeserializer.deserialize(p, ctxt));\n        }\n        \n        if (p.hasToken(JsonToken.VALUE_STRING)) {\n            String str = p.getText();\n            if (str.length() == 0) {\n                return (Collection<Object>) _valueInstantiator.createFromString(ctxt, str);\n            }\n        }\n        return deserialize(p, ctxt, (Collection<Object>) _valueInstantiator.createUsingDefault(ctxt));\n    }\n\n    @Override\n    public Collection<Object> deserialize(JsonParser p, DeserializationContext ctxt, Collection<Object> result) throws IOException {\n        \n        if (!p.isExpectedStartArrayToken()) {\n            return handleNonArray(p, ctxt, result);\n        }\n        \n        p.setCurrentValue(result);\n\n        JsonDeserializer<Object> valueDes = _valueDeserializer;\n        final TypeDeserializer typeDeser = _valueTypeDeserializer;\n        CollectionReferringAccumulator referringAccumulator =\n            (valueDes.getObjectIdReader() == null) ? null :\n                new CollectionReferringAccumulator(_collectionType.getContentType().getRawClass(), result);\n\n        JsonToken t;\n        while ((t = p.nextToken()) != JsonToken.END_ARRAY) {\n            try {\n                Object value;\n                if (t == JsonToken.VALUE_NULL) {\n                    value = valueDes.getNullValue(ctxt);\n                } else if (typeDeser == null) {\n                    value = valueDes.deserialize(p, ctxt);\n                } else {\n                    value = valueDes.deserializeWithType(p, ctxt, typeDeser);\n                }\n                if (referringAccumulator != null) {\n                    referringAccumulator.add(value);\n                } else {\n                    result.add(value);\n                }\n            } catch (UnresolvedForwardReference reference) {\n                if (referringAccumulator == null) {\n                    throw JsonMappingException\n                            .from(p, \"Unresolved forward reference but no identity info\", reference);\n                }\n                Referring ref = referringAccumulator.handleUnresolvedReference(reference);\n                reference.getRoid().appendReferring(ref);\n            } catch (Exception e) {\n                boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n                if (!wrap && e instanceof RuntimeException) {\n                    throw (RuntimeException)e;\n                }\n                throw JsonMappingException.wrapWithPath(e, result, result.size());\n            }\n        }\n        return result;\n    }\n\n    @Override\n    public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException {\n        \n        return typeDeserializer.deserializeTypedFromArray(jp, ctxt);\n    }\n\n    \n    protected final Collection<Object> handleNonArray(JsonParser p, DeserializationContext ctxt, Collection<Object> result) throws IOException {\n        \n        boolean canWrap = (_unwrapSingle == Boolean.TRUE) ||\n                ((_unwrapSingle == null) &&\n                        ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY));\n        if (!canWrap) {\n            throw ctxt.mappingException(_collectionType.getRawClass());\n        }\n        JsonDeserializer<Object> valueDes = _valueDeserializer;\n        final TypeDeserializer typeDeser = _valueTypeDeserializer;\n        JsonToken t = p.getCurrentToken();\n\n        Object value;\n\n        try {\n            if (t == JsonToken.VALUE_NULL) {\n                value = valueDes.getNullValue(ctxt);\n            } else if (typeDeser == null) {\n                value = valueDes.deserialize(p, ctxt);\n            } else {\n                value = valueDes.deserializeWithType(p, ctxt, typeDeser);\n            }\n        } catch (Exception e) {\n            \n            throw JsonMappingException.wrapWithPath(e, Object.class, result.size());\n        }\n        result.add(value);\n        return result;\n    }\n\n    public final static class CollectionReferringAccumulator { private final Class<?> _elementType; private final Collection<Object> _result; private List<CollectionReferring> _accumulator = new ArrayList<CollectionReferring>(); public CollectionReferringAccumulator(Class<?> elementType, Collection<Object> result) {\n            _elementType = elementType;\n            _result = result;\n        }\n\n        public void add(Object value) {\n            if (_accumulator.isEmpty()) {\n                _result.add(value);\n            } else {\n                CollectionReferring ref = _accumulator.get(_accumulator.size() - 1);\n                ref.next.add(value);\n            }\n        }\n\n        public Referring handleUnresolvedReference(UnresolvedForwardReference reference) {\n            CollectionReferring id = new CollectionReferring(this, reference, _elementType);\n            _accumulator.add(id);\n            return id;\n        }\n\n        public void resolveForwardReference(Object id, Object value) throws IOException {\n            Iterator<CollectionReferring> iterator = _accumulator.iterator();\n            \n            \n            \n            Collection<Object> previous = _result;\n            while (iterator.hasNext()) {\n                CollectionReferring ref = iterator.next();\n                if (ref.hasId(id)) {\n                    iterator.remove();\n                    previous.add(value);\n                    previous.addAll(ref.next);\n                    return;\n                }\n                previous = ref.next;\n            }\n\n            throw new IllegalArgumentException(\"Trying to resolve a forward reference with id [\" + id\n                    + \"] that wasn't previously seen as unresolved.\");\n        }\n    }\n\n    \n    private final static class CollectionReferring extends Referring { private final CollectionReferringAccumulator _parent; public final List<Object> next = new ArrayList<Object>(); CollectionReferring(CollectionReferringAccumulator parent, UnresolvedForwardReference reference, Class<?> contentType) {\n            super(reference, contentType);\n            _parent = parent;\n        }\n        \n        @Override\n        public void handleResolvedForwardReference(Object id, Object value) throws IOException {\n            _parent.resolveForwardReference(id, value);\n        }\n    }\n}\n",
      "buggy_signatures": [
        "protected CollectionDeserializer(JavaType collectionType, JsonDeserializer<Object> valueDeser, TypeDeserializer valueTypeDeser, ValueInstantiator valueInstantiator, JsonDeserializer<Object> delegateDeser, Boolean unwrapSingle)",
        "protected CollectionDeserializer(CollectionDeserializer src)",
        "protected CollectionDeserializer withResolved(JsonDeserializer<?> dd, JsonDeserializer<?> vd, TypeDeserializer vtd, Boolean unwrapSingle)",
        "protected CollectionDeserializer withResolved(JsonDeserializer<?> dd, JsonDeserializer<?> vd, TypeDeserializer vtd)",
        "public boolean isCachable()",
        "public CollectionDeserializer createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException",
        "public JavaType getContentType()",
        "public JsonDeserializer<Object> getContentDeserializer()",
        "public Collection<Object> deserialize(JsonParser p, DeserializationContext ctxt) throws IOException",
        "public Collection<Object> deserialize(JsonParser p, DeserializationContext ctxt, Collection<Object> result) throws IOException",
        "public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException",
        "protected final Collection<Object> handleNonArray(JsonParser p, DeserializationContext ctxt, Collection<Object> result) throws IOException",
        "public void add(Object value)",
        "public Referring handleUnresolvedReference(UnresolvedForwardReference reference)",
        "public void resolveForwardReference(Object id, Object value) throws IOException",
        "public void handleResolvedForwardReference(Object id, Object value) throws IOException"
      ],
      "fixed_signatures": [
        "protected CollectionDeserializer(JavaType collectionType, JsonDeserializer<Object> valueDeser, TypeDeserializer valueTypeDeser, ValueInstantiator valueInstantiator, JsonDeserializer<Object> delegateDeser, Boolean unwrapSingle)",
        "protected CollectionDeserializer(CollectionDeserializer src)",
        "protected CollectionDeserializer withResolved(JsonDeserializer<?> dd, JsonDeserializer<?> vd, TypeDeserializer vtd, Boolean unwrapSingle)",
        "protected CollectionDeserializer withResolved(JsonDeserializer<?> dd, JsonDeserializer<?> vd, TypeDeserializer vtd)",
        "public boolean isCachable()",
        "public CollectionDeserializer createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException",
        "public JavaType getContentType()",
        "public JsonDeserializer<Object> getContentDeserializer()",
        "public Collection<Object> deserialize(JsonParser p, DeserializationContext ctxt) throws IOException",
        "public Collection<Object> deserialize(JsonParser p, DeserializationContext ctxt, Collection<Object> result) throws IOException",
        "public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException",
        "protected final Collection<Object> handleNonArray(JsonParser p, DeserializationContext ctxt, Collection<Object> result) throws IOException",
        "public void add(Object value)",
        "public Referring handleUnresolvedReference(UnresolvedForwardReference reference)",
        "public void resolveForwardReference(Object id, Object value) throws IOException",
        "public void handleResolvedForwardReference(Object id, Object value) throws IOException"
      ],
      "methods": [
        {
          "buggy_method": "  public CollectionDeserializer createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException {\n  \n  JsonDeserializer<Object> delegateDeser = null;\n  if (_valueInstantiator != null) {\n  if (_valueInstantiator.canCreateUsingDelegate()) {\n  JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig());\n  if (delegateType == null) {\n  throw new IllegalArgumentException(\"Invalid delegate-creator definition for \"+_collectionType\n  +\": value instantiator (\"+_valueInstantiator.getClass().getName()\n  +\") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'\");\n  }\n  delegateDeser = findDeserializer(ctxt, delegateType, property);\n  }\n  }\n  \n  \n  \n  Boolean unwrapSingle = findFormatFeature(ctxt, property, Collection.class,\n  JsonFormat.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY);\n  \n  JsonDeserializer<?> valueDeser = _valueDeserializer;\n  \n  \n  valueDeser = findConvertingContentDeserializer(ctxt, property, valueDeser);\n  final JavaType vt = _collectionType.getContentType();\n  if (valueDeser == null) {\n  valueDeser = ctxt.findContextualValueDeserializer(vt, property);\n  } else { \n  valueDeser = ctxt.handleSecondaryContextualization(valueDeser, property, vt);\n  }\n  \n  TypeDeserializer valueTypeDeser = _valueTypeDeserializer;\n  if (valueTypeDeser != null) {\n  valueTypeDeser = valueTypeDeser.forProperty(property);\n  }\n  return withResolved(delegateDeser, valueDeser, valueTypeDeser, unwrapSingle);\n  }",
          "fixed_method": "  public CollectionDeserializer createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException {\n  \n  JsonDeserializer<Object> delegateDeser = null;\n  if (_valueInstantiator != null) {\n  if (_valueInstantiator.canCreateUsingDelegate()) {\n  JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig());\n  if (delegateType == null) {\n  throw new IllegalArgumentException(\"Invalid delegate-creator definition for \"+_collectionType\n  +\": value instantiator (\"+_valueInstantiator.getClass().getName()\n  +\") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'\");\n  }\n  delegateDeser = findDeserializer(ctxt, delegateType, property);\n  } else if (_valueInstantiator.canCreateUsingArrayDelegate()) {\n  JavaType delegateType = _valueInstantiator.getArrayDelegateType(ctxt.getConfig());\n  if (delegateType == null) {\n  throw new IllegalArgumentException(\"Invalid array-delegate-creator definition for \"+_collectionType\n  +\": value instantiator (\"+_valueInstantiator.getClass().getName()\n  +\") returned true for 'canCreateUsingArrayDelegate()', but null for 'getArrayDelegateType()'\");\n  }\n  delegateDeser = findDeserializer(ctxt, delegateType, property);\n  }\n  }\n  \n  \n  \n  Boolean unwrapSingle = findFormatFeature(ctxt, property, Collection.class,\n  JsonFormat.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY);\n  \n  JsonDeserializer<?> valueDeser = _valueDeserializer;\n  \n  \n  valueDeser = findConvertingContentDeserializer(ctxt, property, valueDeser);\n  final JavaType vt = _collectionType.getContentType();\n  if (valueDeser == null) {\n  valueDeser = ctxt.findContextualValueDeserializer(vt, property);\n  } else { \n  valueDeser = ctxt.handleSecondaryContextualization(valueDeser, property, vt);\n  }\n  \n  TypeDeserializer valueTypeDeser = _valueTypeDeserializer;\n  if (valueTypeDeser != null) {\n  valueTypeDeser = valueTypeDeser.forProperty(property);\n  }\n  return withResolved(delegateDeser, valueDeser, valueTypeDeser, unwrapSingle);\n  }",
          "diff": [
            "@@ -181,6 +181,14 @@",
            "                             +\") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'\");\n",
            "                 }\n",
            "                 delegateDeser = findDeserializer(ctxt, delegateType, property);\n",
            "+            } else if (_valueInstantiator.canCreateUsingArrayDelegate()) {\n",
            "+                JavaType delegateType = _valueInstantiator.getArrayDelegateType(ctxt.getConfig());\n",
            "+                if (delegateType == null) {\n",
            "+                    throw new IllegalArgumentException(\"Invalid array-delegate-creator definition for \"+_collectionType\n",
            "+                            +\": value instantiator (\"+_valueInstantiator.getClass().getName()\n",
            "+                            +\") returned true for 'canCreateUsingArrayDelegate()', but null for 'getArrayDelegateType()'\");\n",
            "+                }\n",
            "+                delegateDeser = findDeserializer(ctxt, delegateType, property);\n",
            "             }\n",
            "         }\n",
            "         // [databind#1043]: allow per-property allow-wrapping of single overrides:\n"
          ],
          "changed_lines": 8
        }
      ]
    }
  ]
}
