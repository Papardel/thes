{
  "bug_id": "25",
  "failed_tests": {
    "org.joda.time.TestDateTimeZoneCutover": [
      {
        "methodName": "test_DateTime_constructor_Moscow_Autumn",
        "error": "junit.framework.ComparisonFailure",
        "message": "expected:<...10-28T02:30:00.000+0[4]:00> but was:<...10-28T02:30:00.000+0[3]:00>",
        "fail_line": "        assertEquals(\"2007-10-28T02:30:00.000+04:00\", dt.toString());",
        "test_source": "  public void test_DateTime_constructor_Moscow_Autumn() {\n  DateTime dt = new DateTime(2007, 10, 28, 2, 30, ZONE_MOSCOW);\n  assertEquals(\"2007-10-28T02:30:00.000+04:00\", dt.toString());\n  }",
        "stack": [
          "TestDateTimeZoneCutover.test_DateTime_constructor_Moscow_Autumn line 922"
        ]
      },
      {
        "methodName": "test_getOffsetFromLocal_Moscow_Autumn_overlap_mins",
        "error": "junit.framework.ComparisonFailure",
        "message": "2007-10-28T02:00:00.000+03:00 expected:<...10-28T02:00:00.000+0[4]:00> but was:<...10-28T02:00:00.000+0[3]:00>",
        "fail_line": "                doTest_getOffsetFromLocal(10, 28, 2, min, \"2007-10-28T02:0\" + min + \":00.000+04:00\", ZONE_MOSCOW);",
        "test_source": "  public void test_getOffsetFromLocal_Moscow_Autumn_overlap_mins() {\n  for (int min = 0; min < 60; min++) {\n  if (min < 10) {\n  doTest_getOffsetFromLocal(10, 28, 2, min, \"2007-10-28T02:0\" + min + \":00.000+04:00\", ZONE_MOSCOW);\n  } else {\n  doTest_getOffsetFromLocal(10, 28, 2, min, \"2007-10-28T02:\" + min + \":00.000+04:00\", ZONE_MOSCOW);\n  }\n  }\n  }",
        "stack": [
          "TestDateTimeZoneCutover.doTest_getOffsetFromLocal line 1232, TestDateTimeZoneCutover.doTest_getOffsetFromLocal line 1217, TestDateTimeZoneCutover.test_getOffsetFromLocal_Moscow_Autumn_overlap_mins line 913"
        ]
      },
      {
        "methodName": "test_getOffsetFromLocal_Moscow_Autumn",
        "error": "junit.framework.ComparisonFailure",
        "message": "2007-10-28T02:00:00.000+03:00 expected:<...10-28T02:00:00.000+0[4]:00> but was:<...10-28T02:00:00.000+0[3]:00>",
        "fail_line": "        doTest_getOffsetFromLocal(10, 28, 2, 0, \"2007-10-28T02:00:00.000+04:00\", ZONE_MOSCOW);",
        "test_source": "  public void test_getOffsetFromLocal_Moscow_Autumn() {\n  doTest_getOffsetFromLocal(10, 28, 0, 0, \"2007-10-28T00:00:00.000+04:00\", ZONE_MOSCOW);\n  doTest_getOffsetFromLocal(10, 28, 0,30, \"2007-10-28T00:30:00.000+04:00\", ZONE_MOSCOW);\n  doTest_getOffsetFromLocal(10, 28, 1, 0, \"2007-10-28T01:00:00.000+04:00\", ZONE_MOSCOW);\n  doTest_getOffsetFromLocal(10, 28, 1,30, \"2007-10-28T01:30:00.000+04:00\", ZONE_MOSCOW);\n  \n  doTest_getOffsetFromLocal(10, 28, 2, 0, \"2007-10-28T02:00:00.000+04:00\", ZONE_MOSCOW);\n  doTest_getOffsetFromLocal(10, 28, 2,30, \"2007-10-28T02:30:00.000+04:00\", ZONE_MOSCOW);\n  doTest_getOffsetFromLocal(10, 28, 2,30,59,999, \"2007-10-28T02:30:59.999+04:00\", ZONE_MOSCOW);\n  doTest_getOffsetFromLocal(10, 28, 2,59,59,998, \"2007-10-28T02:59:59.998+04:00\", ZONE_MOSCOW);\n  doTest_getOffsetFromLocal(10, 28, 2,59,59,999, \"2007-10-28T02:59:59.999+04:00\", ZONE_MOSCOW);\n  \n  doTest_getOffsetFromLocal(10, 28, 3, 0, \"2007-10-28T03:00:00.000+03:00\", ZONE_MOSCOW);\n  doTest_getOffsetFromLocal(10, 28, 3,30, \"2007-10-28T03:30:00.000+03:00\", ZONE_MOSCOW);\n  doTest_getOffsetFromLocal(10, 28, 4, 0, \"2007-10-28T04:00:00.000+03:00\", ZONE_MOSCOW);\n  doTest_getOffsetFromLocal(10, 28, 5, 0, \"2007-10-28T05:00:00.000+03:00\", ZONE_MOSCOW);\n  doTest_getOffsetFromLocal(10, 28, 6, 0, \"2007-10-28T06:00:00.000+03:00\", ZONE_MOSCOW);\n  doTest_getOffsetFromLocal(10, 28, 7, 0, \"2007-10-28T07:00:00.000+03:00\", ZONE_MOSCOW);\n  doTest_getOffsetFromLocal(10, 28, 8, 0, \"2007-10-28T08:00:00.000+03:00\", ZONE_MOSCOW);\n  }",
        "stack": [
          "TestDateTimeZoneCutover.doTest_getOffsetFromLocal line 1232, TestDateTimeZoneCutover.doTest_getOffsetFromLocal line 1217, TestDateTimeZoneCutover.test_getOffsetFromLocal_Moscow_Autumn line 895"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/joda/time/DateTimeZone.java",
      "buggy_full_code": "\npackage org.joda.time;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.ObjectStreamException;\nimport java.io.Serializable;\nimport java.lang.ref.Reference;\nimport java.lang.ref.SoftReference;\nimport java.util.HashMap;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TimeZone;\n\nimport org.joda.convert.FromString;\nimport org.joda.convert.ToString;\nimport org.joda.time.chrono.BaseChronology;\nimport org.joda.time.field.FieldUtils;\nimport org.joda.time.format.DateTimeFormat;\nimport org.joda.time.format.DateTimeFormatter;\nimport org.joda.time.format.DateTimeFormatterBuilder;\nimport org.joda.time.format.FormatUtils;\nimport org.joda.time.tz.DefaultNameProvider;\nimport org.joda.time.tz.FixedDateTimeZone;\nimport org.joda.time.tz.NameProvider;\nimport org.joda.time.tz.Provider;\nimport org.joda.time.tz.UTCProvider;\nimport org.joda.time.tz.ZoneInfoProvider;\n\n\npublic abstract class DateTimeZone implements Serializable { private static final long serialVersionUID = 5546345482340108586L; public static final DateTimeZone UTC = new FixedDateTimeZone(\"UTC\", \"UTC\", 0, 0); private static Provider cProvider; private static NameProvider cNameProvider; private static Set<String> cAvailableIDs; private static volatile DateTimeZone cDefault; private static DateTimeFormatter cOffsetFormatter; private static Map<String, SoftReference<DateTimeZone>> iFixedOffsetCache; private static Map<String, String> cZoneIdConversion; static {\n        setProvider0(null);\n        setNameProvider0(null);\n    }\n\n    \n    \n    public static DateTimeZone getDefault() {\n        DateTimeZone zone = cDefault;\n        if (zone == null) {\n            synchronized(DateTimeZone.class) {\n                zone = cDefault;\n                if (zone == null) {\n                    DateTimeZone temp = null;\n                    try {\n                        try {\n                            String id = System.getProperty(\"user.timezone\");\n                            if (id != null) {  \n                                temp = forID(id);\n                            }\n                        } catch (RuntimeException ex) {\n                            \n                        }\n                        if (temp == null) {\n                            temp = forTimeZone(TimeZone.getDefault());\n                        }\n                    } catch (IllegalArgumentException ex) {\n                        \n                    }\n                    if (temp == null) {\n                        temp = UTC;\n                    }\n                    cDefault = zone = temp;\n                }\n            }\n        }\n        return zone;\n    }\n\n    \n    public static void setDefault(DateTimeZone zone) throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setDefault\"));\n        }\n        if (zone == null) {\n            throw new IllegalArgumentException(\"The datetime zone must not be null\");\n        }\n        synchronized(DateTimeZone.class) {\n            cDefault = zone;\n        }\n    }\n\n    \n    \n    @FromString\n    public static DateTimeZone forID(String id) {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        DateTimeZone zone = cProvider.getZone(id);\n        if (zone != null) {\n            return zone;\n        }\n        if (id.startsWith(\"+\") || id.startsWith(\"-\")) {\n            int offset = parseOffset(id);\n            if (offset == 0L) {\n                return DateTimeZone.UTC;\n            } else {\n                id = printOffset(offset);\n                return fixedOffsetZone(id, offset);\n            }\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }\n\n    \n    public static DateTimeZone forOffsetHours(int hoursOffset) throws IllegalArgumentException {\n        return forOffsetHoursMinutes(hoursOffset, 0);\n    }\n\n    \n    public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException {\n        if (hoursOffset == 0 && minutesOffset == 0) {\n            return DateTimeZone.UTC;\n        }\n        if (minutesOffset < 0 || minutesOffset > 59) {\n            throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n        }\n        int offset = 0;\n        try {\n            int hoursInMinutes = FieldUtils.safeMultiply(hoursOffset, 60);\n            if (hoursInMinutes < 0) {\n                minutesOffset = FieldUtils.safeAdd(hoursInMinutes, -minutesOffset);\n            } else {\n                minutesOffset = FieldUtils.safeAdd(hoursInMinutes, minutesOffset);\n            }\n            offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);\n        } catch (ArithmeticException ex) {\n            throw new IllegalArgumentException(\"Offset is too large\");\n        }\n        return forOffsetMillis(offset);\n    }\n\n    \n    public static DateTimeZone forOffsetMillis(int millisOffset) {\n        String id = printOffset(millisOffset);\n        return fixedOffsetZone(id, millisOffset);\n    }\n\n    \n    public static DateTimeZone forTimeZone(TimeZone zone) {\n        if (zone == null) {\n            return getDefault();\n        }\n        final String id = zone.getID();\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n\n        \n        DateTimeZone dtz = null;\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) {\n            dtz = cProvider.getZone(id);\n        }\n        if (dtz != null) {\n            return dtz;\n        }\n\n        \n        if (convId == null) {\n            convId = zone.getDisplayName();\n            if (convId.startsWith(\"GMT+\") || convId.startsWith(\"GMT-\")) {\n                convId = convId.substring(3);\n                int offset = parseOffset(convId);\n                if (offset == 0L) {\n                    return DateTimeZone.UTC;\n                } else {\n                    convId = printOffset(offset);\n                    return fixedOffsetZone(convId, offset);\n                }\n            }\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }\n\n    \n    \n    private static synchronized DateTimeZone fixedOffsetZone(String id, int offset) {\n        if (offset == 0) {\n            return DateTimeZone.UTC;\n        }\n        if (iFixedOffsetCache == null) {\n            iFixedOffsetCache = new HashMap<String, SoftReference<DateTimeZone>>();\n        }\n        DateTimeZone zone;\n        Reference<DateTimeZone> ref = iFixedOffsetCache.get(id);\n        if (ref != null) {\n            zone = ref.get();\n            if (zone != null) {\n                return zone;\n            }\n        }\n        zone = new FixedDateTimeZone(id, null, offset, offset);\n        iFixedOffsetCache.put(id, new SoftReference<DateTimeZone>(zone));\n        return zone;\n    }\n\n    \n    public static Set<String> getAvailableIDs() {\n        return cAvailableIDs;\n    }\n\n    \n    \n    public static Provider getProvider() {\n        return cProvider;\n    }\n\n    \n    public static void setProvider(Provider provider) throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setProvider\"));\n        }\n        setProvider0(provider);\n    }\n\n    \n    private static void setProvider0(Provider provider) {\n        if (provider == null) {\n            provider = getDefaultProvider();\n        }\n        Set<String> ids = provider.getAvailableIDs();\n        if (ids == null || ids.size() == 0) {\n            throw new IllegalArgumentException\n                (\"The provider doesn't have any available ids\");\n        }\n        if (!ids.contains(\"UTC\")) {\n            throw new IllegalArgumentException(\"The provider doesn't support UTC\");\n        }\n        if (!UTC.equals(provider.getZone(\"UTC\"))) {\n            throw new IllegalArgumentException(\"Invalid UTC zone provided\");\n        }\n        cProvider = provider;\n        cAvailableIDs = ids;\n    }\n\n    \n    private static Provider getDefaultProvider() {\n        Provider provider = null;\n\n        try {\n            String providerClass =\n                System.getProperty(\"org.joda.time.DateTimeZone.Provider\");\n            if (providerClass != null) {\n                try {\n                    provider = (Provider) Class.forName(providerClass).newInstance();\n                } catch (Exception ex) {\n                    Thread thread = Thread.currentThread();\n                    thread.getThreadGroup().uncaughtException(thread, ex);\n                }\n            }\n        } catch (SecurityException ex) {\n            \n        }\n\n        if (provider == null) {\n            try {\n                provider = new ZoneInfoProvider(\"org/joda/time/tz/data\");\n            } catch (Exception ex) {\n                Thread thread = Thread.currentThread();\n                thread.getThreadGroup().uncaughtException(thread, ex);\n            }\n        }\n\n        if (provider == null) {\n            provider = new UTCProvider();\n        }\n\n        return provider;\n    }\n\n    \n    \n    public static NameProvider getNameProvider() {\n        return cNameProvider;\n    }\n\n    \n    public static void setNameProvider(NameProvider nameProvider) throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setNameProvider\"));\n        }\n        setNameProvider0(nameProvider);\n    }\n\n    \n    private static void setNameProvider0(NameProvider nameProvider) {\n        if (nameProvider == null) {\n            nameProvider = getDefaultNameProvider();\n        }\n        cNameProvider = nameProvider;\n    }\n\n    \n    private static NameProvider getDefaultNameProvider() {\n        NameProvider nameProvider = null;\n        try {\n            String providerClass = System.getProperty(\"org.joda.time.DateTimeZone.NameProvider\");\n            if (providerClass != null) {\n                try {\n                    nameProvider = (NameProvider) Class.forName(providerClass).newInstance();\n                } catch (Exception ex) {\n                    Thread thread = Thread.currentThread();\n                    thread.getThreadGroup().uncaughtException(thread, ex);\n                }\n            }\n        } catch (SecurityException ex) {\n            \n        }\n\n        if (nameProvider == null) {\n            nameProvider = new DefaultNameProvider();\n        }\n\n        return nameProvider;\n    }\n\n    \n    \n    private static synchronized String getConvertedId(String id) {\n        Map<String, String> map = cZoneIdConversion;\n        if (map == null) {\n            \n            map = new HashMap<String, String>();\n            map.put(\"GMT\", \"UTC\");\n            map.put(\"MIT\", \"Pacific/Apia\");\n            map.put(\"HST\", \"Pacific/Honolulu\");\n            map.put(\"AST\", \"America/Anchorage\");\n            map.put(\"PST\", \"America/Los_Angeles\");\n            map.put(\"MST\", \"America/Denver\");\n            map.put(\"PNT\", \"America/Phoenix\");\n            map.put(\"CST\", \"America/Chicago\");\n            map.put(\"EST\", \"America/New_York\");\n            map.put(\"IET\", \"America/Indianapolis\");\n            map.put(\"PRT\", \"America/Puerto_Rico\");\n            map.put(\"CNT\", \"America/St_Johns\");\n            map.put(\"AGT\", \"America/Buenos_Aires\");\n            map.put(\"BET\", \"America/Sao_Paulo\");\n            map.put(\"WET\", \"Europe/London\");\n            map.put(\"ECT\", \"Europe/Paris\");\n            map.put(\"ART\", \"Africa/Cairo\");\n            map.put(\"CAT\", \"Africa/Harare\");\n            map.put(\"EET\", \"Europe/Bucharest\");\n            map.put(\"EAT\", \"Africa/Addis_Ababa\");\n            map.put(\"MET\", \"Asia/Tehran\");\n            map.put(\"NET\", \"Asia/Yerevan\");\n            map.put(\"PLT\", \"Asia/Karachi\");\n            map.put(\"IST\", \"Asia/Calcutta\");\n            map.put(\"BST\", \"Asia/Dhaka\");\n            map.put(\"VST\", \"Asia/Saigon\");\n            map.put(\"CTT\", \"Asia/Shanghai\");\n            map.put(\"JST\", \"Asia/Tokyo\");\n            map.put(\"ACT\", \"Australia/Darwin\");\n            map.put(\"AET\", \"Australia/Sydney\");\n            map.put(\"SST\", \"Pacific/Guadalcanal\");\n            map.put(\"NST\", \"Pacific/Auckland\");\n            cZoneIdConversion = map;\n        }\n        return map.get(id);\n    }\n\n    private static int parseOffset(String str) {\n        \n        \n        Chronology chrono = new BaseChronology() {\n            public DateTimeZone getZone() {\n                return null;\n            }\n            public Chronology withUTC() {\n                return this;\n            }\n            public Chronology withZone(DateTimeZone zone) {\n                return this;\n            }\n            public String toString() {\n                return getClass().getName();\n            }\n        };\n        return -(int) offsetFormatter().withChronology(chrono).parseMillis(str);\n    }\n\n    \n    private static String printOffset(int offset) {\n        StringBuffer buf = new StringBuffer();\n        if (offset >= 0) {\n            buf.append('+');\n        } else {\n            buf.append('-');\n            offset = -offset;\n        }\n\n        int hours = offset / DateTimeConstants.MILLIS_PER_HOUR;\n        FormatUtils.appendPaddedInteger(buf, hours, 2);\n        offset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR;\n\n        int minutes = offset / DateTimeConstants.MILLIS_PER_MINUTE;\n        buf.append(':');\n        FormatUtils.appendPaddedInteger(buf, minutes, 2);\n        offset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n        if (offset == 0) {\n            return buf.toString();\n        }\n\n        int seconds = offset / DateTimeConstants.MILLIS_PER_SECOND;\n        buf.append(':');\n        FormatUtils.appendPaddedInteger(buf, seconds, 2);\n        offset -= seconds * DateTimeConstants.MILLIS_PER_SECOND;\n        if (offset == 0) {\n            return buf.toString();\n        }\n\n        buf.append('.');\n        FormatUtils.appendPaddedInteger(buf, offset, 3);\n        return buf.toString();\n    }\n\n    \n    private static synchronized DateTimeFormatter offsetFormatter() {\n        if (cOffsetFormatter == null) {\n            cOffsetFormatter = new DateTimeFormatterBuilder()\n                .appendTimeZoneOffset(null, true, 2, 4)\n                .toFormatter();\n        }\n        return cOffsetFormatter;\n    }\n\n    \n    \n\n    private final String iID; protected DateTimeZone(String id) {\n        if (id == null) {\n            throw new IllegalArgumentException(\"Id must not be null\");\n        }\n        iID = id;\n    }\n\n    \n    \n\n    \n    @ToString\n    public final String getID() {\n        return iID;\n    }\n\n    \n    public abstract String getNameKey(long instant); public final String getShortName(long instant) {\n        return getShortName(instant, null);\n    }\n\n    \n    public String getShortName(long instant, Locale locale) {\n        if (locale == null) {\n            locale = Locale.getDefault();\n        }\n        String nameKey = getNameKey(instant);\n        if (nameKey == null) {\n            return iID;\n        }\n        String name = cNameProvider.getShortName(locale, iID, nameKey);\n        if (name != null) {\n            return name;\n        }\n        return printOffset(getOffset(instant));\n    }\n\n    \n    public final String getName(long instant) {\n        return getName(instant, null);\n    }\n\n    \n    public String getName(long instant, Locale locale) {\n        if (locale == null) {\n            locale = Locale.getDefault();\n        }\n        String nameKey = getNameKey(instant);\n        if (nameKey == null) {\n            return iID;\n        }\n        String name = cNameProvider.getName(locale, iID, nameKey);\n        if (name != null) {\n            return name;\n        }\n        return printOffset(getOffset(instant));\n    }\n\n    \n    public abstract int getOffset(long instant); public final int getOffset(ReadableInstant instant) {\n        if (instant == null) {\n            return getOffset(DateTimeUtils.currentTimeMillis());\n        }\n        return getOffset(instant.getMillis());\n    }\n\n    \n    public abstract int getStandardOffset(long instant); public boolean isStandardOffset(long instant) {\n        return getOffset(instant) == getStandardOffset(instant);\n    }\n\n    \n    public int getOffsetFromLocal(long instantLocal) {\n        \n        final int offsetLocal = getOffset(instantLocal);\n        \n        final long instantAdjusted = instantLocal - offsetLocal;\n        final int offsetAdjusted = getOffset(instantAdjusted);\n        \n        if (offsetLocal != offsetAdjusted) {\n            \n            \n            if ((offsetLocal - offsetAdjusted) < 0) {\n                \n                \n                \n                long nextLocal = nextTransition(instantAdjusted);\n                long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n                if (nextLocal != nextAdjusted) {\n                    return offsetLocal;\n                }\n            }\n        }\n        return offsetAdjusted;\n    }\n\n    \n    public long convertUTCToLocal(long instantUTC) {\n        int offset = getOffset(instantUTC);\n        long instantLocal = instantUTC + offset;\n        \n        if ((instantUTC ^ instantLocal) < 0 && (instantUTC ^ offset) >= 0) {\n            throw new ArithmeticException(\"Adding time zone offset caused overflow\");\n        }\n        return instantLocal;\n    }\n\n    \n    public long convertLocalToUTC(long instantLocal, boolean strict, long originalInstantUTC) {\n        int offsetOriginal = getOffset(originalInstantUTC);\n        long instantUTC = instantLocal - offsetOriginal;\n        int offsetLocalFromOriginal = getOffset(instantUTC);\n        if (offsetLocalFromOriginal == offsetOriginal) {\n            return instantUTC;\n        }\n        return convertLocalToUTC(instantLocal, strict);\n    }\n\n    \n    public long convertLocalToUTC(long instantLocal, boolean strict) {\n        \n        int offsetLocal = getOffset(instantLocal);\n        \n        int offset = getOffset(instantLocal - offsetLocal);\n        \n        if (offsetLocal != offset) {\n            \n            \n            \n            if (strict || offsetLocal < 0) {\n                \n                long nextLocal = nextTransition(instantLocal - offsetLocal);\n                if (nextLocal == (instantLocal - offsetLocal)) {\n                    nextLocal = Long.MAX_VALUE;\n                }\n                long nextAdjusted = nextTransition(instantLocal - offset);\n                if (nextAdjusted == (instantLocal - offset)) {\n                    nextAdjusted = Long.MAX_VALUE;\n                }\n                if (nextLocal != nextAdjusted) {\n                    \n                    if (strict) {\n                        \n                        throw new IllegalArgumentException(\"Illegal instant due to time zone offset transition: \" +\n                                DateTimeFormat.forPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSS\").print(new Instant(instantLocal)) +\n                                \" (\" + getID() + \")\");\n                    } else {\n                        \n                        \n                        \n                        offset = offsetLocal;\n                    }\n                }\n            }\n        }\n        \n        long instantUTC = instantLocal - offset;\n        \n        if ((instantLocal ^ instantUTC) < 0 && (instantLocal ^ offset) < 0) {\n            throw new ArithmeticException(\"Subtracting time zone offset caused overflow\");\n        }\n        return instantUTC;\n    }\n\n    \n    public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant) {\n        if (newZone == null) {\n            newZone = DateTimeZone.getDefault();\n        }\n        if (newZone == this) {\n            return oldInstant;\n        }\n        long instantLocal = oldInstant + getOffset(oldInstant);\n        return instantLocal - newZone.getOffsetFromLocal(instantLocal);\n    }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n        \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n    public boolean isLocalDateTimeGap(LocalDateTime localDateTime) {\n        if (isFixed()) {\n            return false;\n        }\n        try {\n            localDateTime.toDateTime(this);\n            return false;\n        } catch (IllegalArgumentException ex) {\n            return true;\n        }\n    }\n\n    \n    \n    public abstract boolean isFixed(); public abstract long nextTransition(long instant); public abstract long previousTransition(long instant); public java.util.TimeZone toTimeZone() {\n        return java.util.TimeZone.getTimeZone(iID);\n    }\n\n    \n    public abstract boolean equals(Object object); public int hashCode() {\n        return 57 + getID().hashCode();\n    }\n\n    \n    public String toString() {\n        return getID();\n    }\n\n    \n    protected Object writeReplace() throws ObjectStreamException {\n        return new Stub(iID);\n    }\n\n    \n    private static final class Stub implements Serializable { private static final long serialVersionUID = -6471952376487863581L; private transient String iID; Stub(String id) {\n            iID = id;\n        }\n\n        private void writeObject(ObjectOutputStream out) throws IOException {\n            out.writeUTF(iID);\n        }\n\n        private void readObject(ObjectInputStream in) throws IOException {\n            iID = in.readUTF();\n        }\n\n        private Object readResolve() throws ObjectStreamException {\n            return forID(iID);\n        }\n    }\n}\n",
      "fixed_full_code": "\npackage org.joda.time;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.ObjectStreamException;\nimport java.io.Serializable;\nimport java.lang.ref.Reference;\nimport java.lang.ref.SoftReference;\nimport java.util.HashMap;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TimeZone;\n\nimport org.joda.convert.FromString;\nimport org.joda.convert.ToString;\nimport org.joda.time.chrono.BaseChronology;\nimport org.joda.time.field.FieldUtils;\nimport org.joda.time.format.DateTimeFormat;\nimport org.joda.time.format.DateTimeFormatter;\nimport org.joda.time.format.DateTimeFormatterBuilder;\nimport org.joda.time.format.FormatUtils;\nimport org.joda.time.tz.DefaultNameProvider;\nimport org.joda.time.tz.FixedDateTimeZone;\nimport org.joda.time.tz.NameProvider;\nimport org.joda.time.tz.Provider;\nimport org.joda.time.tz.UTCProvider;\nimport org.joda.time.tz.ZoneInfoProvider;\n\n\npublic abstract class DateTimeZone implements Serializable { private static final long serialVersionUID = 5546345482340108586L; public static final DateTimeZone UTC = new FixedDateTimeZone(\"UTC\", \"UTC\", 0, 0); private static Provider cProvider; private static NameProvider cNameProvider; private static Set<String> cAvailableIDs; private static volatile DateTimeZone cDefault; private static DateTimeFormatter cOffsetFormatter; private static Map<String, SoftReference<DateTimeZone>> iFixedOffsetCache; private static Map<String, String> cZoneIdConversion; static {\n        setProvider0(null);\n        setNameProvider0(null);\n    }\n\n    \n    \n    public static DateTimeZone getDefault() {\n        DateTimeZone zone = cDefault;\n        if (zone == null) {\n            synchronized(DateTimeZone.class) {\n                zone = cDefault;\n                if (zone == null) {\n                    DateTimeZone temp = null;\n                    try {\n                        try {\n                            String id = System.getProperty(\"user.timezone\");\n                            if (id != null) {  \n                                temp = forID(id);\n                            }\n                        } catch (RuntimeException ex) {\n                            \n                        }\n                        if (temp == null) {\n                            temp = forTimeZone(TimeZone.getDefault());\n                        }\n                    } catch (IllegalArgumentException ex) {\n                        \n                    }\n                    if (temp == null) {\n                        temp = UTC;\n                    }\n                    cDefault = zone = temp;\n                }\n            }\n        }\n        return zone;\n    }\n\n    \n    public static void setDefault(DateTimeZone zone) throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setDefault\"));\n        }\n        if (zone == null) {\n            throw new IllegalArgumentException(\"The datetime zone must not be null\");\n        }\n        synchronized(DateTimeZone.class) {\n            cDefault = zone;\n        }\n    }\n\n    \n    \n    @FromString\n    public static DateTimeZone forID(String id) {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        DateTimeZone zone = cProvider.getZone(id);\n        if (zone != null) {\n            return zone;\n        }\n        if (id.startsWith(\"+\") || id.startsWith(\"-\")) {\n            int offset = parseOffset(id);\n            if (offset == 0L) {\n                return DateTimeZone.UTC;\n            } else {\n                id = printOffset(offset);\n                return fixedOffsetZone(id, offset);\n            }\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }\n\n    \n    public static DateTimeZone forOffsetHours(int hoursOffset) throws IllegalArgumentException {\n        return forOffsetHoursMinutes(hoursOffset, 0);\n    }\n\n    \n    public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException {\n        if (hoursOffset == 0 && minutesOffset == 0) {\n            return DateTimeZone.UTC;\n        }\n        if (minutesOffset < 0 || minutesOffset > 59) {\n            throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n        }\n        int offset = 0;\n        try {\n            int hoursInMinutes = FieldUtils.safeMultiply(hoursOffset, 60);\n            if (hoursInMinutes < 0) {\n                minutesOffset = FieldUtils.safeAdd(hoursInMinutes, -minutesOffset);\n            } else {\n                minutesOffset = FieldUtils.safeAdd(hoursInMinutes, minutesOffset);\n            }\n            offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);\n        } catch (ArithmeticException ex) {\n            throw new IllegalArgumentException(\"Offset is too large\");\n        }\n        return forOffsetMillis(offset);\n    }\n\n    \n    public static DateTimeZone forOffsetMillis(int millisOffset) {\n        String id = printOffset(millisOffset);\n        return fixedOffsetZone(id, millisOffset);\n    }\n\n    \n    public static DateTimeZone forTimeZone(TimeZone zone) {\n        if (zone == null) {\n            return getDefault();\n        }\n        final String id = zone.getID();\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n\n        \n        DateTimeZone dtz = null;\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) {\n            dtz = cProvider.getZone(id);\n        }\n        if (dtz != null) {\n            return dtz;\n        }\n\n        \n        if (convId == null) {\n            convId = zone.getDisplayName();\n            if (convId.startsWith(\"GMT+\") || convId.startsWith(\"GMT-\")) {\n                convId = convId.substring(3);\n                int offset = parseOffset(convId);\n                if (offset == 0L) {\n                    return DateTimeZone.UTC;\n                } else {\n                    convId = printOffset(offset);\n                    return fixedOffsetZone(convId, offset);\n                }\n            }\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }\n\n    \n    \n    private static synchronized DateTimeZone fixedOffsetZone(String id, int offset) {\n        if (offset == 0) {\n            return DateTimeZone.UTC;\n        }\n        if (iFixedOffsetCache == null) {\n            iFixedOffsetCache = new HashMap<String, SoftReference<DateTimeZone>>();\n        }\n        DateTimeZone zone;\n        Reference<DateTimeZone> ref = iFixedOffsetCache.get(id);\n        if (ref != null) {\n            zone = ref.get();\n            if (zone != null) {\n                return zone;\n            }\n        }\n        zone = new FixedDateTimeZone(id, null, offset, offset);\n        iFixedOffsetCache.put(id, new SoftReference<DateTimeZone>(zone));\n        return zone;\n    }\n\n    \n    public static Set<String> getAvailableIDs() {\n        return cAvailableIDs;\n    }\n\n    \n    \n    public static Provider getProvider() {\n        return cProvider;\n    }\n\n    \n    public static void setProvider(Provider provider) throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setProvider\"));\n        }\n        setProvider0(provider);\n    }\n\n    \n    private static void setProvider0(Provider provider) {\n        if (provider == null) {\n            provider = getDefaultProvider();\n        }\n        Set<String> ids = provider.getAvailableIDs();\n        if (ids == null || ids.size() == 0) {\n            throw new IllegalArgumentException\n                (\"The provider doesn't have any available ids\");\n        }\n        if (!ids.contains(\"UTC\")) {\n            throw new IllegalArgumentException(\"The provider doesn't support UTC\");\n        }\n        if (!UTC.equals(provider.getZone(\"UTC\"))) {\n            throw new IllegalArgumentException(\"Invalid UTC zone provided\");\n        }\n        cProvider = provider;\n        cAvailableIDs = ids;\n    }\n\n    \n    private static Provider getDefaultProvider() {\n        Provider provider = null;\n\n        try {\n            String providerClass =\n                System.getProperty(\"org.joda.time.DateTimeZone.Provider\");\n            if (providerClass != null) {\n                try {\n                    provider = (Provider) Class.forName(providerClass).newInstance();\n                } catch (Exception ex) {\n                    Thread thread = Thread.currentThread();\n                    thread.getThreadGroup().uncaughtException(thread, ex);\n                }\n            }\n        } catch (SecurityException ex) {\n            \n        }\n\n        if (provider == null) {\n            try {\n                provider = new ZoneInfoProvider(\"org/joda/time/tz/data\");\n            } catch (Exception ex) {\n                Thread thread = Thread.currentThread();\n                thread.getThreadGroup().uncaughtException(thread, ex);\n            }\n        }\n\n        if (provider == null) {\n            provider = new UTCProvider();\n        }\n\n        return provider;\n    }\n\n    \n    \n    public static NameProvider getNameProvider() {\n        return cNameProvider;\n    }\n\n    \n    public static void setNameProvider(NameProvider nameProvider) throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setNameProvider\"));\n        }\n        setNameProvider0(nameProvider);\n    }\n\n    \n    private static void setNameProvider0(NameProvider nameProvider) {\n        if (nameProvider == null) {\n            nameProvider = getDefaultNameProvider();\n        }\n        cNameProvider = nameProvider;\n    }\n\n    \n    private static NameProvider getDefaultNameProvider() {\n        NameProvider nameProvider = null;\n        try {\n            String providerClass = System.getProperty(\"org.joda.time.DateTimeZone.NameProvider\");\n            if (providerClass != null) {\n                try {\n                    nameProvider = (NameProvider) Class.forName(providerClass).newInstance();\n                } catch (Exception ex) {\n                    Thread thread = Thread.currentThread();\n                    thread.getThreadGroup().uncaughtException(thread, ex);\n                }\n            }\n        } catch (SecurityException ex) {\n            \n        }\n\n        if (nameProvider == null) {\n            nameProvider = new DefaultNameProvider();\n        }\n\n        return nameProvider;\n    }\n\n    \n    \n    private static synchronized String getConvertedId(String id) {\n        Map<String, String> map = cZoneIdConversion;\n        if (map == null) {\n            \n            map = new HashMap<String, String>();\n            map.put(\"GMT\", \"UTC\");\n            map.put(\"MIT\", \"Pacific/Apia\");\n            map.put(\"HST\", \"Pacific/Honolulu\");\n            map.put(\"AST\", \"America/Anchorage\");\n            map.put(\"PST\", \"America/Los_Angeles\");\n            map.put(\"MST\", \"America/Denver\");\n            map.put(\"PNT\", \"America/Phoenix\");\n            map.put(\"CST\", \"America/Chicago\");\n            map.put(\"EST\", \"America/New_York\");\n            map.put(\"IET\", \"America/Indianapolis\");\n            map.put(\"PRT\", \"America/Puerto_Rico\");\n            map.put(\"CNT\", \"America/St_Johns\");\n            map.put(\"AGT\", \"America/Buenos_Aires\");\n            map.put(\"BET\", \"America/Sao_Paulo\");\n            map.put(\"WET\", \"Europe/London\");\n            map.put(\"ECT\", \"Europe/Paris\");\n            map.put(\"ART\", \"Africa/Cairo\");\n            map.put(\"CAT\", \"Africa/Harare\");\n            map.put(\"EET\", \"Europe/Bucharest\");\n            map.put(\"EAT\", \"Africa/Addis_Ababa\");\n            map.put(\"MET\", \"Asia/Tehran\");\n            map.put(\"NET\", \"Asia/Yerevan\");\n            map.put(\"PLT\", \"Asia/Karachi\");\n            map.put(\"IST\", \"Asia/Calcutta\");\n            map.put(\"BST\", \"Asia/Dhaka\");\n            map.put(\"VST\", \"Asia/Saigon\");\n            map.put(\"CTT\", \"Asia/Shanghai\");\n            map.put(\"JST\", \"Asia/Tokyo\");\n            map.put(\"ACT\", \"Australia/Darwin\");\n            map.put(\"AET\", \"Australia/Sydney\");\n            map.put(\"SST\", \"Pacific/Guadalcanal\");\n            map.put(\"NST\", \"Pacific/Auckland\");\n            cZoneIdConversion = map;\n        }\n        return map.get(id);\n    }\n\n    private static int parseOffset(String str) {\n        \n        \n        Chronology chrono = new BaseChronology() {\n            public DateTimeZone getZone() {\n                return null;\n            }\n            public Chronology withUTC() {\n                return this;\n            }\n            public Chronology withZone(DateTimeZone zone) {\n                return this;\n            }\n            public String toString() {\n                return getClass().getName();\n            }\n        };\n        return -(int) offsetFormatter().withChronology(chrono).parseMillis(str);\n    }\n\n    \n    private static String printOffset(int offset) {\n        StringBuffer buf = new StringBuffer();\n        if (offset >= 0) {\n            buf.append('+');\n        } else {\n            buf.append('-');\n            offset = -offset;\n        }\n\n        int hours = offset / DateTimeConstants.MILLIS_PER_HOUR;\n        FormatUtils.appendPaddedInteger(buf, hours, 2);\n        offset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR;\n\n        int minutes = offset / DateTimeConstants.MILLIS_PER_MINUTE;\n        buf.append(':');\n        FormatUtils.appendPaddedInteger(buf, minutes, 2);\n        offset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n        if (offset == 0) {\n            return buf.toString();\n        }\n\n        int seconds = offset / DateTimeConstants.MILLIS_PER_SECOND;\n        buf.append(':');\n        FormatUtils.appendPaddedInteger(buf, seconds, 2);\n        offset -= seconds * DateTimeConstants.MILLIS_PER_SECOND;\n        if (offset == 0) {\n            return buf.toString();\n        }\n\n        buf.append('.');\n        FormatUtils.appendPaddedInteger(buf, offset, 3);\n        return buf.toString();\n    }\n\n    \n    private static synchronized DateTimeFormatter offsetFormatter() {\n        if (cOffsetFormatter == null) {\n            cOffsetFormatter = new DateTimeFormatterBuilder()\n                .appendTimeZoneOffset(null, true, 2, 4)\n                .toFormatter();\n        }\n        return cOffsetFormatter;\n    }\n\n    \n    \n\n    private final String iID; protected DateTimeZone(String id) {\n        if (id == null) {\n            throw new IllegalArgumentException(\"Id must not be null\");\n        }\n        iID = id;\n    }\n\n    \n    \n\n    \n    @ToString\n    public final String getID() {\n        return iID;\n    }\n\n    \n    public abstract String getNameKey(long instant); public final String getShortName(long instant) {\n        return getShortName(instant, null);\n    }\n\n    \n    public String getShortName(long instant, Locale locale) {\n        if (locale == null) {\n            locale = Locale.getDefault();\n        }\n        String nameKey = getNameKey(instant);\n        if (nameKey == null) {\n            return iID;\n        }\n        String name = cNameProvider.getShortName(locale, iID, nameKey);\n        if (name != null) {\n            return name;\n        }\n        return printOffset(getOffset(instant));\n    }\n\n    \n    public final String getName(long instant) {\n        return getName(instant, null);\n    }\n\n    \n    public String getName(long instant, Locale locale) {\n        if (locale == null) {\n            locale = Locale.getDefault();\n        }\n        String nameKey = getNameKey(instant);\n        if (nameKey == null) {\n            return iID;\n        }\n        String name = cNameProvider.getName(locale, iID, nameKey);\n        if (name != null) {\n            return name;\n        }\n        return printOffset(getOffset(instant));\n    }\n\n    \n    public abstract int getOffset(long instant); public final int getOffset(ReadableInstant instant) {\n        if (instant == null) {\n            return getOffset(DateTimeUtils.currentTimeMillis());\n        }\n        return getOffset(instant.getMillis());\n    }\n\n    \n    public abstract int getStandardOffset(long instant); public boolean isStandardOffset(long instant) {\n        return getOffset(instant) == getStandardOffset(instant);\n    }\n\n    \n    public int getOffsetFromLocal(long instantLocal) {\n        \n        final int offsetLocal = getOffset(instantLocal);\n        \n        final long instantAdjusted = instantLocal - offsetLocal;\n        final int offsetAdjusted = getOffset(instantAdjusted);\n        \n        if (offsetLocal != offsetAdjusted) {\n            \n            \n            if ((offsetLocal - offsetAdjusted) < 0) {\n                \n                \n                \n                long nextLocal = nextTransition(instantAdjusted);\n                long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n                if (nextLocal != nextAdjusted) {\n                    return offsetLocal;\n                }\n            }\n        } else if (offsetLocal > 0) {\n            long prev = previousTransition(instantAdjusted);\n            if (prev < instantAdjusted) {\n                int offsetPrev = getOffset(prev);\n                int diff = offsetPrev - offsetLocal;\n                if (instantAdjusted - prev <= diff) {\n                    return offsetPrev;\n                }\n            }\n        }\n        return offsetAdjusted;\n    }\n\n    \n    public long convertUTCToLocal(long instantUTC) {\n        int offset = getOffset(instantUTC);\n        long instantLocal = instantUTC + offset;\n        \n        if ((instantUTC ^ instantLocal) < 0 && (instantUTC ^ offset) >= 0) {\n            throw new ArithmeticException(\"Adding time zone offset caused overflow\");\n        }\n        return instantLocal;\n    }\n\n    \n    public long convertLocalToUTC(long instantLocal, boolean strict, long originalInstantUTC) {\n        int offsetOriginal = getOffset(originalInstantUTC);\n        long instantUTC = instantLocal - offsetOriginal;\n        int offsetLocalFromOriginal = getOffset(instantUTC);\n        if (offsetLocalFromOriginal == offsetOriginal) {\n            return instantUTC;\n        }\n        return convertLocalToUTC(instantLocal, strict);\n    }\n\n    \n    public long convertLocalToUTC(long instantLocal, boolean strict) {\n        \n        int offsetLocal = getOffset(instantLocal);\n        \n        int offset = getOffset(instantLocal - offsetLocal);\n        \n        if (offsetLocal != offset) {\n            \n            \n            \n            if (strict || offsetLocal < 0) {\n                \n                long nextLocal = nextTransition(instantLocal - offsetLocal);\n                if (nextLocal == (instantLocal - offsetLocal)) {\n                    nextLocal = Long.MAX_VALUE;\n                }\n                long nextAdjusted = nextTransition(instantLocal - offset);\n                if (nextAdjusted == (instantLocal - offset)) {\n                    nextAdjusted = Long.MAX_VALUE;\n                }\n                if (nextLocal != nextAdjusted) {\n                    \n                    if (strict) {\n                        \n                        throw new IllegalArgumentException(\"Illegal instant due to time zone offset transition: \" +\n                                DateTimeFormat.forPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSS\").print(new Instant(instantLocal)) +\n                                \" (\" + getID() + \")\");\n                    } else {\n                        \n                        \n                        \n                        offset = offsetLocal;\n                    }\n                }\n            }\n        }\n        \n        long instantUTC = instantLocal - offset;\n        \n        if ((instantLocal ^ instantUTC) < 0 && (instantLocal ^ offset) < 0) {\n            throw new ArithmeticException(\"Subtracting time zone offset caused overflow\");\n        }\n        return instantUTC;\n    }\n\n    \n    public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant) {\n        if (newZone == null) {\n            newZone = DateTimeZone.getDefault();\n        }\n        if (newZone == this) {\n            return oldInstant;\n        }\n        long instantLocal = oldInstant + getOffset(oldInstant);\n        return instantLocal - newZone.getOffsetFromLocal(instantLocal);\n    }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n        \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n    public boolean isLocalDateTimeGap(LocalDateTime localDateTime) {\n        if (isFixed()) {\n            return false;\n        }\n        try {\n            localDateTime.toDateTime(this);\n            return false;\n        } catch (IllegalArgumentException ex) {\n            return true;\n        }\n    }\n\n    \n    \n    public abstract boolean isFixed(); public abstract long nextTransition(long instant); public abstract long previousTransition(long instant); public java.util.TimeZone toTimeZone() {\n        return java.util.TimeZone.getTimeZone(iID);\n    }\n\n    \n    public abstract boolean equals(Object object); public int hashCode() {\n        return 57 + getID().hashCode();\n    }\n\n    \n    public String toString() {\n        return getID();\n    }\n\n    \n    protected Object writeReplace() throws ObjectStreamException {\n        return new Stub(iID);\n    }\n\n    \n    private static final class Stub implements Serializable { private static final long serialVersionUID = -6471952376487863581L; private transient String iID; Stub(String id) {\n            iID = id;\n        }\n\n        private void writeObject(ObjectOutputStream out) throws IOException {\n            out.writeUTF(iID);\n        }\n\n        private void readObject(ObjectInputStream in) throws IOException {\n            iID = in.readUTF();\n        }\n\n        private Object readResolve() throws ObjectStreamException {\n            return forID(iID);\n        }\n    }\n}\n",
      "buggy_signatures": [
        "public static DateTimeZone getDefault()",
        "synchronized(DateTimeZone.class)",
        "public static void setDefault(DateTimeZone zone) throws SecurityException",
        "synchronized(DateTimeZone.class)",
        "public static DateTimeZone forID(String id)",
        "public static DateTimeZone forOffsetHours(int hoursOffset) throws IllegalArgumentException",
        "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException",
        "public static DateTimeZone forOffsetMillis(int millisOffset)",
        "public static DateTimeZone forTimeZone(TimeZone zone)",
        "private static synchronized DateTimeZone fixedOffsetZone(String id, int offset)",
        "public static Set<String> getAvailableIDs()",
        "public static Provider getProvider()",
        "public static void setProvider(Provider provider) throws SecurityException",
        "private static void setProvider0(Provider provider)",
        "private static Provider getDefaultProvider()",
        "public static NameProvider getNameProvider()",
        "public static void setNameProvider(NameProvider nameProvider) throws SecurityException",
        "private static void setNameProvider0(NameProvider nameProvider)",
        "private static NameProvider getDefaultNameProvider()",
        "private static synchronized String getConvertedId(String id)",
        "private static int parseOffset(String str)",
        "public DateTimeZone getZone()",
        "public Chronology withUTC()",
        "public Chronology withZone(DateTimeZone zone)",
        "public String toString()",
        "private static String printOffset(int offset)",
        "private static synchronized DateTimeFormatter offsetFormatter()",
        "private final String iID; protected DateTimeZone(String id)",
        "public final String getID()",
        "public abstract String getNameKey(long instant); public final String getShortName(long instant)",
        "public String getShortName(long instant, Locale locale)",
        "public final String getName(long instant)",
        "public String getName(long instant, Locale locale)",
        "public abstract int getOffset(long instant); public final int getOffset(ReadableInstant instant)",
        "public abstract int getStandardOffset(long instant); public boolean isStandardOffset(long instant)",
        "public int getOffsetFromLocal(long instantLocal)",
        "public long convertUTCToLocal(long instantUTC)",
        "public long convertLocalToUTC(long instantLocal, boolean strict, long originalInstantUTC)",
        "public long convertLocalToUTC(long instantLocal, boolean strict)",
        "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)",
        "public boolean isLocalDateTimeGap(LocalDateTime localDateTime)",
        "public abstract boolean isFixed(); public abstract long nextTransition(long instant); public abstract long previousTransition(long instant); public java.util.TimeZone toTimeZone()",
        "public abstract boolean equals(Object object); public int hashCode()",
        "public String toString()",
        "protected Object writeReplace() throws ObjectStreamException",
        "private void writeObject(ObjectOutputStream out) throws IOException",
        "private void readObject(ObjectInputStream in) throws IOException",
        "private Object readResolve() throws ObjectStreamException"
      ],
      "fixed_signatures": [
        "public static DateTimeZone getDefault()",
        "synchronized(DateTimeZone.class)",
        "public static void setDefault(DateTimeZone zone) throws SecurityException",
        "synchronized(DateTimeZone.class)",
        "public static DateTimeZone forID(String id)",
        "public static DateTimeZone forOffsetHours(int hoursOffset) throws IllegalArgumentException",
        "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException",
        "public static DateTimeZone forOffsetMillis(int millisOffset)",
        "public static DateTimeZone forTimeZone(TimeZone zone)",
        "private static synchronized DateTimeZone fixedOffsetZone(String id, int offset)",
        "public static Set<String> getAvailableIDs()",
        "public static Provider getProvider()",
        "public static void setProvider(Provider provider) throws SecurityException",
        "private static void setProvider0(Provider provider)",
        "private static Provider getDefaultProvider()",
        "public static NameProvider getNameProvider()",
        "public static void setNameProvider(NameProvider nameProvider) throws SecurityException",
        "private static void setNameProvider0(NameProvider nameProvider)",
        "private static NameProvider getDefaultNameProvider()",
        "private static synchronized String getConvertedId(String id)",
        "private static int parseOffset(String str)",
        "public DateTimeZone getZone()",
        "public Chronology withUTC()",
        "public Chronology withZone(DateTimeZone zone)",
        "public String toString()",
        "private static String printOffset(int offset)",
        "private static synchronized DateTimeFormatter offsetFormatter()",
        "private final String iID; protected DateTimeZone(String id)",
        "public final String getID()",
        "public abstract String getNameKey(long instant); public final String getShortName(long instant)",
        "public String getShortName(long instant, Locale locale)",
        "public final String getName(long instant)",
        "public String getName(long instant, Locale locale)",
        "public abstract int getOffset(long instant); public final int getOffset(ReadableInstant instant)",
        "public abstract int getStandardOffset(long instant); public boolean isStandardOffset(long instant)",
        "public int getOffsetFromLocal(long instantLocal)",
        "public long convertUTCToLocal(long instantUTC)",
        "public long convertLocalToUTC(long instantLocal, boolean strict, long originalInstantUTC)",
        "public long convertLocalToUTC(long instantLocal, boolean strict)",
        "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)",
        "public boolean isLocalDateTimeGap(LocalDateTime localDateTime)",
        "public abstract boolean isFixed(); public abstract long nextTransition(long instant); public abstract long previousTransition(long instant); public java.util.TimeZone toTimeZone()",
        "public abstract boolean equals(Object object); public int hashCode()",
        "public String toString()",
        "protected Object writeReplace() throws ObjectStreamException",
        "private void writeObject(ObjectOutputStream out) throws IOException",
        "private void readObject(ObjectInputStream in) throws IOException",
        "private Object readResolve() throws ObjectStreamException"
      ],
      "methods": [
        {
          "buggy_method": "  public int getOffsetFromLocal(long instantLocal) {\n  \n  final int offsetLocal = getOffset(instantLocal);\n  \n  final long instantAdjusted = instantLocal - offsetLocal;\n  final int offsetAdjusted = getOffset(instantAdjusted);\n  \n  if (offsetLocal != offsetAdjusted) {\n  \n  \n  if ((offsetLocal - offsetAdjusted) < 0) {\n  \n  \n  \n  long nextLocal = nextTransition(instantAdjusted);\n  long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n  if (nextLocal != nextAdjusted) {\n  return offsetLocal;\n  }\n  }\n  }\n  return offsetAdjusted;\n  }",
          "fixed_method": "  public int getOffsetFromLocal(long instantLocal) {\n  \n  final int offsetLocal = getOffset(instantLocal);\n  \n  final long instantAdjusted = instantLocal - offsetLocal;\n  final int offsetAdjusted = getOffset(instantAdjusted);\n  \n  if (offsetLocal != offsetAdjusted) {\n  \n  \n  if ((offsetLocal - offsetAdjusted) < 0) {\n  \n  \n  \n  long nextLocal = nextTransition(instantAdjusted);\n  long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n  if (nextLocal != nextAdjusted) {\n  return offsetLocal;\n  }\n  }\n  } else if (offsetLocal > 0) {\n  long prev = previousTransition(instantAdjusted);\n  if (prev < instantAdjusted) {\n  int offsetPrev = getOffset(prev);\n  int diff = offsetPrev - offsetLocal;\n  if (instantAdjusted - prev <= diff) {\n  return offsetPrev;\n  }\n  }\n  }\n  return offsetAdjusted;\n  }",
          "diff": [
            "@@ -894,6 +894,15 @@",
            "                 long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n",
            "                 if (nextLocal != nextAdjusted) {\n",
            "                     return offsetLocal;\n",
            "+                }\n",
            "+            }\n",
            "+        } else if (offsetLocal > 0) {\n",
            "+            long prev = previousTransition(instantAdjusted);\n",
            "+            if (prev < instantAdjusted) {\n",
            "+                int offsetPrev = getOffset(prev);\n",
            "+                int diff = offsetPrev - offsetLocal;\n",
            "+                if (instantAdjusted - prev <= diff) {\n",
            "+                    return offsetPrev;\n",
            "                 }\n",
            "             }\n",
            "         }\n"
          ],
          "changed_lines": 9
        }
      ]
    }
  ]
}
