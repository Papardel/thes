{
  "bug_id": "45",
  "failed_tests": {
    "org.apache.commons.compress.archivers.tar.TarUtilsTest": [
      {
        "methodName": "testRoundTripOctalOrBinary8",
        "error": "java.lang.IllegalArgumentException",
        "message": "Value -72057594037927935 is too large for 8 byte field.",
        "fail_line": "        testRoundTripOctalOrBinary(8);",
        "test_source": "  public void testRoundTripOctalOrBinary8() {\n  testRoundTripOctalOrBinary(8);\n  }",
        "stack": [
          "TarUtils.formatBigIntegerBinary line 523, TarUtils.formatLongOctalOrBinaryBytes line 488, TarUtilsTest.checkRoundTripOctalOrBinary line 141, TarUtilsTest.testRoundTripOctalOrBinary line 163, TarUtilsTest.testRoundTripOctalOrBinary8 line 148"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/compress/archivers/tar/TarUtils.java",
      "buggy_full_code": "\npackage org.apache.commons.compress.archivers.tar;\n\nimport static org.apache.commons.compress.archivers.tar.TarConstants.CHKSUMLEN; import static org.apache.commons.compress.archivers.tar.TarConstants.CHKSUM_OFFSET; import java.io.IOException; import java.math.BigInteger; import java.nio.ByteBuffer; import org.apache.commons.compress.archivers.zip.ZipEncoding; import org.apache.commons.compress.archivers.zip.ZipEncodingHelper; public class TarUtils { private static final int BYTE_MASK = 255; static final ZipEncoding DEFAULT_ENCODING = ZipEncodingHelper.getZipEncoding(null); static final ZipEncoding FALLBACK_ENCODING = new ZipEncoding() {\n            @Override\n            public boolean canEncode(final String name) { return true; }\n\n            @Override\n            public ByteBuffer encode(final String name) {\n                final int length = name.length();\n                final byte[] buf = new byte[length];\n\n                \n                for (int i = 0; i < length; ++i) {\n                    buf[i] = (byte) name.charAt(i);\n                }\n                return ByteBuffer.wrap(buf);\n            }\n\n            @Override\n            public String decode(final byte[] buffer) {\n                final int length = buffer.length;\n                final StringBuilder result = new StringBuilder(length);\n\n                for (final byte b : buffer) {\n                    if (b == 0) { \n                        break;\n                    }\n                    result.append((char) (b & 0xFF)); \n                }\n\n                return result.toString();\n            }\n        };\n\n    \n    private TarUtils() {\n    }\n\n    \n    public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n        long    result = 0;\n        int     end = offset + length;\n        int     start = offset;\n\n        if (length < 2){\n            throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n        }\n\n        if (buffer[start] == 0) {\n            return 0L;\n        }\n\n        \n        while (start < end){\n            if (buffer[start] == ' '){\n                start++;\n            } else {\n                break;\n            }\n        }\n\n        \n        \n        \n        \n        byte trailer = buffer[end - 1];\n        while (start < end && (trailer == 0 || trailer == ' ')) {\n            end--;\n            trailer = buffer[end - 1];\n        }\n\n        for ( ;start < end; start++) {\n            final byte currentByte = buffer[start];\n            \n            if (currentByte < '0' || currentByte > '7'){\n                throw new IllegalArgumentException(\n                        exceptionMessage(buffer, offset, length, start, currentByte));\n            }\n            result = (result << 3) + (currentByte - '0'); \n            \n        }\n\n        return result;\n    }\n\n    \n    public static long parseOctalOrBinary(final byte[] buffer, final int offset, final int length) {\n\n        if ((buffer[offset] & 0x80) == 0) {\n            return parseOctal(buffer, offset, length);\n        }\n        final boolean negative = buffer[offset] == (byte) 0xff;\n        if (length < 9) {\n            return parseBinaryLong(buffer, offset, length, negative);\n        }\n        return parseBinaryBigInteger(buffer, offset, length, negative);\n    }\n\n    private static long parseBinaryLong(final byte[] buffer, final int offset, final int length, final boolean negative) {\n        if (length >= 9) {\n            throw new IllegalArgumentException(\"At offset \" + offset + \", \"\n                                               + length + \" byte binary number\"\n                                               + \" exceeds maximum signed long\"\n                                               + \" value\");\n        }\n        long val = 0;\n        for (int i = 1; i < length; i++) {\n            val = (val << 8) + (buffer[offset + i] & 0xff);\n        }\n        if (negative) {\n            \n            val--;\n            val ^= (long) Math.pow(2.0, (length - 1) * 8.0) - 1;\n        }\n        return negative ? -val : val;\n    }\n\n    private static long parseBinaryBigInteger(final byte[] buffer, final int offset, final int length, final boolean negative) {\n        final byte[] remainder = new byte[length - 1];\n        System.arraycopy(buffer, offset + 1, remainder, 0, length - 1);\n        BigInteger val = new BigInteger(remainder);\n        if (negative) {\n            \n            val = val.add(BigInteger.valueOf(-1)).not();\n        }\n        if (val.bitLength() > 63) {\n            throw new IllegalArgumentException(\"At offset \" + offset + \", \"\n                                               + length + \" byte binary number\"\n                                               + \" exceeds maximum signed long\"\n                                               + \" value\");\n        }\n        return negative ? -val.longValue() : val.longValue();\n    }\n\n    \n    public static boolean parseBoolean(final byte[] buffer, final int offset) {\n        return buffer[offset] == 1;\n    }\n\n    \n    private static String exceptionMessage(final byte[] buffer, final int offset, final int length, final int current, final byte currentByte) {\n        \n        \n        \n        \n        \n        \n        \n        String string = new String(buffer, offset, length);\n\n        string=string.replaceAll(\"\\0\", \"{NUL}\"); \n        final String s = \"Invalid byte \"+currentByte+\" at offset \"+(current-offset)+\" in '\"+string+\"' len=\"+length;\n        return s;\n    }\n\n    \n    public static String parseName(final byte[] buffer, final int offset, final int length) {\n        try {\n            return parseName(buffer, offset, length, DEFAULT_ENCODING);\n        } catch (final IOException ex) {\n            try {\n                return parseName(buffer, offset, length, FALLBACK_ENCODING);\n            } catch (final IOException ex2) {\n                \n                throw new RuntimeException(ex2); \n            }\n        }\n    }\n\n    \n    public static String parseName(final byte[] buffer, final int offset, final int length, final ZipEncoding encoding) throws IOException {\n\n        int len = length;\n        for (; len > 0; len--) {\n            if (buffer[offset + len - 1] != 0) {\n                break;\n            }\n        }\n        if (len > 0) {\n            final byte[] b = new byte[len];\n            System.arraycopy(buffer, offset, b, 0, len);\n            return encoding.decode(b);\n        }\n        return \"\";\n    }\n\n    \n    public static int formatNameBytes(final String name, final byte[] buf, final int offset, final int length) {\n        try {\n            return formatNameBytes(name, buf, offset, length, DEFAULT_ENCODING);\n        } catch (final IOException ex) {\n            try {\n                return formatNameBytes(name, buf, offset, length,\n                                       FALLBACK_ENCODING);\n            } catch (final IOException ex2) {\n                \n                throw new RuntimeException(ex2); \n            }\n        }\n    }\n\n    \n    public static int formatNameBytes(final String name, final byte[] buf, final int offset, final int length, final ZipEncoding encoding) throws IOException {\n        int len = name.length();\n        ByteBuffer b = encoding.encode(name);\n        while (b.limit() > length && len > 0) {\n            b = encoding.encode(name.substring(0, --len));\n        }\n        final int limit = b.limit() - b.position();\n        System.arraycopy(b.array(), b.arrayOffset(), buf, offset, limit);\n\n        \n        for (int i = limit; i < length; ++i) {\n            buf[offset + i] = 0;\n        }\n\n        return offset + length;\n    }\n\n    \n    public static void formatUnsignedOctalString(final long value, final byte[] buffer, final int offset, final int length) {\n        int remaining = length;\n        remaining--;\n        if (value == 0) {\n            buffer[offset + remaining--] = (byte) '0';\n        } else {\n            long val = value;\n            for (; remaining >= 0 && val != 0; --remaining) {\n                \n                buffer[offset + remaining] = (byte) ((byte) '0' + (byte) (val & 7));\n                val = val >>> 3;\n                \n            }\n            if (val != 0){\n                throw new IllegalArgumentException\n                (value+\"=\"+Long.toOctalString(value)+ \" will not fit in octal number buffer of length \"+length);\n            }\n        }\n\n        for (; remaining >= 0; --remaining) { \n            buffer[offset + remaining] = (byte) '0';\n        }\n    }\n\n    \n    public static int formatOctalBytes(final long value, final byte[] buf, final int offset, final int length) {\n\n        int idx=length-2; \n        formatUnsignedOctalString(value, buf, offset, idx);\n\n        buf[offset + idx++] = (byte) ' '; \n        buf[offset + idx]   = 0; \n\n        return offset + length;\n    }\n\n    \n    public static int formatLongOctalBytes(final long value, final byte[] buf, final int offset, final int length) {\n\n        final int idx=length-1; \n\n        formatUnsignedOctalString(value, buf, offset, idx);\n        buf[offset + idx] = (byte) ' '; \n\n        return offset + length;\n    }\n\n    \n    public static int formatLongOctalOrBinaryBytes( final long value, final byte[] buf, final int offset, final int length) {\n\n        \n        final long maxAsOctalChar = length == TarConstants.UIDLEN ? TarConstants.MAXID : TarConstants.MAXSIZE;\n\n        final boolean negative = value < 0;\n        if (!negative && value <= maxAsOctalChar) { \n            return formatLongOctalBytes(value, buf, offset, length);\n        }\n\n        if (length < 9) {\n            formatLongBinary(value, buf, offset, length, negative);\n        }\n        formatBigIntegerBinary(value, buf, offset, length, negative);\n\n        buf[offset] = (byte) (negative ? 0xff : 0x80);\n        return offset + length;\n    }\n\n    private static void formatLongBinary(final long value, final byte[] buf, final int offset, final int length, final boolean negative) {\n        final int bits = (length - 1) * 8;\n        final long max = 1l << bits;\n        long val = Math.abs(value); \n        if (val < 0 || val >= max) {\n            throw new IllegalArgumentException(\"Value \" + value +\n                \" is too large for \" + length + \" byte field.\");\n        }\n        if (negative) {\n            val ^= max - 1;\n            val++;\n            val |= 0xffl << bits;\n        }\n        for (int i = offset + length - 1; i >= offset; i--) {\n            buf[i] = (byte) val;\n            val >>= 8;\n        }\n    }\n\n    private static void formatBigIntegerBinary(final long value, final byte[] buf, final int offset, final int length, final boolean negative) {\n        final BigInteger val = BigInteger.valueOf(value);\n        final byte[] b = val.toByteArray();\n        final int len = b.length;\n        if (len > length - 1) {\n            throw new IllegalArgumentException(\"Value \" + value +\n                \" is too large for \" + length + \" byte field.\");\n        }\n        final int off = offset + length - len;\n        System.arraycopy(b, 0, buf, off, len);\n        final byte fill = (byte) (negative ? 0xff : 0);\n        for (int i = offset + 1; i < off; i++) {\n            buf[i] = fill;\n        }\n    }\n\n    \n    public static int formatCheckSumOctalBytes(final long value, final byte[] buf, final int offset, final int length) {\n\n        int idx=length-2; \n        formatUnsignedOctalString(value, buf, offset, idx);\n\n        buf[offset + idx++]   = 0; \n        buf[offset + idx]     = (byte) ' '; \n\n        return offset + length;\n    }\n\n    \n    public static long computeCheckSum(final byte[] buf) {\n        long sum = 0;\n\n        for (final byte element : buf) {\n            sum += BYTE_MASK & element;\n        }\n\n        return sum;\n    }\n\n    \n    public static boolean verifyCheckSum(final byte[] header) {\n        final long storedSum = parseOctal(header, CHKSUM_OFFSET, CHKSUMLEN);\n        long unsignedSum = 0;\n        long signedSum = 0;\n\n        for (int i = 0; i < header.length; i++) {\n            byte b = header[i];\n            if (CHKSUM_OFFSET  <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {\n                b = ' ';\n            }\n            unsignedSum += 0xff & b;\n            signedSum += b;\n        }\n        return storedSum == unsignedSum || storedSum == signedSum;\n    }\n\n}\n",
      "fixed_full_code": "\npackage org.apache.commons.compress.archivers.tar;\n\nimport static org.apache.commons.compress.archivers.tar.TarConstants.CHKSUMLEN; import static org.apache.commons.compress.archivers.tar.TarConstants.CHKSUM_OFFSET; import java.io.IOException; import java.math.BigInteger; import java.nio.ByteBuffer; import org.apache.commons.compress.archivers.zip.ZipEncoding; import org.apache.commons.compress.archivers.zip.ZipEncodingHelper; public class TarUtils { private static final int BYTE_MASK = 255; static final ZipEncoding DEFAULT_ENCODING = ZipEncodingHelper.getZipEncoding(null); static final ZipEncoding FALLBACK_ENCODING = new ZipEncoding() {\n            @Override\n            public boolean canEncode(final String name) { return true; }\n\n            @Override\n            public ByteBuffer encode(final String name) {\n                final int length = name.length();\n                final byte[] buf = new byte[length];\n\n                \n                for (int i = 0; i < length; ++i) {\n                    buf[i] = (byte) name.charAt(i);\n                }\n                return ByteBuffer.wrap(buf);\n            }\n\n            @Override\n            public String decode(final byte[] buffer) {\n                final int length = buffer.length;\n                final StringBuilder result = new StringBuilder(length);\n\n                for (final byte b : buffer) {\n                    if (b == 0) { \n                        break;\n                    }\n                    result.append((char) (b & 0xFF)); \n                }\n\n                return result.toString();\n            }\n        };\n\n    \n    private TarUtils() {\n    }\n\n    \n    public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n        long    result = 0;\n        int     end = offset + length;\n        int     start = offset;\n\n        if (length < 2){\n            throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n        }\n\n        if (buffer[start] == 0) {\n            return 0L;\n        }\n\n        \n        while (start < end){\n            if (buffer[start] == ' '){\n                start++;\n            } else {\n                break;\n            }\n        }\n\n        \n        \n        \n        \n        byte trailer = buffer[end - 1];\n        while (start < end && (trailer == 0 || trailer == ' ')) {\n            end--;\n            trailer = buffer[end - 1];\n        }\n\n        for ( ;start < end; start++) {\n            final byte currentByte = buffer[start];\n            \n            if (currentByte < '0' || currentByte > '7'){\n                throw new IllegalArgumentException(\n                        exceptionMessage(buffer, offset, length, start, currentByte));\n            }\n            result = (result << 3) + (currentByte - '0'); \n            \n        }\n\n        return result;\n    }\n\n    \n    public static long parseOctalOrBinary(final byte[] buffer, final int offset, final int length) {\n\n        if ((buffer[offset] & 0x80) == 0) {\n            return parseOctal(buffer, offset, length);\n        }\n        final boolean negative = buffer[offset] == (byte) 0xff;\n        if (length < 9) {\n            return parseBinaryLong(buffer, offset, length, negative);\n        }\n        return parseBinaryBigInteger(buffer, offset, length, negative);\n    }\n\n    private static long parseBinaryLong(final byte[] buffer, final int offset, final int length, final boolean negative) {\n        if (length >= 9) {\n            throw new IllegalArgumentException(\"At offset \" + offset + \", \"\n                                               + length + \" byte binary number\"\n                                               + \" exceeds maximum signed long\"\n                                               + \" value\");\n        }\n        long val = 0;\n        for (int i = 1; i < length; i++) {\n            val = (val << 8) + (buffer[offset + i] & 0xff);\n        }\n        if (negative) {\n            \n            val--;\n            val ^= (long) Math.pow(2.0, (length - 1) * 8.0) - 1;\n        }\n        return negative ? -val : val;\n    }\n\n    private static long parseBinaryBigInteger(final byte[] buffer, final int offset, final int length, final boolean negative) {\n        final byte[] remainder = new byte[length - 1];\n        System.arraycopy(buffer, offset + 1, remainder, 0, length - 1);\n        BigInteger val = new BigInteger(remainder);\n        if (negative) {\n            \n            val = val.add(BigInteger.valueOf(-1)).not();\n        }\n        if (val.bitLength() > 63) {\n            throw new IllegalArgumentException(\"At offset \" + offset + \", \"\n                                               + length + \" byte binary number\"\n                                               + \" exceeds maximum signed long\"\n                                               + \" value\");\n        }\n        return negative ? -val.longValue() : val.longValue();\n    }\n\n    \n    public static boolean parseBoolean(final byte[] buffer, final int offset) {\n        return buffer[offset] == 1;\n    }\n\n    \n    private static String exceptionMessage(final byte[] buffer, final int offset, final int length, final int current, final byte currentByte) {\n        \n        \n        \n        \n        \n        \n        \n        String string = new String(buffer, offset, length);\n\n        string=string.replaceAll(\"\\0\", \"{NUL}\"); \n        final String s = \"Invalid byte \"+currentByte+\" at offset \"+(current-offset)+\" in '\"+string+\"' len=\"+length;\n        return s;\n    }\n\n    \n    public static String parseName(final byte[] buffer, final int offset, final int length) {\n        try {\n            return parseName(buffer, offset, length, DEFAULT_ENCODING);\n        } catch (final IOException ex) {\n            try {\n                return parseName(buffer, offset, length, FALLBACK_ENCODING);\n            } catch (final IOException ex2) {\n                \n                throw new RuntimeException(ex2); \n            }\n        }\n    }\n\n    \n    public static String parseName(final byte[] buffer, final int offset, final int length, final ZipEncoding encoding) throws IOException {\n\n        int len = length;\n        for (; len > 0; len--) {\n            if (buffer[offset + len - 1] != 0) {\n                break;\n            }\n        }\n        if (len > 0) {\n            final byte[] b = new byte[len];\n            System.arraycopy(buffer, offset, b, 0, len);\n            return encoding.decode(b);\n        }\n        return \"\";\n    }\n\n    \n    public static int formatNameBytes(final String name, final byte[] buf, final int offset, final int length) {\n        try {\n            return formatNameBytes(name, buf, offset, length, DEFAULT_ENCODING);\n        } catch (final IOException ex) {\n            try {\n                return formatNameBytes(name, buf, offset, length,\n                                       FALLBACK_ENCODING);\n            } catch (final IOException ex2) {\n                \n                throw new RuntimeException(ex2); \n            }\n        }\n    }\n\n    \n    public static int formatNameBytes(final String name, final byte[] buf, final int offset, final int length, final ZipEncoding encoding) throws IOException {\n        int len = name.length();\n        ByteBuffer b = encoding.encode(name);\n        while (b.limit() > length && len > 0) {\n            b = encoding.encode(name.substring(0, --len));\n        }\n        final int limit = b.limit() - b.position();\n        System.arraycopy(b.array(), b.arrayOffset(), buf, offset, limit);\n\n        \n        for (int i = limit; i < length; ++i) {\n            buf[offset + i] = 0;\n        }\n\n        return offset + length;\n    }\n\n    \n    public static void formatUnsignedOctalString(final long value, final byte[] buffer, final int offset, final int length) {\n        int remaining = length;\n        remaining--;\n        if (value == 0) {\n            buffer[offset + remaining--] = (byte) '0';\n        } else {\n            long val = value;\n            for (; remaining >= 0 && val != 0; --remaining) {\n                \n                buffer[offset + remaining] = (byte) ((byte) '0' + (byte) (val & 7));\n                val = val >>> 3;\n                \n            }\n            if (val != 0){\n                throw new IllegalArgumentException\n                (value+\"=\"+Long.toOctalString(value)+ \" will not fit in octal number buffer of length \"+length);\n            }\n        }\n\n        for (; remaining >= 0; --remaining) { \n            buffer[offset + remaining] = (byte) '0';\n        }\n    }\n\n    \n    public static int formatOctalBytes(final long value, final byte[] buf, final int offset, final int length) {\n\n        int idx=length-2; \n        formatUnsignedOctalString(value, buf, offset, idx);\n\n        buf[offset + idx++] = (byte) ' '; \n        buf[offset + idx]   = 0; \n\n        return offset + length;\n    }\n\n    \n    public static int formatLongOctalBytes(final long value, final byte[] buf, final int offset, final int length) {\n\n        final int idx=length-1; \n\n        formatUnsignedOctalString(value, buf, offset, idx);\n        buf[offset + idx] = (byte) ' '; \n\n        return offset + length;\n    }\n\n    \n    public static int formatLongOctalOrBinaryBytes( final long value, final byte[] buf, final int offset, final int length) {\n\n        \n        final long maxAsOctalChar = length == TarConstants.UIDLEN ? TarConstants.MAXID : TarConstants.MAXSIZE;\n\n        final boolean negative = value < 0;\n        if (!negative && value <= maxAsOctalChar) { \n            return formatLongOctalBytes(value, buf, offset, length);\n        }\n\n        if (length < 9) {\n            formatLongBinary(value, buf, offset, length, negative);\n        } else {\n            formatBigIntegerBinary(value, buf, offset, length, negative);\n        }\n\n        buf[offset] = (byte) (negative ? 0xff : 0x80);\n        return offset + length;\n    }\n\n    private static void formatLongBinary(final long value, final byte[] buf, final int offset, final int length, final boolean negative) {\n        final int bits = (length - 1) * 8;\n        final long max = 1l << bits;\n        long val = Math.abs(value); \n        if (val < 0 || val >= max) {\n            throw new IllegalArgumentException(\"Value \" + value +\n                \" is too large for \" + length + \" byte field.\");\n        }\n        if (negative) {\n            val ^= max - 1;\n            val++;\n            val |= 0xffl << bits;\n        }\n        for (int i = offset + length - 1; i >= offset; i--) {\n            buf[i] = (byte) val;\n            val >>= 8;\n        }\n    }\n\n    private static void formatBigIntegerBinary(final long value, final byte[] buf, final int offset, final int length, final boolean negative) {\n        final BigInteger val = BigInteger.valueOf(value);\n        final byte[] b = val.toByteArray();\n        final int len = b.length;\n        if (len > length - 1) {\n            throw new IllegalArgumentException(\"Value \" + value +\n                \" is too large for \" + length + \" byte field.\");\n        }\n        final int off = offset + length - len;\n        System.arraycopy(b, 0, buf, off, len);\n        final byte fill = (byte) (negative ? 0xff : 0);\n        for (int i = offset + 1; i < off; i++) {\n            buf[i] = fill;\n        }\n    }\n\n    \n    public static int formatCheckSumOctalBytes(final long value, final byte[] buf, final int offset, final int length) {\n\n        int idx=length-2; \n        formatUnsignedOctalString(value, buf, offset, idx);\n\n        buf[offset + idx++]   = 0; \n        buf[offset + idx]     = (byte) ' '; \n\n        return offset + length;\n    }\n\n    \n    public static long computeCheckSum(final byte[] buf) {\n        long sum = 0;\n\n        for (final byte element : buf) {\n            sum += BYTE_MASK & element;\n        }\n\n        return sum;\n    }\n\n    \n    public static boolean verifyCheckSum(final byte[] header) {\n        final long storedSum = parseOctal(header, CHKSUM_OFFSET, CHKSUMLEN);\n        long unsignedSum = 0;\n        long signedSum = 0;\n\n        for (int i = 0; i < header.length; i++) {\n            byte b = header[i];\n            if (CHKSUM_OFFSET  <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {\n                b = ' ';\n            }\n            unsignedSum += 0xff & b;\n            signedSum += b;\n        }\n        return storedSum == unsignedSum || storedSum == signedSum;\n    }\n\n}\n",
      "buggy_signatures": [
        "public boolean canEncode(final String name)",
        "public ByteBuffer encode(final String name)",
        "public String decode(final byte[] buffer)",
        "private TarUtils()",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length)",
        "public static long parseOctalOrBinary(final byte[] buffer, final int offset, final int length)",
        "private static long parseBinaryLong(final byte[] buffer, final int offset, final int length, final boolean negative)",
        "private static long parseBinaryBigInteger(final byte[] buffer, final int offset, final int length, final boolean negative)",
        "public static boolean parseBoolean(final byte[] buffer, final int offset)",
        "private static String exceptionMessage(final byte[] buffer, final int offset, final int length, final int current, final byte currentByte)",
        "public static String parseName(final byte[] buffer, final int offset, final int length)",
        "public static String parseName(final byte[] buffer, final int offset, final int length, final ZipEncoding encoding) throws IOException",
        "public static int formatNameBytes(final String name, final byte[] buf, final int offset, final int length)",
        "public static int formatNameBytes(final String name, final byte[] buf, final int offset, final int length, final ZipEncoding encoding) throws IOException",
        "public static void formatUnsignedOctalString(final long value, final byte[] buffer, final int offset, final int length)",
        "public static int formatOctalBytes(final long value, final byte[] buf, final int offset, final int length)",
        "public static int formatLongOctalBytes(final long value, final byte[] buf, final int offset, final int length)",
        "public static int formatLongOctalOrBinaryBytes( final long value, final byte[] buf, final int offset, final int length)",
        "private static void formatLongBinary(final long value, final byte[] buf, final int offset, final int length, final boolean negative)",
        "private static void formatBigIntegerBinary(final long value, final byte[] buf, final int offset, final int length, final boolean negative)",
        "public static int formatCheckSumOctalBytes(final long value, final byte[] buf, final int offset, final int length)",
        "public static long computeCheckSum(final byte[] buf)",
        "public static boolean verifyCheckSum(final byte[] header)"
      ],
      "fixed_signatures": [
        "public boolean canEncode(final String name)",
        "public ByteBuffer encode(final String name)",
        "public String decode(final byte[] buffer)",
        "private TarUtils()",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length)",
        "public static long parseOctalOrBinary(final byte[] buffer, final int offset, final int length)",
        "private static long parseBinaryLong(final byte[] buffer, final int offset, final int length, final boolean negative)",
        "private static long parseBinaryBigInteger(final byte[] buffer, final int offset, final int length, final boolean negative)",
        "public static boolean parseBoolean(final byte[] buffer, final int offset)",
        "private static String exceptionMessage(final byte[] buffer, final int offset, final int length, final int current, final byte currentByte)",
        "public static String parseName(final byte[] buffer, final int offset, final int length)",
        "public static String parseName(final byte[] buffer, final int offset, final int length, final ZipEncoding encoding) throws IOException",
        "public static int formatNameBytes(final String name, final byte[] buf, final int offset, final int length)",
        "public static int formatNameBytes(final String name, final byte[] buf, final int offset, final int length, final ZipEncoding encoding) throws IOException",
        "public static void formatUnsignedOctalString(final long value, final byte[] buffer, final int offset, final int length)",
        "public static int formatOctalBytes(final long value, final byte[] buf, final int offset, final int length)",
        "public static int formatLongOctalBytes(final long value, final byte[] buf, final int offset, final int length)",
        "public static int formatLongOctalOrBinaryBytes( final long value, final byte[] buf, final int offset, final int length)",
        "private static void formatLongBinary(final long value, final byte[] buf, final int offset, final int length, final boolean negative)",
        "private static void formatBigIntegerBinary(final long value, final byte[] buf, final int offset, final int length, final boolean negative)",
        "public static int formatCheckSumOctalBytes(final long value, final byte[] buf, final int offset, final int length)",
        "public static long computeCheckSum(final byte[] buf)",
        "public static boolean verifyCheckSum(final byte[] header)"
      ],
      "methods": [
        {
          "buggy_method": "  public static int formatLongOctalOrBinaryBytes( final long value, final byte[] buf, final int offset, final int length) {\n\n  \n  final long maxAsOctalChar = length == TarConstants.UIDLEN ? TarConstants.MAXID : TarConstants.MAXSIZE;\n\n  final boolean negative = value < 0;\n  if (!negative && value <= maxAsOctalChar) { \n  return formatLongOctalBytes(value, buf, offset, length);\n  }\n\n  if (length < 9) {\n  formatLongBinary(value, buf, offset, length, negative);\n  }\n  formatBigIntegerBinary(value, buf, offset, length, negative);\n\n  buf[offset] = (byte) (negative ? 0xff : 0x80);\n  return offset + length;\n  }",
          "fixed_method": "  public static int formatLongOctalOrBinaryBytes( final long value, final byte[] buf, final int offset, final int length) {\n\n  \n  final long maxAsOctalChar = length == TarConstants.UIDLEN ? TarConstants.MAXID : TarConstants.MAXSIZE;\n\n  final boolean negative = value < 0;\n  if (!negative && value <= maxAsOctalChar) { \n  return formatLongOctalBytes(value, buf, offset, length);\n  }\n\n  if (length < 9) {\n  formatLongBinary(value, buf, offset, length, negative);\n  } else {\n  formatBigIntegerBinary(value, buf, offset, length, negative);\n  }\n\n  buf[offset] = (byte) (negative ? 0xff : 0x80);\n  return offset + length;\n  }",
          "diff": [
            "@@ -484,8 +484,9 @@",
            " \n",
            "         if (length < 9) {\n",
            "             formatLongBinary(value, buf, offset, length, negative);\n",
            "-        }\n",
            "-        formatBigIntegerBinary(value, buf, offset, length, negative);\n",
            "+        } else {\n",
            "+            formatBigIntegerBinary(value, buf, offset, length, negative);\n",
            "+        }\n",
            " \n",
            "         buf[offset] = (byte) (negative ? 0xff : 0x80);\n",
            "         return offset + length;\n"
          ],
          "changed_lines": 5
        }
      ]
    }
  ]
}
