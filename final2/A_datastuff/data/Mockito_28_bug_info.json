{
  "bug_id": "28",
  "failed_tests": {
    "org.mockitousage.bugs.InjectionByTypeShouldFirstLookForExactTypeThenAncestorTest": [
      {
        "methodName": "mock_should_be_injected_once_and_in_the_best_matching_type",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected same:<java.lang.Object@3b519b9d> was not:<mockedBean>",
        "fail_line": "        assertSame(REFERENCE, illegalInjectionExample.mockShouldNotGoInHere);",
        "test_source": "  public void mock_should_be_injected_once_and_in_the_best_matching_type() {\n  assertSame(REFERENCE, illegalInjectionExample.mockShouldNotGoInHere);\n  assertSame(mockedBean, illegalInjectionExample.mockShouldGoInHere);\n  }",
        "stack": [
          "InjectionByTypeShouldFirstLookForExactTypeThenAncestorTest.mock_should_be_injected_once_and_in_the_best_matching_type line 33, JUnit45AndHigherRunnerImpl.run line 37, MockitoJUnitRunner.run line 62"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/mockito/internal/configuration/DefaultInjectionEngine.java",
      "buggy_full_code": "\npackage org.mockito.internal.configuration;\n\nimport org.mockito.exceptions.Reporter;\nimport org.mockito.exceptions.base.MockitoException;\nimport org.mockito.internal.configuration.injection.FinalMockCandidateFilter;\nimport org.mockito.internal.configuration.injection.MockCandidateFilter;\nimport org.mockito.internal.configuration.injection.NameBasedCandidateFilter;\nimport org.mockito.internal.configuration.injection.TypeBasedCandidateFilter;\nimport org.mockito.internal.util.reflection.FieldInitializer;\n\nimport java.lang.reflect.Field;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.Set;\n\n\npublic class DefaultInjectionEngine { private final MockCandidateFilter mockCandidateFilter = new TypeBasedCandidateFilter(new NameBasedCandidateFilter(new FinalMockCandidateFilter())); private Comparator<Field> supertypesLast = new Comparator<Field>() {\n        public int compare(Field field1, Field field2) {\n            Class<?> field1Type = field1.getType();\n            Class<?> field2Type = field2.getType();\n\n            if(field1Type.isAssignableFrom(field2Type)) {\n                return 1;\n            }\n            if(field2Type.isAssignableFrom(field1Type)) {\n                return -1;\n            }\n            return 0;\n        }\n    };\n\n    \n    public void injectMocksOnFields(Set<Field> injectMocksFields, Set<Object> mocks, Object testClassInstance) {\n        for (Field field : injectMocksFields) {\n            Set<Object> mocksToBeInjected = new HashSet<Object>(mocks);\n            Object injectMocksFieldInstance = null;\n            try {\n                injectMocksFieldInstance = new FieldInitializer(testClassInstance, field).initialize();\n            } catch (MockitoException e) {\n                new Reporter().cannotInitializeForInjectMocksAnnotation(field.getName(), e);\n            }\n\n            \n            Class<?> fieldClass = injectMocksFieldInstance.getClass();\n            while (fieldClass != Object.class) {\n                injectMockCandidate(fieldClass, mocksToBeInjected, injectMocksFieldInstance);\n                fieldClass = fieldClass.getSuperclass();\n            }\n        }\n    }\n\n    private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n        for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n            mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\n        }\n    }\n\n    private Field[] orderedInstanceFieldsFrom(Class<?> awaitingInjectionClazz) {\n        Field[] declaredFields = awaitingInjectionClazz.getDeclaredFields();\n        Arrays.sort(declaredFields, supertypesLast);\n        return declaredFields;\n    }\n\n}\n",
      "fixed_full_code": "\npackage org.mockito.internal.configuration;\n\nimport org.mockito.exceptions.Reporter;\nimport org.mockito.exceptions.base.MockitoException;\nimport org.mockito.internal.configuration.injection.FinalMockCandidateFilter;\nimport org.mockito.internal.configuration.injection.MockCandidateFilter;\nimport org.mockito.internal.configuration.injection.NameBasedCandidateFilter;\nimport org.mockito.internal.configuration.injection.TypeBasedCandidateFilter;\nimport org.mockito.internal.util.reflection.FieldInitializer;\n\nimport java.lang.reflect.Field;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.Set;\n\n\npublic class DefaultInjectionEngine { private final MockCandidateFilter mockCandidateFilter = new TypeBasedCandidateFilter(new NameBasedCandidateFilter(new FinalMockCandidateFilter())); private Comparator<Field> supertypesLast = new Comparator<Field>() {\n        public int compare(Field field1, Field field2) {\n            Class<?> field1Type = field1.getType();\n            Class<?> field2Type = field2.getType();\n\n            if(field1Type.isAssignableFrom(field2Type)) {\n                return 1;\n            }\n            if(field2Type.isAssignableFrom(field1Type)) {\n                return -1;\n            }\n            return 0;\n        }\n    };\n\n    \n    public void injectMocksOnFields(Set<Field> injectMocksFields, Set<Object> mocks, Object testClassInstance) {\n        for (Field field : injectMocksFields) {\n            Set<Object> mocksToBeInjected = new HashSet<Object>(mocks);\n            Object injectMocksFieldInstance = null;\n            try {\n                injectMocksFieldInstance = new FieldInitializer(testClassInstance, field).initialize();\n            } catch (MockitoException e) {\n                new Reporter().cannotInitializeForInjectMocksAnnotation(field.getName(), e);\n            }\n\n            \n            Class<?> fieldClass = injectMocksFieldInstance.getClass();\n            while (fieldClass != Object.class) {\n                injectMockCandidate(fieldClass, mocksToBeInjected, injectMocksFieldInstance);\n                fieldClass = fieldClass.getSuperclass();\n            }\n        }\n    }\n\n    private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n        for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n            Object injected = mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\n            mocks.remove(injected);\n        }\n    }\n\n    private Field[] orderedInstanceFieldsFrom(Class<?> awaitingInjectionClazz) {\n        Field[] declaredFields = awaitingInjectionClazz.getDeclaredFields();\n        Arrays.sort(declaredFields, supertypesLast);\n        return declaredFields;\n    }\n\n}\n",
      "buggy_signatures": [
        "public int compare(Field field1, Field field2)",
        "public void injectMocksOnFields(Set<Field> injectMocksFields, Set<Object> mocks, Object testClassInstance)",
        "private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance)",
        "private Field[] orderedInstanceFieldsFrom(Class<?> awaitingInjectionClazz)"
      ],
      "fixed_signatures": [
        "public int compare(Field field1, Field field2)",
        "public void injectMocksOnFields(Set<Field> injectMocksFields, Set<Object> mocks, Object testClassInstance)",
        "private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance)",
        "private Field[] orderedInstanceFieldsFrom(Class<?> awaitingInjectionClazz)"
      ],
      "methods": [
        {
          "buggy_method": "  private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n  for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n  mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\n  }\n  }",
          "fixed_method": "  private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n  for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n  Object injected = mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\n  mocks.remove(injected);\n  }\n  }",
          "diff": [
            "@@ -90,7 +90,8 @@",
            " \n",
            "     private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n",
            "         for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n",
            "-            mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\n",
            "+            Object injected = mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\n",
            "+            mocks.remove(injected);\n",
            "         }\n",
            "     }\n",
            " \n"
          ],
          "changed_lines": 3
        }
      ]
    }
  ]
}
