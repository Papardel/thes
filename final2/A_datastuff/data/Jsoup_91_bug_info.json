{
  "bug_id": "91",
  "failed_tests": {
    "org.jsoup.integration.ConnectTest": [
      {
        "methodName": "testBinaryThrowsExceptionWhenTypeIgnored",
        "error": "junit.framework.AssertionFailedError",
        "message": "",
        "fail_line": "        assertTrue(threw);",
        "test_source": "  public void testBinaryThrowsExceptionWhenTypeIgnored() {\n  Connection con = Jsoup.connect(FileServlet.Url);\n  con.data(FileServlet.LocationParam, \"/htmltests/thumb.jpg\");\n  con.data(FileServlet.ContentTypeParam, \"image/jpeg\");\n  con.ignoreContentType(true);\n\n  boolean threw = false;\n  try {\n  con.execute();\n  Document doc = con.response().parse();\n  } catch (IOException e) {\n  threw = true;\n  assertEquals(\"Input is binary and unsupported\", e.getMessage());\n  }\n  assertTrue(threw);\n  }",
        "stack": [
          "ConnectTest.testBinaryThrowsExceptionWhenTypeIgnored line 509"
        ]
      },
      {
        "methodName": "testBinaryResultThrows",
        "error": "junit.framework.AssertionFailedError",
        "message": "",
        "fail_line": "        assertTrue(threw);",
        "test_source": "  public void testBinaryResultThrows() {\n  Connection con = Jsoup.connect(FileServlet.Url);\n  con.data(FileServlet.LocationParam, \"/htmltests/thumb.jpg\");\n  con.data(FileServlet.ContentTypeParam, \"text/html\");\n\n  boolean threw = false;\n  try {\n  con.execute();\n  Document doc = con.response().parse();\n  } catch (IOException e) {\n  threw = true;\n  assertEquals(\"Input is binary and unsupported\", e.getMessage());\n  }\n  assertTrue(threw);\n  }",
        "stack": [
          "ConnectTest.testBinaryResultThrows line 526"
        ]
      }
    ],
    "org.jsoup.integration.ParseTest": [
      {
        "methodName": "testBinaryThrowsException",
        "error": "junit.framework.AssertionFailedError",
        "message": "",
        "fail_line": "        assertTrue(threw);",
        "test_source": "  public void testBinaryThrowsException() throws IOException {\n  File in = getFile(\"/htmltests/thumb.jpg\");\n\n  boolean threw = false;\n  try {\n  Document doc = Jsoup.parse(in, \"UTF-8\");\n  } catch (IOException e) {\n  threw = true;\n  assertEquals(\"Input is binary and unsupported\", e.getMessage());\n  }\n  assertTrue(threw);\n  }",
        "stack": [
          "ParseTest.testBinaryThrowsException line 79"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/jsoup/UncheckedIOException.java",
      "buggy_full_code": "package org.jsoup;\n\nimport java.io.IOException;\n\npublic class UncheckedIOException extends RuntimeException { public UncheckedIOException(IOException cause) {\n        super(cause);\n    }\n\n\n    public IOException ioException() {\n        return (IOException) getCause();\n    }\n}\n",
      "fixed_full_code": "package org.jsoup;\n\nimport java.io.IOException;\n\npublic class UncheckedIOException extends RuntimeException { public UncheckedIOException(IOException cause) {\n        super(cause);\n    }\n\n    public UncheckedIOException(String message) {\n        super(new IOException(message));\n    }\n\n    public IOException ioException() {\n        return (IOException) getCause();\n    }\n}\n",
      "buggy_signatures": [
        "public class UncheckedIOException extends RuntimeException { public UncheckedIOException(IOException cause)",
        "public IOException ioException()"
      ],
      "fixed_signatures": [
        "public class UncheckedIOException extends RuntimeException { public UncheckedIOException(IOException cause)",
        "public UncheckedIOException(String message)",
        "public IOException ioException()"
      ],
      "methods": [
        {
          "buggy_method": "  public IOException ioException() {\n  return (IOException) getCause();\n  }",
          "fixed_method": "  public UncheckedIOException(String message) {\n  super(new IOException(message));\n  }",
          "diff": [
            "@@ -7,6 +7,9 @@",
            "         super(cause);\n",
            "     }\n",
            " \n",
            "+    public UncheckedIOException(String message) {\n",
            "+        super(new IOException(message));\n",
            "+    }\n",
            " \n",
            "     public IOException ioException() {\n",
            "         return (IOException) getCause();\n"
          ],
          "changed_lines": 3
        }
      ]
    },
    {
      "name": "org/jsoup/parser/CharacterReader.java",
      "buggy_full_code": "package org.jsoup.parser;\n\nimport org.jsoup.UncheckedIOException;\nimport org.jsoup.helper.Validate;\n\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.util.Arrays;\nimport java.util.Locale;\n\n\npublic final class CharacterReader { static final char EOF = (char) -1; private static final int maxStringCacheLen = 12; static final int maxBufferLen = 1024 * 32; private static final int readAheadLimit = (int) (maxBufferLen * 0.75); private final char[] charBuf; private final Reader reader; private int bufLength; private int bufSplitPoint; private int bufPos; private int readerPos; private int bufMark = -1; private final String[] stringCache = new String[512]; public CharacterReader(Reader input, int sz) {\n        Validate.notNull(input);\n        Validate.isTrue(input.markSupported());\n        reader = input;\n        charBuf = new char[sz > maxBufferLen ? maxBufferLen : sz];\n        bufferUp();\n\n    }\n\n    public CharacterReader(Reader input) {\n        this(input, maxBufferLen);\n    }\n\n    public CharacterReader(String input) {\n        this(new StringReader(input), input.length());\n    }\n\n    private void bufferUp() {\n        final int pos = bufPos;\n        if (pos < bufSplitPoint)\n            return;\n\n        try {\n            reader.skip(pos);\n            reader.mark(maxBufferLen);\n            final int read = reader.read(charBuf);\n            reader.reset();\n            if (read != -1) {\n                bufLength = read;\n                readerPos += pos;\n                bufPos = 0;\n                bufMark = -1;\n                bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength;\n            }\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    \n    public int pos() {\n        return readerPos + bufPos;\n    }\n\n    \n    public boolean isEmpty() {\n        bufferUp();\n        return bufPos >= bufLength;\n    }\n\n    private boolean isEmptyNoBufferUp() {\n        return bufPos >= bufLength;\n    }\n\n    \n    public char current() {\n        bufferUp();\n        return isEmptyNoBufferUp() ? EOF : charBuf[bufPos];\n    }\n\n    char consume() {\n        bufferUp();\n        char val = isEmptyNoBufferUp() ? EOF : charBuf[bufPos];\n        bufPos++;\n        return val;\n    }\n\n    void unconsume() {\n        if (bufPos < 1)\n            throw new UncheckedIOException(new IOException(\"No buffer left to unconsume\"));\n\n        bufPos--;\n    }\n\n    \n    public void advance() {\n        bufPos++;\n    }\n\n    void mark() {\n        \n        bufSplitPoint = 0;\n        bufferUp();\n        bufMark = bufPos;\n    }\n\n    void rewindToMark() {\n        if (bufMark == -1)\n            throw new UncheckedIOException(new IOException(\"Mark invalid\"));\n\n        bufPos = bufMark;\n    }\n\n    \n    int nextIndexOf(char c) {\n        \n        bufferUp();\n        for (int i = bufPos; i < bufLength; i++) {\n            if (c == charBuf[i])\n                return i - bufPos;\n        }\n        return -1;\n    }\n\n    \n    int nextIndexOf(CharSequence seq) {\n        bufferUp();\n        \n        char startChar = seq.charAt(0);\n        for (int offset = bufPos; offset < bufLength; offset++) {\n            \n            if (startChar != charBuf[offset])\n                while(++offset < bufLength && startChar != charBuf[offset]) {  }\n            int i = offset + 1;\n            int last = i + seq.length()-1;\n            if (offset < bufLength && last <= bufLength) {\n                for (int j = 1; i < last && seq.charAt(j) == charBuf[i]; i++, j++) {  }\n                if (i == last) \n                    return offset - bufPos;\n            }\n        }\n        return -1;\n    }\n\n    \n    public String consumeTo(char c) {\n        int offset = nextIndexOf(c);\n        if (offset != -1) {\n            String consumed = cacheString(charBuf, stringCache, bufPos, offset);\n            bufPos += offset;\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    String consumeTo(String seq) {\n        int offset = nextIndexOf(seq);\n        if (offset != -1) {\n            String consumed = cacheString(charBuf, stringCache, bufPos, offset);\n            bufPos += offset;\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    \n    public String consumeToAny(final char... chars) {\n        bufferUp();\n        int pos = bufPos;\n        final int start = pos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n        final int charLen = chars.length;\n        int i;\n\n        OUTER: while (pos < remaining) {\n            for (i = 0; i < charLen; i++) {\n                if (val[pos] == chars[i])\n                    break OUTER;\n            }\n            pos++;\n        }\n\n        bufPos = pos;\n        return pos > start ? cacheString(charBuf, stringCache, start, pos -start) : \"\";\n    }\n\n    String consumeToAnySorted(final char... chars) {\n        bufferUp();\n        int pos = bufPos;\n        final int start = pos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        while (pos < remaining) {\n            if (Arrays.binarySearch(chars, val[pos]) >= 0)\n                break;\n            pos++;\n        }\n        bufPos = pos;\n        return bufPos > start ? cacheString(charBuf, stringCache, start, pos -start) : \"\";\n    }\n\n    String consumeData() {\n        \n        \n        int pos = bufPos;\n        final int start = pos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        OUTER: while (pos < remaining) {\n            switch (val[pos]) {\n                case '&':\n                case '<':\n                case TokeniserState.nullChar:\n                    break OUTER;\n                default:\n                    pos++;\n            }\n        }\n        bufPos = pos;\n        return pos > start ? cacheString(charBuf, stringCache, start, pos -start) : \"\";\n    }\n\n    String consumeTagName() {\n        \n        \n        bufferUp();\n        int pos = bufPos;\n        final int start = pos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        OUTER: while (pos < remaining) {\n            switch (val[pos]) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                case '/':\n                case '>':\n                case '<':\n                case TokeniserState.nullChar:\n                    break OUTER;\n            }\n            pos++;\n        }\n\n        bufPos = pos;\n        return pos > start ? cacheString(charBuf, stringCache, start, pos -start) : \"\";\n    }\n\n    String consumeToEnd() {\n        bufferUp();\n        String data = cacheString(charBuf, stringCache, bufPos, bufLength - bufPos);\n        bufPos = bufLength;\n        return data;\n    }\n\n    String consumeLetterSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\n            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c))\n                bufPos++;\n            else\n                break;\n        }\n\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    String consumeLetterThenDigitSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\n            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c))\n                bufPos++;\n            else\n                break;\n        }\n        while (!isEmptyNoBufferUp()) {\n            char c = charBuf[bufPos];\n            if (c >= '0' && c <= '9')\n                bufPos++;\n            else\n                break;\n        }\n\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    String consumeHexSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\n            if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f'))\n                bufPos++;\n            else\n                break;\n        }\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    String consumeDigitSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\n            if (c >= '0' && c <= '9')\n                bufPos++;\n            else\n                break;\n        }\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    boolean matches(char c) {\n        return !isEmpty() && charBuf[bufPos] == c;\n\n    }\n\n    boolean matches(String seq) {\n        bufferUp();\n        int scanLength = seq.length();\n        if (scanLength > bufLength - bufPos)\n            return false;\n\n        for (int offset = 0; offset < scanLength; offset++)\n            if (seq.charAt(offset) != charBuf[bufPos +offset])\n                return false;\n        return true;\n    }\n\n    boolean matchesIgnoreCase(String seq) {\n        bufferUp();\n        int scanLength = seq.length();\n        if (scanLength > bufLength - bufPos)\n            return false;\n\n        for (int offset = 0; offset < scanLength; offset++) {\n            char upScan = Character.toUpperCase(seq.charAt(offset));\n            char upTarget = Character.toUpperCase(charBuf[bufPos + offset]);\n            if (upScan != upTarget)\n                return false;\n        }\n        return true;\n    }\n\n    boolean matchesAny(char... seq) {\n        if (isEmpty())\n            return false;\n\n        bufferUp();\n        char c = charBuf[bufPos];\n        for (char seek : seq) {\n            if (seek == c)\n                return true;\n        }\n        return false;\n    }\n\n    boolean matchesAnySorted(char[] seq) {\n        bufferUp();\n        return !isEmpty() && Arrays.binarySearch(seq, charBuf[bufPos]) >= 0;\n    }\n\n    boolean matchesLetter() {\n        if (isEmpty())\n            return false;\n        char c = charBuf[bufPos];\n        return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c);\n    }\n\n    boolean matchesDigit() {\n        if (isEmpty())\n            return false;\n        char c = charBuf[bufPos];\n        return (c >= '0' && c <= '9');\n    }\n\n    boolean matchConsume(String seq) {\n        bufferUp();\n        if (matches(seq)) {\n            bufPos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean matchConsumeIgnoreCase(String seq) {\n        if (matchesIgnoreCase(seq)) {\n            bufPos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean containsIgnoreCase(String seq) {\n        \n        String loScan = seq.toLowerCase(Locale.ENGLISH);\n        String hiScan = seq.toUpperCase(Locale.ENGLISH);\n        return (nextIndexOf(loScan) > -1) || (nextIndexOf(hiScan) > -1);\n    }\n\n\n    \n\n\n\n    @Override\n    public String toString() {\n        return new String(charBuf, bufPos, bufLength - bufPos);\n    }\n\n    \n    private static String cacheString(final char[] charBuf, final String[] stringCache, final int start, final int count) {\n        \n        if (count > maxStringCacheLen)\n            return new String(charBuf, start, count);\n        if (count < 1)\n            return \"\";\n\n        \n        int hash = 0;\n        int offset = start;\n        for (int i = 0; i < count; i++) {\n            hash = 31 * hash + charBuf[offset++];\n        }\n\n        \n        final int index = hash & stringCache.length - 1;\n        String cached = stringCache[index];\n\n        if (cached == null) { \n            cached = new String(charBuf, start, count);\n            stringCache[index] = cached;\n        } else { \n            if (rangeEquals(charBuf, start, count, cached)) { \n                return cached;\n            } else { \n                cached = new String(charBuf, start, count);\n                stringCache[index] = cached; \n            }\n        }\n        return cached;\n    }\n\n    \n    static boolean rangeEquals(final char[] charBuf, final int start, int count, final String cached) {\n        if (count == cached.length()) {\n            int i = start;\n            int j = 0;\n            while (count-- != 0) {\n                if (charBuf[i++] != cached.charAt(j++))\n                    return false;\n            }\n            return true;\n        }\n        return false;\n    }\n\n    \n    boolean rangeEquals(final int start, final int count, final String cached) {\n        return rangeEquals(charBuf, start, count, cached);\n    }\n}\n",
      "fixed_full_code": "package org.jsoup.parser;\n\nimport org.jsoup.UncheckedIOException;\nimport org.jsoup.helper.Validate;\n\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.util.Arrays;\nimport java.util.Locale;\n\n\npublic final class CharacterReader { static final char EOF = (char) -1; private static final int maxStringCacheLen = 12; static final int maxBufferLen = 1024 * 32; private static final int readAheadLimit = (int) (maxBufferLen * 0.75); private final char[] charBuf; private final Reader reader; private int bufLength; private int bufSplitPoint; private int bufPos; private int readerPos; private int bufMark = -1; private final String[] stringCache = new String[512]; public CharacterReader(Reader input, int sz) {\n        Validate.notNull(input);\n        Validate.isTrue(input.markSupported());\n        reader = input;\n        charBuf = new char[sz > maxBufferLen ? maxBufferLen : sz];\n        bufferUp();\n\n        if (isBinary()) {\n            throw new UncheckedIOException(\"Input is binary and unsupported\");\n        }\n    }\n\n    public CharacterReader(Reader input) {\n        this(input, maxBufferLen);\n    }\n\n    public CharacterReader(String input) {\n        this(new StringReader(input), input.length());\n    }\n\n    private void bufferUp() {\n        final int pos = bufPos;\n        if (pos < bufSplitPoint)\n            return;\n\n        try {\n            reader.skip(pos);\n            reader.mark(maxBufferLen);\n            final int read = reader.read(charBuf);\n            reader.reset();\n            if (read != -1) {\n                bufLength = read;\n                readerPos += pos;\n                bufPos = 0;\n                bufMark = -1;\n                bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength;\n            }\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    \n    public int pos() {\n        return readerPos + bufPos;\n    }\n\n    \n    public boolean isEmpty() {\n        bufferUp();\n        return bufPos >= bufLength;\n    }\n\n    private boolean isEmptyNoBufferUp() {\n        return bufPos >= bufLength;\n    }\n\n    \n    public char current() {\n        bufferUp();\n        return isEmptyNoBufferUp() ? EOF : charBuf[bufPos];\n    }\n\n    char consume() {\n        bufferUp();\n        char val = isEmptyNoBufferUp() ? EOF : charBuf[bufPos];\n        bufPos++;\n        return val;\n    }\n\n    void unconsume() {\n        if (bufPos < 1)\n            throw new UncheckedIOException(new IOException(\"No buffer left to unconsume\"));\n\n        bufPos--;\n    }\n\n    \n    public void advance() {\n        bufPos++;\n    }\n\n    void mark() {\n        \n        bufSplitPoint = 0;\n        bufferUp();\n        bufMark = bufPos;\n    }\n\n    void rewindToMark() {\n        if (bufMark == -1)\n            throw new UncheckedIOException(new IOException(\"Mark invalid\"));\n\n        bufPos = bufMark;\n    }\n\n    \n    int nextIndexOf(char c) {\n        \n        bufferUp();\n        for (int i = bufPos; i < bufLength; i++) {\n            if (c == charBuf[i])\n                return i - bufPos;\n        }\n        return -1;\n    }\n\n    \n    int nextIndexOf(CharSequence seq) {\n        bufferUp();\n        \n        char startChar = seq.charAt(0);\n        for (int offset = bufPos; offset < bufLength; offset++) {\n            \n            if (startChar != charBuf[offset])\n                while(++offset < bufLength && startChar != charBuf[offset]) {  }\n            int i = offset + 1;\n            int last = i + seq.length()-1;\n            if (offset < bufLength && last <= bufLength) {\n                for (int j = 1; i < last && seq.charAt(j) == charBuf[i]; i++, j++) {  }\n                if (i == last) \n                    return offset - bufPos;\n            }\n        }\n        return -1;\n    }\n\n    \n    public String consumeTo(char c) {\n        int offset = nextIndexOf(c);\n        if (offset != -1) {\n            String consumed = cacheString(charBuf, stringCache, bufPos, offset);\n            bufPos += offset;\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    String consumeTo(String seq) {\n        int offset = nextIndexOf(seq);\n        if (offset != -1) {\n            String consumed = cacheString(charBuf, stringCache, bufPos, offset);\n            bufPos += offset;\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    \n    public String consumeToAny(final char... chars) {\n        bufferUp();\n        int pos = bufPos;\n        final int start = pos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n        final int charLen = chars.length;\n        int i;\n\n        OUTER: while (pos < remaining) {\n            for (i = 0; i < charLen; i++) {\n                if (val[pos] == chars[i])\n                    break OUTER;\n            }\n            pos++;\n        }\n\n        bufPos = pos;\n        return pos > start ? cacheString(charBuf, stringCache, start, pos -start) : \"\";\n    }\n\n    String consumeToAnySorted(final char... chars) {\n        bufferUp();\n        int pos = bufPos;\n        final int start = pos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        while (pos < remaining) {\n            if (Arrays.binarySearch(chars, val[pos]) >= 0)\n                break;\n            pos++;\n        }\n        bufPos = pos;\n        return bufPos > start ? cacheString(charBuf, stringCache, start, pos -start) : \"\";\n    }\n\n    String consumeData() {\n        \n        \n        int pos = bufPos;\n        final int start = pos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        OUTER: while (pos < remaining) {\n            switch (val[pos]) {\n                case '&':\n                case '<':\n                case TokeniserState.nullChar:\n                    break OUTER;\n                default:\n                    pos++;\n            }\n        }\n        bufPos = pos;\n        return pos > start ? cacheString(charBuf, stringCache, start, pos -start) : \"\";\n    }\n\n    String consumeTagName() {\n        \n        \n        bufferUp();\n        int pos = bufPos;\n        final int start = pos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        OUTER: while (pos < remaining) {\n            switch (val[pos]) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                case '/':\n                case '>':\n                case '<':\n                case TokeniserState.nullChar:\n                    break OUTER;\n            }\n            pos++;\n        }\n\n        bufPos = pos;\n        return pos > start ? cacheString(charBuf, stringCache, start, pos -start) : \"\";\n    }\n\n    String consumeToEnd() {\n        bufferUp();\n        String data = cacheString(charBuf, stringCache, bufPos, bufLength - bufPos);\n        bufPos = bufLength;\n        return data;\n    }\n\n    String consumeLetterSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\n            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c))\n                bufPos++;\n            else\n                break;\n        }\n\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    String consumeLetterThenDigitSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\n            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c))\n                bufPos++;\n            else\n                break;\n        }\n        while (!isEmptyNoBufferUp()) {\n            char c = charBuf[bufPos];\n            if (c >= '0' && c <= '9')\n                bufPos++;\n            else\n                break;\n        }\n\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    String consumeHexSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\n            if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f'))\n                bufPos++;\n            else\n                break;\n        }\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    String consumeDigitSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\n            if (c >= '0' && c <= '9')\n                bufPos++;\n            else\n                break;\n        }\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    boolean matches(char c) {\n        return !isEmpty() && charBuf[bufPos] == c;\n\n    }\n\n    boolean matches(String seq) {\n        bufferUp();\n        int scanLength = seq.length();\n        if (scanLength > bufLength - bufPos)\n            return false;\n\n        for (int offset = 0; offset < scanLength; offset++)\n            if (seq.charAt(offset) != charBuf[bufPos +offset])\n                return false;\n        return true;\n    }\n\n    boolean matchesIgnoreCase(String seq) {\n        bufferUp();\n        int scanLength = seq.length();\n        if (scanLength > bufLength - bufPos)\n            return false;\n\n        for (int offset = 0; offset < scanLength; offset++) {\n            char upScan = Character.toUpperCase(seq.charAt(offset));\n            char upTarget = Character.toUpperCase(charBuf[bufPos + offset]);\n            if (upScan != upTarget)\n                return false;\n        }\n        return true;\n    }\n\n    boolean matchesAny(char... seq) {\n        if (isEmpty())\n            return false;\n\n        bufferUp();\n        char c = charBuf[bufPos];\n        for (char seek : seq) {\n            if (seek == c)\n                return true;\n        }\n        return false;\n    }\n\n    boolean matchesAnySorted(char[] seq) {\n        bufferUp();\n        return !isEmpty() && Arrays.binarySearch(seq, charBuf[bufPos]) >= 0;\n    }\n\n    boolean matchesLetter() {\n        if (isEmpty())\n            return false;\n        char c = charBuf[bufPos];\n        return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c);\n    }\n\n    boolean matchesDigit() {\n        if (isEmpty())\n            return false;\n        char c = charBuf[bufPos];\n        return (c >= '0' && c <= '9');\n    }\n\n    boolean matchConsume(String seq) {\n        bufferUp();\n        if (matches(seq)) {\n            bufPos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean matchConsumeIgnoreCase(String seq) {\n        if (matchesIgnoreCase(seq)) {\n            bufPos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean containsIgnoreCase(String seq) {\n        \n        String loScan = seq.toLowerCase(Locale.ENGLISH);\n        String hiScan = seq.toUpperCase(Locale.ENGLISH);\n        return (nextIndexOf(loScan) > -1) || (nextIndexOf(hiScan) > -1);\n    }\n\n    private static final int numNullsConsideredBinary = 10; boolean isBinary() {\n        int nullsSeen = 0;\n\n        for (int i = bufPos; i < bufLength; i++) {\n            if (charBuf[i] == '\\0')\n                nullsSeen++;\n        }\n\n        return nullsSeen >= numNullsConsideredBinary;\n    }\n\n    @Override\n    public String toString() {\n        return new String(charBuf, bufPos, bufLength - bufPos);\n    }\n\n    \n    private static String cacheString(final char[] charBuf, final String[] stringCache, final int start, final int count) {\n        \n        if (count > maxStringCacheLen)\n            return new String(charBuf, start, count);\n        if (count < 1)\n            return \"\";\n\n        \n        int hash = 0;\n        int offset = start;\n        for (int i = 0; i < count; i++) {\n            hash = 31 * hash + charBuf[offset++];\n        }\n\n        \n        final int index = hash & stringCache.length - 1;\n        String cached = stringCache[index];\n\n        if (cached == null) { \n            cached = new String(charBuf, start, count);\n            stringCache[index] = cached;\n        } else { \n            if (rangeEquals(charBuf, start, count, cached)) { \n                return cached;\n            } else { \n                cached = new String(charBuf, start, count);\n                stringCache[index] = cached; \n            }\n        }\n        return cached;\n    }\n\n    \n    static boolean rangeEquals(final char[] charBuf, final int start, int count, final String cached) {\n        if (count == cached.length()) {\n            int i = start;\n            int j = 0;\n            while (count-- != 0) {\n                if (charBuf[i++] != cached.charAt(j++))\n                    return false;\n            }\n            return true;\n        }\n        return false;\n    }\n\n    \n    boolean rangeEquals(final int start, final int count, final String cached) {\n        return rangeEquals(charBuf, start, count, cached);\n    }\n}\n",
      "buggy_signatures": [
        "public CharacterReader(Reader input)",
        "public CharacterReader(String input)",
        "private void bufferUp()",
        "public int pos()",
        "public boolean isEmpty()",
        "private boolean isEmptyNoBufferUp()",
        "public char current()",
        "public void advance()",
        "public String consumeTo(char c)",
        "public String consumeToAny(final char... chars)",
        "public String toString()",
        "private static String cacheString(final char[] charBuf, final String[] stringCache, final int start, final int count)",
        "static boolean rangeEquals(final char[] charBuf, final int start, int count, final String cached)"
      ],
      "fixed_signatures": [
        "public CharacterReader(Reader input)",
        "public CharacterReader(String input)",
        "private void bufferUp()",
        "public int pos()",
        "public boolean isEmpty()",
        "private boolean isEmptyNoBufferUp()",
        "public char current()",
        "public void advance()",
        "public String consumeTo(char c)",
        "public String consumeToAny(final char... chars)",
        "public String toString()",
        "private static String cacheString(final char[] charBuf, final String[] stringCache, final int start, final int count)",
        "static boolean rangeEquals(final char[] charBuf, final int start, int count, final String cached)"
      ],
      "methods": [
        {
          "buggy_method": "  public CharacterReader(Reader input) {\n  this(input, maxBufferLen);\n  }",
          "fixed_method": "  public CharacterReader(Reader input, int sz) {\n  Validate.notNull(input);\n  Validate.isTrue(input.markSupported());\n  reader = input;\n  charBuf = new char[sz > maxBufferLen ? maxBufferLen : sz];\n  bufferUp();\n\n  if (isBinary()) {\n  throw new UncheckedIOException(\"Input is binary and unsupported\");\n  }\n  }",
          "diff": [
            "@@ -34,6 +34,9 @@",
            "         charBuf = new char[sz > maxBufferLen ? maxBufferLen : sz];\n",
            "         bufferUp();\n",
            " \n",
            "+        if (isBinary()) {\n",
            "+            throw new UncheckedIOException(\"Input is binary and unsupported\");\n",
            "+        }\n",
            "     }\n",
            " \n",
            "     public CharacterReader(Reader input) {\n"
          ],
          "changed_lines": 3
        },
        {
          "buggy_method": "  public String consumeToAny(final char... chars) {\n  bufferUp();\n  int pos = bufPos;\n  final int start = pos;\n  final int remaining = bufLength;\n  final char[] val = charBuf;\n  final int charLen = chars.length;\n  int i;\n\n  OUTER: while (pos < remaining) {\n  for (i = 0; i < charLen; i++) {\n  if (val[pos] == chars[i])\n  break OUTER;\n  }\n  pos++;\n  }\n\n  bufPos = pos;\n  return pos > start ? cacheString(charBuf, stringCache, start, pos -start) : \"\";\n  }",
          "fixed_method": "  public String consumeToAny(final char... chars) {\n  bufferUp();\n  int pos = bufPos;\n  final int start = pos;\n  final int remaining = bufLength;\n  final char[] val = charBuf;\n  final int charLen = chars.length;\n  int i;\n\n  OUTER: while (pos < remaining) {\n  for (i = 0; i < charLen; i++) {\n  if (val[pos] == chars[i])\n  break OUTER;\n  }\n  pos++;\n  }\n\n  bufPos = pos;\n  return pos > start ? cacheString(charBuf, stringCache, start, pos -start) : \"\";\n  }",
          "diff": [
            "@@ -449,13 +452,22 @@",
            "         return (nextIndexOf(loScan) > -1) || (nextIndexOf(hiScan) > -1);\n",
            "     }\n",
            " \n",
            "+    private static final int numNullsConsideredBinary = 10; // conservative\n",
            " \n",
            "     /**\n",
            "      *  Heuristic to determine if the current buffer looks like binary content. Reader will already hopefully be\n",
            "      *  decoded correctly, so a bunch of NULLs indicates a binary file\n",
            "      */\n",
            "-\n",
            "-\n",
            "+    boolean isBinary() {\n",
            "+        int nullsSeen = 0;\n",
            "+\n",
            "+        for (int i = bufPos; i < bufLength; i++) {\n",
            "+            if (charBuf[i] == '\\0')\n",
            "+                nullsSeen++;\n",
            "+        }\n",
            "+\n",
            "+        return nullsSeen >= numNullsConsideredBinary;\n",
            "+    }\n",
            " \n",
            "     @Override\n",
            "     public String toString() {\n"
          ],
          "changed_lines": 13
        }
      ]
    }
  ]
}
