{
  "bug_id": "21",
  "failed_tests": {
    "org.mockito.internal.creation.instance.ConstructorInstantiatorTest": [
      {
        "methodName": "creates_instances_of_inner_classes",
        "error": "org.mockito.internal.creation.instance.InstantationException",
        "message": "Unable to create mock instance of 'SomeInnerClass'.",
        "fail_line": "        assertEquals(new ConstructorInstantiator(new ChildOfThis()).newInstance(SomeInnerClass.class).getClass(), SomeInnerClass.class);",
        "test_source": "",
        "stack": [
          "ConstructorInstantiator.paramsException line 33, ConstructorInstantiator.withOuterClass line 27, ConstructorInstantiator.newInstance line 17, ConstructorInstantiatorTest.creates_instances_of_inner_classes line 21, ConstructorInstantiator.withOuterClass line 24"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/mockito/internal/creation/instance/ConstructorInstantiator.java",
      "buggy_full_code": "package org.mockito.internal.creation.instance;\n\nimport java.lang.reflect.Constructor;\n\npublic class ConstructorInstantiator implements Instantiator { private final Object outerClassInstance; public ConstructorInstantiator(Object outerClassInstance) {\n        this.outerClassInstance = outerClassInstance;\n    }\n\n    public <T> T newInstance(Class<T> cls) {\n        if (outerClassInstance == null) {\n            return noArgConstructor(cls);\n        }\n        return withOuterClass(cls);\n    }\n\n    private <T> T withOuterClass(Class<T> cls) {\n        try {\n            \n            \n            Constructor<T> c = cls.getDeclaredConstructor(outerClassInstance.getClass());\n            return c.newInstance(outerClassInstance);\n        } catch (Exception e) {\n            throw paramsException(cls, e);\n        }\n    }\n\n    private static <T> InstantationException paramsException(Class<T> cls, Exception e) {\n        return new InstantationException(\"Unable to create mock instance of '\"\n                + cls.getSimpleName() + \"'.\\nPlease ensure that the outer instance has correct type and that the target class has parameter-less constructor.\", e);\n    }\n\n\n    private static <T> T noArgConstructor(Class<T> cls) {\n        try {\n            return cls.newInstance();\n        } catch (Exception e) {\n            throw new InstantationException(\"Unable to create mock instance of '\"\n                    + cls.getSimpleName() + \"'.\\nPlease ensure it has parameter-less constructor.\", e);\n        }\n    }\n}\n",
      "fixed_full_code": "package org.mockito.internal.creation.instance;\n\nimport java.lang.reflect.Constructor;\n\npublic class ConstructorInstantiator implements Instantiator { private final Object outerClassInstance; public ConstructorInstantiator(Object outerClassInstance) {\n        this.outerClassInstance = outerClassInstance;\n    }\n\n    public <T> T newInstance(Class<T> cls) {\n        if (outerClassInstance == null) {\n            return noArgConstructor(cls);\n        }\n        return withParams(cls, outerClassInstance);\n    }\n\n    private static <T> T withParams(Class<T> cls, Object... params) {\n        try {\n            \n            \n            for (Constructor<?> constructor : cls.getDeclaredConstructors()) {\n                Class<?>[] types = constructor.getParameterTypes();\n                if (paramsMatch(types, params)) {\n                    return (T) constructor.newInstance(params);\n                }\n            }\n        } catch (Exception e) {\n            throw paramsException(cls, e);\n        }\n        throw paramsException(cls, null);\n    }\n\n    private static <T> InstantationException paramsException(Class<T> cls, Exception e) {\n        return new InstantationException(\"Unable to create mock instance of '\"\n                + cls.getSimpleName() + \"'.\\nPlease ensure that the outer instance has correct type and that the target class has parameter-less constructor.\", e);\n    }\n\n    private static boolean paramsMatch(Class<?>[] types, Object[] params) {\n        if (params.length != types.length) {\n            return false;\n        }\n        for (int i = 0; i < params.length; i++) {\n            if (!types[i].isInstance(params[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private static <T> T noArgConstructor(Class<T> cls) {\n        try {\n            return cls.newInstance();\n        } catch (Exception e) {\n            throw new InstantationException(\"Unable to create mock instance of '\"\n                    + cls.getSimpleName() + \"'.\\nPlease ensure it has parameter-less constructor.\", e);\n        }\n    }\n}\n",
      "buggy_signatures": [
        "public class ConstructorInstantiator implements Instantiator { private final Object outerClassInstance; public ConstructorInstantiator(Object outerClassInstance)",
        "public <T> T newInstance(Class<T> cls)",
        "private <T> T withOuterClass(Class<T> cls)",
        "private static <T> InstantationException paramsException(Class<T> cls, Exception e)",
        "private static <T> T noArgConstructor(Class<T> cls)"
      ],
      "fixed_signatures": [
        "public class ConstructorInstantiator implements Instantiator { private final Object outerClassInstance; public ConstructorInstantiator(Object outerClassInstance)",
        "public <T> T newInstance(Class<T> cls)",
        "private static <T> T withParams(Class<T> cls, Object... params)",
        "private static <T> InstantationException paramsException(Class<T> cls, Exception e)",
        "private static boolean paramsMatch(Class<?>[] types, Object[] params)",
        "private static <T> T noArgConstructor(Class<T> cls)"
      ],
      "methods": [
        {
          "buggy_method": "  private <T> T withOuterClass(Class<T> cls) {\n  try {\n  \n  \n  Constructor<T> c = cls.getDeclaredConstructor(outerClassInstance.getClass());\n  return c.newInstance(outerClassInstance);\n  } catch (Exception e) {\n  throw paramsException(cls, e);\n  }\n  }",
          "fixed_method": "  private static <T> T withParams(Class<T> cls, Object... params) {\n  try {\n  \n  \n  for (Constructor<?> constructor : cls.getDeclaredConstructors()) {\n  Class<?>[] types = constructor.getParameterTypes();\n  if (paramsMatch(types, params)) {\n  return (T) constructor.newInstance(params);\n  }\n  }\n  } catch (Exception e) {\n  throw paramsException(cls, e);\n  }\n  throw paramsException(cls, null);\n  }",
          "diff": [
            "@@ -14,18 +14,23 @@",
            "         if (outerClassInstance == null) {\n",
            "             return noArgConstructor(cls);\n",
            "         }\n",
            "-        return withOuterClass(cls);\n",
            "+        return withParams(cls, outerClassInstance);\n",
            "     }\n",
            " \n",
            "-    private <T> T withOuterClass(Class<T> cls) {\n",
            "+    private static <T> T withParams(Class<T> cls, Object... params) {\n",
            "         try {\n",
            "             //this is kind of overengineered because we don't need to support more params\n",
            "             //however, I know we will be needing it :)\n",
            "-            Constructor<T> c = cls.getDeclaredConstructor(outerClassInstance.getClass());\n",
            "-            return c.newInstance(outerClassInstance);\n",
            "+            for (Constructor<?> constructor : cls.getDeclaredConstructors()) {\n",
            "+                Class<?>[] types = constructor.getParameterTypes();\n",
            "+                if (paramsMatch(types, params)) {\n",
            "+                    return (T) constructor.newInstance(params);\n",
            "+                }\n",
            "+            }\n",
            "         } catch (Exception e) {\n",
            "             throw paramsException(cls, e);\n",
            "         }\n",
            "+        throw paramsException(cls, null);\n",
            "     }\n",
            " \n",
            "     private static <T> InstantationException paramsException(Class<T> cls, Exception e) {\n"
          ],
          "changed_lines": 13
        },
        {
          "buggy_method": "  private static <T> T noArgConstructor(Class<T> cls) {\n  try {\n  return cls.newInstance();\n  } catch (Exception e) {\n  throw new InstantationException(\"Unable to create mock instance of '\"\n  + cls.getSimpleName() + \"'.\\nPlease ensure it has parameter-less constructor.\", e);\n  }\n  }",
          "fixed_method": "  private static boolean paramsMatch(Class<?>[] types, Object[] params) {\n  if (params.length != types.length) {\n  return false;\n  }\n  for (int i = 0; i < params.length; i++) {\n  if (!types[i].isInstance(params[i])) {\n  return false;\n  }\n  }\n  return true;\n  }",
          "diff": [
            "@@ -33,6 +38,17 @@",
            "                 + cls.getSimpleName() + \"'.\\nPlease ensure that the outer instance has correct type and that the target class has parameter-less constructor.\", e);\n",
            "     }\n",
            " \n",
            "+    private static boolean paramsMatch(Class<?>[] types, Object[] params) {\n",
            "+        if (params.length != types.length) {\n",
            "+            return false;\n",
            "+        }\n",
            "+        for (int i = 0; i < params.length; i++) {\n",
            "+            if (!types[i].isInstance(params[i])) {\n",
            "+                return false;\n",
            "+            }\n",
            "+        }\n",
            "+        return true;\n",
            "+    }\n",
            " \n",
            "     private static <T> T noArgConstructor(Class<T> cls) {\n",
            "         try {\n"
          ],
          "changed_lines": 11
        }
      ]
    }
  ]
}
