{
  "bug_id": "18",
  "failed_tests": {
    "org.joda.time.chrono.TestGJChronology": [
      {
        "methodName": "testLeapYearRulesConstruction",
        "error": "org.joda.time.IllegalFieldValueException",
        "message": "Value 29 for dayOfMonth must be in the range [1,28]",
        "fail_line": "        DateMidnight dt = new DateMidnight(1500, 2, 29, GJChronology.getInstanceUTC());",
        "test_source": "  public void testLeapYearRulesConstruction() {\n  // 1500 not leap in Gregorian, but is leap in Julian\n  DateMidnight dt = new DateMidnight(1500, 2, 29, GJChronology.getInstanceUTC());\n  assertEquals(dt.getYear(), 1500);\n  assertEquals(dt.getMonthOfYear(), 2);\n  assertEquals(dt.getDayOfMonth(), 29);\n  }",
        "stack": [
          "FieldUtils.verifyValueBounds line 235, BasicChronology.getDateMidnightMillis line 605, BasicChronology.getDateTimeMillis line 177, GregorianChronology.getDateTimeMillis line 45, GJChronology.getDateTimeMillis line 365, BaseDateTime.<init> line 254, DateMidnight.<init> line 343, TestGJChronology.testLeapYearRulesConstruction line 496"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/joda/time/chrono/GJChronology.java",
      "buggy_full_code": "\npackage org.joda.time.chrono;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Locale;\nimport java.util.Map;\n\nimport org.joda.time.Chronology;\nimport org.joda.time.DateTimeField;\nimport org.joda.time.DateTimeUtils;\nimport org.joda.time.DateTimeZone;\nimport org.joda.time.DurationField;\nimport org.joda.time.IllegalFieldValueException;\nimport org.joda.time.Instant;\nimport org.joda.time.ReadableInstant;\nimport org.joda.time.ReadablePartial;\nimport org.joda.time.field.BaseDateTimeField;\nimport org.joda.time.field.DecoratedDurationField;\nimport org.joda.time.format.DateTimeFormatter;\nimport org.joda.time.format.ISODateTimeFormat;\n\n\npublic final class GJChronology extends AssembledChronology { private static final long serialVersionUID = -2545574827706931671L; private static long convertByYear(long instant, Chronology from, Chronology to) {\n        return to.getDateTimeMillis\n            (from.year().get(instant),\n             from.monthOfYear().get(instant),\n             from.dayOfMonth().get(instant),\n             from.millisOfDay().get(instant));\n    }\n\n    \n    private static long convertByWeekyear(final long instant, Chronology from, Chronology to) {\n        long newInstant;\n        newInstant = to.weekyear().set(0, from.weekyear().get(instant));\n        newInstant = to.weekOfWeekyear().set(newInstant, from.weekOfWeekyear().get(instant));\n        newInstant = to.dayOfWeek().set(newInstant, from.dayOfWeek().get(instant));\n        newInstant = to.millisOfDay().set(newInstant, from.millisOfDay().get(instant));\n        return newInstant;\n    }\n\n    \n    static final Instant DEFAULT_CUTOVER = new Instant(-12219292800000L); private static final Map<DateTimeZone, ArrayList<GJChronology>> cCache = new HashMap<DateTimeZone, ArrayList<GJChronology>>(); public static GJChronology getInstanceUTC() {\n        return getInstance(DateTimeZone.UTC, DEFAULT_CUTOVER, 4);\n    }\n\n    \n    public static GJChronology getInstance() {\n        return getInstance(DateTimeZone.getDefault(), DEFAULT_CUTOVER, 4);\n    }\n\n    \n    public static GJChronology getInstance(DateTimeZone zone) {\n        return getInstance(zone, DEFAULT_CUTOVER, 4);\n    }\n\n    \n    public static GJChronology getInstance( DateTimeZone zone, ReadableInstant gregorianCutover) {\n        \n        return getInstance(zone, gregorianCutover, 4);\n    }\n    \n    \n    public static synchronized GJChronology getInstance( DateTimeZone zone, ReadableInstant gregorianCutover, int minDaysInFirstWeek) {\n        \n        zone = DateTimeUtils.getZone(zone);\n        Instant cutoverInstant;\n        if (gregorianCutover == null) {\n            cutoverInstant = DEFAULT_CUTOVER;\n        } else {\n            cutoverInstant = gregorianCutover.toInstant();\n        }\n\n        GJChronology chrono;\n\n        ArrayList<GJChronology> chronos = cCache.get(zone);\n        if (chronos == null) {\n            chronos = new ArrayList<GJChronology>(2);\n            cCache.put(zone, chronos);\n        } else {\n            for (int i=chronos.size(); --i>=0; ) {\n                chrono = chronos.get(i);\n                if (minDaysInFirstWeek == chrono.getMinimumDaysInFirstWeek() &&\n                    cutoverInstant.equals(chrono.getGregorianCutover())) {\n                    \n                    return chrono;\n                }\n            }\n        }\n\n        if (zone == DateTimeZone.UTC) {\n            chrono = new GJChronology\n                (JulianChronology.getInstance(zone, minDaysInFirstWeek),\n                 GregorianChronology.getInstance(zone, minDaysInFirstWeek),\n                 cutoverInstant);\n        } else {\n            chrono = getInstance(DateTimeZone.UTC, cutoverInstant, minDaysInFirstWeek);\n            chrono = new GJChronology\n                (ZonedChronology.getInstance(chrono, zone),\n                 chrono.iJulianChronology,\n                 chrono.iGregorianChronology,\n                 chrono.iCutoverInstant);\n        }\n\n        chronos.add(chrono);\n\n        return chrono;\n    }\n\n    \n    public static GJChronology getInstance( DateTimeZone zone, long gregorianCutover, int minDaysInFirstWeek) {\n        \n        Instant cutoverInstant;\n        if (gregorianCutover == DEFAULT_CUTOVER.getMillis()) {\n            cutoverInstant = null;\n        } else {\n            cutoverInstant = new Instant(gregorianCutover);\n        }\n        return getInstance(zone, cutoverInstant, minDaysInFirstWeek);\n    }\n\n    \n    private JulianChronology iJulianChronology; private GregorianChronology iGregorianChronology; private Instant iCutoverInstant; private long iCutoverMillis; private long iGapDuration; private GJChronology(JulianChronology julian, GregorianChronology gregorian, Instant cutoverInstant) {\n        super(null, new Object[] {julian, gregorian, cutoverInstant});\n    }\n\n    \n    private GJChronology(Chronology base, JulianChronology julian, GregorianChronology gregorian, Instant cutoverInstant) {\n        super(base, new Object[] {julian, gregorian, cutoverInstant});\n    }\n\n    \n    private Object readResolve() {\n        return getInstance(getZone(), iCutoverInstant, getMinimumDaysInFirstWeek());\n    }\n\n    public DateTimeZone getZone() {\n        Chronology base;\n        if ((base = getBase()) != null) {\n            return base.getZone();\n        }\n        return DateTimeZone.UTC;\n    }\n\n    \n    \n    \n    public Chronology withUTC() {\n        return withZone(DateTimeZone.UTC);\n    }\n\n    \n    public Chronology withZone(DateTimeZone zone) {\n        if (zone == null) {\n            zone = DateTimeZone.getDefault();\n        }\n        if (zone == getZone()) {\n            return this;\n        }\n        return getInstance(zone, iCutoverInstant, getMinimumDaysInFirstWeek());\n    }\n\n    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int millisOfDay) throws IllegalArgumentException {\n        Chronology base;\n        if ((base = getBase()) != null) {\n            return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay);\n        }\n\n        \n        long instant = iGregorianChronology.getDateTimeMillis\n            (year, monthOfYear, dayOfMonth, millisOfDay);\n        if (instant < iCutoverMillis) {\n            \n            instant = iJulianChronology.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth, millisOfDay);\n            if (instant >= iCutoverMillis) {\n                \n                throw new IllegalArgumentException(\"Specified date does not exist\");\n            }\n        }\n        return instant;\n    }\n\n    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException {\n        Chronology base;\n        if ((base = getBase()) != null) {\n            return base.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n        }\n\n        \n        long instant;\n            instant = iGregorianChronology.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n        if (instant < iCutoverMillis) {\n            \n            instant = iJulianChronology.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n            if (instant >= iCutoverMillis) {\n                \n                throw new IllegalArgumentException(\"Specified date does not exist\");\n            }\n        }\n        return instant;\n    }\n\n    \n    public Instant getGregorianCutover() {\n        return iCutoverInstant;\n    }\n\n    \n    public int getMinimumDaysInFirstWeek() {\n        return iGregorianChronology.getMinimumDaysInFirstWeek();\n    }\n\n    \n    public boolean equals(Object obj) {\n        return super.equals(obj);\n    }\n\n    \n    public int hashCode() {\n        return \"GJ\".hashCode() * 11 + iJulianChronology.hashCode() +\n            iGregorianChronology.hashCode() + iCutoverInstant.hashCode();\n    }\n\n    \n    \n    \n    public String toString() {\n        StringBuffer sb = new StringBuffer(60);\n        sb.append(\"GJChronology\");\n        sb.append('[');\n        sb.append(getZone().getID());\n        \n        if (iCutoverMillis != DEFAULT_CUTOVER.getMillis()) {\n            sb.append(\",cutover=\");\n            DateTimeFormatter printer;\n            if (withUTC().dayOfYear().remainder(iCutoverMillis) == 0) {\n                printer = ISODateTimeFormat.date();\n            } else {\n                printer = ISODateTimeFormat.dateTime();\n            }\n            printer.withChronology(withUTC()).printTo(sb, iCutoverMillis);\n        }\n        \n        if (getMinimumDaysInFirstWeek() != 4) {\n            sb.append(\",mdfw=\");\n            sb.append(getMinimumDaysInFirstWeek());\n        }\n        sb.append(']');\n        \n        return sb.toString();\n    }\n\n    protected void assemble(Fields fields) {\n        Object[] params = (Object[])getParam();\n\n        JulianChronology julian = (JulianChronology)params[0];\n        GregorianChronology gregorian = (GregorianChronology)params[1];\n        Instant cutoverInstant = (Instant)params[2];\n        iCutoverMillis = cutoverInstant.getMillis();\n\n        iJulianChronology = julian;\n        iGregorianChronology = gregorian;\n        iCutoverInstant = cutoverInstant;\n\n        if (getBase() != null) {\n            return;\n        }\n\n        if (julian.getMinimumDaysInFirstWeek() != gregorian.getMinimumDaysInFirstWeek()) {\n            throw new IllegalArgumentException();\n        }\n\n        \n        iGapDuration = iCutoverMillis - julianToGregorianByYear(iCutoverMillis);\n\n        \n\n        \n        \n        fields.copyFieldsFrom(gregorian);\n        \n        \n        \n\n        \n        if (gregorian.millisOfDay().get(iCutoverMillis) == 0) {\n            \n            \n\n            fields.millisOfSecond = new CutoverField(julian.millisOfSecond(), fields.millisOfSecond, iCutoverMillis);\n            fields.millisOfDay = new CutoverField(julian.millisOfDay(), fields.millisOfDay, iCutoverMillis);\n            fields.secondOfMinute = new CutoverField(julian.secondOfMinute(), fields.secondOfMinute, iCutoverMillis);\n            fields.secondOfDay = new CutoverField(julian.secondOfDay(), fields.secondOfDay, iCutoverMillis);\n            fields.minuteOfHour = new CutoverField(julian.minuteOfHour(), fields.minuteOfHour, iCutoverMillis);\n            fields.minuteOfDay = new CutoverField(julian.minuteOfDay(), fields.minuteOfDay, iCutoverMillis);\n            fields.hourOfDay = new CutoverField(julian.hourOfDay(), fields.hourOfDay, iCutoverMillis);\n            fields.hourOfHalfday = new CutoverField(julian.hourOfHalfday(), fields.hourOfHalfday, iCutoverMillis);\n            fields.clockhourOfDay = new CutoverField(julian.clockhourOfDay(), fields.clockhourOfDay, iCutoverMillis);\n            fields.clockhourOfHalfday = new CutoverField(julian.clockhourOfHalfday(),\n                                                         fields.clockhourOfHalfday, iCutoverMillis);\n            fields.halfdayOfDay = new CutoverField(julian.halfdayOfDay(), fields.halfdayOfDay, iCutoverMillis);\n        }\n\n        \n        {\n            fields.era = new CutoverField(julian.era(), fields.era, iCutoverMillis);\n        }\n\n        \n        \n        \n        \n\n        {\n            long cutover = gregorian.year().roundCeiling(iCutoverMillis);\n            fields.dayOfYear = new CutoverField(\n                julian.dayOfYear(), fields.dayOfYear, cutover);\n        }\n\n        {\n            long cutover = gregorian.weekyear().roundCeiling(iCutoverMillis);\n            fields.weekOfWeekyear = new CutoverField(\n                julian.weekOfWeekyear(), fields.weekOfWeekyear, cutover, true);\n        }\n\n        \n        \n        \n        {\n            fields.year = new ImpreciseCutoverField(\n                julian.year(), fields.year, iCutoverMillis);\n            fields.years = fields.year.getDurationField();\n            fields.yearOfEra = new ImpreciseCutoverField(\n                julian.yearOfEra(), fields.yearOfEra, fields.years, iCutoverMillis);\n            fields.yearOfCentury = new ImpreciseCutoverField(\n                julian.yearOfCentury(), fields.yearOfCentury, fields.years, iCutoverMillis);\n            \n            fields.centuryOfEra = new ImpreciseCutoverField(\n                julian.centuryOfEra(), fields.centuryOfEra, iCutoverMillis);\n            fields.centuries = fields.centuryOfEra.getDurationField();\n            \n            fields.monthOfYear = new ImpreciseCutoverField(\n                julian.monthOfYear(), fields.monthOfYear, iCutoverMillis);\n            fields.months = fields.monthOfYear.getDurationField();\n            \n            fields.weekyear = new ImpreciseCutoverField(\n                julian.weekyear(), fields.weekyear, null, iCutoverMillis, true);\n            fields.weekyearOfCentury = new ImpreciseCutoverField(\n                julian.weekyearOfCentury(), fields.weekyearOfCentury, fields.weekyears, iCutoverMillis);\n            fields.weekyears = fields.weekyear.getDurationField();\n        }\n\n        \n        \n        {\n            CutoverField cf = new CutoverField\n                (julian.dayOfMonth(), fields.dayOfMonth, iCutoverMillis);\n            cf.iRangeDurationField = fields.months;\n            fields.dayOfMonth = cf;\n        }\n    }\n\n    long julianToGregorianByYear(long instant) {\n        return convertByYear(instant, iJulianChronology, iGregorianChronology);\n    }\n\n    long gregorianToJulianByYear(long instant) {\n        return convertByYear(instant, iGregorianChronology, iJulianChronology);\n    }\n\n    long julianToGregorianByWeekyear(long instant) {\n        return convertByWeekyear(instant, iJulianChronology, iGregorianChronology);\n    }\n\n    long gregorianToJulianByWeekyear(long instant) {\n        return convertByWeekyear(instant, iGregorianChronology, iJulianChronology);\n    }\n\n    \n    \n    private class CutoverField extends BaseDateTimeField { private static final long serialVersionUID = 3528501219481026402L; final DateTimeField iJulianField; final DateTimeField iGregorianField; final long iCutover; final boolean iConvertByWeekyear; protected DurationField iDurationField; protected DurationField iRangeDurationField; CutoverField(DateTimeField julianField, DateTimeField gregorianField, long cutoverMillis) {\n            this(julianField, gregorianField, cutoverMillis, false);\n        }\n\n        \n        CutoverField(DateTimeField julianField, DateTimeField gregorianField,\n                     long cutoverMillis, boolean convertByWeekyear) {\n            super(gregorianField.getType());\n            iJulianField = julianField;\n            iGregorianField = gregorianField;\n            iCutover = cutoverMillis;\n            iConvertByWeekyear = convertByWeekyear;\n            \n            \n            iDurationField = gregorianField.getDurationField();\n\n            DurationField rangeField = gregorianField.getRangeDurationField();\n            if (rangeField == null) {\n                rangeField = julianField.getRangeDurationField();\n            }\n            iRangeDurationField = rangeField;\n        }\n\n        public boolean isLenient() {\n            return false;\n        }\n\n        public int get(long instant) {\n            if (instant >= iCutover) {\n                return iGregorianField.get(instant);\n            } else {\n                return iJulianField.get(instant);\n            }\n        }\n\n        public String getAsText(long instant, Locale locale) {\n            if (instant >= iCutover) {\n                return iGregorianField.getAsText(instant, locale);\n            } else {\n                return iJulianField.getAsText(instant, locale);\n            }\n        }\n\n        public String getAsText(int fieldValue, Locale locale) {\n            return iGregorianField.getAsText(fieldValue, locale);\n        }\n\n        public String getAsShortText(long instant, Locale locale) {\n            if (instant >= iCutover) {\n                return iGregorianField.getAsShortText(instant, locale);\n            } else {\n                return iJulianField.getAsShortText(instant, locale);\n            }\n        }\n\n        public String getAsShortText(int fieldValue, Locale locale) {\n            return iGregorianField.getAsShortText(fieldValue, locale);\n        }\n\n        public long add(long instant, int value) {\n            return iGregorianField.add(instant, value);\n        }\n\n        public long add(long instant, long value) {\n            return iGregorianField.add(instant, value);\n        }\n\n        public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {\n            \n            \n            if (valueToAdd == 0) {\n                return values;\n            }\n            if (DateTimeUtils.isContiguous(partial)) {\n                long instant = 0L;\n                for (int i = 0, isize = partial.size(); i < isize; i++) {\n                    instant = partial.getFieldType(i).getField(GJChronology.this).set(instant, values[i]);\n                }\n                instant = add(instant, valueToAdd);\n                return GJChronology.this.get(partial, instant);\n            } else {\n                return super.add(partial, fieldIndex, values, valueToAdd);\n            }\n        }\n\n        public int getDifference(long minuendInstant, long subtrahendInstant) {\n            return iGregorianField.getDifference(minuendInstant, subtrahendInstant);\n        }\n\n        public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n            return iGregorianField.getDifferenceAsLong(minuendInstant, subtrahendInstant);\n        }\n\n        public long set(long instant, int value) {\n            if (instant >= iCutover) {\n                instant = iGregorianField.set(instant, value);\n                if (instant < iCutover) {\n                    \n                    if (instant + iGapDuration < iCutover) {\n                        instant = gregorianToJulian(instant);\n                    }\n                    \n                    if (get(instant) != value) {\n                        throw new IllegalFieldValueException\n                            (iGregorianField.getType(), Integer.valueOf(value), null, null);\n                    }\n                }\n            } else {\n                instant = iJulianField.set(instant, value);\n                if (instant >= iCutover) {\n                    \n                    if (instant - iGapDuration >= iCutover) {\n                        instant = julianToGregorian(instant);\n                    }\n                    \n                    if (get(instant) != value) {\n                       throw new IllegalFieldValueException\n                            (iJulianField.getType(), Integer.valueOf(value), null, null);\n                    }\n                }\n            }\n            return instant;\n        }\n\n        public long set(long instant, String text, Locale locale) {\n            if (instant >= iCutover) {\n                instant = iGregorianField.set(instant, text, locale);\n                if (instant < iCutover) {\n                    \n                    if (instant + iGapDuration < iCutover) {\n                        instant = gregorianToJulian(instant);\n                    }\n                    \n                }\n            } else {\n                instant = iJulianField.set(instant, text, locale);\n                if (instant >= iCutover) {\n                    \n                    if (instant - iGapDuration >= iCutover) {\n                        instant = julianToGregorian(instant);\n                    }\n                    \n                }\n            }\n            return instant;\n        }\n\n        public DurationField getDurationField() {\n            return iDurationField;\n        }\n\n        public DurationField getRangeDurationField() {\n            return iRangeDurationField;\n        }\n\n        public boolean isLeap(long instant) {\n            if (instant >= iCutover) {\n                return iGregorianField.isLeap(instant);\n            } else {\n                return iJulianField.isLeap(instant);\n            }\n        }\n\n        public int getLeapAmount(long instant) {\n            if (instant >= iCutover) {\n                return iGregorianField.getLeapAmount(instant);\n            } else {\n                return iJulianField.getLeapAmount(instant);\n            }\n        }\n\n        public DurationField getLeapDurationField() {\n            return iGregorianField.getLeapDurationField();\n        }\n\n\n        public int getMinimumValue() {\n            \n            \n            return iJulianField.getMinimumValue();\n        }\n\n        public int getMinimumValue(ReadablePartial partial) {\n            return iJulianField.getMinimumValue(partial);\n        }\n\n        public int getMinimumValue(ReadablePartial partial, int[] values) {\n            return iJulianField.getMinimumValue(partial, values);\n        }\n\n        public int getMinimumValue(long instant) {\n            if (instant < iCutover) {\n                return iJulianField.getMinimumValue(instant);\n            }\n\n            int min = iGregorianField.getMinimumValue(instant);\n\n            \n            \n            instant = iGregorianField.set(instant, min);\n            if (instant < iCutover) {\n                min = iGregorianField.get(iCutover);\n            }\n\n            return min;\n        }\n\n        public int getMaximumValue() {\n            \n            \n            return iGregorianField.getMaximumValue();\n        }\n\n        public int getMaximumValue(long instant) {\n            if (instant >= iCutover) {\n                return iGregorianField.getMaximumValue(instant);\n            }\n\n            int max = iJulianField.getMaximumValue(instant);\n\n            \n            \n            instant = iJulianField.set(instant, max);\n            if (instant >= iCutover) {\n                max = iJulianField.get(iJulianField.add(iCutover, -1));\n            }\n\n            return max;\n        }\n\n        public int getMaximumValue(ReadablePartial partial) {\n            long instant = GJChronology.getInstanceUTC().set(partial, 0L);\n            return getMaximumValue(instant);\n        }\n\n        public int getMaximumValue(ReadablePartial partial, int[] values) {\n            Chronology chrono = GJChronology.getInstanceUTC();\n            long instant = 0L;\n            for (int i = 0, isize = partial.size(); i < isize; i++) {\n                DateTimeField field = partial.getFieldType(i).getField(chrono);\n                if (values[i] <= field.getMaximumValue(instant)) {\n                    instant = field.set(instant, values[i]);\n                }\n            }\n            return getMaximumValue(instant);\n        }\n\n        public long roundFloor(long instant) {\n            if (instant >= iCutover) {\n                instant = iGregorianField.roundFloor(instant);\n                if (instant < iCutover) {\n                    \n                    if (instant + iGapDuration < iCutover) {\n                        instant = gregorianToJulian(instant);\n                    }\n                }\n            } else {\n                instant = iJulianField.roundFloor(instant);\n            }\n            return instant;\n        }\n\n        public long roundCeiling(long instant) {\n            if (instant >= iCutover) {\n                instant = iGregorianField.roundCeiling(instant);\n            } else {\n                instant = iJulianField.roundCeiling(instant);\n                if (instant >= iCutover) {\n                    \n                    if (instant - iGapDuration >= iCutover) {\n                        instant = julianToGregorian(instant);\n                    }\n                }\n            }\n            return instant;\n        }\n\n        public int getMaximumTextLength(Locale locale) {\n            return Math.max(iJulianField.getMaximumTextLength(locale),\n                            iGregorianField.getMaximumTextLength(locale));\n        }\n\n        public int getMaximumShortTextLength(Locale locale) {\n            return Math.max(iJulianField.getMaximumShortTextLength(locale),\n                            iGregorianField.getMaximumShortTextLength(locale));\n        }\n\n        protected long julianToGregorian(long instant) {\n            if (iConvertByWeekyear) {\n                return julianToGregorianByWeekyear(instant);\n            } else {\n                return julianToGregorianByYear(instant);\n            }\n        }\n\n        protected long gregorianToJulian(long instant) {\n            if (iConvertByWeekyear) {\n                return gregorianToJulianByWeekyear(instant);\n            } else {\n                return gregorianToJulianByYear(instant);\n            }\n        }\n    }\n\n    \n    \n    private final class ImpreciseCutoverField extends CutoverField { private static final long serialVersionUID = 3410248757173576441L; ImpreciseCutoverField(DateTimeField julianField, DateTimeField gregorianField, long cutoverMillis) {\n            this(julianField, gregorianField, null, cutoverMillis, false);\n        }\n\n        \n        ImpreciseCutoverField(DateTimeField julianField, DateTimeField gregorianField,\n                              DurationField durationField, long cutoverMillis)\n        {\n            this(julianField, gregorianField, durationField, cutoverMillis, false);\n        }\n\n        \n        ImpreciseCutoverField(DateTimeField julianField, DateTimeField gregorianField,\n                              DurationField durationField,\n                              long cutoverMillis, boolean convertByWeekyear)\n        {\n            super(julianField, gregorianField, cutoverMillis, convertByWeekyear);\n            if (durationField == null) {\n                durationField = new LinkedDurationField(iDurationField, this);\n            }\n            iDurationField = durationField;\n        }\n\n        public long add(long instant, int value) {\n            if (instant >= iCutover) {\n                instant = iGregorianField.add(instant, value);\n                if (instant < iCutover) {\n                    \n                    if (instant + iGapDuration < iCutover) {\n                        instant = gregorianToJulian(instant);\n                    }\n                }\n            } else {\n                instant = iJulianField.add(instant, value);\n                if (instant >= iCutover) {\n                    \n                    if (instant - iGapDuration >= iCutover) {\n                        instant = julianToGregorian(instant);\n                    }\n                }\n            }\n            return instant;\n        }\n        \n        public long add(long instant, long value) {\n            if (instant >= iCutover) {\n                instant = iGregorianField.add(instant, value);\n                if (instant < iCutover) {\n                    \n                    if (instant + iGapDuration < iCutover) {\n                        instant = gregorianToJulian(instant);\n                    }\n                }\n            } else {\n                instant = iJulianField.add(instant, value);\n                if (instant >= iCutover) {\n                    \n                    if (instant - iGapDuration >= iCutover) {\n                        instant = julianToGregorian(instant);\n                    }\n                }\n            }\n            return instant;\n        }\n\n        public int getDifference(long minuendInstant, long subtrahendInstant) {\n            if (minuendInstant >= iCutover) {\n                if (subtrahendInstant >= iCutover) {\n                    return iGregorianField.getDifference(minuendInstant, subtrahendInstant);\n                }\n                \n                \n                minuendInstant = gregorianToJulian(minuendInstant);\n                return iJulianField.getDifference(minuendInstant, subtrahendInstant);\n            } else {\n                if (subtrahendInstant < iCutover) {\n                    return iJulianField.getDifference(minuendInstant, subtrahendInstant);\n                }\n                \n                \n                minuendInstant = julianToGregorian(minuendInstant);\n                return iGregorianField.getDifference(minuendInstant, subtrahendInstant);\n            }\n        }\n\n        public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n            if (minuendInstant >= iCutover) {\n                if (subtrahendInstant >= iCutover) {\n                    return iGregorianField.getDifferenceAsLong(minuendInstant, subtrahendInstant);\n                }\n                \n                \n                minuendInstant = gregorianToJulian(minuendInstant);\n                return iJulianField.getDifferenceAsLong(minuendInstant, subtrahendInstant);\n            } else {\n                if (subtrahendInstant < iCutover) {\n                    return iJulianField.getDifferenceAsLong(minuendInstant, subtrahendInstant);\n                }\n                \n                \n                minuendInstant = julianToGregorian(minuendInstant);\n                return iGregorianField.getDifferenceAsLong(minuendInstant, subtrahendInstant);\n            }\n        }\n\n        \n        \n        \n        \n        \n        \n        \n        \n        \n\n        public int getMinimumValue(long instant) {\n            if (instant >= iCutover) {\n                return iGregorianField.getMinimumValue(instant);\n            } else {\n                return iJulianField.getMinimumValue(instant);\n            }\n        }\n\n        public int getMaximumValue(long instant) {\n            if (instant >= iCutover) {\n                return iGregorianField.getMaximumValue(instant);\n            } else {\n                return iJulianField.getMaximumValue(instant);\n            }\n        }\n    }\n\n    \n    \n    private static class LinkedDurationField extends DecoratedDurationField { private static final long serialVersionUID = 4097975388007713084L; private final ImpreciseCutoverField iField; LinkedDurationField(DurationField durationField, ImpreciseCutoverField dateTimeField) {\n            super(durationField, durationField.getType());\n            iField = dateTimeField;\n        }\n\n        public long add(long instant, int value) {\n            return iField.add(instant, value);\n        }\n\n        public long add(long instant, long value) {\n            return iField.add(instant, value);\n        }\n\n        public int getDifference(long minuendInstant, long subtrahendInstant) {\n            return iField.getDifference(minuendInstant, subtrahendInstant);\n        }\n\n        public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n            return iField.getDifferenceAsLong(minuendInstant, subtrahendInstant);\n        }\n    }\n\n}\n",
      "fixed_full_code": "\npackage org.joda.time.chrono;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Locale;\nimport java.util.Map;\n\nimport org.joda.time.Chronology;\nimport org.joda.time.DateTimeField;\nimport org.joda.time.DateTimeUtils;\nimport org.joda.time.DateTimeZone;\nimport org.joda.time.DurationField;\nimport org.joda.time.IllegalFieldValueException;\nimport org.joda.time.Instant;\nimport org.joda.time.ReadableInstant;\nimport org.joda.time.ReadablePartial;\nimport org.joda.time.field.BaseDateTimeField;\nimport org.joda.time.field.DecoratedDurationField;\nimport org.joda.time.format.DateTimeFormatter;\nimport org.joda.time.format.ISODateTimeFormat;\n\n\npublic final class GJChronology extends AssembledChronology { private static final long serialVersionUID = -2545574827706931671L; private static long convertByYear(long instant, Chronology from, Chronology to) {\n        return to.getDateTimeMillis\n            (from.year().get(instant),\n             from.monthOfYear().get(instant),\n             from.dayOfMonth().get(instant),\n             from.millisOfDay().get(instant));\n    }\n\n    \n    private static long convertByWeekyear(final long instant, Chronology from, Chronology to) {\n        long newInstant;\n        newInstant = to.weekyear().set(0, from.weekyear().get(instant));\n        newInstant = to.weekOfWeekyear().set(newInstant, from.weekOfWeekyear().get(instant));\n        newInstant = to.dayOfWeek().set(newInstant, from.dayOfWeek().get(instant));\n        newInstant = to.millisOfDay().set(newInstant, from.millisOfDay().get(instant));\n        return newInstant;\n    }\n\n    \n    static final Instant DEFAULT_CUTOVER = new Instant(-12219292800000L); private static final Map<DateTimeZone, ArrayList<GJChronology>> cCache = new HashMap<DateTimeZone, ArrayList<GJChronology>>(); public static GJChronology getInstanceUTC() {\n        return getInstance(DateTimeZone.UTC, DEFAULT_CUTOVER, 4);\n    }\n\n    \n    public static GJChronology getInstance() {\n        return getInstance(DateTimeZone.getDefault(), DEFAULT_CUTOVER, 4);\n    }\n\n    \n    public static GJChronology getInstance(DateTimeZone zone) {\n        return getInstance(zone, DEFAULT_CUTOVER, 4);\n    }\n\n    \n    public static GJChronology getInstance( DateTimeZone zone, ReadableInstant gregorianCutover) {\n        \n        return getInstance(zone, gregorianCutover, 4);\n    }\n    \n    \n    public static synchronized GJChronology getInstance( DateTimeZone zone, ReadableInstant gregorianCutover, int minDaysInFirstWeek) {\n        \n        zone = DateTimeUtils.getZone(zone);\n        Instant cutoverInstant;\n        if (gregorianCutover == null) {\n            cutoverInstant = DEFAULT_CUTOVER;\n        } else {\n            cutoverInstant = gregorianCutover.toInstant();\n        }\n\n        GJChronology chrono;\n\n        ArrayList<GJChronology> chronos = cCache.get(zone);\n        if (chronos == null) {\n            chronos = new ArrayList<GJChronology>(2);\n            cCache.put(zone, chronos);\n        } else {\n            for (int i=chronos.size(); --i>=0; ) {\n                chrono = chronos.get(i);\n                if (minDaysInFirstWeek == chrono.getMinimumDaysInFirstWeek() &&\n                    cutoverInstant.equals(chrono.getGregorianCutover())) {\n                    \n                    return chrono;\n                }\n            }\n        }\n\n        if (zone == DateTimeZone.UTC) {\n            chrono = new GJChronology\n                (JulianChronology.getInstance(zone, minDaysInFirstWeek),\n                 GregorianChronology.getInstance(zone, minDaysInFirstWeek),\n                 cutoverInstant);\n        } else {\n            chrono = getInstance(DateTimeZone.UTC, cutoverInstant, minDaysInFirstWeek);\n            chrono = new GJChronology\n                (ZonedChronology.getInstance(chrono, zone),\n                 chrono.iJulianChronology,\n                 chrono.iGregorianChronology,\n                 chrono.iCutoverInstant);\n        }\n\n        chronos.add(chrono);\n\n        return chrono;\n    }\n\n    \n    public static GJChronology getInstance( DateTimeZone zone, long gregorianCutover, int minDaysInFirstWeek) {\n        \n        Instant cutoverInstant;\n        if (gregorianCutover == DEFAULT_CUTOVER.getMillis()) {\n            cutoverInstant = null;\n        } else {\n            cutoverInstant = new Instant(gregorianCutover);\n        }\n        return getInstance(zone, cutoverInstant, minDaysInFirstWeek);\n    }\n\n    \n    private JulianChronology iJulianChronology; private GregorianChronology iGregorianChronology; private Instant iCutoverInstant; private long iCutoverMillis; private long iGapDuration; private GJChronology(JulianChronology julian, GregorianChronology gregorian, Instant cutoverInstant) {\n        super(null, new Object[] {julian, gregorian, cutoverInstant});\n    }\n\n    \n    private GJChronology(Chronology base, JulianChronology julian, GregorianChronology gregorian, Instant cutoverInstant) {\n        super(base, new Object[] {julian, gregorian, cutoverInstant});\n    }\n\n    \n    private Object readResolve() {\n        return getInstance(getZone(), iCutoverInstant, getMinimumDaysInFirstWeek());\n    }\n\n    public DateTimeZone getZone() {\n        Chronology base;\n        if ((base = getBase()) != null) {\n            return base.getZone();\n        }\n        return DateTimeZone.UTC;\n    }\n\n    \n    \n    \n    public Chronology withUTC() {\n        return withZone(DateTimeZone.UTC);\n    }\n\n    \n    public Chronology withZone(DateTimeZone zone) {\n        if (zone == null) {\n            zone = DateTimeZone.getDefault();\n        }\n        if (zone == getZone()) {\n            return this;\n        }\n        return getInstance(zone, iCutoverInstant, getMinimumDaysInFirstWeek());\n    }\n\n    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int millisOfDay) throws IllegalArgumentException {\n        Chronology base;\n        if ((base = getBase()) != null) {\n            return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay);\n        }\n\n        \n        long instant = iGregorianChronology.getDateTimeMillis\n            (year, monthOfYear, dayOfMonth, millisOfDay);\n        if (instant < iCutoverMillis) {\n            \n            instant = iJulianChronology.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth, millisOfDay);\n            if (instant >= iCutoverMillis) {\n                \n                throw new IllegalArgumentException(\"Specified date does not exist\");\n            }\n        }\n        return instant;\n    }\n\n    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException {\n        Chronology base;\n        if ((base = getBase()) != null) {\n            return base.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n        }\n\n        \n        long instant;\n        try {\n            instant = iGregorianChronology.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n        } catch (IllegalFieldValueException ex) {\n            if (monthOfYear != 2 || dayOfMonth != 29) {\n                throw ex;\n            }\n            instant = iGregorianChronology.getDateTimeMillis\n                (year, monthOfYear, 28,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n            if (instant >= iCutoverMillis) {\n                throw ex;\n            }\n        }\n        if (instant < iCutoverMillis) {\n            \n            instant = iJulianChronology.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n            if (instant >= iCutoverMillis) {\n                \n                throw new IllegalArgumentException(\"Specified date does not exist\");\n            }\n        }\n        return instant;\n    }\n\n    \n    public Instant getGregorianCutover() {\n        return iCutoverInstant;\n    }\n\n    \n    public int getMinimumDaysInFirstWeek() {\n        return iGregorianChronology.getMinimumDaysInFirstWeek();\n    }\n\n    \n    public boolean equals(Object obj) {\n        return super.equals(obj);\n    }\n\n    \n    public int hashCode() {\n        return \"GJ\".hashCode() * 11 + iJulianChronology.hashCode() +\n            iGregorianChronology.hashCode() + iCutoverInstant.hashCode();\n    }\n\n    \n    \n    \n    public String toString() {\n        StringBuffer sb = new StringBuffer(60);\n        sb.append(\"GJChronology\");\n        sb.append('[');\n        sb.append(getZone().getID());\n        \n        if (iCutoverMillis != DEFAULT_CUTOVER.getMillis()) {\n            sb.append(\",cutover=\");\n            DateTimeFormatter printer;\n            if (withUTC().dayOfYear().remainder(iCutoverMillis) == 0) {\n                printer = ISODateTimeFormat.date();\n            } else {\n                printer = ISODateTimeFormat.dateTime();\n            }\n            printer.withChronology(withUTC()).printTo(sb, iCutoverMillis);\n        }\n        \n        if (getMinimumDaysInFirstWeek() != 4) {\n            sb.append(\",mdfw=\");\n            sb.append(getMinimumDaysInFirstWeek());\n        }\n        sb.append(']');\n        \n        return sb.toString();\n    }\n\n    protected void assemble(Fields fields) {\n        Object[] params = (Object[])getParam();\n\n        JulianChronology julian = (JulianChronology)params[0];\n        GregorianChronology gregorian = (GregorianChronology)params[1];\n        Instant cutoverInstant = (Instant)params[2];\n        iCutoverMillis = cutoverInstant.getMillis();\n\n        iJulianChronology = julian;\n        iGregorianChronology = gregorian;\n        iCutoverInstant = cutoverInstant;\n\n        if (getBase() != null) {\n            return;\n        }\n\n        if (julian.getMinimumDaysInFirstWeek() != gregorian.getMinimumDaysInFirstWeek()) {\n            throw new IllegalArgumentException();\n        }\n\n        \n        iGapDuration = iCutoverMillis - julianToGregorianByYear(iCutoverMillis);\n\n        \n\n        \n        \n        fields.copyFieldsFrom(gregorian);\n        \n        \n        \n\n        \n        if (gregorian.millisOfDay().get(iCutoverMillis) == 0) {\n            \n            \n\n            fields.millisOfSecond = new CutoverField(julian.millisOfSecond(), fields.millisOfSecond, iCutoverMillis);\n            fields.millisOfDay = new CutoverField(julian.millisOfDay(), fields.millisOfDay, iCutoverMillis);\n            fields.secondOfMinute = new CutoverField(julian.secondOfMinute(), fields.secondOfMinute, iCutoverMillis);\n            fields.secondOfDay = new CutoverField(julian.secondOfDay(), fields.secondOfDay, iCutoverMillis);\n            fields.minuteOfHour = new CutoverField(julian.minuteOfHour(), fields.minuteOfHour, iCutoverMillis);\n            fields.minuteOfDay = new CutoverField(julian.minuteOfDay(), fields.minuteOfDay, iCutoverMillis);\n            fields.hourOfDay = new CutoverField(julian.hourOfDay(), fields.hourOfDay, iCutoverMillis);\n            fields.hourOfHalfday = new CutoverField(julian.hourOfHalfday(), fields.hourOfHalfday, iCutoverMillis);\n            fields.clockhourOfDay = new CutoverField(julian.clockhourOfDay(), fields.clockhourOfDay, iCutoverMillis);\n            fields.clockhourOfHalfday = new CutoverField(julian.clockhourOfHalfday(),\n                                                         fields.clockhourOfHalfday, iCutoverMillis);\n            fields.halfdayOfDay = new CutoverField(julian.halfdayOfDay(), fields.halfdayOfDay, iCutoverMillis);\n        }\n\n        \n        {\n            fields.era = new CutoverField(julian.era(), fields.era, iCutoverMillis);\n        }\n\n        \n        \n        \n        \n\n        {\n            long cutover = gregorian.year().roundCeiling(iCutoverMillis);\n            fields.dayOfYear = new CutoverField(\n                julian.dayOfYear(), fields.dayOfYear, cutover);\n        }\n\n        {\n            long cutover = gregorian.weekyear().roundCeiling(iCutoverMillis);\n            fields.weekOfWeekyear = new CutoverField(\n                julian.weekOfWeekyear(), fields.weekOfWeekyear, cutover, true);\n        }\n\n        \n        \n        \n        {\n            fields.year = new ImpreciseCutoverField(\n                julian.year(), fields.year, iCutoverMillis);\n            fields.years = fields.year.getDurationField();\n            fields.yearOfEra = new ImpreciseCutoverField(\n                julian.yearOfEra(), fields.yearOfEra, fields.years, iCutoverMillis);\n            fields.yearOfCentury = new ImpreciseCutoverField(\n                julian.yearOfCentury(), fields.yearOfCentury, fields.years, iCutoverMillis);\n            \n            fields.centuryOfEra = new ImpreciseCutoverField(\n                julian.centuryOfEra(), fields.centuryOfEra, iCutoverMillis);\n            fields.centuries = fields.centuryOfEra.getDurationField();\n            \n            fields.monthOfYear = new ImpreciseCutoverField(\n                julian.monthOfYear(), fields.monthOfYear, iCutoverMillis);\n            fields.months = fields.monthOfYear.getDurationField();\n            \n            fields.weekyear = new ImpreciseCutoverField(\n                julian.weekyear(), fields.weekyear, null, iCutoverMillis, true);\n            fields.weekyearOfCentury = new ImpreciseCutoverField(\n                julian.weekyearOfCentury(), fields.weekyearOfCentury, fields.weekyears, iCutoverMillis);\n            fields.weekyears = fields.weekyear.getDurationField();\n        }\n\n        \n        \n        {\n            CutoverField cf = new CutoverField\n                (julian.dayOfMonth(), fields.dayOfMonth, iCutoverMillis);\n            cf.iRangeDurationField = fields.months;\n            fields.dayOfMonth = cf;\n        }\n    }\n\n    long julianToGregorianByYear(long instant) {\n        return convertByYear(instant, iJulianChronology, iGregorianChronology);\n    }\n\n    long gregorianToJulianByYear(long instant) {\n        return convertByYear(instant, iGregorianChronology, iJulianChronology);\n    }\n\n    long julianToGregorianByWeekyear(long instant) {\n        return convertByWeekyear(instant, iJulianChronology, iGregorianChronology);\n    }\n\n    long gregorianToJulianByWeekyear(long instant) {\n        return convertByWeekyear(instant, iGregorianChronology, iJulianChronology);\n    }\n\n    \n    \n    private class CutoverField extends BaseDateTimeField { private static final long serialVersionUID = 3528501219481026402L; final DateTimeField iJulianField; final DateTimeField iGregorianField; final long iCutover; final boolean iConvertByWeekyear; protected DurationField iDurationField; protected DurationField iRangeDurationField; CutoverField(DateTimeField julianField, DateTimeField gregorianField, long cutoverMillis) {\n            this(julianField, gregorianField, cutoverMillis, false);\n        }\n\n        \n        CutoverField(DateTimeField julianField, DateTimeField gregorianField,\n                     long cutoverMillis, boolean convertByWeekyear) {\n            super(gregorianField.getType());\n            iJulianField = julianField;\n            iGregorianField = gregorianField;\n            iCutover = cutoverMillis;\n            iConvertByWeekyear = convertByWeekyear;\n            \n            \n            iDurationField = gregorianField.getDurationField();\n\n            DurationField rangeField = gregorianField.getRangeDurationField();\n            if (rangeField == null) {\n                rangeField = julianField.getRangeDurationField();\n            }\n            iRangeDurationField = rangeField;\n        }\n\n        public boolean isLenient() {\n            return false;\n        }\n\n        public int get(long instant) {\n            if (instant >= iCutover) {\n                return iGregorianField.get(instant);\n            } else {\n                return iJulianField.get(instant);\n            }\n        }\n\n        public String getAsText(long instant, Locale locale) {\n            if (instant >= iCutover) {\n                return iGregorianField.getAsText(instant, locale);\n            } else {\n                return iJulianField.getAsText(instant, locale);\n            }\n        }\n\n        public String getAsText(int fieldValue, Locale locale) {\n            return iGregorianField.getAsText(fieldValue, locale);\n        }\n\n        public String getAsShortText(long instant, Locale locale) {\n            if (instant >= iCutover) {\n                return iGregorianField.getAsShortText(instant, locale);\n            } else {\n                return iJulianField.getAsShortText(instant, locale);\n            }\n        }\n\n        public String getAsShortText(int fieldValue, Locale locale) {\n            return iGregorianField.getAsShortText(fieldValue, locale);\n        }\n\n        public long add(long instant, int value) {\n            return iGregorianField.add(instant, value);\n        }\n\n        public long add(long instant, long value) {\n            return iGregorianField.add(instant, value);\n        }\n\n        public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {\n            \n            \n            if (valueToAdd == 0) {\n                return values;\n            }\n            if (DateTimeUtils.isContiguous(partial)) {\n                long instant = 0L;\n                for (int i = 0, isize = partial.size(); i < isize; i++) {\n                    instant = partial.getFieldType(i).getField(GJChronology.this).set(instant, values[i]);\n                }\n                instant = add(instant, valueToAdd);\n                return GJChronology.this.get(partial, instant);\n            } else {\n                return super.add(partial, fieldIndex, values, valueToAdd);\n            }\n        }\n\n        public int getDifference(long minuendInstant, long subtrahendInstant) {\n            return iGregorianField.getDifference(minuendInstant, subtrahendInstant);\n        }\n\n        public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n            return iGregorianField.getDifferenceAsLong(minuendInstant, subtrahendInstant);\n        }\n\n        public long set(long instant, int value) {\n            if (instant >= iCutover) {\n                instant = iGregorianField.set(instant, value);\n                if (instant < iCutover) {\n                    \n                    if (instant + iGapDuration < iCutover) {\n                        instant = gregorianToJulian(instant);\n                    }\n                    \n                    if (get(instant) != value) {\n                        throw new IllegalFieldValueException\n                            (iGregorianField.getType(), Integer.valueOf(value), null, null);\n                    }\n                }\n            } else {\n                instant = iJulianField.set(instant, value);\n                if (instant >= iCutover) {\n                    \n                    if (instant - iGapDuration >= iCutover) {\n                        instant = julianToGregorian(instant);\n                    }\n                    \n                    if (get(instant) != value) {\n                       throw new IllegalFieldValueException\n                            (iJulianField.getType(), Integer.valueOf(value), null, null);\n                    }\n                }\n            }\n            return instant;\n        }\n\n        public long set(long instant, String text, Locale locale) {\n            if (instant >= iCutover) {\n                instant = iGregorianField.set(instant, text, locale);\n                if (instant < iCutover) {\n                    \n                    if (instant + iGapDuration < iCutover) {\n                        instant = gregorianToJulian(instant);\n                    }\n                    \n                }\n            } else {\n                instant = iJulianField.set(instant, text, locale);\n                if (instant >= iCutover) {\n                    \n                    if (instant - iGapDuration >= iCutover) {\n                        instant = julianToGregorian(instant);\n                    }\n                    \n                }\n            }\n            return instant;\n        }\n\n        public DurationField getDurationField() {\n            return iDurationField;\n        }\n\n        public DurationField getRangeDurationField() {\n            return iRangeDurationField;\n        }\n\n        public boolean isLeap(long instant) {\n            if (instant >= iCutover) {\n                return iGregorianField.isLeap(instant);\n            } else {\n                return iJulianField.isLeap(instant);\n            }\n        }\n\n        public int getLeapAmount(long instant) {\n            if (instant >= iCutover) {\n                return iGregorianField.getLeapAmount(instant);\n            } else {\n                return iJulianField.getLeapAmount(instant);\n            }\n        }\n\n        public DurationField getLeapDurationField() {\n            return iGregorianField.getLeapDurationField();\n        }\n\n\n        public int getMinimumValue() {\n            \n            \n            return iJulianField.getMinimumValue();\n        }\n\n        public int getMinimumValue(ReadablePartial partial) {\n            return iJulianField.getMinimumValue(partial);\n        }\n\n        public int getMinimumValue(ReadablePartial partial, int[] values) {\n            return iJulianField.getMinimumValue(partial, values);\n        }\n\n        public int getMinimumValue(long instant) {\n            if (instant < iCutover) {\n                return iJulianField.getMinimumValue(instant);\n            }\n\n            int min = iGregorianField.getMinimumValue(instant);\n\n            \n            \n            instant = iGregorianField.set(instant, min);\n            if (instant < iCutover) {\n                min = iGregorianField.get(iCutover);\n            }\n\n            return min;\n        }\n\n        public int getMaximumValue() {\n            \n            \n            return iGregorianField.getMaximumValue();\n        }\n\n        public int getMaximumValue(long instant) {\n            if (instant >= iCutover) {\n                return iGregorianField.getMaximumValue(instant);\n            }\n\n            int max = iJulianField.getMaximumValue(instant);\n\n            \n            \n            instant = iJulianField.set(instant, max);\n            if (instant >= iCutover) {\n                max = iJulianField.get(iJulianField.add(iCutover, -1));\n            }\n\n            return max;\n        }\n\n        public int getMaximumValue(ReadablePartial partial) {\n            long instant = GJChronology.getInstanceUTC().set(partial, 0L);\n            return getMaximumValue(instant);\n        }\n\n        public int getMaximumValue(ReadablePartial partial, int[] values) {\n            Chronology chrono = GJChronology.getInstanceUTC();\n            long instant = 0L;\n            for (int i = 0, isize = partial.size(); i < isize; i++) {\n                DateTimeField field = partial.getFieldType(i).getField(chrono);\n                if (values[i] <= field.getMaximumValue(instant)) {\n                    instant = field.set(instant, values[i]);\n                }\n            }\n            return getMaximumValue(instant);\n        }\n\n        public long roundFloor(long instant) {\n            if (instant >= iCutover) {\n                instant = iGregorianField.roundFloor(instant);\n                if (instant < iCutover) {\n                    \n                    if (instant + iGapDuration < iCutover) {\n                        instant = gregorianToJulian(instant);\n                    }\n                }\n            } else {\n                instant = iJulianField.roundFloor(instant);\n            }\n            return instant;\n        }\n\n        public long roundCeiling(long instant) {\n            if (instant >= iCutover) {\n                instant = iGregorianField.roundCeiling(instant);\n            } else {\n                instant = iJulianField.roundCeiling(instant);\n                if (instant >= iCutover) {\n                    \n                    if (instant - iGapDuration >= iCutover) {\n                        instant = julianToGregorian(instant);\n                    }\n                }\n            }\n            return instant;\n        }\n\n        public int getMaximumTextLength(Locale locale) {\n            return Math.max(iJulianField.getMaximumTextLength(locale),\n                            iGregorianField.getMaximumTextLength(locale));\n        }\n\n        public int getMaximumShortTextLength(Locale locale) {\n            return Math.max(iJulianField.getMaximumShortTextLength(locale),\n                            iGregorianField.getMaximumShortTextLength(locale));\n        }\n\n        protected long julianToGregorian(long instant) {\n            if (iConvertByWeekyear) {\n                return julianToGregorianByWeekyear(instant);\n            } else {\n                return julianToGregorianByYear(instant);\n            }\n        }\n\n        protected long gregorianToJulian(long instant) {\n            if (iConvertByWeekyear) {\n                return gregorianToJulianByWeekyear(instant);\n            } else {\n                return gregorianToJulianByYear(instant);\n            }\n        }\n    }\n\n    \n    \n    private final class ImpreciseCutoverField extends CutoverField { private static final long serialVersionUID = 3410248757173576441L; ImpreciseCutoverField(DateTimeField julianField, DateTimeField gregorianField, long cutoverMillis) {\n            this(julianField, gregorianField, null, cutoverMillis, false);\n        }\n\n        \n        ImpreciseCutoverField(DateTimeField julianField, DateTimeField gregorianField,\n                              DurationField durationField, long cutoverMillis)\n        {\n            this(julianField, gregorianField, durationField, cutoverMillis, false);\n        }\n\n        \n        ImpreciseCutoverField(DateTimeField julianField, DateTimeField gregorianField,\n                              DurationField durationField,\n                              long cutoverMillis, boolean convertByWeekyear)\n        {\n            super(julianField, gregorianField, cutoverMillis, convertByWeekyear);\n            if (durationField == null) {\n                durationField = new LinkedDurationField(iDurationField, this);\n            }\n            iDurationField = durationField;\n        }\n\n        public long add(long instant, int value) {\n            if (instant >= iCutover) {\n                instant = iGregorianField.add(instant, value);\n                if (instant < iCutover) {\n                    \n                    if (instant + iGapDuration < iCutover) {\n                        instant = gregorianToJulian(instant);\n                    }\n                }\n            } else {\n                instant = iJulianField.add(instant, value);\n                if (instant >= iCutover) {\n                    \n                    if (instant - iGapDuration >= iCutover) {\n                        instant = julianToGregorian(instant);\n                    }\n                }\n            }\n            return instant;\n        }\n        \n        public long add(long instant, long value) {\n            if (instant >= iCutover) {\n                instant = iGregorianField.add(instant, value);\n                if (instant < iCutover) {\n                    \n                    if (instant + iGapDuration < iCutover) {\n                        instant = gregorianToJulian(instant);\n                    }\n                }\n            } else {\n                instant = iJulianField.add(instant, value);\n                if (instant >= iCutover) {\n                    \n                    if (instant - iGapDuration >= iCutover) {\n                        instant = julianToGregorian(instant);\n                    }\n                }\n            }\n            return instant;\n        }\n\n        public int getDifference(long minuendInstant, long subtrahendInstant) {\n            if (minuendInstant >= iCutover) {\n                if (subtrahendInstant >= iCutover) {\n                    return iGregorianField.getDifference(minuendInstant, subtrahendInstant);\n                }\n                \n                \n                minuendInstant = gregorianToJulian(minuendInstant);\n                return iJulianField.getDifference(minuendInstant, subtrahendInstant);\n            } else {\n                if (subtrahendInstant < iCutover) {\n                    return iJulianField.getDifference(minuendInstant, subtrahendInstant);\n                }\n                \n                \n                minuendInstant = julianToGregorian(minuendInstant);\n                return iGregorianField.getDifference(minuendInstant, subtrahendInstant);\n            }\n        }\n\n        public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n            if (minuendInstant >= iCutover) {\n                if (subtrahendInstant >= iCutover) {\n                    return iGregorianField.getDifferenceAsLong(minuendInstant, subtrahendInstant);\n                }\n                \n                \n                minuendInstant = gregorianToJulian(minuendInstant);\n                return iJulianField.getDifferenceAsLong(minuendInstant, subtrahendInstant);\n            } else {\n                if (subtrahendInstant < iCutover) {\n                    return iJulianField.getDifferenceAsLong(minuendInstant, subtrahendInstant);\n                }\n                \n                \n                minuendInstant = julianToGregorian(minuendInstant);\n                return iGregorianField.getDifferenceAsLong(minuendInstant, subtrahendInstant);\n            }\n        }\n\n        \n        \n        \n        \n        \n        \n        \n        \n        \n\n        public int getMinimumValue(long instant) {\n            if (instant >= iCutover) {\n                return iGregorianField.getMinimumValue(instant);\n            } else {\n                return iJulianField.getMinimumValue(instant);\n            }\n        }\n\n        public int getMaximumValue(long instant) {\n            if (instant >= iCutover) {\n                return iGregorianField.getMaximumValue(instant);\n            } else {\n                return iJulianField.getMaximumValue(instant);\n            }\n        }\n    }\n\n    \n    \n    private static class LinkedDurationField extends DecoratedDurationField { private static final long serialVersionUID = 4097975388007713084L; private final ImpreciseCutoverField iField; LinkedDurationField(DurationField durationField, ImpreciseCutoverField dateTimeField) {\n            super(durationField, durationField.getType());\n            iField = dateTimeField;\n        }\n\n        public long add(long instant, int value) {\n            return iField.add(instant, value);\n        }\n\n        public long add(long instant, long value) {\n            return iField.add(instant, value);\n        }\n\n        public int getDifference(long minuendInstant, long subtrahendInstant) {\n            return iField.getDifference(minuendInstant, subtrahendInstant);\n        }\n\n        public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n            return iField.getDifferenceAsLong(minuendInstant, subtrahendInstant);\n        }\n    }\n\n}\n",
      "buggy_signatures": [
        "private static long convertByWeekyear(final long instant, Chronology from, Chronology to)",
        "public static GJChronology getInstance()",
        "public static GJChronology getInstance(DateTimeZone zone)",
        "public static GJChronology getInstance( DateTimeZone zone, ReadableInstant gregorianCutover)",
        "public static synchronized GJChronology getInstance( DateTimeZone zone, ReadableInstant gregorianCutover, int minDaysInFirstWeek)",
        "public static GJChronology getInstance( DateTimeZone zone, long gregorianCutover, int minDaysInFirstWeek)",
        "private JulianChronology iJulianChronology; private GregorianChronology iGregorianChronology; private Instant iCutoverInstant; private long iCutoverMillis; private long iGapDuration; private GJChronology(JulianChronology julian, GregorianChronology gregorian, Instant cutoverInstant)",
        "private GJChronology(Chronology base, JulianChronology julian, GregorianChronology gregorian, Instant cutoverInstant)",
        "private Object readResolve()",
        "public DateTimeZone getZone()",
        "public Chronology withUTC()",
        "public Chronology withZone(DateTimeZone zone)",
        "public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int millisOfDay) throws IllegalArgumentException",
        "public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException",
        "public Instant getGregorianCutover()",
        "public int getMinimumDaysInFirstWeek()",
        "public boolean equals(Object obj)",
        "public int hashCode()",
        "public String toString()",
        "protected void assemble(Fields fields)",
        "public boolean isLenient()",
        "public int get(long instant)",
        "public String getAsText(long instant, Locale locale)",
        "public String getAsText(int fieldValue, Locale locale)",
        "public String getAsShortText(long instant, Locale locale)",
        "public String getAsShortText(int fieldValue, Locale locale)",
        "public long add(long instant, int value)",
        "public long add(long instant, long value)",
        "public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd)",
        "public int getDifference(long minuendInstant, long subtrahendInstant)",
        "public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant)",
        "public long set(long instant, int value)",
        "public long set(long instant, String text, Locale locale)",
        "public DurationField getDurationField()",
        "public DurationField getRangeDurationField()",
        "public boolean isLeap(long instant)",
        "public int getLeapAmount(long instant)",
        "public DurationField getLeapDurationField()",
        "public int getMinimumValue()",
        "public int getMinimumValue(ReadablePartial partial)",
        "public int getMinimumValue(ReadablePartial partial, int[] values)",
        "public int getMinimumValue(long instant)",
        "public int getMaximumValue()",
        "public int getMaximumValue(long instant)",
        "public int getMaximumValue(ReadablePartial partial)",
        "public int getMaximumValue(ReadablePartial partial, int[] values)",
        "public long roundFloor(long instant)",
        "public long roundCeiling(long instant)",
        "public int getMaximumTextLength(Locale locale)",
        "public int getMaximumShortTextLength(Locale locale)",
        "protected long julianToGregorian(long instant)",
        "protected long gregorianToJulian(long instant)",
        "public long add(long instant, int value)",
        "public long add(long instant, long value)",
        "public int getDifference(long minuendInstant, long subtrahendInstant)",
        "public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant)",
        "public int getMinimumValue(long instant)",
        "public int getMaximumValue(long instant)",
        "public long add(long instant, int value)",
        "public long add(long instant, long value)",
        "public int getDifference(long minuendInstant, long subtrahendInstant)",
        "public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant)"
      ],
      "fixed_signatures": [
        "private static long convertByWeekyear(final long instant, Chronology from, Chronology to)",
        "public static GJChronology getInstance()",
        "public static GJChronology getInstance(DateTimeZone zone)",
        "public static GJChronology getInstance( DateTimeZone zone, ReadableInstant gregorianCutover)",
        "public static synchronized GJChronology getInstance( DateTimeZone zone, ReadableInstant gregorianCutover, int minDaysInFirstWeek)",
        "public static GJChronology getInstance( DateTimeZone zone, long gregorianCutover, int minDaysInFirstWeek)",
        "private JulianChronology iJulianChronology; private GregorianChronology iGregorianChronology; private Instant iCutoverInstant; private long iCutoverMillis; private long iGapDuration; private GJChronology(JulianChronology julian, GregorianChronology gregorian, Instant cutoverInstant)",
        "private GJChronology(Chronology base, JulianChronology julian, GregorianChronology gregorian, Instant cutoverInstant)",
        "private Object readResolve()",
        "public DateTimeZone getZone()",
        "public Chronology withUTC()",
        "public Chronology withZone(DateTimeZone zone)",
        "public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int millisOfDay) throws IllegalArgumentException",
        "public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException",
        "public Instant getGregorianCutover()",
        "public int getMinimumDaysInFirstWeek()",
        "public boolean equals(Object obj)",
        "public int hashCode()",
        "public String toString()",
        "protected void assemble(Fields fields)",
        "public boolean isLenient()",
        "public int get(long instant)",
        "public String getAsText(long instant, Locale locale)",
        "public String getAsText(int fieldValue, Locale locale)",
        "public String getAsShortText(long instant, Locale locale)",
        "public String getAsShortText(int fieldValue, Locale locale)",
        "public long add(long instant, int value)",
        "public long add(long instant, long value)",
        "public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd)",
        "public int getDifference(long minuendInstant, long subtrahendInstant)",
        "public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant)",
        "public long set(long instant, int value)",
        "public long set(long instant, String text, Locale locale)",
        "public DurationField getDurationField()",
        "public DurationField getRangeDurationField()",
        "public boolean isLeap(long instant)",
        "public int getLeapAmount(long instant)",
        "public DurationField getLeapDurationField()",
        "public int getMinimumValue()",
        "public int getMinimumValue(ReadablePartial partial)",
        "public int getMinimumValue(ReadablePartial partial, int[] values)",
        "public int getMinimumValue(long instant)",
        "public int getMaximumValue()",
        "public int getMaximumValue(long instant)",
        "public int getMaximumValue(ReadablePartial partial)",
        "public int getMaximumValue(ReadablePartial partial, int[] values)",
        "public long roundFloor(long instant)",
        "public long roundCeiling(long instant)",
        "public int getMaximumTextLength(Locale locale)",
        "public int getMaximumShortTextLength(Locale locale)",
        "protected long julianToGregorian(long instant)",
        "protected long gregorianToJulian(long instant)",
        "public long add(long instant, int value)",
        "public long add(long instant, long value)",
        "public int getDifference(long minuendInstant, long subtrahendInstant)",
        "public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant)",
        "public int getMinimumValue(long instant)",
        "public int getMaximumValue(long instant)",
        "public long add(long instant, int value)",
        "public long add(long instant, long value)",
        "public int getDifference(long minuendInstant, long subtrahendInstant)",
        "public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant)"
      ],
      "methods": [
        {
          "buggy_method": "  public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException {\n  Chronology base;\n  if ((base = getBase()) != null) {\n  return base.getDateTimeMillis\n  (year, monthOfYear, dayOfMonth,\n  hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n  }\n\n  \n  long instant;\n  instant = iGregorianChronology.getDateTimeMillis\n  (year, monthOfYear, dayOfMonth,\n  hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n  if (instant < iCutoverMillis) {\n  \n  instant = iJulianChronology.getDateTimeMillis\n  (year, monthOfYear, dayOfMonth,\n  hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n  if (instant >= iCutoverMillis) {\n  \n  throw new IllegalArgumentException(\"Specified date does not exist\");\n  }\n  }\n  return instant;\n  }",
          "fixed_method": "  public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException {\n  Chronology base;\n  if ((base = getBase()) != null) {\n  return base.getDateTimeMillis\n  (year, monthOfYear, dayOfMonth,\n  hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n  }\n\n  \n  long instant;\n  try {\n  instant = iGregorianChronology.getDateTimeMillis\n  (year, monthOfYear, dayOfMonth,\n  hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n  } catch (IllegalFieldValueException ex) {\n  if (monthOfYear != 2 || dayOfMonth != 29) {\n  throw ex;\n  }\n  instant = iGregorianChronology.getDateTimeMillis\n  (year, monthOfYear, 28,\n  hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n  if (instant >= iCutoverMillis) {\n  throw ex;\n  }\n  }\n  if (instant < iCutoverMillis) {\n  \n  instant = iJulianChronology.getDateTimeMillis\n  (year, monthOfYear, dayOfMonth,\n  hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n  if (instant >= iCutoverMillis) {\n  \n  throw new IllegalArgumentException(\"Specified date does not exist\");\n  }\n  }\n  return instant;\n  }",
          "diff": [
            "@@ -361,9 +361,21 @@",
            " \n",
            "         // Assume date is Gregorian.\n",
            "         long instant;\n",
            "+        try {\n",
            "             instant = iGregorianChronology.getDateTimeMillis\n",
            "                 (year, monthOfYear, dayOfMonth,\n",
            "                  hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n",
            "+        } catch (IllegalFieldValueException ex) {\n",
            "+            if (monthOfYear != 2 || dayOfMonth != 29) {\n",
            "+                throw ex;\n",
            "+            }\n",
            "+            instant = iGregorianChronology.getDateTimeMillis\n",
            "+                (year, monthOfYear, 28,\n",
            "+                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n",
            "+            if (instant >= iCutoverMillis) {\n",
            "+                throw ex;\n",
            "+            }\n",
            "+        }\n",
            "         if (instant < iCutoverMillis) {\n",
            "             // Maybe it's Julian.\n",
            "             instant = iJulianChronology.getDateTimeMillis\n"
          ],
          "changed_lines": 12
        }
      ]
    }
  ]
}
