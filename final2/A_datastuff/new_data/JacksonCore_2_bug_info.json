{
  "bug_id": "2",
  "failed_tests": {
    "com.fasterxml.jackson.core.json.TestParserErrorHandling": [
      {
        "methodName": "testMangledNumbersBytes",
        "error": "junit.framework.AssertionFailedError",
        "message": "Should have gotten an exception; instead got token: VALUE_NUMBER_INT",
        "fail_line": "        _testMangledNumbers(true);",
        "test_source": "  public void testMangledNumbersBytes() throws Exception {\n  _testMangledNumbers(true);\n  }",
        "stack": [
          "TestParserErrorHandling._testMangledNumbers line 93, TestParserErrorHandling.testMangledNumbersBytes line 22"
        ]
      },
      {
        "methodName": "testMangledNumbersChars",
        "error": "junit.framework.AssertionFailedError",
        "message": "Should have gotten an exception; instead got token: VALUE_NUMBER_INT",
        "fail_line": "        _testMangledNumbers(false);",
        "test_source": "  public void testMangledNumbersChars() throws Exception {\n  _testMangledNumbers(false);\n  }",
        "stack": [
          "TestParserErrorHandling._testMangledNumbers line 93, TestParserErrorHandling.testMangledNumbersChars line 26"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
      "buggy_full_code": "package com.fasterxml.jackson.core.json;\n\nimport java.io.*;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.base.ParserBase;\nimport com.fasterxml.jackson.core.io.CharTypes;\nimport com.fasterxml.jackson.core.io.IOContext;\nimport com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer;\nimport com.fasterxml.jackson.core.util.*;\n\n\npublic final class ReaderBasedJsonParser extends ParserBase { protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1(); private final static int[] _icWS = CharTypes.getInputCodeWS(); protected Reader _reader; protected char[] _inputBuffer; protected ObjectCodec _objectCodec; final protected CharsToNameCanonicalizer _symbols; final protected int _hashSeed; protected boolean _tokenIncomplete = false; public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st) {\n        super(ctxt, features);\n        _reader = r;\n        _inputBuffer = ctxt.allocTokenBuffer();\n        _objectCodec = codec;\n        _symbols = st;\n        _hashSeed = st.hashSeed();\n    }\n    \n    \n\n    @Override\n    public ObjectCodec getCodec() {\n        return _objectCodec;\n    }\n\n    @Override\n    public void setCodec(ObjectCodec c) {\n        _objectCodec = c;\n    }\n    \n    @Override\n    public int releaseBuffered(Writer w) throws IOException {\n        int count = _inputEnd - _inputPtr;\n        if (count < 1) {\n            return 0;\n        }\n        \n        int origPtr = _inputPtr;\n        w.write(_inputBuffer, origPtr, count);\n        return count;\n    }\n\n    @Override\n    public Object getInputSource() {\n        return _reader;\n    }\n\n    @Override\n    protected boolean loadMore() throws IOException {\n        _currInputProcessed += _inputEnd;\n        _currInputRowStart -= _inputEnd;\n\n        if (_reader != null) {\n            int count = _reader.read(_inputBuffer, 0, _inputBuffer.length);\n            if (count > 0) {\n                _inputPtr = 0;\n                _inputEnd = count;\n                return true;\n            }\n            \n            _closeInput();\n            \n            if (count == 0) {\n                throw new IOException(\"Reader returned 0 characters when trying to read \"+_inputEnd);\n            }\n        }\n        return false;\n    }\n\n    protected char getNextChar(String eofMsg) throws IOException, JsonParseException {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(eofMsg);\n            }\n        }\n        return _inputBuffer[_inputPtr++];\n    }\n\n    @Override\n    protected void _closeInput() throws IOException {\n        \n        if (_reader != null) {\n            if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_SOURCE)) {\n                _reader.close();\n            }\n            _reader = null;\n        }\n    }\n\n    \n    @Override\n    protected void _releaseBuffers() throws IOException {\n        super._releaseBuffers();\n        char[] buf = _inputBuffer;\n        if (buf != null) {\n            _inputBuffer = null;\n            _ioContext.releaseTokenBuffer(buf);\n        }\n    }\n    \n    \n    \n    \n    @Override\n    public String getText() throws IOException, JsonParseException {\n        JsonToken t = _currToken;\n        if (t == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); \n            }\n            return _textBuffer.contentsAsString();\n        }\n        return _getText2(t);\n    }\n\n    \n    \n    \n    @Override\n    public String getValueAsString() throws IOException, JsonParseException {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); \n            }\n            return _textBuffer.contentsAsString();\n        }\n        return super.getValueAsString(null);\n    }\n    \n    \n    @Override\n    public String getValueAsString(String defValue) throws IOException, JsonParseException {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); \n            }\n            return _textBuffer.contentsAsString();\n        }\n        return super.getValueAsString(defValue);\n    }\n    \n    \n    protected String _getText2(JsonToken t) {\n        if (t == null) {\n            return null;\n        }\n        switch (t) {\n        case FIELD_NAME:\n            return _parsingContext.getCurrentName();\n\n        case VALUE_STRING:\n            \n        case VALUE_NUMBER_INT:\n        case VALUE_NUMBER_FLOAT:\n            return _textBuffer.contentsAsString();\n        default:\n            return t.asString();\n        }\n    }\n\n    @Override\n    public char[] getTextCharacters() throws IOException, JsonParseException {\n        if (_currToken != null) { \n            switch (_currToken) {\n                \n            case FIELD_NAME:\n                if (!_nameCopied) {\n                    String name = _parsingContext.getCurrentName();\n                    int nameLen = name.length();\n                    if (_nameCopyBuffer == null) {\n                        _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen);\n                    } else if (_nameCopyBuffer.length < nameLen) {\n                        _nameCopyBuffer = new char[nameLen];\n                    }\n                    name.getChars(0, nameLen, _nameCopyBuffer, 0);\n                    _nameCopied = true;\n                }\n                return _nameCopyBuffer;\n    \n            case VALUE_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); \n                }\n                \n            case VALUE_NUMBER_INT:\n            case VALUE_NUMBER_FLOAT:\n                return _textBuffer.getTextBuffer();\n                \n            default:\n                return _currToken.asCharArray();\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public int getTextLength() throws IOException, JsonParseException {\n        if (_currToken != null) { \n            switch (_currToken) {\n                \n            case FIELD_NAME:\n                return _parsingContext.getCurrentName().length();\n            case VALUE_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); \n                }\n                \n            case VALUE_NUMBER_INT:\n            case VALUE_NUMBER_FLOAT:\n                return _textBuffer.size();\n                \n            default:\n                return _currToken.asCharArray().length;\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public int getTextOffset() throws IOException, JsonParseException {\n        \n        if (_currToken != null) {\n            switch (_currToken) {\n            case FIELD_NAME:\n                return 0;\n            case VALUE_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); \n                }\n                \n            case VALUE_NUMBER_INT:\n            case VALUE_NUMBER_FLOAT:\n                return _textBuffer.getTextOffset();\n            default:\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException {\n        if (_currToken != JsonToken.VALUE_STRING &&\n                (_currToken != JsonToken.VALUE_EMBEDDED_OBJECT || _binaryValue == null)) {\n            _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\");\n        }\n        \n        if (_tokenIncomplete) {\n            try {\n                _binaryValue = _decodeBase64(b64variant);\n            } catch (IllegalArgumentException iae) {\n                throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage());\n            }\n            \n            _tokenIncomplete = false;\n        } else { \n            if (_binaryValue == null) {\n                @SuppressWarnings(\"resource\")\n                ByteArrayBuilder builder = _getByteArrayBuilder();\n                _decodeBase64(getText(), builder, b64variant);\n                _binaryValue = builder.toByteArray();\n            }\n        }\n        return _binaryValue;\n    }\n    \n    @Override\n    public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException {\n        \n        if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) {\n            byte[] b = getBinaryValue(b64variant);\n            out.write(b);\n            return b.length;\n        }\n        \n        byte[] buf = _ioContext.allocBase64Buffer();\n        try {\n            return _readBinary(b64variant, out, buf);\n        } finally {\n            _ioContext.releaseBase64Buffer(buf);\n        }\n    }\n\n    protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\n        int outputCount = 0;\n\n        while (true) {\n            \n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { \n                if (ch == '\"') {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { \n                    continue;\n                }\n            }\n\n            \n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            \n\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            \n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            \n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    \n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    \n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    \n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            \n            decodedData = (decodedData << 6) | bits;\n            \n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    \n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    \n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            \n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }\n\n    \n\n    \n    @Override\n    public JsonToken nextToken() throws IOException, JsonParseException {\n        _numTypesValid = NR_UNKNOWN;\n\n        \n        if (_currToken == JsonToken.FIELD_NAME) {\n            return _nextAfterName();\n        }\n        if (_tokenIncomplete) {\n            _skipString(); \n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) { \n            \n            close();\n            return (_currToken = null);\n        }\n\n        \n        _tokenInputTotal = _currInputProcessed + _inputPtr - 1;\n        _tokenInputRow = _currInputRow;\n        _tokenInputCol = _inputPtr - _currInputRowStart - 1;\n\n        \n        _binaryValue = null;\n\n        \n        if (i == INT_RBRACKET) {\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.getParent();\n            return (_currToken = JsonToken.END_ARRAY);\n        }\n        if (i == INT_RCURLY) {\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.getParent();\n            return (_currToken = JsonToken.END_OBJECT);\n        }\n\n        \n        if (_parsingContext.expectComma()) {\n            if (i != INT_COMMA) {\n                _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\");\n            }\n            i = _skipWS();\n        }\n\n        \n        boolean inObject = _parsingContext.inObject();\n        if (inObject) {\n           \n            String name = _parseName(i);\n            _parsingContext.setCurrentName(name);\n            _currToken = JsonToken.FIELD_NAME;\n            i = _skipWS();\n            if (i != INT_COLON) {\n                _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");\n            }\n            i = _skipWS();\n        }\n\n        \n\n        JsonToken t;\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            t = JsonToken.VALUE_STRING;\n            break;\n        case '[':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_OBJECT;\n            break;\n        case ']':\n        case '}':\n            \n            \n            _reportUnexpectedChar(i, \"expected a value\");\n        case 't':\n            _matchToken(\"true\", 1);\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchToken(\"false\", 1);\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchToken(\"null\", 1);\n            t = JsonToken.VALUE_NULL;\n            break;\n\n        case '-':\n            \n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parseNumber(i);\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n\n        if (inObject) {\n            _nextToken = t;\n            return _currToken;\n        }\n        _currToken = t;\n        return t;\n    }\n\n    private JsonToken _nextAfterName() {\n        _nameCopied = false; \n        JsonToken t = _nextToken;\n        _nextToken = null;\n        \n        if (t == JsonToken.START_ARRAY) {\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n        } else if (t == JsonToken.START_OBJECT) {\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n        }\n        return (_currToken = t);\n    }\n\n    \n\n    \n    @Override\n    public String nextTextValue() throws IOException, JsonParseException {\n        if (_currToken == JsonToken.FIELD_NAME) { \n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_STRING) {\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString();\n                }\n                return _textBuffer.contentsAsString();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        \n        return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;\n    }\n\n    \n    @Override\n    public int nextIntValue(int defaultValue) throws IOException, JsonParseException {\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getIntValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        \n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;\n    }\n\n    \n    @Override\n    public long nextLongValue(long defaultValue) throws IOException, JsonParseException {\n        if (_currToken == JsonToken.FIELD_NAME) { \n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getLongValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        \n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;\n    }\n\n    \n    @Override\n    public Boolean nextBooleanValue() throws IOException, JsonParseException {\n        if (_currToken == JsonToken.FIELD_NAME) { \n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_TRUE) {\n                return Boolean.TRUE;\n            }\n            if (t == JsonToken.VALUE_FALSE) {\n                return Boolean.FALSE;\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        switch (nextToken()) {\n        case VALUE_TRUE:\n            return Boolean.TRUE;\n        case VALUE_FALSE:\n            return Boolean.FALSE;\n        default:\n        \treturn null;\n        }\n    }\n    \n    @Override\n    public void close() throws IOException {\n        super.close();\n        _symbols.release();\n    }\n\n    \n\n    \n    protected JsonToken _parseNumber(int ch) throws IOException {\n        \n        boolean negative = (ch == INT_MINUS);\n        int ptr = _inputPtr;\n        int startPtr = ptr-1; \n        final int inputLen = _inputEnd;\n\n        dummy_loop:\n        do { \n            if (negative) { \n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = _inputBuffer[ptr++];\n                \n                if (ch > INT_9 || ch < INT_0) {\n                    _inputPtr = ptr;\n                    return _handleInvalidNumberStart(ch, true);\n                }\n                \n            }\n            \n            if (ch == INT_0) {\n                break dummy_loop;\n            }\n            \n            \n            \n            int intLen = 1; \n            \n            \n            \n            int_loop:\n            while (true) {\n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break int_loop;\n                }\n                ++intLen;\n            }\n\n            int fractLen = 0;\n            \n            \n            if (ch == '.') { \n                fract_loop:\n                while (true) {\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                    if (ch < INT_0 || ch > INT_9) {\n                        break fract_loop;\n                    }\n                    ++fractLen;\n                }\n                \n                if (fractLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n                }\n            }\n\n            int expLen = 0;\n            if (ch == 'e' || ch == 'E') { \n                if (ptr >= inputLen) {\n                    break dummy_loop;\n                }\n                \n                ch = (int) _inputBuffer[ptr++];\n                if (ch == INT_MINUS || ch == INT_PLUS) { \n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                while (ch <= INT_9 && ch >= INT_0) {\n                    ++expLen;\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                \n                if (expLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n                }\n            }\n            \n            --ptr; \n            _inputPtr = ptr;\n            \n            int len = ptr-startPtr;\n            _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n            return reset(negative, intLen, fractLen, expLen);\n        } while (false);\n\n        _inputPtr = negative ? (startPtr+1) : startPtr;\n        return _parseNumber2(negative);\n    }\n\n    \n    private JsonToken _parseNumber2(boolean negative) throws IOException {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n\n        \n        if (negative) {\n            outBuf[outPtr++] = '-';\n        }\n\n        \n        int intLen = 0;\n        char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\");\n        if (c == '0') {\n            c = _verifyNoLeadingZeroes();\n        }\n        boolean eof = false;\n\n        \n        int_loop:\n        while (c >= '0' && c <= '9') {\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                \n                c = CHAR_NULL;\n                eof = true;\n                break int_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        \n        if (intLen == 0) {\n            reportInvalidNumber(\"Missing integer part (next char \"+_getCharDesc(c)+\")\");\n        }\n\n        int fractLen = 0;\n        \n        if (c == '.') { \n            outBuf[outPtr++] = c;\n\n            fract_loop:\n            while (true) {\n                if (_inputPtr >= _inputEnd && !loadMore()) {\n                    eof = true;\n                    break fract_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n                if (c < INT_0 || c > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n            }\n            \n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n            }\n        }\n\n        int expLen = 0;\n        if (c == 'e' || c == 'E') { \n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            \n            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                : getNextChar(\"expected a digit for number exponent\");\n            \n            if (c == '-' || c == '+') {\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                \n                c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                    : getNextChar(\"expected a digit for number exponent\");\n            }\n\n            exp_loop:\n            while (c <= INT_9 && c >= INT_0) {\n                ++expLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                if (_inputPtr >= _inputEnd && !loadMore()) {\n                    eof = true;\n                    break exp_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n            }\n            \n            if (expLen == 0) {\n                reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n            }\n        }\n\n        \n        if (!eof) {\n            --_inputPtr;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        \n        return reset(negative, intLen, fractLen, expLen);\n    }\n\n    \n    private char _verifyNoLeadingZeroes() throws IOException {\n        \n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            return '0';\n        }\n        char ch = _inputBuffer[_inputPtr];\n        \n        if (ch < '0' || ch > '9') {\n            return '0';\n        }\n        if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) {\n            reportInvalidNumber(\"Leading zeroes not allowed\");\n        }\n        \n        ++_inputPtr; \n        if (ch == INT_0) {\n            while (_inputPtr < _inputEnd || loadMore()) {\n                ch = _inputBuffer[_inputPtr];\n                if (ch < '0' || ch > '9') { \n                    return '0';\n                }\n                ++_inputPtr; \n                if (ch != '0') { \n                    break;\n                }\n            }\n        }\n        return ch;\n    }\n\n    \n    protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException {\n        if (ch == 'I') {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOFInValue();\n                }\n            }\n            ch = _inputBuffer[_inputPtr++];\n            if (ch == 'N') {\n                String match = negative ? \"-INF\" :\"+INF\";\n                _matchToken(match, 3);\n                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n                }\n                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            } else if (ch == 'n') {\n                String match = negative ? \"-Infinity\" :\"+Infinity\";\n                _matchToken(match, 3);\n                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n                }\n                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            }\n        }\n        reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        return null;\n    }\n\n    \n        \n    \n    \n\n    protected String _parseName(int i) throws IOException {\n        if (i != INT_QUOTE) {\n            return _handleOddName(i);\n        }\n        \n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode && codes[ch] != 0) {\n                    if (ch == '\"') {\n                        int start = _inputPtr;\n                        _inputPtr = ptr+1; \n                        return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                    }\n                    break;\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        int start = _inputPtr;\n        _inputPtr = ptr;\n        return _parseName2(start, hash, INT_QUOTE);\n    }\n\n    private String _parseName2(int startPtr, int hash, int endChar) throws IOException {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n\n        \n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing '\"+((char) endChar)+\"' for name\");\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    \n                    c = _decodeEscaped();\n                } else if (i <= endChar) {\n                    if (i == endChar) {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"name\");\n                    }\n                }\n            }\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n            \n            outBuf[outPtr++] = c;\n\n            \n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n\n    \n    protected String _handleOddName(int i) throws IOException {\n        \n        if (i == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n            return _parseAposName();\n        }\n        \n        if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {\n            _reportUnexpectedChar(i, \"was expecting double-quote to start field name\");\n        }\n        final int[] codes = CharTypes.getInputCodeLatin1JsNames();\n        final int maxCode = codes.length;\n\n        \n        boolean firstOk;\n\n        if (i < maxCode) { \n            firstOk = (codes[i] == 0) && (i < INT_0 || i > INT_9);\n        } else {\n            firstOk = Character.isJavaIdentifierPart((char) i);\n        }\n        if (!firstOk) {\n            _reportUnexpectedChar(i, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\");\n        }\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode) {\n                    if (codes[ch] != 0) {\n                        int start = _inputPtr-1; \n                        _inputPtr = ptr;\n                        return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                    }\n                } else if (!Character.isJavaIdentifierPart((char) ch)) {\n                    int start = _inputPtr-1; \n                    _inputPtr = ptr;\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n        int start = _inputPtr-1;\n        _inputPtr = ptr;\n        return _handleOddName2(start, hash, codes);\n    }\n\n    protected String _parseAposName() throws IOException {\n        \n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch == '\\'') {\n                    int start = _inputPtr;\n                    _inputPtr = ptr+1; \n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                if (ch < maxCode && codes[ch] != 0) {\n                    break;\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        int start = _inputPtr;\n        _inputPtr = ptr;\n\n        return _parseName2(start, hash, '\\'');\n    }\n\n    \n    protected JsonToken _handleOddValue(int i) throws IOException {\n        \n        switch (i) {\n        case '\\'':\n            \n            if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n                return _handleApos();\n            }\n            break;\n        case 'N':\n            _matchToken(\"NaN\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"NaN\", Double.NaN);\n            }\n            _reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case 'I':\n            _matchToken(\"Infinity\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY);\n            }\n            _reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case '+': \n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOFInValue();\n                }\n            }\n            return _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false);\n        }\n        \n        if (Character.isJavaIdentifierStart(i)) {\n            _reportInvalidToken(\"\"+((char) i), \"('true', 'false' or 'null')\");\n        }\n        \n        _reportUnexpectedChar(i, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\n        return null;\n    }\n    \n    protected JsonToken _handleApos() throws IOException {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\");\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= '\\\\') {\n                if (i == '\\\\') {\n                    \n                    c = _decodeEscaped();\n                } else if (i <= '\\'') {\n                    if (i == '\\'') {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n            \n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            \n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        return JsonToken.VALUE_STRING;\n    }\n    \n    private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        final int maxCode = codes.length;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) { \n                    break;\n                }\n            }\n            char c = _inputBuffer[_inputPtr];\n            int i = (int) c;\n            if (i <= maxCode) {\n                if (codes[i] != 0) {\n                    break;\n                }\n            } else if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n            \n            outBuf[outPtr++] = c;\n\n            \n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n  \n    @Override\n    protected void _finishString() throws IOException {\n        \n        int ptr = _inputPtr;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode && codes[ch] != 0) {\n                    if (ch == '\"') {\n                        _textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n                        _inputPtr = ptr+1;\n                        \n                        return;\n                    }\n                    break;\n                }\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        \n        _textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n        _inputPtr = ptr;\n        _finishString2();\n    }\n\n    protected void _finishString2() throws IOException {\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\");\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    \n                    c = _decodeEscaped();\n                } else if (i <= INT_QUOTE) {\n                    if (i == INT_QUOTE) {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n            \n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            \n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n    }\n\n    \n    protected void _skipString() throws IOException {\n        _tokenIncomplete = false;\n\n        int inputPtr = _inputPtr;\n        int inputLen = _inputEnd;\n        char[] inputBuffer = _inputBuffer;\n\n        while (true) {\n            if (inputPtr >= inputLen) {\n                _inputPtr = inputPtr;\n                if (!loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\");\n                }\n                inputPtr = _inputPtr;\n                inputLen = _inputEnd;\n            }\n            char c = inputBuffer[inputPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    \n                    _inputPtr = inputPtr;\n                    c = _decodeEscaped();\n                    inputPtr = _inputPtr;\n                    inputLen = _inputEnd;\n                } else if (i <= INT_QUOTE) {\n                    if (i == INT_QUOTE) {\n                        _inputPtr = inputPtr;\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _inputPtr = inputPtr;\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n        }\n    }\n\n    \n    \n    \n    protected void _skipCR() throws IOException {\n        if (_inputPtr < _inputEnd || loadMore()) {\n            if (_inputBuffer[_inputPtr] == '\\n') {\n                ++_inputPtr;\n            }\n        }\n        ++_currInputRow;\n        _currInputRowStart = _inputPtr;\n    }\n\n    private int _skipWS() throws IOException {\n        final int[] codes = _icWS;\n        while (_inputPtr < _inputEnd || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i >= 64) {\n                return i;\n            }\n            switch (codes[i]) {\n            case -1:\n                _throwInvalidSpace(i);\n            case 0:\n                return i;\n            case 1:\n                continue;\n            case '\\n':\n                ++_currInputRow;\n                _currInputRowStart = _inputPtr;\n                break;\n            case '\\r':\n                _skipCR();\n                break;\n            case '/':\n                _skipComment();\n                break;\n            case '#':\n                if (!_skipYAMLComment()) {\n                    return i;\n                }\n                break;\n            }\n        }\n        throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\");\n    }\n\n    private int _skipWSOrEnd() throws IOException {\n        final int[] codes = _icWS;\n        while (_inputPtr < _inputEnd || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i >= 64) {\n                return i;\n            }\n            switch (codes[i]) {\n            case -1:\n                _throwInvalidSpace(i);\n            case 0:\n                return i;\n            case 1:\n                continue;\n            case '\\n':\n                ++_currInputRow;\n                _currInputRowStart = _inputPtr;\n                break;\n            case '\\r':\n                _skipCR();\n                break;\n            case '/':\n                _skipComment();\n                break;\n            case '#':\n                if (!_skipYAMLComment()) {\n                    return i;\n                }\n                break;\n            }\n        }\n        \n        _handleEOF();\n        return -1;\n    }\n\n    private void _skipComment() throws IOException {\n        if (!isEnabled(Feature.ALLOW_COMMENTS)) {\n            _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\");\n        }\n        \n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            _reportInvalidEOF(\" in a comment\");\n        }\n        char c = _inputBuffer[_inputPtr++];\n        if (c == '/') {\n            _skipLine();\n        } else if (c == '*') {\n            _skipCComment();\n        } else {\n            _reportUnexpectedChar(c, \"was expecting either '*' or '/' for a comment\");\n        }\n    }\n\n    private void _skipCComment() throws IOException {\n        \n        main_loop:\n        while ((_inputPtr < _inputEnd) || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i <= '*') {\n                if (i == '*') { \n                    if ((_inputPtr >= _inputEnd) && !loadMore()) {\n                        break main_loop;\n                    }\n                    if (_inputBuffer[_inputPtr] == INT_SLASH) {\n                        ++_inputPtr;\n                        return;\n                    }\n                    continue;\n                }\n                if (i < INT_SPACE) {\n                    if (i == INT_LF) {\n                        ++_currInputRow;\n                        _currInputRowStart = _inputPtr;\n                    } else if (i == INT_CR) {\n                        _skipCR();\n                    } else if (i != INT_TAB) {\n                        _throwInvalidSpace(i);\n                    }\n                }\n            }\n        }\n        _reportInvalidEOF(\" in a comment\");\n    }\n\n    private boolean _skipYAMLComment() throws IOException {\n        if (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) {\n            return false;\n        }\n        _skipLine();\n        return true;\n    }\n    \n    private void _skipLine() throws IOException {\n        \n        while ((_inputPtr < _inputEnd) || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                    break;\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n    }\n\n    @Override\n    protected char _decodeEscaped() throws IOException {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\" in character escape sequence\");\n            }\n        }\n        char c = _inputBuffer[_inputPtr++];\n\n        switch ((int) c) {\n            \n        case 'b':\n            return '\\b';\n        case 't':\n            return '\\t';\n        case 'n':\n            return '\\n';\n        case 'f':\n            return '\\f';\n        case 'r':\n            return '\\r';\n\n            \n        case '\"':\n        case '/':\n        case '\\\\':\n            return c;\n\n        case 'u': \n            break;\n\n        default:\n            return _handleUnrecognizedCharacterEscape(c);\n        }\n\n        \n        int value = 0;\n        for (int i = 0; i < 4; ++i) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in character escape sequence\");\n                }\n            }\n            int ch = (int) _inputBuffer[_inputPtr++];\n            int digit = CharTypes.charToHex(ch);\n            if (digit < 0) {\n                _reportUnexpectedChar(ch, \"expected a hex-digit for character escape sequence\");\n            }\n            value = (value << 4) | digit;\n        }\n        return (char) value;\n    }\n    \n    \n    protected void _matchToken(String matchStr, int i) throws IOException {\n        final int len = matchStr.length();\n\n        do {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidToken(matchStr.substring(0, i));\n                }\n            }\n            if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n\n        \n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                return;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        if (c < '0' || c == ']' || c == '}') { \n            return;\n        }\n        \n        if (Character.isJavaIdentifierPart(c)) {\n            _reportInvalidToken(matchStr.substring(0, i));\n        }\n        return;\n    }\n\n    \n\n    \n    @SuppressWarnings(\"resource\")\n    protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException {\n        ByteArrayBuilder builder = _getByteArrayBuilder();\n\n        \n        while (true) {\n            \n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (ch == '\"') { \n                    return builder.toByteArray();\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { \n                    continue;\n                }\n            }\n            int decodedData = bits;\n            \n            \n            \n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n            \n            \n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            \n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    \n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        builder.append(decodedData);\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    \n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    \n                    decodedData >>= 4;\n                    builder.append(decodedData);\n                    continue;\n                }\n                \n            }\n            \n            decodedData = (decodedData << 6) | bits;\n            \n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    \n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        builder.appendTwoBytes(decodedData);\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    \n                    \n                    \n                    \n                    \n                    decodedData >>= 2;\n                    builder.appendTwoBytes(decodedData);\n                    continue;\n                }\n                \n            }\n            \n            decodedData = (decodedData << 6) | bits;\n            builder.appendThreeBytes(decodedData);\n        }\n    }\n\n    \n\n    protected void _reportInvalidToken(String matchedPart) throws IOException {\n        _reportInvalidToken(matchedPart, \"'null', 'true', 'false' or NaN\");\n    }\n    \n    protected void _reportInvalidToken(String matchedPart, String msg) throws IOException {\n        StringBuilder sb = new StringBuilder(matchedPart);\n        \n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    break;\n                }\n            }\n            char c = _inputBuffer[_inputPtr];\n            if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            sb.append(c);\n        }\n        _reportError(\"Unrecognized token '\"+sb.toString()+\"': was expecting \");\n    }\n}\n",
      "fixed_full_code": "package com.fasterxml.jackson.core.json;\n\nimport java.io.*;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.base.ParserBase;\nimport com.fasterxml.jackson.core.io.CharTypes;\nimport com.fasterxml.jackson.core.io.IOContext;\nimport com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer;\nimport com.fasterxml.jackson.core.util.*;\n\n\npublic final class ReaderBasedJsonParser extends ParserBase { protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1(); private final static int[] _icWS = CharTypes.getInputCodeWS(); protected Reader _reader; protected char[] _inputBuffer; protected ObjectCodec _objectCodec; final protected CharsToNameCanonicalizer _symbols; final protected int _hashSeed; protected boolean _tokenIncomplete = false; public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st) {\n        super(ctxt, features);\n        _reader = r;\n        _inputBuffer = ctxt.allocTokenBuffer();\n        _objectCodec = codec;\n        _symbols = st;\n        _hashSeed = st.hashSeed();\n    }\n    \n    \n\n    @Override\n    public ObjectCodec getCodec() {\n        return _objectCodec;\n    }\n\n    @Override\n    public void setCodec(ObjectCodec c) {\n        _objectCodec = c;\n    }\n    \n    @Override\n    public int releaseBuffered(Writer w) throws IOException {\n        int count = _inputEnd - _inputPtr;\n        if (count < 1) {\n            return 0;\n        }\n        \n        int origPtr = _inputPtr;\n        w.write(_inputBuffer, origPtr, count);\n        return count;\n    }\n\n    @Override\n    public Object getInputSource() {\n        return _reader;\n    }\n\n    @Override\n    protected boolean loadMore() throws IOException {\n        _currInputProcessed += _inputEnd;\n        _currInputRowStart -= _inputEnd;\n\n        if (_reader != null) {\n            int count = _reader.read(_inputBuffer, 0, _inputBuffer.length);\n            if (count > 0) {\n                _inputPtr = 0;\n                _inputEnd = count;\n                return true;\n            }\n            \n            _closeInput();\n            \n            if (count == 0) {\n                throw new IOException(\"Reader returned 0 characters when trying to read \"+_inputEnd);\n            }\n        }\n        return false;\n    }\n\n    protected char getNextChar(String eofMsg) throws IOException, JsonParseException {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(eofMsg);\n            }\n        }\n        return _inputBuffer[_inputPtr++];\n    }\n\n    @Override\n    protected void _closeInput() throws IOException {\n        \n        if (_reader != null) {\n            if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_SOURCE)) {\n                _reader.close();\n            }\n            _reader = null;\n        }\n    }\n\n    \n    @Override\n    protected void _releaseBuffers() throws IOException {\n        super._releaseBuffers();\n        char[] buf = _inputBuffer;\n        if (buf != null) {\n            _inputBuffer = null;\n            _ioContext.releaseTokenBuffer(buf);\n        }\n    }\n    \n    \n    \n    \n    @Override\n    public String getText() throws IOException, JsonParseException {\n        JsonToken t = _currToken;\n        if (t == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); \n            }\n            return _textBuffer.contentsAsString();\n        }\n        return _getText2(t);\n    }\n\n    \n    \n    \n    @Override\n    public String getValueAsString() throws IOException, JsonParseException {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); \n            }\n            return _textBuffer.contentsAsString();\n        }\n        return super.getValueAsString(null);\n    }\n    \n    \n    @Override\n    public String getValueAsString(String defValue) throws IOException, JsonParseException {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); \n            }\n            return _textBuffer.contentsAsString();\n        }\n        return super.getValueAsString(defValue);\n    }\n    \n    \n    protected String _getText2(JsonToken t) {\n        if (t == null) {\n            return null;\n        }\n        switch (t) {\n        case FIELD_NAME:\n            return _parsingContext.getCurrentName();\n\n        case VALUE_STRING:\n            \n        case VALUE_NUMBER_INT:\n        case VALUE_NUMBER_FLOAT:\n            return _textBuffer.contentsAsString();\n        default:\n            return t.asString();\n        }\n    }\n\n    @Override\n    public char[] getTextCharacters() throws IOException, JsonParseException {\n        if (_currToken != null) { \n            switch (_currToken) {\n                \n            case FIELD_NAME:\n                if (!_nameCopied) {\n                    String name = _parsingContext.getCurrentName();\n                    int nameLen = name.length();\n                    if (_nameCopyBuffer == null) {\n                        _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen);\n                    } else if (_nameCopyBuffer.length < nameLen) {\n                        _nameCopyBuffer = new char[nameLen];\n                    }\n                    name.getChars(0, nameLen, _nameCopyBuffer, 0);\n                    _nameCopied = true;\n                }\n                return _nameCopyBuffer;\n    \n            case VALUE_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); \n                }\n                \n            case VALUE_NUMBER_INT:\n            case VALUE_NUMBER_FLOAT:\n                return _textBuffer.getTextBuffer();\n                \n            default:\n                return _currToken.asCharArray();\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public int getTextLength() throws IOException, JsonParseException {\n        if (_currToken != null) { \n            switch (_currToken) {\n                \n            case FIELD_NAME:\n                return _parsingContext.getCurrentName().length();\n            case VALUE_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); \n                }\n                \n            case VALUE_NUMBER_INT:\n            case VALUE_NUMBER_FLOAT:\n                return _textBuffer.size();\n                \n            default:\n                return _currToken.asCharArray().length;\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public int getTextOffset() throws IOException, JsonParseException {\n        \n        if (_currToken != null) {\n            switch (_currToken) {\n            case FIELD_NAME:\n                return 0;\n            case VALUE_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); \n                }\n                \n            case VALUE_NUMBER_INT:\n            case VALUE_NUMBER_FLOAT:\n                return _textBuffer.getTextOffset();\n            default:\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException {\n        if (_currToken != JsonToken.VALUE_STRING &&\n                (_currToken != JsonToken.VALUE_EMBEDDED_OBJECT || _binaryValue == null)) {\n            _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\");\n        }\n        \n        if (_tokenIncomplete) {\n            try {\n                _binaryValue = _decodeBase64(b64variant);\n            } catch (IllegalArgumentException iae) {\n                throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage());\n            }\n            \n            _tokenIncomplete = false;\n        } else { \n            if (_binaryValue == null) {\n                @SuppressWarnings(\"resource\")\n                ByteArrayBuilder builder = _getByteArrayBuilder();\n                _decodeBase64(getText(), builder, b64variant);\n                _binaryValue = builder.toByteArray();\n            }\n        }\n        return _binaryValue;\n    }\n    \n    @Override\n    public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException {\n        \n        if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) {\n            byte[] b = getBinaryValue(b64variant);\n            out.write(b);\n            return b.length;\n        }\n        \n        byte[] buf = _ioContext.allocBase64Buffer();\n        try {\n            return _readBinary(b64variant, out, buf);\n        } finally {\n            _ioContext.releaseBase64Buffer(buf);\n        }\n    }\n\n    protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\n        int outputCount = 0;\n\n        while (true) {\n            \n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { \n                if (ch == '\"') {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { \n                    continue;\n                }\n            }\n\n            \n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            \n\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            \n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            \n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    \n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    \n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    \n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            \n            decodedData = (decodedData << 6) | bits;\n            \n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    \n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    \n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            \n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }\n\n    \n\n    \n    @Override\n    public JsonToken nextToken() throws IOException, JsonParseException {\n        _numTypesValid = NR_UNKNOWN;\n\n        \n        if (_currToken == JsonToken.FIELD_NAME) {\n            return _nextAfterName();\n        }\n        if (_tokenIncomplete) {\n            _skipString(); \n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) { \n            \n            close();\n            return (_currToken = null);\n        }\n\n        \n        _tokenInputTotal = _currInputProcessed + _inputPtr - 1;\n        _tokenInputRow = _currInputRow;\n        _tokenInputCol = _inputPtr - _currInputRowStart - 1;\n\n        \n        _binaryValue = null;\n\n        \n        if (i == INT_RBRACKET) {\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.getParent();\n            return (_currToken = JsonToken.END_ARRAY);\n        }\n        if (i == INT_RCURLY) {\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.getParent();\n            return (_currToken = JsonToken.END_OBJECT);\n        }\n\n        \n        if (_parsingContext.expectComma()) {\n            if (i != INT_COMMA) {\n                _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\");\n            }\n            i = _skipWS();\n        }\n\n        \n        boolean inObject = _parsingContext.inObject();\n        if (inObject) {\n           \n            String name = _parseName(i);\n            _parsingContext.setCurrentName(name);\n            _currToken = JsonToken.FIELD_NAME;\n            i = _skipWS();\n            if (i != INT_COLON) {\n                _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");\n            }\n            i = _skipWS();\n        }\n\n        \n\n        JsonToken t;\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            t = JsonToken.VALUE_STRING;\n            break;\n        case '[':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_OBJECT;\n            break;\n        case ']':\n        case '}':\n            \n            \n            _reportUnexpectedChar(i, \"expected a value\");\n        case 't':\n            _matchToken(\"true\", 1);\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchToken(\"false\", 1);\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchToken(\"null\", 1);\n            t = JsonToken.VALUE_NULL;\n            break;\n\n        case '-':\n            \n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parseNumber(i);\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n\n        if (inObject) {\n            _nextToken = t;\n            return _currToken;\n        }\n        _currToken = t;\n        return t;\n    }\n\n    private JsonToken _nextAfterName() {\n        _nameCopied = false; \n        JsonToken t = _nextToken;\n        _nextToken = null;\n        \n        if (t == JsonToken.START_ARRAY) {\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n        } else if (t == JsonToken.START_OBJECT) {\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n        }\n        return (_currToken = t);\n    }\n\n    \n\n    \n    @Override\n    public String nextTextValue() throws IOException, JsonParseException {\n        if (_currToken == JsonToken.FIELD_NAME) { \n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_STRING) {\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString();\n                }\n                return _textBuffer.contentsAsString();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        \n        return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;\n    }\n\n    \n    @Override\n    public int nextIntValue(int defaultValue) throws IOException, JsonParseException {\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getIntValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        \n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;\n    }\n\n    \n    @Override\n    public long nextLongValue(long defaultValue) throws IOException, JsonParseException {\n        if (_currToken == JsonToken.FIELD_NAME) { \n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getLongValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        \n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;\n    }\n\n    \n    @Override\n    public Boolean nextBooleanValue() throws IOException, JsonParseException {\n        if (_currToken == JsonToken.FIELD_NAME) { \n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_TRUE) {\n                return Boolean.TRUE;\n            }\n            if (t == JsonToken.VALUE_FALSE) {\n                return Boolean.FALSE;\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        switch (nextToken()) {\n        case VALUE_TRUE:\n            return Boolean.TRUE;\n        case VALUE_FALSE:\n            return Boolean.FALSE;\n        default:\n        \treturn null;\n        }\n    }\n    \n    @Override\n    public void close() throws IOException {\n        super.close();\n        _symbols.release();\n    }\n\n    \n\n    \n    protected JsonToken _parseNumber(int ch) throws IOException {\n        \n        boolean negative = (ch == INT_MINUS);\n        int ptr = _inputPtr;\n        int startPtr = ptr-1; \n        final int inputLen = _inputEnd;\n\n        dummy_loop:\n        do { \n            if (negative) { \n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = _inputBuffer[ptr++];\n                \n                if (ch > INT_9 || ch < INT_0) {\n                    _inputPtr = ptr;\n                    return _handleInvalidNumberStart(ch, true);\n                }\n                \n            }\n            \n            if (ch == INT_0) {\n                break dummy_loop;\n            }\n            \n            \n            \n            int intLen = 1; \n            \n            \n            \n            int_loop:\n            while (true) {\n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break int_loop;\n                }\n                ++intLen;\n            }\n\n            int fractLen = 0;\n            \n            \n            if (ch == '.') { \n                fract_loop:\n                while (true) {\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                    if (ch < INT_0 || ch > INT_9) {\n                        break fract_loop;\n                    }\n                    ++fractLen;\n                }\n                \n                if (fractLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n                }\n            }\n\n            int expLen = 0;\n            if (ch == 'e' || ch == 'E') { \n                if (ptr >= inputLen) {\n                    break dummy_loop;\n                }\n                \n                ch = (int) _inputBuffer[ptr++];\n                if (ch == INT_MINUS || ch == INT_PLUS) { \n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                while (ch <= INT_9 && ch >= INT_0) {\n                    ++expLen;\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                \n                if (expLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n                }\n            }\n            \n            --ptr; \n            _inputPtr = ptr;\n            \n            if (_parsingContext.inRoot()) {\n                _verifyRootSpace(ch);\n            }\n            int len = ptr-startPtr;\n            _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n            return reset(negative, intLen, fractLen, expLen);\n        } while (false);\n\n        _inputPtr = negative ? (startPtr+1) : startPtr;\n        return _parseNumber2(negative);\n    }\n\n    \n    private JsonToken _parseNumber2(boolean negative) throws IOException {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n\n        \n        if (negative) {\n            outBuf[outPtr++] = '-';\n        }\n\n        \n        int intLen = 0;\n        char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\");\n        if (c == '0') {\n            c = _verifyNoLeadingZeroes();\n        }\n        boolean eof = false;\n\n        \n        int_loop:\n        while (c >= '0' && c <= '9') {\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                \n                c = CHAR_NULL;\n                eof = true;\n                break int_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        \n        if (intLen == 0) {\n            reportInvalidNumber(\"Missing integer part (next char \"+_getCharDesc(c)+\")\");\n        }\n\n        int fractLen = 0;\n        \n        if (c == '.') { \n            outBuf[outPtr++] = c;\n\n            fract_loop:\n            while (true) {\n                if (_inputPtr >= _inputEnd && !loadMore()) {\n                    eof = true;\n                    break fract_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n                if (c < INT_0 || c > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n            }\n            \n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n            }\n        }\n\n        int expLen = 0;\n        if (c == 'e' || c == 'E') { \n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            \n            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                : getNextChar(\"expected a digit for number exponent\");\n            \n            if (c == '-' || c == '+') {\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                \n                c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                    : getNextChar(\"expected a digit for number exponent\");\n            }\n\n            exp_loop:\n            while (c <= INT_9 && c >= INT_0) {\n                ++expLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                if (_inputPtr >= _inputEnd && !loadMore()) {\n                    eof = true;\n                    break exp_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n            }\n            \n            if (expLen == 0) {\n                reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n            }\n        }\n\n        \n        if (!eof) {\n            --_inputPtr;\n            if (_parsingContext.inRoot()) {\n                _verifyRootSpace(c);\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        \n        return reset(negative, intLen, fractLen, expLen);\n    }\n\n    \n    private char _verifyNoLeadingZeroes() throws IOException {\n        \n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            return '0';\n        }\n        char ch = _inputBuffer[_inputPtr];\n        \n        if (ch < '0' || ch > '9') {\n            return '0';\n        }\n        if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) {\n            reportInvalidNumber(\"Leading zeroes not allowed\");\n        }\n        \n        ++_inputPtr; \n        if (ch == INT_0) {\n            while (_inputPtr < _inputEnd || loadMore()) {\n                ch = _inputBuffer[_inputPtr];\n                if (ch < '0' || ch > '9') { \n                    return '0';\n                }\n                ++_inputPtr; \n                if (ch != '0') { \n                    break;\n                }\n            }\n        }\n        return ch;\n    }\n\n    \n    protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException {\n        if (ch == 'I') {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOFInValue();\n                }\n            }\n            ch = _inputBuffer[_inputPtr++];\n            if (ch == 'N') {\n                String match = negative ? \"-INF\" :\"+INF\";\n                _matchToken(match, 3);\n                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n                }\n                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            } else if (ch == 'n') {\n                String match = negative ? \"-Infinity\" :\"+Infinity\";\n                _matchToken(match, 3);\n                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n                }\n                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            }\n        }\n        reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        return null;\n    }\n\n    \n    private final void _verifyRootSpace(int ch) throws IOException {\n        \n        ++_inputPtr;\n        switch (ch) {\n        case ' ':\n        case '\\t':\n            return;\n        case '\\r':\n            _skipCR();\n            return;\n        case '\\n':\n            ++_currInputRow;\n            _currInputRowStart = _inputPtr;\n            return;\n        }\n        _reportMissingRootWS(ch);\n    }\n    \n    \n\n    protected String _parseName(int i) throws IOException {\n        if (i != INT_QUOTE) {\n            return _handleOddName(i);\n        }\n        \n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode && codes[ch] != 0) {\n                    if (ch == '\"') {\n                        int start = _inputPtr;\n                        _inputPtr = ptr+1; \n                        return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                    }\n                    break;\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        int start = _inputPtr;\n        _inputPtr = ptr;\n        return _parseName2(start, hash, INT_QUOTE);\n    }\n\n    private String _parseName2(int startPtr, int hash, int endChar) throws IOException {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n\n        \n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing '\"+((char) endChar)+\"' for name\");\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    \n                    c = _decodeEscaped();\n                } else if (i <= endChar) {\n                    if (i == endChar) {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"name\");\n                    }\n                }\n            }\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n            \n            outBuf[outPtr++] = c;\n\n            \n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n\n    \n    protected String _handleOddName(int i) throws IOException {\n        \n        if (i == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n            return _parseAposName();\n        }\n        \n        if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {\n            _reportUnexpectedChar(i, \"was expecting double-quote to start field name\");\n        }\n        final int[] codes = CharTypes.getInputCodeLatin1JsNames();\n        final int maxCode = codes.length;\n\n        \n        boolean firstOk;\n\n        if (i < maxCode) { \n            firstOk = (codes[i] == 0) && (i < INT_0 || i > INT_9);\n        } else {\n            firstOk = Character.isJavaIdentifierPart((char) i);\n        }\n        if (!firstOk) {\n            _reportUnexpectedChar(i, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\");\n        }\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode) {\n                    if (codes[ch] != 0) {\n                        int start = _inputPtr-1; \n                        _inputPtr = ptr;\n                        return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                    }\n                } else if (!Character.isJavaIdentifierPart((char) ch)) {\n                    int start = _inputPtr-1; \n                    _inputPtr = ptr;\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n        int start = _inputPtr-1;\n        _inputPtr = ptr;\n        return _handleOddName2(start, hash, codes);\n    }\n\n    protected String _parseAposName() throws IOException {\n        \n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch == '\\'') {\n                    int start = _inputPtr;\n                    _inputPtr = ptr+1; \n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                if (ch < maxCode && codes[ch] != 0) {\n                    break;\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        int start = _inputPtr;\n        _inputPtr = ptr;\n\n        return _parseName2(start, hash, '\\'');\n    }\n\n    \n    protected JsonToken _handleOddValue(int i) throws IOException {\n        \n        switch (i) {\n        case '\\'':\n            \n            if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n                return _handleApos();\n            }\n            break;\n        case 'N':\n            _matchToken(\"NaN\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"NaN\", Double.NaN);\n            }\n            _reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case 'I':\n            _matchToken(\"Infinity\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY);\n            }\n            _reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case '+': \n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOFInValue();\n                }\n            }\n            return _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false);\n        }\n        \n        if (Character.isJavaIdentifierStart(i)) {\n            _reportInvalidToken(\"\"+((char) i), \"('true', 'false' or 'null')\");\n        }\n        \n        _reportUnexpectedChar(i, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\n        return null;\n    }\n    \n    protected JsonToken _handleApos() throws IOException {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\");\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= '\\\\') {\n                if (i == '\\\\') {\n                    \n                    c = _decodeEscaped();\n                } else if (i <= '\\'') {\n                    if (i == '\\'') {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n            \n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            \n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        return JsonToken.VALUE_STRING;\n    }\n    \n    private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        final int maxCode = codes.length;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) { \n                    break;\n                }\n            }\n            char c = _inputBuffer[_inputPtr];\n            int i = (int) c;\n            if (i <= maxCode) {\n                if (codes[i] != 0) {\n                    break;\n                }\n            } else if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n            \n            outBuf[outPtr++] = c;\n\n            \n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n  \n    @Override\n    protected void _finishString() throws IOException {\n        \n        int ptr = _inputPtr;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode && codes[ch] != 0) {\n                    if (ch == '\"') {\n                        _textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n                        _inputPtr = ptr+1;\n                        \n                        return;\n                    }\n                    break;\n                }\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        \n        _textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n        _inputPtr = ptr;\n        _finishString2();\n    }\n\n    protected void _finishString2() throws IOException {\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\");\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    \n                    c = _decodeEscaped();\n                } else if (i <= INT_QUOTE) {\n                    if (i == INT_QUOTE) {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n            \n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            \n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n    }\n\n    \n    protected void _skipString() throws IOException {\n        _tokenIncomplete = false;\n\n        int inputPtr = _inputPtr;\n        int inputLen = _inputEnd;\n        char[] inputBuffer = _inputBuffer;\n\n        while (true) {\n            if (inputPtr >= inputLen) {\n                _inputPtr = inputPtr;\n                if (!loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\");\n                }\n                inputPtr = _inputPtr;\n                inputLen = _inputEnd;\n            }\n            char c = inputBuffer[inputPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    \n                    _inputPtr = inputPtr;\n                    c = _decodeEscaped();\n                    inputPtr = _inputPtr;\n                    inputLen = _inputEnd;\n                } else if (i <= INT_QUOTE) {\n                    if (i == INT_QUOTE) {\n                        _inputPtr = inputPtr;\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _inputPtr = inputPtr;\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n        }\n    }\n\n    \n    \n    \n    protected void _skipCR() throws IOException {\n        if (_inputPtr < _inputEnd || loadMore()) {\n            if (_inputBuffer[_inputPtr] == '\\n') {\n                ++_inputPtr;\n            }\n        }\n        ++_currInputRow;\n        _currInputRowStart = _inputPtr;\n    }\n\n    private int _skipWS() throws IOException {\n        final int[] codes = _icWS;\n        while (_inputPtr < _inputEnd || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i >= 64) {\n                return i;\n            }\n            switch (codes[i]) {\n            case -1:\n                _throwInvalidSpace(i);\n            case 0:\n                return i;\n            case 1:\n                continue;\n            case '\\n':\n                ++_currInputRow;\n                _currInputRowStart = _inputPtr;\n                break;\n            case '\\r':\n                _skipCR();\n                break;\n            case '/':\n                _skipComment();\n                break;\n            case '#':\n                if (!_skipYAMLComment()) {\n                    return i;\n                }\n                break;\n            }\n        }\n        throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\");\n    }\n\n    private int _skipWSOrEnd() throws IOException {\n        final int[] codes = _icWS;\n        while (_inputPtr < _inputEnd || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i >= 64) {\n                return i;\n            }\n            switch (codes[i]) {\n            case -1:\n                _throwInvalidSpace(i);\n            case 0:\n                return i;\n            case 1:\n                continue;\n            case '\\n':\n                ++_currInputRow;\n                _currInputRowStart = _inputPtr;\n                break;\n            case '\\r':\n                _skipCR();\n                break;\n            case '/':\n                _skipComment();\n                break;\n            case '#':\n                if (!_skipYAMLComment()) {\n                    return i;\n                }\n                break;\n            }\n        }\n        \n        _handleEOF();\n        return -1;\n    }\n\n    private void _skipComment() throws IOException {\n        if (!isEnabled(Feature.ALLOW_COMMENTS)) {\n            _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\");\n        }\n        \n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            _reportInvalidEOF(\" in a comment\");\n        }\n        char c = _inputBuffer[_inputPtr++];\n        if (c == '/') {\n            _skipLine();\n        } else if (c == '*') {\n            _skipCComment();\n        } else {\n            _reportUnexpectedChar(c, \"was expecting either '*' or '/' for a comment\");\n        }\n    }\n\n    private void _skipCComment() throws IOException {\n        \n        main_loop:\n        while ((_inputPtr < _inputEnd) || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i <= '*') {\n                if (i == '*') { \n                    if ((_inputPtr >= _inputEnd) && !loadMore()) {\n                        break main_loop;\n                    }\n                    if (_inputBuffer[_inputPtr] == INT_SLASH) {\n                        ++_inputPtr;\n                        return;\n                    }\n                    continue;\n                }\n                if (i < INT_SPACE) {\n                    if (i == INT_LF) {\n                        ++_currInputRow;\n                        _currInputRowStart = _inputPtr;\n                    } else if (i == INT_CR) {\n                        _skipCR();\n                    } else if (i != INT_TAB) {\n                        _throwInvalidSpace(i);\n                    }\n                }\n            }\n        }\n        _reportInvalidEOF(\" in a comment\");\n    }\n\n    private boolean _skipYAMLComment() throws IOException {\n        if (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) {\n            return false;\n        }\n        _skipLine();\n        return true;\n    }\n    \n    private void _skipLine() throws IOException {\n        \n        while ((_inputPtr < _inputEnd) || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                    break;\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n    }\n\n    @Override\n    protected char _decodeEscaped() throws IOException {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\" in character escape sequence\");\n            }\n        }\n        char c = _inputBuffer[_inputPtr++];\n\n        switch ((int) c) {\n            \n        case 'b':\n            return '\\b';\n        case 't':\n            return '\\t';\n        case 'n':\n            return '\\n';\n        case 'f':\n            return '\\f';\n        case 'r':\n            return '\\r';\n\n            \n        case '\"':\n        case '/':\n        case '\\\\':\n            return c;\n\n        case 'u': \n            break;\n\n        default:\n            return _handleUnrecognizedCharacterEscape(c);\n        }\n\n        \n        int value = 0;\n        for (int i = 0; i < 4; ++i) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in character escape sequence\");\n                }\n            }\n            int ch = (int) _inputBuffer[_inputPtr++];\n            int digit = CharTypes.charToHex(ch);\n            if (digit < 0) {\n                _reportUnexpectedChar(ch, \"expected a hex-digit for character escape sequence\");\n            }\n            value = (value << 4) | digit;\n        }\n        return (char) value;\n    }\n    \n    \n    protected void _matchToken(String matchStr, int i) throws IOException {\n        final int len = matchStr.length();\n\n        do {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidToken(matchStr.substring(0, i));\n                }\n            }\n            if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n\n        \n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                return;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        if (c < '0' || c == ']' || c == '}') { \n            return;\n        }\n        \n        if (Character.isJavaIdentifierPart(c)) {\n            _reportInvalidToken(matchStr.substring(0, i));\n        }\n        return;\n    }\n\n    \n\n    \n    @SuppressWarnings(\"resource\")\n    protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException {\n        ByteArrayBuilder builder = _getByteArrayBuilder();\n\n        \n        while (true) {\n            \n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (ch == '\"') { \n                    return builder.toByteArray();\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { \n                    continue;\n                }\n            }\n            int decodedData = bits;\n            \n            \n            \n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n            \n            \n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            \n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    \n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        builder.append(decodedData);\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    \n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    \n                    decodedData >>= 4;\n                    builder.append(decodedData);\n                    continue;\n                }\n                \n            }\n            \n            decodedData = (decodedData << 6) | bits;\n            \n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    \n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        builder.appendTwoBytes(decodedData);\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    \n                    \n                    \n                    \n                    \n                    decodedData >>= 2;\n                    builder.appendTwoBytes(decodedData);\n                    continue;\n                }\n                \n            }\n            \n            decodedData = (decodedData << 6) | bits;\n            builder.appendThreeBytes(decodedData);\n        }\n    }\n\n    \n\n    protected void _reportInvalidToken(String matchedPart) throws IOException {\n        _reportInvalidToken(matchedPart, \"'null', 'true', 'false' or NaN\");\n    }\n    \n    protected void _reportInvalidToken(String matchedPart, String msg) throws IOException {\n        StringBuilder sb = new StringBuilder(matchedPart);\n        \n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    break;\n                }\n            }\n            char c = _inputBuffer[_inputPtr];\n            if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            sb.append(c);\n        }\n        _reportError(\"Unrecognized token '\"+sb.toString()+\"': was expecting \");\n    }\n}\n",
      "buggy_signatures": [
        "public ObjectCodec getCodec()",
        "public void setCodec(ObjectCodec c)",
        "public int releaseBuffered(Writer w) throws IOException",
        "public Object getInputSource()",
        "protected boolean loadMore() throws IOException",
        "protected char getNextChar(String eofMsg) throws IOException, JsonParseException",
        "protected void _closeInput() throws IOException",
        "protected void _releaseBuffers() throws IOException",
        "public String getText() throws IOException, JsonParseException",
        "public String getValueAsString() throws IOException, JsonParseException",
        "public String getValueAsString(String defValue) throws IOException, JsonParseException",
        "protected String _getText2(JsonToken t)",
        "public char[] getTextCharacters() throws IOException, JsonParseException",
        "public int getTextLength() throws IOException, JsonParseException",
        "public int getTextOffset() throws IOException, JsonParseException",
        "public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException",
        "public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException",
        "protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException",
        "public JsonToken nextToken() throws IOException, JsonParseException",
        "private JsonToken _nextAfterName()",
        "public String nextTextValue() throws IOException, JsonParseException",
        "public int nextIntValue(int defaultValue) throws IOException, JsonParseException",
        "public long nextLongValue(long defaultValue) throws IOException, JsonParseException",
        "public Boolean nextBooleanValue() throws IOException, JsonParseException",
        "public void close() throws IOException",
        "protected JsonToken _parseNumber(int ch) throws IOException",
        "private JsonToken _parseNumber2(boolean negative) throws IOException",
        "private char _verifyNoLeadingZeroes() throws IOException",
        "protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException",
        "protected String _parseName(int i) throws IOException",
        "private String _parseName2(int startPtr, int hash, int endChar) throws IOException",
        "protected String _handleOddName(int i) throws IOException",
        "protected String _parseAposName() throws IOException",
        "protected JsonToken _handleOddValue(int i) throws IOException",
        "protected JsonToken _handleApos() throws IOException",
        "private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException",
        "protected void _finishString() throws IOException",
        "protected void _finishString2() throws IOException",
        "protected void _skipString() throws IOException",
        "protected void _skipCR() throws IOException",
        "private int _skipWS() throws IOException",
        "private int _skipWSOrEnd() throws IOException",
        "private void _skipComment() throws IOException",
        "private void _skipCComment() throws IOException",
        "private boolean _skipYAMLComment() throws IOException",
        "private void _skipLine() throws IOException",
        "protected char _decodeEscaped() throws IOException",
        "protected void _matchToken(String matchStr, int i) throws IOException",
        "protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException",
        "protected void _reportInvalidToken(String matchedPart) throws IOException",
        "protected void _reportInvalidToken(String matchedPart, String msg) throws IOException"
      ],
      "fixed_signatures": [
        "public ObjectCodec getCodec()",
        "public void setCodec(ObjectCodec c)",
        "public int releaseBuffered(Writer w) throws IOException",
        "public Object getInputSource()",
        "protected boolean loadMore() throws IOException",
        "protected char getNextChar(String eofMsg) throws IOException, JsonParseException",
        "protected void _closeInput() throws IOException",
        "protected void _releaseBuffers() throws IOException",
        "public String getText() throws IOException, JsonParseException",
        "public String getValueAsString() throws IOException, JsonParseException",
        "public String getValueAsString(String defValue) throws IOException, JsonParseException",
        "protected String _getText2(JsonToken t)",
        "public char[] getTextCharacters() throws IOException, JsonParseException",
        "public int getTextLength() throws IOException, JsonParseException",
        "public int getTextOffset() throws IOException, JsonParseException",
        "public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException",
        "public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException",
        "protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException",
        "public JsonToken nextToken() throws IOException, JsonParseException",
        "private JsonToken _nextAfterName()",
        "public String nextTextValue() throws IOException, JsonParseException",
        "public int nextIntValue(int defaultValue) throws IOException, JsonParseException",
        "public long nextLongValue(long defaultValue) throws IOException, JsonParseException",
        "public Boolean nextBooleanValue() throws IOException, JsonParseException",
        "public void close() throws IOException",
        "protected JsonToken _parseNumber(int ch) throws IOException",
        "private JsonToken _parseNumber2(boolean negative) throws IOException",
        "private char _verifyNoLeadingZeroes() throws IOException",
        "protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException",
        "private final void _verifyRootSpace(int ch) throws IOException",
        "protected String _parseName(int i) throws IOException",
        "private String _parseName2(int startPtr, int hash, int endChar) throws IOException",
        "protected String _handleOddName(int i) throws IOException",
        "protected String _parseAposName() throws IOException",
        "protected JsonToken _handleOddValue(int i) throws IOException",
        "protected JsonToken _handleApos() throws IOException",
        "private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException",
        "protected void _finishString() throws IOException",
        "protected void _finishString2() throws IOException",
        "protected void _skipString() throws IOException",
        "protected void _skipCR() throws IOException",
        "private int _skipWS() throws IOException",
        "private int _skipWSOrEnd() throws IOException",
        "private void _skipComment() throws IOException",
        "private void _skipCComment() throws IOException",
        "private boolean _skipYAMLComment() throws IOException",
        "private void _skipLine() throws IOException",
        "protected char _decodeEscaped() throws IOException",
        "protected void _matchToken(String matchStr, int i) throws IOException",
        "protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException",
        "protected void _reportInvalidToken(String matchedPart) throws IOException",
        "protected void _reportInvalidToken(String matchedPart, String msg) throws IOException"
      ],
      "methods": [
        {
          "buggy_method": "  protected JsonToken _parseNumber(int ch) throws IOException {\n  \n  boolean negative = (ch == INT_MINUS);\n  int ptr = _inputPtr;\n  int startPtr = ptr-1; \n  final int inputLen = _inputEnd;\n\n  dummy_loop:\n  do { \n  if (negative) { \n  if (ptr >= _inputEnd) {\n  break dummy_loop;\n  }\n  ch = _inputBuffer[ptr++];\n  \n  if (ch > INT_9 || ch < INT_0) {\n  _inputPtr = ptr;\n  return _handleInvalidNumberStart(ch, true);\n  }\n  \n  }\n  \n  if (ch == INT_0) {\n  break dummy_loop;\n  }\n  \n  \n  \n  int intLen = 1; \n  \n  \n  \n  int_loop:\n  while (true) {\n  if (ptr >= _inputEnd) {\n  break dummy_loop;\n  }\n  ch = (int) _inputBuffer[ptr++];\n  if (ch < INT_0 || ch > INT_9) {\n  break int_loop;\n  }\n  ++intLen;\n  }\n\n  int fractLen = 0;\n  \n  \n  if (ch == '.') { \n  fract_loop:\n  while (true) {\n  if (ptr >= inputLen) {\n  break dummy_loop;\n  }\n  ch = (int) _inputBuffer[ptr++];\n  if (ch < INT_0 || ch > INT_9) {\n  break fract_loop;\n  }\n  ++fractLen;\n  }\n  \n  if (fractLen == 0) {\n  reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n  }\n  }\n\n  int expLen = 0;\n  if (ch == 'e' || ch == 'E') { \n  if (ptr >= inputLen) {\n  break dummy_loop;\n  }\n  \n  ch = (int) _inputBuffer[ptr++];\n  if (ch == INT_MINUS || ch == INT_PLUS) { \n  if (ptr >= inputLen) {\n  break dummy_loop;\n  }\n  ch = (int) _inputBuffer[ptr++];\n  }\n  while (ch <= INT_9 && ch >= INT_0) {\n  ++expLen;\n  if (ptr >= inputLen) {\n  break dummy_loop;\n  }\n  ch = (int) _inputBuffer[ptr++];\n  }\n  \n  if (expLen == 0) {\n  reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n  }\n  }\n  \n  --ptr; \n  _inputPtr = ptr;\n  \n  int len = ptr-startPtr;\n  _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n  return reset(negative, intLen, fractLen, expLen);\n  } while (false);\n\n  _inputPtr = negative ? (startPtr+1) : startPtr;\n  return _parseNumber2(negative);\n  }",
          "fixed_method": "  protected JsonToken _parseNumber(int ch) throws IOException {\n  \n  boolean negative = (ch == INT_MINUS);\n  int ptr = _inputPtr;\n  int startPtr = ptr-1; \n  final int inputLen = _inputEnd;\n\n  dummy_loop:\n  do { \n  if (negative) { \n  if (ptr >= _inputEnd) {\n  break dummy_loop;\n  }\n  ch = _inputBuffer[ptr++];\n  \n  if (ch > INT_9 || ch < INT_0) {\n  _inputPtr = ptr;\n  return _handleInvalidNumberStart(ch, true);\n  }\n  \n  }\n  \n  if (ch == INT_0) {\n  break dummy_loop;\n  }\n  \n  \n  \n  int intLen = 1; \n  \n  \n  \n  int_loop:\n  while (true) {\n  if (ptr >= _inputEnd) {\n  break dummy_loop;\n  }\n  ch = (int) _inputBuffer[ptr++];\n  if (ch < INT_0 || ch > INT_9) {\n  break int_loop;\n  }\n  ++intLen;\n  }\n\n  int fractLen = 0;\n  \n  \n  if (ch == '.') { \n  fract_loop:\n  while (true) {\n  if (ptr >= inputLen) {\n  break dummy_loop;\n  }\n  ch = (int) _inputBuffer[ptr++];\n  if (ch < INT_0 || ch > INT_9) {\n  break fract_loop;\n  }\n  ++fractLen;\n  }\n  \n  if (fractLen == 0) {\n  reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n  }\n  }\n\n  int expLen = 0;\n  if (ch == 'e' || ch == 'E') { \n  if (ptr >= inputLen) {\n  break dummy_loop;\n  }\n  \n  ch = (int) _inputBuffer[ptr++];\n  if (ch == INT_MINUS || ch == INT_PLUS) { \n  if (ptr >= inputLen) {\n  break dummy_loop;\n  }\n  ch = (int) _inputBuffer[ptr++];\n  }\n  while (ch <= INT_9 && ch >= INT_0) {\n  ++expLen;\n  if (ptr >= inputLen) {\n  break dummy_loop;\n  }\n  ch = (int) _inputBuffer[ptr++];\n  }\n  \n  if (expLen == 0) {\n  reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n  }\n  }\n  \n  --ptr; \n  _inputPtr = ptr;\n  \n  if (_parsingContext.inRoot()) {\n  _verifyRootSpace(ch);\n  }\n  int len = ptr-startPtr;\n  _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n  return reset(negative, intLen, fractLen, expLen);\n  } while (false);\n\n  _inputPtr = negative ? (startPtr+1) : startPtr;\n  return _parseNumber2(negative);\n  }",
          "diff": [
            "@@ -949,6 +949,9 @@",
            "             --ptr; // need to push back following separator\n",
            "             _inputPtr = ptr;\n",
            "             // As per #105, need separating space between root values; check here\n",
            "+            if (_parsingContext.inRoot()) {\n",
            "+                _verifyRootSpace(ch);\n",
            "+            }\n",
            "             int len = ptr-startPtr;\n",
            "             _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n",
            "             return reset(negative, intLen, fractLen, expLen);\n"
          ],
          "changed_lines": 3
        },
        {
          "buggy_method": "  private JsonToken _parseNumber2(boolean negative) throws IOException {\n  char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n  int outPtr = 0;\n\n  \n  if (negative) {\n  outBuf[outPtr++] = '-';\n  }\n\n  \n  int intLen = 0;\n  char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\");\n  if (c == '0') {\n  c = _verifyNoLeadingZeroes();\n  }\n  boolean eof = false;\n\n  \n  int_loop:\n  while (c >= '0' && c <= '9') {\n  ++intLen;\n  if (outPtr >= outBuf.length) {\n  outBuf = _textBuffer.finishCurrentSegment();\n  outPtr = 0;\n  }\n  outBuf[outPtr++] = c;\n  if (_inputPtr >= _inputEnd && !loadMore()) {\n  \n  c = CHAR_NULL;\n  eof = true;\n  break int_loop;\n  }\n  c = _inputBuffer[_inputPtr++];\n  }\n  \n  if (intLen == 0) {\n  reportInvalidNumber(\"Missing integer part (next char \"+_getCharDesc(c)+\")\");\n  }\n\n  int fractLen = 0;\n  \n  if (c == '.') { \n  outBuf[outPtr++] = c;\n\n  fract_loop:\n  while (true) {\n  if (_inputPtr >= _inputEnd && !loadMore()) {\n  eof = true;\n  break fract_loop;\n  }\n  c = _inputBuffer[_inputPtr++];\n  if (c < INT_0 || c > INT_9) {\n  break fract_loop;\n  }\n  ++fractLen;\n  if (outPtr >= outBuf.length) {\n  outBuf = _textBuffer.finishCurrentSegment();\n  outPtr = 0;\n  }\n  outBuf[outPtr++] = c;\n  }\n  \n  if (fractLen == 0) {\n  reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n  }\n  }\n\n  int expLen = 0;\n  if (c == 'e' || c == 'E') { \n  if (outPtr >= outBuf.length) {\n  outBuf = _textBuffer.finishCurrentSegment();\n  outPtr = 0;\n  }\n  outBuf[outPtr++] = c;\n  \n  c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n  : getNextChar(\"expected a digit for number exponent\");\n  \n  if (c == '-' || c == '+') {\n  if (outPtr >= outBuf.length) {\n  outBuf = _textBuffer.finishCurrentSegment();\n  outPtr = 0;\n  }\n  outBuf[outPtr++] = c;\n  \n  c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n  : getNextChar(\"expected a digit for number exponent\");\n  }\n\n  exp_loop:\n  while (c <= INT_9 && c >= INT_0) {\n  ++expLen;\n  if (outPtr >= outBuf.length) {\n  outBuf = _textBuffer.finishCurrentSegment();\n  outPtr = 0;\n  }\n  outBuf[outPtr++] = c;\n  if (_inputPtr >= _inputEnd && !loadMore()) {\n  eof = true;\n  break exp_loop;\n  }\n  c = _inputBuffer[_inputPtr++];\n  }\n  \n  if (expLen == 0) {\n  reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n  }\n  }\n\n  \n  if (!eof) {\n  --_inputPtr;\n  }\n  _textBuffer.setCurrentLength(outPtr);\n  \n  return reset(negative, intLen, fractLen, expLen);\n  }",
          "fixed_method": "  private JsonToken _parseNumber2(boolean negative) throws IOException {\n  char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n  int outPtr = 0;\n\n  \n  if (negative) {\n  outBuf[outPtr++] = '-';\n  }\n\n  \n  int intLen = 0;\n  char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\");\n  if (c == '0') {\n  c = _verifyNoLeadingZeroes();\n  }\n  boolean eof = false;\n\n  \n  int_loop:\n  while (c >= '0' && c <= '9') {\n  ++intLen;\n  if (outPtr >= outBuf.length) {\n  outBuf = _textBuffer.finishCurrentSegment();\n  outPtr = 0;\n  }\n  outBuf[outPtr++] = c;\n  if (_inputPtr >= _inputEnd && !loadMore()) {\n  \n  c = CHAR_NULL;\n  eof = true;\n  break int_loop;\n  }\n  c = _inputBuffer[_inputPtr++];\n  }\n  \n  if (intLen == 0) {\n  reportInvalidNumber(\"Missing integer part (next char \"+_getCharDesc(c)+\")\");\n  }\n\n  int fractLen = 0;\n  \n  if (c == '.') { \n  outBuf[outPtr++] = c;\n\n  fract_loop:\n  while (true) {\n  if (_inputPtr >= _inputEnd && !loadMore()) {\n  eof = true;\n  break fract_loop;\n  }\n  c = _inputBuffer[_inputPtr++];\n  if (c < INT_0 || c > INT_9) {\n  break fract_loop;\n  }\n  ++fractLen;\n  if (outPtr >= outBuf.length) {\n  outBuf = _textBuffer.finishCurrentSegment();\n  outPtr = 0;\n  }\n  outBuf[outPtr++] = c;\n  }\n  \n  if (fractLen == 0) {\n  reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n  }\n  }\n\n  int expLen = 0;\n  if (c == 'e' || c == 'E') { \n  if (outPtr >= outBuf.length) {\n  outBuf = _textBuffer.finishCurrentSegment();\n  outPtr = 0;\n  }\n  outBuf[outPtr++] = c;\n  \n  c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n  : getNextChar(\"expected a digit for number exponent\");\n  \n  if (c == '-' || c == '+') {\n  if (outPtr >= outBuf.length) {\n  outBuf = _textBuffer.finishCurrentSegment();\n  outPtr = 0;\n  }\n  outBuf[outPtr++] = c;\n  \n  c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n  : getNextChar(\"expected a digit for number exponent\");\n  }\n\n  exp_loop:\n  while (c <= INT_9 && c >= INT_0) {\n  ++expLen;\n  if (outPtr >= outBuf.length) {\n  outBuf = _textBuffer.finishCurrentSegment();\n  outPtr = 0;\n  }\n  outBuf[outPtr++] = c;\n  if (_inputPtr >= _inputEnd && !loadMore()) {\n  eof = true;\n  break exp_loop;\n  }\n  c = _inputBuffer[_inputPtr++];\n  }\n  \n  if (expLen == 0) {\n  reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n  }\n  }\n\n  \n  if (!eof) {\n  --_inputPtr;\n  if (_parsingContext.inRoot()) {\n  _verifyRootSpace(c);\n  }\n  }\n  _textBuffer.setCurrentLength(outPtr);\n  \n  return reset(negative, intLen, fractLen, expLen);\n  }",
          "diff": [
            "@@ -1078,6 +1081,9 @@",
            "         // Ok; unless we hit end-of-input, need to push last char read back\n",
            "         if (!eof) {\n",
            "             --_inputPtr;\n",
            "+            if (_parsingContext.inRoot()) {\n",
            "+                _verifyRootSpace(c);\n",
            "+            }\n",
            "         }\n",
            "         _textBuffer.setCurrentLength(outPtr);\n",
            "         // And there we have it!\n"
          ],
          "changed_lines": 3
        },
        {
          "buggy_method": "  protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException {\n  if (ch == 'I') {\n  if (_inputPtr >= _inputEnd) {\n  if (!loadMore()) {\n  _reportInvalidEOFInValue();\n  }\n  }\n  ch = _inputBuffer[_inputPtr++];\n  if (ch == 'N') {\n  String match = negative ? \"-INF\" :\"+INF\";\n  _matchToken(match, 3);\n  if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n  return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n  }\n  _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n  } else if (ch == 'n') {\n  String match = negative ? \"-Infinity\" :\"+Infinity\";\n  _matchToken(match, 3);\n  if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n  return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n  }\n  _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n  }\n  }\n  reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n  return null;\n  }",
          "fixed_method": "  private final void _verifyRootSpace(int ch) throws IOException {\n  \n  ++_inputPtr;\n  switch (ch) {\n  case ' ':\n  case '\\t':\n  return;\n  case '\\r':\n  _skipCR();\n  return;\n  case '\\n':\n  ++_currInputRow;\n  _currInputRowStart = _inputPtr;\n  return;\n  }\n  _reportMissingRootWS(ch);\n  }",
          "diff": [
            "@@ -1159,7 +1165,24 @@",
            "      * NOTE: caller MUST ensure there is at least one character available;\n",
            "      * and that input pointer is AT given char (not past)\n",
            "      */\n",
            "+    private final void _verifyRootSpace(int ch) throws IOException\n",
            "+    {\n",
            "         // caller had pushed it back, before calling; reset\n",
            "+        ++_inputPtr;\n",
            "+        switch (ch) {\n",
            "+        case ' ':\n",
            "+        case '\\t':\n",
            "+            return;\n",
            "+        case '\\r':\n",
            "+            _skipCR();\n",
            "+            return;\n",
            "+        case '\\n':\n",
            "+            ++_currInputRow;\n",
            "+            _currInputRowStart = _inputPtr;\n",
            "+            return;\n",
            "+        }\n",
            "+        _reportMissingRootWS(ch);\n",
            "+    }\n",
            "     \n",
            "     /*\n",
            "     /**********************************************************\n"
          ],
          "changed_lines": 17
        }
      ]
    },
    {
      "name": "com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java",
      "buggy_full_code": "package com.fasterxml.jackson.core.json;\n\nimport java.io.*;\nimport java.util.Arrays;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.base.ParserBase;\nimport com.fasterxml.jackson.core.io.CharTypes;\nimport com.fasterxml.jackson.core.io.IOContext;\nimport com.fasterxml.jackson.core.sym.*;\nimport com.fasterxml.jackson.core.util.*;\n\n\npublic final class UTF8StreamJsonParser extends ParserBase { final static byte BYTE_LF = (byte) '\\n'; private final static int[] _icUTF8 = CharTypes.getInputCodeUtf8(); protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1(); private final static int[] _icWS = CharTypes.getInputCodeWS(); protected ObjectCodec _objectCodec; final protected BytesToNameCanonicalizer _symbols; protected int[] _quadBuffer = new int[16]; protected boolean _tokenIncomplete = false; private int _quad1; protected InputStream _inputStream; protected byte[] _inputBuffer; protected boolean _bufferRecyclable; public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable) {\n        super(ctxt, features);\n        _inputStream = in;\n        _objectCodec = codec;\n        _symbols = sym;\n        _inputBuffer = inputBuffer;\n        _inputPtr = start;\n        _inputEnd = end;\n        _bufferRecyclable = bufferRecyclable;\n    }\n\n    @Override\n    public ObjectCodec getCodec() {\n        return _objectCodec;\n    }\n\n    @Override\n    public void setCodec(ObjectCodec c) {\n        _objectCodec = c;\n    }\n    \n    \n\n    @Override\n    public int releaseBuffered(OutputStream out) throws IOException {\n        int count = _inputEnd - _inputPtr;\n        if (count < 1) {\n            return 0;\n        }\n        \n        int origPtr = _inputPtr;\n        out.write(_inputBuffer, origPtr, count);\n        return count;\n    }\n\n    @Override\n    public Object getInputSource() {\n        return _inputStream;\n    }\n    \n    \n\n    @Override\n    protected boolean loadMore() throws IOException {\n        _currInputProcessed += _inputEnd;\n        _currInputRowStart -= _inputEnd;\n        \n        if (_inputStream != null) {\n            int count = _inputStream.read(_inputBuffer, 0, _inputBuffer.length);\n            if (count > 0) {\n                _inputPtr = 0;\n                _inputEnd = count;\n                return true;\n            }\n            \n            _closeInput();\n            \n            if (count == 0) {\n                throw new IOException(\"InputStream.read() returned 0 characters when trying to read \"+_inputBuffer.length+\" bytes\");\n            }\n        }\n        return false;\n    }\n\n    \n    protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException {\n        \n        if (_inputStream == null) {\n            return false;\n        }\n        \n        int amount = _inputEnd - _inputPtr;\n        if (amount > 0 && _inputPtr > 0) {\n            _currInputProcessed += _inputPtr;\n            _currInputRowStart -= _inputPtr;\n            System.arraycopy(_inputBuffer, _inputPtr, _inputBuffer, 0, amount);\n            _inputEnd = amount;\n        } else {\n            _inputEnd = 0;\n        }\n        _inputPtr = 0;\n        while (_inputEnd < minAvailable) {\n            int count = _inputStream.read(_inputBuffer, _inputEnd, _inputBuffer.length - _inputEnd);\n            if (count < 1) {\n                \n                _closeInput();\n                \n                if (count == 0) {\n                    throw new IOException(\"InputStream.read() returned 0 characters when trying to read \"+amount+\" bytes\");\n                }\n                return false;\n            }\n            _inputEnd += count;\n        }\n        return true;\n    }\n    \n    @Override\n    protected void _closeInput() throws IOException {\n        \n        if (_inputStream != null) {\n            if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_SOURCE)) {\n                _inputStream.close();\n            }\n            _inputStream = null;\n        }\n    }\n\n    \n    @Override\n    protected void _releaseBuffers() throws IOException {\n        super._releaseBuffers();\n        if (_bufferRecyclable) {\n            byte[] buf = _inputBuffer;\n            if (buf != null) {\n                _inputBuffer = null;\n                _ioContext.releaseReadIOBuffer(buf);\n            }\n        }\n    }\n\n    \n\n    @Override\n    public String getText() throws IOException, JsonParseException {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); \n            }\n            return _textBuffer.contentsAsString();\n        }\n        return _getText2(_currToken);\n    }\n\n    \n    \n    \n    @Override\n    public String getValueAsString() throws IOException, JsonParseException {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); \n            }\n            return _textBuffer.contentsAsString();\n        }\n        return super.getValueAsString(null);\n    }\n    \n    \n    @Override\n    public String getValueAsString(String defValue) throws IOException, JsonParseException {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); \n            }\n            return _textBuffer.contentsAsString();\n        }\n        return super.getValueAsString(defValue);\n    }\n    \n    protected String _getText2(JsonToken t) {\n        if (t == null) {\n            return null;\n        }\n        switch (t) {\n        case FIELD_NAME:\n            return _parsingContext.getCurrentName();\n\n        case VALUE_STRING:\n            \n        case VALUE_NUMBER_INT:\n        case VALUE_NUMBER_FLOAT:\n            return _textBuffer.contentsAsString();\n        default:\n        \treturn t.asString();\n        }\n    }\n\n    @Override\n    public char[] getTextCharacters() throws IOException, JsonParseException {\n        if (_currToken != null) { \n            switch (_currToken) {\n                \n            case FIELD_NAME:\n                if (!_nameCopied) {\n                    String name = _parsingContext.getCurrentName();\n                    int nameLen = name.length();\n                    if (_nameCopyBuffer == null) {\n                        _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen);\n                    } else if (_nameCopyBuffer.length < nameLen) {\n                        _nameCopyBuffer = new char[nameLen];\n                    }\n                    name.getChars(0, nameLen, _nameCopyBuffer, 0);\n                    _nameCopied = true;\n                }\n                return _nameCopyBuffer;\n    \n            case VALUE_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); \n                }\n                \n            case VALUE_NUMBER_INT:\n            case VALUE_NUMBER_FLOAT:\n                return _textBuffer.getTextBuffer();\n                \n            default:\n                return _currToken.asCharArray();\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public int getTextLength() throws IOException, JsonParseException {\n        if (_currToken != null) { \n            switch (_currToken) {\n                \n            case FIELD_NAME:\n                return _parsingContext.getCurrentName().length();\n            case VALUE_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); \n                }\n                \n            case VALUE_NUMBER_INT:\n            case VALUE_NUMBER_FLOAT:\n                return _textBuffer.size();\n                \n            default:\n                return _currToken.asCharArray().length;\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public int getTextOffset() throws IOException, JsonParseException {\n        \n        if (_currToken != null) {\n            switch (_currToken) {\n            case FIELD_NAME:\n                return 0;\n            case VALUE_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); \n                }\n                \n            case VALUE_NUMBER_INT:\n            case VALUE_NUMBER_FLOAT:\n                return _textBuffer.getTextOffset();\n            default:\n            }\n        }\n        return 0;\n    }\n    \n    @Override\n    public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException {\n        if (_currToken != JsonToken.VALUE_STRING &&\n                (_currToken != JsonToken.VALUE_EMBEDDED_OBJECT || _binaryValue == null)) {\n            _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\");\n        }\n        \n        if (_tokenIncomplete) {\n            try {\n                _binaryValue = _decodeBase64(b64variant);\n            } catch (IllegalArgumentException iae) {\n                throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage());\n            }\n            \n            _tokenIncomplete = false;\n        } else { \n            if (_binaryValue == null) {\n                @SuppressWarnings(\"resource\")\n                ByteArrayBuilder builder = _getByteArrayBuilder();\n                _decodeBase64(getText(), builder, b64variant);\n                _binaryValue = builder.toByteArray();\n            }\n        }\n        return _binaryValue;\n    }\n\n    @Override\n    public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException {\n        \n        if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) {\n            byte[] b = getBinaryValue(b64variant);\n            out.write(b);\n            return b.length;\n        }\n        \n        byte[] buf = _ioContext.allocBase64Buffer();\n        try {\n            return _readBinary(b64variant, out, buf);\n        } finally {\n            _ioContext.releaseBase64Buffer(buf);\n        }\n    }\n\n    protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\n        int outputCount = 0;\n\n        while (true) {\n            \n            int ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { \n                if (ch == INT_QUOTE) {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { \n                    continue;\n                }\n            }\n\n            \n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            \n\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            \n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n            bits = b64variant.decodeBase64Char(ch);\n\n            \n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    \n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    \n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++] & 0xFF;\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    \n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            \n            decodedData = (decodedData << 6) | bits;\n            \n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    \n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    \n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            \n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }\n\n    \n\n    \n    @Override\n    public JsonToken nextToken() throws IOException, JsonParseException {\n        _numTypesValid = NR_UNKNOWN;\n        \n        if (_currToken == JsonToken.FIELD_NAME) {\n            return _nextAfterName();\n        }\n        if (_tokenIncomplete) {\n            _skipString(); \n        }\n\n        int i = _skipWSOrEnd();\n        if (i < 0) { \n            \n            close();\n            return (_currToken = null);\n        }\n\n        \n        _tokenInputTotal = _currInputProcessed + _inputPtr - 1;\n        _tokenInputRow = _currInputRow;\n        _tokenInputCol = _inputPtr - _currInputRowStart - 1;\n\n        \n        _binaryValue = null;\n\n        \n        if (i == INT_RBRACKET) {\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.getParent();\n            return (_currToken = JsonToken.END_ARRAY);\n        }\n        if (i == INT_RCURLY) {\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.getParent();\n            return (_currToken = JsonToken.END_OBJECT);\n        }\n\n        \n        if (_parsingContext.expectComma()) {\n            if (i != INT_COMMA) {\n                _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\");\n            }\n            i = _skipWS();\n        }\n\n        \n        if (!_parsingContext.inObject()) {\n            return _nextTokenNotInObject(i);\n        }\n        \n        Name n = _parseFieldName(i);\n        _parsingContext.setCurrentName(n.getName());\n        _currToken = JsonToken.FIELD_NAME;\n\n        \n        if (_inputPtr < _inputEnd && _inputBuffer[_inputPtr] == ':') {\n            ++_inputPtr;\n        } else {\n            i = _skipWS();\n            if (i != INT_COLON) {\n                _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");\n            }\n        }\n        i = _skipWS();\n\n        \n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return _currToken;\n        }        \n        JsonToken t;\n\n        switch (i) {\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        case ']':\n        case '}':\n            \n            \n            _reportUnexpectedChar(i, \"expected a value\");\n        case 't':\n            _matchToken(\"true\", 1);\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchToken(\"false\", 1);\n             t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchToken(\"null\", 1);\n            t = JsonToken.VALUE_NULL;\n            break;\n\n        case '-':\n            \n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parseNumber(i);\n            break;\n        default:\n            t = _handleUnexpectedValue(i);\n        }\n        _nextToken = t;\n        return _currToken;\n    }\n\n    private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException {\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            return (_currToken = JsonToken.VALUE_STRING);\n        }\n        switch (i) {\n        case '[':\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            return (_currToken = JsonToken.START_ARRAY);\n        case '{':\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            return (_currToken = JsonToken.START_OBJECT);\n        case ']':\n        case '}':\n            \n            \n            _reportUnexpectedChar(i, \"expected a value\");\n        case 't':\n            _matchToken(\"true\", 1);\n            return (_currToken = JsonToken.VALUE_TRUE);\n        case 'f':\n            _matchToken(\"false\", 1);\n            return (_currToken = JsonToken.VALUE_FALSE);\n        case 'n':\n            _matchToken(\"null\", 1);\n            return (_currToken = JsonToken.VALUE_NULL);\n        case '-':\n            \n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            return (_currToken = _parseNumber(i));\n        }\n        return (_currToken = _handleUnexpectedValue(i));\n    }\n    \n    private JsonToken _nextAfterName() {\n        _nameCopied = false; \n        JsonToken t = _nextToken;\n        _nextToken = null;\n        \n        if (t == JsonToken.START_ARRAY) {\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n        } else if (t == JsonToken.START_OBJECT) {\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n        }\n        return (_currToken = t);\n    }\n\n    @Override\n    public void close() throws IOException {\n        super.close();\n        \n        _symbols.release();\n    }\n    \n    \n    \n    @Override\n    public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException {\n        \n        \n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) { \n            _nextAfterName();\n            return false;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) { \n            close();\n            _currToken = null;\n            return false;\n        }\n        _tokenInputTotal = _currInputProcessed + _inputPtr - 1;\n        _tokenInputRow = _currInputRow;\n        _tokenInputCol = _inputPtr - _currInputRowStart - 1;\n\n        \n        _binaryValue = null;\n\n        \n        if (i == INT_RBRACKET) {\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.getParent();\n            _currToken = JsonToken.END_ARRAY;\n            return false;\n        }\n        if (i == INT_RCURLY) {\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.getParent();\n            _currToken = JsonToken.END_OBJECT;\n            return false;\n        }\n\n        \n        if (_parsingContext.expectComma()) {\n            if (i != INT_COMMA) {\n                _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\");\n            }\n            i = _skipWS();\n        }\n\n        if (!_parsingContext.inObject()) {\n            _nextTokenNotInObject(i);\n            return false;\n        }\n        \n        \n        if (i == INT_QUOTE) {\n            \n            byte[] nameBytes = str.asQuotedUTF8();\n            final int len = nameBytes.length;\n            if ((_inputPtr + len) < _inputEnd) { \n                \n                final int end = _inputPtr+len;\n                if (_inputBuffer[end] == INT_QUOTE) {\n                    int offset = 0;\n                    final int ptr = _inputPtr;\n                    while (true) {\n                        if (offset == len) { \n                            _inputPtr = end+1; \n                            \n                            _parsingContext.setCurrentName(str.getValue());\n                            _currToken = JsonToken.FIELD_NAME;\n                            \n                            _isNextTokenNameYes();\n                            return true;\n                        }\n                        if (nameBytes[offset] != _inputBuffer[ptr+offset]) {\n                            break;\n                        }\n                        ++offset;\n                    }\n                }\n            }\n        }\n        return _isNextTokenNameMaybe(i, str);\n    }\n\n    private void _isNextTokenNameYes() throws IOException, JsonParseException {\n        \n        int i;\n        if (_inputPtr < (_inputEnd-1) && _inputBuffer[_inputPtr] == INT_COLON) { \n            i = _inputBuffer[++_inputPtr];\n            ++_inputPtr;\n            if (i == INT_QUOTE) {\n                _tokenIncomplete = true;\n                _nextToken = JsonToken.VALUE_STRING;\n                return;\n            }\n            if (i == INT_LCURLY) {\n                _nextToken = JsonToken.START_OBJECT;\n                return;\n            }\n            if (i == INT_LBRACKET) {\n                _nextToken = JsonToken.START_ARRAY;\n                return;\n            }\n            i &= 0xFF;\n            if (i <= INT_SPACE || i == INT_SLASH) {\n            \t--_inputPtr;\n                i = _skipWS();\n            }\n        } else {\n            i = _skipColon();\n        }\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return;\n        case '[':\n            _nextToken = JsonToken.START_ARRAY;\n            return;\n        case '{':\n            _nextToken = JsonToken.START_OBJECT;\n            return;\n        case ']':\n        case '}':\n            _reportUnexpectedChar(i, \"expected a value\");\n        case 't':\n            _matchToken(\"true\", 1);\n            _nextToken = JsonToken.VALUE_TRUE;\n            return;\n        case 'f':\n            _matchToken(\"false\", 1);\n            _nextToken = JsonToken.VALUE_FALSE;\n            return;\n        case 'n':\n            _matchToken(\"null\", 1);\n            _nextToken = JsonToken.VALUE_NULL;\n            return;\n        case '-':\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            _nextToken = _parseNumber(i);\n            return;\n        }\n        _nextToken = _handleUnexpectedValue(i);\n    }\n    \n    private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException {\n        \n            \n        Name n = _parseFieldName(i);\n        final boolean match;\n        {\n            String nameStr = n.getName();\n            _parsingContext.setCurrentName(nameStr);\n            match = nameStr.equals(str.getValue());\n        }\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipWS();\n        if (i != INT_COLON) {\n            _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");\n        }\n        i = _skipWS();\n\n        \n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return match;\n        }\n        JsonToken t;\n\n        switch (i) {\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        case ']':\n        case '}':\n            _reportUnexpectedChar(i, \"expected a value\");\n        case 't':\n            _matchToken(\"true\", 1);\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchToken(\"false\", 1);\n             t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchToken(\"null\", 1);\n            t = JsonToken.VALUE_NULL;\n            break;\n\n        case '-':\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n\n            t = _parseNumber(i);\n            break;\n        default:\n            t = _handleUnexpectedValue(i);\n        }\n        _nextToken = t;\n        return match;\n    }\n\n    @Override\n    public String nextTextValue() throws IOException, JsonParseException {\n        \n        if (_currToken == JsonToken.FIELD_NAME) { \n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_STRING) {\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString();\n                }\n                return _textBuffer.contentsAsString();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        \n        return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;\n    }\n\n    @Override\n    public int nextIntValue(int defaultValue) throws IOException, JsonParseException {\n        \n        if (_currToken == JsonToken.FIELD_NAME) { \n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getIntValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        \n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;\n    }\n\n    @Override\n    public long nextLongValue(long defaultValue) throws IOException, JsonParseException {\n        \n        if (_currToken == JsonToken.FIELD_NAME) { \n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getLongValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        \n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;\n    }\n\n    @Override\n    public Boolean nextBooleanValue() throws IOException, JsonParseException {\n        \n        if (_currToken == JsonToken.FIELD_NAME) { \n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_TRUE) {\n                return Boolean.TRUE;\n            }\n            if (t == JsonToken.VALUE_FALSE) {\n                return Boolean.FALSE;\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        switch (nextToken()) {\n        case VALUE_TRUE:\n            return Boolean.TRUE;\n        case VALUE_FALSE:\n            return Boolean.FALSE;\n        default:\n        \treturn null;\n        }\n    }\n    \n    \n\n    \n    protected JsonToken _parseNumber(int c) throws IOException, JsonParseException {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        \n        if (negative) {\n            outBuf[outPtr++] = '-';\n            \n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            \n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        \n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        \n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        \n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        \n        while (true) {\n            if (_inputPtr >= end) {\n                \n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloat(outBuf, outPtr, c, negative, intLen);\n        }\n        \n        --_inputPtr; \n        _textBuffer.setCurrentLength(outPtr);\n        \n\n        \n        return resetInt(negative, intLen);\n    }\n    \n    \n    private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException {\n        \n        while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                _textBuffer.setCurrentLength(outPtr);\n                return resetInt(negative, intPartLength);\n            }\n            int c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c > INT_9 || c < INT_0) {\n                if (c == '.' || c == 'e' || c == 'E') {\n                    return _parseFloat(outBuf, outPtr, c, negative, intPartLength);\n                }\n                break;\n            }\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            ++intPartLength;\n        }\n        --_inputPtr; \n        _textBuffer.setCurrentLength(outPtr);\n        \n\n        \n        return resetInt(negative, intPartLength);\n        \n    }\n    \n    \n    private int _verifyNoLeadingZeroes() throws IOException, JsonParseException {\n        \n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            return INT_0;\n        }\n        int ch = _inputBuffer[_inputPtr] & 0xFF;\n        \n        if (ch < INT_0 || ch > INT_9) {\n            return INT_0;\n        }\n        \n        if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) {\n            reportInvalidNumber(\"Leading zeroes not allowed\");\n        }\n        \n        ++_inputPtr; \n        if (ch == INT_0) {\n            while (_inputPtr < _inputEnd || loadMore()) {\n                ch = _inputBuffer[_inputPtr] & 0xFF;\n                if (ch < INT_0 || ch > INT_9) { \n                    return INT_0;\n                }\n                ++_inputPtr; \n                if (ch != INT_0) { \n                    break;\n                }\n            }\n        }\n        return ch;\n    }\n    \n    private JsonToken _parseFloat(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException {\n        int fractLen = 0;\n        boolean eof = false;\n\n        \n        if (c == '.') { \n            outBuf[outPtr++] = (char) c;\n\n            fract_loop:\n            while (true) {\n                if (_inputPtr >= _inputEnd && !loadMore()) {\n                    eof = true;\n                    break fract_loop;\n                }\n                c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n                if (c < INT_0 || c > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = (char) c;\n            }\n            \n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n            }\n        }\n\n        int expLen = 0;\n        if (c == 'e' || c == 'E') { \n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            \n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            \n            if (c == '-' || c == '+') {\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = (char) c;\n                \n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            }\n\n            exp_loop:\n            while (c <= INT_9 && c >= INT_0) {\n                ++expLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = (char) c;\n                if (_inputPtr >= _inputEnd && !loadMore()) {\n                    eof = true;\n                    break exp_loop;\n                }\n                c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            }\n            \n            if (expLen == 0) {\n                reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n            }\n        }\n\n        \n        if (!eof) {\n            --_inputPtr;\n            \n        }\n        _textBuffer.setCurrentLength(outPtr);\n\n        \n        return resetFloat(negative, integerPartLength, fractLen, expLen);\n    }\n\n    \n        \n        \n\n    \n    \n    protected Name _parseFieldName(int i) throws IOException, JsonParseException {\n        if (i != INT_QUOTE) {\n            return _handleOddName(i);\n        }\n        \n        if ((_inputPtr + 9) > _inputEnd) { \n            return slowParseName();\n        }\n\n        \n        \n        final byte[] input = _inputBuffer;\n        final int[] codes = _icLatin1;\n\n        int q = input[_inputPtr++] & 0xFF;\n\n        if (codes[q] == 0) {\n            i = input[_inputPtr++] & 0xFF;\n            if (codes[i] == 0) {\n                q = (q << 8) | i;\n                i = input[_inputPtr++] & 0xFF;\n                if (codes[i] == 0) {\n                    q = (q << 8) | i;\n                    i = input[_inputPtr++] & 0xFF;\n                    if (codes[i] == 0) {\n                        q = (q << 8) | i;\n                        i = input[_inputPtr++] & 0xFF;\n                        if (codes[i] == 0) {\n                            _quad1 = q;\n                            return parseMediumName(i, codes);\n                        }\n                        if (i == INT_QUOTE) { \n                            return findName(q, 4);\n                        }\n                        return parseName(q, i, 4);\n                    }\n                    if (i == INT_QUOTE) { \n                        return findName(q, 3);\n                    }\n                    return parseName(q, i, 3);\n                }                \n                if (i == INT_QUOTE) { \n                    return findName(q, 2);\n                }\n                return parseName(q, i, 2);\n            }\n            if (i == INT_QUOTE) { \n                return findName(q, 1);\n            }\n            return parseName(q, i, 1);\n        }     \n        if (q == INT_QUOTE) { \n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        return parseName(0, q, 0); \n    }\n\n    protected Name parseMediumName(int q2, final int[] codes) throws IOException, JsonParseException {\n        \n        int i = _inputBuffer[_inputPtr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { \n                return findName(_quad1, q2, 1);\n            }\n            return parseName(_quad1, q2, i, 1); \n        }\n        q2 = (q2 << 8) | i;\n        i = _inputBuffer[_inputPtr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { \n                return findName(_quad1, q2, 2);\n            }\n            return parseName(_quad1, q2, i, 2);\n        }\n        q2 = (q2 << 8) | i;\n        i = _inputBuffer[_inputPtr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { \n                return findName(_quad1, q2, 3);\n            }\n            return parseName(_quad1, q2, i, 3);\n        }\n        q2 = (q2 << 8) | i;\n        i = _inputBuffer[_inputPtr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { \n                return findName(_quad1, q2, 4);\n            }\n            return parseName(_quad1, q2, i, 4);\n        }\n        _quadBuffer[0] = _quad1;\n        _quadBuffer[1] = q2;\n        return parseLongName(i);\n    }\n\n    protected Name parseLongName(int q) throws IOException, JsonParseException {\n        \n        final int[] codes = _icLatin1;\n        int qlen = 2;\n\n        while (true) {\n            \n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedName(_quadBuffer, qlen, 0, q, 0);\n            }\n            \n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 2);\n                }\n                return parseEscapedName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            \n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }\n\n    \n    protected Name slowParseName() throws IOException, JsonParseException {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\\"' for name\");\n            }\n        }\n        int i = _inputBuffer[_inputPtr++] & 0xFF;\n        if (i == INT_QUOTE) { \n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        return parseEscapedName(_quadBuffer, 0, 0, i, 0);\n    }\n\n    private Name parseName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException {\n        return parseEscapedName(_quadBuffer, 0, q1, ch, lastQuadBytes);\n    }\n\n    private Name parseName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException {\n        _quadBuffer[0] = q1;\n        return parseEscapedName(_quadBuffer, 1, q2, ch, lastQuadBytes);\n    }\n\n    \n    protected Name parseEscapedName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException {\n        \n        final int[] codes = _icLatin1;\n\n        while (true) {\n            if (codes[ch] != 0) {\n                if (ch == INT_QUOTE) { \n                    break;\n                }\n                \n                if (ch != INT_BACKSLASH) {\n                    \n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    \n                    ch = _decodeEscaped();\n                }\n                \n                if (ch > 127) {\n                    \n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { \n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        \n                    } else { \n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        \n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    \n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            \n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }\n\n    \n    protected Name _handleOddName(int ch) throws IOException, JsonParseException {\n        \n        if (ch == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n            return _parseAposName();\n        }\n        \n        if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {\n            _reportUnexpectedChar(ch, \"was expecting double-quote to start field name\");\n        }\n        \n        final int[] codes = CharTypes.getInputCodeUtf8JsNames();\n        \n        if (codes[ch] != 0) {\n            _reportUnexpectedChar(ch, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\");\n        }\n\n        \n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        while (true) {\n            \n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\n            ch = _inputBuffer[_inputPtr] & 0xFF;\n            if (codes[ch] != 0) {\n                break;\n            }\n            ++_inputPtr;\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }\n\n    \n    protected Name _parseAposName() throws IOException, JsonParseException {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == '\\'') { \n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        \n\n        final int[] codes = _icLatin1;\n\n        while (true) {\n            if (ch == '\\'') {\n                break;\n            }\n            \n            if (ch != '\"' && codes[ch] != 0) {\n                if (ch != '\\\\') {\n                    \n                    \n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    \n                    ch = _decodeEscaped();\n                }\n                \n                if (ch > 127) {\n                    \n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { \n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        \n                    } else { \n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        \n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    \n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            \n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }\n\n    \n\n    private Name findName(int q1, int lastQuadBytes) throws JsonParseException {\n        \n        Name name = _symbols.findName(q1);\n        if (name != null) {\n            return name;\n        }\n        \n        _quadBuffer[0] = q1;\n        return addName(_quadBuffer, 1, lastQuadBytes);\n    }\n\n    private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException {\n        \n        Name name = _symbols.findName(q1, q2);\n        if (name != null) {\n            return name;\n        }\n        \n        _quadBuffer[0] = q1;\n        _quadBuffer[1] = q2;\n        return addName(_quadBuffer, 2, lastQuadBytes);\n    }\n\n    private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException {\n        if (qlen >= quads.length) {\n            _quadBuffer = quads = growArrayBy(quads, quads.length);\n        }\n        quads[qlen++] = lastQuad;\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            return addName(quads, qlen, lastQuadBytes);\n        }\n        return name;\n    }\n\n    \n    private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException {\n        \n        \n        int byteLen = (qlen << 2) - 4 + lastQuadBytes;\n\n        \n        int lastQuad;\n\n        if (lastQuadBytes < 4) {\n            lastQuad = quads[qlen-1];\n            \n            quads[qlen-1] = (lastQuad << ((4 - lastQuadBytes) << 3));\n        } else {\n            lastQuad = 0;\n        }\n\n        \n        char[] cbuf = _textBuffer.emptyAndGetCurrentSegment();\n        int cix = 0;\n\n        for (int ix = 0; ix < byteLen; ) {\n            int ch = quads[ix >> 2]; \n            int byteIx = (ix & 3);\n            ch = (ch >> ((3 - byteIx) << 3)) & 0xFF;\n            ++ix;\n\n            if (ch > 127) { \n                int needed;\n                if ((ch & 0xE0) == 0xC0) { \n                    ch &= 0x1F;\n                    needed = 1;\n                } else if ((ch & 0xF0) == 0xE0) { \n                    ch &= 0x0F;\n                    needed = 2;\n                } else if ((ch & 0xF8) == 0xF0) { \n                    ch &= 0x07;\n                    needed = 3;\n                } else { \n                    _reportInvalidInitial(ch);\n                    needed = ch = 1; \n                }\n                if ((ix + needed) > byteLen) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n                \n                \n                int ch2 = quads[ix >> 2]; \n                byteIx = (ix & 3);\n                ch2 = (ch2 >> ((3 - byteIx) << 3));\n                ++ix;\n                \n                if ((ch2 & 0xC0) != 0x080) {\n                    _reportInvalidOther(ch2);\n                }\n                ch = (ch << 6) | (ch2 & 0x3F);\n                if (needed > 1) {\n                    ch2 = quads[ix >> 2];\n                    byteIx = (ix & 3);\n                    ch2 = (ch2 >> ((3 - byteIx) << 3));\n                    ++ix;\n                    \n                    if ((ch2 & 0xC0) != 0x080) {\n                        _reportInvalidOther(ch2);\n                    }\n                    ch = (ch << 6) | (ch2 & 0x3F);\n                    if (needed > 2) { \n                        ch2 = quads[ix >> 2];\n                        byteIx = (ix & 3);\n                        ch2 = (ch2 >> ((3 - byteIx) << 3));\n                        ++ix;\n                        if ((ch2 & 0xC0) != 0x080) {\n                            _reportInvalidOther(ch2 & 0xFF);\n                        }\n                        ch = (ch << 6) | (ch2 & 0x3F);\n                    }\n                }\n                if (needed > 2) { \n                    ch -= 0x10000; \n                    if (cix >= cbuf.length) {\n                        cbuf = _textBuffer.expandCurrentSegment();\n                    }\n                    cbuf[cix++] = (char) (0xD800 + (ch >> 10));\n                    ch = 0xDC00 | (ch & 0x03FF);\n                }\n            }\n            if (cix >= cbuf.length) {\n                cbuf = _textBuffer.expandCurrentSegment();\n            }\n            cbuf[cix++] = (char) ch;\n        }\n\n        \n        String baseName = new String(cbuf, 0, cix);\n        \n        if (lastQuadBytes < 4) {\n            quads[qlen-1] = lastQuad;\n        }\n        return _symbols.addName(baseName, quads, qlen);\n    }\n\n    \n\n    @Override\n    protected void _finishString() throws IOException {\n        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = _icUTF8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\n            int c = (int) inputBuffer[ptr] & 0xFF;\n            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }\n\n    private void _finishString2(char[] outBuf, int outPtr) throws IOException {\n        int c;\n\n        \n        final int[] codes = _icUTF8;\n        final byte[] inputBuffer = _inputBuffer;\n\n        main_loop:\n        while (true) {\n            \n            ascii_loop:\n            while (true) {\n                int ptr = _inputPtr;\n                if (ptr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                    ptr = _inputPtr;\n                }\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                final int max = Math.min(_inputEnd, (ptr + (outBuf.length - outPtr)));\n                while (ptr < max) {\n                    c = (int) inputBuffer[ptr++] & 0xFF;\n                    if (codes[c] != 0) {\n                        _inputPtr = ptr;\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (char) c;\n                }\n                _inputPtr = ptr;\n            }\n            \n            if (c == INT_QUOTE) {\n                break main_loop;\n            }\n\n            switch (codes[c]) {\n            case 1: \n                c = _decodeEscaped();\n                break;\n            case 2: \n                c = _decodeUtf8_2(c);\n                break;\n            case 3: \n                if ((_inputEnd - _inputPtr) >= 2) {\n                    c = _decodeUtf8_3fast(c);\n                } else {\n                    c = _decodeUtf8_3(c);\n                }\n                break;\n            case 4: \n                c = _decodeUtf8_4(c);\n                \n                outBuf[outPtr++] = (char) (0xD800 | (c >> 10));\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                c = 0xDC00 | (c & 0x3FF);\n                \n                break;\n            default:\n                if (c < INT_SPACE) {\n                    \n                    _throwUnquotedSpace(c, \"string value\");\n                } else {\n                    \n                    _reportInvalidChar(c);\n                }\n            }\n            \n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            \n            outBuf[outPtr++] = (char) c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n    }\n\n    \n    protected void _skipString() throws IOException {\n        _tokenIncomplete = false;\n\n        \n        final int[] codes = _icUTF8;\n        final byte[] inputBuffer = _inputBuffer;\n\n        main_loop:\n        while (true) {\n            int c;\n\n            ascii_loop:\n            while (true) {\n                int ptr = _inputPtr;\n                int max = _inputEnd;\n                if (ptr >= max) {\n                    loadMoreGuaranteed();\n                    ptr = _inputPtr;\n                    max = _inputEnd;\n                }\n                while (ptr < max) {\n                    c = (int) inputBuffer[ptr++] & 0xFF;\n                    if (codes[c] != 0) {\n                        _inputPtr = ptr;\n                        break ascii_loop;\n                    }\n                }\n                _inputPtr = ptr;\n            }\n            \n            if (c == INT_QUOTE) {\n                break main_loop;\n            }\n            \n            switch (codes[c]) {\n            case 1: \n                _decodeEscaped();\n                break;\n            case 2: \n                _skipUtf8_2(c);\n                break;\n            case 3: \n                _skipUtf8_3(c);\n                break;\n            case 4: \n                _skipUtf8_4(c);\n                break;\n            default:\n                if (c < INT_SPACE) {\n                    \n                    _throwUnquotedSpace(c, \"string value\");\n                } else {\n                    \n                    _reportInvalidChar(c);\n                }\n            }\n        }\n    }\n\n    \n    protected JsonToken _handleUnexpectedValue(int c) throws IOException {\n        \n        switch (c) {\n        case '\\'':\n            if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n                return _handleApos();\n            }\n            break;\n        case 'N':\n            _matchToken(\"NaN\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"NaN\", Double.NaN);\n            }\n            _reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case 'I':\n            _matchToken(\"Infinity\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY);\n            }\n            _reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case '+': \n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOFInValue();\n                }\n            }\n            return _handleInvalidNumberStart(_inputBuffer[_inputPtr++] & 0xFF, false);\n        }\n        \n        if (Character.isJavaIdentifierStart(c)) {\n            _reportInvalidToken(\"\"+((char) c), \"('true', 'false' or 'null')\");\n        }\n        \n        _reportUnexpectedChar(c, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\n        return null;\n    }\n\n    protected JsonToken _handleApos() throws IOException {\n        int c = 0;\n        \n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n\n        \n        final int[] codes = _icUTF8;\n        final byte[] inputBuffer = _inputBuffer;\n\n        main_loop:\n        while (true) {\n            \n            ascii_loop:\n            while (true) {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                int max = _inputEnd;\n                {\n                    int max2 = _inputPtr + (outBuf.length - outPtr);\n                    if (max2 < max) {\n                        max = max2;\n                    }\n                }\n                while (_inputPtr < max) {\n                    c = (int) inputBuffer[_inputPtr++] & 0xFF;\n                    if (c == '\\'' || codes[c] != 0) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (char) c;\n                }\n            }\n\n            \n            if (c == '\\'') {\n                break main_loop;\n            }\n\n            switch (codes[c]) {\n            case 1: \n                if (c != '\\'') { \n                    c = _decodeEscaped();\n                }\n                break;\n            case 2: \n                c = _decodeUtf8_2(c);\n                break;\n            case 3: \n                if ((_inputEnd - _inputPtr) >= 2) {\n                    c = _decodeUtf8_3fast(c);\n                } else {\n                    c = _decodeUtf8_3(c);\n                }\n                break;\n            case 4: \n                c = _decodeUtf8_4(c);\n                \n                outBuf[outPtr++] = (char) (0xD800 | (c >> 10));\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                c = 0xDC00 | (c & 0x3FF);\n                \n                break;\n            default:\n                if (c < INT_SPACE) {\n                    _throwUnquotedSpace(c, \"string value\");\n                }\n                \n                _reportInvalidChar(c);\n            }\n            \n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            \n            outBuf[outPtr++] = (char) c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n\n        return JsonToken.VALUE_STRING;\n    }\n    \n    \n    protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException {\n        while (ch == 'I') {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOFInValue();\n                }\n            }\n            ch = _inputBuffer[_inputPtr++];\n            String match;\n            if (ch == 'N') {\n                match = neg ? \"-INF\" :\"+INF\";\n            } else if (ch == 'n') {\n                match = neg ? \"-Infinity\" :\"+Infinity\";\n            } else {\n                break;\n            }\n            _matchToken(match, 3);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(match, neg ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n            }\n            _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n        }\n        reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        return null;\n    }\n\n    protected void _matchToken(String matchStr, int i) throws IOException {\n        final int len = matchStr.length();\n    \n        do {\n            if (((_inputPtr >= _inputEnd) && !loadMore())\n                ||  (_inputBuffer[_inputPtr] != matchStr.charAt(i))) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n    \n        \n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            return;\n        }\n        int ch = _inputBuffer[_inputPtr] & 0xFF;\n        if (ch < '0' || ch == ']' || ch == '}') { \n            return;\n        }\n        \n        char c = (char) _decodeCharForError(ch);\n        if (Character.isJavaIdentifierPart(c)) {\n            _reportInvalidToken(matchStr.substring(0, i));\n        }\n    }\n\n    protected void _reportInvalidToken(String matchedPart) throws IOException {\n        _reportInvalidToken(matchedPart, \"'null', 'true', 'false' or NaN\");\n    }\n    \n    protected void _reportInvalidToken(String matchedPart, String msg) throws IOException {\n        StringBuilder sb = new StringBuilder(matchedPart);\n\n        \n        while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                break;\n            }\n            int i = (int) _inputBuffer[_inputPtr++];\n            char c = (char) _decodeCharForError(i);\n            if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            sb.append(c);\n        }\n        _reportError(\"Unrecognized token '\"+sb.toString()+\"': was expecting \"+msg);\n    }\n\n    \n    \n    private final int _skipWS() throws IOException {\n        final int[] codes = _icWS;\n        while (_inputPtr < _inputEnd || loadMore()) {\n            final int i = _inputBuffer[_inputPtr++] & 0xFF;\n            switch (codes[i]) {\n            case 0: \n                return i;\n            case 1: \n                continue;\n            case 2: \n                _skipUtf8_2(i);\n                break;\n            case 3: \n                _skipUtf8_3(i);\n                break;\n            case 4: \n                _skipUtf8_4(i);\n                break;\n            case INT_LF:\n                ++_currInputRow;\n                _currInputRowStart = _inputPtr;\n                break;\n            case INT_CR:\n                _skipCR();\n                break;\n            case '/':\n                _skipComment();\n                break;\n            case '#':\n                if (!_skipYAMLComment()) {\n                    return i;\n                }\n                break;\n            default: \n                \n                if (i < 32) {\n                    _throwInvalidSpace(i);\n                }\n                _reportInvalidChar(i);\n            }\n        }\n        throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\");\n    }\n\n    private int _skipWSOrEnd() throws IOException {\n        final int[] codes = _icWS;\n        while ((_inputPtr < _inputEnd) || loadMore()) {\n            final int i = _inputBuffer[_inputPtr++] & 0xFF;\n            switch (codes[i]) {\n            case 0: \n                return i;\n            case 1: \n                continue;\n            case 2: \n                _skipUtf8_2(i);\n                break;\n            case 3: \n                _skipUtf8_3(i);\n                break;\n            case 4: \n                _skipUtf8_4(i);\n                break;\n            case INT_LF:\n                ++_currInputRow;\n                _currInputRowStart = _inputPtr;\n                break;\n            case INT_CR:\n                _skipCR();\n                break;\n            case '/':\n                _skipComment();\n                break;\n            case '#':\n                if (!_skipYAMLComment()) {\n                    return i;\n                }\n                break;\n            default: \n                if (i < 32) {\n                    _throwInvalidSpace(i);\n                }\n                _reportInvalidChar(i);\n            }\n        }\n        \n        _handleEOF();\n        return -1;\n    }\n\n    \n    private int _skipColon() throws IOException {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        \n        int i = _inputBuffer[_inputPtr++];\n        if (i == INT_COLON) {\n            if (_inputPtr < _inputEnd) {\n                i = _inputBuffer[_inputPtr] & 0xFF;\n                if (i > INT_SPACE && i != INT_SLASH) {\n                    ++_inputPtr;\n                    return i;\n                }\n            }\n        } else {\n            \n            i &= 0xFF;\n            \n            space_loop:\n            while (true) {\n                switch (i) {\n                case ' ':\n                case '\\t':\n                    break;\n                case INT_CR:\n                    _skipCR();\n                    break;\n                case INT_LF:\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                case '/':\n                    _skipComment();\n                    break;\n                default:\n                    if (i < INT_SPACE) {\n                        _throwInvalidSpace(i);\n                    }\n                    break space_loop;\n                }\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                i = _inputBuffer[_inputPtr++] & 0xFF;\n            }\n            if (i != INT_COLON) {\n                _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");\n            }\n        }\n\n            \n        while (_inputPtr < _inputEnd || loadMore()) {\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (i > INT_SPACE) {\n                if (i != INT_SLASH) {\n                    return i;\n                }\n                _skipComment();\n            } else if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\");\n    }\n    \n    private void _skipComment() throws IOException {\n        if (!isEnabled(Feature.ALLOW_COMMENTS)) {\n            _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\");\n        }\n        \n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            _reportInvalidEOF(\" in a comment\");\n        }\n        int c = _inputBuffer[_inputPtr++] & 0xFF;\n        if (c == '/') {\n            _skipLine();\n        } else if (c == '*') {\n            _skipCComment();\n        } else {\n            _reportUnexpectedChar(c, \"was expecting either '*' or '/' for a comment\");\n        }\n    }\n\n    private void _skipCComment() throws IOException {\n        \n        final int[] codes = CharTypes.getInputCodeComment();\n\n        \n        main_loop:\n        while ((_inputPtr < _inputEnd) || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            int code = codes[i];\n            if (code != 0) {\n                switch (code) {\n                case '*':\n                    if (_inputPtr >= _inputEnd && !loadMore()) {\n                        break main_loop;\n                    }\n                    if (_inputBuffer[_inputPtr] == INT_SLASH) {\n                        ++_inputPtr;\n                        return;\n                    }\n                    break;\n                case INT_LF:\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                case INT_CR:\n                    _skipCR();\n                    break;\n                case 2: \n                    _skipUtf8_2(i);\n                    break;\n                case 3: \n                    _skipUtf8_3(i);\n                    break;\n                case 4: \n                    _skipUtf8_4(i);\n                    break;\n                default: \n                    \n                    _reportInvalidChar(i);\n                }\n            }\n        }\n        _reportInvalidEOF(\" in a comment\");\n    }\n\n    private boolean _skipYAMLComment() throws IOException {\n        if (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) {\n            return false;\n        }\n        _skipLine();\n        return true;\n    }\n\n    \n    private void _skipLine() throws IOException {\n        \n        final int[] codes = CharTypes.getInputCodeComment();\n        while ((_inputPtr < _inputEnd) || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            int code = codes[i];\n            if (code != 0) {\n                switch (code) {\n                case INT_LF:\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    return;\n                case INT_CR:\n                    _skipCR();\n                    return;\n                case '*': \n                    break;\n                case 2: \n                    _skipUtf8_2(i);\n                    break;\n                case 3: \n                    _skipUtf8_3(i);\n                    break;\n                case 4: \n                    _skipUtf8_4(i);\n                    break;\n                default: \n                    if (code < 0) {\n                        \n                        _reportInvalidChar(i);\n                    }\n                }\n            }\n        }\n    }\n    \n    @Override\n    protected char _decodeEscaped() throws IOException {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\" in character escape sequence\");\n            }\n        }\n        int c = (int) _inputBuffer[_inputPtr++];\n\n        switch ((int) c) {\n            \n        case 'b':\n            return '\\b';\n        case 't':\n            return '\\t';\n        case 'n':\n            return '\\n';\n        case 'f':\n            return '\\f';\n        case 'r':\n            return '\\r';\n\n            \n        case '\"':\n        case '/':\n        case '\\\\':\n            return (char) c;\n\n        case 'u': \n            break;\n\n        default:\n            return _handleUnrecognizedCharacterEscape((char) _decodeCharForError(c));\n        }\n\n        \n        int value = 0;\n        for (int i = 0; i < 4; ++i) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in character escape sequence\");\n                }\n            }\n            int ch = (int) _inputBuffer[_inputPtr++];\n            int digit = CharTypes.charToHex(ch);\n            if (digit < 0) {\n                _reportUnexpectedChar(ch, \"expected a hex-digit for character escape sequence\");\n            }\n            value = (value << 4) | digit;\n        }\n        return (char) value;\n    }\n\n    protected int _decodeCharForError(int firstByte) throws IOException {\n        int c = (int) firstByte;\n        if (c < 0) { \n            int needed;\n            \n            \n            if ((c & 0xE0) == 0xC0) { \n                c &= 0x1F;\n                needed = 1;\n            } else if ((c & 0xF0) == 0xE0) { \n                c &= 0x0F;\n                needed = 2;\n            } else if ((c & 0xF8) == 0xF0) {\n                \n                c &= 0x07;\n                needed = 3;\n            } else {\n                _reportInvalidInitial(c & 0xFF);\n                needed = 1; \n            }\n\n            int d = nextByte();\n            if ((d & 0xC0) != 0x080) {\n                _reportInvalidOther(d & 0xFF);\n            }\n            c = (c << 6) | (d & 0x3F);\n            \n            if (needed > 1) { \n                d = nextByte(); \n                if ((d & 0xC0) != 0x080) {\n                    _reportInvalidOther(d & 0xFF);\n                }\n                c = (c << 6) | (d & 0x3F);\n                if (needed > 2) { \n                    d = nextByte();\n                    if ((d & 0xC0) != 0x080) {\n                        _reportInvalidOther(d & 0xFF);\n                    }\n                    c = (c << 6) | (d & 0x3F);\n                }\n            }\n        }\n        return c;\n    }\n\n    \n\n    private int _decodeUtf8_2(int c) throws IOException {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        int d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        return ((c & 0x1F) << 6) | (d & 0x3F);\n    }\n\n    private int _decodeUtf8_3(int c1) throws IOException {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        c1 &= 0x0F;\n        int d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        int c = (c1 << 6) | (d & 0x3F);\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        c = (c << 6) | (d & 0x3F);\n        return c;\n    }\n\n    private int _decodeUtf8_3fast(int c1) throws IOException {\n        c1 &= 0x0F;\n        int d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        int c = (c1 << 6) | (d & 0x3F);\n        d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        c = (c << 6) | (d & 0x3F);\n        return c;\n    }\n\n    \n    private int _decodeUtf8_4(int c) throws IOException {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        int d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        c = ((c & 0x07) << 6) | (d & 0x3F);\n\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        c = (c << 6) | (d & 0x3F);\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n\n        \n        return ((c << 6) | (d & 0x3F)) - 0x10000;\n    }\n\n    private void _skipUtf8_2(int c) throws IOException {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        c = (int) _inputBuffer[_inputPtr++];\n        if ((c & 0xC0) != 0x080) {\n            _reportInvalidOther(c & 0xFF, _inputPtr);\n        }\n    }\n\n    \n    private void _skipUtf8_3(int c) throws IOException {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        \n        c = (int) _inputBuffer[_inputPtr++];\n        if ((c & 0xC0) != 0x080) {\n            _reportInvalidOther(c & 0xFF, _inputPtr);\n        }\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        c = (int) _inputBuffer[_inputPtr++];\n        if ((c & 0xC0) != 0x080) {\n            _reportInvalidOther(c & 0xFF, _inputPtr);\n        }\n    }\n\n    private void _skipUtf8_4(int c) throws IOException {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        int d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n    }\n\n    \n\n    \n    protected void _skipCR() throws IOException {\n        if (_inputPtr < _inputEnd || loadMore()) {\n            if (_inputBuffer[_inputPtr] == BYTE_LF) {\n                ++_inputPtr;\n            }\n        }\n        ++_currInputRow;\n        _currInputRowStart = _inputPtr;\n    }\n\n        private int nextByte() throws IOException {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        return _inputBuffer[_inputPtr++] & 0xFF;\n    }\n\n    \n\n    protected void _reportInvalidChar(int c) throws JsonParseException {\n        \n        if (c < INT_SPACE) {\n            _throwInvalidSpace(c);\n        }\n        _reportInvalidInitial(c);\n    }\n\n    protected void _reportInvalidInitial(int mask) throws JsonParseException {\n        _reportError(\"Invalid UTF-8 start byte 0x\"+Integer.toHexString(mask));\n    }\n\n    protected void _reportInvalidOther(int mask) throws JsonParseException {\n        _reportError(\"Invalid UTF-8 middle byte 0x\"+Integer.toHexString(mask));\n    }\n\n    protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException {\n        _inputPtr = ptr;\n        _reportInvalidOther(mask);\n    }\n\n    public static int[] growArrayBy(int[] arr, int more) {\n        if (arr == null) {\n            return new int[more];\n        }\n        return Arrays.copyOf(arr, arr.length + more);\n    }\n\n    \n\n    \n    @SuppressWarnings(\"resource\")\n    protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException {\n        ByteArrayBuilder builder = _getByteArrayBuilder();\n\n        \n        while (true) {\n            \n            int ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { \n                if (ch == INT_QUOTE) {\n                    return builder.toByteArray();\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { \n                    continue;\n                }\n            }\n            int decodedData = bits;\n            \n            \n            \n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n            \n            \n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n            bits = b64variant.decodeBase64Char(ch);\n\n            \n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    \n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        builder.append(decodedData);\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    \n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++] & 0xFF;\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    \n                    decodedData >>= 4;\n                    builder.append(decodedData);\n                    continue;\n                }\n            }\n            \n            decodedData = (decodedData << 6) | bits;\n            \n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    \n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        builder.appendTwoBytes(decodedData);\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    \n                    decodedData >>= 2;\n                    builder.appendTwoBytes(decodedData);\n                    continue;\n                }\n            }\n            \n            decodedData = (decodedData << 6) | bits;\n            builder.appendThreeBytes(decodedData);\n        }\n    }\n}\n",
      "fixed_full_code": "package com.fasterxml.jackson.core.json;\n\nimport java.io.*;\nimport java.util.Arrays;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.base.ParserBase;\nimport com.fasterxml.jackson.core.io.CharTypes;\nimport com.fasterxml.jackson.core.io.IOContext;\nimport com.fasterxml.jackson.core.sym.*;\nimport com.fasterxml.jackson.core.util.*;\n\n\npublic final class UTF8StreamJsonParser extends ParserBase { final static byte BYTE_LF = (byte) '\\n'; private final static int[] _icUTF8 = CharTypes.getInputCodeUtf8(); protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1(); private final static int[] _icWS = CharTypes.getInputCodeWS(); protected ObjectCodec _objectCodec; final protected BytesToNameCanonicalizer _symbols; protected int[] _quadBuffer = new int[16]; protected boolean _tokenIncomplete = false; private int _quad1; protected InputStream _inputStream; protected byte[] _inputBuffer; protected boolean _bufferRecyclable; public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable) {\n        super(ctxt, features);\n        _inputStream = in;\n        _objectCodec = codec;\n        _symbols = sym;\n        _inputBuffer = inputBuffer;\n        _inputPtr = start;\n        _inputEnd = end;\n        _bufferRecyclable = bufferRecyclable;\n    }\n\n    @Override\n    public ObjectCodec getCodec() {\n        return _objectCodec;\n    }\n\n    @Override\n    public void setCodec(ObjectCodec c) {\n        _objectCodec = c;\n    }\n    \n    \n\n    @Override\n    public int releaseBuffered(OutputStream out) throws IOException {\n        int count = _inputEnd - _inputPtr;\n        if (count < 1) {\n            return 0;\n        }\n        \n        int origPtr = _inputPtr;\n        out.write(_inputBuffer, origPtr, count);\n        return count;\n    }\n\n    @Override\n    public Object getInputSource() {\n        return _inputStream;\n    }\n    \n    \n\n    @Override\n    protected boolean loadMore() throws IOException {\n        _currInputProcessed += _inputEnd;\n        _currInputRowStart -= _inputEnd;\n        \n        if (_inputStream != null) {\n            int count = _inputStream.read(_inputBuffer, 0, _inputBuffer.length);\n            if (count > 0) {\n                _inputPtr = 0;\n                _inputEnd = count;\n                return true;\n            }\n            \n            _closeInput();\n            \n            if (count == 0) {\n                throw new IOException(\"InputStream.read() returned 0 characters when trying to read \"+_inputBuffer.length+\" bytes\");\n            }\n        }\n        return false;\n    }\n\n    \n    protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException {\n        \n        if (_inputStream == null) {\n            return false;\n        }\n        \n        int amount = _inputEnd - _inputPtr;\n        if (amount > 0 && _inputPtr > 0) {\n            _currInputProcessed += _inputPtr;\n            _currInputRowStart -= _inputPtr;\n            System.arraycopy(_inputBuffer, _inputPtr, _inputBuffer, 0, amount);\n            _inputEnd = amount;\n        } else {\n            _inputEnd = 0;\n        }\n        _inputPtr = 0;\n        while (_inputEnd < minAvailable) {\n            int count = _inputStream.read(_inputBuffer, _inputEnd, _inputBuffer.length - _inputEnd);\n            if (count < 1) {\n                \n                _closeInput();\n                \n                if (count == 0) {\n                    throw new IOException(\"InputStream.read() returned 0 characters when trying to read \"+amount+\" bytes\");\n                }\n                return false;\n            }\n            _inputEnd += count;\n        }\n        return true;\n    }\n    \n    @Override\n    protected void _closeInput() throws IOException {\n        \n        if (_inputStream != null) {\n            if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_SOURCE)) {\n                _inputStream.close();\n            }\n            _inputStream = null;\n        }\n    }\n\n    \n    @Override\n    protected void _releaseBuffers() throws IOException {\n        super._releaseBuffers();\n        if (_bufferRecyclable) {\n            byte[] buf = _inputBuffer;\n            if (buf != null) {\n                _inputBuffer = null;\n                _ioContext.releaseReadIOBuffer(buf);\n            }\n        }\n    }\n\n    \n\n    @Override\n    public String getText() throws IOException, JsonParseException {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); \n            }\n            return _textBuffer.contentsAsString();\n        }\n        return _getText2(_currToken);\n    }\n\n    \n    \n    \n    @Override\n    public String getValueAsString() throws IOException, JsonParseException {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); \n            }\n            return _textBuffer.contentsAsString();\n        }\n        return super.getValueAsString(null);\n    }\n    \n    \n    @Override\n    public String getValueAsString(String defValue) throws IOException, JsonParseException {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); \n            }\n            return _textBuffer.contentsAsString();\n        }\n        return super.getValueAsString(defValue);\n    }\n    \n    protected String _getText2(JsonToken t) {\n        if (t == null) {\n            return null;\n        }\n        switch (t) {\n        case FIELD_NAME:\n            return _parsingContext.getCurrentName();\n\n        case VALUE_STRING:\n            \n        case VALUE_NUMBER_INT:\n        case VALUE_NUMBER_FLOAT:\n            return _textBuffer.contentsAsString();\n        default:\n        \treturn t.asString();\n        }\n    }\n\n    @Override\n    public char[] getTextCharacters() throws IOException, JsonParseException {\n        if (_currToken != null) { \n            switch (_currToken) {\n                \n            case FIELD_NAME:\n                if (!_nameCopied) {\n                    String name = _parsingContext.getCurrentName();\n                    int nameLen = name.length();\n                    if (_nameCopyBuffer == null) {\n                        _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen);\n                    } else if (_nameCopyBuffer.length < nameLen) {\n                        _nameCopyBuffer = new char[nameLen];\n                    }\n                    name.getChars(0, nameLen, _nameCopyBuffer, 0);\n                    _nameCopied = true;\n                }\n                return _nameCopyBuffer;\n    \n            case VALUE_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); \n                }\n                \n            case VALUE_NUMBER_INT:\n            case VALUE_NUMBER_FLOAT:\n                return _textBuffer.getTextBuffer();\n                \n            default:\n                return _currToken.asCharArray();\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public int getTextLength() throws IOException, JsonParseException {\n        if (_currToken != null) { \n            switch (_currToken) {\n                \n            case FIELD_NAME:\n                return _parsingContext.getCurrentName().length();\n            case VALUE_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); \n                }\n                \n            case VALUE_NUMBER_INT:\n            case VALUE_NUMBER_FLOAT:\n                return _textBuffer.size();\n                \n            default:\n                return _currToken.asCharArray().length;\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public int getTextOffset() throws IOException, JsonParseException {\n        \n        if (_currToken != null) {\n            switch (_currToken) {\n            case FIELD_NAME:\n                return 0;\n            case VALUE_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); \n                }\n                \n            case VALUE_NUMBER_INT:\n            case VALUE_NUMBER_FLOAT:\n                return _textBuffer.getTextOffset();\n            default:\n            }\n        }\n        return 0;\n    }\n    \n    @Override\n    public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException {\n        if (_currToken != JsonToken.VALUE_STRING &&\n                (_currToken != JsonToken.VALUE_EMBEDDED_OBJECT || _binaryValue == null)) {\n            _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\");\n        }\n        \n        if (_tokenIncomplete) {\n            try {\n                _binaryValue = _decodeBase64(b64variant);\n            } catch (IllegalArgumentException iae) {\n                throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage());\n            }\n            \n            _tokenIncomplete = false;\n        } else { \n            if (_binaryValue == null) {\n                @SuppressWarnings(\"resource\")\n                ByteArrayBuilder builder = _getByteArrayBuilder();\n                _decodeBase64(getText(), builder, b64variant);\n                _binaryValue = builder.toByteArray();\n            }\n        }\n        return _binaryValue;\n    }\n\n    @Override\n    public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException {\n        \n        if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) {\n            byte[] b = getBinaryValue(b64variant);\n            out.write(b);\n            return b.length;\n        }\n        \n        byte[] buf = _ioContext.allocBase64Buffer();\n        try {\n            return _readBinary(b64variant, out, buf);\n        } finally {\n            _ioContext.releaseBase64Buffer(buf);\n        }\n    }\n\n    protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\n        int outputCount = 0;\n\n        while (true) {\n            \n            int ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { \n                if (ch == INT_QUOTE) {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { \n                    continue;\n                }\n            }\n\n            \n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            \n\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            \n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n            bits = b64variant.decodeBase64Char(ch);\n\n            \n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    \n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    \n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++] & 0xFF;\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    \n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            \n            decodedData = (decodedData << 6) | bits;\n            \n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    \n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    \n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            \n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }\n\n    \n\n    \n    @Override\n    public JsonToken nextToken() throws IOException, JsonParseException {\n        _numTypesValid = NR_UNKNOWN;\n        \n        if (_currToken == JsonToken.FIELD_NAME) {\n            return _nextAfterName();\n        }\n        if (_tokenIncomplete) {\n            _skipString(); \n        }\n\n        int i = _skipWSOrEnd();\n        if (i < 0) { \n            \n            close();\n            return (_currToken = null);\n        }\n\n        \n        _tokenInputTotal = _currInputProcessed + _inputPtr - 1;\n        _tokenInputRow = _currInputRow;\n        _tokenInputCol = _inputPtr - _currInputRowStart - 1;\n\n        \n        _binaryValue = null;\n\n        \n        if (i == INT_RBRACKET) {\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.getParent();\n            return (_currToken = JsonToken.END_ARRAY);\n        }\n        if (i == INT_RCURLY) {\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.getParent();\n            return (_currToken = JsonToken.END_OBJECT);\n        }\n\n        \n        if (_parsingContext.expectComma()) {\n            if (i != INT_COMMA) {\n                _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\");\n            }\n            i = _skipWS();\n        }\n\n        \n        if (!_parsingContext.inObject()) {\n            return _nextTokenNotInObject(i);\n        }\n        \n        Name n = _parseFieldName(i);\n        _parsingContext.setCurrentName(n.getName());\n        _currToken = JsonToken.FIELD_NAME;\n\n        \n        if (_inputPtr < _inputEnd && _inputBuffer[_inputPtr] == ':') {\n            ++_inputPtr;\n        } else {\n            i = _skipWS();\n            if (i != INT_COLON) {\n                _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");\n            }\n        }\n        i = _skipWS();\n\n        \n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return _currToken;\n        }        \n        JsonToken t;\n\n        switch (i) {\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        case ']':\n        case '}':\n            \n            \n            _reportUnexpectedChar(i, \"expected a value\");\n        case 't':\n            _matchToken(\"true\", 1);\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchToken(\"false\", 1);\n             t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchToken(\"null\", 1);\n            t = JsonToken.VALUE_NULL;\n            break;\n\n        case '-':\n            \n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parseNumber(i);\n            break;\n        default:\n            t = _handleUnexpectedValue(i);\n        }\n        _nextToken = t;\n        return _currToken;\n    }\n\n    private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException {\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            return (_currToken = JsonToken.VALUE_STRING);\n        }\n        switch (i) {\n        case '[':\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            return (_currToken = JsonToken.START_ARRAY);\n        case '{':\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            return (_currToken = JsonToken.START_OBJECT);\n        case ']':\n        case '}':\n            \n            \n            _reportUnexpectedChar(i, \"expected a value\");\n        case 't':\n            _matchToken(\"true\", 1);\n            return (_currToken = JsonToken.VALUE_TRUE);\n        case 'f':\n            _matchToken(\"false\", 1);\n            return (_currToken = JsonToken.VALUE_FALSE);\n        case 'n':\n            _matchToken(\"null\", 1);\n            return (_currToken = JsonToken.VALUE_NULL);\n        case '-':\n            \n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            return (_currToken = _parseNumber(i));\n        }\n        return (_currToken = _handleUnexpectedValue(i));\n    }\n    \n    private JsonToken _nextAfterName() {\n        _nameCopied = false; \n        JsonToken t = _nextToken;\n        _nextToken = null;\n        \n        if (t == JsonToken.START_ARRAY) {\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n        } else if (t == JsonToken.START_OBJECT) {\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n        }\n        return (_currToken = t);\n    }\n\n    @Override\n    public void close() throws IOException {\n        super.close();\n        \n        _symbols.release();\n    }\n    \n    \n    \n    @Override\n    public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException {\n        \n        \n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) { \n            _nextAfterName();\n            return false;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) { \n            close();\n            _currToken = null;\n            return false;\n        }\n        _tokenInputTotal = _currInputProcessed + _inputPtr - 1;\n        _tokenInputRow = _currInputRow;\n        _tokenInputCol = _inputPtr - _currInputRowStart - 1;\n\n        \n        _binaryValue = null;\n\n        \n        if (i == INT_RBRACKET) {\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.getParent();\n            _currToken = JsonToken.END_ARRAY;\n            return false;\n        }\n        if (i == INT_RCURLY) {\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.getParent();\n            _currToken = JsonToken.END_OBJECT;\n            return false;\n        }\n\n        \n        if (_parsingContext.expectComma()) {\n            if (i != INT_COMMA) {\n                _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\");\n            }\n            i = _skipWS();\n        }\n\n        if (!_parsingContext.inObject()) {\n            _nextTokenNotInObject(i);\n            return false;\n        }\n        \n        \n        if (i == INT_QUOTE) {\n            \n            byte[] nameBytes = str.asQuotedUTF8();\n            final int len = nameBytes.length;\n            if ((_inputPtr + len) < _inputEnd) { \n                \n                final int end = _inputPtr+len;\n                if (_inputBuffer[end] == INT_QUOTE) {\n                    int offset = 0;\n                    final int ptr = _inputPtr;\n                    while (true) {\n                        if (offset == len) { \n                            _inputPtr = end+1; \n                            \n                            _parsingContext.setCurrentName(str.getValue());\n                            _currToken = JsonToken.FIELD_NAME;\n                            \n                            _isNextTokenNameYes();\n                            return true;\n                        }\n                        if (nameBytes[offset] != _inputBuffer[ptr+offset]) {\n                            break;\n                        }\n                        ++offset;\n                    }\n                }\n            }\n        }\n        return _isNextTokenNameMaybe(i, str);\n    }\n\n    private void _isNextTokenNameYes() throws IOException, JsonParseException {\n        \n        int i;\n        if (_inputPtr < (_inputEnd-1) && _inputBuffer[_inputPtr] == INT_COLON) { \n            i = _inputBuffer[++_inputPtr];\n            ++_inputPtr;\n            if (i == INT_QUOTE) {\n                _tokenIncomplete = true;\n                _nextToken = JsonToken.VALUE_STRING;\n                return;\n            }\n            if (i == INT_LCURLY) {\n                _nextToken = JsonToken.START_OBJECT;\n                return;\n            }\n            if (i == INT_LBRACKET) {\n                _nextToken = JsonToken.START_ARRAY;\n                return;\n            }\n            i &= 0xFF;\n            if (i <= INT_SPACE || i == INT_SLASH) {\n            \t--_inputPtr;\n                i = _skipWS();\n            }\n        } else {\n            i = _skipColon();\n        }\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return;\n        case '[':\n            _nextToken = JsonToken.START_ARRAY;\n            return;\n        case '{':\n            _nextToken = JsonToken.START_OBJECT;\n            return;\n        case ']':\n        case '}':\n            _reportUnexpectedChar(i, \"expected a value\");\n        case 't':\n            _matchToken(\"true\", 1);\n            _nextToken = JsonToken.VALUE_TRUE;\n            return;\n        case 'f':\n            _matchToken(\"false\", 1);\n            _nextToken = JsonToken.VALUE_FALSE;\n            return;\n        case 'n':\n            _matchToken(\"null\", 1);\n            _nextToken = JsonToken.VALUE_NULL;\n            return;\n        case '-':\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            _nextToken = _parseNumber(i);\n            return;\n        }\n        _nextToken = _handleUnexpectedValue(i);\n    }\n    \n    private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException {\n        \n            \n        Name n = _parseFieldName(i);\n        final boolean match;\n        {\n            String nameStr = n.getName();\n            _parsingContext.setCurrentName(nameStr);\n            match = nameStr.equals(str.getValue());\n        }\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipWS();\n        if (i != INT_COLON) {\n            _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");\n        }\n        i = _skipWS();\n\n        \n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return match;\n        }\n        JsonToken t;\n\n        switch (i) {\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        case ']':\n        case '}':\n            _reportUnexpectedChar(i, \"expected a value\");\n        case 't':\n            _matchToken(\"true\", 1);\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchToken(\"false\", 1);\n             t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchToken(\"null\", 1);\n            t = JsonToken.VALUE_NULL;\n            break;\n\n        case '-':\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n\n            t = _parseNumber(i);\n            break;\n        default:\n            t = _handleUnexpectedValue(i);\n        }\n        _nextToken = t;\n        return match;\n    }\n\n    @Override\n    public String nextTextValue() throws IOException, JsonParseException {\n        \n        if (_currToken == JsonToken.FIELD_NAME) { \n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_STRING) {\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString();\n                }\n                return _textBuffer.contentsAsString();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        \n        return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;\n    }\n\n    @Override\n    public int nextIntValue(int defaultValue) throws IOException, JsonParseException {\n        \n        if (_currToken == JsonToken.FIELD_NAME) { \n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getIntValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        \n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;\n    }\n\n    @Override\n    public long nextLongValue(long defaultValue) throws IOException, JsonParseException {\n        \n        if (_currToken == JsonToken.FIELD_NAME) { \n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getLongValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        \n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;\n    }\n\n    @Override\n    public Boolean nextBooleanValue() throws IOException, JsonParseException {\n        \n        if (_currToken == JsonToken.FIELD_NAME) { \n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_TRUE) {\n                return Boolean.TRUE;\n            }\n            if (t == JsonToken.VALUE_FALSE) {\n                return Boolean.FALSE;\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        switch (nextToken()) {\n        case VALUE_TRUE:\n            return Boolean.TRUE;\n        case VALUE_FALSE:\n            return Boolean.FALSE;\n        default:\n        \treturn null;\n        }\n    }\n    \n    \n\n    \n    protected JsonToken _parseNumber(int c) throws IOException, JsonParseException {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        \n        if (negative) {\n            outBuf[outPtr++] = '-';\n            \n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            \n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        \n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        \n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        \n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        \n        while (true) {\n            if (_inputPtr >= end) {\n                \n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloat(outBuf, outPtr, c, negative, intLen);\n        }\n        \n        --_inputPtr; \n        _textBuffer.setCurrentLength(outPtr);\n        \n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(c);\n        }\n\n        \n        return resetInt(negative, intLen);\n    }\n    \n    \n    private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException {\n        \n        while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                _textBuffer.setCurrentLength(outPtr);\n                return resetInt(negative, intPartLength);\n            }\n            int c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c > INT_9 || c < INT_0) {\n                if (c == '.' || c == 'e' || c == 'E') {\n                    return _parseFloat(outBuf, outPtr, c, negative, intPartLength);\n                }\n                break;\n            }\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            ++intPartLength;\n        }\n        --_inputPtr; \n        _textBuffer.setCurrentLength(outPtr);\n        \n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(_inputBuffer[_inputPtr++] & 0xFF);\n        }\n\n        \n        return resetInt(negative, intPartLength);\n        \n    }\n    \n    \n    private int _verifyNoLeadingZeroes() throws IOException, JsonParseException {\n        \n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            return INT_0;\n        }\n        int ch = _inputBuffer[_inputPtr] & 0xFF;\n        \n        if (ch < INT_0 || ch > INT_9) {\n            return INT_0;\n        }\n        \n        if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) {\n            reportInvalidNumber(\"Leading zeroes not allowed\");\n        }\n        \n        ++_inputPtr; \n        if (ch == INT_0) {\n            while (_inputPtr < _inputEnd || loadMore()) {\n                ch = _inputBuffer[_inputPtr] & 0xFF;\n                if (ch < INT_0 || ch > INT_9) { \n                    return INT_0;\n                }\n                ++_inputPtr; \n                if (ch != INT_0) { \n                    break;\n                }\n            }\n        }\n        return ch;\n    }\n    \n    private JsonToken _parseFloat(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException {\n        int fractLen = 0;\n        boolean eof = false;\n\n        \n        if (c == '.') { \n            outBuf[outPtr++] = (char) c;\n\n            fract_loop:\n            while (true) {\n                if (_inputPtr >= _inputEnd && !loadMore()) {\n                    eof = true;\n                    break fract_loop;\n                }\n                c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n                if (c < INT_0 || c > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = (char) c;\n            }\n            \n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n            }\n        }\n\n        int expLen = 0;\n        if (c == 'e' || c == 'E') { \n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            \n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            \n            if (c == '-' || c == '+') {\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = (char) c;\n                \n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            }\n\n            exp_loop:\n            while (c <= INT_9 && c >= INT_0) {\n                ++expLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = (char) c;\n                if (_inputPtr >= _inputEnd && !loadMore()) {\n                    eof = true;\n                    break exp_loop;\n                }\n                c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            }\n            \n            if (expLen == 0) {\n                reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n            }\n        }\n\n        \n        if (!eof) {\n            --_inputPtr;\n            \n            if (_parsingContext.inRoot()) {\n                _verifyRootSpace(c);\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n\n        \n        return resetFloat(negative, integerPartLength, fractLen, expLen);\n    }\n\n    \n    private final void _verifyRootSpace(int ch) throws IOException {\n        \n        ++_inputPtr;\n        \n        switch (ch) {\n        case ' ':\n        case '\\t':\n            return;\n        case '\\r':\n            _skipCR();\n            return;\n        case '\\n':\n            ++_currInputRow;\n            _currInputRowStart = _inputPtr;\n            return;\n        }\n        _reportMissingRootWS(ch);\n    }\n\n    \n    \n    protected Name _parseFieldName(int i) throws IOException, JsonParseException {\n        if (i != INT_QUOTE) {\n            return _handleOddName(i);\n        }\n        \n        if ((_inputPtr + 9) > _inputEnd) { \n            return slowParseName();\n        }\n\n        \n        \n        final byte[] input = _inputBuffer;\n        final int[] codes = _icLatin1;\n\n        int q = input[_inputPtr++] & 0xFF;\n\n        if (codes[q] == 0) {\n            i = input[_inputPtr++] & 0xFF;\n            if (codes[i] == 0) {\n                q = (q << 8) | i;\n                i = input[_inputPtr++] & 0xFF;\n                if (codes[i] == 0) {\n                    q = (q << 8) | i;\n                    i = input[_inputPtr++] & 0xFF;\n                    if (codes[i] == 0) {\n                        q = (q << 8) | i;\n                        i = input[_inputPtr++] & 0xFF;\n                        if (codes[i] == 0) {\n                            _quad1 = q;\n                            return parseMediumName(i, codes);\n                        }\n                        if (i == INT_QUOTE) { \n                            return findName(q, 4);\n                        }\n                        return parseName(q, i, 4);\n                    }\n                    if (i == INT_QUOTE) { \n                        return findName(q, 3);\n                    }\n                    return parseName(q, i, 3);\n                }                \n                if (i == INT_QUOTE) { \n                    return findName(q, 2);\n                }\n                return parseName(q, i, 2);\n            }\n            if (i == INT_QUOTE) { \n                return findName(q, 1);\n            }\n            return parseName(q, i, 1);\n        }     \n        if (q == INT_QUOTE) { \n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        return parseName(0, q, 0); \n    }\n\n    protected Name parseMediumName(int q2, final int[] codes) throws IOException, JsonParseException {\n        \n        int i = _inputBuffer[_inputPtr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { \n                return findName(_quad1, q2, 1);\n            }\n            return parseName(_quad1, q2, i, 1); \n        }\n        q2 = (q2 << 8) | i;\n        i = _inputBuffer[_inputPtr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { \n                return findName(_quad1, q2, 2);\n            }\n            return parseName(_quad1, q2, i, 2);\n        }\n        q2 = (q2 << 8) | i;\n        i = _inputBuffer[_inputPtr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { \n                return findName(_quad1, q2, 3);\n            }\n            return parseName(_quad1, q2, i, 3);\n        }\n        q2 = (q2 << 8) | i;\n        i = _inputBuffer[_inputPtr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { \n                return findName(_quad1, q2, 4);\n            }\n            return parseName(_quad1, q2, i, 4);\n        }\n        _quadBuffer[0] = _quad1;\n        _quadBuffer[1] = q2;\n        return parseLongName(i);\n    }\n\n    protected Name parseLongName(int q) throws IOException, JsonParseException {\n        \n        final int[] codes = _icLatin1;\n        int qlen = 2;\n\n        while (true) {\n            \n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedName(_quadBuffer, qlen, 0, q, 0);\n            }\n            \n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 2);\n                }\n                return parseEscapedName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            \n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }\n\n    \n    protected Name slowParseName() throws IOException, JsonParseException {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\\"' for name\");\n            }\n        }\n        int i = _inputBuffer[_inputPtr++] & 0xFF;\n        if (i == INT_QUOTE) { \n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        return parseEscapedName(_quadBuffer, 0, 0, i, 0);\n    }\n\n    private Name parseName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException {\n        return parseEscapedName(_quadBuffer, 0, q1, ch, lastQuadBytes);\n    }\n\n    private Name parseName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException {\n        _quadBuffer[0] = q1;\n        return parseEscapedName(_quadBuffer, 1, q2, ch, lastQuadBytes);\n    }\n\n    \n    protected Name parseEscapedName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException {\n        \n        final int[] codes = _icLatin1;\n\n        while (true) {\n            if (codes[ch] != 0) {\n                if (ch == INT_QUOTE) { \n                    break;\n                }\n                \n                if (ch != INT_BACKSLASH) {\n                    \n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    \n                    ch = _decodeEscaped();\n                }\n                \n                if (ch > 127) {\n                    \n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { \n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        \n                    } else { \n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        \n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    \n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            \n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }\n\n    \n    protected Name _handleOddName(int ch) throws IOException, JsonParseException {\n        \n        if (ch == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n            return _parseAposName();\n        }\n        \n        if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {\n            _reportUnexpectedChar(ch, \"was expecting double-quote to start field name\");\n        }\n        \n        final int[] codes = CharTypes.getInputCodeUtf8JsNames();\n        \n        if (codes[ch] != 0) {\n            _reportUnexpectedChar(ch, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\");\n        }\n\n        \n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        while (true) {\n            \n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\n            ch = _inputBuffer[_inputPtr] & 0xFF;\n            if (codes[ch] != 0) {\n                break;\n            }\n            ++_inputPtr;\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }\n\n    \n    protected Name _parseAposName() throws IOException, JsonParseException {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == '\\'') { \n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        \n\n        final int[] codes = _icLatin1;\n\n        while (true) {\n            if (ch == '\\'') {\n                break;\n            }\n            \n            if (ch != '\"' && codes[ch] != 0) {\n                if (ch != '\\\\') {\n                    \n                    \n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    \n                    ch = _decodeEscaped();\n                }\n                \n                if (ch > 127) {\n                    \n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { \n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        \n                    } else { \n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        \n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    \n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            \n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }\n\n    \n\n    private Name findName(int q1, int lastQuadBytes) throws JsonParseException {\n        \n        Name name = _symbols.findName(q1);\n        if (name != null) {\n            return name;\n        }\n        \n        _quadBuffer[0] = q1;\n        return addName(_quadBuffer, 1, lastQuadBytes);\n    }\n\n    private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException {\n        \n        Name name = _symbols.findName(q1, q2);\n        if (name != null) {\n            return name;\n        }\n        \n        _quadBuffer[0] = q1;\n        _quadBuffer[1] = q2;\n        return addName(_quadBuffer, 2, lastQuadBytes);\n    }\n\n    private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException {\n        if (qlen >= quads.length) {\n            _quadBuffer = quads = growArrayBy(quads, quads.length);\n        }\n        quads[qlen++] = lastQuad;\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            return addName(quads, qlen, lastQuadBytes);\n        }\n        return name;\n    }\n\n    \n    private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException {\n        \n        \n        int byteLen = (qlen << 2) - 4 + lastQuadBytes;\n\n        \n        int lastQuad;\n\n        if (lastQuadBytes < 4) {\n            lastQuad = quads[qlen-1];\n            \n            quads[qlen-1] = (lastQuad << ((4 - lastQuadBytes) << 3));\n        } else {\n            lastQuad = 0;\n        }\n\n        \n        char[] cbuf = _textBuffer.emptyAndGetCurrentSegment();\n        int cix = 0;\n\n        for (int ix = 0; ix < byteLen; ) {\n            int ch = quads[ix >> 2]; \n            int byteIx = (ix & 3);\n            ch = (ch >> ((3 - byteIx) << 3)) & 0xFF;\n            ++ix;\n\n            if (ch > 127) { \n                int needed;\n                if ((ch & 0xE0) == 0xC0) { \n                    ch &= 0x1F;\n                    needed = 1;\n                } else if ((ch & 0xF0) == 0xE0) { \n                    ch &= 0x0F;\n                    needed = 2;\n                } else if ((ch & 0xF8) == 0xF0) { \n                    ch &= 0x07;\n                    needed = 3;\n                } else { \n                    _reportInvalidInitial(ch);\n                    needed = ch = 1; \n                }\n                if ((ix + needed) > byteLen) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n                \n                \n                int ch2 = quads[ix >> 2]; \n                byteIx = (ix & 3);\n                ch2 = (ch2 >> ((3 - byteIx) << 3));\n                ++ix;\n                \n                if ((ch2 & 0xC0) != 0x080) {\n                    _reportInvalidOther(ch2);\n                }\n                ch = (ch << 6) | (ch2 & 0x3F);\n                if (needed > 1) {\n                    ch2 = quads[ix >> 2];\n                    byteIx = (ix & 3);\n                    ch2 = (ch2 >> ((3 - byteIx) << 3));\n                    ++ix;\n                    \n                    if ((ch2 & 0xC0) != 0x080) {\n                        _reportInvalidOther(ch2);\n                    }\n                    ch = (ch << 6) | (ch2 & 0x3F);\n                    if (needed > 2) { \n                        ch2 = quads[ix >> 2];\n                        byteIx = (ix & 3);\n                        ch2 = (ch2 >> ((3 - byteIx) << 3));\n                        ++ix;\n                        if ((ch2 & 0xC0) != 0x080) {\n                            _reportInvalidOther(ch2 & 0xFF);\n                        }\n                        ch = (ch << 6) | (ch2 & 0x3F);\n                    }\n                }\n                if (needed > 2) { \n                    ch -= 0x10000; \n                    if (cix >= cbuf.length) {\n                        cbuf = _textBuffer.expandCurrentSegment();\n                    }\n                    cbuf[cix++] = (char) (0xD800 + (ch >> 10));\n                    ch = 0xDC00 | (ch & 0x03FF);\n                }\n            }\n            if (cix >= cbuf.length) {\n                cbuf = _textBuffer.expandCurrentSegment();\n            }\n            cbuf[cix++] = (char) ch;\n        }\n\n        \n        String baseName = new String(cbuf, 0, cix);\n        \n        if (lastQuadBytes < 4) {\n            quads[qlen-1] = lastQuad;\n        }\n        return _symbols.addName(baseName, quads, qlen);\n    }\n\n    \n\n    @Override\n    protected void _finishString() throws IOException {\n        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = _icUTF8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\n            int c = (int) inputBuffer[ptr] & 0xFF;\n            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }\n\n    private void _finishString2(char[] outBuf, int outPtr) throws IOException {\n        int c;\n\n        \n        final int[] codes = _icUTF8;\n        final byte[] inputBuffer = _inputBuffer;\n\n        main_loop:\n        while (true) {\n            \n            ascii_loop:\n            while (true) {\n                int ptr = _inputPtr;\n                if (ptr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                    ptr = _inputPtr;\n                }\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                final int max = Math.min(_inputEnd, (ptr + (outBuf.length - outPtr)));\n                while (ptr < max) {\n                    c = (int) inputBuffer[ptr++] & 0xFF;\n                    if (codes[c] != 0) {\n                        _inputPtr = ptr;\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (char) c;\n                }\n                _inputPtr = ptr;\n            }\n            \n            if (c == INT_QUOTE) {\n                break main_loop;\n            }\n\n            switch (codes[c]) {\n            case 1: \n                c = _decodeEscaped();\n                break;\n            case 2: \n                c = _decodeUtf8_2(c);\n                break;\n            case 3: \n                if ((_inputEnd - _inputPtr) >= 2) {\n                    c = _decodeUtf8_3fast(c);\n                } else {\n                    c = _decodeUtf8_3(c);\n                }\n                break;\n            case 4: \n                c = _decodeUtf8_4(c);\n                \n                outBuf[outPtr++] = (char) (0xD800 | (c >> 10));\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                c = 0xDC00 | (c & 0x3FF);\n                \n                break;\n            default:\n                if (c < INT_SPACE) {\n                    \n                    _throwUnquotedSpace(c, \"string value\");\n                } else {\n                    \n                    _reportInvalidChar(c);\n                }\n            }\n            \n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            \n            outBuf[outPtr++] = (char) c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n    }\n\n    \n    protected void _skipString() throws IOException {\n        _tokenIncomplete = false;\n\n        \n        final int[] codes = _icUTF8;\n        final byte[] inputBuffer = _inputBuffer;\n\n        main_loop:\n        while (true) {\n            int c;\n\n            ascii_loop:\n            while (true) {\n                int ptr = _inputPtr;\n                int max = _inputEnd;\n                if (ptr >= max) {\n                    loadMoreGuaranteed();\n                    ptr = _inputPtr;\n                    max = _inputEnd;\n                }\n                while (ptr < max) {\n                    c = (int) inputBuffer[ptr++] & 0xFF;\n                    if (codes[c] != 0) {\n                        _inputPtr = ptr;\n                        break ascii_loop;\n                    }\n                }\n                _inputPtr = ptr;\n            }\n            \n            if (c == INT_QUOTE) {\n                break main_loop;\n            }\n            \n            switch (codes[c]) {\n            case 1: \n                _decodeEscaped();\n                break;\n            case 2: \n                _skipUtf8_2(c);\n                break;\n            case 3: \n                _skipUtf8_3(c);\n                break;\n            case 4: \n                _skipUtf8_4(c);\n                break;\n            default:\n                if (c < INT_SPACE) {\n                    \n                    _throwUnquotedSpace(c, \"string value\");\n                } else {\n                    \n                    _reportInvalidChar(c);\n                }\n            }\n        }\n    }\n\n    \n    protected JsonToken _handleUnexpectedValue(int c) throws IOException {\n        \n        switch (c) {\n        case '\\'':\n            if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n                return _handleApos();\n            }\n            break;\n        case 'N':\n            _matchToken(\"NaN\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"NaN\", Double.NaN);\n            }\n            _reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case 'I':\n            _matchToken(\"Infinity\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY);\n            }\n            _reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case '+': \n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOFInValue();\n                }\n            }\n            return _handleInvalidNumberStart(_inputBuffer[_inputPtr++] & 0xFF, false);\n        }\n        \n        if (Character.isJavaIdentifierStart(c)) {\n            _reportInvalidToken(\"\"+((char) c), \"('true', 'false' or 'null')\");\n        }\n        \n        _reportUnexpectedChar(c, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\n        return null;\n    }\n\n    protected JsonToken _handleApos() throws IOException {\n        int c = 0;\n        \n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n\n        \n        final int[] codes = _icUTF8;\n        final byte[] inputBuffer = _inputBuffer;\n\n        main_loop:\n        while (true) {\n            \n            ascii_loop:\n            while (true) {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                int max = _inputEnd;\n                {\n                    int max2 = _inputPtr + (outBuf.length - outPtr);\n                    if (max2 < max) {\n                        max = max2;\n                    }\n                }\n                while (_inputPtr < max) {\n                    c = (int) inputBuffer[_inputPtr++] & 0xFF;\n                    if (c == '\\'' || codes[c] != 0) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (char) c;\n                }\n            }\n\n            \n            if (c == '\\'') {\n                break main_loop;\n            }\n\n            switch (codes[c]) {\n            case 1: \n                if (c != '\\'') { \n                    c = _decodeEscaped();\n                }\n                break;\n            case 2: \n                c = _decodeUtf8_2(c);\n                break;\n            case 3: \n                if ((_inputEnd - _inputPtr) >= 2) {\n                    c = _decodeUtf8_3fast(c);\n                } else {\n                    c = _decodeUtf8_3(c);\n                }\n                break;\n            case 4: \n                c = _decodeUtf8_4(c);\n                \n                outBuf[outPtr++] = (char) (0xD800 | (c >> 10));\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                c = 0xDC00 | (c & 0x3FF);\n                \n                break;\n            default:\n                if (c < INT_SPACE) {\n                    _throwUnquotedSpace(c, \"string value\");\n                }\n                \n                _reportInvalidChar(c);\n            }\n            \n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            \n            outBuf[outPtr++] = (char) c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n\n        return JsonToken.VALUE_STRING;\n    }\n    \n    \n    protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException {\n        while (ch == 'I') {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOFInValue();\n                }\n            }\n            ch = _inputBuffer[_inputPtr++];\n            String match;\n            if (ch == 'N') {\n                match = neg ? \"-INF\" :\"+INF\";\n            } else if (ch == 'n') {\n                match = neg ? \"-Infinity\" :\"+Infinity\";\n            } else {\n                break;\n            }\n            _matchToken(match, 3);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(match, neg ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n            }\n            _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n        }\n        reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        return null;\n    }\n\n    protected void _matchToken(String matchStr, int i) throws IOException {\n        final int len = matchStr.length();\n    \n        do {\n            if (((_inputPtr >= _inputEnd) && !loadMore())\n                ||  (_inputBuffer[_inputPtr] != matchStr.charAt(i))) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n    \n        \n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            return;\n        }\n        int ch = _inputBuffer[_inputPtr] & 0xFF;\n        if (ch < '0' || ch == ']' || ch == '}') { \n            return;\n        }\n        \n        char c = (char) _decodeCharForError(ch);\n        if (Character.isJavaIdentifierPart(c)) {\n            _reportInvalidToken(matchStr.substring(0, i));\n        }\n    }\n\n    protected void _reportInvalidToken(String matchedPart) throws IOException {\n        _reportInvalidToken(matchedPart, \"'null', 'true', 'false' or NaN\");\n    }\n    \n    protected void _reportInvalidToken(String matchedPart, String msg) throws IOException {\n        StringBuilder sb = new StringBuilder(matchedPart);\n\n        \n        while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                break;\n            }\n            int i = (int) _inputBuffer[_inputPtr++];\n            char c = (char) _decodeCharForError(i);\n            if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            sb.append(c);\n        }\n        _reportError(\"Unrecognized token '\"+sb.toString()+\"': was expecting \"+msg);\n    }\n\n    \n    \n    private final int _skipWS() throws IOException {\n        final int[] codes = _icWS;\n        while (_inputPtr < _inputEnd || loadMore()) {\n            final int i = _inputBuffer[_inputPtr++] & 0xFF;\n            switch (codes[i]) {\n            case 0: \n                return i;\n            case 1: \n                continue;\n            case 2: \n                _skipUtf8_2(i);\n                break;\n            case 3: \n                _skipUtf8_3(i);\n                break;\n            case 4: \n                _skipUtf8_4(i);\n                break;\n            case INT_LF:\n                ++_currInputRow;\n                _currInputRowStart = _inputPtr;\n                break;\n            case INT_CR:\n                _skipCR();\n                break;\n            case '/':\n                _skipComment();\n                break;\n            case '#':\n                if (!_skipYAMLComment()) {\n                    return i;\n                }\n                break;\n            default: \n                \n                if (i < 32) {\n                    _throwInvalidSpace(i);\n                }\n                _reportInvalidChar(i);\n            }\n        }\n        throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\");\n    }\n\n    private int _skipWSOrEnd() throws IOException {\n        final int[] codes = _icWS;\n        while ((_inputPtr < _inputEnd) || loadMore()) {\n            final int i = _inputBuffer[_inputPtr++] & 0xFF;\n            switch (codes[i]) {\n            case 0: \n                return i;\n            case 1: \n                continue;\n            case 2: \n                _skipUtf8_2(i);\n                break;\n            case 3: \n                _skipUtf8_3(i);\n                break;\n            case 4: \n                _skipUtf8_4(i);\n                break;\n            case INT_LF:\n                ++_currInputRow;\n                _currInputRowStart = _inputPtr;\n                break;\n            case INT_CR:\n                _skipCR();\n                break;\n            case '/':\n                _skipComment();\n                break;\n            case '#':\n                if (!_skipYAMLComment()) {\n                    return i;\n                }\n                break;\n            default: \n                _reportInvalidChar(i);\n            }\n        }\n        \n        _handleEOF();\n        return -1;\n    }\n\n    \n    private int _skipColon() throws IOException {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        \n        int i = _inputBuffer[_inputPtr++];\n        if (i == INT_COLON) {\n            if (_inputPtr < _inputEnd) {\n                i = _inputBuffer[_inputPtr] & 0xFF;\n                if (i > INT_SPACE && i != INT_SLASH) {\n                    ++_inputPtr;\n                    return i;\n                }\n            }\n        } else {\n            \n            i &= 0xFF;\n            \n            space_loop:\n            while (true) {\n                switch (i) {\n                case ' ':\n                case '\\t':\n                    break;\n                case INT_CR:\n                    _skipCR();\n                    break;\n                case INT_LF:\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                case '/':\n                    _skipComment();\n                    break;\n                default:\n                    if (i < INT_SPACE) {\n                        _throwInvalidSpace(i);\n                    }\n                    break space_loop;\n                }\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                i = _inputBuffer[_inputPtr++] & 0xFF;\n            }\n            if (i != INT_COLON) {\n                _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");\n            }\n        }\n\n            \n        while (_inputPtr < _inputEnd || loadMore()) {\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (i > INT_SPACE) {\n                if (i != INT_SLASH) {\n                    return i;\n                }\n                _skipComment();\n            } else if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\");\n    }\n    \n    private void _skipComment() throws IOException {\n        if (!isEnabled(Feature.ALLOW_COMMENTS)) {\n            _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\");\n        }\n        \n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            _reportInvalidEOF(\" in a comment\");\n        }\n        int c = _inputBuffer[_inputPtr++] & 0xFF;\n        if (c == '/') {\n            _skipLine();\n        } else if (c == '*') {\n            _skipCComment();\n        } else {\n            _reportUnexpectedChar(c, \"was expecting either '*' or '/' for a comment\");\n        }\n    }\n\n    private void _skipCComment() throws IOException {\n        \n        final int[] codes = CharTypes.getInputCodeComment();\n\n        \n        main_loop:\n        while ((_inputPtr < _inputEnd) || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            int code = codes[i];\n            if (code != 0) {\n                switch (code) {\n                case '*':\n                    if (_inputPtr >= _inputEnd && !loadMore()) {\n                        break main_loop;\n                    }\n                    if (_inputBuffer[_inputPtr] == INT_SLASH) {\n                        ++_inputPtr;\n                        return;\n                    }\n                    break;\n                case INT_LF:\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                case INT_CR:\n                    _skipCR();\n                    break;\n                case 2: \n                    _skipUtf8_2(i);\n                    break;\n                case 3: \n                    _skipUtf8_3(i);\n                    break;\n                case 4: \n                    _skipUtf8_4(i);\n                    break;\n                default: \n                    \n                    _reportInvalidChar(i);\n                }\n            }\n        }\n        _reportInvalidEOF(\" in a comment\");\n    }\n\n    private boolean _skipYAMLComment() throws IOException {\n        if (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) {\n            return false;\n        }\n        _skipLine();\n        return true;\n    }\n\n    \n    private void _skipLine() throws IOException {\n        \n        final int[] codes = CharTypes.getInputCodeComment();\n        while ((_inputPtr < _inputEnd) || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            int code = codes[i];\n            if (code != 0) {\n                switch (code) {\n                case INT_LF:\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    return;\n                case INT_CR:\n                    _skipCR();\n                    return;\n                case '*': \n                    break;\n                case 2: \n                    _skipUtf8_2(i);\n                    break;\n                case 3: \n                    _skipUtf8_3(i);\n                    break;\n                case 4: \n                    _skipUtf8_4(i);\n                    break;\n                default: \n                    if (code < 0) {\n                        \n                        _reportInvalidChar(i);\n                    }\n                }\n            }\n        }\n    }\n    \n    @Override\n    protected char _decodeEscaped() throws IOException {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\" in character escape sequence\");\n            }\n        }\n        int c = (int) _inputBuffer[_inputPtr++];\n\n        switch ((int) c) {\n            \n        case 'b':\n            return '\\b';\n        case 't':\n            return '\\t';\n        case 'n':\n            return '\\n';\n        case 'f':\n            return '\\f';\n        case 'r':\n            return '\\r';\n\n            \n        case '\"':\n        case '/':\n        case '\\\\':\n            return (char) c;\n\n        case 'u': \n            break;\n\n        default:\n            return _handleUnrecognizedCharacterEscape((char) _decodeCharForError(c));\n        }\n\n        \n        int value = 0;\n        for (int i = 0; i < 4; ++i) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in character escape sequence\");\n                }\n            }\n            int ch = (int) _inputBuffer[_inputPtr++];\n            int digit = CharTypes.charToHex(ch);\n            if (digit < 0) {\n                _reportUnexpectedChar(ch, \"expected a hex-digit for character escape sequence\");\n            }\n            value = (value << 4) | digit;\n        }\n        return (char) value;\n    }\n\n    protected int _decodeCharForError(int firstByte) throws IOException {\n        int c = (int) firstByte;\n        if (c < 0) { \n            int needed;\n            \n            \n            if ((c & 0xE0) == 0xC0) { \n                c &= 0x1F;\n                needed = 1;\n            } else if ((c & 0xF0) == 0xE0) { \n                c &= 0x0F;\n                needed = 2;\n            } else if ((c & 0xF8) == 0xF0) {\n                \n                c &= 0x07;\n                needed = 3;\n            } else {\n                _reportInvalidInitial(c & 0xFF);\n                needed = 1; \n            }\n\n            int d = nextByte();\n            if ((d & 0xC0) != 0x080) {\n                _reportInvalidOther(d & 0xFF);\n            }\n            c = (c << 6) | (d & 0x3F);\n            \n            if (needed > 1) { \n                d = nextByte(); \n                if ((d & 0xC0) != 0x080) {\n                    _reportInvalidOther(d & 0xFF);\n                }\n                c = (c << 6) | (d & 0x3F);\n                if (needed > 2) { \n                    d = nextByte();\n                    if ((d & 0xC0) != 0x080) {\n                        _reportInvalidOther(d & 0xFF);\n                    }\n                    c = (c << 6) | (d & 0x3F);\n                }\n            }\n        }\n        return c;\n    }\n\n    \n\n    private int _decodeUtf8_2(int c) throws IOException {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        int d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        return ((c & 0x1F) << 6) | (d & 0x3F);\n    }\n\n    private int _decodeUtf8_3(int c1) throws IOException {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        c1 &= 0x0F;\n        int d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        int c = (c1 << 6) | (d & 0x3F);\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        c = (c << 6) | (d & 0x3F);\n        return c;\n    }\n\n    private int _decodeUtf8_3fast(int c1) throws IOException {\n        c1 &= 0x0F;\n        int d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        int c = (c1 << 6) | (d & 0x3F);\n        d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        c = (c << 6) | (d & 0x3F);\n        return c;\n    }\n\n    \n    private int _decodeUtf8_4(int c) throws IOException {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        int d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        c = ((c & 0x07) << 6) | (d & 0x3F);\n\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        c = (c << 6) | (d & 0x3F);\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n\n        \n        return ((c << 6) | (d & 0x3F)) - 0x10000;\n    }\n\n    private void _skipUtf8_2(int c) throws IOException {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        c = (int) _inputBuffer[_inputPtr++];\n        if ((c & 0xC0) != 0x080) {\n            _reportInvalidOther(c & 0xFF, _inputPtr);\n        }\n    }\n\n    \n    private void _skipUtf8_3(int c) throws IOException {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        \n        c = (int) _inputBuffer[_inputPtr++];\n        if ((c & 0xC0) != 0x080) {\n            _reportInvalidOther(c & 0xFF, _inputPtr);\n        }\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        c = (int) _inputBuffer[_inputPtr++];\n        if ((c & 0xC0) != 0x080) {\n            _reportInvalidOther(c & 0xFF, _inputPtr);\n        }\n    }\n\n    private void _skipUtf8_4(int c) throws IOException {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        int d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n    }\n\n    \n\n    \n    protected void _skipCR() throws IOException {\n        if (_inputPtr < _inputEnd || loadMore()) {\n            if (_inputBuffer[_inputPtr] == BYTE_LF) {\n                ++_inputPtr;\n            }\n        }\n        ++_currInputRow;\n        _currInputRowStart = _inputPtr;\n    }\n\n        private int nextByte() throws IOException {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        return _inputBuffer[_inputPtr++] & 0xFF;\n    }\n\n    \n\n    protected void _reportInvalidChar(int c) throws JsonParseException {\n        \n        if (c < INT_SPACE) {\n            _throwInvalidSpace(c);\n        }\n        _reportInvalidInitial(c);\n    }\n\n    protected void _reportInvalidInitial(int mask) throws JsonParseException {\n        _reportError(\"Invalid UTF-8 start byte 0x\"+Integer.toHexString(mask));\n    }\n\n    protected void _reportInvalidOther(int mask) throws JsonParseException {\n        _reportError(\"Invalid UTF-8 middle byte 0x\"+Integer.toHexString(mask));\n    }\n\n    protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException {\n        _inputPtr = ptr;\n        _reportInvalidOther(mask);\n    }\n\n    public static int[] growArrayBy(int[] arr, int more) {\n        if (arr == null) {\n            return new int[more];\n        }\n        return Arrays.copyOf(arr, arr.length + more);\n    }\n\n    \n\n    \n    @SuppressWarnings(\"resource\")\n    protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException {\n        ByteArrayBuilder builder = _getByteArrayBuilder();\n\n        \n        while (true) {\n            \n            int ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { \n                if (ch == INT_QUOTE) {\n                    return builder.toByteArray();\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { \n                    continue;\n                }\n            }\n            int decodedData = bits;\n            \n            \n            \n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n            \n            \n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n            bits = b64variant.decodeBase64Char(ch);\n\n            \n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    \n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        builder.append(decodedData);\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    \n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++] & 0xFF;\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    \n                    decodedData >>= 4;\n                    builder.append(decodedData);\n                    continue;\n                }\n            }\n            \n            decodedData = (decodedData << 6) | bits;\n            \n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    \n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        builder.appendTwoBytes(decodedData);\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    \n                    decodedData >>= 2;\n                    builder.appendTwoBytes(decodedData);\n                    continue;\n                }\n            }\n            \n            decodedData = (decodedData << 6) | bits;\n            builder.appendThreeBytes(decodedData);\n        }\n    }\n}\n",
      "buggy_signatures": [
        "public ObjectCodec getCodec()",
        "public void setCodec(ObjectCodec c)",
        "public int releaseBuffered(OutputStream out) throws IOException",
        "public Object getInputSource()",
        "protected boolean loadMore() throws IOException",
        "protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException",
        "protected void _closeInput() throws IOException",
        "protected void _releaseBuffers() throws IOException",
        "public String getText() throws IOException, JsonParseException",
        "public String getValueAsString() throws IOException, JsonParseException",
        "public String getValueAsString(String defValue) throws IOException, JsonParseException",
        "protected String _getText2(JsonToken t)",
        "public char[] getTextCharacters() throws IOException, JsonParseException",
        "public int getTextLength() throws IOException, JsonParseException",
        "public int getTextOffset() throws IOException, JsonParseException",
        "public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException",
        "public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException",
        "protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException",
        "public JsonToken nextToken() throws IOException, JsonParseException",
        "private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException",
        "private JsonToken _nextAfterName()",
        "public void close() throws IOException",
        "public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException",
        "private void _isNextTokenNameYes() throws IOException, JsonParseException",
        "private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException",
        "public String nextTextValue() throws IOException, JsonParseException",
        "public int nextIntValue(int defaultValue) throws IOException, JsonParseException",
        "public long nextLongValue(long defaultValue) throws IOException, JsonParseException",
        "public Boolean nextBooleanValue() throws IOException, JsonParseException",
        "protected JsonToken _parseNumber(int c) throws IOException, JsonParseException",
        "private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException",
        "private int _verifyNoLeadingZeroes() throws IOException, JsonParseException",
        "private JsonToken _parseFloat(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException",
        "protected Name _parseFieldName(int i) throws IOException, JsonParseException",
        "protected Name parseMediumName(int q2, final int[] codes) throws IOException, JsonParseException",
        "protected Name parseLongName(int q) throws IOException, JsonParseException",
        "protected Name slowParseName() throws IOException, JsonParseException",
        "private Name parseName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException",
        "private Name parseName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException",
        "protected Name parseEscapedName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException",
        "protected Name _handleOddName(int ch) throws IOException, JsonParseException",
        "protected Name _parseAposName() throws IOException, JsonParseException",
        "private Name findName(int q1, int lastQuadBytes) throws JsonParseException",
        "private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException",
        "private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException",
        "private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException",
        "protected void _finishString() throws IOException",
        "private void _finishString2(char[] outBuf, int outPtr) throws IOException",
        "protected void _skipString() throws IOException",
        "protected JsonToken _handleUnexpectedValue(int c) throws IOException",
        "protected JsonToken _handleApos() throws IOException",
        "protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException",
        "protected void _matchToken(String matchStr, int i) throws IOException",
        "protected void _reportInvalidToken(String matchedPart) throws IOException",
        "protected void _reportInvalidToken(String matchedPart, String msg) throws IOException",
        "private final int _skipWS() throws IOException",
        "private int _skipWSOrEnd() throws IOException",
        "private int _skipColon() throws IOException",
        "private void _skipComment() throws IOException",
        "private void _skipCComment() throws IOException",
        "private boolean _skipYAMLComment() throws IOException",
        "private void _skipLine() throws IOException",
        "protected char _decodeEscaped() throws IOException",
        "protected int _decodeCharForError(int firstByte) throws IOException",
        "private int _decodeUtf8_2(int c) throws IOException",
        "private int _decodeUtf8_3(int c1) throws IOException",
        "private int _decodeUtf8_3fast(int c1) throws IOException",
        "private int _decodeUtf8_4(int c) throws IOException",
        "private void _skipUtf8_2(int c) throws IOException",
        "private void _skipUtf8_3(int c) throws IOException",
        "private void _skipUtf8_4(int c) throws IOException",
        "protected void _skipCR() throws IOException",
        "private int nextByte() throws IOException",
        "protected void _reportInvalidChar(int c) throws JsonParseException",
        "protected void _reportInvalidInitial(int mask) throws JsonParseException",
        "protected void _reportInvalidOther(int mask) throws JsonParseException",
        "protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException",
        "public static int[] growArrayBy(int[] arr, int more)",
        "protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException"
      ],
      "fixed_signatures": [
        "public ObjectCodec getCodec()",
        "public void setCodec(ObjectCodec c)",
        "public int releaseBuffered(OutputStream out) throws IOException",
        "public Object getInputSource()",
        "protected boolean loadMore() throws IOException",
        "protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException",
        "protected void _closeInput() throws IOException",
        "protected void _releaseBuffers() throws IOException",
        "public String getText() throws IOException, JsonParseException",
        "public String getValueAsString() throws IOException, JsonParseException",
        "public String getValueAsString(String defValue) throws IOException, JsonParseException",
        "protected String _getText2(JsonToken t)",
        "public char[] getTextCharacters() throws IOException, JsonParseException",
        "public int getTextLength() throws IOException, JsonParseException",
        "public int getTextOffset() throws IOException, JsonParseException",
        "public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException",
        "public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException",
        "protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException",
        "public JsonToken nextToken() throws IOException, JsonParseException",
        "private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException",
        "private JsonToken _nextAfterName()",
        "public void close() throws IOException",
        "public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException",
        "private void _isNextTokenNameYes() throws IOException, JsonParseException",
        "private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException",
        "public String nextTextValue() throws IOException, JsonParseException",
        "public int nextIntValue(int defaultValue) throws IOException, JsonParseException",
        "public long nextLongValue(long defaultValue) throws IOException, JsonParseException",
        "public Boolean nextBooleanValue() throws IOException, JsonParseException",
        "protected JsonToken _parseNumber(int c) throws IOException, JsonParseException",
        "private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException",
        "private int _verifyNoLeadingZeroes() throws IOException, JsonParseException",
        "private JsonToken _parseFloat(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException",
        "private final void _verifyRootSpace(int ch) throws IOException",
        "protected Name _parseFieldName(int i) throws IOException, JsonParseException",
        "protected Name parseMediumName(int q2, final int[] codes) throws IOException, JsonParseException",
        "protected Name parseLongName(int q) throws IOException, JsonParseException",
        "protected Name slowParseName() throws IOException, JsonParseException",
        "private Name parseName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException",
        "private Name parseName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException",
        "protected Name parseEscapedName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException",
        "protected Name _handleOddName(int ch) throws IOException, JsonParseException",
        "protected Name _parseAposName() throws IOException, JsonParseException",
        "private Name findName(int q1, int lastQuadBytes) throws JsonParseException",
        "private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException",
        "private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException",
        "private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException",
        "protected void _finishString() throws IOException",
        "private void _finishString2(char[] outBuf, int outPtr) throws IOException",
        "protected void _skipString() throws IOException",
        "protected JsonToken _handleUnexpectedValue(int c) throws IOException",
        "protected JsonToken _handleApos() throws IOException",
        "protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException",
        "protected void _matchToken(String matchStr, int i) throws IOException",
        "protected void _reportInvalidToken(String matchedPart) throws IOException",
        "protected void _reportInvalidToken(String matchedPart, String msg) throws IOException",
        "private final int _skipWS() throws IOException",
        "private int _skipWSOrEnd() throws IOException",
        "private int _skipColon() throws IOException",
        "private void _skipComment() throws IOException",
        "private void _skipCComment() throws IOException",
        "private boolean _skipYAMLComment() throws IOException",
        "private void _skipLine() throws IOException",
        "protected char _decodeEscaped() throws IOException",
        "protected int _decodeCharForError(int firstByte) throws IOException",
        "private int _decodeUtf8_2(int c) throws IOException",
        "private int _decodeUtf8_3(int c1) throws IOException",
        "private int _decodeUtf8_3fast(int c1) throws IOException",
        "private int _decodeUtf8_4(int c) throws IOException",
        "private void _skipUtf8_2(int c) throws IOException",
        "private void _skipUtf8_3(int c) throws IOException",
        "private void _skipUtf8_4(int c) throws IOException",
        "protected void _skipCR() throws IOException",
        "private int nextByte() throws IOException",
        "protected void _reportInvalidChar(int c) throws JsonParseException",
        "protected void _reportInvalidInitial(int mask) throws JsonParseException",
        "protected void _reportInvalidOther(int mask) throws JsonParseException",
        "protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException",
        "public static int[] growArrayBy(int[] arr, int more)",
        "protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException"
      ],
      "methods": [
        {
          "buggy_method": "  protected JsonToken _parseNumber(int c) throws IOException, JsonParseException {\n  char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n  int outPtr = 0;\n  boolean negative = (c == INT_MINUS);\n\n  \n  if (negative) {\n  outBuf[outPtr++] = '-';\n  \n  if (_inputPtr >= _inputEnd) {\n  loadMoreGuaranteed();\n  }\n  c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n  \n  if (c < INT_0 || c > INT_9) {\n  return _handleInvalidNumberStart(c, true);\n  }\n  }\n\n  \n  if (c == INT_0) {\n  c = _verifyNoLeadingZeroes();\n  }\n  \n  \n  outBuf[outPtr++] = (char) c;\n  int intLen = 1;\n\n  \n  int end = _inputPtr + outBuf.length;\n  if (end > _inputEnd) {\n  end = _inputEnd;\n  }\n\n  \n  while (true) {\n  if (_inputPtr >= end) {\n  \n  return _parserNumber2(outBuf, outPtr, negative, intLen);\n  }\n  c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n  if (c < INT_0 || c > INT_9) {\n  break;\n  }\n  ++intLen;\n  if (outPtr >= outBuf.length) {\n  outBuf = _textBuffer.finishCurrentSegment();\n  outPtr = 0;\n  }\n  outBuf[outPtr++] = (char) c;\n  }\n  if (c == '.' || c == 'e' || c == 'E') {\n  return _parseFloat(outBuf, outPtr, c, negative, intLen);\n  }\n  \n  --_inputPtr; \n  _textBuffer.setCurrentLength(outPtr);\n  \n\n  \n  return resetInt(negative, intLen);\n  }",
          "fixed_method": "  protected JsonToken _parseNumber(int c) throws IOException, JsonParseException {\n  char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n  int outPtr = 0;\n  boolean negative = (c == INT_MINUS);\n\n  \n  if (negative) {\n  outBuf[outPtr++] = '-';\n  \n  if (_inputPtr >= _inputEnd) {\n  loadMoreGuaranteed();\n  }\n  c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n  \n  if (c < INT_0 || c > INT_9) {\n  return _handleInvalidNumberStart(c, true);\n  }\n  }\n\n  \n  if (c == INT_0) {\n  c = _verifyNoLeadingZeroes();\n  }\n  \n  \n  outBuf[outPtr++] = (char) c;\n  int intLen = 1;\n\n  \n  int end = _inputPtr + outBuf.length;\n  if (end > _inputEnd) {\n  end = _inputEnd;\n  }\n\n  \n  while (true) {\n  if (_inputPtr >= end) {\n  \n  return _parserNumber2(outBuf, outPtr, negative, intLen);\n  }\n  c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n  if (c < INT_0 || c > INT_9) {\n  break;\n  }\n  ++intLen;\n  if (outPtr >= outBuf.length) {\n  outBuf = _textBuffer.finishCurrentSegment();\n  outPtr = 0;\n  }\n  outBuf[outPtr++] = (char) c;\n  }\n  if (c == '.' || c == 'e' || c == 'E') {\n  return _parseFloat(outBuf, outPtr, c, negative, intLen);\n  }\n  \n  --_inputPtr; \n  _textBuffer.setCurrentLength(outPtr);\n  \n  if (_parsingContext.inRoot()) {\n  _verifyRootSpace(c);\n  }\n\n  \n  return resetInt(negative, intLen);\n  }",
          "diff": [
            "@@ -1241,6 +1241,9 @@",
            "         --_inputPtr; // to push back trailing char (comma etc)\n",
            "         _textBuffer.setCurrentLength(outPtr);\n",
            "         // As per #105, need separating space between root values; check here\n",
            "+        if (_parsingContext.inRoot()) {\n",
            "+            _verifyRootSpace(c);\n",
            "+        }\n",
            " \n",
            "         // And there we have it!\n",
            "         return resetInt(negative, intLen);\n"
          ],
          "changed_lines": 3
        },
        {
          "buggy_method": "  private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException {\n  \n  while (true) {\n  if (_inputPtr >= _inputEnd && !loadMore()) {\n  _textBuffer.setCurrentLength(outPtr);\n  return resetInt(negative, intPartLength);\n  }\n  int c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n  if (c > INT_9 || c < INT_0) {\n  if (c == '.' || c == 'e' || c == 'E') {\n  return _parseFloat(outBuf, outPtr, c, negative, intPartLength);\n  }\n  break;\n  }\n  if (outPtr >= outBuf.length) {\n  outBuf = _textBuffer.finishCurrentSegment();\n  outPtr = 0;\n  }\n  outBuf[outPtr++] = (char) c;\n  ++intPartLength;\n  }\n  --_inputPtr; \n  _textBuffer.setCurrentLength(outPtr);\n  \n\n  \n  return resetInt(negative, intPartLength);\n  \n  }",
          "fixed_method": "  private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException {\n  \n  while (true) {\n  if (_inputPtr >= _inputEnd && !loadMore()) {\n  _textBuffer.setCurrentLength(outPtr);\n  return resetInt(negative, intPartLength);\n  }\n  int c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n  if (c > INT_9 || c < INT_0) {\n  if (c == '.' || c == 'e' || c == 'E') {\n  return _parseFloat(outBuf, outPtr, c, negative, intPartLength);\n  }\n  break;\n  }\n  if (outPtr >= outBuf.length) {\n  outBuf = _textBuffer.finishCurrentSegment();\n  outPtr = 0;\n  }\n  outBuf[outPtr++] = (char) c;\n  ++intPartLength;\n  }\n  --_inputPtr; \n  _textBuffer.setCurrentLength(outPtr);\n  \n  if (_parsingContext.inRoot()) {\n  _verifyRootSpace(_inputBuffer[_inputPtr++] & 0xFF);\n  }\n\n  \n  return resetInt(negative, intPartLength);\n  \n  }",
          "diff": [
            "@@ -1277,6 +1280,9 @@",
            "         --_inputPtr; // to push back trailing char (comma etc)\n",
            "         _textBuffer.setCurrentLength(outPtr);\n",
            "         // As per #105, need separating space between root values; check here\n",
            "+        if (_parsingContext.inRoot()) {\n",
            "+            _verifyRootSpace(_inputBuffer[_inputPtr++] & 0xFF);\n",
            "+        }\n",
            " \n",
            "         // And there we have it!\n",
            "         return resetInt(negative, intPartLength);\n"
          ],
          "changed_lines": 3
        },
        {
          "buggy_method": "  private JsonToken _parseFloat(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException {\n  int fractLen = 0;\n  boolean eof = false;\n\n  \n  if (c == '.') { \n  outBuf[outPtr++] = (char) c;\n\n  fract_loop:\n  while (true) {\n  if (_inputPtr >= _inputEnd && !loadMore()) {\n  eof = true;\n  break fract_loop;\n  }\n  c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n  if (c < INT_0 || c > INT_9) {\n  break fract_loop;\n  }\n  ++fractLen;\n  if (outPtr >= outBuf.length) {\n  outBuf = _textBuffer.finishCurrentSegment();\n  outPtr = 0;\n  }\n  outBuf[outPtr++] = (char) c;\n  }\n  \n  if (fractLen == 0) {\n  reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n  }\n  }\n\n  int expLen = 0;\n  if (c == 'e' || c == 'E') { \n  if (outPtr >= outBuf.length) {\n  outBuf = _textBuffer.finishCurrentSegment();\n  outPtr = 0;\n  }\n  outBuf[outPtr++] = (char) c;\n  \n  if (_inputPtr >= _inputEnd) {\n  loadMoreGuaranteed();\n  }\n  c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n  \n  if (c == '-' || c == '+') {\n  if (outPtr >= outBuf.length) {\n  outBuf = _textBuffer.finishCurrentSegment();\n  outPtr = 0;\n  }\n  outBuf[outPtr++] = (char) c;\n  \n  if (_inputPtr >= _inputEnd) {\n  loadMoreGuaranteed();\n  }\n  c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n  }\n\n  exp_loop:\n  while (c <= INT_9 && c >= INT_0) {\n  ++expLen;\n  if (outPtr >= outBuf.length) {\n  outBuf = _textBuffer.finishCurrentSegment();\n  outPtr = 0;\n  }\n  outBuf[outPtr++] = (char) c;\n  if (_inputPtr >= _inputEnd && !loadMore()) {\n  eof = true;\n  break exp_loop;\n  }\n  c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n  }\n  \n  if (expLen == 0) {\n  reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n  }\n  }\n\n  \n  if (!eof) {\n  --_inputPtr;\n  \n  }\n  _textBuffer.setCurrentLength(outPtr);\n\n  \n  return resetFloat(negative, integerPartLength, fractLen, expLen);\n  }",
          "fixed_method": "  private JsonToken _parseFloat(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException {\n  int fractLen = 0;\n  boolean eof = false;\n\n  \n  if (c == '.') { \n  outBuf[outPtr++] = (char) c;\n\n  fract_loop:\n  while (true) {\n  if (_inputPtr >= _inputEnd && !loadMore()) {\n  eof = true;\n  break fract_loop;\n  }\n  c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n  if (c < INT_0 || c > INT_9) {\n  break fract_loop;\n  }\n  ++fractLen;\n  if (outPtr >= outBuf.length) {\n  outBuf = _textBuffer.finishCurrentSegment();\n  outPtr = 0;\n  }\n  outBuf[outPtr++] = (char) c;\n  }\n  \n  if (fractLen == 0) {\n  reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n  }\n  }\n\n  int expLen = 0;\n  if (c == 'e' || c == 'E') { \n  if (outPtr >= outBuf.length) {\n  outBuf = _textBuffer.finishCurrentSegment();\n  outPtr = 0;\n  }\n  outBuf[outPtr++] = (char) c;\n  \n  if (_inputPtr >= _inputEnd) {\n  loadMoreGuaranteed();\n  }\n  c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n  \n  if (c == '-' || c == '+') {\n  if (outPtr >= outBuf.length) {\n  outBuf = _textBuffer.finishCurrentSegment();\n  outPtr = 0;\n  }\n  outBuf[outPtr++] = (char) c;\n  \n  if (_inputPtr >= _inputEnd) {\n  loadMoreGuaranteed();\n  }\n  c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n  }\n\n  exp_loop:\n  while (c <= INT_9 && c >= INT_0) {\n  ++expLen;\n  if (outPtr >= outBuf.length) {\n  outBuf = _textBuffer.finishCurrentSegment();\n  outPtr = 0;\n  }\n  outBuf[outPtr++] = (char) c;\n  if (_inputPtr >= _inputEnd && !loadMore()) {\n  eof = true;\n  break exp_loop;\n  }\n  c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n  }\n  \n  if (expLen == 0) {\n  reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n  }\n  }\n\n  \n  if (!eof) {\n  --_inputPtr;\n  \n  if (_parsingContext.inRoot()) {\n  _verifyRootSpace(c);\n  }\n  }\n  _textBuffer.setCurrentLength(outPtr);\n\n  \n  return resetFloat(negative, integerPartLength, fractLen, expLen);\n  }",
          "diff": [
            "@@ -1404,6 +1410,9 @@",
            "         if (!eof) {\n",
            "             --_inputPtr;\n",
            "             // As per #105, need separating space between root values; check here\n",
            "+            if (_parsingContext.inRoot()) {\n",
            "+                _verifyRootSpace(c);\n",
            "+            }\n",
            "         }\n",
            "         _textBuffer.setCurrentLength(outPtr);\n",
            " \n",
            "@@ -1418,8 +1427,25 @@",
            "      * NOTE: caller MUST ensure there is at least one character available;\n",
            "      * and that input pointer is AT given char (not past)\n",
            "      */\n",
            "+    private final void _verifyRootSpace(int ch) throws IOException\n",
            "+    {\n",
            "         // caller had pushed it back, before calling; reset\n",
            "+        ++_inputPtr;\n",
            "         // TODO? Handle UTF-8 char decoding for error reporting\n",
            "+        switch (ch) {\n",
            "+        case ' ':\n",
            "+        case '\\t':\n",
            "+            return;\n",
            "+        case '\\r':\n",
            "+            _skipCR();\n",
            "+            return;\n",
            "+        case '\\n':\n",
            "+            ++_currInputRow;\n",
            "+            _currInputRowStart = _inputPtr;\n",
            "+            return;\n",
            "+        }\n",
            "+        _reportMissingRootWS(ch);\n",
            "+    }\n",
            " \n",
            "     /*\n",
            "     /**********************************************************\n"
          ],
          "changed_lines": 20
        },
        {
          "buggy_method": "  private int _skipWSOrEnd() throws IOException {\n  final int[] codes = _icWS;\n  while ((_inputPtr < _inputEnd) || loadMore()) {\n  final int i = _inputBuffer[_inputPtr++] & 0xFF;\n  switch (codes[i]) {\n  case 0: \n  return i;\n  case 1: \n  continue;\n  case 2: \n  _skipUtf8_2(i);\n  break;\n  case 3: \n  _skipUtf8_3(i);\n  break;\n  case 4: \n  _skipUtf8_4(i);\n  break;\n  case INT_LF:\n  ++_currInputRow;\n  _currInputRowStart = _inputPtr;\n  break;\n  case INT_CR:\n  _skipCR();\n  break;\n  case '/':\n  _skipComment();\n  break;\n  case '#':\n  if (!_skipYAMLComment()) {\n  return i;\n  }\n  break;\n  default: \n  if (i < 32) {\n  _throwInvalidSpace(i);\n  }\n  _reportInvalidChar(i);\n  }\n  }\n  \n  _handleEOF();\n  return -1;\n  }",
          "fixed_method": "  private int _skipWSOrEnd() throws IOException {\n  final int[] codes = _icWS;\n  while ((_inputPtr < _inputEnd) || loadMore()) {\n  final int i = _inputBuffer[_inputPtr++] & 0xFF;\n  switch (codes[i]) {\n  case 0: \n  return i;\n  case 1: \n  continue;\n  case 2: \n  _skipUtf8_2(i);\n  break;\n  case 3: \n  _skipUtf8_3(i);\n  break;\n  case 4: \n  _skipUtf8_4(i);\n  break;\n  case INT_LF:\n  ++_currInputRow;\n  _currInputRowStart = _inputPtr;\n  break;\n  case INT_CR:\n  _skipCR();\n  break;\n  case '/':\n  _skipComment();\n  break;\n  case '#':\n  if (!_skipYAMLComment()) {\n  return i;\n  }\n  break;\n  default: \n  _reportInvalidChar(i);\n  }\n  }\n  \n  _handleEOF();\n  return -1;\n  }",
          "diff": [
            "@@ -2572,9 +2598,6 @@",
            "                 }\n",
            "                 break;\n",
            "             default: // e.g. -1\n",
            "-                if (i < 32) {\n",
            "-                    _throwInvalidSpace(i);\n",
            "-                }\n",
            "                 _reportInvalidChar(i);\n",
            "             }\n",
            "         }\n"
          ],
          "changed_lines": 3
        }
      ]
    }
  ]
}
