{
  "bug_id": "1",
  "failed_tests": {
    "org.apache.commons.compress.archivers.CpioTestCase": [
      {
        "methodName": "testCpioUnarchive",
        "error": "java.io.EOFException",
        "message": "",
        "fail_line": "        while ((entry = in.getNextEntry()) != null) {",
        "test_source": "  public void testCpioUnarchive() throws Exception {\n  final File output = new File(dir, \"bla.cpio\");\n  {\n  final File file1 = getFile(\"test1.xml\");\n  final File file2 = getFile(\"test2.xml\");\n\n  final OutputStream out = new FileOutputStream(output);\n  final ArchiveOutputStream os = new ArchiveStreamFactory().createArchiveOutputStream(\"cpio\", out);\n  os.putArchiveEntry(new CpioArchiveEntry(\"test1.xml\", file1.length()));\n  IOUtils.copy(new FileInputStream(file1), os);\n  os.closeArchiveEntry();\n\n  os.putArchiveEntry(new CpioArchiveEntry(\"test2.xml\", file2.length()));\n  IOUtils.copy(new FileInputStream(file2), os);\n  os.closeArchiveEntry();\n\n  os.close();\n  out.close();\n  }\n\n  // Unarchive Operation\n  final File input = output;\n  final InputStream is = new FileInputStream(input);\n  final ArchiveInputStream in = new ArchiveStreamFactory().createArchiveInputStream(\"cpio\", is);\n\n\n  Map result = new HashMap();\n  ArchiveEntry entry = null;\n  while ((entry = in.getNextEntry()) != null) {\n  File target = new File(dir, entry.getName());\n  final OutputStream out = new FileOutputStream(target);\n  IOUtils.copy(in, out);\n  out.close();\n  result.put(entry.getName(), target);\n  }\n  in.close();\n\n  int lineSepLength = System.getProperty(\"line.separator\").length();\n\n  File t = (File)result.get(\"test1.xml\");\n  assertTrue(\"Expected \" + t.getAbsolutePath() + \" to exist\", t.exists());\n  assertEquals(\"length of \" + t.getAbsolutePath(),\n  72 + 4 * lineSepLength, t.length());\n\n  t = (File)result.get(\"test2.xml\");\n  assertTrue(\"Expected \" + t.getAbsolutePath() + \" to exist\", t.exists());\n  assertEquals(\"length of \" + t.getAbsolutePath(),\n  73 + 5 * lineSepLength, t.length());\n  }",
        "stack": [
          "CpioArchiveInputStream.readFully line 293, CpioArchiveInputStream.getNextCPIOEntry line 168, CpioArchiveInputStream.getNextEntry line 421, CpioTestCase.testCpioUnarchive line 82"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java",
      "buggy_full_code": "\npackage org.apache.commons.compress.archivers.cpio;\n\nimport java.io.FilterOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.util.HashMap;\n\nimport org.apache.commons.compress.archivers.ArchiveEntry;\nimport org.apache.commons.compress.archivers.ArchiveOutputStream;\n\n\npublic class CpioArchiveOutputStream extends ArchiveOutputStream implements\n        CpioConstants {\n\n    private CpioArchiveEntry cpioEntry;\n\n    private boolean closed = false;\n\n    private boolean finished;\n\n    private short entryFormat = FORMAT_NEW;\n\n    private final HashMap names = new HashMap();\n\n    private long crc = 0;\n\n    private long written;\n\n    private final OutputStream out;\n\n    \n    public CpioArchiveOutputStream(final OutputStream out, final short format) {\n        this.out = new FilterOutputStream(out);\n        setFormat(format);\n    }\n\n    \n    public CpioArchiveOutputStream(final OutputStream out) {\n        this(out, FORMAT_NEW);\n    }\n\n    \n    private void ensureOpen() throws IOException {\n        if (this.closed) {\n            throw new IOException(\"Stream closed\");\n        }\n    }\n\n    \n    private void setFormat(final short format) {\n        switch (format) {\n        case FORMAT_NEW:\n        case FORMAT_NEW_CRC:\n        case FORMAT_OLD_ASCII:\n        case FORMAT_OLD_BINARY:\n            break;\n        default:\n            throw new IllegalArgumentException(\"Unknown header type\");\n\n        }\n        synchronized (this) {\n            this.entryFormat = format;\n        }\n    }\n\n    \n    public void putNextEntry(final CpioArchiveEntry e) throws IOException {\n        ensureOpen();\n        if (this.cpioEntry != null) {\n            closeArchiveEntry(); \n        }\n        if (e.getTime() == -1) {\n            e.setTime(System.currentTimeMillis());\n        }\n\n        \n        \n        if (e.getFormat() == -1) {\n            e.setFormat(this.entryFormat);\n        }\n\n        if (this.names.put(e.getName(), e) != null) {\n            throw new IOException(\"duplicate entry: \" + e.getName());\n        }\n\n        writeHeader(e);\n        this.cpioEntry = e;\n        this.written = 0;\n    }\n\n    private void writeHeader(final CpioArchiveEntry e) throws IOException {\n        switch (e.getFormat()) {\n        case FORMAT_NEW:\n            out.write(MAGIC_NEW.getBytes());\n            writeNewEntry(e);\n            break;\n        case FORMAT_NEW_CRC:\n            out.write(MAGIC_NEW_CRC.getBytes());\n            writeNewEntry(e);\n            break;\n        case FORMAT_OLD_ASCII:\n            out.write(MAGIC_OLD_ASCII.getBytes());\n            writeOldAsciiEntry(e);\n            break;\n        case FORMAT_OLD_BINARY:\n            boolean swapHalfWord = true;\n            writeBinaryLong(MAGIC_OLD_BINARY, 2, swapHalfWord);\n            writeOldBinaryEntry(e, swapHalfWord);\n            break;\n        }\n    }\n\n    private void writeNewEntry(final CpioArchiveEntry entry) throws IOException {\n        writeAsciiLong(entry.getInode(), 8, 16);\n        writeAsciiLong(entry.getMode(), 8, 16);\n        writeAsciiLong(entry.getUID(), 8, 16);\n        writeAsciiLong(entry.getGID(), 8, 16);\n        writeAsciiLong(entry.getNumberOfLinks(), 8, 16);\n        writeAsciiLong(entry.getTime(), 8, 16);\n        writeAsciiLong(entry.getSize(), 8, 16);\n        writeAsciiLong(entry.getDeviceMaj(), 8, 16);\n        writeAsciiLong(entry.getDeviceMin(), 8, 16);\n        writeAsciiLong(entry.getRemoteDeviceMaj(), 8, 16);\n        writeAsciiLong(entry.getRemoteDeviceMin(), 8, 16);\n        writeAsciiLong(entry.getName().length() + 1, 8, 16);\n        writeAsciiLong(entry.getChksum(), 8, 16);\n        writeCString(entry.getName());\n        pad(entry.getHeaderSize() + entry.getName().length() + 1, 4);\n    }\n\n    private void writeOldAsciiEntry(final CpioArchiveEntry entry)\n            throws IOException {\n        writeAsciiLong(entry.getDevice(), 6, 8);\n        writeAsciiLong(entry.getInode(), 6, 8);\n        writeAsciiLong(entry.getMode(), 6, 8);\n        writeAsciiLong(entry.getUID(), 6, 8);\n        writeAsciiLong(entry.getGID(), 6, 8);\n        writeAsciiLong(entry.getNumberOfLinks(), 6, 8);\n        writeAsciiLong(entry.getRemoteDevice(), 6, 8);\n        writeAsciiLong(entry.getTime(), 11, 8);\n        writeAsciiLong(entry.getName().length() + 1, 6, 8);\n        writeAsciiLong(entry.getSize(), 11, 8);\n        writeCString(entry.getName());\n    }\n\n    private void writeOldBinaryEntry(final CpioArchiveEntry entry,\n            final boolean swapHalfWord) throws IOException {\n        writeBinaryLong(entry.getDevice(), 2, swapHalfWord);\n        writeBinaryLong(entry.getInode(), 2, swapHalfWord);\n        writeBinaryLong(entry.getMode(), 2, swapHalfWord);\n        writeBinaryLong(entry.getUID(), 2, swapHalfWord);\n        writeBinaryLong(entry.getGID(), 2, swapHalfWord);\n        writeBinaryLong(entry.getNumberOfLinks(), 2, swapHalfWord);\n        writeBinaryLong(entry.getRemoteDevice(), 2, swapHalfWord);\n        writeBinaryLong(entry.getTime(), 4, swapHalfWord);\n        writeBinaryLong(entry.getName().length() + 1, 2, swapHalfWord);\n        writeBinaryLong(entry.getSize(), 4, swapHalfWord);\n        writeCString(entry.getName());\n        pad(entry.getHeaderSize() + entry.getName().length() + 1, 2);\n    }\n\n    \n    public void closeArchiveEntry() throws IOException {\n        ensureOpen();\n\n        if (this.cpioEntry.getSize() != this.written) {\n            throw new IOException(\"invalid entry size (expected \"\n                    + this.cpioEntry.getSize() + \" but got \" + this.written\n                    + \" bytes)\");\n        }\n        if ((this.cpioEntry.getFormat() | FORMAT_NEW_MASK) == FORMAT_NEW_MASK) {\n            pad(this.cpioEntry.getSize(), 4);\n        } else if ((this.cpioEntry.getFormat() | FORMAT_OLD_BINARY) == FORMAT_OLD_BINARY) {\n            pad(this.cpioEntry.getSize(), 2);\n        }\n        if ((this.cpioEntry.getFormat() | FORMAT_NEW_CRC) == FORMAT_NEW_CRC) {\n            if (this.crc != this.cpioEntry.getChksum()) {\n                throw new IOException(\"CRC Error\");\n            }\n        }\n        this.cpioEntry = null;\n        this.crc = 0;\n        this.written = 0;\n    }\n\n    \n    public void write(final byte[] b, final int off, final int len)\n            throws IOException {\n        ensureOpen();\n        if (off < 0 || len < 0 || off > b.length - len) {\n            throw new IndexOutOfBoundsException();\n        } else if (len == 0) {\n            return;\n        }\n\n        if (this.cpioEntry == null) {\n            throw new IOException(\"no current CPIO entry\");\n        }\n        if (this.written + len > this.cpioEntry.getSize()) {\n            throw new IOException(\"attempt to write past end of STORED entry\");\n        }\n        out.write(b, off, len);\n        this.written += len;\n        if ((this.cpioEntry.getFormat() | FORMAT_NEW_CRC) == FORMAT_NEW_CRC) {\n            for (int pos = 0; pos < len; pos++) {\n                this.crc += b[pos] & 0xFF;\n            }\n        }\n    }\n\n    \n    public void finish() throws IOException {\n        ensureOpen();\n\n        if (this.finished) {\n            return;\n        }\n        if (this.cpioEntry != null) {\n            closeArchiveEntry();\n        }\n        this.cpioEntry = new CpioArchiveEntry(this.entryFormat);\n        this.cpioEntry.setMode(0);\n        this.cpioEntry.setName(\"TRAILER!!!\");\n        this.cpioEntry.setNumberOfLinks(1);\n        writeHeader(this.cpioEntry);\n        closeArchiveEntry();\n    }\n\n    \n    public void close() throws IOException {\n        if (!this.closed) {\n            super.close();\n            this.closed = true;\n        }\n    }\n\n    private void pad(final long count, final int border) throws IOException {\n        long skip = count % border;\n        if (skip > 0) {\n            byte tmp[] = new byte[(int) (border - skip)];\n            out.write(tmp);\n        }\n    }\n\n    private void writeBinaryLong(final long number, final int length,\n            final boolean swapHalfWord) throws IOException {\n        byte tmp[] = CpioUtil.long2byteArray(number, length, swapHalfWord);\n        out.write(tmp);\n    }\n\n    private void writeAsciiLong(final long number, final int length,\n            final int radix) throws IOException {\n        StringBuffer tmp = new StringBuffer();\n        String tmpStr;\n        if (radix == 16) {\n            tmp.append(Long.toHexString(number));\n        } else if (radix == 8) {\n            tmp.append(Long.toOctalString(number));\n        } else {\n            tmp.append(Long.toString(number));\n        }\n\n        if (tmp.length() <= length) {\n            long insertLength = length - tmp.length();\n            for (int pos = 0; pos < insertLength; pos++) {\n                tmp.insert(0, \"0\");\n            }\n            tmpStr = tmp.toString();\n        } else {\n            tmpStr = tmp.substring(tmp.length() - length);\n        }\n        out.write(tmpStr.getBytes());\n    }\n\n    private void writeCString(final String str) throws IOException {\n        out.write(str.getBytes());\n        out.write('\\0');\n    }\n\n    \n    public void putArchiveEntry(ArchiveEntry entry) throws IOException {\n        this.putNextEntry((CpioArchiveEntry) entry);\n    }\n\n    \n    public void write(int b) throws IOException {\n        out.write(b);\n    }\n}\n",
      "fixed_full_code": "\npackage org.apache.commons.compress.archivers.cpio;\n\nimport java.io.FilterOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.util.HashMap;\n\nimport org.apache.commons.compress.archivers.ArchiveEntry;\nimport org.apache.commons.compress.archivers.ArchiveOutputStream;\n\n\npublic class CpioArchiveOutputStream extends ArchiveOutputStream implements\n        CpioConstants {\n\n    private CpioArchiveEntry cpioEntry;\n\n    private boolean closed = false;\n\n    private boolean finished;\n\n    private short entryFormat = FORMAT_NEW;\n\n    private final HashMap names = new HashMap();\n\n    private long crc = 0;\n\n    private long written;\n\n    private final OutputStream out;\n\n    \n    public CpioArchiveOutputStream(final OutputStream out, final short format) {\n        this.out = new FilterOutputStream(out);\n        setFormat(format);\n    }\n\n    \n    public CpioArchiveOutputStream(final OutputStream out) {\n        this(out, FORMAT_NEW);\n    }\n\n    \n    private void ensureOpen() throws IOException {\n        if (this.closed) {\n            throw new IOException(\"Stream closed\");\n        }\n    }\n\n    \n    private void setFormat(final short format) {\n        switch (format) {\n        case FORMAT_NEW:\n        case FORMAT_NEW_CRC:\n        case FORMAT_OLD_ASCII:\n        case FORMAT_OLD_BINARY:\n            break;\n        default:\n            throw new IllegalArgumentException(\"Unknown header type\");\n\n        }\n        synchronized (this) {\n            this.entryFormat = format;\n        }\n    }\n\n    \n    public void putNextEntry(final CpioArchiveEntry e) throws IOException {\n        ensureOpen();\n        if (this.cpioEntry != null) {\n            closeArchiveEntry(); \n        }\n        if (e.getTime() == -1) {\n            e.setTime(System.currentTimeMillis());\n        }\n\n        \n        \n        if (e.getFormat() == -1) {\n            e.setFormat(this.entryFormat);\n        }\n\n        if (this.names.put(e.getName(), e) != null) {\n            throw new IOException(\"duplicate entry: \" + e.getName());\n        }\n\n        writeHeader(e);\n        this.cpioEntry = e;\n        this.written = 0;\n    }\n\n    private void writeHeader(final CpioArchiveEntry e) throws IOException {\n        switch (e.getFormat()) {\n        case FORMAT_NEW:\n            out.write(MAGIC_NEW.getBytes());\n            writeNewEntry(e);\n            break;\n        case FORMAT_NEW_CRC:\n            out.write(MAGIC_NEW_CRC.getBytes());\n            writeNewEntry(e);\n            break;\n        case FORMAT_OLD_ASCII:\n            out.write(MAGIC_OLD_ASCII.getBytes());\n            writeOldAsciiEntry(e);\n            break;\n        case FORMAT_OLD_BINARY:\n            boolean swapHalfWord = true;\n            writeBinaryLong(MAGIC_OLD_BINARY, 2, swapHalfWord);\n            writeOldBinaryEntry(e, swapHalfWord);\n            break;\n        }\n    }\n\n    private void writeNewEntry(final CpioArchiveEntry entry) throws IOException {\n        writeAsciiLong(entry.getInode(), 8, 16);\n        writeAsciiLong(entry.getMode(), 8, 16);\n        writeAsciiLong(entry.getUID(), 8, 16);\n        writeAsciiLong(entry.getGID(), 8, 16);\n        writeAsciiLong(entry.getNumberOfLinks(), 8, 16);\n        writeAsciiLong(entry.getTime(), 8, 16);\n        writeAsciiLong(entry.getSize(), 8, 16);\n        writeAsciiLong(entry.getDeviceMaj(), 8, 16);\n        writeAsciiLong(entry.getDeviceMin(), 8, 16);\n        writeAsciiLong(entry.getRemoteDeviceMaj(), 8, 16);\n        writeAsciiLong(entry.getRemoteDeviceMin(), 8, 16);\n        writeAsciiLong(entry.getName().length() + 1, 8, 16);\n        writeAsciiLong(entry.getChksum(), 8, 16);\n        writeCString(entry.getName());\n        pad(entry.getHeaderSize() + entry.getName().length() + 1, 4);\n    }\n\n    private void writeOldAsciiEntry(final CpioArchiveEntry entry)\n            throws IOException {\n        writeAsciiLong(entry.getDevice(), 6, 8);\n        writeAsciiLong(entry.getInode(), 6, 8);\n        writeAsciiLong(entry.getMode(), 6, 8);\n        writeAsciiLong(entry.getUID(), 6, 8);\n        writeAsciiLong(entry.getGID(), 6, 8);\n        writeAsciiLong(entry.getNumberOfLinks(), 6, 8);\n        writeAsciiLong(entry.getRemoteDevice(), 6, 8);\n        writeAsciiLong(entry.getTime(), 11, 8);\n        writeAsciiLong(entry.getName().length() + 1, 6, 8);\n        writeAsciiLong(entry.getSize(), 11, 8);\n        writeCString(entry.getName());\n    }\n\n    private void writeOldBinaryEntry(final CpioArchiveEntry entry,\n            final boolean swapHalfWord) throws IOException {\n        writeBinaryLong(entry.getDevice(), 2, swapHalfWord);\n        writeBinaryLong(entry.getInode(), 2, swapHalfWord);\n        writeBinaryLong(entry.getMode(), 2, swapHalfWord);\n        writeBinaryLong(entry.getUID(), 2, swapHalfWord);\n        writeBinaryLong(entry.getGID(), 2, swapHalfWord);\n        writeBinaryLong(entry.getNumberOfLinks(), 2, swapHalfWord);\n        writeBinaryLong(entry.getRemoteDevice(), 2, swapHalfWord);\n        writeBinaryLong(entry.getTime(), 4, swapHalfWord);\n        writeBinaryLong(entry.getName().length() + 1, 2, swapHalfWord);\n        writeBinaryLong(entry.getSize(), 4, swapHalfWord);\n        writeCString(entry.getName());\n        pad(entry.getHeaderSize() + entry.getName().length() + 1, 2);\n    }\n\n    \n    public void closeArchiveEntry() throws IOException {\n        ensureOpen();\n\n        if (this.cpioEntry.getSize() != this.written) {\n            throw new IOException(\"invalid entry size (expected \"\n                    + this.cpioEntry.getSize() + \" but got \" + this.written\n                    + \" bytes)\");\n        }\n        if ((this.cpioEntry.getFormat() | FORMAT_NEW_MASK) == FORMAT_NEW_MASK) {\n            pad(this.cpioEntry.getSize(), 4);\n        } else if ((this.cpioEntry.getFormat() | FORMAT_OLD_BINARY) == FORMAT_OLD_BINARY) {\n            pad(this.cpioEntry.getSize(), 2);\n        }\n        if ((this.cpioEntry.getFormat() | FORMAT_NEW_CRC) == FORMAT_NEW_CRC) {\n            if (this.crc != this.cpioEntry.getChksum()) {\n                throw new IOException(\"CRC Error\");\n            }\n        }\n        this.cpioEntry = null;\n        this.crc = 0;\n        this.written = 0;\n    }\n\n    \n    public void write(final byte[] b, final int off, final int len)\n            throws IOException {\n        ensureOpen();\n        if (off < 0 || len < 0 || off > b.length - len) {\n            throw new IndexOutOfBoundsException();\n        } else if (len == 0) {\n            return;\n        }\n\n        if (this.cpioEntry == null) {\n            throw new IOException(\"no current CPIO entry\");\n        }\n        if (this.written + len > this.cpioEntry.getSize()) {\n            throw new IOException(\"attempt to write past end of STORED entry\");\n        }\n        out.write(b, off, len);\n        this.written += len;\n        if ((this.cpioEntry.getFormat() | FORMAT_NEW_CRC) == FORMAT_NEW_CRC) {\n            for (int pos = 0; pos < len; pos++) {\n                this.crc += b[pos] & 0xFF;\n            }\n        }\n    }\n\n    \n    public void finish() throws IOException {\n        ensureOpen();\n\n        if (this.finished) {\n            return;\n        }\n        if (this.cpioEntry != null) {\n            closeArchiveEntry();\n        }\n        this.cpioEntry = new CpioArchiveEntry(this.entryFormat);\n        this.cpioEntry.setMode(0);\n        this.cpioEntry.setName(\"TRAILER!!!\");\n        this.cpioEntry.setNumberOfLinks(1);\n        writeHeader(this.cpioEntry);\n        closeArchiveEntry();\n    }\n\n    \n    public void close() throws IOException {\n        if (!this.closed) {\n            this.finish();\n            super.close();\n            this.closed = true;\n        }\n    }\n\n    private void pad(final long count, final int border) throws IOException {\n        long skip = count % border;\n        if (skip > 0) {\n            byte tmp[] = new byte[(int) (border - skip)];\n            out.write(tmp);\n        }\n    }\n\n    private void writeBinaryLong(final long number, final int length,\n            final boolean swapHalfWord) throws IOException {\n        byte tmp[] = CpioUtil.long2byteArray(number, length, swapHalfWord);\n        out.write(tmp);\n    }\n\n    private void writeAsciiLong(final long number, final int length,\n            final int radix) throws IOException {\n        StringBuffer tmp = new StringBuffer();\n        String tmpStr;\n        if (radix == 16) {\n            tmp.append(Long.toHexString(number));\n        } else if (radix == 8) {\n            tmp.append(Long.toOctalString(number));\n        } else {\n            tmp.append(Long.toString(number));\n        }\n\n        if (tmp.length() <= length) {\n            long insertLength = length - tmp.length();\n            for (int pos = 0; pos < insertLength; pos++) {\n                tmp.insert(0, \"0\");\n            }\n            tmpStr = tmp.toString();\n        } else {\n            tmpStr = tmp.substring(tmp.length() - length);\n        }\n        out.write(tmpStr.getBytes());\n    }\n\n    private void writeCString(final String str) throws IOException {\n        out.write(str.getBytes());\n        out.write('\\0');\n    }\n\n    \n    public void putArchiveEntry(ArchiveEntry entry) throws IOException {\n        this.putNextEntry((CpioArchiveEntry) entry);\n    }\n\n    \n    public void write(int b) throws IOException {\n        out.write(b);\n    }\n}\n",
      "buggy_signatures": [
        "private final HashMap names = new HashMap()",
        "public CpioArchiveOutputStream(final OutputStream out, final short format)",
        "public CpioArchiveOutputStream(final OutputStream out)",
        "private void ensureOpen() throws IOException",
        "private void setFormat(final short format)",
        "synchronized (this)",
        "public void putNextEntry(final CpioArchiveEntry e) throws IOException",
        "private void writeHeader(final CpioArchiveEntry e) throws IOException",
        "private void writeNewEntry(final CpioArchiveEntry entry) throws IOException",
        "private void writeOldAsciiEntry(final CpioArchiveEntry entry)",
        "private void writeOldBinaryEntry(final CpioArchiveEntry entry, final boolean swapHalfWord) throws IOException",
        "public void closeArchiveEntry() throws IOException",
        "public void write(final byte[] b, final int off, final int len)",
        "public void finish() throws IOException",
        "public void close() throws IOException",
        "private void pad(final long count, final int border) throws IOException",
        "private void writeBinaryLong(final long number, final int length, final boolean swapHalfWord) throws IOException",
        "private void writeAsciiLong(final long number, final int length, final int radix) throws IOException",
        "private void writeCString(final String str) throws IOException",
        "public void putArchiveEntry(ArchiveEntry entry) throws IOException",
        "public void write(int b) throws IOException"
      ],
      "fixed_signatures": [
        "private final HashMap names = new HashMap()",
        "public CpioArchiveOutputStream(final OutputStream out, final short format)",
        "public CpioArchiveOutputStream(final OutputStream out)",
        "private void ensureOpen() throws IOException",
        "private void setFormat(final short format)",
        "synchronized (this)",
        "public void putNextEntry(final CpioArchiveEntry e) throws IOException",
        "private void writeHeader(final CpioArchiveEntry e) throws IOException",
        "private void writeNewEntry(final CpioArchiveEntry entry) throws IOException",
        "private void writeOldAsciiEntry(final CpioArchiveEntry entry)",
        "private void writeOldBinaryEntry(final CpioArchiveEntry entry, final boolean swapHalfWord) throws IOException",
        "public void closeArchiveEntry() throws IOException",
        "public void write(final byte[] b, final int off, final int len)",
        "public void finish() throws IOException",
        "public void close() throws IOException",
        "private void pad(final long count, final int border) throws IOException",
        "private void writeBinaryLong(final long number, final int length, final boolean swapHalfWord) throws IOException",
        "private void writeAsciiLong(final long number, final int length, final int radix) throws IOException",
        "private void writeCString(final String str) throws IOException",
        "public void putArchiveEntry(ArchiveEntry entry) throws IOException",
        "public void write(int b) throws IOException"
      ],
      "methods": [
        {
          "buggy_method": "  public void close() throws IOException {\n  if (!this.closed) {\n  super.close();\n  this.closed = true;\n  }\n  }",
          "fixed_method": "  public void close() throws IOException {\n  if (!this.closed) {\n  this.finish();\n  super.close();\n  this.closed = true;\n  }\n  }",
          "diff": [
            "@@ -343,6 +343,7 @@",
            "      */\n",
            "     public void close() throws IOException {\n",
            "         if (!this.closed) {\n",
            "+            this.finish();\n",
            "             super.close();\n",
            "             this.closed = true;\n",
            "         }\n"
          ],
          "changed_lines": 1
        }
      ]
    }
  ]
}