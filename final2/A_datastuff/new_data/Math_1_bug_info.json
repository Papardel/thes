{
  "bug_id": "1",
  "failed_tests": {
    "org.apache.commons.math3.fraction.BigFractionTest": [
      {
        "methodName": "testDigitLimitConstructor",
        "error": "org.apache.commons.math3.fraction.FractionConversionException",
        "message": "illegal state: Overflow trying to convert 0.5 to fraction (2,499,999,794/4,999,999,587)",
        "fail_line": "        assertFraction(1, 2, new BigFraction(0.5000000001, 10));",
        "test_source": "  public void testDigitLimitConstructor() throws ConvergenceException {\n  assertFraction(2, 5, new BigFraction(0.4, 9));\n  assertFraction(2, 5, new BigFraction(0.4, 99));\n  assertFraction(2, 5, new BigFraction(0.4, 999));\n\n  assertFraction(3, 5, new BigFraction(0.6152, 9));\n  assertFraction(8, 13, new BigFraction(0.6152, 99));\n  assertFraction(510, 829, new BigFraction(0.6152, 999));\n  assertFraction(769, 1250, new BigFraction(0.6152, 9999));\n  \n  // MATH-996\n  assertFraction(1, 2, new BigFraction(0.5000000001, 10));\n  }",
        "stack": [
          "BigFraction.<init> line 306, BigFraction.<init> line 356, BigFractionTest.testDigitLimitConstructor line 159"
        ]
      }
    ],
    "org.apache.commons.math3.fraction.FractionTest": [
      {
        "methodName": "testDigitLimitConstructor",
        "error": "org.apache.commons.math3.fraction.FractionConversionException",
        "message": "illegal state: Overflow trying to convert 0.5 to fraction (2,499,999,794/4,999,999,587)",
        "fail_line": "        assertFraction(1, 2, new Fraction(0.5000000001, 10));",
        "test_source": "  public void testDigitLimitConstructor() throws ConvergenceException {\n  assertFraction(2, 5, new Fraction(0.4,  9));\n  assertFraction(2, 5, new Fraction(0.4,  99));\n  assertFraction(2, 5, new Fraction(0.4, 999));\n\n  assertFraction(3, 5,  new Fraction(0.6152,  9));\n  assertFraction(8, 13,  new Fraction(0.6152,  99));\n  assertFraction(510, 829,  new Fraction(0.6152,  999));\n  assertFraction(769, 1250, new Fraction(0.6152, 9999));\n\n  // MATH-996\n  assertFraction(1, 2, new Fraction(0.5000000001, 10));\n  }",
        "stack": [
          "Fraction.<init> line 215, Fraction.<init> line 144, FractionTest.testDigitLimitConstructor line 134"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/math3/fraction/BigFraction.java",
      "buggy_full_code": "\npackage org.apache.commons.math3.fraction;\n\nimport java.io.Serializable;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\n\nimport org.apache.commons.math3.FieldElement;\nimport org.apache.commons.math3.exception.MathArithmeticException;\nimport org.apache.commons.math3.exception.MathIllegalArgumentException;\nimport org.apache.commons.math3.exception.NullArgumentException;\nimport org.apache.commons.math3.exception.ZeroException;\nimport org.apache.commons.math3.exception.util.LocalizedFormats;\nimport org.apache.commons.math3.util.ArithmeticUtils;\nimport org.apache.commons.math3.util.FastMath;\nimport org.apache.commons.math3.util.MathUtils;\n\n\npublic class BigFraction extends Number implements FieldElement<BigFraction>, Comparable<BigFraction>, Serializable { public static final BigFraction TWO = new BigFraction(2); public static final BigFraction ONE = new BigFraction(1); public static final BigFraction ZERO = new BigFraction(0); public static final BigFraction MINUS_ONE = new BigFraction(-1); public static final BigFraction FOUR_FIFTHS = new BigFraction(4, 5); public static final BigFraction ONE_FIFTH = new BigFraction(1, 5); public static final BigFraction ONE_HALF = new BigFraction(1, 2); public static final BigFraction ONE_QUARTER = new BigFraction(1, 4); public static final BigFraction ONE_THIRD = new BigFraction(1, 3); public static final BigFraction THREE_FIFTHS = new BigFraction(3, 5); public static final BigFraction THREE_QUARTERS = new BigFraction(3, 4); public static final BigFraction TWO_FIFTHS = new BigFraction(2, 5); public static final BigFraction TWO_QUARTERS = new BigFraction(2, 4); public static final BigFraction TWO_THIRDS = new BigFraction(2, 3); private static final long serialVersionUID = -5630213147331578515L; private static final BigInteger ONE_HUNDRED = BigInteger.valueOf(100); private final BigInteger numerator; private final BigInteger denominator; public BigFraction(final BigInteger num) {\n        this(num, BigInteger.ONE);\n    }\n\n    \n    public BigFraction(BigInteger num, BigInteger den) {\n        MathUtils.checkNotNull(num, LocalizedFormats.NUMERATOR);\n        MathUtils.checkNotNull(den, LocalizedFormats.DENOMINATOR);\n        if (BigInteger.ZERO.equals(den)) {\n            throw new ZeroException(LocalizedFormats.ZERO_DENOMINATOR);\n        }\n        if (BigInteger.ZERO.equals(num)) {\n            numerator   = BigInteger.ZERO;\n            denominator = BigInteger.ONE;\n        } else {\n\n            \n            final BigInteger gcd = num.gcd(den);\n            if (BigInteger.ONE.compareTo(gcd) < 0) {\n                num = num.divide(gcd);\n                den = den.divide(gcd);\n            }\n\n            \n            if (BigInteger.ZERO.compareTo(den) > 0) {\n                num = num.negate();\n                den = den.negate();\n            }\n\n            \n            numerator   = num;\n            denominator = den;\n\n        }\n    }\n\n    \n    public BigFraction(final double value) throws MathIllegalArgumentException {\n        if (Double.isNaN(value)) {\n            throw new MathIllegalArgumentException(LocalizedFormats.NAN_VALUE_CONVERSION);\n        }\n        if (Double.isInfinite(value)) {\n            throw new MathIllegalArgumentException(LocalizedFormats.INFINITE_VALUE_CONVERSION);\n        }\n\n        \n        final long bits     = Double.doubleToLongBits(value);\n        final long sign     = bits & 0x8000000000000000L;\n        final long exponent = bits & 0x7ff0000000000000L;\n        long m              = bits & 0x000fffffffffffffL;\n        if (exponent != 0) {\n            \n            m |= 0x0010000000000000L;\n        }\n        if (sign != 0) {\n            m = -m;\n        }\n        int k = ((int) (exponent >> 52)) - 1075;\n        while (((m & 0x001ffffffffffffeL) != 0) && ((m & 0x1) == 0)) {\n            m = m >> 1;\n            ++k;\n        }\n\n        if (k < 0) {\n            numerator   = BigInteger.valueOf(m);\n            denominator = BigInteger.ZERO.flipBit(-k);\n        } else {\n            numerator   = BigInteger.valueOf(m).multiply(BigInteger.ZERO.flipBit(k));\n            denominator = BigInteger.ONE;\n        }\n\n    }\n\n    \n    public BigFraction(final double value, final double epsilon, final int maxIterations) throws FractionConversionException {\n        this(value, epsilon, Integer.MAX_VALUE, maxIterations);\n    }\n\n    \n    private BigFraction(final double value, final double epsilon, final int maxDenominator, int maxIterations) throws FractionConversionException {\n        long overflow = Integer.MAX_VALUE;\n        double r0 = value;\n        long a0 = (long) FastMath.floor(r0);\n        if (a0 > overflow) {\n            throw new FractionConversionException(value, a0, 1l);\n        }\n\n        \n        \n        if (FastMath.abs(a0 - value) < epsilon) {\n            numerator = BigInteger.valueOf(a0);\n            denominator = BigInteger.ONE;\n            return;\n        }\n\n        long p0 = 1;\n        long q0 = 0;\n        long p1 = a0;\n        long q1 = 1;\n\n        long p2 = 0;\n        long q2 = 1;\n\n        int n = 0;\n        boolean stop = false;\n        do {\n            ++n;\n            final double r1 = 1.0 / (r0 - a0);\n            final long a1 = (long) FastMath.floor(r1);\n            p2 = (a1 * p1) + p0;\n            q2 = (a1 * q1) + q0;\n            if ((p2 > overflow) || (q2 > overflow)) {\n                \n                \n                throw new FractionConversionException(value, p2, q2);\n            }\n\n            final double convergent = (double) p2 / (double) q2;\n            if ((n < maxIterations) &&\n                (FastMath.abs(convergent - value) > epsilon) &&\n                (q2 < maxDenominator)) {\n                p0 = p1;\n                p1 = p2;\n                q0 = q1;\n                q1 = q2;\n                a0 = a1;\n                r0 = r1;\n            } else {\n                stop = true;\n            }\n        } while (!stop);\n\n        if (n >= maxIterations) {\n            throw new FractionConversionException(value, maxIterations);\n        }\n\n        if (q2 < maxDenominator) {\n            numerator   = BigInteger.valueOf(p2);\n            denominator = BigInteger.valueOf(q2);\n        } else {\n            numerator   = BigInteger.valueOf(p1);\n            denominator = BigInteger.valueOf(q1);\n        }\n    }\n\n    \n    public BigFraction(final double value, final int maxDenominator) throws FractionConversionException {\n        this(value, 0, maxDenominator, 100);\n    }\n\n    \n    public BigFraction(final int num) {\n        this(BigInteger.valueOf(num), BigInteger.ONE);\n    }\n\n    \n    public BigFraction(final int num, final int den) {\n        this(BigInteger.valueOf(num), BigInteger.valueOf(den));\n    }\n\n    \n    public BigFraction(final long num) {\n        this(BigInteger.valueOf(num), BigInteger.ONE);\n    }\n\n    \n    public BigFraction(final long num, final long den) {\n        this(BigInteger.valueOf(num), BigInteger.valueOf(den));\n    }\n\n    \n    public static BigFraction getReducedFraction(final int numerator, final int denominator) {\n        if (numerator == 0) {\n            return ZERO; \n        }\n\n        return new BigFraction(numerator, denominator);\n    }\n\n    \n    public BigFraction abs() {\n        return (BigInteger.ZERO.compareTo(numerator) <= 0) ? this : negate();\n    }\n\n    \n    public BigFraction add(final BigInteger bg) throws NullArgumentException {\n        MathUtils.checkNotNull(bg);\n        return new BigFraction(numerator.add(denominator.multiply(bg)), denominator);\n    }\n\n    \n    public BigFraction add(final int i) {\n        return add(BigInteger.valueOf(i));\n    }\n\n    \n    public BigFraction add(final long l) {\n        return add(BigInteger.valueOf(l));\n    }\n\n    \n    public BigFraction add(final BigFraction fraction) {\n        if (fraction == null) {\n            throw new NullArgumentException(LocalizedFormats.FRACTION);\n        }\n        if (ZERO.equals(fraction)) {\n            return this;\n        }\n\n        BigInteger num = null;\n        BigInteger den = null;\n\n        if (denominator.equals(fraction.denominator)) {\n            num = numerator.add(fraction.numerator);\n            den = denominator;\n        } else {\n            num = (numerator.multiply(fraction.denominator)).add((fraction.numerator).multiply(denominator));\n            den = denominator.multiply(fraction.denominator);\n        }\n        return new BigFraction(num, den);\n\n    }\n\n    \n    public BigDecimal bigDecimalValue() {\n        return new BigDecimal(numerator).divide(new BigDecimal(denominator));\n    }\n\n    \n    public BigDecimal bigDecimalValue(final int roundingMode) {\n        return new BigDecimal(numerator).divide(new BigDecimal(denominator), roundingMode);\n    }\n\n    \n    public BigDecimal bigDecimalValue(final int scale, final int roundingMode) {\n        return new BigDecimal(numerator).divide(new BigDecimal(denominator), scale, roundingMode);\n    }\n\n    \n    public int compareTo(final BigFraction object) {\n        BigInteger nOd = numerator.multiply(object.denominator);\n        BigInteger dOn = denominator.multiply(object.numerator);\n        return nOd.compareTo(dOn);\n    }\n\n    \n    public BigFraction divide(final BigInteger bg) {\n        if (bg == null) {\n            throw new NullArgumentException(LocalizedFormats.FRACTION);\n        }\n        if (BigInteger.ZERO.equals(bg)) {\n            throw new MathArithmeticException(LocalizedFormats.ZERO_DENOMINATOR);\n        }\n        return new BigFraction(numerator, denominator.multiply(bg));\n    }\n\n    \n    public BigFraction divide(final int i) {\n        return divide(BigInteger.valueOf(i));\n    }\n\n    \n    public BigFraction divide(final long l) {\n        return divide(BigInteger.valueOf(l));\n    }\n\n    \n    public BigFraction divide(final BigFraction fraction) {\n        if (fraction == null) {\n            throw new NullArgumentException(LocalizedFormats.FRACTION);\n        }\n        if (BigInteger.ZERO.equals(fraction.numerator)) {\n            throw new MathArithmeticException(LocalizedFormats.ZERO_DENOMINATOR);\n        }\n\n        return multiply(fraction.reciprocal());\n    }\n\n    \n    @Override\n    public double doubleValue() {\n        double result = numerator.doubleValue() / denominator.doubleValue();\n        if (Double.isNaN(result)) {\n            \n            \n            int shift = Math.max(numerator.bitLength(),\n                                 denominator.bitLength()) - FastMath.getExponent(Double.MAX_VALUE);\n            result = numerator.shiftRight(shift).doubleValue() /\n                denominator.shiftRight(shift).doubleValue();\n        }\n        return result;\n    }\n\n    \n    @Override\n    public boolean equals(final Object other) {\n        boolean ret = false;\n\n        if (this == other) {\n            ret = true;\n        } else if (other instanceof BigFraction) {\n            BigFraction rhs = ((BigFraction) other).reduce();\n            BigFraction thisOne = this.reduce();\n            ret = thisOne.numerator.equals(rhs.numerator) && thisOne.denominator.equals(rhs.denominator);\n        }\n\n        return ret;\n    }\n\n    \n    @Override\n    public float floatValue() {\n        float result = numerator.floatValue() / denominator.floatValue();\n        if (Double.isNaN(result)) {\n            \n            \n            int shift = Math.max(numerator.bitLength(),\n                                 denominator.bitLength()) - FastMath.getExponent(Float.MAX_VALUE);\n            result = numerator.shiftRight(shift).floatValue() /\n                denominator.shiftRight(shift).floatValue();\n        }\n        return result;\n    }\n\n    \n    public BigInteger getDenominator() {\n        return denominator;\n    }\n\n    \n    public int getDenominatorAsInt() {\n        return denominator.intValue();\n    }\n\n    \n    public long getDenominatorAsLong() {\n        return denominator.longValue();\n    }\n\n    \n    public BigInteger getNumerator() {\n        return numerator;\n    }\n\n    \n    public int getNumeratorAsInt() {\n        return numerator.intValue();\n    }\n\n    \n    public long getNumeratorAsLong() {\n        return numerator.longValue();\n    }\n\n    \n    @Override\n    public int hashCode() {\n        return 37 * (37 * 17 + numerator.hashCode()) + denominator.hashCode();\n    }\n\n    \n    @Override\n    public int intValue() {\n        return numerator.divide(denominator).intValue();\n    }\n\n    \n    @Override\n    public long longValue() {\n        return numerator.divide(denominator).longValue();\n    }\n\n    \n    public BigFraction multiply(final BigInteger bg) {\n        if (bg == null) {\n            throw new NullArgumentException();\n        }\n        return new BigFraction(bg.multiply(numerator), denominator);\n    }\n\n    \n    public BigFraction multiply(final int i) {\n        return multiply(BigInteger.valueOf(i));\n    }\n\n    \n    public BigFraction multiply(final long l) {\n        return multiply(BigInteger.valueOf(l));\n    }\n\n    \n    public BigFraction multiply(final BigFraction fraction) {\n        if (fraction == null) {\n            throw new NullArgumentException(LocalizedFormats.FRACTION);\n        }\n        if (numerator.equals(BigInteger.ZERO) ||\n            fraction.numerator.equals(BigInteger.ZERO)) {\n            return ZERO;\n        }\n        return new BigFraction(numerator.multiply(fraction.numerator),\n                               denominator.multiply(fraction.denominator));\n    }\n\n    \n    public BigFraction negate() {\n        return new BigFraction(numerator.negate(), denominator);\n    }\n\n    \n    public double percentageValue() {\n        return multiply(ONE_HUNDRED).doubleValue();\n    }\n\n    \n    public BigFraction pow(final int exponent) {\n        if (exponent < 0) {\n            return new BigFraction(denominator.pow(-exponent), numerator.pow(-exponent));\n        }\n        return new BigFraction(numerator.pow(exponent), denominator.pow(exponent));\n    }\n\n    \n    public BigFraction pow(final long exponent) {\n        if (exponent < 0) {\n            return new BigFraction(ArithmeticUtils.pow(denominator, -exponent),\n                                   ArithmeticUtils.pow(numerator,   -exponent));\n        }\n        return new BigFraction(ArithmeticUtils.pow(numerator,   exponent),\n                               ArithmeticUtils.pow(denominator, exponent));\n    }\n\n    \n    public BigFraction pow(final BigInteger exponent) {\n        if (exponent.compareTo(BigInteger.ZERO) < 0) {\n            final BigInteger eNeg = exponent.negate();\n            return new BigFraction(ArithmeticUtils.pow(denominator, eNeg),\n                                   ArithmeticUtils.pow(numerator,   eNeg));\n        }\n        return new BigFraction(ArithmeticUtils.pow(numerator,   exponent),\n                               ArithmeticUtils.pow(denominator, exponent));\n    }\n\n    \n    public double pow(final double exponent) {\n        return FastMath.pow(numerator.doubleValue(),   exponent) /\n               FastMath.pow(denominator.doubleValue(), exponent);\n    }\n\n    \n    public BigFraction reciprocal() {\n        return new BigFraction(denominator, numerator);\n    }\n\n    \n    public BigFraction reduce() {\n        final BigInteger gcd = numerator.gcd(denominator);\n        return new BigFraction(numerator.divide(gcd), denominator.divide(gcd));\n    }\n\n    \n    public BigFraction subtract(final BigInteger bg) {\n        if (bg == null) {\n            throw new NullArgumentException();\n        }\n        return new BigFraction(numerator.subtract(denominator.multiply(bg)), denominator);\n    }\n\n    \n    public BigFraction subtract(final int i) {\n        return subtract(BigInteger.valueOf(i));\n    }\n\n    \n    public BigFraction subtract(final long l) {\n        return subtract(BigInteger.valueOf(l));\n    }\n\n    \n    public BigFraction subtract(final BigFraction fraction) {\n        if (fraction == null) {\n            throw new NullArgumentException(LocalizedFormats.FRACTION);\n        }\n        if (ZERO.equals(fraction)) {\n            return this;\n        }\n\n        BigInteger num = null;\n        BigInteger den = null;\n        if (denominator.equals(fraction.denominator)) {\n            num = numerator.subtract(fraction.numerator);\n            den = denominator;\n        } else {\n            num = (numerator.multiply(fraction.denominator)).subtract((fraction.numerator).multiply(denominator));\n            den = denominator.multiply(fraction.denominator);\n        }\n        return new BigFraction(num, den);\n\n    }\n\n    \n    @Override\n    public String toString() {\n        String str = null;\n        if (BigInteger.ONE.equals(denominator)) {\n            str = numerator.toString();\n        } else if (BigInteger.ZERO.equals(numerator)) {\n            str = \"0\";\n        } else {\n            str = numerator + \" / \" + denominator;\n        }\n        return str;\n    }\n\n    \n    public BigFractionField getField() {\n        return BigFractionField.getInstance();\n    }\n\n}\n",
      "fixed_full_code": "\npackage org.apache.commons.math3.fraction;\n\nimport java.io.Serializable;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\n\nimport org.apache.commons.math3.FieldElement;\nimport org.apache.commons.math3.exception.MathArithmeticException;\nimport org.apache.commons.math3.exception.MathIllegalArgumentException;\nimport org.apache.commons.math3.exception.NullArgumentException;\nimport org.apache.commons.math3.exception.ZeroException;\nimport org.apache.commons.math3.exception.util.LocalizedFormats;\nimport org.apache.commons.math3.util.ArithmeticUtils;\nimport org.apache.commons.math3.util.FastMath;\nimport org.apache.commons.math3.util.MathUtils;\n\n\npublic class BigFraction extends Number implements FieldElement<BigFraction>, Comparable<BigFraction>, Serializable { public static final BigFraction TWO = new BigFraction(2); public static final BigFraction ONE = new BigFraction(1); public static final BigFraction ZERO = new BigFraction(0); public static final BigFraction MINUS_ONE = new BigFraction(-1); public static final BigFraction FOUR_FIFTHS = new BigFraction(4, 5); public static final BigFraction ONE_FIFTH = new BigFraction(1, 5); public static final BigFraction ONE_HALF = new BigFraction(1, 2); public static final BigFraction ONE_QUARTER = new BigFraction(1, 4); public static final BigFraction ONE_THIRD = new BigFraction(1, 3); public static final BigFraction THREE_FIFTHS = new BigFraction(3, 5); public static final BigFraction THREE_QUARTERS = new BigFraction(3, 4); public static final BigFraction TWO_FIFTHS = new BigFraction(2, 5); public static final BigFraction TWO_QUARTERS = new BigFraction(2, 4); public static final BigFraction TWO_THIRDS = new BigFraction(2, 3); private static final long serialVersionUID = -5630213147331578515L; private static final BigInteger ONE_HUNDRED = BigInteger.valueOf(100); private final BigInteger numerator; private final BigInteger denominator; public BigFraction(final BigInteger num) {\n        this(num, BigInteger.ONE);\n    }\n\n    \n    public BigFraction(BigInteger num, BigInteger den) {\n        MathUtils.checkNotNull(num, LocalizedFormats.NUMERATOR);\n        MathUtils.checkNotNull(den, LocalizedFormats.DENOMINATOR);\n        if (BigInteger.ZERO.equals(den)) {\n            throw new ZeroException(LocalizedFormats.ZERO_DENOMINATOR);\n        }\n        if (BigInteger.ZERO.equals(num)) {\n            numerator   = BigInteger.ZERO;\n            denominator = BigInteger.ONE;\n        } else {\n\n            \n            final BigInteger gcd = num.gcd(den);\n            if (BigInteger.ONE.compareTo(gcd) < 0) {\n                num = num.divide(gcd);\n                den = den.divide(gcd);\n            }\n\n            \n            if (BigInteger.ZERO.compareTo(den) > 0) {\n                num = num.negate();\n                den = den.negate();\n            }\n\n            \n            numerator   = num;\n            denominator = den;\n\n        }\n    }\n\n    \n    public BigFraction(final double value) throws MathIllegalArgumentException {\n        if (Double.isNaN(value)) {\n            throw new MathIllegalArgumentException(LocalizedFormats.NAN_VALUE_CONVERSION);\n        }\n        if (Double.isInfinite(value)) {\n            throw new MathIllegalArgumentException(LocalizedFormats.INFINITE_VALUE_CONVERSION);\n        }\n\n        \n        final long bits     = Double.doubleToLongBits(value);\n        final long sign     = bits & 0x8000000000000000L;\n        final long exponent = bits & 0x7ff0000000000000L;\n        long m              = bits & 0x000fffffffffffffL;\n        if (exponent != 0) {\n            \n            m |= 0x0010000000000000L;\n        }\n        if (sign != 0) {\n            m = -m;\n        }\n        int k = ((int) (exponent >> 52)) - 1075;\n        while (((m & 0x001ffffffffffffeL) != 0) && ((m & 0x1) == 0)) {\n            m = m >> 1;\n            ++k;\n        }\n\n        if (k < 0) {\n            numerator   = BigInteger.valueOf(m);\n            denominator = BigInteger.ZERO.flipBit(-k);\n        } else {\n            numerator   = BigInteger.valueOf(m).multiply(BigInteger.ZERO.flipBit(k));\n            denominator = BigInteger.ONE;\n        }\n\n    }\n\n    \n    public BigFraction(final double value, final double epsilon, final int maxIterations) throws FractionConversionException {\n        this(value, epsilon, Integer.MAX_VALUE, maxIterations);\n    }\n\n    \n    private BigFraction(final double value, final double epsilon, final int maxDenominator, int maxIterations) throws FractionConversionException {\n        long overflow = Integer.MAX_VALUE;\n        double r0 = value;\n        long a0 = (long) FastMath.floor(r0);\n        if (a0 > overflow) {\n            throw new FractionConversionException(value, a0, 1l);\n        }\n\n        \n        \n        if (FastMath.abs(a0 - value) < epsilon) {\n            numerator = BigInteger.valueOf(a0);\n            denominator = BigInteger.ONE;\n            return;\n        }\n\n        long p0 = 1;\n        long q0 = 0;\n        long p1 = a0;\n        long q1 = 1;\n\n        long p2 = 0;\n        long q2 = 1;\n\n        int n = 0;\n        boolean stop = false;\n        do {\n            ++n;\n            final double r1 = 1.0 / (r0 - a0);\n            final long a1 = (long) FastMath.floor(r1);\n            p2 = (a1 * p1) + p0;\n            q2 = (a1 * q1) + q0;\n            if ((p2 > overflow) || (q2 > overflow)) {\n                \n                \n                if (epsilon == 0.0 && FastMath.abs(q1) < maxDenominator) {\n                    break;\n                }\n                throw new FractionConversionException(value, p2, q2);\n            }\n\n            final double convergent = (double) p2 / (double) q2;\n            if ((n < maxIterations) &&\n                (FastMath.abs(convergent - value) > epsilon) &&\n                (q2 < maxDenominator)) {\n                p0 = p1;\n                p1 = p2;\n                q0 = q1;\n                q1 = q2;\n                a0 = a1;\n                r0 = r1;\n            } else {\n                stop = true;\n            }\n        } while (!stop);\n\n        if (n >= maxIterations) {\n            throw new FractionConversionException(value, maxIterations);\n        }\n\n        if (q2 < maxDenominator) {\n            numerator   = BigInteger.valueOf(p2);\n            denominator = BigInteger.valueOf(q2);\n        } else {\n            numerator   = BigInteger.valueOf(p1);\n            denominator = BigInteger.valueOf(q1);\n        }\n    }\n\n    \n    public BigFraction(final double value, final int maxDenominator) throws FractionConversionException {\n        this(value, 0, maxDenominator, 100);\n    }\n\n    \n    public BigFraction(final int num) {\n        this(BigInteger.valueOf(num), BigInteger.ONE);\n    }\n\n    \n    public BigFraction(final int num, final int den) {\n        this(BigInteger.valueOf(num), BigInteger.valueOf(den));\n    }\n\n    \n    public BigFraction(final long num) {\n        this(BigInteger.valueOf(num), BigInteger.ONE);\n    }\n\n    \n    public BigFraction(final long num, final long den) {\n        this(BigInteger.valueOf(num), BigInteger.valueOf(den));\n    }\n\n    \n    public static BigFraction getReducedFraction(final int numerator, final int denominator) {\n        if (numerator == 0) {\n            return ZERO; \n        }\n\n        return new BigFraction(numerator, denominator);\n    }\n\n    \n    public BigFraction abs() {\n        return (BigInteger.ZERO.compareTo(numerator) <= 0) ? this : negate();\n    }\n\n    \n    public BigFraction add(final BigInteger bg) throws NullArgumentException {\n        MathUtils.checkNotNull(bg);\n        return new BigFraction(numerator.add(denominator.multiply(bg)), denominator);\n    }\n\n    \n    public BigFraction add(final int i) {\n        return add(BigInteger.valueOf(i));\n    }\n\n    \n    public BigFraction add(final long l) {\n        return add(BigInteger.valueOf(l));\n    }\n\n    \n    public BigFraction add(final BigFraction fraction) {\n        if (fraction == null) {\n            throw new NullArgumentException(LocalizedFormats.FRACTION);\n        }\n        if (ZERO.equals(fraction)) {\n            return this;\n        }\n\n        BigInteger num = null;\n        BigInteger den = null;\n\n        if (denominator.equals(fraction.denominator)) {\n            num = numerator.add(fraction.numerator);\n            den = denominator;\n        } else {\n            num = (numerator.multiply(fraction.denominator)).add((fraction.numerator).multiply(denominator));\n            den = denominator.multiply(fraction.denominator);\n        }\n        return new BigFraction(num, den);\n\n    }\n\n    \n    public BigDecimal bigDecimalValue() {\n        return new BigDecimal(numerator).divide(new BigDecimal(denominator));\n    }\n\n    \n    public BigDecimal bigDecimalValue(final int roundingMode) {\n        return new BigDecimal(numerator).divide(new BigDecimal(denominator), roundingMode);\n    }\n\n    \n    public BigDecimal bigDecimalValue(final int scale, final int roundingMode) {\n        return new BigDecimal(numerator).divide(new BigDecimal(denominator), scale, roundingMode);\n    }\n\n    \n    public int compareTo(final BigFraction object) {\n        BigInteger nOd = numerator.multiply(object.denominator);\n        BigInteger dOn = denominator.multiply(object.numerator);\n        return nOd.compareTo(dOn);\n    }\n\n    \n    public BigFraction divide(final BigInteger bg) {\n        if (bg == null) {\n            throw new NullArgumentException(LocalizedFormats.FRACTION);\n        }\n        if (BigInteger.ZERO.equals(bg)) {\n            throw new MathArithmeticException(LocalizedFormats.ZERO_DENOMINATOR);\n        }\n        return new BigFraction(numerator, denominator.multiply(bg));\n    }\n\n    \n    public BigFraction divide(final int i) {\n        return divide(BigInteger.valueOf(i));\n    }\n\n    \n    public BigFraction divide(final long l) {\n        return divide(BigInteger.valueOf(l));\n    }\n\n    \n    public BigFraction divide(final BigFraction fraction) {\n        if (fraction == null) {\n            throw new NullArgumentException(LocalizedFormats.FRACTION);\n        }\n        if (BigInteger.ZERO.equals(fraction.numerator)) {\n            throw new MathArithmeticException(LocalizedFormats.ZERO_DENOMINATOR);\n        }\n\n        return multiply(fraction.reciprocal());\n    }\n\n    \n    @Override\n    public double doubleValue() {\n        double result = numerator.doubleValue() / denominator.doubleValue();\n        if (Double.isNaN(result)) {\n            \n            \n            int shift = Math.max(numerator.bitLength(),\n                                 denominator.bitLength()) - FastMath.getExponent(Double.MAX_VALUE);\n            result = numerator.shiftRight(shift).doubleValue() /\n                denominator.shiftRight(shift).doubleValue();\n        }\n        return result;\n    }\n\n    \n    @Override\n    public boolean equals(final Object other) {\n        boolean ret = false;\n\n        if (this == other) {\n            ret = true;\n        } else if (other instanceof BigFraction) {\n            BigFraction rhs = ((BigFraction) other).reduce();\n            BigFraction thisOne = this.reduce();\n            ret = thisOne.numerator.equals(rhs.numerator) && thisOne.denominator.equals(rhs.denominator);\n        }\n\n        return ret;\n    }\n\n    \n    @Override\n    public float floatValue() {\n        float result = numerator.floatValue() / denominator.floatValue();\n        if (Double.isNaN(result)) {\n            \n            \n            int shift = Math.max(numerator.bitLength(),\n                                 denominator.bitLength()) - FastMath.getExponent(Float.MAX_VALUE);\n            result = numerator.shiftRight(shift).floatValue() /\n                denominator.shiftRight(shift).floatValue();\n        }\n        return result;\n    }\n\n    \n    public BigInteger getDenominator() {\n        return denominator;\n    }\n\n    \n    public int getDenominatorAsInt() {\n        return denominator.intValue();\n    }\n\n    \n    public long getDenominatorAsLong() {\n        return denominator.longValue();\n    }\n\n    \n    public BigInteger getNumerator() {\n        return numerator;\n    }\n\n    \n    public int getNumeratorAsInt() {\n        return numerator.intValue();\n    }\n\n    \n    public long getNumeratorAsLong() {\n        return numerator.longValue();\n    }\n\n    \n    @Override\n    public int hashCode() {\n        return 37 * (37 * 17 + numerator.hashCode()) + denominator.hashCode();\n    }\n\n    \n    @Override\n    public int intValue() {\n        return numerator.divide(denominator).intValue();\n    }\n\n    \n    @Override\n    public long longValue() {\n        return numerator.divide(denominator).longValue();\n    }\n\n    \n    public BigFraction multiply(final BigInteger bg) {\n        if (bg == null) {\n            throw new NullArgumentException();\n        }\n        return new BigFraction(bg.multiply(numerator), denominator);\n    }\n\n    \n    public BigFraction multiply(final int i) {\n        return multiply(BigInteger.valueOf(i));\n    }\n\n    \n    public BigFraction multiply(final long l) {\n        return multiply(BigInteger.valueOf(l));\n    }\n\n    \n    public BigFraction multiply(final BigFraction fraction) {\n        if (fraction == null) {\n            throw new NullArgumentException(LocalizedFormats.FRACTION);\n        }\n        if (numerator.equals(BigInteger.ZERO) ||\n            fraction.numerator.equals(BigInteger.ZERO)) {\n            return ZERO;\n        }\n        return new BigFraction(numerator.multiply(fraction.numerator),\n                               denominator.multiply(fraction.denominator));\n    }\n\n    \n    public BigFraction negate() {\n        return new BigFraction(numerator.negate(), denominator);\n    }\n\n    \n    public double percentageValue() {\n        return multiply(ONE_HUNDRED).doubleValue();\n    }\n\n    \n    public BigFraction pow(final int exponent) {\n        if (exponent < 0) {\n            return new BigFraction(denominator.pow(-exponent), numerator.pow(-exponent));\n        }\n        return new BigFraction(numerator.pow(exponent), denominator.pow(exponent));\n    }\n\n    \n    public BigFraction pow(final long exponent) {\n        if (exponent < 0) {\n            return new BigFraction(ArithmeticUtils.pow(denominator, -exponent),\n                                   ArithmeticUtils.pow(numerator,   -exponent));\n        }\n        return new BigFraction(ArithmeticUtils.pow(numerator,   exponent),\n                               ArithmeticUtils.pow(denominator, exponent));\n    }\n\n    \n    public BigFraction pow(final BigInteger exponent) {\n        if (exponent.compareTo(BigInteger.ZERO) < 0) {\n            final BigInteger eNeg = exponent.negate();\n            return new BigFraction(ArithmeticUtils.pow(denominator, eNeg),\n                                   ArithmeticUtils.pow(numerator,   eNeg));\n        }\n        return new BigFraction(ArithmeticUtils.pow(numerator,   exponent),\n                               ArithmeticUtils.pow(denominator, exponent));\n    }\n\n    \n    public double pow(final double exponent) {\n        return FastMath.pow(numerator.doubleValue(),   exponent) /\n               FastMath.pow(denominator.doubleValue(), exponent);\n    }\n\n    \n    public BigFraction reciprocal() {\n        return new BigFraction(denominator, numerator);\n    }\n\n    \n    public BigFraction reduce() {\n        final BigInteger gcd = numerator.gcd(denominator);\n        return new BigFraction(numerator.divide(gcd), denominator.divide(gcd));\n    }\n\n    \n    public BigFraction subtract(final BigInteger bg) {\n        if (bg == null) {\n            throw new NullArgumentException();\n        }\n        return new BigFraction(numerator.subtract(denominator.multiply(bg)), denominator);\n    }\n\n    \n    public BigFraction subtract(final int i) {\n        return subtract(BigInteger.valueOf(i));\n    }\n\n    \n    public BigFraction subtract(final long l) {\n        return subtract(BigInteger.valueOf(l));\n    }\n\n    \n    public BigFraction subtract(final BigFraction fraction) {\n        if (fraction == null) {\n            throw new NullArgumentException(LocalizedFormats.FRACTION);\n        }\n        if (ZERO.equals(fraction)) {\n            return this;\n        }\n\n        BigInteger num = null;\n        BigInteger den = null;\n        if (denominator.equals(fraction.denominator)) {\n            num = numerator.subtract(fraction.numerator);\n            den = denominator;\n        } else {\n            num = (numerator.multiply(fraction.denominator)).subtract((fraction.numerator).multiply(denominator));\n            den = denominator.multiply(fraction.denominator);\n        }\n        return new BigFraction(num, den);\n\n    }\n\n    \n    @Override\n    public String toString() {\n        String str = null;\n        if (BigInteger.ONE.equals(denominator)) {\n            str = numerator.toString();\n        } else if (BigInteger.ZERO.equals(numerator)) {\n            str = \"0\";\n        } else {\n            str = numerator + \" / \" + denominator;\n        }\n        return str;\n    }\n\n    \n    public BigFractionField getField() {\n        return BigFractionField.getInstance();\n    }\n\n}\n",
      "buggy_signatures": [
        "public BigFraction(BigInteger num, BigInteger den)",
        "public BigFraction(final double value) throws MathIllegalArgumentException",
        "public BigFraction(final double value, final double epsilon, final int maxIterations) throws FractionConversionException",
        "private BigFraction(final double value, final double epsilon, final int maxDenominator, int maxIterations) throws FractionConversionException",
        "public BigFraction(final double value, final int maxDenominator) throws FractionConversionException",
        "public BigFraction(final int num)",
        "public BigFraction(final int num, final int den)",
        "public BigFraction(final long num)",
        "public BigFraction(final long num, final long den)",
        "public static BigFraction getReducedFraction(final int numerator, final int denominator)",
        "public BigFraction abs()",
        "public BigFraction add(final BigInteger bg) throws NullArgumentException",
        "public BigFraction add(final int i)",
        "public BigFraction add(final long l)",
        "public BigFraction add(final BigFraction fraction)",
        "public BigDecimal bigDecimalValue()",
        "public BigDecimal bigDecimalValue(final int roundingMode)",
        "public BigDecimal bigDecimalValue(final int scale, final int roundingMode)",
        "public int compareTo(final BigFraction object)",
        "public BigFraction divide(final BigInteger bg)",
        "public BigFraction divide(final int i)",
        "public BigFraction divide(final long l)",
        "public BigFraction divide(final BigFraction fraction)",
        "public double doubleValue()",
        "public boolean equals(final Object other)",
        "public float floatValue()",
        "public BigInteger getDenominator()",
        "public int getDenominatorAsInt()",
        "public long getDenominatorAsLong()",
        "public BigInteger getNumerator()",
        "public int getNumeratorAsInt()",
        "public long getNumeratorAsLong()",
        "public int hashCode()",
        "public int intValue()",
        "public long longValue()",
        "public BigFraction multiply(final BigInteger bg)",
        "public BigFraction multiply(final int i)",
        "public BigFraction multiply(final long l)",
        "public BigFraction multiply(final BigFraction fraction)",
        "public BigFraction negate()",
        "public double percentageValue()",
        "public BigFraction pow(final int exponent)",
        "public BigFraction pow(final long exponent)",
        "public BigFraction pow(final BigInteger exponent)",
        "public double pow(final double exponent)",
        "public BigFraction reciprocal()",
        "public BigFraction reduce()",
        "public BigFraction subtract(final BigInteger bg)",
        "public BigFraction subtract(final int i)",
        "public BigFraction subtract(final long l)",
        "public BigFraction subtract(final BigFraction fraction)",
        "public String toString()",
        "public BigFractionField getField()"
      ],
      "fixed_signatures": [
        "public BigFraction(BigInteger num, BigInteger den)",
        "public BigFraction(final double value) throws MathIllegalArgumentException",
        "public BigFraction(final double value, final double epsilon, final int maxIterations) throws FractionConversionException",
        "private BigFraction(final double value, final double epsilon, final int maxDenominator, int maxIterations) throws FractionConversionException",
        "public BigFraction(final double value, final int maxDenominator) throws FractionConversionException",
        "public BigFraction(final int num)",
        "public BigFraction(final int num, final int den)",
        "public BigFraction(final long num)",
        "public BigFraction(final long num, final long den)",
        "public static BigFraction getReducedFraction(final int numerator, final int denominator)",
        "public BigFraction abs()",
        "public BigFraction add(final BigInteger bg) throws NullArgumentException",
        "public BigFraction add(final int i)",
        "public BigFraction add(final long l)",
        "public BigFraction add(final BigFraction fraction)",
        "public BigDecimal bigDecimalValue()",
        "public BigDecimal bigDecimalValue(final int roundingMode)",
        "public BigDecimal bigDecimalValue(final int scale, final int roundingMode)",
        "public int compareTo(final BigFraction object)",
        "public BigFraction divide(final BigInteger bg)",
        "public BigFraction divide(final int i)",
        "public BigFraction divide(final long l)",
        "public BigFraction divide(final BigFraction fraction)",
        "public double doubleValue()",
        "public boolean equals(final Object other)",
        "public float floatValue()",
        "public BigInteger getDenominator()",
        "public int getDenominatorAsInt()",
        "public long getDenominatorAsLong()",
        "public BigInteger getNumerator()",
        "public int getNumeratorAsInt()",
        "public long getNumeratorAsLong()",
        "public int hashCode()",
        "public int intValue()",
        "public long longValue()",
        "public BigFraction multiply(final BigInteger bg)",
        "public BigFraction multiply(final int i)",
        "public BigFraction multiply(final long l)",
        "public BigFraction multiply(final BigFraction fraction)",
        "public BigFraction negate()",
        "public double percentageValue()",
        "public BigFraction pow(final int exponent)",
        "public BigFraction pow(final long exponent)",
        "public BigFraction pow(final BigInteger exponent)",
        "public double pow(final double exponent)",
        "public BigFraction reciprocal()",
        "public BigFraction reduce()",
        "public BigFraction subtract(final BigInteger bg)",
        "public BigFraction subtract(final int i)",
        "public BigFraction subtract(final long l)",
        "public BigFraction subtract(final BigFraction fraction)",
        "public String toString()",
        "public BigFractionField getField()"
      ],
      "methods": [
        {
          "buggy_method": "  private BigFraction(final double value, final double epsilon, final int maxDenominator, int maxIterations) throws FractionConversionException {\n  long overflow = Integer.MAX_VALUE;\n  double r0 = value;\n  long a0 = (long) FastMath.floor(r0);\n  if (a0 > overflow) {\n  throw new FractionConversionException(value, a0, 1l);\n  }\n\n  \n  \n  if (FastMath.abs(a0 - value) < epsilon) {\n  numerator = BigInteger.valueOf(a0);\n  denominator = BigInteger.ONE;\n  return;\n  }\n\n  long p0 = 1;\n  long q0 = 0;\n  long p1 = a0;\n  long q1 = 1;\n\n  long p2 = 0;\n  long q2 = 1;\n\n  int n = 0;\n  boolean stop = false;\n  do {\n  ++n;\n  final double r1 = 1.0 / (r0 - a0);\n  final long a1 = (long) FastMath.floor(r1);\n  p2 = (a1 * p1) + p0;\n  q2 = (a1 * q1) + q0;\n  if ((p2 > overflow) || (q2 > overflow)) {\n  \n  \n  throw new FractionConversionException(value, p2, q2);\n  }\n\n  final double convergent = (double) p2 / (double) q2;\n  if ((n < maxIterations) &&\n  (FastMath.abs(convergent - value) > epsilon) &&\n  (q2 < maxDenominator)) {\n  p0 = p1;\n  p1 = p2;\n  q0 = q1;\n  q1 = q2;\n  a0 = a1;\n  r0 = r1;\n  } else {\n  stop = true;\n  }\n  } while (!stop);\n\n  if (n >= maxIterations) {\n  throw new FractionConversionException(value, maxIterations);\n  }\n\n  if (q2 < maxDenominator) {\n  numerator  = BigInteger.valueOf(p2);\n  denominator = BigInteger.valueOf(q2);\n  } else {\n  numerator  = BigInteger.valueOf(p1);\n  denominator = BigInteger.valueOf(q1);\n  }\n  }",
          "fixed_method": "  private BigFraction(final double value, final double epsilon, final int maxDenominator, int maxIterations) throws FractionConversionException {\n  long overflow = Integer.MAX_VALUE;\n  double r0 = value;\n  long a0 = (long) FastMath.floor(r0);\n  if (a0 > overflow) {\n  throw new FractionConversionException(value, a0, 1l);\n  }\n\n  \n  \n  if (FastMath.abs(a0 - value) < epsilon) {\n  numerator = BigInteger.valueOf(a0);\n  denominator = BigInteger.ONE;\n  return;\n  }\n\n  long p0 = 1;\n  long q0 = 0;\n  long p1 = a0;\n  long q1 = 1;\n\n  long p2 = 0;\n  long q2 = 1;\n\n  int n = 0;\n  boolean stop = false;\n  do {\n  ++n;\n  final double r1 = 1.0 / (r0 - a0);\n  final long a1 = (long) FastMath.floor(r1);\n  p2 = (a1 * p1) + p0;\n  q2 = (a1 * q1) + q0;\n  if ((p2 > overflow) || (q2 > overflow)) {\n  \n  \n  if (epsilon == 0.0 && FastMath.abs(q1) < maxDenominator) {\n  break;\n  }\n  throw new FractionConversionException(value, p2, q2);\n  }\n\n  final double convergent = (double) p2 / (double) q2;\n  if ((n < maxIterations) &&\n  (FastMath.abs(convergent - value) > epsilon) &&\n  (q2 < maxDenominator)) {\n  p0 = p1;\n  p1 = p2;\n  q0 = q1;\n  q1 = q2;\n  a0 = a1;\n  r0 = r1;\n  } else {\n  stop = true;\n  }\n  } while (!stop);\n\n  if (n >= maxIterations) {\n  throw new FractionConversionException(value, maxIterations);\n  }\n\n  if (q2 < maxDenominator) {\n  numerator  = BigInteger.valueOf(p2);\n  denominator = BigInteger.valueOf(q2);\n  } else {\n  numerator  = BigInteger.valueOf(p1);\n  denominator = BigInteger.valueOf(q1);\n  }\n  }",
          "diff": [
            "@@ -303,6 +303,9 @@",
            "             if ((p2 > overflow) || (q2 > overflow)) {\n",
            "                 // in maxDenominator mode, if the last fraction was very close to the actual value\n",
            "                 // q2 may overflow in the next iteration; in this case return the last one.\n",
            "+                if (epsilon == 0.0 && FastMath.abs(q1) < maxDenominator) {\n",
            "+                    break;\n",
            "+                }\n",
            "                 throw new FractionConversionException(value, p2, q2);\n",
            "             }\n",
            " \n"
          ],
          "changed_lines": 3
        }
      ]
    },
    {
      "name": "org/apache/commons/math3/fraction/Fraction.java",
      "buggy_full_code": "\npackage org.apache.commons.math3.fraction;\n\nimport java.io.Serializable;\nimport java.math.BigInteger;\n\nimport org.apache.commons.math3.FieldElement;\nimport org.apache.commons.math3.exception.util.LocalizedFormats;\nimport org.apache.commons.math3.exception.MathArithmeticException;\nimport org.apache.commons.math3.exception.NullArgumentException;\nimport org.apache.commons.math3.util.ArithmeticUtils;\nimport org.apache.commons.math3.util.FastMath;\n\n\npublic class Fraction extends Number implements FieldElement<Fraction>, Comparable<Fraction>, Serializable { public static final Fraction TWO = new Fraction(2, 1); public static final Fraction ONE = new Fraction(1, 1); public static final Fraction ZERO = new Fraction(0, 1); public static final Fraction FOUR_FIFTHS = new Fraction(4, 5); public static final Fraction ONE_FIFTH = new Fraction(1, 5); public static final Fraction ONE_HALF = new Fraction(1, 2); public static final Fraction ONE_QUARTER = new Fraction(1, 4); public static final Fraction ONE_THIRD = new Fraction(1, 3); public static final Fraction THREE_FIFTHS = new Fraction(3, 5); public static final Fraction THREE_QUARTERS = new Fraction(3, 4); public static final Fraction TWO_FIFTHS = new Fraction(2, 5); public static final Fraction TWO_QUARTERS = new Fraction(2, 4); public static final Fraction TWO_THIRDS = new Fraction(2, 3); public static final Fraction MINUS_ONE = new Fraction(-1, 1); private static final long serialVersionUID = 3698073679419233275L; private static final double DEFAULT_EPSILON = 1e-5; private final int denominator; private final int numerator; public Fraction(double value) throws FractionConversionException {\n        this(value, DEFAULT_EPSILON, 100);\n    }\n\n    \n    public Fraction(double value, double epsilon, int maxIterations) throws FractionConversionException {\n        this(value, epsilon, Integer.MAX_VALUE, maxIterations);\n    }\n\n    \n    public Fraction(double value, int maxDenominator) throws FractionConversionException {\n       this(value, 0, maxDenominator, 100);\n    }\n\n    \n    private Fraction(double value, double epsilon, int maxDenominator, int maxIterations) throws FractionConversionException {\n        long overflow = Integer.MAX_VALUE;\n        double r0 = value;\n        long a0 = (long)FastMath.floor(r0);\n        if (FastMath.abs(a0) > overflow) {\n            throw new FractionConversionException(value, a0, 1l);\n        }\n\n        \n        if (FastMath.abs(a0 - value) < epsilon) {\n            this.numerator = (int) a0;\n            this.denominator = 1;\n            return;\n        }\n\n        long p0 = 1;\n        long q0 = 0;\n        long p1 = a0;\n        long q1 = 1;\n\n        long p2 = 0;\n        long q2 = 1;\n\n        int n = 0;\n        boolean stop = false;\n        do {\n            ++n;\n            double r1 = 1.0 / (r0 - a0);\n            long a1 = (long)FastMath.floor(r1);\n            p2 = (a1 * p1) + p0;\n            q2 = (a1 * q1) + q0;\n\n            if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) {\n                \n                \n                throw new FractionConversionException(value, p2, q2);\n            }\n\n            double convergent = (double)p2 / (double)q2;\n            if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) {\n                p0 = p1;\n                p1 = p2;\n                q0 = q1;\n                q1 = q2;\n                a0 = a1;\n                r0 = r1;\n            } else {\n                stop = true;\n            }\n        } while (!stop);\n\n        if (n >= maxIterations) {\n            throw new FractionConversionException(value, maxIterations);\n        }\n\n        if (q2 < maxDenominator) {\n            this.numerator = (int) p2;\n            this.denominator = (int) q2;\n        } else {\n            this.numerator = (int) p1;\n            this.denominator = (int) q1;\n        }\n\n    }\n\n    \n    public Fraction(int num) {\n        this(num, 1);\n    }\n\n    \n    public Fraction(int num, int den) {\n        if (den == 0) {\n            throw new MathArithmeticException(LocalizedFormats.ZERO_DENOMINATOR_IN_FRACTION,\n                                              num, den);\n        }\n        if (den < 0) {\n            if (num == Integer.MIN_VALUE ||\n                den == Integer.MIN_VALUE) {\n                throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_FRACTION,\n                                                  num, den);\n            }\n            num = -num;\n            den = -den;\n        }\n        \n        final int d = ArithmeticUtils.gcd(num, den);\n        if (d > 1) {\n            num /= d;\n            den /= d;\n        }\n\n        \n        if (den < 0) {\n            num = -num;\n            den = -den;\n        }\n        this.numerator   = num;\n        this.denominator = den;\n    }\n\n    \n    public Fraction abs() {\n        Fraction ret;\n        if (numerator >= 0) {\n            ret = this;\n        } else {\n            ret = negate();\n        }\n        return ret;\n    }\n\n    \n    public int compareTo(Fraction object) {\n        long nOd = ((long) numerator) * object.denominator;\n        long dOn = ((long) denominator) * object.numerator;\n        return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0);\n    }\n\n    \n    @Override\n    public double doubleValue() {\n        return (double)numerator / (double)denominator;\n    }\n\n    \n    @Override\n    public boolean equals(Object other) {\n        if (this == other) {\n            return true;\n        }\n        if (other instanceof Fraction) {\n            \n            \n            Fraction rhs = (Fraction)other;\n            return (numerator == rhs.numerator) &&\n                (denominator == rhs.denominator);\n        }\n        return false;\n    }\n\n    \n    @Override\n    public float floatValue() {\n        return (float)doubleValue();\n    }\n\n    \n    public int getDenominator() {\n        return denominator;\n    }\n\n    \n    public int getNumerator() {\n        return numerator;\n    }\n\n    \n    @Override\n    public int hashCode() {\n        return 37 * (37 * 17 + numerator) + denominator;\n    }\n\n    \n    @Override\n    public int intValue() {\n        return (int)doubleValue();\n    }\n\n    \n    @Override\n    public long longValue() {\n        return (long)doubleValue();\n    }\n\n    \n    public Fraction negate() {\n        if (numerator==Integer.MIN_VALUE) {\n            throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_FRACTION, numerator, denominator);\n        }\n        return new Fraction(-numerator, denominator);\n    }\n\n    \n    public Fraction reciprocal() {\n        return new Fraction(denominator, numerator);\n    }\n\n    \n    public Fraction add(Fraction fraction) {\n        return addSub(fraction, true );\n    }\n\n    \n    public Fraction add(final int i) {\n        return new Fraction(numerator + i * denominator, denominator);\n    }\n\n    \n    public Fraction subtract(Fraction fraction) {\n        return addSub(fraction, false );\n    }\n\n    \n    public Fraction subtract(final int i) {\n        return new Fraction(numerator - i * denominator, denominator);\n    }\n\n    \n    private Fraction addSub(Fraction fraction, boolean isAdd) {\n        if (fraction == null) {\n            throw new NullArgumentException(LocalizedFormats.FRACTION);\n        }\n        \n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }\n        \n        \n        int d1 = ArithmeticUtils.gcd(denominator, fraction.denominator);\n        if (d1==1) {\n            \n            int uvp = ArithmeticUtils.mulAndCheck(numerator, fraction.denominator);\n            int upv = ArithmeticUtils.mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? ArithmeticUtils.addAndCheck(uvp, upv) :\n                 ArithmeticUtils.subAndCheck(uvp, upv),\n                 ArithmeticUtils.mulAndCheck(denominator, fraction.denominator));\n        }\n        \n        \n        \n        BigInteger uvp = BigInteger.valueOf(numerator)\n        .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        BigInteger upv = BigInteger.valueOf(fraction.numerator)\n        .multiply(BigInteger.valueOf(denominator/d1));\n        BigInteger t = isAdd ? uvp.add(upv) : uvp.subtract(upv);\n        \n        \n        int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        int d2 = (tmodd1==0)?d1:ArithmeticUtils.gcd(tmodd1, d1);\n\n        \n        BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new MathArithmeticException(LocalizedFormats.NUMERATOR_OVERFLOW_AFTER_MULTIPLY,\n                                              w);\n        }\n        return new Fraction (w.intValue(),\n                ArithmeticUtils.mulAndCheck(denominator/d1,\n                        fraction.denominator/d2));\n    }\n\n    \n    public Fraction multiply(Fraction fraction) {\n        if (fraction == null) {\n            throw new NullArgumentException(LocalizedFormats.FRACTION);\n        }\n        if (numerator == 0 || fraction.numerator == 0) {\n            return ZERO;\n        }\n        \n        \n        int d1 = ArithmeticUtils.gcd(numerator, fraction.denominator);\n        int d2 = ArithmeticUtils.gcd(fraction.numerator, denominator);\n        return getReducedFraction\n        (ArithmeticUtils.mulAndCheck(numerator/d1, fraction.numerator/d2),\n                ArithmeticUtils.mulAndCheck(denominator/d2, fraction.denominator/d1));\n    }\n\n    \n    public Fraction multiply(final int i) {\n        return new Fraction(numerator * i, denominator);\n    }\n\n    \n    public Fraction divide(Fraction fraction) {\n        if (fraction == null) {\n            throw new NullArgumentException(LocalizedFormats.FRACTION);\n        }\n        if (fraction.numerator == 0) {\n            throw new MathArithmeticException(LocalizedFormats.ZERO_FRACTION_TO_DIVIDE_BY,\n                                              fraction.numerator, fraction.denominator);\n        }\n        return multiply(fraction.reciprocal());\n    }\n\n    \n    public Fraction divide(final int i) {\n        return new Fraction(numerator, denominator * i);\n    }\n\n    \n    public double percentageValue() {\n        return 100 * doubleValue();\n    }\n\n    \n    public static Fraction getReducedFraction(int numerator, int denominator) {\n        if (denominator == 0) {\n            throw new MathArithmeticException(LocalizedFormats.ZERO_DENOMINATOR_IN_FRACTION,\n                                              numerator, denominator);\n        }\n        if (numerator==0) {\n            return ZERO; \n        }\n        \n        if (denominator==Integer.MIN_VALUE && (numerator&1)==0) {\n            numerator/=2; denominator/=2;\n        }\n        if (denominator < 0) {\n            if (numerator==Integer.MIN_VALUE ||\n                    denominator==Integer.MIN_VALUE) {\n                throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_FRACTION,\n                                                  numerator, denominator);\n            }\n            numerator = -numerator;\n            denominator = -denominator;\n        }\n        \n        int gcd = ArithmeticUtils.gcd(numerator, denominator);\n        numerator /= gcd;\n        denominator /= gcd;\n        return new Fraction(numerator, denominator);\n    }\n\n    \n    @Override\n    public String toString() {\n        String str = null;\n        if (denominator == 1) {\n            str = Integer.toString(numerator);\n        } else if (numerator == 0) {\n            str = \"0\";\n        } else {\n            str = numerator + \" / \" + denominator;\n        }\n        return str;\n    }\n\n    \n    public FractionField getField() {\n        return FractionField.getInstance();\n    }\n\n}\n",
      "fixed_full_code": "\npackage org.apache.commons.math3.fraction;\n\nimport java.io.Serializable;\nimport java.math.BigInteger;\n\nimport org.apache.commons.math3.FieldElement;\nimport org.apache.commons.math3.exception.util.LocalizedFormats;\nimport org.apache.commons.math3.exception.MathArithmeticException;\nimport org.apache.commons.math3.exception.NullArgumentException;\nimport org.apache.commons.math3.util.ArithmeticUtils;\nimport org.apache.commons.math3.util.FastMath;\n\n\npublic class Fraction extends Number implements FieldElement<Fraction>, Comparable<Fraction>, Serializable { public static final Fraction TWO = new Fraction(2, 1); public static final Fraction ONE = new Fraction(1, 1); public static final Fraction ZERO = new Fraction(0, 1); public static final Fraction FOUR_FIFTHS = new Fraction(4, 5); public static final Fraction ONE_FIFTH = new Fraction(1, 5); public static final Fraction ONE_HALF = new Fraction(1, 2); public static final Fraction ONE_QUARTER = new Fraction(1, 4); public static final Fraction ONE_THIRD = new Fraction(1, 3); public static final Fraction THREE_FIFTHS = new Fraction(3, 5); public static final Fraction THREE_QUARTERS = new Fraction(3, 4); public static final Fraction TWO_FIFTHS = new Fraction(2, 5); public static final Fraction TWO_QUARTERS = new Fraction(2, 4); public static final Fraction TWO_THIRDS = new Fraction(2, 3); public static final Fraction MINUS_ONE = new Fraction(-1, 1); private static final long serialVersionUID = 3698073679419233275L; private static final double DEFAULT_EPSILON = 1e-5; private final int denominator; private final int numerator; public Fraction(double value) throws FractionConversionException {\n        this(value, DEFAULT_EPSILON, 100);\n    }\n\n    \n    public Fraction(double value, double epsilon, int maxIterations) throws FractionConversionException {\n        this(value, epsilon, Integer.MAX_VALUE, maxIterations);\n    }\n\n    \n    public Fraction(double value, int maxDenominator) throws FractionConversionException {\n       this(value, 0, maxDenominator, 100);\n    }\n\n    \n    private Fraction(double value, double epsilon, int maxDenominator, int maxIterations) throws FractionConversionException {\n        long overflow = Integer.MAX_VALUE;\n        double r0 = value;\n        long a0 = (long)FastMath.floor(r0);\n        if (FastMath.abs(a0) > overflow) {\n            throw new FractionConversionException(value, a0, 1l);\n        }\n\n        \n        if (FastMath.abs(a0 - value) < epsilon) {\n            this.numerator = (int) a0;\n            this.denominator = 1;\n            return;\n        }\n\n        long p0 = 1;\n        long q0 = 0;\n        long p1 = a0;\n        long q1 = 1;\n\n        long p2 = 0;\n        long q2 = 1;\n\n        int n = 0;\n        boolean stop = false;\n        do {\n            ++n;\n            double r1 = 1.0 / (r0 - a0);\n            long a1 = (long)FastMath.floor(r1);\n            p2 = (a1 * p1) + p0;\n            q2 = (a1 * q1) + q0;\n\n            if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) {\n                \n                \n                if (epsilon == 0.0 && FastMath.abs(q1) < maxDenominator) {\n                    break;\n                }\n                throw new FractionConversionException(value, p2, q2);\n            }\n\n            double convergent = (double)p2 / (double)q2;\n            if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) {\n                p0 = p1;\n                p1 = p2;\n                q0 = q1;\n                q1 = q2;\n                a0 = a1;\n                r0 = r1;\n            } else {\n                stop = true;\n            }\n        } while (!stop);\n\n        if (n >= maxIterations) {\n            throw new FractionConversionException(value, maxIterations);\n        }\n\n        if (q2 < maxDenominator) {\n            this.numerator = (int) p2;\n            this.denominator = (int) q2;\n        } else {\n            this.numerator = (int) p1;\n            this.denominator = (int) q1;\n        }\n\n    }\n\n    \n    public Fraction(int num) {\n        this(num, 1);\n    }\n\n    \n    public Fraction(int num, int den) {\n        if (den == 0) {\n            throw new MathArithmeticException(LocalizedFormats.ZERO_DENOMINATOR_IN_FRACTION,\n                                              num, den);\n        }\n        if (den < 0) {\n            if (num == Integer.MIN_VALUE ||\n                den == Integer.MIN_VALUE) {\n                throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_FRACTION,\n                                                  num, den);\n            }\n            num = -num;\n            den = -den;\n        }\n        \n        final int d = ArithmeticUtils.gcd(num, den);\n        if (d > 1) {\n            num /= d;\n            den /= d;\n        }\n\n        \n        if (den < 0) {\n            num = -num;\n            den = -den;\n        }\n        this.numerator   = num;\n        this.denominator = den;\n    }\n\n    \n    public Fraction abs() {\n        Fraction ret;\n        if (numerator >= 0) {\n            ret = this;\n        } else {\n            ret = negate();\n        }\n        return ret;\n    }\n\n    \n    public int compareTo(Fraction object) {\n        long nOd = ((long) numerator) * object.denominator;\n        long dOn = ((long) denominator) * object.numerator;\n        return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0);\n    }\n\n    \n    @Override\n    public double doubleValue() {\n        return (double)numerator / (double)denominator;\n    }\n\n    \n    @Override\n    public boolean equals(Object other) {\n        if (this == other) {\n            return true;\n        }\n        if (other instanceof Fraction) {\n            \n            \n            Fraction rhs = (Fraction)other;\n            return (numerator == rhs.numerator) &&\n                (denominator == rhs.denominator);\n        }\n        return false;\n    }\n\n    \n    @Override\n    public float floatValue() {\n        return (float)doubleValue();\n    }\n\n    \n    public int getDenominator() {\n        return denominator;\n    }\n\n    \n    public int getNumerator() {\n        return numerator;\n    }\n\n    \n    @Override\n    public int hashCode() {\n        return 37 * (37 * 17 + numerator) + denominator;\n    }\n\n    \n    @Override\n    public int intValue() {\n        return (int)doubleValue();\n    }\n\n    \n    @Override\n    public long longValue() {\n        return (long)doubleValue();\n    }\n\n    \n    public Fraction negate() {\n        if (numerator==Integer.MIN_VALUE) {\n            throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_FRACTION, numerator, denominator);\n        }\n        return new Fraction(-numerator, denominator);\n    }\n\n    \n    public Fraction reciprocal() {\n        return new Fraction(denominator, numerator);\n    }\n\n    \n    public Fraction add(Fraction fraction) {\n        return addSub(fraction, true );\n    }\n\n    \n    public Fraction add(final int i) {\n        return new Fraction(numerator + i * denominator, denominator);\n    }\n\n    \n    public Fraction subtract(Fraction fraction) {\n        return addSub(fraction, false );\n    }\n\n    \n    public Fraction subtract(final int i) {\n        return new Fraction(numerator - i * denominator, denominator);\n    }\n\n    \n    private Fraction addSub(Fraction fraction, boolean isAdd) {\n        if (fraction == null) {\n            throw new NullArgumentException(LocalizedFormats.FRACTION);\n        }\n        \n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }\n        \n        \n        int d1 = ArithmeticUtils.gcd(denominator, fraction.denominator);\n        if (d1==1) {\n            \n            int uvp = ArithmeticUtils.mulAndCheck(numerator, fraction.denominator);\n            int upv = ArithmeticUtils.mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? ArithmeticUtils.addAndCheck(uvp, upv) :\n                 ArithmeticUtils.subAndCheck(uvp, upv),\n                 ArithmeticUtils.mulAndCheck(denominator, fraction.denominator));\n        }\n        \n        \n        \n        BigInteger uvp = BigInteger.valueOf(numerator)\n        .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        BigInteger upv = BigInteger.valueOf(fraction.numerator)\n        .multiply(BigInteger.valueOf(denominator/d1));\n        BigInteger t = isAdd ? uvp.add(upv) : uvp.subtract(upv);\n        \n        \n        int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        int d2 = (tmodd1==0)?d1:ArithmeticUtils.gcd(tmodd1, d1);\n\n        \n        BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new MathArithmeticException(LocalizedFormats.NUMERATOR_OVERFLOW_AFTER_MULTIPLY,\n                                              w);\n        }\n        return new Fraction (w.intValue(),\n                ArithmeticUtils.mulAndCheck(denominator/d1,\n                        fraction.denominator/d2));\n    }\n\n    \n    public Fraction multiply(Fraction fraction) {\n        if (fraction == null) {\n            throw new NullArgumentException(LocalizedFormats.FRACTION);\n        }\n        if (numerator == 0 || fraction.numerator == 0) {\n            return ZERO;\n        }\n        \n        \n        int d1 = ArithmeticUtils.gcd(numerator, fraction.denominator);\n        int d2 = ArithmeticUtils.gcd(fraction.numerator, denominator);\n        return getReducedFraction\n        (ArithmeticUtils.mulAndCheck(numerator/d1, fraction.numerator/d2),\n                ArithmeticUtils.mulAndCheck(denominator/d2, fraction.denominator/d1));\n    }\n\n    \n    public Fraction multiply(final int i) {\n        return new Fraction(numerator * i, denominator);\n    }\n\n    \n    public Fraction divide(Fraction fraction) {\n        if (fraction == null) {\n            throw new NullArgumentException(LocalizedFormats.FRACTION);\n        }\n        if (fraction.numerator == 0) {\n            throw new MathArithmeticException(LocalizedFormats.ZERO_FRACTION_TO_DIVIDE_BY,\n                                              fraction.numerator, fraction.denominator);\n        }\n        return multiply(fraction.reciprocal());\n    }\n\n    \n    public Fraction divide(final int i) {\n        return new Fraction(numerator, denominator * i);\n    }\n\n    \n    public double percentageValue() {\n        return 100 * doubleValue();\n    }\n\n    \n    public static Fraction getReducedFraction(int numerator, int denominator) {\n        if (denominator == 0) {\n            throw new MathArithmeticException(LocalizedFormats.ZERO_DENOMINATOR_IN_FRACTION,\n                                              numerator, denominator);\n        }\n        if (numerator==0) {\n            return ZERO; \n        }\n        \n        if (denominator==Integer.MIN_VALUE && (numerator&1)==0) {\n            numerator/=2; denominator/=2;\n        }\n        if (denominator < 0) {\n            if (numerator==Integer.MIN_VALUE ||\n                    denominator==Integer.MIN_VALUE) {\n                throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_FRACTION,\n                                                  numerator, denominator);\n            }\n            numerator = -numerator;\n            denominator = -denominator;\n        }\n        \n        int gcd = ArithmeticUtils.gcd(numerator, denominator);\n        numerator /= gcd;\n        denominator /= gcd;\n        return new Fraction(numerator, denominator);\n    }\n\n    \n    @Override\n    public String toString() {\n        String str = null;\n        if (denominator == 1) {\n            str = Integer.toString(numerator);\n        } else if (numerator == 0) {\n            str = \"0\";\n        } else {\n            str = numerator + \" / \" + denominator;\n        }\n        return str;\n    }\n\n    \n    public FractionField getField() {\n        return FractionField.getInstance();\n    }\n\n}\n",
      "buggy_signatures": [
        "public Fraction(double value, double epsilon, int maxIterations) throws FractionConversionException",
        "public Fraction(double value, int maxDenominator) throws FractionConversionException",
        "private Fraction(double value, double epsilon, int maxDenominator, int maxIterations) throws FractionConversionException",
        "public Fraction(int num)",
        "public Fraction(int num, int den)",
        "public Fraction abs()",
        "public int compareTo(Fraction object)",
        "public double doubleValue()",
        "public boolean equals(Object other)",
        "public float floatValue()",
        "public int getDenominator()",
        "public int getNumerator()",
        "public int hashCode()",
        "public int intValue()",
        "public long longValue()",
        "public Fraction negate()",
        "public Fraction reciprocal()",
        "public Fraction add(Fraction fraction)",
        "public Fraction add(final int i)",
        "public Fraction subtract(Fraction fraction)",
        "public Fraction subtract(final int i)",
        "private Fraction addSub(Fraction fraction, boolean isAdd)",
        "public Fraction multiply(Fraction fraction)",
        "public Fraction multiply(final int i)",
        "public Fraction divide(Fraction fraction)",
        "public Fraction divide(final int i)",
        "public double percentageValue()",
        "public static Fraction getReducedFraction(int numerator, int denominator)",
        "public String toString()",
        "public FractionField getField()"
      ],
      "fixed_signatures": [
        "public Fraction(double value, double epsilon, int maxIterations) throws FractionConversionException",
        "public Fraction(double value, int maxDenominator) throws FractionConversionException",
        "private Fraction(double value, double epsilon, int maxDenominator, int maxIterations) throws FractionConversionException",
        "public Fraction(int num)",
        "public Fraction(int num, int den)",
        "public Fraction abs()",
        "public int compareTo(Fraction object)",
        "public double doubleValue()",
        "public boolean equals(Object other)",
        "public float floatValue()",
        "public int getDenominator()",
        "public int getNumerator()",
        "public int hashCode()",
        "public int intValue()",
        "public long longValue()",
        "public Fraction negate()",
        "public Fraction reciprocal()",
        "public Fraction add(Fraction fraction)",
        "public Fraction add(final int i)",
        "public Fraction subtract(Fraction fraction)",
        "public Fraction subtract(final int i)",
        "private Fraction addSub(Fraction fraction, boolean isAdd)",
        "public Fraction multiply(Fraction fraction)",
        "public Fraction multiply(final int i)",
        "public Fraction divide(Fraction fraction)",
        "public Fraction divide(final int i)",
        "public double percentageValue()",
        "public static Fraction getReducedFraction(int numerator, int denominator)",
        "public String toString()",
        "public FractionField getField()"
      ],
      "methods": [
        {
          "buggy_method": "  private Fraction(double value, double epsilon, int maxDenominator, int maxIterations) throws FractionConversionException {\n  long overflow = Integer.MAX_VALUE;\n  double r0 = value;\n  long a0 = (long)FastMath.floor(r0);\n  if (FastMath.abs(a0) > overflow) {\n  throw new FractionConversionException(value, a0, 1l);\n  }\n\n  \n  if (FastMath.abs(a0 - value) < epsilon) {\n  this.numerator = (int) a0;\n  this.denominator = 1;\n  return;\n  }\n\n  long p0 = 1;\n  long q0 = 0;\n  long p1 = a0;\n  long q1 = 1;\n\n  long p2 = 0;\n  long q2 = 1;\n\n  int n = 0;\n  boolean stop = false;\n  do {\n  ++n;\n  double r1 = 1.0 / (r0 - a0);\n  long a1 = (long)FastMath.floor(r1);\n  p2 = (a1 * p1) + p0;\n  q2 = (a1 * q1) + q0;\n\n  if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) {\n  \n  \n  throw new FractionConversionException(value, p2, q2);\n  }\n\n  double convergent = (double)p2 / (double)q2;\n  if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) {\n  p0 = p1;\n  p1 = p2;\n  q0 = q1;\n  q1 = q2;\n  a0 = a1;\n  r0 = r1;\n  } else {\n  stop = true;\n  }\n  } while (!stop);\n\n  if (n >= maxIterations) {\n  throw new FractionConversionException(value, maxIterations);\n  }\n\n  if (q2 < maxDenominator) {\n  this.numerator = (int) p2;\n  this.denominator = (int) q2;\n  } else {\n  this.numerator = (int) p1;\n  this.denominator = (int) q1;\n  }\n\n  }",
          "fixed_method": "  private Fraction(double value, double epsilon, int maxDenominator, int maxIterations) throws FractionConversionException {\n  long overflow = Integer.MAX_VALUE;\n  double r0 = value;\n  long a0 = (long)FastMath.floor(r0);\n  if (FastMath.abs(a0) > overflow) {\n  throw new FractionConversionException(value, a0, 1l);\n  }\n\n  \n  if (FastMath.abs(a0 - value) < epsilon) {\n  this.numerator = (int) a0;\n  this.denominator = 1;\n  return;\n  }\n\n  long p0 = 1;\n  long q0 = 0;\n  long p1 = a0;\n  long q1 = 1;\n\n  long p2 = 0;\n  long q2 = 1;\n\n  int n = 0;\n  boolean stop = false;\n  do {\n  ++n;\n  double r1 = 1.0 / (r0 - a0);\n  long a1 = (long)FastMath.floor(r1);\n  p2 = (a1 * p1) + p0;\n  q2 = (a1 * q1) + q0;\n\n  if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) {\n  \n  \n  if (epsilon == 0.0 && FastMath.abs(q1) < maxDenominator) {\n  break;\n  }\n  throw new FractionConversionException(value, p2, q2);\n  }\n\n  double convergent = (double)p2 / (double)q2;\n  if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) {\n  p0 = p1;\n  p1 = p2;\n  q0 = q1;\n  q1 = q2;\n  a0 = a1;\n  r0 = r1;\n  } else {\n  stop = true;\n  }\n  } while (!stop);\n\n  if (n >= maxIterations) {\n  throw new FractionConversionException(value, maxIterations);\n  }\n\n  if (q2 < maxDenominator) {\n  this.numerator = (int) p2;\n  this.denominator = (int) q2;\n  } else {\n  this.numerator = (int) p1;\n  this.denominator = (int) q1;\n  }\n\n  }",
          "diff": [
            "@@ -212,6 +212,9 @@",
            "             if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) {\n",
            "                 // in maxDenominator mode, if the last fraction was very close to the actual value\n",
            "                 // q2 may overflow in the next iteration; in this case return the last one.\n",
            "+                if (epsilon == 0.0 && FastMath.abs(q1) < maxDenominator) {\n",
            "+                    break;\n",
            "+                }\n",
            "                 throw new FractionConversionException(value, p2, q2);\n",
            "             }\n",
            " \n"
          ],
          "changed_lines": 3
        }
      ]
    }
  ]
}
