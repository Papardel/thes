{
  "bug_id": "3",
  "failed_tests": {
    "org.apache.commons.collections.TestCollectionUtils": [
      {
        "methodName": "testRemoveAll",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<1> but was:<2>",
        "fail_line": "        assertEquals(1, result.size());",
        "test_source": "  public void testRemoveAll() {\n  List base = new ArrayList();\n  base.add(\"A\");\n  base.add(\"B\");\n  base.add(\"C\");\n  List sub = new ArrayList();\n  sub.add(\"A\");\n  sub.add(\"C\");\n  sub.add(\"X\");\n  \n  Collection result = CollectionUtils.removeAll(base, sub);\n  assertEquals(1, result.size());\n  assertEquals(false, result.contains(\"A\"));\n  assertEquals(true, result.contains(\"B\"));\n  assertEquals(false, result.contains(\"C\"));\n  assertEquals(3, base.size());\n  assertEquals(true, base.contains(\"A\"));\n  assertEquals(true, base.contains(\"B\"));\n  assertEquals(true, base.contains(\"C\"));\n  assertEquals(3, sub.size());\n  assertEquals(true, sub.contains(\"A\"));\n  assertEquals(true, sub.contains(\"C\"));\n  assertEquals(true, sub.contains(\"X\"));\n  \n  try {\n  CollectionUtils.removeAll(null, null);\n  fail(\"expecting NullPointerException\");\n  } catch(NullPointerException npe){} // this is what we want\n  }",
        "stack": [
          "TestCollectionUtils.testRemoveAll line 1283"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/collections/CollectionUtils.java",
      "buggy_full_code": "\npackage org.apache.commons.collections;\n\nimport java.lang.reflect.Array;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.apache.commons.collections.collection.PredicatedCollection;\nimport org.apache.commons.collections.collection.SynchronizedCollection;\nimport org.apache.commons.collections.collection.TransformedCollection;\nimport org.apache.commons.collections.collection.TypedCollection;\nimport org.apache.commons.collections.collection.UnmodifiableBoundedCollection;\nimport org.apache.commons.collections.collection.UnmodifiableCollection;\n\n\npublic class CollectionUtils {\n\n    \n    private static Integer INTEGER_ONE = new Integer(1);\n\n    \n    public static final Collection EMPTY_COLLECTION = UnmodifiableCollection.decorate(new ArrayList());\n\n    \n    public CollectionUtils() {\n    }\n\n    \n    public static Collection union(final Collection a, final Collection b) {\n        ArrayList list = new ArrayList();\n        Map mapa = getCardinalityMap(a);\n        Map mapb = getCardinalityMap(b);\n        Set elts = new HashSet(a);\n        elts.addAll(b);\n        Iterator it = elts.iterator();\n        while(it.hasNext()) {\n            Object obj = it.next();\n            for(int i=0,m=Math.max(getFreq(obj,mapa),getFreq(obj,mapb));i<m;i++) {\n                list.add(obj);\n            }\n        }\n        return list;\n    }\n\n    \n    public static Collection intersection(final Collection a, final Collection b) {\n        ArrayList list = new ArrayList();\n        Map mapa = getCardinalityMap(a);\n        Map mapb = getCardinalityMap(b);\n        Set elts = new HashSet(a);\n        elts.addAll(b);\n        Iterator it = elts.iterator();\n        while(it.hasNext()) {\n            Object obj = it.next();\n            for(int i=0,m=Math.min(getFreq(obj,mapa),getFreq(obj,mapb));i<m;i++) {\n                list.add(obj);\n            }\n        }\n        return list;\n    }\n\n    \n    public static Collection disjunction(final Collection a, final Collection b) {\n        ArrayList list = new ArrayList();\n        Map mapa = getCardinalityMap(a);\n        Map mapb = getCardinalityMap(b);\n        Set elts = new HashSet(a);\n        elts.addAll(b);\n        Iterator it = elts.iterator();\n        while(it.hasNext()) {\n            Object obj = it.next();\n            for(int i=0,m=((Math.max(getFreq(obj,mapa),getFreq(obj,mapb)))-(Math.min(getFreq(obj,mapa),getFreq(obj,mapb))));i<m;i++) {\n                list.add(obj);\n            }\n        }\n        return list;\n    }\n\n    \n    public static Collection subtract(final Collection a, final Collection b) {\n        ArrayList list = new ArrayList( a );\n        for (Iterator it = b.iterator(); it.hasNext();) {\n            list.remove(it.next());\n        }\n        return list;\n    }\n\n    \n    public static boolean containsAny(final Collection coll1, final Collection coll2) {\n        if (coll1.size() < coll2.size()) {\n            for (Iterator it = coll1.iterator(); it.hasNext();) {\n                if (coll2.contains(it.next())) {\n                    return true;\n                }\n            }\n        } else {\n            for (Iterator it = coll2.iterator(); it.hasNext();) {\n                if (coll1.contains(it.next())) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    \n    public static Map getCardinalityMap(final Collection coll) {\n        Map count = new HashMap();\n        for (Iterator it = coll.iterator(); it.hasNext();) {\n            Object obj = it.next();\n            Integer c = (Integer) (count.get(obj));\n            if (c == null) {\n                count.put(obj,INTEGER_ONE);\n            } else {\n                count.put(obj,new Integer(c.intValue() + 1));\n            }\n        }\n        return count;\n    }\n\n    \n    public static boolean isSubCollection(final Collection a, final Collection b) {\n        Map mapa = getCardinalityMap(a);\n        Map mapb = getCardinalityMap(b);\n        Iterator it = a.iterator();\n        while (it.hasNext()) {\n            Object obj = it.next();\n            if (getFreq(obj, mapa) > getFreq(obj, mapb)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public static boolean isProperSubCollection(final Collection a, final Collection b) {\n        return (a.size() < b.size()) && CollectionUtils.isSubCollection(a,b);\n    }\n\n    \n    public static boolean isEqualCollection(final Collection a, final Collection b) {\n        if(a.size() != b.size()) {\n            return false;\n        } else {\n            Map mapa = getCardinalityMap(a);\n            Map mapb = getCardinalityMap(b);\n            if(mapa.size() != mapb.size()) {\n                return false;\n            } else {\n                Iterator it = mapa.keySet().iterator();\n                while(it.hasNext()) {\n                    Object obj = it.next();\n                    if(getFreq(obj,mapa) != getFreq(obj,mapb)) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n        }\n    }\n\n    \n    public static int cardinality(Object obj, final Collection coll) {\n        if (coll instanceof Set) {\n            return (coll.contains(obj) ? 1 : 0);\n        }\n        if (coll instanceof Bag) {\n            return ((Bag) coll).getCount(obj);\n        }\n        int count = 0;\n        if (obj == null) {\n            for (Iterator it = coll.iterator();it.hasNext();) {\n                if (it.next() == null) {\n                    count++;\n                }\n            }\n        } else {\n            for (Iterator it = coll.iterator();it.hasNext();) {\n                if (obj.equals(it.next())) {\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n\n    \n    public static Object find(Collection collection, Predicate predicate) {\n        if (collection != null && predicate != null) {\n            for (Iterator iter = collection.iterator(); iter.hasNext();) {\n                Object item = iter.next();\n                if (predicate.evaluate(item)) {\n                    return item;\n                }\n            }\n        }\n        return null;\n    }\n    \n    \n    public static void forAllDo(Collection collection, Closure closure) {\n        if (collection != null && closure != null) {\n            for (Iterator it = collection.iterator(); it.hasNext();) {\n                closure.execute(it.next());\n            }\n        }\n    }\n\n    \n    public static void filter(Collection collection, Predicate predicate) {\n        if (collection != null && predicate != null) {\n            for (Iterator it = collection.iterator(); it.hasNext();) {\n                if (predicate.evaluate(it.next()) == false) {\n                    it.remove();\n                }\n            }\n        }\n    }\n\n    \n    public static void transform(Collection collection, Transformer transformer) {\n        if (collection != null && transformer != null) {\n            if (collection instanceof List) {\n                List list = (List) collection;\n                for (ListIterator it = list.listIterator(); it.hasNext();) {\n                    it.set(transformer.transform(it.next()));\n                }\n            } else {\n                Collection resultCollection = collect(collection, transformer);\n                collection.clear();\n                collection.addAll(resultCollection);\n            }\n        }\n    }\n\n    \n    public static int countMatches(Collection inputCollection, Predicate predicate) {\n        int count = 0;\n        if (inputCollection != null && predicate != null) {\n            for (Iterator it = inputCollection.iterator(); it.hasNext();) {\n                if (predicate.evaluate(it.next())) {\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n\n    \n    public static boolean exists(Collection collection, Predicate predicate) {\n        if (collection != null && predicate != null) {\n            for (Iterator it = collection.iterator(); it.hasNext();) {\n                if (predicate.evaluate(it.next())) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    \n    public static Collection select(Collection inputCollection, Predicate predicate) {\n        ArrayList answer = new ArrayList(inputCollection.size());\n        select(inputCollection, predicate, answer);\n        return answer;\n    }\n\n    \n    public static void select(Collection inputCollection, Predicate predicate, Collection outputCollection) {\n        if (inputCollection != null && predicate != null) {\n            for (Iterator iter = inputCollection.iterator(); iter.hasNext();) {\n                Object item = iter.next();\n                if (predicate.evaluate(item)) {\n                    outputCollection.add(item);\n                }\n            }\n        }\n    }\n    \n    \n    public static Collection selectRejected(Collection inputCollection, Predicate predicate) {\n        ArrayList answer = new ArrayList(inputCollection.size());\n        selectRejected(inputCollection, predicate, answer);\n        return answer;\n    }\n    \n    \n    public static void selectRejected(Collection inputCollection, Predicate predicate, Collection outputCollection) {\n        if (inputCollection != null && predicate != null) {\n            for (Iterator iter = inputCollection.iterator(); iter.hasNext();) {\n                Object item = iter.next();\n                if (predicate.evaluate(item) == false) {\n                    outputCollection.add(item);\n                }\n            }\n        }\n    }\n    \n    \n    public static Collection collect(Collection inputCollection, Transformer transformer) {\n        ArrayList answer = new ArrayList(inputCollection.size());\n        collect(inputCollection, transformer, answer);\n        return answer;\n    }\n    \n    \n    public static Collection collect(Iterator inputIterator, Transformer transformer) {\n        ArrayList answer = new ArrayList();\n        collect(inputIterator, transformer, answer);\n        return answer;\n    }\n    \n    \n    public static Collection collect(Collection inputCollection, final Transformer transformer, final Collection outputCollection) {\n        if (inputCollection != null) {\n            return collect(inputCollection.iterator(), transformer, outputCollection);\n        }\n        return outputCollection;\n    }\n\n    \n    public static Collection collect(Iterator inputIterator, final Transformer transformer, final Collection outputCollection) {\n        if (inputIterator != null && transformer != null) {\n            while (inputIterator.hasNext()) {\n                Object item = inputIterator.next();\n                Object value = transformer.transform(item);\n                outputCollection.add(value);\n            }\n        }\n        return outputCollection;\n    }\n\n    \n    \n    public static boolean addIgnoreNull(Collection collection, Object object) {\n        return (object == null ? false : collection.add(object));\n    }\n    \n    \n    public static void addAll(Collection collection, Iterator iterator) {\n        while (iterator.hasNext()) {\n            collection.add(iterator.next());\n        }\n    }\n    \n    \n    public static void addAll(Collection collection, Enumeration enumeration) {\n        while (enumeration.hasMoreElements()) {\n            collection.add(enumeration.nextElement());\n        }\n    }    \n    \n    \n    public static void addAll(Collection collection, Object[] elements) {\n        for (int i = 0, size = elements.length; i < size; i++) {\n            collection.add(elements[i]);\n        }\n    }    \n    \n    \n    public static Object index(Object obj, int idx) {\n        return index(obj, new Integer(idx));\n    }\n    \n    \n    public static Object index(Object obj, Object index) {\n        if(obj instanceof Map) {\n            Map map = (Map)obj;\n            if(map.containsKey(index)) {\n                return map.get(index);\n            }\n        }\n        int idx = -1;\n        if(index instanceof Integer) {\n            idx = ((Integer)index).intValue();\n        }\n        if(idx < 0) {\n            return obj;\n        } \n        else if(obj instanceof Map) {\n            Map map = (Map)obj;\n            Iterator iterator = map.keySet().iterator();\n            return index(iterator, idx);\n        } \n        else if(obj instanceof List) {\n            return ((List)obj).get(idx);\n        } \n        else if(obj instanceof Object[]) {\n            return ((Object[])obj)[idx];\n        } \n        else if(obj instanceof Enumeration) {\n            Enumeration it = (Enumeration)obj;\n            while(it.hasMoreElements()) {\n                idx--;\n                if(idx == -1) {\n                    return it.nextElement();\n                } else {\n                    it.nextElement();\n                }\n            }\n        } \n        else if(obj instanceof Iterator) {\n            return index((Iterator)obj, idx);\n        }\n        else if(obj instanceof Collection) {\n            Iterator iterator = ((Collection)obj).iterator();\n            return index(iterator, idx);\n        }\n        return obj;\n    }\n\n    private static Object index(Iterator iterator, int idx) {\n        while(iterator.hasNext()) {\n            idx--;\n            if(idx == -1) {\n                return iterator.next();\n            } else {\n                iterator.next();\n            }\n        }\n        return iterator;\n    }\n    \n    \n    public static Object get(Object object, int index) {\n        if (index < 0) {\n            throw new IndexOutOfBoundsException(\"Index cannot be negative: \" + index);\n        }\n        if (object instanceof Map) {\n            Map map = (Map) object;\n            Iterator iterator = map.entrySet().iterator();\n            return get(iterator, index);\n        } else if (object instanceof List) {\n            return ((List) object).get(index);\n        } else if (object instanceof Object[]) {\n            return ((Object[]) object)[index];\n        } else if (object instanceof Iterator) {\n            Iterator it = (Iterator) object;\n            while (it.hasNext()) {\n                index--;\n                if (index == -1) {\n                    return it.next();\n                } else {\n                    it.next();\n                }\n            }\n            throw new IndexOutOfBoundsException(\"Entry does not exist: \" + index);\n        } else if (object instanceof Collection) {\n            Iterator iterator = ((Collection) object).iterator();\n            return get(iterator, index);\n        } else if (object instanceof Enumeration) {\n            Enumeration it = (Enumeration) object;\n            while (it.hasMoreElements()) {\n                index--;\n                if (index == -1) {\n                    return it.nextElement();\n                } else {\n                    it.nextElement();\n                }\n            }\n            throw new IndexOutOfBoundsException(\"Entry does not exist: \" + index);\n        } else if (object == null) {\n            throw new IllegalArgumentException(\"Unsupported object type: null\");\n        } else {\n            try {\n                return Array.get(object, index);\n            } catch (IllegalArgumentException ex) {\n                throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n            }\n        }\n    }\n    \n    \n    public static int size(Object object) {\n        int total = 0;\n        if (object instanceof Map) {\n            total = ((Map) object).size();\n        } else if (object instanceof Collection) {\n            total = ((Collection) object).size();\n        } else if (object instanceof Object[]) {\n            total = ((Object[]) object).length;\n        } else if (object instanceof Iterator) {\n            Iterator it = (Iterator) object;\n            while (it.hasNext()) {\n                total++;\n                it.next();\n            }\n        } else if (object instanceof Enumeration) {\n            Enumeration it = (Enumeration) object;\n            while (it.hasMoreElements()) {\n                total++;\n                it.nextElement();\n            }\n        } else if (object == null) {\n            throw new IllegalArgumentException(\"Unsupported object type: null\");\n        } else {\n            try {\n                total = Array.getLength(object);\n            } catch (IllegalArgumentException ex) {\n                throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n            }\n        }\n        return total;\n    }\n    \n    \n    public static boolean sizeIsEmpty(Object object) {\n        if (object instanceof Collection) {\n            return ((Collection) object).isEmpty();\n        } else if (object instanceof Map) {\n            return ((Map) object).isEmpty();\n        } else if (object instanceof Object[]) {\n            return ((Object[]) object).length == 0;\n        } else if (object instanceof Iterator) {\n            return ((Iterator) object).hasNext() == false;\n        } else if (object instanceof Enumeration) {\n            return ((Enumeration) object).hasMoreElements() == false;\n        } else if (object == null) {\n            throw new IllegalArgumentException(\"Unsupported object type: null\");\n        } else {\n            try {\n                return Array.getLength(object) == 0;\n            } catch (IllegalArgumentException ex) {\n                throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n            }\n        }\n    }\n\n    \n    \n    public static boolean isEmpty(Collection coll) {\n        return (coll == null || coll.isEmpty());\n    }\n\n    \n    public static boolean isNotEmpty(Collection coll) {\n        return !CollectionUtils.isEmpty(coll);\n    }\n\n    \n    \n    public static void reverseArray(Object[] array) {\n        int i = 0;\n        int j = array.length - 1;\n        Object tmp;\n\n        while (j > i) {\n            tmp = array[j];\n            array[j] = array[i];\n            array[i] = tmp;\n            j--;\n            i++;\n        }\n    }\n\n    private static final int getFreq(final Object obj, final Map freqMap) {\n        Integer count = (Integer) freqMap.get(obj);\n        if (count != null) {\n            return count.intValue();\n        }\n        return 0;\n    }\n\n    \n    public static boolean isFull(Collection coll) {\n        if (coll == null) {\n            throw new NullPointerException(\"The collection must not be null\");\n        }\n        if (coll instanceof BoundedCollection) {\n            return ((BoundedCollection) coll).isFull();\n        }\n        try {\n            BoundedCollection bcoll = UnmodifiableBoundedCollection.decorateUsing(coll);\n            return bcoll.isFull();\n            \n        } catch (IllegalArgumentException ex) {\n            return false;\n        }\n    }\n\n    \n    public static int maxSize(Collection coll) {\n        if (coll == null) {\n            throw new NullPointerException(\"The collection must not be null\");\n        }\n        if (coll instanceof BoundedCollection) {\n            return ((BoundedCollection) coll).maxSize();\n        }\n        try {\n            BoundedCollection bcoll = UnmodifiableBoundedCollection.decorateUsing(coll);\n            return bcoll.maxSize();\n            \n        } catch (IllegalArgumentException ex) {\n            return -1;\n        }\n    }\n\n    \n    \n    public static Collection retainAll(Collection collection, Collection retain) {\n        return ListUtils.retainAll(collection, retain);\n    }\n\n    \n    public static Collection removeAll(Collection collection, Collection remove) {\n        return ListUtils.retainAll(collection, remove);\n    }\n\n    \n    \n    public static Collection synchronizedCollection(Collection collection) {\n        return SynchronizedCollection.decorate(collection);\n    }\n\n    \n    public static Collection unmodifiableCollection(Collection collection) {\n        return UnmodifiableCollection.decorate(collection);\n    }\n\n    \n    public static Collection predicatedCollection(Collection collection, Predicate predicate) {\n        return PredicatedCollection.decorate(collection, predicate);\n    }\n\n    \n    public static Collection typedCollection(Collection collection, Class type) {\n        return TypedCollection.decorate(collection, type);\n    }\n    \n    \n    public static Collection transformedCollection(Collection collection, Transformer transformer) {\n        return TransformedCollection.decorate(collection, transformer);\n    }\n\n}\n",
      "fixed_full_code": "\npackage org.apache.commons.collections;\n\nimport java.lang.reflect.Array;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.apache.commons.collections.collection.PredicatedCollection;\nimport org.apache.commons.collections.collection.SynchronizedCollection;\nimport org.apache.commons.collections.collection.TransformedCollection;\nimport org.apache.commons.collections.collection.TypedCollection;\nimport org.apache.commons.collections.collection.UnmodifiableBoundedCollection;\nimport org.apache.commons.collections.collection.UnmodifiableCollection;\n\n\npublic class CollectionUtils {\n\n    \n    private static Integer INTEGER_ONE = new Integer(1);\n\n    \n    public static final Collection EMPTY_COLLECTION = UnmodifiableCollection.decorate(new ArrayList());\n\n    \n    public CollectionUtils() {\n    }\n\n    \n    public static Collection union(final Collection a, final Collection b) {\n        ArrayList list = new ArrayList();\n        Map mapa = getCardinalityMap(a);\n        Map mapb = getCardinalityMap(b);\n        Set elts = new HashSet(a);\n        elts.addAll(b);\n        Iterator it = elts.iterator();\n        while(it.hasNext()) {\n            Object obj = it.next();\n            for(int i=0,m=Math.max(getFreq(obj,mapa),getFreq(obj,mapb));i<m;i++) {\n                list.add(obj);\n            }\n        }\n        return list;\n    }\n\n    \n    public static Collection intersection(final Collection a, final Collection b) {\n        ArrayList list = new ArrayList();\n        Map mapa = getCardinalityMap(a);\n        Map mapb = getCardinalityMap(b);\n        Set elts = new HashSet(a);\n        elts.addAll(b);\n        Iterator it = elts.iterator();\n        while(it.hasNext()) {\n            Object obj = it.next();\n            for(int i=0,m=Math.min(getFreq(obj,mapa),getFreq(obj,mapb));i<m;i++) {\n                list.add(obj);\n            }\n        }\n        return list;\n    }\n\n    \n    public static Collection disjunction(final Collection a, final Collection b) {\n        ArrayList list = new ArrayList();\n        Map mapa = getCardinalityMap(a);\n        Map mapb = getCardinalityMap(b);\n        Set elts = new HashSet(a);\n        elts.addAll(b);\n        Iterator it = elts.iterator();\n        while(it.hasNext()) {\n            Object obj = it.next();\n            for(int i=0,m=((Math.max(getFreq(obj,mapa),getFreq(obj,mapb)))-(Math.min(getFreq(obj,mapa),getFreq(obj,mapb))));i<m;i++) {\n                list.add(obj);\n            }\n        }\n        return list;\n    }\n\n    \n    public static Collection subtract(final Collection a, final Collection b) {\n        ArrayList list = new ArrayList( a );\n        for (Iterator it = b.iterator(); it.hasNext();) {\n            list.remove(it.next());\n        }\n        return list;\n    }\n\n    \n    public static boolean containsAny(final Collection coll1, final Collection coll2) {\n        if (coll1.size() < coll2.size()) {\n            for (Iterator it = coll1.iterator(); it.hasNext();) {\n                if (coll2.contains(it.next())) {\n                    return true;\n                }\n            }\n        } else {\n            for (Iterator it = coll2.iterator(); it.hasNext();) {\n                if (coll1.contains(it.next())) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    \n    public static Map getCardinalityMap(final Collection coll) {\n        Map count = new HashMap();\n        for (Iterator it = coll.iterator(); it.hasNext();) {\n            Object obj = it.next();\n            Integer c = (Integer) (count.get(obj));\n            if (c == null) {\n                count.put(obj,INTEGER_ONE);\n            } else {\n                count.put(obj,new Integer(c.intValue() + 1));\n            }\n        }\n        return count;\n    }\n\n    \n    public static boolean isSubCollection(final Collection a, final Collection b) {\n        Map mapa = getCardinalityMap(a);\n        Map mapb = getCardinalityMap(b);\n        Iterator it = a.iterator();\n        while (it.hasNext()) {\n            Object obj = it.next();\n            if (getFreq(obj, mapa) > getFreq(obj, mapb)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public static boolean isProperSubCollection(final Collection a, final Collection b) {\n        return (a.size() < b.size()) && CollectionUtils.isSubCollection(a,b);\n    }\n\n    \n    public static boolean isEqualCollection(final Collection a, final Collection b) {\n        if(a.size() != b.size()) {\n            return false;\n        } else {\n            Map mapa = getCardinalityMap(a);\n            Map mapb = getCardinalityMap(b);\n            if(mapa.size() != mapb.size()) {\n                return false;\n            } else {\n                Iterator it = mapa.keySet().iterator();\n                while(it.hasNext()) {\n                    Object obj = it.next();\n                    if(getFreq(obj,mapa) != getFreq(obj,mapb)) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n        }\n    }\n\n    \n    public static int cardinality(Object obj, final Collection coll) {\n        if (coll instanceof Set) {\n            return (coll.contains(obj) ? 1 : 0);\n        }\n        if (coll instanceof Bag) {\n            return ((Bag) coll).getCount(obj);\n        }\n        int count = 0;\n        if (obj == null) {\n            for (Iterator it = coll.iterator();it.hasNext();) {\n                if (it.next() == null) {\n                    count++;\n                }\n            }\n        } else {\n            for (Iterator it = coll.iterator();it.hasNext();) {\n                if (obj.equals(it.next())) {\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n\n    \n    public static Object find(Collection collection, Predicate predicate) {\n        if (collection != null && predicate != null) {\n            for (Iterator iter = collection.iterator(); iter.hasNext();) {\n                Object item = iter.next();\n                if (predicate.evaluate(item)) {\n                    return item;\n                }\n            }\n        }\n        return null;\n    }\n    \n    \n    public static void forAllDo(Collection collection, Closure closure) {\n        if (collection != null && closure != null) {\n            for (Iterator it = collection.iterator(); it.hasNext();) {\n                closure.execute(it.next());\n            }\n        }\n    }\n\n    \n    public static void filter(Collection collection, Predicate predicate) {\n        if (collection != null && predicate != null) {\n            for (Iterator it = collection.iterator(); it.hasNext();) {\n                if (predicate.evaluate(it.next()) == false) {\n                    it.remove();\n                }\n            }\n        }\n    }\n\n    \n    public static void transform(Collection collection, Transformer transformer) {\n        if (collection != null && transformer != null) {\n            if (collection instanceof List) {\n                List list = (List) collection;\n                for (ListIterator it = list.listIterator(); it.hasNext();) {\n                    it.set(transformer.transform(it.next()));\n                }\n            } else {\n                Collection resultCollection = collect(collection, transformer);\n                collection.clear();\n                collection.addAll(resultCollection);\n            }\n        }\n    }\n\n    \n    public static int countMatches(Collection inputCollection, Predicate predicate) {\n        int count = 0;\n        if (inputCollection != null && predicate != null) {\n            for (Iterator it = inputCollection.iterator(); it.hasNext();) {\n                if (predicate.evaluate(it.next())) {\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n\n    \n    public static boolean exists(Collection collection, Predicate predicate) {\n        if (collection != null && predicate != null) {\n            for (Iterator it = collection.iterator(); it.hasNext();) {\n                if (predicate.evaluate(it.next())) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    \n    public static Collection select(Collection inputCollection, Predicate predicate) {\n        ArrayList answer = new ArrayList(inputCollection.size());\n        select(inputCollection, predicate, answer);\n        return answer;\n    }\n\n    \n    public static void select(Collection inputCollection, Predicate predicate, Collection outputCollection) {\n        if (inputCollection != null && predicate != null) {\n            for (Iterator iter = inputCollection.iterator(); iter.hasNext();) {\n                Object item = iter.next();\n                if (predicate.evaluate(item)) {\n                    outputCollection.add(item);\n                }\n            }\n        }\n    }\n    \n    \n    public static Collection selectRejected(Collection inputCollection, Predicate predicate) {\n        ArrayList answer = new ArrayList(inputCollection.size());\n        selectRejected(inputCollection, predicate, answer);\n        return answer;\n    }\n    \n    \n    public static void selectRejected(Collection inputCollection, Predicate predicate, Collection outputCollection) {\n        if (inputCollection != null && predicate != null) {\n            for (Iterator iter = inputCollection.iterator(); iter.hasNext();) {\n                Object item = iter.next();\n                if (predicate.evaluate(item) == false) {\n                    outputCollection.add(item);\n                }\n            }\n        }\n    }\n    \n    \n    public static Collection collect(Collection inputCollection, Transformer transformer) {\n        ArrayList answer = new ArrayList(inputCollection.size());\n        collect(inputCollection, transformer, answer);\n        return answer;\n    }\n    \n    \n    public static Collection collect(Iterator inputIterator, Transformer transformer) {\n        ArrayList answer = new ArrayList();\n        collect(inputIterator, transformer, answer);\n        return answer;\n    }\n    \n    \n    public static Collection collect(Collection inputCollection, final Transformer transformer, final Collection outputCollection) {\n        if (inputCollection != null) {\n            return collect(inputCollection.iterator(), transformer, outputCollection);\n        }\n        return outputCollection;\n    }\n\n    \n    public static Collection collect(Iterator inputIterator, final Transformer transformer, final Collection outputCollection) {\n        if (inputIterator != null && transformer != null) {\n            while (inputIterator.hasNext()) {\n                Object item = inputIterator.next();\n                Object value = transformer.transform(item);\n                outputCollection.add(value);\n            }\n        }\n        return outputCollection;\n    }\n\n    \n    \n    public static boolean addIgnoreNull(Collection collection, Object object) {\n        return (object == null ? false : collection.add(object));\n    }\n    \n    \n    public static void addAll(Collection collection, Iterator iterator) {\n        while (iterator.hasNext()) {\n            collection.add(iterator.next());\n        }\n    }\n    \n    \n    public static void addAll(Collection collection, Enumeration enumeration) {\n        while (enumeration.hasMoreElements()) {\n            collection.add(enumeration.nextElement());\n        }\n    }    \n    \n    \n    public static void addAll(Collection collection, Object[] elements) {\n        for (int i = 0, size = elements.length; i < size; i++) {\n            collection.add(elements[i]);\n        }\n    }    \n    \n    \n    public static Object index(Object obj, int idx) {\n        return index(obj, new Integer(idx));\n    }\n    \n    \n    public static Object index(Object obj, Object index) {\n        if(obj instanceof Map) {\n            Map map = (Map)obj;\n            if(map.containsKey(index)) {\n                return map.get(index);\n            }\n        }\n        int idx = -1;\n        if(index instanceof Integer) {\n            idx = ((Integer)index).intValue();\n        }\n        if(idx < 0) {\n            return obj;\n        } \n        else if(obj instanceof Map) {\n            Map map = (Map)obj;\n            Iterator iterator = map.keySet().iterator();\n            return index(iterator, idx);\n        } \n        else if(obj instanceof List) {\n            return ((List)obj).get(idx);\n        } \n        else if(obj instanceof Object[]) {\n            return ((Object[])obj)[idx];\n        } \n        else if(obj instanceof Enumeration) {\n            Enumeration it = (Enumeration)obj;\n            while(it.hasMoreElements()) {\n                idx--;\n                if(idx == -1) {\n                    return it.nextElement();\n                } else {\n                    it.nextElement();\n                }\n            }\n        } \n        else if(obj instanceof Iterator) {\n            return index((Iterator)obj, idx);\n        }\n        else if(obj instanceof Collection) {\n            Iterator iterator = ((Collection)obj).iterator();\n            return index(iterator, idx);\n        }\n        return obj;\n    }\n\n    private static Object index(Iterator iterator, int idx) {\n        while(iterator.hasNext()) {\n            idx--;\n            if(idx == -1) {\n                return iterator.next();\n            } else {\n                iterator.next();\n            }\n        }\n        return iterator;\n    }\n    \n    \n    public static Object get(Object object, int index) {\n        if (index < 0) {\n            throw new IndexOutOfBoundsException(\"Index cannot be negative: \" + index);\n        }\n        if (object instanceof Map) {\n            Map map = (Map) object;\n            Iterator iterator = map.entrySet().iterator();\n            return get(iterator, index);\n        } else if (object instanceof List) {\n            return ((List) object).get(index);\n        } else if (object instanceof Object[]) {\n            return ((Object[]) object)[index];\n        } else if (object instanceof Iterator) {\n            Iterator it = (Iterator) object;\n            while (it.hasNext()) {\n                index--;\n                if (index == -1) {\n                    return it.next();\n                } else {\n                    it.next();\n                }\n            }\n            throw new IndexOutOfBoundsException(\"Entry does not exist: \" + index);\n        } else if (object instanceof Collection) {\n            Iterator iterator = ((Collection) object).iterator();\n            return get(iterator, index);\n        } else if (object instanceof Enumeration) {\n            Enumeration it = (Enumeration) object;\n            while (it.hasMoreElements()) {\n                index--;\n                if (index == -1) {\n                    return it.nextElement();\n                } else {\n                    it.nextElement();\n                }\n            }\n            throw new IndexOutOfBoundsException(\"Entry does not exist: \" + index);\n        } else if (object == null) {\n            throw new IllegalArgumentException(\"Unsupported object type: null\");\n        } else {\n            try {\n                return Array.get(object, index);\n            } catch (IllegalArgumentException ex) {\n                throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n            }\n        }\n    }\n    \n    \n    public static int size(Object object) {\n        int total = 0;\n        if (object instanceof Map) {\n            total = ((Map) object).size();\n        } else if (object instanceof Collection) {\n            total = ((Collection) object).size();\n        } else if (object instanceof Object[]) {\n            total = ((Object[]) object).length;\n        } else if (object instanceof Iterator) {\n            Iterator it = (Iterator) object;\n            while (it.hasNext()) {\n                total++;\n                it.next();\n            }\n        } else if (object instanceof Enumeration) {\n            Enumeration it = (Enumeration) object;\n            while (it.hasMoreElements()) {\n                total++;\n                it.nextElement();\n            }\n        } else if (object == null) {\n            throw new IllegalArgumentException(\"Unsupported object type: null\");\n        } else {\n            try {\n                total = Array.getLength(object);\n            } catch (IllegalArgumentException ex) {\n                throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n            }\n        }\n        return total;\n    }\n    \n    \n    public static boolean sizeIsEmpty(Object object) {\n        if (object instanceof Collection) {\n            return ((Collection) object).isEmpty();\n        } else if (object instanceof Map) {\n            return ((Map) object).isEmpty();\n        } else if (object instanceof Object[]) {\n            return ((Object[]) object).length == 0;\n        } else if (object instanceof Iterator) {\n            return ((Iterator) object).hasNext() == false;\n        } else if (object instanceof Enumeration) {\n            return ((Enumeration) object).hasMoreElements() == false;\n        } else if (object == null) {\n            throw new IllegalArgumentException(\"Unsupported object type: null\");\n        } else {\n            try {\n                return Array.getLength(object) == 0;\n            } catch (IllegalArgumentException ex) {\n                throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n            }\n        }\n    }\n\n    \n    \n    public static boolean isEmpty(Collection coll) {\n        return (coll == null || coll.isEmpty());\n    }\n\n    \n    public static boolean isNotEmpty(Collection coll) {\n        return !CollectionUtils.isEmpty(coll);\n    }\n\n    \n    \n    public static void reverseArray(Object[] array) {\n        int i = 0;\n        int j = array.length - 1;\n        Object tmp;\n\n        while (j > i) {\n            tmp = array[j];\n            array[j] = array[i];\n            array[i] = tmp;\n            j--;\n            i++;\n        }\n    }\n\n    private static final int getFreq(final Object obj, final Map freqMap) {\n        Integer count = (Integer) freqMap.get(obj);\n        if (count != null) {\n            return count.intValue();\n        }\n        return 0;\n    }\n\n    \n    public static boolean isFull(Collection coll) {\n        if (coll == null) {\n            throw new NullPointerException(\"The collection must not be null\");\n        }\n        if (coll instanceof BoundedCollection) {\n            return ((BoundedCollection) coll).isFull();\n        }\n        try {\n            BoundedCollection bcoll = UnmodifiableBoundedCollection.decorateUsing(coll);\n            return bcoll.isFull();\n            \n        } catch (IllegalArgumentException ex) {\n            return false;\n        }\n    }\n\n    \n    public static int maxSize(Collection coll) {\n        if (coll == null) {\n            throw new NullPointerException(\"The collection must not be null\");\n        }\n        if (coll instanceof BoundedCollection) {\n            return ((BoundedCollection) coll).maxSize();\n        }\n        try {\n            BoundedCollection bcoll = UnmodifiableBoundedCollection.decorateUsing(coll);\n            return bcoll.maxSize();\n            \n        } catch (IllegalArgumentException ex) {\n            return -1;\n        }\n    }\n\n    \n    \n    public static Collection retainAll(Collection collection, Collection retain) {\n        return ListUtils.retainAll(collection, retain);\n    }\n\n    \n    public static Collection removeAll(Collection collection, Collection remove) {\n        return ListUtils.removeAll(collection, remove);\n    }\n\n    \n    \n    public static Collection synchronizedCollection(Collection collection) {\n        return SynchronizedCollection.decorate(collection);\n    }\n\n    \n    public static Collection unmodifiableCollection(Collection collection) {\n        return UnmodifiableCollection.decorate(collection);\n    }\n\n    \n    public static Collection predicatedCollection(Collection collection, Predicate predicate) {\n        return PredicatedCollection.decorate(collection, predicate);\n    }\n\n    \n    public static Collection typedCollection(Collection collection, Class type) {\n        return TypedCollection.decorate(collection, type);\n    }\n    \n    \n    public static Collection transformedCollection(Collection collection, Transformer transformer) {\n        return TransformedCollection.decorate(collection, transformer);\n    }\n\n}\n",
      "buggy_signatures": [
        "private static Integer INTEGER_ONE = new Integer(1)",
        "public static final Collection EMPTY_COLLECTION = UnmodifiableCollection.decorate(new ArrayList())",
        "public CollectionUtils()",
        "public static Collection union(final Collection a, final Collection b)",
        "public static Collection intersection(final Collection a, final Collection b)",
        "public static Collection disjunction(final Collection a, final Collection b)",
        "public static Collection subtract(final Collection a, final Collection b)",
        "public static boolean containsAny(final Collection coll1, final Collection coll2)",
        "public static Map getCardinalityMap(final Collection coll)",
        "public static boolean isSubCollection(final Collection a, final Collection b)",
        "public static boolean isProperSubCollection(final Collection a, final Collection b)",
        "public static boolean isEqualCollection(final Collection a, final Collection b)",
        "public static int cardinality(Object obj, final Collection coll)",
        "public static Object find(Collection collection, Predicate predicate)",
        "public static void forAllDo(Collection collection, Closure closure)",
        "public static void filter(Collection collection, Predicate predicate)",
        "public static void transform(Collection collection, Transformer transformer)",
        "public static int countMatches(Collection inputCollection, Predicate predicate)",
        "public static boolean exists(Collection collection, Predicate predicate)",
        "public static Collection select(Collection inputCollection, Predicate predicate)",
        "public static void select(Collection inputCollection, Predicate predicate, Collection outputCollection)",
        "public static Collection selectRejected(Collection inputCollection, Predicate predicate)",
        "public static void selectRejected(Collection inputCollection, Predicate predicate, Collection outputCollection)",
        "public static Collection collect(Collection inputCollection, Transformer transformer)",
        "public static Collection collect(Iterator inputIterator, Transformer transformer)",
        "public static Collection collect(Collection inputCollection, final Transformer transformer, final Collection outputCollection)",
        "public static Collection collect(Iterator inputIterator, final Transformer transformer, final Collection outputCollection)",
        "public static boolean addIgnoreNull(Collection collection, Object object)",
        "public static void addAll(Collection collection, Iterator iterator)",
        "public static void addAll(Collection collection, Enumeration enumeration)",
        "public static void addAll(Collection collection, Object[] elements)",
        "public static Object index(Object obj, int idx)",
        "public static Object index(Object obj, Object index)",
        "private static Object index(Iterator iterator, int idx)",
        "public static Object get(Object object, int index)",
        "public static int size(Object object)",
        "public static boolean sizeIsEmpty(Object object)",
        "public static boolean isEmpty(Collection coll)",
        "public static boolean isNotEmpty(Collection coll)",
        "public static void reverseArray(Object[] array)",
        "private static final int getFreq(final Object obj, final Map freqMap)",
        "public static boolean isFull(Collection coll)",
        "public static int maxSize(Collection coll)",
        "public static Collection retainAll(Collection collection, Collection retain)",
        "public static Collection removeAll(Collection collection, Collection remove)",
        "public static Collection synchronizedCollection(Collection collection)",
        "public static Collection unmodifiableCollection(Collection collection)",
        "public static Collection predicatedCollection(Collection collection, Predicate predicate)",
        "public static Collection typedCollection(Collection collection, Class type)",
        "public static Collection transformedCollection(Collection collection, Transformer transformer)"
      ],
      "fixed_signatures": [
        "private static Integer INTEGER_ONE = new Integer(1)",
        "public static final Collection EMPTY_COLLECTION = UnmodifiableCollection.decorate(new ArrayList())",
        "public CollectionUtils()",
        "public static Collection union(final Collection a, final Collection b)",
        "public static Collection intersection(final Collection a, final Collection b)",
        "public static Collection disjunction(final Collection a, final Collection b)",
        "public static Collection subtract(final Collection a, final Collection b)",
        "public static boolean containsAny(final Collection coll1, final Collection coll2)",
        "public static Map getCardinalityMap(final Collection coll)",
        "public static boolean isSubCollection(final Collection a, final Collection b)",
        "public static boolean isProperSubCollection(final Collection a, final Collection b)",
        "public static boolean isEqualCollection(final Collection a, final Collection b)",
        "public static int cardinality(Object obj, final Collection coll)",
        "public static Object find(Collection collection, Predicate predicate)",
        "public static void forAllDo(Collection collection, Closure closure)",
        "public static void filter(Collection collection, Predicate predicate)",
        "public static void transform(Collection collection, Transformer transformer)",
        "public static int countMatches(Collection inputCollection, Predicate predicate)",
        "public static boolean exists(Collection collection, Predicate predicate)",
        "public static Collection select(Collection inputCollection, Predicate predicate)",
        "public static void select(Collection inputCollection, Predicate predicate, Collection outputCollection)",
        "public static Collection selectRejected(Collection inputCollection, Predicate predicate)",
        "public static void selectRejected(Collection inputCollection, Predicate predicate, Collection outputCollection)",
        "public static Collection collect(Collection inputCollection, Transformer transformer)",
        "public static Collection collect(Iterator inputIterator, Transformer transformer)",
        "public static Collection collect(Collection inputCollection, final Transformer transformer, final Collection outputCollection)",
        "public static Collection collect(Iterator inputIterator, final Transformer transformer, final Collection outputCollection)",
        "public static boolean addIgnoreNull(Collection collection, Object object)",
        "public static void addAll(Collection collection, Iterator iterator)",
        "public static void addAll(Collection collection, Enumeration enumeration)",
        "public static void addAll(Collection collection, Object[] elements)",
        "public static Object index(Object obj, int idx)",
        "public static Object index(Object obj, Object index)",
        "private static Object index(Iterator iterator, int idx)",
        "public static Object get(Object object, int index)",
        "public static int size(Object object)",
        "public static boolean sizeIsEmpty(Object object)",
        "public static boolean isEmpty(Collection coll)",
        "public static boolean isNotEmpty(Collection coll)",
        "public static void reverseArray(Object[] array)",
        "private static final int getFreq(final Object obj, final Map freqMap)",
        "public static boolean isFull(Collection coll)",
        "public static int maxSize(Collection coll)",
        "public static Collection retainAll(Collection collection, Collection retain)",
        "public static Collection removeAll(Collection collection, Collection remove)",
        "public static Collection synchronizedCollection(Collection collection)",
        "public static Collection unmodifiableCollection(Collection collection)",
        "public static Collection predicatedCollection(Collection collection, Predicate predicate)",
        "public static Collection typedCollection(Collection collection, Class type)",
        "public static Collection transformedCollection(Collection collection, Transformer transformer)"
      ],
      "methods": [
        {
          "buggy_method": "  public static Collection removeAll(Collection collection, Collection remove) {\n  return ListUtils.retainAll(collection, remove);\n  }",
          "fixed_method": "  public static Collection removeAll(Collection collection, Collection remove) {\n  return ListUtils.removeAll(collection, remove);\n  }",
          "diff": [
            "@@ -1118,7 +1118,7 @@",
            "      * @since Commons Collections 3.3 (method existed in 3.2 but was completely broken)\n",
            "      */\n",
            "     public static Collection removeAll(Collection collection, Collection remove) {\n",
            "-        return ListUtils.retainAll(collection, remove);\n",
            "+        return ListUtils.removeAll(collection, remove);\n",
            "     }\n",
            " \n",
            "     //-----------------------------------------------------------------------\n"
          ],
          "changed_lines": 2
        }
      ]
    }
  ]
}