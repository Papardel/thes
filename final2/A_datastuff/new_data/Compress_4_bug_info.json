{
  "bug_id": "4",
  "failed_tests": {
    "org.apache.commons.compress.archivers.jar.JarArchiveOutputStreamTest": [
      {
        "methodName": "testJarMarker",
        "error": "java.io.IOException",
        "message": "central directory is empty, can't expand corrupt archive.",
        "fail_line": "            zf = new ZipFile(testArchive);",
        "test_source": "  public void testJarMarker() throws IOException {\n  File testArchive = File.createTempFile(\"jar-aostest\", \".jar\");\n  JarArchiveOutputStream out = null;\n  ZipFile zf = null;\n  try {\n\n  out = new JarArchiveOutputStream(new FileOutputStream(testArchive));\n  out.putArchiveEntry(new ZipArchiveEntry(\"foo/\"));\n  out.closeArchiveEntry();\n  out.putArchiveEntry(new ZipArchiveEntry(\"bar/\"));\n  out.closeArchiveEntry();\n  out.finish();\n  out.close();\n  out = null;\n\n  zf = new ZipFile(testArchive);\n  ZipArchiveEntry ze = zf.getEntry(\"foo/\");\n  assertNotNull(ze);\n  ZipExtraField[] fes = ze.getExtraFields();\n  assertEquals(1, fes.length);\n  assertTrue(fes[0] instanceof JarMarker);\n\n  ze = zf.getEntry(\"bar/\");\n  assertNotNull(ze);\n  fes = ze.getExtraFields();\n  assertEquals(0, fes.length);\n  } finally {\n  if (out != null) {\n  try {\n  out.close();\n  } catch (IOException e) { /* swallow */ }\n  }\n  ZipFile.closeQuietly(zf);\n  if (testArchive.exists()) {\n  testArchive.delete();\n  }\n  }\n  }",
        "stack": [
          "ZipFile.populateFromCentralDirectory line 318, ZipFile.<init> line 181, ZipFile.<init> line 158, ZipFile.<init> line 119, JarArchiveOutputStreamTest.testJarMarker line 48"
        ]
      }
    ],
    "org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest": [
      {
        "methodName": "testCP437FileRoundtripImplicitUnicodeExtra",
        "error": "java.io.IOException",
        "message": "central directory is empty, can't expand corrupt archive.",
        "fail_line": "        testFileRoundtrip(CP437, false, false);",
        "test_source": "  public void testCP437FileRoundtripImplicitUnicodeExtra()\n  throws IOException {\n  testFileRoundtrip(CP437, false, false);\n  }",
        "stack": [
          "ZipFile.populateFromCentralDirectory line 318, ZipFile.<init> line 181, UTF8ZipFilesTest.testFile line 291, UTF8ZipFilesTest.testFileRoundtrip line 202, UTF8ZipFilesTest.testCP437FileRoundtripImplicitUnicodeExtra line 75"
        ]
      },
      {
        "methodName": "testUtf8FileRoundtripImplicitUnicodeExtra",
        "error": "java.io.IOException",
        "message": "central directory is empty, can't expand corrupt archive.",
        "fail_line": "        testFileRoundtrip(UTF_8, true, false);",
        "test_source": "  public void testUtf8FileRoundtripImplicitUnicodeExtra()\n  throws IOException {\n  testFileRoundtrip(UTF_8, true, false);\n  }",
        "stack": [
          "ZipFile.populateFromCentralDirectory line 318, ZipFile.<init> line 181, UTF8ZipFilesTest.testFile line 291, UTF8ZipFilesTest.testFileRoundtrip line 202, UTF8ZipFilesTest.testUtf8FileRoundtripImplicitUnicodeExtra line 65"
        ]
      },
      {
        "methodName": "testCP437FileRoundtripExplicitUnicodeExtra",
        "error": "java.io.IOException",
        "message": "central directory is empty, can't expand corrupt archive.",
        "fail_line": "        testFileRoundtrip(CP437, false, true);",
        "test_source": "  public void testCP437FileRoundtripExplicitUnicodeExtra()\n  throws IOException {\n  testFileRoundtrip(CP437, false, true);\n  }",
        "stack": [
          "ZipFile.populateFromCentralDirectory line 318, ZipFile.<init> line 181, UTF8ZipFilesTest.testFile line 291, UTF8ZipFilesTest.testFileRoundtrip line 202, UTF8ZipFilesTest.testCP437FileRoundtripExplicitUnicodeExtra line 55"
        ]
      },
      {
        "methodName": "testUtf8FileRoundtripExplicitUnicodeExtra",
        "error": "java.io.IOException",
        "message": "central directory is empty, can't expand corrupt archive.",
        "fail_line": "        testFileRoundtrip(UTF_8, true, true);",
        "test_source": "  public void testUtf8FileRoundtripExplicitUnicodeExtra()\n  throws IOException {\n  testFileRoundtrip(UTF_8, true, true);\n  }",
        "stack": [
          "ZipFile.populateFromCentralDirectory line 318, ZipFile.<init> line 181, UTF8ZipFilesTest.testFile line 291, UTF8ZipFilesTest.testFileRoundtrip line 202, UTF8ZipFilesTest.testUtf8FileRoundtripExplicitUnicodeExtra line 45"
        ]
      },
      {
        "methodName": "testASCIIFileRoundtripImplicitUnicodeExtra",
        "error": "java.io.IOException",
        "message": "central directory is empty, can't expand corrupt archive.",
        "fail_line": "        testFileRoundtrip(US_ASCII, false, false);",
        "test_source": "  public void testASCIIFileRoundtripImplicitUnicodeExtra()\n  throws IOException {\n  testFileRoundtrip(US_ASCII, false, false);\n  }",
        "stack": [
          "ZipFile.populateFromCentralDirectory line 318, ZipFile.<init> line 181, UTF8ZipFilesTest.testFile line 291, UTF8ZipFilesTest.testFileRoundtrip line 202, UTF8ZipFilesTest.testASCIIFileRoundtripImplicitUnicodeExtra line 80"
        ]
      },
      {
        "methodName": "testUtf8FileRoundtripNoEFSImplicitUnicodeExtra",
        "error": "java.io.IOException",
        "message": "central directory is empty, can't expand corrupt archive.",
        "fail_line": "        testFileRoundtrip(UTF_8, false, false);",
        "test_source": "  public void testUtf8FileRoundtripNoEFSImplicitUnicodeExtra()\n  throws IOException {\n  testFileRoundtrip(UTF_8, false, false);\n  }",
        "stack": [
          "ZipFile.populateFromCentralDirectory line 318, ZipFile.<init> line 181, UTF8ZipFilesTest.testFile line 291, UTF8ZipFilesTest.testFileRoundtrip line 202, UTF8ZipFilesTest.testUtf8FileRoundtripNoEFSImplicitUnicodeExtra line 70"
        ]
      },
      {
        "methodName": "testZipArchiveInputStreamReadsUnicodeFields",
        "error": "java.io.IOException",
        "message": "central directory is empty, can't expand corrupt archive.",
        "fail_line": "            zf = new ZipFile(file, US_ASCII, true);",
        "test_source": "  public void testZipArchiveInputStreamReadsUnicodeFields()\n  throws IOException {\n  File file = File.createTempFile(\"unicode-test\", \".zip\");\n  ZipFile zf = null;\n  try {\n  createTestFile(file, US_ASCII, false, true);\n  zf = new ZipFile(file, US_ASCII, true);\n  assertNotNull(zf.getEntry(ASCII_TXT));\n  assertNotNull(zf.getEntry(EURO_FOR_DOLLAR_TXT));\n  assertNotNull(zf.getEntry(OIL_BARREL_TXT));\n  } finally {\n  ZipFile.closeQuietly(zf);\n  if (file.exists()) {\n  file.delete();\n  }\n  }\n  }",
        "stack": [
          "ZipFile.populateFromCentralDirectory line 318, ZipFile.<init> line 181, UTF8ZipFilesTest.testZipArchiveInputStreamReadsUnicodeFields line 183"
        ]
      },
      {
        "methodName": "testASCIIFileRoundtripExplicitUnicodeExtra",
        "error": "java.io.IOException",
        "message": "central directory is empty, can't expand corrupt archive.",
        "fail_line": "        testFileRoundtrip(US_ASCII, false, true);",
        "test_source": "  public void testASCIIFileRoundtripExplicitUnicodeExtra()\n  throws IOException {\n  testFileRoundtrip(US_ASCII, false, true);\n  }",
        "stack": [
          "ZipFile.populateFromCentralDirectory line 318, ZipFile.<init> line 181, UTF8ZipFilesTest.testFile line 291, UTF8ZipFilesTest.testFileRoundtrip line 202, UTF8ZipFilesTest.testASCIIFileRoundtripExplicitUnicodeExtra line 60"
        ]
      },
      {
        "methodName": "testUtf8FileRoundtripNoEFSExplicitUnicodeExtra",
        "error": "java.io.IOException",
        "message": "central directory is empty, can't expand corrupt archive.",
        "fail_line": "        testFileRoundtrip(UTF_8, false, true);",
        "test_source": "  public void testUtf8FileRoundtripNoEFSExplicitUnicodeExtra()\n  throws IOException {\n  testFileRoundtrip(UTF_8, false, true);\n  }",
        "stack": [
          "ZipFile.populateFromCentralDirectory line 318, ZipFile.<init> line 181, UTF8ZipFilesTest.testFile line 291, UTF8ZipFilesTest.testFileRoundtrip line 202, UTF8ZipFilesTest.testUtf8FileRoundtripNoEFSExplicitUnicodeExtra line 50"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java",
      "buggy_full_code": "\npackage org.apache.commons.compress.archivers.cpio;\n\nimport java.io.File;\nimport java.io.FilterOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.util.HashMap;\n\nimport org.apache.commons.compress.archivers.ArchiveEntry;\nimport org.apache.commons.compress.archivers.ArchiveOutputStream;\nimport org.apache.commons.compress.utils.ArchiveUtils;\n\n\npublic class CpioArchiveOutputStream extends ArchiveOutputStream implements\n        CpioConstants {\n\n    private CpioArchiveEntry entry;\n\n    private boolean closed = false;\n\n    private boolean finished;\n\n    \n    private final short entryFormat;\n\n    private final HashMap names = new HashMap();\n\n    private long crc = 0;\n\n    private long written;\n\n    private final OutputStream out;\n\n    \n    public CpioArchiveOutputStream(final OutputStream out, final short format) {\n        this.out = new FilterOutputStream(out);\n        switch (format) {\n        case FORMAT_NEW:\n        case FORMAT_NEW_CRC:\n        case FORMAT_OLD_ASCII:\n        case FORMAT_OLD_BINARY:\n            break;\n        default:\n            throw new IllegalArgumentException(\"Unknown format: \"+format);\n        \n        }\n        this.entryFormat = format;\n    }\n\n    \n    public CpioArchiveOutputStream(final OutputStream out) {\n        this(out, FORMAT_NEW);\n    }\n\n    \n    private void ensureOpen() throws IOException {\n        if (this.closed) {\n            throw new IOException(\"Stream closed\");\n        }\n    }\n\n    \n    public void putArchiveEntry(ArchiveEntry entry) throws IOException {\n        CpioArchiveEntry e = (CpioArchiveEntry) entry;\n        ensureOpen();\n        if (this.entry != null) {\n            closeArchiveEntry(); \n        }\n        if (e.getTime() == -1) {\n            e.setTime(System.currentTimeMillis());\n        }\n\n        final short format = e.getFormat();\n        if (format != this.entryFormat){\n            throw new IOException(\"Header format: \"+format+\" does not match existing format: \"+this.entryFormat);\n        }\n\n        if (this.names.put(e.getName(), e) != null) {\n            throw new IOException(\"duplicate entry: \" + e.getName());\n        }\n\n        writeHeader(e);\n        this.entry = e;\n        this.written = 0;\n    }\n\n    private void writeHeader(final CpioArchiveEntry e) throws IOException {\n        switch (e.getFormat()) {\n        case FORMAT_NEW:\n            out.write(ArchiveUtils.toAsciiBytes(MAGIC_NEW));\n            writeNewEntry(e);\n            break;\n        case FORMAT_NEW_CRC:\n            out.write(ArchiveUtils.toAsciiBytes(MAGIC_NEW_CRC));\n            writeNewEntry(e);\n            break;\n        case FORMAT_OLD_ASCII:\n            out.write(ArchiveUtils.toAsciiBytes(MAGIC_OLD_ASCII));\n            writeOldAsciiEntry(e);\n            break;\n        case FORMAT_OLD_BINARY:\n            boolean swapHalfWord = true;\n            writeBinaryLong(MAGIC_OLD_BINARY, 2, swapHalfWord);\n            writeOldBinaryEntry(e, swapHalfWord);\n            break;\n        }\n    }\n\n    private void writeNewEntry(final CpioArchiveEntry entry) throws IOException {\n        writeAsciiLong(entry.getInode(), 8, 16);\n        writeAsciiLong(entry.getMode(), 8, 16);\n        writeAsciiLong(entry.getUID(), 8, 16);\n        writeAsciiLong(entry.getGID(), 8, 16);\n        writeAsciiLong(entry.getNumberOfLinks(), 8, 16);\n        writeAsciiLong(entry.getTime(), 8, 16);\n        writeAsciiLong(entry.getSize(), 8, 16);\n        writeAsciiLong(entry.getDeviceMaj(), 8, 16);\n        writeAsciiLong(entry.getDeviceMin(), 8, 16);\n        writeAsciiLong(entry.getRemoteDeviceMaj(), 8, 16);\n        writeAsciiLong(entry.getRemoteDeviceMin(), 8, 16);\n        writeAsciiLong(entry.getName().length() + 1, 8, 16);\n        writeAsciiLong(entry.getChksum(), 8, 16);\n        writeCString(entry.getName());\n        pad(entry.getHeaderPadCount());\n    }\n\n    private void writeOldAsciiEntry(final CpioArchiveEntry entry)\n            throws IOException {\n        writeAsciiLong(entry.getDevice(), 6, 8);\n        writeAsciiLong(entry.getInode(), 6, 8);\n        writeAsciiLong(entry.getMode(), 6, 8);\n        writeAsciiLong(entry.getUID(), 6, 8);\n        writeAsciiLong(entry.getGID(), 6, 8);\n        writeAsciiLong(entry.getNumberOfLinks(), 6, 8);\n        writeAsciiLong(entry.getRemoteDevice(), 6, 8);\n        writeAsciiLong(entry.getTime(), 11, 8);\n        writeAsciiLong(entry.getName().length() + 1, 6, 8);\n        writeAsciiLong(entry.getSize(), 11, 8);\n        writeCString(entry.getName());\n    }\n\n    private void writeOldBinaryEntry(final CpioArchiveEntry entry,\n            final boolean swapHalfWord) throws IOException {\n        writeBinaryLong(entry.getDevice(), 2, swapHalfWord);\n        writeBinaryLong(entry.getInode(), 2, swapHalfWord);\n        writeBinaryLong(entry.getMode(), 2, swapHalfWord);\n        writeBinaryLong(entry.getUID(), 2, swapHalfWord);\n        writeBinaryLong(entry.getGID(), 2, swapHalfWord);\n        writeBinaryLong(entry.getNumberOfLinks(), 2, swapHalfWord);\n        writeBinaryLong(entry.getRemoteDevice(), 2, swapHalfWord);\n        writeBinaryLong(entry.getTime(), 4, swapHalfWord);\n        writeBinaryLong(entry.getName().length() + 1, 2, swapHalfWord);\n        writeBinaryLong(entry.getSize(), 4, swapHalfWord);\n        writeCString(entry.getName());\n        pad(entry.getHeaderPadCount());\n    }\n\n    \n    public void closeArchiveEntry() throws IOException {\n        ensureOpen();\n\n        if (this.entry.getSize() != this.written) {\n            throw new IOException(\"invalid entry size (expected \"\n                    + this.entry.getSize() + \" but got \" + this.written\n                    + \" bytes)\");\n        }\n        pad(this.entry.getDataPadCount());\n        if (this.entry.getFormat() == FORMAT_NEW_CRC) {\n            if (this.crc != this.entry.getChksum()) {\n                throw new IOException(\"CRC Error\");\n            }\n        }\n        this.entry = null;\n        this.crc = 0;\n        this.written = 0;\n    }\n\n    \n    public void write(final byte[] b, final int off, final int len)\n            throws IOException {\n        ensureOpen();\n        if (off < 0 || len < 0 || off > b.length - len) {\n            throw new IndexOutOfBoundsException();\n        } else if (len == 0) {\n            return;\n        }\n\n        if (this.entry == null) {\n            throw new IOException(\"no current CPIO entry\");\n        }\n        if (this.written + len > this.entry.getSize()) {\n            throw new IOException(\"attempt to write past end of STORED entry\");\n        }\n        out.write(b, off, len);\n        this.written += len;\n        if (this.entry.getFormat() == FORMAT_NEW_CRC) {\n            for (int pos = 0; pos < len; pos++) {\n                this.crc += b[pos] & 0xFF;\n            }\n        }\n    }\n\n    \n    public void finish() throws IOException {\n        ensureOpen();\n\n        if (this.finished) {\n            return;\n        }\n        if (this.entry != null) {\n            throw new IOException(\"This archives contains unclosed entries.\");\n        }\n        this.entry = new CpioArchiveEntry(this.entryFormat);\n        this.entry.setName(CPIO_TRAILER);\n        this.entry.setNumberOfLinks(1);\n        writeHeader(this.entry);\n        closeArchiveEntry();\n    }\n\n    \n    public void close() throws IOException {\n        if (!this.closed) {\n            this.finish();\n            out.close();\n            this.closed = true;\n        }\n    }\n\n    private void pad(int count) throws IOException{\n        if (count > 0){\n            byte buff[] = new byte[count];\n            out.write(buff);\n        }\n    }\n\n    private void writeBinaryLong(final long number, final int length,\n            final boolean swapHalfWord) throws IOException {\n        byte tmp[] = CpioUtil.long2byteArray(number, length, swapHalfWord);\n        out.write(tmp);\n    }\n\n    private void writeAsciiLong(final long number, final int length,\n            final int radix) throws IOException {\n        StringBuffer tmp = new StringBuffer();\n        String tmpStr;\n        if (radix == 16) {\n            tmp.append(Long.toHexString(number));\n        } else if (radix == 8) {\n            tmp.append(Long.toOctalString(number));\n        } else {\n            tmp.append(Long.toString(number));\n        }\n\n        if (tmp.length() <= length) {\n            long insertLength = length - tmp.length();\n            for (int pos = 0; pos < insertLength; pos++) {\n                tmp.insert(0, \"0\");\n            }\n            tmpStr = tmp.toString();\n        } else {\n            tmpStr = tmp.substring(tmp.length() - length);\n        }\n        out.write(tmpStr.getBytes()); \n    }\n\n    private void writeCString(final String str) throws IOException {\n        out.write(str.getBytes()); \n        out.write('\\0');\n    }\n\n    public ArchiveEntry createArchiveEntry(File inputFile, String entryName)\n            throws IOException {\n        return new CpioArchiveEntry(inputFile, entryName);\n    }\n\n}\n",
      "fixed_full_code": "\npackage org.apache.commons.compress.archivers.cpio;\n\nimport java.io.File;\nimport java.io.FilterOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.util.HashMap;\n\nimport org.apache.commons.compress.archivers.ArchiveEntry;\nimport org.apache.commons.compress.archivers.ArchiveOutputStream;\nimport org.apache.commons.compress.utils.ArchiveUtils;\n\n\npublic class CpioArchiveOutputStream extends ArchiveOutputStream implements\n        CpioConstants {\n\n    private CpioArchiveEntry entry;\n\n    private boolean closed = false;\n\n    private boolean finished;\n\n    \n    private final short entryFormat;\n\n    private final HashMap names = new HashMap();\n\n    private long crc = 0;\n\n    private long written;\n\n    private final OutputStream out;\n\n    \n    public CpioArchiveOutputStream(final OutputStream out, final short format) {\n        this.out = new FilterOutputStream(out);\n        switch (format) {\n        case FORMAT_NEW:\n        case FORMAT_NEW_CRC:\n        case FORMAT_OLD_ASCII:\n        case FORMAT_OLD_BINARY:\n            break;\n        default:\n            throw new IllegalArgumentException(\"Unknown format: \"+format);\n        \n        }\n        this.entryFormat = format;\n    }\n\n    \n    public CpioArchiveOutputStream(final OutputStream out) {\n        this(out, FORMAT_NEW);\n    }\n\n    \n    private void ensureOpen() throws IOException {\n        if (this.closed) {\n            throw new IOException(\"Stream closed\");\n        }\n    }\n\n    \n    public void putArchiveEntry(ArchiveEntry entry) throws IOException {\n        CpioArchiveEntry e = (CpioArchiveEntry) entry;\n        ensureOpen();\n        if (this.entry != null) {\n            closeArchiveEntry(); \n        }\n        if (e.getTime() == -1) {\n            e.setTime(System.currentTimeMillis());\n        }\n\n        final short format = e.getFormat();\n        if (format != this.entryFormat){\n            throw new IOException(\"Header format: \"+format+\" does not match existing format: \"+this.entryFormat);\n        }\n\n        if (this.names.put(e.getName(), e) != null) {\n            throw new IOException(\"duplicate entry: \" + e.getName());\n        }\n\n        writeHeader(e);\n        this.entry = e;\n        this.written = 0;\n    }\n\n    private void writeHeader(final CpioArchiveEntry e) throws IOException {\n        switch (e.getFormat()) {\n        case FORMAT_NEW:\n            out.write(ArchiveUtils.toAsciiBytes(MAGIC_NEW));\n            writeNewEntry(e);\n            break;\n        case FORMAT_NEW_CRC:\n            out.write(ArchiveUtils.toAsciiBytes(MAGIC_NEW_CRC));\n            writeNewEntry(e);\n            break;\n        case FORMAT_OLD_ASCII:\n            out.write(ArchiveUtils.toAsciiBytes(MAGIC_OLD_ASCII));\n            writeOldAsciiEntry(e);\n            break;\n        case FORMAT_OLD_BINARY:\n            boolean swapHalfWord = true;\n            writeBinaryLong(MAGIC_OLD_BINARY, 2, swapHalfWord);\n            writeOldBinaryEntry(e, swapHalfWord);\n            break;\n        }\n    }\n\n    private void writeNewEntry(final CpioArchiveEntry entry) throws IOException {\n        writeAsciiLong(entry.getInode(), 8, 16);\n        writeAsciiLong(entry.getMode(), 8, 16);\n        writeAsciiLong(entry.getUID(), 8, 16);\n        writeAsciiLong(entry.getGID(), 8, 16);\n        writeAsciiLong(entry.getNumberOfLinks(), 8, 16);\n        writeAsciiLong(entry.getTime(), 8, 16);\n        writeAsciiLong(entry.getSize(), 8, 16);\n        writeAsciiLong(entry.getDeviceMaj(), 8, 16);\n        writeAsciiLong(entry.getDeviceMin(), 8, 16);\n        writeAsciiLong(entry.getRemoteDeviceMaj(), 8, 16);\n        writeAsciiLong(entry.getRemoteDeviceMin(), 8, 16);\n        writeAsciiLong(entry.getName().length() + 1, 8, 16);\n        writeAsciiLong(entry.getChksum(), 8, 16);\n        writeCString(entry.getName());\n        pad(entry.getHeaderPadCount());\n    }\n\n    private void writeOldAsciiEntry(final CpioArchiveEntry entry)\n            throws IOException {\n        writeAsciiLong(entry.getDevice(), 6, 8);\n        writeAsciiLong(entry.getInode(), 6, 8);\n        writeAsciiLong(entry.getMode(), 6, 8);\n        writeAsciiLong(entry.getUID(), 6, 8);\n        writeAsciiLong(entry.getGID(), 6, 8);\n        writeAsciiLong(entry.getNumberOfLinks(), 6, 8);\n        writeAsciiLong(entry.getRemoteDevice(), 6, 8);\n        writeAsciiLong(entry.getTime(), 11, 8);\n        writeAsciiLong(entry.getName().length() + 1, 6, 8);\n        writeAsciiLong(entry.getSize(), 11, 8);\n        writeCString(entry.getName());\n    }\n\n    private void writeOldBinaryEntry(final CpioArchiveEntry entry,\n            final boolean swapHalfWord) throws IOException {\n        writeBinaryLong(entry.getDevice(), 2, swapHalfWord);\n        writeBinaryLong(entry.getInode(), 2, swapHalfWord);\n        writeBinaryLong(entry.getMode(), 2, swapHalfWord);\n        writeBinaryLong(entry.getUID(), 2, swapHalfWord);\n        writeBinaryLong(entry.getGID(), 2, swapHalfWord);\n        writeBinaryLong(entry.getNumberOfLinks(), 2, swapHalfWord);\n        writeBinaryLong(entry.getRemoteDevice(), 2, swapHalfWord);\n        writeBinaryLong(entry.getTime(), 4, swapHalfWord);\n        writeBinaryLong(entry.getName().length() + 1, 2, swapHalfWord);\n        writeBinaryLong(entry.getSize(), 4, swapHalfWord);\n        writeCString(entry.getName());\n        pad(entry.getHeaderPadCount());\n    }\n\n    \n    public void closeArchiveEntry() throws IOException {\n        ensureOpen();\n\n        if (this.entry.getSize() != this.written) {\n            throw new IOException(\"invalid entry size (expected \"\n                    + this.entry.getSize() + \" but got \" + this.written\n                    + \" bytes)\");\n        }\n        pad(this.entry.getDataPadCount());\n        if (this.entry.getFormat() == FORMAT_NEW_CRC) {\n            if (this.crc != this.entry.getChksum()) {\n                throw new IOException(\"CRC Error\");\n            }\n        }\n        this.entry = null;\n        this.crc = 0;\n        this.written = 0;\n    }\n\n    \n    public void write(final byte[] b, final int off, final int len)\n            throws IOException {\n        ensureOpen();\n        if (off < 0 || len < 0 || off > b.length - len) {\n            throw new IndexOutOfBoundsException();\n        } else if (len == 0) {\n            return;\n        }\n\n        if (this.entry == null) {\n            throw new IOException(\"no current CPIO entry\");\n        }\n        if (this.written + len > this.entry.getSize()) {\n            throw new IOException(\"attempt to write past end of STORED entry\");\n        }\n        out.write(b, off, len);\n        this.written += len;\n        if (this.entry.getFormat() == FORMAT_NEW_CRC) {\n            for (int pos = 0; pos < len; pos++) {\n                this.crc += b[pos] & 0xFF;\n            }\n        }\n    }\n\n    \n    public void finish() throws IOException {\n        ensureOpen();\n\n        if (this.finished) {\n            return;\n        }\n        if (this.entry != null) {\n            throw new IOException(\"This archives contains unclosed entries.\");\n        }\n        this.entry = new CpioArchiveEntry(this.entryFormat);\n        this.entry.setName(CPIO_TRAILER);\n        this.entry.setNumberOfLinks(1);\n        writeHeader(this.entry);\n        closeArchiveEntry();\n    }\n\n    \n    public void close() throws IOException {\n        if (!this.closed) {\n            out.close();\n            this.closed = true;\n        }\n    }\n\n    private void pad(int count) throws IOException{\n        if (count > 0){\n            byte buff[] = new byte[count];\n            out.write(buff);\n        }\n    }\n\n    private void writeBinaryLong(final long number, final int length,\n            final boolean swapHalfWord) throws IOException {\n        byte tmp[] = CpioUtil.long2byteArray(number, length, swapHalfWord);\n        out.write(tmp);\n    }\n\n    private void writeAsciiLong(final long number, final int length,\n            final int radix) throws IOException {\n        StringBuffer tmp = new StringBuffer();\n        String tmpStr;\n        if (radix == 16) {\n            tmp.append(Long.toHexString(number));\n        } else if (radix == 8) {\n            tmp.append(Long.toOctalString(number));\n        } else {\n            tmp.append(Long.toString(number));\n        }\n\n        if (tmp.length() <= length) {\n            long insertLength = length - tmp.length();\n            for (int pos = 0; pos < insertLength; pos++) {\n                tmp.insert(0, \"0\");\n            }\n            tmpStr = tmp.toString();\n        } else {\n            tmpStr = tmp.substring(tmp.length() - length);\n        }\n        out.write(tmpStr.getBytes()); \n    }\n\n    private void writeCString(final String str) throws IOException {\n        out.write(str.getBytes()); \n        out.write('\\0');\n    }\n\n    public ArchiveEntry createArchiveEntry(File inputFile, String entryName)\n            throws IOException {\n        return new CpioArchiveEntry(inputFile, entryName);\n    }\n\n}\n",
      "buggy_signatures": [
        "private final HashMap names = new HashMap()",
        "public CpioArchiveOutputStream(final OutputStream out, final short format)",
        "public CpioArchiveOutputStream(final OutputStream out)",
        "private void ensureOpen() throws IOException",
        "public void putArchiveEntry(ArchiveEntry entry) throws IOException",
        "private void writeHeader(final CpioArchiveEntry e) throws IOException",
        "private void writeNewEntry(final CpioArchiveEntry entry) throws IOException",
        "private void writeOldAsciiEntry(final CpioArchiveEntry entry)",
        "private void writeOldBinaryEntry(final CpioArchiveEntry entry, final boolean swapHalfWord) throws IOException",
        "public void closeArchiveEntry() throws IOException",
        "public void write(final byte[] b, final int off, final int len)",
        "public void finish() throws IOException",
        "public void close() throws IOException",
        "private void pad(int count) throws IOException",
        "private void writeBinaryLong(final long number, final int length, final boolean swapHalfWord) throws IOException",
        "private void writeAsciiLong(final long number, final int length, final int radix) throws IOException",
        "private void writeCString(final String str) throws IOException",
        "public ArchiveEntry createArchiveEntry(File inputFile, String entryName)"
      ],
      "fixed_signatures": [
        "private final HashMap names = new HashMap()",
        "public CpioArchiveOutputStream(final OutputStream out, final short format)",
        "public CpioArchiveOutputStream(final OutputStream out)",
        "private void ensureOpen() throws IOException",
        "public void putArchiveEntry(ArchiveEntry entry) throws IOException",
        "private void writeHeader(final CpioArchiveEntry e) throws IOException",
        "private void writeNewEntry(final CpioArchiveEntry entry) throws IOException",
        "private void writeOldAsciiEntry(final CpioArchiveEntry entry)",
        "private void writeOldBinaryEntry(final CpioArchiveEntry entry, final boolean swapHalfWord) throws IOException",
        "public void closeArchiveEntry() throws IOException",
        "public void write(final byte[] b, final int off, final int len)",
        "public void finish() throws IOException",
        "public void close() throws IOException",
        "private void pad(int count) throws IOException",
        "private void writeBinaryLong(final long number, final int length, final boolean swapHalfWord) throws IOException",
        "private void writeAsciiLong(final long number, final int length, final int radix) throws IOException",
        "private void writeCString(final String str) throws IOException",
        "public ArchiveEntry createArchiveEntry(File inputFile, String entryName)"
      ],
      "methods": [
        {
          "buggy_method": "  public void close() throws IOException {\n  if (!this.closed) {\n  this.finish();\n  out.close();\n  this.closed = true;\n  }\n  }",
          "fixed_method": "  public void close() throws IOException {\n  if (!this.closed) {\n  out.close();\n  this.closed = true;\n  }\n  }",
          "diff": [
            "@@ -333,7 +333,6 @@",
            "      */\n",
            "     public void close() throws IOException {\n",
            "         if (!this.closed) {\n",
            "-            this.finish();\n",
            "             out.close();\n",
            "             this.closed = true;\n",
            "         }\n"
          ],
          "changed_lines": 1
        }
      ]
    },
    {
      "name": "org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java",
      "buggy_full_code": "\npackage org.apache.commons.compress.archivers.tar;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport org.apache.commons.compress.archivers.ArchiveEntry;\nimport org.apache.commons.compress.archivers.ArchiveOutputStream;\n\n\npublic class TarArchiveOutputStream extends ArchiveOutputStream {\n    \n    public static final int LONGFILE_ERROR = 0;\n\n    \n    public static final int LONGFILE_TRUNCATE = 1;\n\n    \n    public static final int LONGFILE_GNU = 2;\n\n    private long      currSize;\n    private String    currName;\n    private long      currBytes;\n    private final byte[]    recordBuf;\n    private int       assemLen;\n    private final byte[]    assemBuf;\n    protected final TarBuffer buffer;\n    private int       longFileMode = LONGFILE_ERROR;\n\n    private boolean closed = false;\n\n    \n    private boolean haveUnclosedEntry = false;\n    \n    private final OutputStream out;\n\n    \n    public TarArchiveOutputStream(OutputStream os) {\n        this(os, TarBuffer.DEFAULT_BLKSIZE, TarBuffer.DEFAULT_RCDSIZE);\n    }\n\n    \n    public TarArchiveOutputStream(OutputStream os, int blockSize) {\n        this(os, blockSize, TarBuffer.DEFAULT_RCDSIZE);\n    }\n\n    \n    public TarArchiveOutputStream(OutputStream os, int blockSize, int recordSize) {\n        out = os;\n\n        this.buffer = new TarBuffer(os, blockSize, recordSize);\n        this.assemLen = 0;\n        this.assemBuf = new byte[recordSize];\n        this.recordBuf = new byte[recordSize];\n    }\n\n    \n    public void setLongFileMode(int longFileMode) {\n        this.longFileMode = longFileMode;\n    }\n\n\n    \n    public void finish() throws IOException {\n        if(haveUnclosedEntry) {\n            throw new IOException(\"This archives contains unclosed entries.\");\n        }\n        writeEOFRecord();\n        writeEOFRecord();\n    }\n\n    \n    public void close() throws IOException {\n        if (!closed) {\n            finish();\n            buffer.close();\n            out.close();\n            closed = true;\n        }\n    }\n\n    \n    public int getRecordSize() {\n        return buffer.getRecordSize();\n    }\n\n    \n    public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException {\n        TarArchiveEntry entry = (TarArchiveEntry) archiveEntry;\n        if (entry.getName().length() >= TarConstants.NAMELEN) {\n\n            if (longFileMode == LONGFILE_GNU) {\n                \n                \n                TarArchiveEntry longLinkEntry = new TarArchiveEntry(TarConstants.GNU_LONGLINK,\n                                                                    TarConstants.LF_GNUTYPE_LONGNAME);\n\n                final byte[] nameBytes = entry.getName().getBytes(); \n                longLinkEntry.setSize(nameBytes.length + 1); \n                putArchiveEntry(longLinkEntry);\n                write(nameBytes);\n                write(0); \n                closeArchiveEntry();\n            } else if (longFileMode != LONGFILE_TRUNCATE) {\n                throw new RuntimeException(\"file name '\" + entry.getName()\n                                           + \"' is too long ( > \"\n                                           + TarConstants.NAMELEN + \" bytes)\");\n            }\n        }\n\n        entry.writeEntryHeader(recordBuf);\n        buffer.writeRecord(recordBuf);\n\n        currBytes = 0;\n\n        if (entry.isDirectory()) {\n            currSize = 0;\n        } else {\n            currSize = entry.getSize();\n        }\n        currName = entry.getName();\n        haveUnclosedEntry = true;\n    }\n\n    \n    public void closeArchiveEntry() throws IOException {\n        if (assemLen > 0) {\n            for (int i = assemLen; i < assemBuf.length; ++i) {\n                assemBuf[i] = 0;\n            }\n\n            buffer.writeRecord(assemBuf);\n\n            currBytes += assemLen;\n            assemLen = 0;\n        }\n\n        if (currBytes < currSize) {\n            throw new IOException(\"entry '\" + currName + \"' closed at '\"\n                                  + currBytes\n                                  + \"' before the '\" + currSize\n                                  + \"' bytes specified in the header were written\");\n        }\n        haveUnclosedEntry = false;\n    }\n\n    \n    public void write(byte[] wBuf, int wOffset, int numToWrite) throws IOException {\n        if ((currBytes + numToWrite) > currSize) {\n            throw new IOException(\"request to write '\" + numToWrite\n                                  + \"' bytes exceeds size in header of '\"\n                                  + currSize + \"' bytes for entry '\"\n                                  + currName + \"'\");\n\n            \n            \n            \n            \n            \n            \n            \n        }\n\n        if (assemLen > 0) {\n            if ((assemLen + numToWrite) >= recordBuf.length) {\n                int aLen = recordBuf.length - assemLen;\n\n                System.arraycopy(assemBuf, 0, recordBuf, 0,\n                                 assemLen);\n                System.arraycopy(wBuf, wOffset, recordBuf,\n                                 assemLen, aLen);\n                buffer.writeRecord(recordBuf);\n\n                currBytes += recordBuf.length;\n                wOffset += aLen;\n                numToWrite -= aLen;\n                assemLen = 0;\n            } else {\n                System.arraycopy(wBuf, wOffset, assemBuf, assemLen,\n                                 numToWrite);\n\n                wOffset += numToWrite;\n                assemLen += numToWrite;\n                numToWrite = 0;\n            }\n        }\n\n        \n        \n        \n        \n        \n        while (numToWrite > 0) {\n            if (numToWrite < recordBuf.length) {\n                System.arraycopy(wBuf, wOffset, assemBuf, assemLen,\n                                 numToWrite);\n\n                assemLen += numToWrite;\n\n                break;\n            }\n\n            buffer.writeRecord(wBuf, wOffset);\n\n            int num = recordBuf.length;\n\n            currBytes += num;\n            numToWrite -= num;\n            wOffset += num;\n        }\n    }\n\n    \n    private void writeEOFRecord() throws IOException {\n        for (int i = 0; i < recordBuf.length; ++i) {\n            recordBuf[i] = 0;\n        }\n\n        buffer.writeRecord(recordBuf);\n    }\n\n    \n    public void flush() throws IOException {\n        out.flush();\n    }\n\n    public ArchiveEntry createArchiveEntry(File inputFile, String entryName)\n            throws IOException {\n        return new TarArchiveEntry(inputFile, entryName);\n    }\n}\n",
      "fixed_full_code": "\npackage org.apache.commons.compress.archivers.tar;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport org.apache.commons.compress.archivers.ArchiveEntry;\nimport org.apache.commons.compress.archivers.ArchiveOutputStream;\n\n\npublic class TarArchiveOutputStream extends ArchiveOutputStream {\n    \n    public static final int LONGFILE_ERROR = 0;\n\n    \n    public static final int LONGFILE_TRUNCATE = 1;\n\n    \n    public static final int LONGFILE_GNU = 2;\n\n    private long      currSize;\n    private String    currName;\n    private long      currBytes;\n    private final byte[]    recordBuf;\n    private int       assemLen;\n    private final byte[]    assemBuf;\n    protected final TarBuffer buffer;\n    private int       longFileMode = LONGFILE_ERROR;\n\n    private boolean closed = false;\n\n    \n    private boolean haveUnclosedEntry = false;\n    \n    private final OutputStream out;\n\n    \n    public TarArchiveOutputStream(OutputStream os) {\n        this(os, TarBuffer.DEFAULT_BLKSIZE, TarBuffer.DEFAULT_RCDSIZE);\n    }\n\n    \n    public TarArchiveOutputStream(OutputStream os, int blockSize) {\n        this(os, blockSize, TarBuffer.DEFAULT_RCDSIZE);\n    }\n\n    \n    public TarArchiveOutputStream(OutputStream os, int blockSize, int recordSize) {\n        out = os;\n\n        this.buffer = new TarBuffer(os, blockSize, recordSize);\n        this.assemLen = 0;\n        this.assemBuf = new byte[recordSize];\n        this.recordBuf = new byte[recordSize];\n    }\n\n    \n    public void setLongFileMode(int longFileMode) {\n        this.longFileMode = longFileMode;\n    }\n\n\n    \n    public void finish() throws IOException {\n        if(haveUnclosedEntry) {\n            throw new IOException(\"This archives contains unclosed entries.\");\n        }\n        writeEOFRecord();\n        writeEOFRecord();\n    }\n\n    \n    public void close() throws IOException {\n        if (!closed) {\n            buffer.close();\n            out.close();\n            closed = true;\n        }\n    }\n\n    \n    public int getRecordSize() {\n        return buffer.getRecordSize();\n    }\n\n    \n    public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException {\n        TarArchiveEntry entry = (TarArchiveEntry) archiveEntry;\n        if (entry.getName().length() >= TarConstants.NAMELEN) {\n\n            if (longFileMode == LONGFILE_GNU) {\n                \n                \n                TarArchiveEntry longLinkEntry = new TarArchiveEntry(TarConstants.GNU_LONGLINK,\n                                                                    TarConstants.LF_GNUTYPE_LONGNAME);\n\n                final byte[] nameBytes = entry.getName().getBytes(); \n                longLinkEntry.setSize(nameBytes.length + 1); \n                putArchiveEntry(longLinkEntry);\n                write(nameBytes);\n                write(0); \n                closeArchiveEntry();\n            } else if (longFileMode != LONGFILE_TRUNCATE) {\n                throw new RuntimeException(\"file name '\" + entry.getName()\n                                           + \"' is too long ( > \"\n                                           + TarConstants.NAMELEN + \" bytes)\");\n            }\n        }\n\n        entry.writeEntryHeader(recordBuf);\n        buffer.writeRecord(recordBuf);\n\n        currBytes = 0;\n\n        if (entry.isDirectory()) {\n            currSize = 0;\n        } else {\n            currSize = entry.getSize();\n        }\n        currName = entry.getName();\n        haveUnclosedEntry = true;\n    }\n\n    \n    public void closeArchiveEntry() throws IOException {\n        if (assemLen > 0) {\n            for (int i = assemLen; i < assemBuf.length; ++i) {\n                assemBuf[i] = 0;\n            }\n\n            buffer.writeRecord(assemBuf);\n\n            currBytes += assemLen;\n            assemLen = 0;\n        }\n\n        if (currBytes < currSize) {\n            throw new IOException(\"entry '\" + currName + \"' closed at '\"\n                                  + currBytes\n                                  + \"' before the '\" + currSize\n                                  + \"' bytes specified in the header were written\");\n        }\n        haveUnclosedEntry = false;\n    }\n\n    \n    public void write(byte[] wBuf, int wOffset, int numToWrite) throws IOException {\n        if ((currBytes + numToWrite) > currSize) {\n            throw new IOException(\"request to write '\" + numToWrite\n                                  + \"' bytes exceeds size in header of '\"\n                                  + currSize + \"' bytes for entry '\"\n                                  + currName + \"'\");\n\n            \n            \n            \n            \n            \n            \n            \n        }\n\n        if (assemLen > 0) {\n            if ((assemLen + numToWrite) >= recordBuf.length) {\n                int aLen = recordBuf.length - assemLen;\n\n                System.arraycopy(assemBuf, 0, recordBuf, 0,\n                                 assemLen);\n                System.arraycopy(wBuf, wOffset, recordBuf,\n                                 assemLen, aLen);\n                buffer.writeRecord(recordBuf);\n\n                currBytes += recordBuf.length;\n                wOffset += aLen;\n                numToWrite -= aLen;\n                assemLen = 0;\n            } else {\n                System.arraycopy(wBuf, wOffset, assemBuf, assemLen,\n                                 numToWrite);\n\n                wOffset += numToWrite;\n                assemLen += numToWrite;\n                numToWrite = 0;\n            }\n        }\n\n        \n        \n        \n        \n        \n        while (numToWrite > 0) {\n            if (numToWrite < recordBuf.length) {\n                System.arraycopy(wBuf, wOffset, assemBuf, assemLen,\n                                 numToWrite);\n\n                assemLen += numToWrite;\n\n                break;\n            }\n\n            buffer.writeRecord(wBuf, wOffset);\n\n            int num = recordBuf.length;\n\n            currBytes += num;\n            numToWrite -= num;\n            wOffset += num;\n        }\n    }\n\n    \n    private void writeEOFRecord() throws IOException {\n        for (int i = 0; i < recordBuf.length; ++i) {\n            recordBuf[i] = 0;\n        }\n\n        buffer.writeRecord(recordBuf);\n    }\n\n    \n    public void flush() throws IOException {\n        out.flush();\n    }\n\n    public ArchiveEntry createArchiveEntry(File inputFile, String entryName)\n            throws IOException {\n        return new TarArchiveEntry(inputFile, entryName);\n    }\n}\n",
      "buggy_signatures": [
        "public TarArchiveOutputStream(OutputStream os)",
        "public TarArchiveOutputStream(OutputStream os, int blockSize)",
        "public TarArchiveOutputStream(OutputStream os, int blockSize, int recordSize)",
        "public void setLongFileMode(int longFileMode)",
        "public void finish() throws IOException",
        "public void close() throws IOException",
        "public int getRecordSize()",
        "public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException",
        "public void closeArchiveEntry() throws IOException",
        "public void write(byte[] wBuf, int wOffset, int numToWrite) throws IOException",
        "private void writeEOFRecord() throws IOException",
        "public void flush() throws IOException",
        "public ArchiveEntry createArchiveEntry(File inputFile, String entryName)"
      ],
      "fixed_signatures": [
        "public TarArchiveOutputStream(OutputStream os)",
        "public TarArchiveOutputStream(OutputStream os, int blockSize)",
        "public TarArchiveOutputStream(OutputStream os, int blockSize, int recordSize)",
        "public void setLongFileMode(int longFileMode)",
        "public void finish() throws IOException",
        "public void close() throws IOException",
        "public int getRecordSize()",
        "public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException",
        "public void closeArchiveEntry() throws IOException",
        "public void write(byte[] wBuf, int wOffset, int numToWrite) throws IOException",
        "private void writeEOFRecord() throws IOException",
        "public void flush() throws IOException",
        "public ArchiveEntry createArchiveEntry(File inputFile, String entryName)"
      ],
      "methods": [
        {
          "buggy_method": "  public void close() throws IOException {\n  if (!closed) {\n  finish();\n  buffer.close();\n  out.close();\n  closed = true;\n  }\n  }",
          "fixed_method": "  public void close() throws IOException {\n  if (!closed) {\n  buffer.close();\n  out.close();\n  closed = true;\n  }\n  }",
          "diff": [
            "@@ -123,7 +123,6 @@",
            "      */\n",
            "     public void close() throws IOException {\n",
            "         if (!closed) {\n",
            "-            finish();\n",
            "             buffer.close();\n",
            "             out.close();\n",
            "             closed = true;\n"
          ],
          "changed_lines": 1
        }
      ]
    },
    {
      "name": "org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java",
      "buggy_full_code": "\npackage org.apache.commons.compress.archivers.zip;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.RandomAccessFile;\nimport java.nio.ByteBuffer;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.zip.CRC32;\nimport java.util.zip.Deflater;\nimport java.util.zip.ZipException;\n\nimport org.apache.commons.compress.archivers.ArchiveEntry;\nimport org.apache.commons.compress.archivers.ArchiveOutputStream;\n\n\npublic class ZipArchiveOutputStream extends ArchiveOutputStream {\n\n    static final int BYTE_MASK = 0xFF;\n    private static final int SHORT = 2;\n    private static final int WORD = 4;\n    static final int BUFFER_SIZE = 512;\n    \n    private static final int DEFLATER_BLOCK_SIZE = 8192;\n\n    \n    public static final int DEFLATED = java.util.zip.ZipEntry.DEFLATED;\n\n    \n    public static final int DEFAULT_COMPRESSION = Deflater.DEFAULT_COMPRESSION;\n\n    \n    public static final int STORED = java.util.zip.ZipEntry.STORED;\n\n    \n    static final String DEFAULT_ENCODING = ZipEncodingHelper.UTF8;\n\n     \n    public static final int EFS_FLAG = 1 << 11;\n\n    \n    private ZipArchiveEntry entry;\n\n    \n    private String comment = \"\";\n\n    \n    private int level = DEFAULT_COMPRESSION;\n\n    \n    private boolean hasCompressionLevelChanged = false;\n\n    \n    private int method = java.util.zip.ZipEntry.DEFLATED;\n\n    \n    private final List entries = new LinkedList();\n\n    \n    private final CRC32 crc = new CRC32();\n\n    \n    private long written = 0;\n\n    \n    private long dataStart = 0;\n\n    \n    private long localDataStart = 0;\n\n    \n    private long cdOffset = 0;\n\n    \n    private long cdLength = 0;\n\n    \n    private static final byte[] ZERO = {0, 0};\n\n    \n    private static final byte[] LZERO = {0, 0, 0, 0};\n\n    \n    private final Map offsets = new HashMap();\n\n    \n    private String encoding = DEFAULT_ENCODING;\n\n    \n    private ZipEncoding zipEncoding =\n        ZipEncodingHelper.getZipEncoding(DEFAULT_ENCODING);\n\n    \n    protected final Deflater def = new Deflater(level, true);\n\n    \n    private final byte[] buf = new byte[BUFFER_SIZE];\n\n    \n    private final RandomAccessFile raf;\n\n    private final OutputStream out;\n\n    \n    private boolean useEFS = true; \n\n    \n    private boolean fallbackToUTF8 = false;\n\n    \n    private UnicodeExtraFieldPolicy createUnicodeExtraFields =\n        UnicodeExtraFieldPolicy.NEVER;\n\n    \n    public ZipArchiveOutputStream(OutputStream out) {\n        this.out = out;\n        this.raf = null;\n    }\n\n    \n    public ZipArchiveOutputStream(File file) throws IOException {\n        OutputStream o = null;\n        RandomAccessFile _raf = null;\n        try {\n            _raf = new RandomAccessFile(file, \"rw\");\n            _raf.setLength(0);\n        } catch (IOException e) {\n            if (_raf != null) {\n                try {\n                    _raf.close();\n                } catch (IOException inner) {\n                    \n                }\n                _raf = null;\n            }\n            o = new FileOutputStream(file);\n        }\n        out = o;\n        raf = _raf;\n    }\n\n    \n    public boolean isSeekable() {\n        return raf != null;\n    }\n\n    \n    public void setEncoding(final String encoding) {\n        this.encoding = encoding;\n        this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n        useEFS &= ZipEncodingHelper.isUTF8(encoding);\n    }\n\n    \n    public String getEncoding() {\n        return encoding;\n    }\n\n    \n    public void setUseLanguageEncodingFlag(boolean b) {\n        useEFS = b && ZipEncodingHelper.isUTF8(encoding);\n    }\n\n    \n    public void setCreateUnicodeExtraFields(UnicodeExtraFieldPolicy b) {\n        createUnicodeExtraFields = b;\n    }\n\n    \n    public void setFallbackToUTF8(boolean b) {\n        fallbackToUTF8 = b;\n    }\n\n    \n    public void finish() throws IOException {\n        if(entry != null) {\n            throw new IOException(\"This archives contains unclosed entries.\");\n        }\n        \n        cdOffset = written;\n        for (Iterator i = entries.iterator(); i.hasNext(); ) {\n            writeCentralFileHeader((ZipArchiveEntry) i.next());\n        }\n        cdLength = written - cdOffset;\n        writeCentralDirectoryEnd();\n        offsets.clear();\n        entries.clear();\n    }\n\n    \n    public void closeArchiveEntry() throws IOException {\n        if (entry == null) {\n            return;\n        }\n\n        long realCrc = crc.getValue();\n        crc.reset();\n\n        if (entry.getMethod() == DEFLATED) {\n            def.finish();\n            while (!def.finished()) {\n                deflate();\n            }\n\n            entry.setSize(ZipUtil.adjustToLong(def.getTotalIn()));\n            entry.setCompressedSize(ZipUtil.adjustToLong(def.getTotalOut()));\n            entry.setCrc(realCrc);\n\n            def.reset();\n\n            written += entry.getCompressedSize();\n        } else if (raf == null) {\n            if (entry.getCrc() != realCrc) {\n                throw new ZipException(\"bad CRC checksum for entry \"\n                                       + entry.getName() + \": \"\n                                       + Long.toHexString(entry.getCrc())\n                                       + \" instead of \"\n                                       + Long.toHexString(realCrc));\n            }\n\n            if (entry.getSize() != written - dataStart) {\n                throw new ZipException(\"bad size for entry \"\n                                       + entry.getName() + \": \"\n                                       + entry.getSize()\n                                       + \" instead of \"\n                                       + (written - dataStart));\n            }\n        } else { \n            long size = written - dataStart;\n\n            entry.setSize(size);\n            entry.setCompressedSize(size);\n            entry.setCrc(realCrc);\n        }\n\n        \n        \n        if (raf != null) {\n            long save = raf.getFilePointer();\n\n            raf.seek(localDataStart);\n            writeOut(ZipLong.getBytes(entry.getCrc()));\n            writeOut(ZipLong.getBytes(entry.getCompressedSize()));\n            writeOut(ZipLong.getBytes(entry.getSize()));\n            raf.seek(save);\n        }\n\n        writeDataDescriptor(entry);\n        entry = null;\n    }\n\n    \n \n    public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException {\n        closeArchiveEntry();\n\n        entry = ((ZipArchiveEntry) archiveEntry);\n        entries.add(entry);\n\n        if (entry.getMethod() == -1) { \n            entry.setMethod(method);\n        }\n\n        if (entry.getTime() == -1) { \n            entry.setTime(System.currentTimeMillis());\n        }\n\n        \n        if (entry.getMethod() == STORED && raf == null) {\n            if (entry.getSize() == -1) {\n                throw new ZipException(\"uncompressed size is required for\"\n                                       + \" STORED method when not writing to a\"\n                                       + \" file\");\n            }\n            if (entry.getCrc() == -1) {\n                throw new ZipException(\"crc checksum is required for STORED\"\n                                       + \" method when not writing to a file\");\n            }\n            entry.setCompressedSize(entry.getSize());\n        }\n\n        if (entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {\n            def.setLevel(level);\n            hasCompressionLevelChanged = false;\n        }\n        writeLocalFileHeader(entry);\n    }\n\n    \n    public void setComment(String comment) {\n        this.comment = comment;\n    }\n\n    \n    public void setLevel(int level) {\n        if (level < Deflater.DEFAULT_COMPRESSION\n            || level > Deflater.BEST_COMPRESSION) {\n            throw new IllegalArgumentException(\"Invalid compression level: \"\n                                               + level);\n        }\n        hasCompressionLevelChanged = (this.level != level);\n        this.level = level;\n    }\n\n    \n    public void setMethod(int method) {\n        this.method = method;\n    }\n\n    \n    public void write(byte[] b, int offset, int length) throws IOException {\n        if (entry.getMethod() == DEFLATED) {\n            if (length > 0) {\n                if (!def.finished()) {\n                    if (length <= DEFLATER_BLOCK_SIZE) {\n                        def.setInput(b, offset, length);\n                        deflateUntilInputIsNeeded();\n                    } else {\n                        final int fullblocks = length / DEFLATER_BLOCK_SIZE;\n                        for (int i = 0; i < fullblocks; i++) {\n                            def.setInput(b, offset + i * DEFLATER_BLOCK_SIZE,\n                                         DEFLATER_BLOCK_SIZE);\n                            deflateUntilInputIsNeeded();\n                        }\n                        final int done = fullblocks * DEFLATER_BLOCK_SIZE;\n                        if (done < length) {\n                            def.setInput(b, offset + done, length - done);\n                            deflateUntilInputIsNeeded();\n                        }\n                    }\n                }\n            }\n        } else {\n            writeOut(b, offset, length);\n            written += length;\n        }\n        crc.update(b, offset, length);\n    }\n\n    \n    public void close() throws IOException {\n        finish();\n        if (raf != null) {\n            raf.close();\n        }\n        if (out != null) {\n            out.close();\n        }\n    }\n\n    \n    public void flush() throws IOException {\n        if (out != null) {\n            out.flush();\n        }\n    }\n\n    \n    \n    static final byte[] LFH_SIG = ZipLong.LFH_SIG.getBytes();\n    \n    static final byte[] DD_SIG = ZipLong.getBytes(0X08074B50L);\n    \n    static final byte[] CFH_SIG = ZipLong.CFH_SIG.getBytes();\n    \n    static final byte[] EOCD_SIG = ZipLong.getBytes(0X06054B50L);\n\n    \n    protected final void deflate() throws IOException {\n        int len = def.deflate(buf, 0, buf.length);\n        if (len > 0) {\n            writeOut(buf, 0, len);\n        }\n    }\n\n    \n    protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\n\n        boolean encodable = zipEncoding.canEncode(ze.getName());\n        \n        final ZipEncoding entryEncoding;\n        \n        if (!encodable && fallbackToUTF8) {\n            entryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n        } else {\n            entryEncoding = zipEncoding;\n        }\n        \n        ByteBuffer name = entryEncoding.encode(ze.getName());        \n\n        if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n\n            if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                || !encodable) {\n                ze.addExtraField(new UnicodePathExtraField(ze.getName(),\n                                                           name.array(),\n                                                           name.arrayOffset(),\n                                                           name.limit()));\n            }\n\n            String comm = ze.getComment();\n            if (comm != null && !\"\".equals(comm)) {\n\n                boolean commentEncodable = this.zipEncoding.canEncode(comm);\n\n                if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                    || !commentEncodable) {\n                    ByteBuffer commentB = entryEncoding.encode(comm);\n                    ze.addExtraField(new UnicodeCommentExtraField(comm,\n                                                                  commentB.array(),\n                                                                  commentB.arrayOffset(),\n                                                                  commentB.limit())\n                                     );\n                }\n            }\n        }\n\n        offsets.put(ze, ZipLong.getBytes(written));\n\n        writeOut(LFH_SIG);\n        written += WORD;\n\n        \n        final int zipMethod = ze.getMethod();\n\n        writeVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n                                                         !encodable\n                                                         && fallbackToUTF8);\n        written += WORD;\n\n        \n        writeOut(ZipShort.getBytes(zipMethod));\n        written += SHORT;\n\n        \n        writeOut(ZipUtil.toDosTime(ze.getTime()));\n        written += WORD;\n\n        \n        \n        \n        localDataStart = written;\n        if (zipMethod == DEFLATED || raf != null) {\n            writeOut(LZERO);\n            writeOut(LZERO);\n            writeOut(LZERO);\n        } else {\n            writeOut(ZipLong.getBytes(ze.getCrc()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n        }\n        \n        written += 12;\n        \n\n        \n        writeOut(ZipShort.getBytes(name.limit()));\n        written += SHORT;\n\n        \n        byte[] extra = ze.getLocalFileDataExtra();\n        writeOut(ZipShort.getBytes(extra.length));\n        written += SHORT;\n\n        \n        writeOut(name.array(), name.arrayOffset(), name.limit());\n        written += name.limit();\n\n        \n        writeOut(extra);\n        written += extra.length;\n\n        dataStart = written;\n    }\n\n    \n    protected void writeDataDescriptor(ZipArchiveEntry ze) throws IOException {\n        if (ze.getMethod() != DEFLATED || raf != null) {\n            return;\n        }\n        writeOut(DD_SIG);\n        writeOut(ZipLong.getBytes(entry.getCrc()));\n        writeOut(ZipLong.getBytes(entry.getCompressedSize()));\n        writeOut(ZipLong.getBytes(entry.getSize()));\n        \n        written += 16;\n        \n    }\n\n    \n    protected void writeCentralFileHeader(ZipArchiveEntry ze) throws IOException {\n        writeOut(CFH_SIG);\n        written += WORD;\n\n        \n        \n        writeOut(ZipShort.getBytes((ze.getPlatform() << 8) | 20));\n        written += SHORT;\n\n        final int zipMethod = ze.getMethod();\n        final boolean encodable = zipEncoding.canEncode(ze.getName());\n        writeVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n                                                         !encodable\n                                                         && fallbackToUTF8);\n        written += WORD;\n\n        \n        writeOut(ZipShort.getBytes(zipMethod));\n        written += SHORT;\n\n        \n        writeOut(ZipUtil.toDosTime(ze.getTime()));\n        written += WORD;\n\n        \n        \n        \n        writeOut(ZipLong.getBytes(ze.getCrc()));\n        writeOut(ZipLong.getBytes(ze.getCompressedSize()));\n        writeOut(ZipLong.getBytes(ze.getSize()));\n        \n        written += 12;\n        \n\n        \n        final ZipEncoding entryEncoding;\n        \n        if (!encodable && fallbackToUTF8) {\n            entryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n        } else {\n            entryEncoding = zipEncoding;\n        }\n        \n        ByteBuffer name = entryEncoding.encode(ze.getName());        \n\n        writeOut(ZipShort.getBytes(name.limit()));\n        written += SHORT;\n\n        \n        byte[] extra = ze.getCentralDirectoryExtra();\n        writeOut(ZipShort.getBytes(extra.length));\n        written += SHORT;\n\n        \n        String comm = ze.getComment();\n        if (comm == null) {\n            comm = \"\";\n        }\n        \n        ByteBuffer commentB = entryEncoding.encode(comm);\n        \n        writeOut(ZipShort.getBytes(commentB.limit()));\n        written += SHORT;\n\n        \n        writeOut(ZERO);\n        written += SHORT;\n\n        \n        writeOut(ZipShort.getBytes(ze.getInternalAttributes()));\n        written += SHORT;\n\n        \n        writeOut(ZipLong.getBytes(ze.getExternalAttributes()));\n        written += WORD;\n\n        \n        writeOut((byte[]) offsets.get(ze));\n        written += WORD;\n\n        \n        writeOut(name.array(), name.arrayOffset(), name.limit());\n        written += name.limit();\n\n        \n        writeOut(extra);\n        written += extra.length;\n\n        \n        writeOut(commentB.array(), commentB.arrayOffset(), commentB.limit());\n        written += commentB.limit();\n    }\n\n    \n    protected void writeCentralDirectoryEnd() throws IOException {\n        writeOut(EOCD_SIG);\n\n        \n        writeOut(ZERO);\n        writeOut(ZERO);\n\n        \n        byte[] num = ZipShort.getBytes(entries.size());\n        writeOut(num);\n        writeOut(num);\n\n        \n        writeOut(ZipLong.getBytes(cdLength));\n        writeOut(ZipLong.getBytes(cdOffset));\n\n        \n        ByteBuffer data = this.zipEncoding.encode(comment);\n        writeOut(ZipShort.getBytes(data.limit()));\n        writeOut(data.array(), data.arrayOffset(), data.limit());\n    }\n\n    \n    protected final void writeOut(byte[] data) throws IOException {\n        writeOut(data, 0, data.length);\n    }\n\n    \n    protected final void writeOut(byte[] data, int offset, int length)\n        throws IOException {\n        if (raf != null) {\n            raf.write(data, offset, length);\n        } else {\n            out.write(data, offset, length);\n        }\n    }\n\n    private void deflateUntilInputIsNeeded() throws IOException {\n        while (!def.needsInput()) {\n            deflate();\n        }\n    }\n\n    private void writeVersionNeededToExtractAndGeneralPurposeBits(final int\n                                                                  zipMethod,\n                                                                  final boolean\n                                                                  utfFallback)\n        throws IOException {\n\n        \n        int versionNeededToExtract = 10;\n        int generalPurposeFlag = (useEFS || utfFallback) ? EFS_FLAG : 0;\n        if (zipMethod == DEFLATED && raf == null) {\n            \n            \n            versionNeededToExtract =  20;\n            \n            generalPurposeFlag |= 8;\n        }\n        \n\n        \n        writeOut(ZipShort.getBytes(versionNeededToExtract));\n        \n        writeOut(ZipShort.getBytes(generalPurposeFlag));\n    }\n\n    \n    public static final class UnicodeExtraFieldPolicy {\n        \n        public static final UnicodeExtraFieldPolicy ALWAYS =\n            new UnicodeExtraFieldPolicy(\"always\");\n        \n        public static final UnicodeExtraFieldPolicy NEVER =\n            new UnicodeExtraFieldPolicy(\"never\");\n        \n        public static final UnicodeExtraFieldPolicy NOT_ENCODEABLE =\n            new UnicodeExtraFieldPolicy(\"not encodeable\");\n\n        private final String name;\n        private UnicodeExtraFieldPolicy(String n) {\n            name = n;\n        }\n        public String toString() {\n            return name;\n        }\n    }\n\n    public ArchiveEntry createArchiveEntry(File inputFile, String entryName)\n            throws IOException {\n        return new ZipArchiveEntry(inputFile, entryName);\n    }\n}\n",
      "fixed_full_code": "\npackage org.apache.commons.compress.archivers.zip;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.RandomAccessFile;\nimport java.nio.ByteBuffer;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.zip.CRC32;\nimport java.util.zip.Deflater;\nimport java.util.zip.ZipException;\n\nimport org.apache.commons.compress.archivers.ArchiveEntry;\nimport org.apache.commons.compress.archivers.ArchiveOutputStream;\n\n\npublic class ZipArchiveOutputStream extends ArchiveOutputStream {\n\n    static final int BYTE_MASK = 0xFF;\n    private static final int SHORT = 2;\n    private static final int WORD = 4;\n    static final int BUFFER_SIZE = 512;\n    \n    private static final int DEFLATER_BLOCK_SIZE = 8192;\n\n    \n    public static final int DEFLATED = java.util.zip.ZipEntry.DEFLATED;\n\n    \n    public static final int DEFAULT_COMPRESSION = Deflater.DEFAULT_COMPRESSION;\n\n    \n    public static final int STORED = java.util.zip.ZipEntry.STORED;\n\n    \n    static final String DEFAULT_ENCODING = ZipEncodingHelper.UTF8;\n\n     \n    public static final int EFS_FLAG = 1 << 11;\n\n    \n    private ZipArchiveEntry entry;\n\n    \n    private String comment = \"\";\n\n    \n    private int level = DEFAULT_COMPRESSION;\n\n    \n    private boolean hasCompressionLevelChanged = false;\n\n    \n    private int method = java.util.zip.ZipEntry.DEFLATED;\n\n    \n    private final List entries = new LinkedList();\n\n    \n    private final CRC32 crc = new CRC32();\n\n    \n    private long written = 0;\n\n    \n    private long dataStart = 0;\n\n    \n    private long localDataStart = 0;\n\n    \n    private long cdOffset = 0;\n\n    \n    private long cdLength = 0;\n\n    \n    private static final byte[] ZERO = {0, 0};\n\n    \n    private static final byte[] LZERO = {0, 0, 0, 0};\n\n    \n    private final Map offsets = new HashMap();\n\n    \n    private String encoding = DEFAULT_ENCODING;\n\n    \n    private ZipEncoding zipEncoding =\n        ZipEncodingHelper.getZipEncoding(DEFAULT_ENCODING);\n\n    \n    protected final Deflater def = new Deflater(level, true);\n\n    \n    private final byte[] buf = new byte[BUFFER_SIZE];\n\n    \n    private final RandomAccessFile raf;\n\n    private final OutputStream out;\n\n    \n    private boolean useEFS = true; \n\n    \n    private boolean fallbackToUTF8 = false;\n\n    \n    private UnicodeExtraFieldPolicy createUnicodeExtraFields =\n        UnicodeExtraFieldPolicy.NEVER;\n\n    \n    public ZipArchiveOutputStream(OutputStream out) {\n        this.out = out;\n        this.raf = null;\n    }\n\n    \n    public ZipArchiveOutputStream(File file) throws IOException {\n        OutputStream o = null;\n        RandomAccessFile _raf = null;\n        try {\n            _raf = new RandomAccessFile(file, \"rw\");\n            _raf.setLength(0);\n        } catch (IOException e) {\n            if (_raf != null) {\n                try {\n                    _raf.close();\n                } catch (IOException inner) {\n                    \n                }\n                _raf = null;\n            }\n            o = new FileOutputStream(file);\n        }\n        out = o;\n        raf = _raf;\n    }\n\n    \n    public boolean isSeekable() {\n        return raf != null;\n    }\n\n    \n    public void setEncoding(final String encoding) {\n        this.encoding = encoding;\n        this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n        useEFS &= ZipEncodingHelper.isUTF8(encoding);\n    }\n\n    \n    public String getEncoding() {\n        return encoding;\n    }\n\n    \n    public void setUseLanguageEncodingFlag(boolean b) {\n        useEFS = b && ZipEncodingHelper.isUTF8(encoding);\n    }\n\n    \n    public void setCreateUnicodeExtraFields(UnicodeExtraFieldPolicy b) {\n        createUnicodeExtraFields = b;\n    }\n\n    \n    public void setFallbackToUTF8(boolean b) {\n        fallbackToUTF8 = b;\n    }\n\n    \n    public void finish() throws IOException {\n        if(entry != null) {\n            throw new IOException(\"This archives contains unclosed entries.\");\n        }\n        \n        cdOffset = written;\n        for (Iterator i = entries.iterator(); i.hasNext(); ) {\n            writeCentralFileHeader((ZipArchiveEntry) i.next());\n        }\n        cdLength = written - cdOffset;\n        writeCentralDirectoryEnd();\n        offsets.clear();\n        entries.clear();\n    }\n\n    \n    public void closeArchiveEntry() throws IOException {\n        if (entry == null) {\n            return;\n        }\n\n        long realCrc = crc.getValue();\n        crc.reset();\n\n        if (entry.getMethod() == DEFLATED) {\n            def.finish();\n            while (!def.finished()) {\n                deflate();\n            }\n\n            entry.setSize(ZipUtil.adjustToLong(def.getTotalIn()));\n            entry.setCompressedSize(ZipUtil.adjustToLong(def.getTotalOut()));\n            entry.setCrc(realCrc);\n\n            def.reset();\n\n            written += entry.getCompressedSize();\n        } else if (raf == null) {\n            if (entry.getCrc() != realCrc) {\n                throw new ZipException(\"bad CRC checksum for entry \"\n                                       + entry.getName() + \": \"\n                                       + Long.toHexString(entry.getCrc())\n                                       + \" instead of \"\n                                       + Long.toHexString(realCrc));\n            }\n\n            if (entry.getSize() != written - dataStart) {\n                throw new ZipException(\"bad size for entry \"\n                                       + entry.getName() + \": \"\n                                       + entry.getSize()\n                                       + \" instead of \"\n                                       + (written - dataStart));\n            }\n        } else { \n            long size = written - dataStart;\n\n            entry.setSize(size);\n            entry.setCompressedSize(size);\n            entry.setCrc(realCrc);\n        }\n\n        \n        \n        if (raf != null) {\n            long save = raf.getFilePointer();\n\n            raf.seek(localDataStart);\n            writeOut(ZipLong.getBytes(entry.getCrc()));\n            writeOut(ZipLong.getBytes(entry.getCompressedSize()));\n            writeOut(ZipLong.getBytes(entry.getSize()));\n            raf.seek(save);\n        }\n\n        writeDataDescriptor(entry);\n        entry = null;\n    }\n\n    \n \n    public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException {\n        closeArchiveEntry();\n\n        entry = ((ZipArchiveEntry) archiveEntry);\n        entries.add(entry);\n\n        if (entry.getMethod() == -1) { \n            entry.setMethod(method);\n        }\n\n        if (entry.getTime() == -1) { \n            entry.setTime(System.currentTimeMillis());\n        }\n\n        \n        if (entry.getMethod() == STORED && raf == null) {\n            if (entry.getSize() == -1) {\n                throw new ZipException(\"uncompressed size is required for\"\n                                       + \" STORED method when not writing to a\"\n                                       + \" file\");\n            }\n            if (entry.getCrc() == -1) {\n                throw new ZipException(\"crc checksum is required for STORED\"\n                                       + \" method when not writing to a file\");\n            }\n            entry.setCompressedSize(entry.getSize());\n        }\n\n        if (entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {\n            def.setLevel(level);\n            hasCompressionLevelChanged = false;\n        }\n        writeLocalFileHeader(entry);\n    }\n\n    \n    public void setComment(String comment) {\n        this.comment = comment;\n    }\n\n    \n    public void setLevel(int level) {\n        if (level < Deflater.DEFAULT_COMPRESSION\n            || level > Deflater.BEST_COMPRESSION) {\n            throw new IllegalArgumentException(\"Invalid compression level: \"\n                                               + level);\n        }\n        hasCompressionLevelChanged = (this.level != level);\n        this.level = level;\n    }\n\n    \n    public void setMethod(int method) {\n        this.method = method;\n    }\n\n    \n    public void write(byte[] b, int offset, int length) throws IOException {\n        if (entry.getMethod() == DEFLATED) {\n            if (length > 0) {\n                if (!def.finished()) {\n                    if (length <= DEFLATER_BLOCK_SIZE) {\n                        def.setInput(b, offset, length);\n                        deflateUntilInputIsNeeded();\n                    } else {\n                        final int fullblocks = length / DEFLATER_BLOCK_SIZE;\n                        for (int i = 0; i < fullblocks; i++) {\n                            def.setInput(b, offset + i * DEFLATER_BLOCK_SIZE,\n                                         DEFLATER_BLOCK_SIZE);\n                            deflateUntilInputIsNeeded();\n                        }\n                        final int done = fullblocks * DEFLATER_BLOCK_SIZE;\n                        if (done < length) {\n                            def.setInput(b, offset + done, length - done);\n                            deflateUntilInputIsNeeded();\n                        }\n                    }\n                }\n            }\n        } else {\n            writeOut(b, offset, length);\n            written += length;\n        }\n        crc.update(b, offset, length);\n    }\n\n    \n    public void close() throws IOException {\n        if (raf != null) {\n            raf.close();\n        }\n        if (out != null) {\n            out.close();\n        }\n    }\n\n    \n    public void flush() throws IOException {\n        if (out != null) {\n            out.flush();\n        }\n    }\n\n    \n    \n    static final byte[] LFH_SIG = ZipLong.LFH_SIG.getBytes();\n    \n    static final byte[] DD_SIG = ZipLong.getBytes(0X08074B50L);\n    \n    static final byte[] CFH_SIG = ZipLong.CFH_SIG.getBytes();\n    \n    static final byte[] EOCD_SIG = ZipLong.getBytes(0X06054B50L);\n\n    \n    protected final void deflate() throws IOException {\n        int len = def.deflate(buf, 0, buf.length);\n        if (len > 0) {\n            writeOut(buf, 0, len);\n        }\n    }\n\n    \n    protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\n\n        boolean encodable = zipEncoding.canEncode(ze.getName());\n        \n        final ZipEncoding entryEncoding;\n        \n        if (!encodable && fallbackToUTF8) {\n            entryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n        } else {\n            entryEncoding = zipEncoding;\n        }\n        \n        ByteBuffer name = entryEncoding.encode(ze.getName());        \n\n        if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n\n            if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                || !encodable) {\n                ze.addExtraField(new UnicodePathExtraField(ze.getName(),\n                                                           name.array(),\n                                                           name.arrayOffset(),\n                                                           name.limit()));\n            }\n\n            String comm = ze.getComment();\n            if (comm != null && !\"\".equals(comm)) {\n\n                boolean commentEncodable = this.zipEncoding.canEncode(comm);\n\n                if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                    || !commentEncodable) {\n                    ByteBuffer commentB = entryEncoding.encode(comm);\n                    ze.addExtraField(new UnicodeCommentExtraField(comm,\n                                                                  commentB.array(),\n                                                                  commentB.arrayOffset(),\n                                                                  commentB.limit())\n                                     );\n                }\n            }\n        }\n\n        offsets.put(ze, ZipLong.getBytes(written));\n\n        writeOut(LFH_SIG);\n        written += WORD;\n\n        \n        final int zipMethod = ze.getMethod();\n\n        writeVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n                                                         !encodable\n                                                         && fallbackToUTF8);\n        written += WORD;\n\n        \n        writeOut(ZipShort.getBytes(zipMethod));\n        written += SHORT;\n\n        \n        writeOut(ZipUtil.toDosTime(ze.getTime()));\n        written += WORD;\n\n        \n        \n        \n        localDataStart = written;\n        if (zipMethod == DEFLATED || raf != null) {\n            writeOut(LZERO);\n            writeOut(LZERO);\n            writeOut(LZERO);\n        } else {\n            writeOut(ZipLong.getBytes(ze.getCrc()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n        }\n        \n        written += 12;\n        \n\n        \n        writeOut(ZipShort.getBytes(name.limit()));\n        written += SHORT;\n\n        \n        byte[] extra = ze.getLocalFileDataExtra();\n        writeOut(ZipShort.getBytes(extra.length));\n        written += SHORT;\n\n        \n        writeOut(name.array(), name.arrayOffset(), name.limit());\n        written += name.limit();\n\n        \n        writeOut(extra);\n        written += extra.length;\n\n        dataStart = written;\n    }\n\n    \n    protected void writeDataDescriptor(ZipArchiveEntry ze) throws IOException {\n        if (ze.getMethod() != DEFLATED || raf != null) {\n            return;\n        }\n        writeOut(DD_SIG);\n        writeOut(ZipLong.getBytes(entry.getCrc()));\n        writeOut(ZipLong.getBytes(entry.getCompressedSize()));\n        writeOut(ZipLong.getBytes(entry.getSize()));\n        \n        written += 16;\n        \n    }\n\n    \n    protected void writeCentralFileHeader(ZipArchiveEntry ze) throws IOException {\n        writeOut(CFH_SIG);\n        written += WORD;\n\n        \n        \n        writeOut(ZipShort.getBytes((ze.getPlatform() << 8) | 20));\n        written += SHORT;\n\n        final int zipMethod = ze.getMethod();\n        final boolean encodable = zipEncoding.canEncode(ze.getName());\n        writeVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n                                                         !encodable\n                                                         && fallbackToUTF8);\n        written += WORD;\n\n        \n        writeOut(ZipShort.getBytes(zipMethod));\n        written += SHORT;\n\n        \n        writeOut(ZipUtil.toDosTime(ze.getTime()));\n        written += WORD;\n\n        \n        \n        \n        writeOut(ZipLong.getBytes(ze.getCrc()));\n        writeOut(ZipLong.getBytes(ze.getCompressedSize()));\n        writeOut(ZipLong.getBytes(ze.getSize()));\n        \n        written += 12;\n        \n\n        \n        final ZipEncoding entryEncoding;\n        \n        if (!encodable && fallbackToUTF8) {\n            entryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n        } else {\n            entryEncoding = zipEncoding;\n        }\n        \n        ByteBuffer name = entryEncoding.encode(ze.getName());        \n\n        writeOut(ZipShort.getBytes(name.limit()));\n        written += SHORT;\n\n        \n        byte[] extra = ze.getCentralDirectoryExtra();\n        writeOut(ZipShort.getBytes(extra.length));\n        written += SHORT;\n\n        \n        String comm = ze.getComment();\n        if (comm == null) {\n            comm = \"\";\n        }\n        \n        ByteBuffer commentB = entryEncoding.encode(comm);\n        \n        writeOut(ZipShort.getBytes(commentB.limit()));\n        written += SHORT;\n\n        \n        writeOut(ZERO);\n        written += SHORT;\n\n        \n        writeOut(ZipShort.getBytes(ze.getInternalAttributes()));\n        written += SHORT;\n\n        \n        writeOut(ZipLong.getBytes(ze.getExternalAttributes()));\n        written += WORD;\n\n        \n        writeOut((byte[]) offsets.get(ze));\n        written += WORD;\n\n        \n        writeOut(name.array(), name.arrayOffset(), name.limit());\n        written += name.limit();\n\n        \n        writeOut(extra);\n        written += extra.length;\n\n        \n        writeOut(commentB.array(), commentB.arrayOffset(), commentB.limit());\n        written += commentB.limit();\n    }\n\n    \n    protected void writeCentralDirectoryEnd() throws IOException {\n        writeOut(EOCD_SIG);\n\n        \n        writeOut(ZERO);\n        writeOut(ZERO);\n\n        \n        byte[] num = ZipShort.getBytes(entries.size());\n        writeOut(num);\n        writeOut(num);\n\n        \n        writeOut(ZipLong.getBytes(cdLength));\n        writeOut(ZipLong.getBytes(cdOffset));\n\n        \n        ByteBuffer data = this.zipEncoding.encode(comment);\n        writeOut(ZipShort.getBytes(data.limit()));\n        writeOut(data.array(), data.arrayOffset(), data.limit());\n    }\n\n    \n    protected final void writeOut(byte[] data) throws IOException {\n        writeOut(data, 0, data.length);\n    }\n\n    \n    protected final void writeOut(byte[] data, int offset, int length)\n        throws IOException {\n        if (raf != null) {\n            raf.write(data, offset, length);\n        } else {\n            out.write(data, offset, length);\n        }\n    }\n\n    private void deflateUntilInputIsNeeded() throws IOException {\n        while (!def.needsInput()) {\n            deflate();\n        }\n    }\n\n    private void writeVersionNeededToExtractAndGeneralPurposeBits(final int\n                                                                  zipMethod,\n                                                                  final boolean\n                                                                  utfFallback)\n        throws IOException {\n\n        \n        int versionNeededToExtract = 10;\n        int generalPurposeFlag = (useEFS || utfFallback) ? EFS_FLAG : 0;\n        if (zipMethod == DEFLATED && raf == null) {\n            \n            \n            versionNeededToExtract =  20;\n            \n            generalPurposeFlag |= 8;\n        }\n        \n\n        \n        writeOut(ZipShort.getBytes(versionNeededToExtract));\n        \n        writeOut(ZipShort.getBytes(generalPurposeFlag));\n    }\n\n    \n    public static final class UnicodeExtraFieldPolicy {\n        \n        public static final UnicodeExtraFieldPolicy ALWAYS =\n            new UnicodeExtraFieldPolicy(\"always\");\n        \n        public static final UnicodeExtraFieldPolicy NEVER =\n            new UnicodeExtraFieldPolicy(\"never\");\n        \n        public static final UnicodeExtraFieldPolicy NOT_ENCODEABLE =\n            new UnicodeExtraFieldPolicy(\"not encodeable\");\n\n        private final String name;\n        private UnicodeExtraFieldPolicy(String n) {\n            name = n;\n        }\n        public String toString() {\n            return name;\n        }\n    }\n\n    public ArchiveEntry createArchiveEntry(File inputFile, String entryName)\n            throws IOException {\n        return new ZipArchiveEntry(inputFile, entryName);\n    }\n}\n",
      "buggy_signatures": [
        "private final List entries = new LinkedList()",
        "private final CRC32 crc = new CRC32()",
        "private final Map offsets = new HashMap()",
        "protected final Deflater def = new Deflater(level, true)",
        "public ZipArchiveOutputStream(OutputStream out)",
        "public ZipArchiveOutputStream(File file) throws IOException",
        "public boolean isSeekable()",
        "public void setEncoding(final String encoding)",
        "public String getEncoding()",
        "public void setUseLanguageEncodingFlag(boolean b)",
        "public void setCreateUnicodeExtraFields(UnicodeExtraFieldPolicy b)",
        "public void setFallbackToUTF8(boolean b)",
        "public void finish() throws IOException",
        "public void closeArchiveEntry() throws IOException",
        "public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException",
        "public void setComment(String comment)",
        "public void setLevel(int level)",
        "public void setMethod(int method)",
        "public void write(byte[] b, int offset, int length) throws IOException",
        "public void close() throws IOException",
        "public void flush() throws IOException",
        "static final byte[] LFH_SIG = ZipLong.LFH_SIG.getBytes()",
        "static final byte[] DD_SIG = ZipLong.getBytes(0X08074B50L)",
        "static final byte[] CFH_SIG = ZipLong.CFH_SIG.getBytes()",
        "static final byte[] EOCD_SIG = ZipLong.getBytes(0X06054B50L)",
        "protected final void deflate() throws IOException",
        "protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException",
        "protected void writeDataDescriptor(ZipArchiveEntry ze) throws IOException",
        "protected void writeCentralFileHeader(ZipArchiveEntry ze) throws IOException",
        "protected void writeCentralDirectoryEnd() throws IOException",
        "protected final void writeOut(byte[] data) throws IOException",
        "protected final void writeOut(byte[] data, int offset, int length)",
        "private void deflateUntilInputIsNeeded() throws IOException",
        "private void writeVersionNeededToExtractAndGeneralPurposeBits(final int zipMethod, final boolean utfFallback)",
        "private UnicodeExtraFieldPolicy(String n)",
        "public String toString()",
        "public ArchiveEntry createArchiveEntry(File inputFile, String entryName)"
      ],
      "fixed_signatures": [
        "private final List entries = new LinkedList()",
        "private final CRC32 crc = new CRC32()",
        "private final Map offsets = new HashMap()",
        "protected final Deflater def = new Deflater(level, true)",
        "public ZipArchiveOutputStream(OutputStream out)",
        "public ZipArchiveOutputStream(File file) throws IOException",
        "public boolean isSeekable()",
        "public void setEncoding(final String encoding)",
        "public String getEncoding()",
        "public void setUseLanguageEncodingFlag(boolean b)",
        "public void setCreateUnicodeExtraFields(UnicodeExtraFieldPolicy b)",
        "public void setFallbackToUTF8(boolean b)",
        "public void finish() throws IOException",
        "public void closeArchiveEntry() throws IOException",
        "public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException",
        "public void setComment(String comment)",
        "public void setLevel(int level)",
        "public void setMethod(int method)",
        "public void write(byte[] b, int offset, int length) throws IOException",
        "public void close() throws IOException",
        "public void flush() throws IOException",
        "static final byte[] LFH_SIG = ZipLong.LFH_SIG.getBytes()",
        "static final byte[] DD_SIG = ZipLong.getBytes(0X08074B50L)",
        "static final byte[] CFH_SIG = ZipLong.CFH_SIG.getBytes()",
        "static final byte[] EOCD_SIG = ZipLong.getBytes(0X06054B50L)",
        "protected final void deflate() throws IOException",
        "protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException",
        "protected void writeDataDescriptor(ZipArchiveEntry ze) throws IOException",
        "protected void writeCentralFileHeader(ZipArchiveEntry ze) throws IOException",
        "protected void writeCentralDirectoryEnd() throws IOException",
        "protected final void writeOut(byte[] data) throws IOException",
        "protected final void writeOut(byte[] data, int offset, int length)",
        "private void deflateUntilInputIsNeeded() throws IOException",
        "private void writeVersionNeededToExtractAndGeneralPurposeBits(final int zipMethod, final boolean utfFallback)",
        "private UnicodeExtraFieldPolicy(String n)",
        "public String toString()",
        "public ArchiveEntry createArchiveEntry(File inputFile, String entryName)"
      ],
      "methods": [
        {
          "buggy_method": "  public void close() throws IOException {\n  finish();\n  if (raf != null) {\n  raf.close();\n  }\n  if (out != null) {\n  out.close();\n  }\n  }",
          "fixed_method": "  public void close() throws IOException {\n  if (raf != null) {\n  raf.close();\n  }\n  if (out != null) {\n  out.close();\n  }\n  }",
          "diff": [
            "@@ -527,7 +527,6 @@",
            "      * @exception  IOException  if an I/O error occurs.\n",
            "      */\n",
            "     public void close() throws IOException {\n",
            "-        finish();\n",
            "         if (raf != null) {\n",
            "             raf.close();\n",
            "         }\n"
          ],
          "changed_lines": 1
        }
      ]
    },
    {
      "name": "org/apache/commons/compress/changes/ChangeSetPerformer.java",
      "buggy_full_code": "\npackage org.apache.commons.compress.changes;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.Set;\n\nimport org.apache.commons.compress.archivers.ArchiveEntry;\nimport org.apache.commons.compress.archivers.ArchiveInputStream;\nimport org.apache.commons.compress.archivers.ArchiveOutputStream;\nimport org.apache.commons.compress.utils.IOUtils;\n\n\npublic class ChangeSetPerformer {\n    private final Set changes;\n    \n    \n    public ChangeSetPerformer(final ChangeSet changeSet) {\n        changes = changeSet.getChanges();\n    }\n    \n    \n    public ChangeSetResults perform(ArchiveInputStream in, ArchiveOutputStream out)\n            throws IOException {\n        ChangeSetResults results = new ChangeSetResults();\n        \n        Set workingSet = new LinkedHashSet(changes);\n        \n        for (Iterator it = workingSet.iterator(); it.hasNext();) {\n            Change change = (Change) it.next();\n\n            if (change.type() == Change.TYPE_ADD && change.isReplaceMode()) {\n                copyStream(change.getInput(), out, change.getEntry());\n                it.remove();\n                results.addedFromChangeSet(change.getEntry().getName());\n            }\n        }\n\n        ArchiveEntry entry = null;\n        while ((entry = in.getNextEntry()) != null) {\n            boolean copy = true;\n\n            for (Iterator it = workingSet.iterator(); it.hasNext();) {\n                Change change = (Change) it.next();\n\n                final int type = change.type();\n                final String name = entry.getName();\n                if (type == Change.TYPE_DELETE && name != null) {\n                    if (name.equals(change.targetFile())) {\n                        copy = false;\n                        it.remove();\n                        results.deleted(name);\n                        break;\n                    }\n                } else if(type == Change.TYPE_DELETE_DIR && name != null) {\n                    if (name.startsWith(change.targetFile() + \"/\")) {\n                        copy = false;\n                        results.deleted(name);\n                        break;\n                    }\n                }\n            }\n\n            if (copy) {\n                if (!isDeletedLater(workingSet, entry) && !results.hasBeenAdded(entry.getName())) {\n                    copyStream(in, out, entry);\n                    results.addedFromStream(entry.getName());\n                }\n            }\n        }\n        \n        \n        for (Iterator it = workingSet.iterator(); it.hasNext();) {\n            Change change = (Change) it.next();\n\n            if (change.type() == Change.TYPE_ADD && \n                !change.isReplaceMode() && \n                !results.hasBeenAdded(change.getEntry().getName())) {\n                copyStream(change.getInput(), out, change.getEntry());\n                it.remove();\n                results.addedFromChangeSet(change.getEntry().getName());\n            }\n        }\n        return results;\n    }\n\n    \n    private boolean isDeletedLater(Set workingSet, ArchiveEntry entry) {\n        String source = entry.getName();\n\n        if (!workingSet.isEmpty()) {\n            for (Iterator it = workingSet.iterator(); it.hasNext();) {\n                Change change = (Change) it.next();\n                final int type = change.type();\n                String target = change.targetFile();\n                if (type == Change.TYPE_DELETE && source.equals(target)) {\n                    return true;\n                }\n\n                if (type == Change.TYPE_DELETE_DIR && source.startsWith(target + \"/\")){\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    \n    private void copyStream(InputStream in, ArchiveOutputStream out,\n            ArchiveEntry entry) throws IOException {\n        out.putArchiveEntry(entry);\n        IOUtils.copy(in, out);\n        out.closeArchiveEntry();\n    }\n}\n",
      "fixed_full_code": "\npackage org.apache.commons.compress.changes;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.Set;\n\nimport org.apache.commons.compress.archivers.ArchiveEntry;\nimport org.apache.commons.compress.archivers.ArchiveInputStream;\nimport org.apache.commons.compress.archivers.ArchiveOutputStream;\nimport org.apache.commons.compress.utils.IOUtils;\n\n\npublic class ChangeSetPerformer {\n    private final Set changes;\n    \n    \n    public ChangeSetPerformer(final ChangeSet changeSet) {\n        changes = changeSet.getChanges();\n    }\n    \n    \n    public ChangeSetResults perform(ArchiveInputStream in, ArchiveOutputStream out)\n            throws IOException {\n        ChangeSetResults results = new ChangeSetResults();\n        \n        Set workingSet = new LinkedHashSet(changes);\n        \n        for (Iterator it = workingSet.iterator(); it.hasNext();) {\n            Change change = (Change) it.next();\n\n            if (change.type() == Change.TYPE_ADD && change.isReplaceMode()) {\n                copyStream(change.getInput(), out, change.getEntry());\n                it.remove();\n                results.addedFromChangeSet(change.getEntry().getName());\n            }\n        }\n\n        ArchiveEntry entry = null;\n        while ((entry = in.getNextEntry()) != null) {\n            boolean copy = true;\n\n            for (Iterator it = workingSet.iterator(); it.hasNext();) {\n                Change change = (Change) it.next();\n\n                final int type = change.type();\n                final String name = entry.getName();\n                if (type == Change.TYPE_DELETE && name != null) {\n                    if (name.equals(change.targetFile())) {\n                        copy = false;\n                        it.remove();\n                        results.deleted(name);\n                        break;\n                    }\n                } else if(type == Change.TYPE_DELETE_DIR && name != null) {\n                    if (name.startsWith(change.targetFile() + \"/\")) {\n                        copy = false;\n                        results.deleted(name);\n                        break;\n                    }\n                }\n            }\n\n            if (copy) {\n                if (!isDeletedLater(workingSet, entry) && !results.hasBeenAdded(entry.getName())) {\n                    copyStream(in, out, entry);\n                    results.addedFromStream(entry.getName());\n                }\n            }\n        }\n        \n        \n        for (Iterator it = workingSet.iterator(); it.hasNext();) {\n            Change change = (Change) it.next();\n\n            if (change.type() == Change.TYPE_ADD && \n                !change.isReplaceMode() && \n                !results.hasBeenAdded(change.getEntry().getName())) {\n                copyStream(change.getInput(), out, change.getEntry());\n                it.remove();\n                results.addedFromChangeSet(change.getEntry().getName());\n            }\n        }\n        out.finish();\n        return results;\n    }\n\n    \n    private boolean isDeletedLater(Set workingSet, ArchiveEntry entry) {\n        String source = entry.getName();\n\n        if (!workingSet.isEmpty()) {\n            for (Iterator it = workingSet.iterator(); it.hasNext();) {\n                Change change = (Change) it.next();\n                final int type = change.type();\n                String target = change.targetFile();\n                if (type == Change.TYPE_DELETE && source.equals(target)) {\n                    return true;\n                }\n\n                if (type == Change.TYPE_DELETE_DIR && source.startsWith(target + \"/\")){\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    \n    private void copyStream(InputStream in, ArchiveOutputStream out,\n            ArchiveEntry entry) throws IOException {\n        out.putArchiveEntry(entry);\n        IOUtils.copy(in, out);\n        out.closeArchiveEntry();\n    }\n}\n",
      "buggy_signatures": [
        "public ChangeSetPerformer(final ChangeSet changeSet)",
        "public ChangeSetResults perform(ArchiveInputStream in, ArchiveOutputStream out)",
        "private boolean isDeletedLater(Set workingSet, ArchiveEntry entry)",
        "private void copyStream(InputStream in, ArchiveOutputStream out, ArchiveEntry entry) throws IOException"
      ],
      "fixed_signatures": [
        "public ChangeSetPerformer(final ChangeSet changeSet)",
        "public ChangeSetResults perform(ArchiveInputStream in, ArchiveOutputStream out)",
        "private boolean isDeletedLater(Set workingSet, ArchiveEntry entry)",
        "private void copyStream(InputStream in, ArchiveOutputStream out, ArchiveEntry entry) throws IOException"
      ],
      "methods": [
        {
          "buggy_method": "  public ChangeSetResults perform(ArchiveInputStream in, ArchiveOutputStream out)\n  throws IOException {\n  ChangeSetResults results = new ChangeSetResults();\n  \n  Set workingSet = new LinkedHashSet(changes);\n  \n  for (Iterator it = workingSet.iterator(); it.hasNext();) {\n  Change change = (Change) it.next();\n\n  if (change.type() == Change.TYPE_ADD && change.isReplaceMode()) {\n  copyStream(change.getInput(), out, change.getEntry());\n  it.remove();\n  results.addedFromChangeSet(change.getEntry().getName());\n  }\n  }\n\n  ArchiveEntry entry = null;\n  while ((entry = in.getNextEntry()) != null) {\n  boolean copy = true;\n\n  for (Iterator it = workingSet.iterator(); it.hasNext();) {\n  Change change = (Change) it.next();\n\n  final int type = change.type();\n  final String name = entry.getName();\n  if (type == Change.TYPE_DELETE && name != null) {\n  if (name.equals(change.targetFile())) {\n  copy = false;\n  it.remove();\n  results.deleted(name);\n  break;\n  }\n  } else if(type == Change.TYPE_DELETE_DIR && name != null) {\n  if (name.startsWith(change.targetFile() + \"/\")) {\n  copy = false;\n  results.deleted(name);\n  break;\n  }\n  }\n  }\n\n  if (copy) {\n  if (!isDeletedLater(workingSet, entry) && !results.hasBeenAdded(entry.getName())) {\n  copyStream(in, out, entry);\n  results.addedFromStream(entry.getName());\n  }\n  }\n  }\n  \n  \n  for (Iterator it = workingSet.iterator(); it.hasNext();) {\n  Change change = (Change) it.next();\n\n  if (change.type() == Change.TYPE_ADD && \n  !change.isReplaceMode() && \n  !results.hasBeenAdded(change.getEntry().getName())) {\n  copyStream(change.getInput(), out, change.getEntry());\n  it.remove();\n  results.addedFromChangeSet(change.getEntry().getName());\n  }\n  }\n  return results;\n  }",
          "fixed_method": "  public ChangeSetResults perform(ArchiveInputStream in, ArchiveOutputStream out)\n  throws IOException {\n  ChangeSetResults results = new ChangeSetResults();\n  \n  Set workingSet = new LinkedHashSet(changes);\n  \n  for (Iterator it = workingSet.iterator(); it.hasNext();) {\n  Change change = (Change) it.next();\n\n  if (change.type() == Change.TYPE_ADD && change.isReplaceMode()) {\n  copyStream(change.getInput(), out, change.getEntry());\n  it.remove();\n  results.addedFromChangeSet(change.getEntry().getName());\n  }\n  }\n\n  ArchiveEntry entry = null;\n  while ((entry = in.getNextEntry()) != null) {\n  boolean copy = true;\n\n  for (Iterator it = workingSet.iterator(); it.hasNext();) {\n  Change change = (Change) it.next();\n\n  final int type = change.type();\n  final String name = entry.getName();\n  if (type == Change.TYPE_DELETE && name != null) {\n  if (name.equals(change.targetFile())) {\n  copy = false;\n  it.remove();\n  results.deleted(name);\n  break;\n  }\n  } else if(type == Change.TYPE_DELETE_DIR && name != null) {\n  if (name.startsWith(change.targetFile() + \"/\")) {\n  copy = false;\n  results.deleted(name);\n  break;\n  }\n  }\n  }\n\n  if (copy) {\n  if (!isDeletedLater(workingSet, entry) && !results.hasBeenAdded(entry.getName())) {\n  copyStream(in, out, entry);\n  results.addedFromStream(entry.getName());\n  }\n  }\n  }\n  \n  \n  for (Iterator it = workingSet.iterator(); it.hasNext();) {\n  Change change = (Change) it.next();\n\n  if (change.type() == Change.TYPE_ADD && \n  !change.isReplaceMode() && \n  !results.hasBeenAdded(change.getEntry().getName())) {\n  copyStream(change.getInput(), out, change.getEntry());\n  it.remove();\n  results.addedFromChangeSet(change.getEntry().getName());\n  }\n  }\n  out.finish();\n  return results;\n  }",
          "diff": [
            "@@ -125,6 +125,7 @@",
            "                 results.addedFromChangeSet(change.getEntry().getName());\n",
            "             }\n",
            "         }\n",
            "+        out.finish();\n",
            "         return results;\n",
            "     }\n",
            " \n"
          ],
          "changed_lines": 1
        }
      ]
    }
  ]
}