{
  "bug_id": "2",
  "failed_tests": {
    "org.jfree.data.general.junit.DatasetUtilitiesTests": [
      {
        "methodName": "testBug2849731_2",
        "error": "java.lang.NullPointerException",
        "message": "",
        "fail_line": "        assertEquals(1.0, r.getLowerBound(), EPSILON);",
        "test_source": "  public void testBug2849731_2() {\n  XYIntervalSeriesCollection d = new XYIntervalSeriesCollection();\n  XYIntervalSeries s = new XYIntervalSeries(\"S1\");\n  s.add(1.0, Double.NaN, Double.NaN, Double.NaN, 1.5, Double.NaN);\n  d.addSeries(s);\n  Range r = DatasetUtilities.iterateDomainBounds(d);\n  assertEquals(1.0, r.getLowerBound(), EPSILON);\n  assertEquals(1.0, r.getUpperBound(), EPSILON);\n\n  s.add(1.0, 1.5, Double.NaN, Double.NaN, 1.5, Double.NaN);\n  r = DatasetUtilities.iterateDomainBounds(d);\n  assertEquals(1.0, r.getLowerBound(), EPSILON);\n  assertEquals(1.5, r.getUpperBound(), EPSILON);\n\n  s.add(1.0, Double.NaN, 0.5, Double.NaN, 1.5, Double.NaN);\n  r = DatasetUtilities.iterateDomainBounds(d);\n  assertEquals(0.5, r.getLowerBound(), EPSILON);\n  assertEquals(1.5, r.getUpperBound(), EPSILON);\n  }",
        "stack": [
          "DatasetUtilitiesTests.testBug2849731_2 line 1276"
        ]
      },
      {
        "methodName": "testBug2849731_3",
        "error": "java.lang.NullPointerException",
        "message": "",
        "fail_line": "        assertEquals(1.5, r.getLowerBound(), EPSILON);",
        "test_source": "  public void testBug2849731_3() {\n  XYIntervalSeriesCollection d = new XYIntervalSeriesCollection();\n  XYIntervalSeries s = new XYIntervalSeries(\"S1\");\n  s.add(1.0, Double.NaN, Double.NaN, 1.5, Double.NaN, Double.NaN);\n  d.addSeries(s);\n  Range r = DatasetUtilities.iterateRangeBounds(d);\n  assertEquals(1.5, r.getLowerBound(), EPSILON);\n  assertEquals(1.5, r.getUpperBound(), EPSILON);\n\n  s.add(1.0, 1.5, Double.NaN, Double.NaN, Double.NaN, 2.5);\n  r = DatasetUtilities.iterateRangeBounds(d);\n  assertEquals(1.5, r.getLowerBound(), EPSILON);\n  assertEquals(2.5, r.getUpperBound(), EPSILON);\n\n  s.add(1.0, Double.NaN, 0.5, Double.NaN, 3.5, Double.NaN);\n  r = DatasetUtilities.iterateRangeBounds(d);\n  assertEquals(1.5, r.getLowerBound(), EPSILON);\n  assertEquals(3.5, r.getUpperBound(), EPSILON);\n  }",
        "stack": [
          "DatasetUtilitiesTests.testBug2849731_3 line 1299"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/jfree/data/general/DatasetUtilities.java",
      "buggy_full_code": "\n\npackage org.jfree.data.general;\n\nimport org.jfree.data.pie.PieDataset;\nimport org.jfree.data.pie.DefaultPieDataset;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport org.jfree.chart.util.ArrayUtilities;\nimport org.jfree.data.DomainInfo;\nimport org.jfree.data.KeyToGroupMap;\nimport org.jfree.data.KeyedValues;\nimport org.jfree.data.Range;\nimport org.jfree.data.RangeInfo;\nimport org.jfree.data.category.CategoryDataset;\nimport org.jfree.data.category.CategoryRangeInfo;\nimport org.jfree.data.category.DefaultCategoryDataset;\nimport org.jfree.data.category.IntervalCategoryDataset;\nimport org.jfree.data.function.Function2D;\nimport org.jfree.data.statistics.BoxAndWhiskerCategoryDataset;\nimport org.jfree.data.statistics.BoxAndWhiskerXYDataset;\nimport org.jfree.data.statistics.MultiValueCategoryDataset;\nimport org.jfree.data.statistics.StatisticalCategoryDataset;\nimport org.jfree.data.xy.IntervalXYDataset;\nimport org.jfree.data.xy.OHLCDataset;\nimport org.jfree.data.xy.TableXYDataset;\nimport org.jfree.data.xy.XYDataset;\nimport org.jfree.data.xy.XYDomainInfo;\nimport org.jfree.data.xy.XYRangeInfo;\nimport org.jfree.data.xy.XYSeries;\nimport org.jfree.data.xy.XYSeriesCollection;\n\n\npublic final class DatasetUtilities {\n\n    \n    private DatasetUtilities() {\n        \n    }\n\n    \n    public static double calculatePieDatasetTotal(PieDataset dataset) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        List keys = dataset.getKeys();\n        double totalValue = 0;\n        Iterator iterator = keys.iterator();\n        while (iterator.hasNext()) {\n            Comparable current = (Comparable) iterator.next();\n            if (current != null) {\n                Number value = dataset.getValue(current);\n                double v = 0.0;\n                if (value != null) {\n                    v = value.doubleValue();\n                }\n                if (v > 0) {\n                    totalValue = totalValue + v;\n                }\n            }\n        }\n        return totalValue;\n    }\n\n    \n    public static PieDataset createPieDatasetForRow(CategoryDataset dataset,\n                                                    Comparable rowKey) {\n        int row = dataset.getRowIndex(rowKey);\n        return createPieDatasetForRow(dataset, row);\n    }\n\n    \n    public static PieDataset createPieDatasetForRow(CategoryDataset dataset,\n                                                    int row) {\n        DefaultPieDataset result = new DefaultPieDataset();\n        int columnCount = dataset.getColumnCount();\n        for (int current = 0; current < columnCount; current++) {\n            Comparable columnKey = dataset.getColumnKey(current);\n            result.setValue(columnKey, dataset.getValue(row, current));\n        }\n        return result;\n    }\n\n    \n    public static PieDataset createPieDatasetForColumn(CategoryDataset dataset,\n                                                       Comparable columnKey) {\n        int column = dataset.getColumnIndex(columnKey);\n        return createPieDatasetForColumn(dataset, column);\n    }\n\n    \n    public static PieDataset createPieDatasetForColumn(CategoryDataset dataset,\n                                                       int column) {\n        DefaultPieDataset result = new DefaultPieDataset();\n        int rowCount = dataset.getRowCount();\n        for (int i = 0; i < rowCount; i++) {\n            Comparable rowKey = dataset.getRowKey(i);\n            result.setValue(rowKey, dataset.getValue(i, column));\n        }\n        return result;\n    }\n\n    \n    public static PieDataset createConsolidatedPieDataset(PieDataset source,\n            Comparable key, double minimumPercent) {\n        return DatasetUtilities.createConsolidatedPieDataset(source, key,\n                minimumPercent, 2);\n    }\n\n    \n    public static PieDataset createConsolidatedPieDataset(PieDataset source,\n            Comparable key, double minimumPercent, int minItems) {\n\n        DefaultPieDataset result = new DefaultPieDataset();\n        double total = DatasetUtilities.calculatePieDatasetTotal(source);\n\n        \n        List keys = source.getKeys();\n        ArrayList otherKeys = new ArrayList();\n        Iterator iterator = keys.iterator();\n        while (iterator.hasNext()) {\n            Comparable currentKey = (Comparable) iterator.next();\n            Number dataValue = source.getValue(currentKey);\n            if (dataValue != null) {\n                double value = dataValue.doubleValue();\n                if (value / total < minimumPercent) {\n                    otherKeys.add(currentKey);\n                }\n            }\n        }\n\n        \n        iterator = keys.iterator();\n        double otherValue = 0;\n        while (iterator.hasNext()) {\n            Comparable currentKey = (Comparable) iterator.next();\n            Number dataValue = source.getValue(currentKey);\n            if (dataValue != null) {\n                if (otherKeys.contains(currentKey)\n                    && otherKeys.size() >= minItems) {\n                    \n                    otherValue += dataValue.doubleValue();\n                }\n                else {\n                    \n                    result.setValue(currentKey, dataValue);\n                }\n            }\n        }\n        \n        if (otherKeys.size() >= minItems) {\n            result.setValue(key, otherValue);\n        }\n        return result;\n    }\n\n    \n    public static CategoryDataset createCategoryDataset(String rowKeyPrefix,\n            String columnKeyPrefix, double[][] data) {\n\n        DefaultCategoryDataset result = new DefaultCategoryDataset();\n        for (int r = 0; r < data.length; r++) {\n            String rowKey = rowKeyPrefix + (r + 1);\n            for (int c = 0; c < data[r].length; c++) {\n                String columnKey = columnKeyPrefix + (c + 1);\n                result.addValue(new Double(data[r][c]), rowKey, columnKey);\n            }\n        }\n        return result;\n\n    }\n\n    \n    public static CategoryDataset createCategoryDataset(String rowKeyPrefix,\n            String columnKeyPrefix, Number[][] data) {\n\n        DefaultCategoryDataset result = new DefaultCategoryDataset();\n        for (int r = 0; r < data.length; r++) {\n            String rowKey = rowKeyPrefix + (r + 1);\n            for (int c = 0; c < data[r].length; c++) {\n                String columnKey = columnKeyPrefix + (c + 1);\n                result.addValue(data[r][c], rowKey, columnKey);\n            }\n        }\n        return result;\n\n    }\n\n    \n    public static CategoryDataset createCategoryDataset(Comparable[] rowKeys,\n            Comparable[] columnKeys, double[][] data) {\n\n        \n        if (rowKeys == null) {\n            throw new IllegalArgumentException(\"Null 'rowKeys' argument.\");\n        }\n        if (columnKeys == null) {\n            throw new IllegalArgumentException(\"Null 'columnKeys' argument.\");\n        }\n        if (ArrayUtilities.hasDuplicateItems(rowKeys)) {\n            throw new IllegalArgumentException(\"Duplicate items in 'rowKeys'.\");\n        }\n        if (ArrayUtilities.hasDuplicateItems(columnKeys)) {\n            throw new IllegalArgumentException(\n                    \"Duplicate items in 'columnKeys'.\");\n        }\n        if (rowKeys.length != data.length) {\n            throw new IllegalArgumentException(\n                \"The number of row keys does not match the number of rows in \"\n                + \"the data array.\");\n        }\n        int columnCount = 0;\n        for (int r = 0; r < data.length; r++) {\n            columnCount = Math.max(columnCount, data[r].length);\n        }\n        if (columnKeys.length != columnCount) {\n            throw new IllegalArgumentException(\n                \"The number of column keys does not match the number of \"\n                + \"columns in the data array.\");\n        }\n\n        \n        DefaultCategoryDataset result = new DefaultCategoryDataset();\n        for (int r = 0; r < data.length; r++) {\n            Comparable rowKey = rowKeys[r];\n            for (int c = 0; c < data[r].length; c++) {\n                Comparable columnKey = columnKeys[c];\n                result.addValue(new Double(data[r][c]), rowKey, columnKey);\n            }\n        }\n        return result;\n\n    }\n\n    \n    public static CategoryDataset createCategoryDataset(Comparable rowKey,\n                                                        KeyedValues rowData) {\n\n        if (rowKey == null) {\n            throw new IllegalArgumentException(\"Null 'rowKey' argument.\");\n        }\n        if (rowData == null) {\n            throw new IllegalArgumentException(\"Null 'rowData' argument.\");\n        }\n        DefaultCategoryDataset result = new DefaultCategoryDataset();\n        for (int i = 0; i < rowData.getItemCount(); i++) {\n            result.addValue(rowData.getValue(i), rowKey, rowData.getKey(i));\n        }\n        return result;\n\n    }\n\n    \n    public static XYDataset sampleFunction2D(Function2D f, double start,\n            double end, int samples, Comparable seriesKey) {\n\n        \n        XYSeries series = sampleFunction2DToSeries(f, start, end, samples,\n                seriesKey);\n        XYSeriesCollection collection = new XYSeriesCollection(series);\n        return collection;\n    }\n\n    \n    public static XYSeries sampleFunction2DToSeries(Function2D f,\n            double start, double end, int samples, Comparable seriesKey) {\n\n        if (f == null) {\n            throw new IllegalArgumentException(\"Null 'f' argument.\");\n        }\n        if (seriesKey == null) {\n            throw new IllegalArgumentException(\"Null 'seriesKey' argument.\");\n        }\n        if (start >= end) {\n            throw new IllegalArgumentException(\"Requires 'start' < 'end'.\");\n        }\n        if (samples < 2) {\n            throw new IllegalArgumentException(\"Requires 'samples' > 1\");\n        }\n\n        XYSeries series = new XYSeries(seriesKey);\n        double step = (end - start) / (samples - 1);\n        for (int i = 0; i < samples; i++) {\n            double x = start + (step * i);\n            series.add(x, f.getValue(x));\n        }\n        return series;\n    }\n\n    \n    public static boolean isEmptyOrNull(PieDataset dataset) {\n\n        if (dataset == null) {\n            return true;\n        }\n\n        int itemCount = dataset.getItemCount();\n        if (itemCount == 0) {\n            return true;\n        }\n\n        for (int item = 0; item < itemCount; item++) {\n            Number y = dataset.getValue(item);\n            if (y != null) {\n                double yy = y.doubleValue();\n                if (yy > 0.0) {\n                    return false;\n                }\n            }\n        }\n\n        return true;\n\n    }\n\n    \n    public static boolean isEmptyOrNull(CategoryDataset dataset) {\n\n        if (dataset == null) {\n            return true;\n        }\n\n        int rowCount = dataset.getRowCount();\n        int columnCount = dataset.getColumnCount();\n        if (rowCount == 0 || columnCount == 0) {\n            return true;\n        }\n\n        for (int r = 0; r < rowCount; r++) {\n            for (int c = 0; c < columnCount; c++) {\n                if (dataset.getValue(r, c) != null) {\n                    return false;\n                }\n\n            }\n        }\n\n        return true;\n\n    }\n\n    \n    public static boolean isEmptyOrNull(XYDataset dataset) {\n        if (dataset != null) {\n            for (int s = 0; s < dataset.getSeriesCount(); s++) {\n                if (dataset.getItemCount(s) > 0) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    \n    public static Range findDomainBounds(XYDataset dataset) {\n        return findDomainBounds(dataset, true);\n    }\n\n    \n    public static Range findDomainBounds(XYDataset dataset,\n                                         boolean includeInterval) {\n\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n\n        Range result = null;\n        \n        if (dataset instanceof DomainInfo) {\n            DomainInfo info = (DomainInfo) dataset;\n            result = info.getDomainBounds(includeInterval);\n        }\n        else {\n            result = iterateDomainBounds(dataset, includeInterval);\n        }\n        return result;\n\n    }\n\n    \n    public static Range findDomainBounds(XYDataset dataset,\n            List visibleSeriesKeys, boolean includeInterval) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        Range result = null;\n        if (dataset instanceof XYDomainInfo) {\n            XYDomainInfo info = (XYDomainInfo) dataset;\n            result = info.getDomainBounds(visibleSeriesKeys, includeInterval);\n        }\n        else {\n            result = iterateToFindDomainBounds(dataset, visibleSeriesKeys,\n                    includeInterval);\n        }\n        return result;\n    }\n\n    \n    public static Range iterateDomainBounds(XYDataset dataset) {\n        return iterateDomainBounds(dataset, true);\n    }\n\n    \n    public static Range iterateDomainBounds(XYDataset dataset,\n                                            boolean includeInterval) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n        int seriesCount = dataset.getSeriesCount();\n        double lvalue;\n        double uvalue;\n        if (includeInterval && dataset instanceof IntervalXYDataset) {\n            IntervalXYDataset intervalXYData = (IntervalXYDataset) dataset;\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    lvalue = intervalXYData.getStartXValue(series, item);\n                    uvalue = intervalXYData.getEndXValue(series, item);\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                    }\n                    if (!Double.isNaN(uvalue)) {\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        else {\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    lvalue = dataset.getXValue(series, item);\n                    uvalue = lvalue;\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        if (minimum > maximum) {\n            return null;\n        }\n        else {\n            return new Range(minimum, maximum);\n        }\n    }\n\n    \n    public static Range findRangeBounds(CategoryDataset dataset) {\n        return findRangeBounds(dataset, true);\n    }\n\n    \n    public static Range findRangeBounds(CategoryDataset dataset,\n                                        boolean includeInterval) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        Range result = null;\n        if (dataset instanceof RangeInfo) {\n            RangeInfo info = (RangeInfo) dataset;\n            result = info.getRangeBounds(includeInterval);\n        }\n        else {\n            result = iterateRangeBounds(dataset, includeInterval);\n        }\n        return result;\n    }\n\n    \n    public static Range findRangeBounds(CategoryDataset dataset,\n            List visibleSeriesKeys, boolean includeInterval) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        Range result = null;\n        if (dataset instanceof CategoryRangeInfo) {\n            CategoryRangeInfo info = (CategoryRangeInfo) dataset;\n            result = info.getRangeBounds(visibleSeriesKeys, includeInterval);\n        }\n        else {\n            result = iterateToFindRangeBounds(dataset, visibleSeriesKeys,\n                    includeInterval);\n        }\n        return result;\n    }\n\n    \n    public static Range findRangeBounds(XYDataset dataset) {\n        return findRangeBounds(dataset, true);\n    }\n\n    \n    public static Range findRangeBounds(XYDataset dataset,\n                                        boolean includeInterval) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        Range result = null;\n        if (dataset instanceof RangeInfo) {\n            RangeInfo info = (RangeInfo) dataset;\n            result = info.getRangeBounds(includeInterval);\n        }\n        else {\n            result = iterateRangeBounds(dataset, includeInterval);\n        }\n        return result;\n    }\n\n    \n    public static Range findRangeBounds(XYDataset dataset,\n            List visibleSeriesKeys, Range xRange, boolean includeInterval) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        Range result = null;\n        if (dataset instanceof XYRangeInfo) {\n            XYRangeInfo info = (XYRangeInfo) dataset;\n            result = info.getRangeBounds(visibleSeriesKeys, xRange,\n                    includeInterval);\n        }\n        else {\n            result = iterateToFindRangeBounds(dataset, visibleSeriesKeys,\n                    xRange, includeInterval);\n        }\n        return result;\n    }\n\n    \n    public static Range iterateCategoryRangeBounds(CategoryDataset dataset,\n            boolean includeInterval) {\n        return iterateRangeBounds(dataset, includeInterval);\n    }\n\n    \n    public static Range iterateRangeBounds(CategoryDataset dataset) {\n        return iterateRangeBounds(dataset, true);\n    }\n\n    \n    public static Range iterateRangeBounds(CategoryDataset dataset,\n            boolean includeInterval) {\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n        int rowCount = dataset.getRowCount();\n        int columnCount = dataset.getColumnCount();\n        if (includeInterval && dataset instanceof IntervalCategoryDataset) {\n            \n            \n            IntervalCategoryDataset icd = (IntervalCategoryDataset) dataset;\n            Number value, lvalue, uvalue;\n            for (int row = 0; row < rowCount; row++) {\n                for (int column = 0; column < columnCount; column++) {\n                    value = icd.getValue(row, column);\n                    double v;\n                    if ((value != null)\n                            && !Double.isNaN(v = value.doubleValue())) {\n                        minimum = Math.min(v, minimum);\n                        maximum = Math.max(v, maximum);\n                    }\n                    lvalue = icd.getStartValue(row, column);\n                    if (lvalue != null\n                            && !Double.isNaN(v = lvalue.doubleValue())) {\n                        minimum = Math.min(v, minimum);\n                        maximum = Math.max(v, maximum);\n                    }\n                    uvalue = icd.getEndValue(row, column);\n                    if (uvalue != null \n                            && !Double.isNaN(v = uvalue.doubleValue())) {\n                        minimum = Math.min(v, minimum);\n                        maximum = Math.max(v, maximum);\n                    }\n                }\n            }\n        }\n        else {\n            \n            for (int row = 0; row < rowCount; row++) {\n                for (int column = 0; column < columnCount; column++) {\n                    Number value = dataset.getValue(row, column);\n                    if (value != null) {\n                        double v = value.doubleValue();\n                        if (!Double.isNaN(v)) {\n                            minimum = Math.min(minimum, v);\n                            maximum = Math.max(maximum, v);\n                        }\n                    }\n                }\n            }\n        }\n        if (minimum == Double.POSITIVE_INFINITY) {\n            return null;\n        }\n        else {\n            return new Range(minimum, maximum);\n        }\n    }\n\n    \n    public static Range iterateToFindRangeBounds(CategoryDataset dataset,\n            List visibleSeriesKeys, boolean includeInterval) {\n\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        if (visibleSeriesKeys == null) {\n            throw new IllegalArgumentException(\n                    \"Null 'visibleSeriesKeys' argument.\");\n        }\n\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n        int columnCount = dataset.getColumnCount();\n        if (includeInterval\n                && dataset instanceof BoxAndWhiskerCategoryDataset) {\n            \n            BoxAndWhiskerCategoryDataset bx\n                    = (BoxAndWhiskerCategoryDataset) dataset;\n            Iterator iterator = visibleSeriesKeys.iterator();\n            while (iterator.hasNext()) {\n                Comparable seriesKey = (Comparable) iterator.next();\n                int series = dataset.getRowIndex(seriesKey);\n                int itemCount = dataset.getColumnCount();\n                for (int item = 0; item < itemCount; item++) {\n                    Number lvalue = bx.getMinRegularValue(series, item);\n                    if (lvalue == null) {\n                        lvalue = bx.getValue(series, item);\n                    }\n                    Number uvalue = bx.getMaxRegularValue(series, item);\n                    if (uvalue == null) {\n                        uvalue = bx.getValue(series, item);\n                    }\n                    if (lvalue != null) {\n                        minimum = Math.min(minimum, lvalue.doubleValue());\n                    }\n                    if (uvalue != null) {\n                        maximum = Math.max(maximum, uvalue.doubleValue());\n                    }\n                }\n            }\n        }\n        else if (includeInterval\n                && dataset instanceof IntervalCategoryDataset) {\n            \n            \n            IntervalCategoryDataset icd = (IntervalCategoryDataset) dataset;\n            Number lvalue, uvalue;\n            Iterator iterator = visibleSeriesKeys.iterator();\n            while (iterator.hasNext()) {\n                Comparable seriesKey = (Comparable) iterator.next();\n                int series = dataset.getRowIndex(seriesKey);\n                for (int column = 0; column < columnCount; column++) {\n                    lvalue = icd.getStartValue(series, column);\n                    uvalue = icd.getEndValue(series, column);\n                    if (lvalue != null && !Double.isNaN(lvalue.doubleValue())) {\n                        minimum = Math.min(minimum, lvalue.doubleValue());\n                    }\n                    if (uvalue != null && !Double.isNaN(uvalue.doubleValue())) {\n                        maximum = Math.max(maximum, uvalue.doubleValue());\n                    }\n                }\n            }\n        }\n        else if (includeInterval\n                && dataset instanceof MultiValueCategoryDataset) {\n            \n            \n            MultiValueCategoryDataset mvcd\n                    = (MultiValueCategoryDataset) dataset;\n            Iterator iterator = visibleSeriesKeys.iterator();\n            while (iterator.hasNext()) {\n                Comparable seriesKey = (Comparable) iterator.next();\n                int series = dataset.getRowIndex(seriesKey);\n                for (int column = 0; column < columnCount; column++) {\n                    List values = mvcd.getValues(series, column);\n                    Iterator valueIterator = values.iterator();\n                    while (valueIterator.hasNext()) {\n                    \tObject o = valueIterator.next();\n\t\t\t\t\t\tif (o instanceof Number){\n\t\t\t\t\t\t\tdouble v = ((Number) o).doubleValue();\n\t\t\t\t\t\t\tif (!Double.isNaN(v)){\n\t                            minimum = Math.min(minimum, v);\n\t                            maximum = Math.max(maximum, v);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n                    }\n               }\n            }\n        }\n        else if (includeInterval\n                && dataset instanceof StatisticalCategoryDataset) {\n            \n            \n            StatisticalCategoryDataset scd\n                    = (StatisticalCategoryDataset) dataset;\n            Iterator iterator = visibleSeriesKeys.iterator();\n            while (iterator.hasNext()) {\n                Comparable seriesKey = (Comparable) iterator.next();\n                int series = dataset.getRowIndex(seriesKey);\n                for (int column = 0; column < columnCount; column++) {\n                    Number meanN = scd.getMeanValue(series, column);\n                    if (meanN != null) {\n                        double std = 0.0;\n                        Number stdN = scd.getStdDevValue(series, column);\n                        if (stdN != null) {\n                            std = stdN.doubleValue();\n                            if (Double.isNaN(std)) {\n                                std = 0.0;\n                            }\n                        }\n                        double mean = meanN.doubleValue();\n                        if (!Double.isNaN(mean)) {\n                            minimum = Math.min(minimum, mean - std);\n                            maximum = Math.max(maximum, mean + std);\n                        }\n                    }\n                }\n            }\n        }\n        else {\n            \n            Iterator iterator = visibleSeriesKeys.iterator();\n            while (iterator.hasNext()) {\n                Comparable seriesKey = (Comparable) iterator.next();\n                int series = dataset.getRowIndex(seriesKey);\n                for (int column = 0; column < columnCount; column++) {\n                    Number value = dataset.getValue(series, column);\n                    if (value != null) {\n                        double v = value.doubleValue();\n                        if (!Double.isNaN(v)) {\n                            minimum = Math.min(minimum, v);\n                            maximum = Math.max(maximum, v);\n                        }\n                    }\n                }\n            }\n        }\n        if (minimum == Double.POSITIVE_INFINITY) {\n            return null;\n        }\n        else {\n            return new Range(minimum, maximum);\n        }\n    }\n\n    \n    public static Range iterateXYRangeBounds(XYDataset dataset) {\n        return iterateRangeBounds(dataset);\n    }\n\n    \n    public static Range iterateRangeBounds(XYDataset dataset) {\n        return iterateRangeBounds(dataset, true);\n    }\n\n    \n    public static Range iterateRangeBounds(XYDataset dataset,\n            boolean includeInterval) {\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n        int seriesCount = dataset.getSeriesCount();\n\n        \n        if (includeInterval && dataset instanceof IntervalXYDataset) {\n            \n            IntervalXYDataset ixyd = (IntervalXYDataset) dataset;\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double lvalue = ixyd.getStartYValue(series, item);\n                    double uvalue = ixyd.getEndYValue(series, item);\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                    }\n                    if (!Double.isNaN(uvalue)) {\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        else if (includeInterval && dataset instanceof OHLCDataset) {\n            \n            OHLCDataset ohlc = (OHLCDataset) dataset;\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double lvalue = ohlc.getLowValue(series, item);\n                    double uvalue = ohlc.getHighValue(series, item);\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                    }\n                    if (!Double.isNaN(uvalue)) {\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        else {\n            \n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double value = dataset.getYValue(series, item);\n                    if (!Double.isNaN(value)) {\n                        minimum = Math.min(minimum, value);\n                        maximum = Math.max(maximum, value);\n                    }\n                }\n            }\n        }\n        if (minimum == Double.POSITIVE_INFINITY) {\n            return null;\n        }\n        else {\n            return new Range(minimum, maximum);\n        }\n    }\n\n    \n    public static Range iterateToFindDomainBounds(XYDataset dataset,\n            List visibleSeriesKeys, boolean includeInterval) {\n\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        if (visibleSeriesKeys == null) {\n            throw new IllegalArgumentException(\n                    \"Null 'visibleSeriesKeys' argument.\");\n        }\n\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n\n        if (includeInterval && dataset instanceof IntervalXYDataset) {\n            \n            IntervalXYDataset ixyd = (IntervalXYDataset) dataset;\n            Iterator iterator = visibleSeriesKeys.iterator();\n            while (iterator.hasNext()) {\n                Comparable seriesKey = (Comparable) iterator.next();\n                int series = dataset.indexOf(seriesKey);\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double lvalue = ixyd.getStartXValue(series, item);\n                    double uvalue = ixyd.getEndXValue(series, item);\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                    }\n                    if (!Double.isNaN(uvalue)) {\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        else {\n            \n            Iterator iterator = visibleSeriesKeys.iterator();\n            while (iterator.hasNext()) {\n                Comparable seriesKey = (Comparable) iterator.next();\n                int series = dataset.indexOf(seriesKey);\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double x = dataset.getXValue(series, item);\n                    if (!Double.isNaN(x)) {\n                        minimum = Math.min(minimum, x);\n                        maximum = Math.max(maximum, x);\n                    }\n                }\n            }\n        }\n\n        if (minimum == Double.POSITIVE_INFINITY) {\n            return null;\n        }\n        else {\n            return new Range(minimum, maximum);\n        }\n    }\n\n    \n    public static Range iterateToFindRangeBounds(XYDataset dataset,\n            List visibleSeriesKeys, Range xRange, boolean includeInterval) {\n\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        if (visibleSeriesKeys == null) {\n            throw new IllegalArgumentException(\n                    \"Null 'visibleSeriesKeys' argument.\");\n        }\n        if (xRange == null) {\n            throw new IllegalArgumentException(\"Null 'xRange' argument\");\n        }\n\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n\n        \n        if (includeInterval && dataset instanceof OHLCDataset) {\n            \n            OHLCDataset ohlc = (OHLCDataset) dataset;\n            Iterator iterator = visibleSeriesKeys.iterator();\n            while (iterator.hasNext()) {\n                Comparable seriesKey = (Comparable) iterator.next();\n                int series = dataset.indexOf(seriesKey);\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double x = ohlc.getXValue(series, item);\n                    if (xRange.contains(x)) {\n                        double lvalue = ohlc.getLowValue(series, item);\n                        double uvalue = ohlc.getHighValue(series, item);\n                        if (!Double.isNaN(lvalue)) {\n                            minimum = Math.min(minimum, lvalue);\n                        }\n                        if (!Double.isNaN(uvalue)) {\n                            maximum = Math.max(maximum, uvalue);\n                        }\n                    }\n                }\n            }\n        }\n        else if (includeInterval && dataset instanceof BoxAndWhiskerXYDataset) {\n            \n            BoxAndWhiskerXYDataset bx = (BoxAndWhiskerXYDataset) dataset;\n            Iterator iterator = visibleSeriesKeys.iterator();\n            while (iterator.hasNext()) {\n                Comparable seriesKey = (Comparable) iterator.next();\n                int series = dataset.indexOf(seriesKey);\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double x = bx.getXValue(series, item);\n                    if (xRange.contains(x)) {\n                        Number lvalue = bx.getMinRegularValue(series, item);\n                        Number uvalue = bx.getMaxRegularValue(series, item);\n                        if (lvalue != null) {\n                            minimum = Math.min(minimum, lvalue.doubleValue());\n                        }\n                        if (uvalue != null) {\n                            maximum = Math.max(maximum, uvalue.doubleValue());\n                        }\n                    }\n                }\n            }\n        }\n        else if (includeInterval && dataset instanceof IntervalXYDataset) {\n            \n            IntervalXYDataset ixyd = (IntervalXYDataset) dataset;\n            Iterator iterator = visibleSeriesKeys.iterator();\n            while (iterator.hasNext()) {\n                Comparable seriesKey = (Comparable) iterator.next();\n                int series = dataset.indexOf(seriesKey);\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double x = ixyd.getXValue(series, item);\n                    if (xRange.contains(x)) {\n                        double lvalue = ixyd.getStartYValue(series, item);\n                        double uvalue = ixyd.getEndYValue(series, item);\n                        if (!Double.isNaN(lvalue)) {\n                            minimum = Math.min(minimum, lvalue);\n                        }\n                        if (!Double.isNaN(uvalue)) {\n                            maximum = Math.max(maximum, uvalue);\n                        }\n                    }\n                }\n            }\n        }\n        else {\n            \n            Iterator iterator = visibleSeriesKeys.iterator();\n            while (iterator.hasNext()) {\n                Comparable seriesKey = (Comparable) iterator.next();\n                int series = dataset.indexOf(seriesKey);\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double x = dataset.getXValue(series, item);\n                    double y = dataset.getYValue(series, item);\n                    if (xRange.contains(x)) {\n                        if (!Double.isNaN(y)) {\n                            minimum = Math.min(minimum, y);\n                            maximum = Math.max(maximum, y);\n                        }\n                    }\n                }\n            }\n        }\n        if (minimum == Double.POSITIVE_INFINITY) {\n            return null;\n        }\n        else {\n            return new Range(minimum, maximum);\n        }\n    }\n\n    \n    public static Number findMinimumDomainValue(XYDataset dataset) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        Number result = null;\n        \n        if (dataset instanceof DomainInfo) {\n            DomainInfo info = (DomainInfo) dataset;\n            return new Double(info.getDomainLowerBound(true));\n        }\n        else {\n            double minimum = Double.POSITIVE_INFINITY;\n            int seriesCount = dataset.getSeriesCount();\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n\n                    double value;\n                    if (dataset instanceof IntervalXYDataset) {\n                        IntervalXYDataset intervalXYData\n                            = (IntervalXYDataset) dataset;\n                        value = intervalXYData.getStartXValue(series, item);\n                    }\n                    else {\n                        value = dataset.getXValue(series, item);\n                    }\n                    if (!Double.isNaN(value)) {\n                        minimum = Math.min(minimum, value);\n                    }\n\n                }\n            }\n            if (minimum == Double.POSITIVE_INFINITY) {\n                result = null;\n            }\n            else {\n                result = new Double(minimum);\n            }\n        }\n\n        return result;\n    }\n\n    \n    public static Number findMaximumDomainValue(XYDataset dataset) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        Number result = null;\n        \n        if (dataset instanceof DomainInfo) {\n            DomainInfo info = (DomainInfo) dataset;\n            return new Double(info.getDomainUpperBound(true));\n        }\n\n        \n        else {\n            double maximum = Double.NEGATIVE_INFINITY;\n            int seriesCount = dataset.getSeriesCount();\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n\n                    double value;\n                    if (dataset instanceof IntervalXYDataset) {\n                        IntervalXYDataset intervalXYData\n                            = (IntervalXYDataset) dataset;\n                        value = intervalXYData.getEndXValue(series, item);\n                    }\n                    else {\n                        value = dataset.getXValue(series, item);\n                    }\n                    if (!Double.isNaN(value)) {\n                        maximum = Math.max(maximum, value);\n                    }\n                }\n            }\n            if (maximum == Double.NEGATIVE_INFINITY) {\n                result = null;\n            }\n            else {\n                result = new Double(maximum);\n            }\n\n        }\n\n        return result;\n    }\n\n    \n    public static Number findMinimumRangeValue(CategoryDataset dataset) {\n\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n\n        if (dataset instanceof RangeInfo) {\n            RangeInfo info = (RangeInfo) dataset;\n            return new Double(info.getRangeLowerBound(true));\n        }\n\n        \n        else {\n            double minimum = Double.POSITIVE_INFINITY;\n            int seriesCount = dataset.getRowCount();\n            int itemCount = dataset.getColumnCount();\n            for (int series = 0; series < seriesCount; series++) {\n                for (int item = 0; item < itemCount; item++) {\n                    Number value;\n                    if (dataset instanceof IntervalCategoryDataset) {\n                        IntervalCategoryDataset icd\n                                = (IntervalCategoryDataset) dataset;\n                        value = icd.getStartValue(series, item);\n                    }\n                    else {\n                        value = dataset.getValue(series, item);\n                    }\n                    if (value != null) {\n                        minimum = Math.min(minimum, value.doubleValue());\n                    }\n                }\n            }\n            if (minimum == Double.POSITIVE_INFINITY) {\n                return null;\n            }\n            else {\n                return new Double(minimum);\n            }\n\n        }\n\n    }\n\n    \n    public static Number findMinimumRangeValue(XYDataset dataset) {\n\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n\n        \n        if (dataset instanceof RangeInfo) {\n            RangeInfo info = (RangeInfo) dataset;\n            return new Double(info.getRangeLowerBound(true));\n        }\n\n        \n        else {\n            double minimum = Double.POSITIVE_INFINITY;\n            int seriesCount = dataset.getSeriesCount();\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n\n                    double value;\n                    if (dataset instanceof IntervalXYDataset) {\n                        IntervalXYDataset intervalXYData\n                                = (IntervalXYDataset) dataset;\n                        value = intervalXYData.getStartYValue(series, item);\n                    }\n                    else if (dataset instanceof OHLCDataset) {\n                        OHLCDataset highLowData = (OHLCDataset) dataset;\n                        value = highLowData.getLowValue(series, item);\n                    }\n                    else {\n                        value = dataset.getYValue(series, item);\n                    }\n                    if (!Double.isNaN(value)) {\n                        minimum = Math.min(minimum, value);\n                    }\n\n                }\n            }\n            if (minimum == Double.POSITIVE_INFINITY) {\n                return null;\n            }\n            else {\n                return new Double(minimum);\n            }\n\n        }\n\n    }\n\n    \n    public static Number findMaximumRangeValue(CategoryDataset dataset) {\n\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n\n        \n        if (dataset instanceof RangeInfo) {\n            RangeInfo info = (RangeInfo) dataset;\n            return new Double(info.getRangeUpperBound(true));\n        }\n\n        \n        else {\n\n            double maximum = Double.NEGATIVE_INFINITY;\n            int seriesCount = dataset.getRowCount();\n            int itemCount = dataset.getColumnCount();\n            for (int series = 0; series < seriesCount; series++) {\n                for (int item = 0; item < itemCount; item++) {\n                    Number value;\n                    if (dataset instanceof IntervalCategoryDataset) {\n                        IntervalCategoryDataset icd\n                            = (IntervalCategoryDataset) dataset;\n                        value = icd.getEndValue(series, item);\n                    }\n                    else {\n                        value = dataset.getValue(series, item);\n                    }\n                    if (value != null) {\n                        maximum = Math.max(maximum, value.doubleValue());\n                    }\n                }\n            }\n            if (maximum == Double.NEGATIVE_INFINITY) {\n                return null;\n            }\n            else {\n                return new Double(maximum);\n            }\n\n        }\n\n    }\n\n    \n    public static Number findMaximumRangeValue(XYDataset dataset) {\n\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n\n        \n        if (dataset instanceof RangeInfo) {\n            RangeInfo info = (RangeInfo) dataset;\n            return new Double(info.getRangeUpperBound(true));\n        }\n\n        \n        else  {\n\n            double maximum = Double.NEGATIVE_INFINITY;\n            int seriesCount = dataset.getSeriesCount();\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double value;\n                    if (dataset instanceof IntervalXYDataset) {\n                        IntervalXYDataset intervalXYData\n                            = (IntervalXYDataset) dataset;\n                        value = intervalXYData.getEndYValue(series, item);\n                    }\n                    else if (dataset instanceof OHLCDataset) {\n                        OHLCDataset highLowData = (OHLCDataset) dataset;\n                        value = highLowData.getHighValue(series, item);\n                    }\n                    else {\n                        value = dataset.getYValue(series, item);\n                    }\n                    if (!Double.isNaN(value)) {\n                        maximum = Math.max(maximum, value);\n                    }\n                }\n            }\n            if (maximum == Double.NEGATIVE_INFINITY) {\n                return null;\n            }\n            else {\n                return new Double(maximum);\n            }\n\n        }\n\n    }\n\n    \n    public static Range findStackedRangeBounds(CategoryDataset dataset) {\n        return findStackedRangeBounds(dataset, 0.0);\n    }\n\n    \n    public static Range findStackedRangeBounds(CategoryDataset dataset,\n            double base) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        Range result = null;\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n        int categoryCount = dataset.getColumnCount();\n        for (int item = 0; item < categoryCount; item++) {\n            double positive = base;\n            double negative = base;\n            int seriesCount = dataset.getRowCount();\n            for (int series = 0; series < seriesCount; series++) {\n                Number number = dataset.getValue(series, item);\n                if (number != null) {\n                    double value = number.doubleValue();\n                    if (value > 0.0) {\n                        positive = positive + value;\n                    }\n                    if (value < 0.0) {\n                        negative = negative + value;\n                        \n                    }\n                }\n            }\n            minimum = Math.min(minimum, negative);\n            maximum = Math.max(maximum, positive);\n        }\n        if (minimum <= maximum) {\n            result = new Range(minimum, maximum);\n        }\n        return result;\n\n    }\n\n    \n    public static Range findStackedRangeBounds(CategoryDataset dataset,\n                                               KeyToGroupMap map) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        boolean hasValidData = false;\n        Range result = null;\n\n        \n        int[] groupIndex = new int[dataset.getRowCount()];\n        for (int i = 0; i < dataset.getRowCount(); i++) {\n            groupIndex[i] = map.getGroupIndex(map.getGroup(\n                    dataset.getRowKey(i)));\n        }\n\n        \n        int groupCount = map.getGroupCount();\n        double[] minimum = new double[groupCount];\n        double[] maximum = new double[groupCount];\n\n        int categoryCount = dataset.getColumnCount();\n        for (int item = 0; item < categoryCount; item++) {\n            double[] positive = new double[groupCount];\n            double[] negative = new double[groupCount];\n            int seriesCount = dataset.getRowCount();\n            for (int series = 0; series < seriesCount; series++) {\n                Number number = dataset.getValue(series, item);\n                if (number != null) {\n                    hasValidData = true;\n                    double value = number.doubleValue();\n                    if (value > 0.0) {\n                        positive[groupIndex[series]]\n                                 = positive[groupIndex[series]] + value;\n                    }\n                    if (value < 0.0) {\n                        negative[groupIndex[series]]\n                                 = negative[groupIndex[series]] + value;\n                                 \n                    }\n                }\n            }\n            for (int g = 0; g < groupCount; g++) {\n                minimum[g] = Math.min(minimum[g], negative[g]);\n                maximum[g] = Math.max(maximum[g], positive[g]);\n            }\n        }\n        if (hasValidData) {\n            for (int j = 0; j < groupCount; j++) {\n                result = Range.combine(result, new Range(minimum[j],\n                        maximum[j]));\n            }\n        }\n        return result;\n    }\n\n    \n    public static Number findMinimumStackedRangeValue(CategoryDataset dataset) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        Number result = null;\n        boolean hasValidData = false;\n        double minimum = 0.0;\n        int categoryCount = dataset.getColumnCount();\n        for (int item = 0; item < categoryCount; item++) {\n            double total = 0.0;\n            int seriesCount = dataset.getRowCount();\n            for (int series = 0; series < seriesCount; series++) {\n                Number number = dataset.getValue(series, item);\n                if (number != null) {\n                    hasValidData = true;\n                    double value = number.doubleValue();\n                    if (value < 0.0) {\n                        total = total + value;\n                        \n                    }\n                }\n            }\n            minimum = Math.min(minimum, total);\n        }\n        if (hasValidData) {\n            result = new Double(minimum);\n        }\n        return result;\n    }\n\n    \n    public static Number findMaximumStackedRangeValue(CategoryDataset dataset) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        Number result = null;\n        boolean hasValidData = false;\n        double maximum = 0.0;\n        int categoryCount = dataset.getColumnCount();\n        for (int item = 0; item < categoryCount; item++) {\n            double total = 0.0;\n            int seriesCount = dataset.getRowCount();\n            for (int series = 0; series < seriesCount; series++) {\n                Number number = dataset.getValue(series, item);\n                if (number != null) {\n                    hasValidData = true;\n                    double value = number.doubleValue();\n                    if (value > 0.0) {\n                        total = total + value;\n                    }\n                }\n            }\n            maximum = Math.max(maximum, total);\n        }\n        if (hasValidData) {\n            result = new Double(maximum);\n        }\n        return result;\n    }\n\n    \n    public static Range findStackedRangeBounds(TableXYDataset dataset) {\n        return findStackedRangeBounds(dataset, 0.0);\n    }\n\n    \n    public static Range findStackedRangeBounds(TableXYDataset dataset,\n                                               double base) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        double minimum = base;\n        double maximum = base;\n        for (int itemNo = 0; itemNo < dataset.getItemCount(); itemNo++) {\n            double positive = base;\n            double negative = base;\n            int seriesCount = dataset.getSeriesCount();\n            for (int seriesNo = 0; seriesNo < seriesCount; seriesNo++) {\n                double y = dataset.getYValue(seriesNo, itemNo);\n                if (!Double.isNaN(y)) {\n                    if (y > 0.0) {\n                        positive += y;\n                    }\n                    else {\n                        negative += y;\n                    }\n                }\n            }\n            if (positive > maximum) {\n                maximum = positive;\n            }\n            if (negative < minimum) {\n                minimum = negative;\n            }\n        }\n        if (minimum <= maximum) {\n            return new Range(minimum, maximum);\n        }\n        else {\n            return null;\n        }\n    }\n\n    \n    public static double calculateStackTotal(TableXYDataset dataset, int item) {\n        double total = 0.0;\n        int seriesCount = dataset.getSeriesCount();\n        for (int s = 0; s < seriesCount; s++) {\n            double value = dataset.getYValue(s, item);\n            if (!Double.isNaN(value)) {\n                total = total + value;\n            }\n        }\n        return total;\n    }\n\n    \n    public static Range findCumulativeRangeBounds(CategoryDataset dataset) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        boolean allItemsNull = true; \n                                     \n        double minimum = 0.0;\n        double maximum = 0.0;\n        for (int row = 0; row < dataset.getRowCount(); row++) {\n            double runningTotal = 0.0;\n            for (int column = 0; column <= dataset.getColumnCount() - 1;\n                 column++) {\n                Number n = dataset.getValue(row, column);\n                if (n != null) {\n                    allItemsNull = false;\n                    double value = n.doubleValue();\n                    if (!Double.isNaN(value)) {\n                        runningTotal = runningTotal + value;\n                        minimum = Math.min(minimum, runningTotal);\n                        maximum = Math.max(maximum, runningTotal);\n                    }\n                }\n            }\n        }\n        if (!allItemsNull) {\n            return new Range(minimum, maximum);\n        }\n        else {\n            return null;\n        }\n    }\n\n}\n",
      "fixed_full_code": "\n\npackage org.jfree.data.general;\n\nimport org.jfree.data.pie.PieDataset;\nimport org.jfree.data.pie.DefaultPieDataset;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport org.jfree.chart.util.ArrayUtilities;\nimport org.jfree.data.DomainInfo;\nimport org.jfree.data.KeyToGroupMap;\nimport org.jfree.data.KeyedValues;\nimport org.jfree.data.Range;\nimport org.jfree.data.RangeInfo;\nimport org.jfree.data.category.CategoryDataset;\nimport org.jfree.data.category.CategoryRangeInfo;\nimport org.jfree.data.category.DefaultCategoryDataset;\nimport org.jfree.data.category.IntervalCategoryDataset;\nimport org.jfree.data.function.Function2D;\nimport org.jfree.data.statistics.BoxAndWhiskerCategoryDataset;\nimport org.jfree.data.statistics.BoxAndWhiskerXYDataset;\nimport org.jfree.data.statistics.MultiValueCategoryDataset;\nimport org.jfree.data.statistics.StatisticalCategoryDataset;\nimport org.jfree.data.xy.IntervalXYDataset;\nimport org.jfree.data.xy.OHLCDataset;\nimport org.jfree.data.xy.TableXYDataset;\nimport org.jfree.data.xy.XYDataset;\nimport org.jfree.data.xy.XYDomainInfo;\nimport org.jfree.data.xy.XYRangeInfo;\nimport org.jfree.data.xy.XYSeries;\nimport org.jfree.data.xy.XYSeriesCollection;\n\n\npublic final class DatasetUtilities {\n\n    \n    private DatasetUtilities() {\n        \n    }\n\n    \n    public static double calculatePieDatasetTotal(PieDataset dataset) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        List keys = dataset.getKeys();\n        double totalValue = 0;\n        Iterator iterator = keys.iterator();\n        while (iterator.hasNext()) {\n            Comparable current = (Comparable) iterator.next();\n            if (current != null) {\n                Number value = dataset.getValue(current);\n                double v = 0.0;\n                if (value != null) {\n                    v = value.doubleValue();\n                }\n                if (v > 0) {\n                    totalValue = totalValue + v;\n                }\n            }\n        }\n        return totalValue;\n    }\n\n    \n    public static PieDataset createPieDatasetForRow(CategoryDataset dataset,\n                                                    Comparable rowKey) {\n        int row = dataset.getRowIndex(rowKey);\n        return createPieDatasetForRow(dataset, row);\n    }\n\n    \n    public static PieDataset createPieDatasetForRow(CategoryDataset dataset,\n                                                    int row) {\n        DefaultPieDataset result = new DefaultPieDataset();\n        int columnCount = dataset.getColumnCount();\n        for (int current = 0; current < columnCount; current++) {\n            Comparable columnKey = dataset.getColumnKey(current);\n            result.setValue(columnKey, dataset.getValue(row, current));\n        }\n        return result;\n    }\n\n    \n    public static PieDataset createPieDatasetForColumn(CategoryDataset dataset,\n                                                       Comparable columnKey) {\n        int column = dataset.getColumnIndex(columnKey);\n        return createPieDatasetForColumn(dataset, column);\n    }\n\n    \n    public static PieDataset createPieDatasetForColumn(CategoryDataset dataset,\n                                                       int column) {\n        DefaultPieDataset result = new DefaultPieDataset();\n        int rowCount = dataset.getRowCount();\n        for (int i = 0; i < rowCount; i++) {\n            Comparable rowKey = dataset.getRowKey(i);\n            result.setValue(rowKey, dataset.getValue(i, column));\n        }\n        return result;\n    }\n\n    \n    public static PieDataset createConsolidatedPieDataset(PieDataset source,\n            Comparable key, double minimumPercent) {\n        return DatasetUtilities.createConsolidatedPieDataset(source, key,\n                minimumPercent, 2);\n    }\n\n    \n    public static PieDataset createConsolidatedPieDataset(PieDataset source,\n            Comparable key, double minimumPercent, int minItems) {\n\n        DefaultPieDataset result = new DefaultPieDataset();\n        double total = DatasetUtilities.calculatePieDatasetTotal(source);\n\n        \n        List keys = source.getKeys();\n        ArrayList otherKeys = new ArrayList();\n        Iterator iterator = keys.iterator();\n        while (iterator.hasNext()) {\n            Comparable currentKey = (Comparable) iterator.next();\n            Number dataValue = source.getValue(currentKey);\n            if (dataValue != null) {\n                double value = dataValue.doubleValue();\n                if (value / total < minimumPercent) {\n                    otherKeys.add(currentKey);\n                }\n            }\n        }\n\n        \n        iterator = keys.iterator();\n        double otherValue = 0;\n        while (iterator.hasNext()) {\n            Comparable currentKey = (Comparable) iterator.next();\n            Number dataValue = source.getValue(currentKey);\n            if (dataValue != null) {\n                if (otherKeys.contains(currentKey)\n                    && otherKeys.size() >= minItems) {\n                    \n                    otherValue += dataValue.doubleValue();\n                }\n                else {\n                    \n                    result.setValue(currentKey, dataValue);\n                }\n            }\n        }\n        \n        if (otherKeys.size() >= minItems) {\n            result.setValue(key, otherValue);\n        }\n        return result;\n    }\n\n    \n    public static CategoryDataset createCategoryDataset(String rowKeyPrefix,\n            String columnKeyPrefix, double[][] data) {\n\n        DefaultCategoryDataset result = new DefaultCategoryDataset();\n        for (int r = 0; r < data.length; r++) {\n            String rowKey = rowKeyPrefix + (r + 1);\n            for (int c = 0; c < data[r].length; c++) {\n                String columnKey = columnKeyPrefix + (c + 1);\n                result.addValue(new Double(data[r][c]), rowKey, columnKey);\n            }\n        }\n        return result;\n\n    }\n\n    \n    public static CategoryDataset createCategoryDataset(String rowKeyPrefix,\n            String columnKeyPrefix, Number[][] data) {\n\n        DefaultCategoryDataset result = new DefaultCategoryDataset();\n        for (int r = 0; r < data.length; r++) {\n            String rowKey = rowKeyPrefix + (r + 1);\n            for (int c = 0; c < data[r].length; c++) {\n                String columnKey = columnKeyPrefix + (c + 1);\n                result.addValue(data[r][c], rowKey, columnKey);\n            }\n        }\n        return result;\n\n    }\n\n    \n    public static CategoryDataset createCategoryDataset(Comparable[] rowKeys,\n            Comparable[] columnKeys, double[][] data) {\n\n        \n        if (rowKeys == null) {\n            throw new IllegalArgumentException(\"Null 'rowKeys' argument.\");\n        }\n        if (columnKeys == null) {\n            throw new IllegalArgumentException(\"Null 'columnKeys' argument.\");\n        }\n        if (ArrayUtilities.hasDuplicateItems(rowKeys)) {\n            throw new IllegalArgumentException(\"Duplicate items in 'rowKeys'.\");\n        }\n        if (ArrayUtilities.hasDuplicateItems(columnKeys)) {\n            throw new IllegalArgumentException(\n                    \"Duplicate items in 'columnKeys'.\");\n        }\n        if (rowKeys.length != data.length) {\n            throw new IllegalArgumentException(\n                \"The number of row keys does not match the number of rows in \"\n                + \"the data array.\");\n        }\n        int columnCount = 0;\n        for (int r = 0; r < data.length; r++) {\n            columnCount = Math.max(columnCount, data[r].length);\n        }\n        if (columnKeys.length != columnCount) {\n            throw new IllegalArgumentException(\n                \"The number of column keys does not match the number of \"\n                + \"columns in the data array.\");\n        }\n\n        \n        DefaultCategoryDataset result = new DefaultCategoryDataset();\n        for (int r = 0; r < data.length; r++) {\n            Comparable rowKey = rowKeys[r];\n            for (int c = 0; c < data[r].length; c++) {\n                Comparable columnKey = columnKeys[c];\n                result.addValue(new Double(data[r][c]), rowKey, columnKey);\n            }\n        }\n        return result;\n\n    }\n\n    \n    public static CategoryDataset createCategoryDataset(Comparable rowKey,\n                                                        KeyedValues rowData) {\n\n        if (rowKey == null) {\n            throw new IllegalArgumentException(\"Null 'rowKey' argument.\");\n        }\n        if (rowData == null) {\n            throw new IllegalArgumentException(\"Null 'rowData' argument.\");\n        }\n        DefaultCategoryDataset result = new DefaultCategoryDataset();\n        for (int i = 0; i < rowData.getItemCount(); i++) {\n            result.addValue(rowData.getValue(i), rowKey, rowData.getKey(i));\n        }\n        return result;\n\n    }\n\n    \n    public static XYDataset sampleFunction2D(Function2D f, double start,\n            double end, int samples, Comparable seriesKey) {\n\n        \n        XYSeries series = sampleFunction2DToSeries(f, start, end, samples,\n                seriesKey);\n        XYSeriesCollection collection = new XYSeriesCollection(series);\n        return collection;\n    }\n\n    \n    public static XYSeries sampleFunction2DToSeries(Function2D f,\n            double start, double end, int samples, Comparable seriesKey) {\n\n        if (f == null) {\n            throw new IllegalArgumentException(\"Null 'f' argument.\");\n        }\n        if (seriesKey == null) {\n            throw new IllegalArgumentException(\"Null 'seriesKey' argument.\");\n        }\n        if (start >= end) {\n            throw new IllegalArgumentException(\"Requires 'start' < 'end'.\");\n        }\n        if (samples < 2) {\n            throw new IllegalArgumentException(\"Requires 'samples' > 1\");\n        }\n\n        XYSeries series = new XYSeries(seriesKey);\n        double step = (end - start) / (samples - 1);\n        for (int i = 0; i < samples; i++) {\n            double x = start + (step * i);\n            series.add(x, f.getValue(x));\n        }\n        return series;\n    }\n\n    \n    public static boolean isEmptyOrNull(PieDataset dataset) {\n\n        if (dataset == null) {\n            return true;\n        }\n\n        int itemCount = dataset.getItemCount();\n        if (itemCount == 0) {\n            return true;\n        }\n\n        for (int item = 0; item < itemCount; item++) {\n            Number y = dataset.getValue(item);\n            if (y != null) {\n                double yy = y.doubleValue();\n                if (yy > 0.0) {\n                    return false;\n                }\n            }\n        }\n\n        return true;\n\n    }\n\n    \n    public static boolean isEmptyOrNull(CategoryDataset dataset) {\n\n        if (dataset == null) {\n            return true;\n        }\n\n        int rowCount = dataset.getRowCount();\n        int columnCount = dataset.getColumnCount();\n        if (rowCount == 0 || columnCount == 0) {\n            return true;\n        }\n\n        for (int r = 0; r < rowCount; r++) {\n            for (int c = 0; c < columnCount; c++) {\n                if (dataset.getValue(r, c) != null) {\n                    return false;\n                }\n\n            }\n        }\n\n        return true;\n\n    }\n\n    \n    public static boolean isEmptyOrNull(XYDataset dataset) {\n        if (dataset != null) {\n            for (int s = 0; s < dataset.getSeriesCount(); s++) {\n                if (dataset.getItemCount(s) > 0) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    \n    public static Range findDomainBounds(XYDataset dataset) {\n        return findDomainBounds(dataset, true);\n    }\n\n    \n    public static Range findDomainBounds(XYDataset dataset,\n                                         boolean includeInterval) {\n\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n\n        Range result = null;\n        \n        if (dataset instanceof DomainInfo) {\n            DomainInfo info = (DomainInfo) dataset;\n            result = info.getDomainBounds(includeInterval);\n        }\n        else {\n            result = iterateDomainBounds(dataset, includeInterval);\n        }\n        return result;\n\n    }\n\n    \n    public static Range findDomainBounds(XYDataset dataset,\n            List visibleSeriesKeys, boolean includeInterval) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        Range result = null;\n        if (dataset instanceof XYDomainInfo) {\n            XYDomainInfo info = (XYDomainInfo) dataset;\n            result = info.getDomainBounds(visibleSeriesKeys, includeInterval);\n        }\n        else {\n            result = iterateToFindDomainBounds(dataset, visibleSeriesKeys,\n                    includeInterval);\n        }\n        return result;\n    }\n\n    \n    public static Range iterateDomainBounds(XYDataset dataset) {\n        return iterateDomainBounds(dataset, true);\n    }\n\n    \n    public static Range iterateDomainBounds(XYDataset dataset,\n                                            boolean includeInterval) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n        int seriesCount = dataset.getSeriesCount();\n        double lvalue;\n        double uvalue;\n        if (includeInterval && dataset instanceof IntervalXYDataset) {\n            IntervalXYDataset intervalXYData = (IntervalXYDataset) dataset;\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double value = intervalXYData.getXValue(series, item);\n                    lvalue = intervalXYData.getStartXValue(series, item);\n                    uvalue = intervalXYData.getEndXValue(series, item);\n                    if (!Double.isNaN(value)) {\n                        minimum = Math.min(minimum, value);\n                        maximum = Math.max(maximum, value);\n                    }\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                        maximum = Math.max(maximum, lvalue);\n                    }\n                    if (!Double.isNaN(uvalue)) {\n                        minimum = Math.min(minimum, uvalue);\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        else {\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    lvalue = dataset.getXValue(series, item);\n                    uvalue = lvalue;\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        if (minimum > maximum) {\n            return null;\n        }\n        else {\n            return new Range(minimum, maximum);\n        }\n    }\n\n    \n    public static Range findRangeBounds(CategoryDataset dataset) {\n        return findRangeBounds(dataset, true);\n    }\n\n    \n    public static Range findRangeBounds(CategoryDataset dataset,\n                                        boolean includeInterval) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        Range result = null;\n        if (dataset instanceof RangeInfo) {\n            RangeInfo info = (RangeInfo) dataset;\n            result = info.getRangeBounds(includeInterval);\n        }\n        else {\n            result = iterateRangeBounds(dataset, includeInterval);\n        }\n        return result;\n    }\n\n    \n    public static Range findRangeBounds(CategoryDataset dataset,\n            List visibleSeriesKeys, boolean includeInterval) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        Range result = null;\n        if (dataset instanceof CategoryRangeInfo) {\n            CategoryRangeInfo info = (CategoryRangeInfo) dataset;\n            result = info.getRangeBounds(visibleSeriesKeys, includeInterval);\n        }\n        else {\n            result = iterateToFindRangeBounds(dataset, visibleSeriesKeys,\n                    includeInterval);\n        }\n        return result;\n    }\n\n    \n    public static Range findRangeBounds(XYDataset dataset) {\n        return findRangeBounds(dataset, true);\n    }\n\n    \n    public static Range findRangeBounds(XYDataset dataset,\n                                        boolean includeInterval) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        Range result = null;\n        if (dataset instanceof RangeInfo) {\n            RangeInfo info = (RangeInfo) dataset;\n            result = info.getRangeBounds(includeInterval);\n        }\n        else {\n            result = iterateRangeBounds(dataset, includeInterval);\n        }\n        return result;\n    }\n\n    \n    public static Range findRangeBounds(XYDataset dataset,\n            List visibleSeriesKeys, Range xRange, boolean includeInterval) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        Range result = null;\n        if (dataset instanceof XYRangeInfo) {\n            XYRangeInfo info = (XYRangeInfo) dataset;\n            result = info.getRangeBounds(visibleSeriesKeys, xRange,\n                    includeInterval);\n        }\n        else {\n            result = iterateToFindRangeBounds(dataset, visibleSeriesKeys,\n                    xRange, includeInterval);\n        }\n        return result;\n    }\n\n    \n    public static Range iterateCategoryRangeBounds(CategoryDataset dataset,\n            boolean includeInterval) {\n        return iterateRangeBounds(dataset, includeInterval);\n    }\n\n    \n    public static Range iterateRangeBounds(CategoryDataset dataset) {\n        return iterateRangeBounds(dataset, true);\n    }\n\n    \n    public static Range iterateRangeBounds(CategoryDataset dataset,\n            boolean includeInterval) {\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n        int rowCount = dataset.getRowCount();\n        int columnCount = dataset.getColumnCount();\n        if (includeInterval && dataset instanceof IntervalCategoryDataset) {\n            \n            \n            IntervalCategoryDataset icd = (IntervalCategoryDataset) dataset;\n            Number value, lvalue, uvalue;\n            for (int row = 0; row < rowCount; row++) {\n                for (int column = 0; column < columnCount; column++) {\n                    value = icd.getValue(row, column);\n                    double v;\n                    if ((value != null)\n                            && !Double.isNaN(v = value.doubleValue())) {\n                        minimum = Math.min(v, minimum);\n                        maximum = Math.max(v, maximum);\n                    }\n                    lvalue = icd.getStartValue(row, column);\n                    if (lvalue != null\n                            && !Double.isNaN(v = lvalue.doubleValue())) {\n                        minimum = Math.min(v, minimum);\n                        maximum = Math.max(v, maximum);\n                    }\n                    uvalue = icd.getEndValue(row, column);\n                    if (uvalue != null \n                            && !Double.isNaN(v = uvalue.doubleValue())) {\n                        minimum = Math.min(v, minimum);\n                        maximum = Math.max(v, maximum);\n                    }\n                }\n            }\n        }\n        else {\n            \n            for (int row = 0; row < rowCount; row++) {\n                for (int column = 0; column < columnCount; column++) {\n                    Number value = dataset.getValue(row, column);\n                    if (value != null) {\n                        double v = value.doubleValue();\n                        if (!Double.isNaN(v)) {\n                            minimum = Math.min(minimum, v);\n                            maximum = Math.max(maximum, v);\n                        }\n                    }\n                }\n            }\n        }\n        if (minimum == Double.POSITIVE_INFINITY) {\n            return null;\n        }\n        else {\n            return new Range(minimum, maximum);\n        }\n    }\n\n    \n    public static Range iterateToFindRangeBounds(CategoryDataset dataset,\n            List visibleSeriesKeys, boolean includeInterval) {\n\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        if (visibleSeriesKeys == null) {\n            throw new IllegalArgumentException(\n                    \"Null 'visibleSeriesKeys' argument.\");\n        }\n\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n        int columnCount = dataset.getColumnCount();\n        if (includeInterval\n                && dataset instanceof BoxAndWhiskerCategoryDataset) {\n            \n            BoxAndWhiskerCategoryDataset bx\n                    = (BoxAndWhiskerCategoryDataset) dataset;\n            Iterator iterator = visibleSeriesKeys.iterator();\n            while (iterator.hasNext()) {\n                Comparable seriesKey = (Comparable) iterator.next();\n                int series = dataset.getRowIndex(seriesKey);\n                int itemCount = dataset.getColumnCount();\n                for (int item = 0; item < itemCount; item++) {\n                    Number lvalue = bx.getMinRegularValue(series, item);\n                    if (lvalue == null) {\n                        lvalue = bx.getValue(series, item);\n                    }\n                    Number uvalue = bx.getMaxRegularValue(series, item);\n                    if (uvalue == null) {\n                        uvalue = bx.getValue(series, item);\n                    }\n                    if (lvalue != null) {\n                        minimum = Math.min(minimum, lvalue.doubleValue());\n                    }\n                    if (uvalue != null) {\n                        maximum = Math.max(maximum, uvalue.doubleValue());\n                    }\n                }\n            }\n        }\n        else if (includeInterval\n                && dataset instanceof IntervalCategoryDataset) {\n            \n            \n            IntervalCategoryDataset icd = (IntervalCategoryDataset) dataset;\n            Number lvalue, uvalue;\n            Iterator iterator = visibleSeriesKeys.iterator();\n            while (iterator.hasNext()) {\n                Comparable seriesKey = (Comparable) iterator.next();\n                int series = dataset.getRowIndex(seriesKey);\n                for (int column = 0; column < columnCount; column++) {\n                    lvalue = icd.getStartValue(series, column);\n                    uvalue = icd.getEndValue(series, column);\n                    if (lvalue != null && !Double.isNaN(lvalue.doubleValue())) {\n                        minimum = Math.min(minimum, lvalue.doubleValue());\n                    }\n                    if (uvalue != null && !Double.isNaN(uvalue.doubleValue())) {\n                        maximum = Math.max(maximum, uvalue.doubleValue());\n                    }\n                }\n            }\n        }\n        else if (includeInterval\n                && dataset instanceof MultiValueCategoryDataset) {\n            \n            \n            MultiValueCategoryDataset mvcd\n                    = (MultiValueCategoryDataset) dataset;\n            Iterator iterator = visibleSeriesKeys.iterator();\n            while (iterator.hasNext()) {\n                Comparable seriesKey = (Comparable) iterator.next();\n                int series = dataset.getRowIndex(seriesKey);\n                for (int column = 0; column < columnCount; column++) {\n                    List values = mvcd.getValues(series, column);\n                    Iterator valueIterator = values.iterator();\n                    while (valueIterator.hasNext()) {\n                    \tObject o = valueIterator.next();\n\t\t\t\t\t\tif (o instanceof Number){\n\t\t\t\t\t\t\tdouble v = ((Number) o).doubleValue();\n\t\t\t\t\t\t\tif (!Double.isNaN(v)){\n\t                            minimum = Math.min(minimum, v);\n\t                            maximum = Math.max(maximum, v);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n                    }\n               }\n            }\n        }\n        else if (includeInterval\n                && dataset instanceof StatisticalCategoryDataset) {\n            \n            \n            StatisticalCategoryDataset scd\n                    = (StatisticalCategoryDataset) dataset;\n            Iterator iterator = visibleSeriesKeys.iterator();\n            while (iterator.hasNext()) {\n                Comparable seriesKey = (Comparable) iterator.next();\n                int series = dataset.getRowIndex(seriesKey);\n                for (int column = 0; column < columnCount; column++) {\n                    Number meanN = scd.getMeanValue(series, column);\n                    if (meanN != null) {\n                        double std = 0.0;\n                        Number stdN = scd.getStdDevValue(series, column);\n                        if (stdN != null) {\n                            std = stdN.doubleValue();\n                            if (Double.isNaN(std)) {\n                                std = 0.0;\n                            }\n                        }\n                        double mean = meanN.doubleValue();\n                        if (!Double.isNaN(mean)) {\n                            minimum = Math.min(minimum, mean - std);\n                            maximum = Math.max(maximum, mean + std);\n                        }\n                    }\n                }\n            }\n        }\n        else {\n            \n            Iterator iterator = visibleSeriesKeys.iterator();\n            while (iterator.hasNext()) {\n                Comparable seriesKey = (Comparable) iterator.next();\n                int series = dataset.getRowIndex(seriesKey);\n                for (int column = 0; column < columnCount; column++) {\n                    Number value = dataset.getValue(series, column);\n                    if (value != null) {\n                        double v = value.doubleValue();\n                        if (!Double.isNaN(v)) {\n                            minimum = Math.min(minimum, v);\n                            maximum = Math.max(maximum, v);\n                        }\n                    }\n                }\n            }\n        }\n        if (minimum == Double.POSITIVE_INFINITY) {\n            return null;\n        }\n        else {\n            return new Range(minimum, maximum);\n        }\n    }\n\n    \n    public static Range iterateXYRangeBounds(XYDataset dataset) {\n        return iterateRangeBounds(dataset);\n    }\n\n    \n    public static Range iterateRangeBounds(XYDataset dataset) {\n        return iterateRangeBounds(dataset, true);\n    }\n\n    \n    public static Range iterateRangeBounds(XYDataset dataset,\n            boolean includeInterval) {\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n        int seriesCount = dataset.getSeriesCount();\n\n        \n        if (includeInterval && dataset instanceof IntervalXYDataset) {\n            \n            IntervalXYDataset ixyd = (IntervalXYDataset) dataset;\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double value = ixyd.getYValue(series, item);\n                    double lvalue = ixyd.getStartYValue(series, item);\n                    double uvalue = ixyd.getEndYValue(series, item);\n                    if (!Double.isNaN(value)) {\n                        minimum = Math.min(minimum, value);\n                        maximum = Math.max(maximum, value);\n                    }\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                        maximum = Math.max(maximum, lvalue);\n                    }\n                    if (!Double.isNaN(uvalue)) {\n                        minimum = Math.min(minimum, uvalue);\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        else if (includeInterval && dataset instanceof OHLCDataset) {\n            \n            OHLCDataset ohlc = (OHLCDataset) dataset;\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double lvalue = ohlc.getLowValue(series, item);\n                    double uvalue = ohlc.getHighValue(series, item);\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                    }\n                    if (!Double.isNaN(uvalue)) {\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        else {\n            \n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double value = dataset.getYValue(series, item);\n                    if (!Double.isNaN(value)) {\n                        minimum = Math.min(minimum, value);\n                        maximum = Math.max(maximum, value);\n                    }\n                }\n            }\n        }\n        if (minimum == Double.POSITIVE_INFINITY) {\n            return null;\n        }\n        else {\n            return new Range(minimum, maximum);\n        }\n    }\n\n    \n    public static Range iterateToFindDomainBounds(XYDataset dataset,\n            List visibleSeriesKeys, boolean includeInterval) {\n\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        if (visibleSeriesKeys == null) {\n            throw new IllegalArgumentException(\n                    \"Null 'visibleSeriesKeys' argument.\");\n        }\n\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n\n        if (includeInterval && dataset instanceof IntervalXYDataset) {\n            \n            IntervalXYDataset ixyd = (IntervalXYDataset) dataset;\n            Iterator iterator = visibleSeriesKeys.iterator();\n            while (iterator.hasNext()) {\n                Comparable seriesKey = (Comparable) iterator.next();\n                int series = dataset.indexOf(seriesKey);\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double lvalue = ixyd.getStartXValue(series, item);\n                    double uvalue = ixyd.getEndXValue(series, item);\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                    }\n                    if (!Double.isNaN(uvalue)) {\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        else {\n            \n            Iterator iterator = visibleSeriesKeys.iterator();\n            while (iterator.hasNext()) {\n                Comparable seriesKey = (Comparable) iterator.next();\n                int series = dataset.indexOf(seriesKey);\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double x = dataset.getXValue(series, item);\n                    if (!Double.isNaN(x)) {\n                        minimum = Math.min(minimum, x);\n                        maximum = Math.max(maximum, x);\n                    }\n                }\n            }\n        }\n\n        if (minimum == Double.POSITIVE_INFINITY) {\n            return null;\n        }\n        else {\n            return new Range(minimum, maximum);\n        }\n    }\n\n    \n    public static Range iterateToFindRangeBounds(XYDataset dataset,\n            List visibleSeriesKeys, Range xRange, boolean includeInterval) {\n\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        if (visibleSeriesKeys == null) {\n            throw new IllegalArgumentException(\n                    \"Null 'visibleSeriesKeys' argument.\");\n        }\n        if (xRange == null) {\n            throw new IllegalArgumentException(\"Null 'xRange' argument\");\n        }\n\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n\n        \n        if (includeInterval && dataset instanceof OHLCDataset) {\n            \n            OHLCDataset ohlc = (OHLCDataset) dataset;\n            Iterator iterator = visibleSeriesKeys.iterator();\n            while (iterator.hasNext()) {\n                Comparable seriesKey = (Comparable) iterator.next();\n                int series = dataset.indexOf(seriesKey);\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double x = ohlc.getXValue(series, item);\n                    if (xRange.contains(x)) {\n                        double lvalue = ohlc.getLowValue(series, item);\n                        double uvalue = ohlc.getHighValue(series, item);\n                        if (!Double.isNaN(lvalue)) {\n                            minimum = Math.min(minimum, lvalue);\n                        }\n                        if (!Double.isNaN(uvalue)) {\n                            maximum = Math.max(maximum, uvalue);\n                        }\n                    }\n                }\n            }\n        }\n        else if (includeInterval && dataset instanceof BoxAndWhiskerXYDataset) {\n            \n            BoxAndWhiskerXYDataset bx = (BoxAndWhiskerXYDataset) dataset;\n            Iterator iterator = visibleSeriesKeys.iterator();\n            while (iterator.hasNext()) {\n                Comparable seriesKey = (Comparable) iterator.next();\n                int series = dataset.indexOf(seriesKey);\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double x = bx.getXValue(series, item);\n                    if (xRange.contains(x)) {\n                        Number lvalue = bx.getMinRegularValue(series, item);\n                        Number uvalue = bx.getMaxRegularValue(series, item);\n                        if (lvalue != null) {\n                            minimum = Math.min(minimum, lvalue.doubleValue());\n                        }\n                        if (uvalue != null) {\n                            maximum = Math.max(maximum, uvalue.doubleValue());\n                        }\n                    }\n                }\n            }\n        }\n        else if (includeInterval && dataset instanceof IntervalXYDataset) {\n            \n            IntervalXYDataset ixyd = (IntervalXYDataset) dataset;\n            Iterator iterator = visibleSeriesKeys.iterator();\n            while (iterator.hasNext()) {\n                Comparable seriesKey = (Comparable) iterator.next();\n                int series = dataset.indexOf(seriesKey);\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double x = ixyd.getXValue(series, item);\n                    if (xRange.contains(x)) {\n                        double lvalue = ixyd.getStartYValue(series, item);\n                        double uvalue = ixyd.getEndYValue(series, item);\n                        if (!Double.isNaN(lvalue)) {\n                            minimum = Math.min(minimum, lvalue);\n                        }\n                        if (!Double.isNaN(uvalue)) {\n                            maximum = Math.max(maximum, uvalue);\n                        }\n                    }\n                }\n            }\n        }\n        else {\n            \n            Iterator iterator = visibleSeriesKeys.iterator();\n            while (iterator.hasNext()) {\n                Comparable seriesKey = (Comparable) iterator.next();\n                int series = dataset.indexOf(seriesKey);\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double x = dataset.getXValue(series, item);\n                    double y = dataset.getYValue(series, item);\n                    if (xRange.contains(x)) {\n                        if (!Double.isNaN(y)) {\n                            minimum = Math.min(minimum, y);\n                            maximum = Math.max(maximum, y);\n                        }\n                    }\n                }\n            }\n        }\n        if (minimum == Double.POSITIVE_INFINITY) {\n            return null;\n        }\n        else {\n            return new Range(minimum, maximum);\n        }\n    }\n\n    \n    public static Number findMinimumDomainValue(XYDataset dataset) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        Number result = null;\n        \n        if (dataset instanceof DomainInfo) {\n            DomainInfo info = (DomainInfo) dataset;\n            return new Double(info.getDomainLowerBound(true));\n        }\n        else {\n            double minimum = Double.POSITIVE_INFINITY;\n            int seriesCount = dataset.getSeriesCount();\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n\n                    double value;\n                    if (dataset instanceof IntervalXYDataset) {\n                        IntervalXYDataset intervalXYData\n                            = (IntervalXYDataset) dataset;\n                        value = intervalXYData.getStartXValue(series, item);\n                    }\n                    else {\n                        value = dataset.getXValue(series, item);\n                    }\n                    if (!Double.isNaN(value)) {\n                        minimum = Math.min(minimum, value);\n                    }\n\n                }\n            }\n            if (minimum == Double.POSITIVE_INFINITY) {\n                result = null;\n            }\n            else {\n                result = new Double(minimum);\n            }\n        }\n\n        return result;\n    }\n\n    \n    public static Number findMaximumDomainValue(XYDataset dataset) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        Number result = null;\n        \n        if (dataset instanceof DomainInfo) {\n            DomainInfo info = (DomainInfo) dataset;\n            return new Double(info.getDomainUpperBound(true));\n        }\n\n        \n        else {\n            double maximum = Double.NEGATIVE_INFINITY;\n            int seriesCount = dataset.getSeriesCount();\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n\n                    double value;\n                    if (dataset instanceof IntervalXYDataset) {\n                        IntervalXYDataset intervalXYData\n                            = (IntervalXYDataset) dataset;\n                        value = intervalXYData.getEndXValue(series, item);\n                    }\n                    else {\n                        value = dataset.getXValue(series, item);\n                    }\n                    if (!Double.isNaN(value)) {\n                        maximum = Math.max(maximum, value);\n                    }\n                }\n            }\n            if (maximum == Double.NEGATIVE_INFINITY) {\n                result = null;\n            }\n            else {\n                result = new Double(maximum);\n            }\n\n        }\n\n        return result;\n    }\n\n    \n    public static Number findMinimumRangeValue(CategoryDataset dataset) {\n\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n\n        if (dataset instanceof RangeInfo) {\n            RangeInfo info = (RangeInfo) dataset;\n            return new Double(info.getRangeLowerBound(true));\n        }\n\n        \n        else {\n            double minimum = Double.POSITIVE_INFINITY;\n            int seriesCount = dataset.getRowCount();\n            int itemCount = dataset.getColumnCount();\n            for (int series = 0; series < seriesCount; series++) {\n                for (int item = 0; item < itemCount; item++) {\n                    Number value;\n                    if (dataset instanceof IntervalCategoryDataset) {\n                        IntervalCategoryDataset icd\n                                = (IntervalCategoryDataset) dataset;\n                        value = icd.getStartValue(series, item);\n                    }\n                    else {\n                        value = dataset.getValue(series, item);\n                    }\n                    if (value != null) {\n                        minimum = Math.min(minimum, value.doubleValue());\n                    }\n                }\n            }\n            if (minimum == Double.POSITIVE_INFINITY) {\n                return null;\n            }\n            else {\n                return new Double(minimum);\n            }\n\n        }\n\n    }\n\n    \n    public static Number findMinimumRangeValue(XYDataset dataset) {\n\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n\n        \n        if (dataset instanceof RangeInfo) {\n            RangeInfo info = (RangeInfo) dataset;\n            return new Double(info.getRangeLowerBound(true));\n        }\n\n        \n        else {\n            double minimum = Double.POSITIVE_INFINITY;\n            int seriesCount = dataset.getSeriesCount();\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n\n                    double value;\n                    if (dataset instanceof IntervalXYDataset) {\n                        IntervalXYDataset intervalXYData\n                                = (IntervalXYDataset) dataset;\n                        value = intervalXYData.getStartYValue(series, item);\n                    }\n                    else if (dataset instanceof OHLCDataset) {\n                        OHLCDataset highLowData = (OHLCDataset) dataset;\n                        value = highLowData.getLowValue(series, item);\n                    }\n                    else {\n                        value = dataset.getYValue(series, item);\n                    }\n                    if (!Double.isNaN(value)) {\n                        minimum = Math.min(minimum, value);\n                    }\n\n                }\n            }\n            if (minimum == Double.POSITIVE_INFINITY) {\n                return null;\n            }\n            else {\n                return new Double(minimum);\n            }\n\n        }\n\n    }\n\n    \n    public static Number findMaximumRangeValue(CategoryDataset dataset) {\n\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n\n        \n        if (dataset instanceof RangeInfo) {\n            RangeInfo info = (RangeInfo) dataset;\n            return new Double(info.getRangeUpperBound(true));\n        }\n\n        \n        else {\n\n            double maximum = Double.NEGATIVE_INFINITY;\n            int seriesCount = dataset.getRowCount();\n            int itemCount = dataset.getColumnCount();\n            for (int series = 0; series < seriesCount; series++) {\n                for (int item = 0; item < itemCount; item++) {\n                    Number value;\n                    if (dataset instanceof IntervalCategoryDataset) {\n                        IntervalCategoryDataset icd\n                            = (IntervalCategoryDataset) dataset;\n                        value = icd.getEndValue(series, item);\n                    }\n                    else {\n                        value = dataset.getValue(series, item);\n                    }\n                    if (value != null) {\n                        maximum = Math.max(maximum, value.doubleValue());\n                    }\n                }\n            }\n            if (maximum == Double.NEGATIVE_INFINITY) {\n                return null;\n            }\n            else {\n                return new Double(maximum);\n            }\n\n        }\n\n    }\n\n    \n    public static Number findMaximumRangeValue(XYDataset dataset) {\n\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n\n        \n        if (dataset instanceof RangeInfo) {\n            RangeInfo info = (RangeInfo) dataset;\n            return new Double(info.getRangeUpperBound(true));\n        }\n\n        \n        else  {\n\n            double maximum = Double.NEGATIVE_INFINITY;\n            int seriesCount = dataset.getSeriesCount();\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double value;\n                    if (dataset instanceof IntervalXYDataset) {\n                        IntervalXYDataset intervalXYData\n                            = (IntervalXYDataset) dataset;\n                        value = intervalXYData.getEndYValue(series, item);\n                    }\n                    else if (dataset instanceof OHLCDataset) {\n                        OHLCDataset highLowData = (OHLCDataset) dataset;\n                        value = highLowData.getHighValue(series, item);\n                    }\n                    else {\n                        value = dataset.getYValue(series, item);\n                    }\n                    if (!Double.isNaN(value)) {\n                        maximum = Math.max(maximum, value);\n                    }\n                }\n            }\n            if (maximum == Double.NEGATIVE_INFINITY) {\n                return null;\n            }\n            else {\n                return new Double(maximum);\n            }\n\n        }\n\n    }\n\n    \n    public static Range findStackedRangeBounds(CategoryDataset dataset) {\n        return findStackedRangeBounds(dataset, 0.0);\n    }\n\n    \n    public static Range findStackedRangeBounds(CategoryDataset dataset,\n            double base) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        Range result = null;\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n        int categoryCount = dataset.getColumnCount();\n        for (int item = 0; item < categoryCount; item++) {\n            double positive = base;\n            double negative = base;\n            int seriesCount = dataset.getRowCount();\n            for (int series = 0; series < seriesCount; series++) {\n                Number number = dataset.getValue(series, item);\n                if (number != null) {\n                    double value = number.doubleValue();\n                    if (value > 0.0) {\n                        positive = positive + value;\n                    }\n                    if (value < 0.0) {\n                        negative = negative + value;\n                        \n                    }\n                }\n            }\n            minimum = Math.min(minimum, negative);\n            maximum = Math.max(maximum, positive);\n        }\n        if (minimum <= maximum) {\n            result = new Range(minimum, maximum);\n        }\n        return result;\n\n    }\n\n    \n    public static Range findStackedRangeBounds(CategoryDataset dataset,\n                                               KeyToGroupMap map) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        boolean hasValidData = false;\n        Range result = null;\n\n        \n        int[] groupIndex = new int[dataset.getRowCount()];\n        for (int i = 0; i < dataset.getRowCount(); i++) {\n            groupIndex[i] = map.getGroupIndex(map.getGroup(\n                    dataset.getRowKey(i)));\n        }\n\n        \n        int groupCount = map.getGroupCount();\n        double[] minimum = new double[groupCount];\n        double[] maximum = new double[groupCount];\n\n        int categoryCount = dataset.getColumnCount();\n        for (int item = 0; item < categoryCount; item++) {\n            double[] positive = new double[groupCount];\n            double[] negative = new double[groupCount];\n            int seriesCount = dataset.getRowCount();\n            for (int series = 0; series < seriesCount; series++) {\n                Number number = dataset.getValue(series, item);\n                if (number != null) {\n                    hasValidData = true;\n                    double value = number.doubleValue();\n                    if (value > 0.0) {\n                        positive[groupIndex[series]]\n                                 = positive[groupIndex[series]] + value;\n                    }\n                    if (value < 0.0) {\n                        negative[groupIndex[series]]\n                                 = negative[groupIndex[series]] + value;\n                                 \n                    }\n                }\n            }\n            for (int g = 0; g < groupCount; g++) {\n                minimum[g] = Math.min(minimum[g], negative[g]);\n                maximum[g] = Math.max(maximum[g], positive[g]);\n            }\n        }\n        if (hasValidData) {\n            for (int j = 0; j < groupCount; j++) {\n                result = Range.combine(result, new Range(minimum[j],\n                        maximum[j]));\n            }\n        }\n        return result;\n    }\n\n    \n    public static Number findMinimumStackedRangeValue(CategoryDataset dataset) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        Number result = null;\n        boolean hasValidData = false;\n        double minimum = 0.0;\n        int categoryCount = dataset.getColumnCount();\n        for (int item = 0; item < categoryCount; item++) {\n            double total = 0.0;\n            int seriesCount = dataset.getRowCount();\n            for (int series = 0; series < seriesCount; series++) {\n                Number number = dataset.getValue(series, item);\n                if (number != null) {\n                    hasValidData = true;\n                    double value = number.doubleValue();\n                    if (value < 0.0) {\n                        total = total + value;\n                        \n                    }\n                }\n            }\n            minimum = Math.min(minimum, total);\n        }\n        if (hasValidData) {\n            result = new Double(minimum);\n        }\n        return result;\n    }\n\n    \n    public static Number findMaximumStackedRangeValue(CategoryDataset dataset) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        Number result = null;\n        boolean hasValidData = false;\n        double maximum = 0.0;\n        int categoryCount = dataset.getColumnCount();\n        for (int item = 0; item < categoryCount; item++) {\n            double total = 0.0;\n            int seriesCount = dataset.getRowCount();\n            for (int series = 0; series < seriesCount; series++) {\n                Number number = dataset.getValue(series, item);\n                if (number != null) {\n                    hasValidData = true;\n                    double value = number.doubleValue();\n                    if (value > 0.0) {\n                        total = total + value;\n                    }\n                }\n            }\n            maximum = Math.max(maximum, total);\n        }\n        if (hasValidData) {\n            result = new Double(maximum);\n        }\n        return result;\n    }\n\n    \n    public static Range findStackedRangeBounds(TableXYDataset dataset) {\n        return findStackedRangeBounds(dataset, 0.0);\n    }\n\n    \n    public static Range findStackedRangeBounds(TableXYDataset dataset,\n                                               double base) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        double minimum = base;\n        double maximum = base;\n        for (int itemNo = 0; itemNo < dataset.getItemCount(); itemNo++) {\n            double positive = base;\n            double negative = base;\n            int seriesCount = dataset.getSeriesCount();\n            for (int seriesNo = 0; seriesNo < seriesCount; seriesNo++) {\n                double y = dataset.getYValue(seriesNo, itemNo);\n                if (!Double.isNaN(y)) {\n                    if (y > 0.0) {\n                        positive += y;\n                    }\n                    else {\n                        negative += y;\n                    }\n                }\n            }\n            if (positive > maximum) {\n                maximum = positive;\n            }\n            if (negative < minimum) {\n                minimum = negative;\n            }\n        }\n        if (minimum <= maximum) {\n            return new Range(minimum, maximum);\n        }\n        else {\n            return null;\n        }\n    }\n\n    \n    public static double calculateStackTotal(TableXYDataset dataset, int item) {\n        double total = 0.0;\n        int seriesCount = dataset.getSeriesCount();\n        for (int s = 0; s < seriesCount; s++) {\n            double value = dataset.getYValue(s, item);\n            if (!Double.isNaN(value)) {\n                total = total + value;\n            }\n        }\n        return total;\n    }\n\n    \n    public static Range findCumulativeRangeBounds(CategoryDataset dataset) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        boolean allItemsNull = true; \n                                     \n        double minimum = 0.0;\n        double maximum = 0.0;\n        for (int row = 0; row < dataset.getRowCount(); row++) {\n            double runningTotal = 0.0;\n            for (int column = 0; column <= dataset.getColumnCount() - 1;\n                 column++) {\n                Number n = dataset.getValue(row, column);\n                if (n != null) {\n                    allItemsNull = false;\n                    double value = n.doubleValue();\n                    if (!Double.isNaN(value)) {\n                        runningTotal = runningTotal + value;\n                        minimum = Math.min(minimum, runningTotal);\n                        maximum = Math.max(maximum, runningTotal);\n                    }\n                }\n            }\n        }\n        if (!allItemsNull) {\n            return new Range(minimum, maximum);\n        }\n        else {\n            return null;\n        }\n    }\n\n}\n",
      "buggy_signatures": [
        "private DatasetUtilities()",
        "public static double calculatePieDatasetTotal(PieDataset dataset)",
        "public static PieDataset createPieDatasetForRow(CategoryDataset dataset, Comparable rowKey)",
        "public static PieDataset createPieDatasetForRow(CategoryDataset dataset, int row)",
        "public static PieDataset createPieDatasetForColumn(CategoryDataset dataset, Comparable columnKey)",
        "public static PieDataset createPieDatasetForColumn(CategoryDataset dataset, int column)",
        "public static PieDataset createConsolidatedPieDataset(PieDataset source, Comparable key, double minimumPercent)",
        "public static PieDataset createConsolidatedPieDataset(PieDataset source, Comparable key, double minimumPercent, int minItems)",
        "public static CategoryDataset createCategoryDataset(String rowKeyPrefix, String columnKeyPrefix, double[][] data)",
        "public static CategoryDataset createCategoryDataset(String rowKeyPrefix, String columnKeyPrefix, Number[][] data)",
        "public static CategoryDataset createCategoryDataset(Comparable[] rowKeys, Comparable[] columnKeys, double[][] data)",
        "public static CategoryDataset createCategoryDataset(Comparable rowKey, KeyedValues rowData)",
        "public static XYDataset sampleFunction2D(Function2D f, double start, double end, int samples, Comparable seriesKey)",
        "public static XYSeries sampleFunction2DToSeries(Function2D f, double start, double end, int samples, Comparable seriesKey)",
        "public static boolean isEmptyOrNull(PieDataset dataset)",
        "public static boolean isEmptyOrNull(CategoryDataset dataset)",
        "public static boolean isEmptyOrNull(XYDataset dataset)",
        "public static Range findDomainBounds(XYDataset dataset)",
        "public static Range findDomainBounds(XYDataset dataset, boolean includeInterval)",
        "public static Range findDomainBounds(XYDataset dataset, List visibleSeriesKeys, boolean includeInterval)",
        "public static Range iterateDomainBounds(XYDataset dataset)",
        "public static Range iterateDomainBounds(XYDataset dataset, boolean includeInterval)",
        "public static Range findRangeBounds(CategoryDataset dataset)",
        "public static Range findRangeBounds(CategoryDataset dataset, boolean includeInterval)",
        "public static Range findRangeBounds(CategoryDataset dataset, List visibleSeriesKeys, boolean includeInterval)",
        "public static Range findRangeBounds(XYDataset dataset)",
        "public static Range findRangeBounds(XYDataset dataset, boolean includeInterval)",
        "public static Range findRangeBounds(XYDataset dataset, List visibleSeriesKeys, Range xRange, boolean includeInterval)",
        "public static Range iterateCategoryRangeBounds(CategoryDataset dataset, boolean includeInterval)",
        "public static Range iterateRangeBounds(CategoryDataset dataset)",
        "public static Range iterateRangeBounds(CategoryDataset dataset, boolean includeInterval)",
        "public static Range iterateToFindRangeBounds(CategoryDataset dataset, List visibleSeriesKeys, boolean includeInterval)",
        "public static Range iterateXYRangeBounds(XYDataset dataset)",
        "public static Range iterateRangeBounds(XYDataset dataset)",
        "public static Range iterateRangeBounds(XYDataset dataset, boolean includeInterval)",
        "public static Range iterateToFindDomainBounds(XYDataset dataset, List visibleSeriesKeys, boolean includeInterval)",
        "public static Range iterateToFindRangeBounds(XYDataset dataset, List visibleSeriesKeys, Range xRange, boolean includeInterval)",
        "public static Number findMinimumDomainValue(XYDataset dataset)",
        "public static Number findMaximumDomainValue(XYDataset dataset)",
        "public static Number findMinimumRangeValue(CategoryDataset dataset)",
        "public static Number findMinimumRangeValue(XYDataset dataset)",
        "public static Number findMaximumRangeValue(CategoryDataset dataset)",
        "public static Number findMaximumRangeValue(XYDataset dataset)",
        "public static Range findStackedRangeBounds(CategoryDataset dataset)",
        "public static Range findStackedRangeBounds(CategoryDataset dataset, double base)",
        "public static Range findStackedRangeBounds(CategoryDataset dataset, KeyToGroupMap map)",
        "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)",
        "public static Number findMaximumStackedRangeValue(CategoryDataset dataset)",
        "public static Range findStackedRangeBounds(TableXYDataset dataset)",
        "public static Range findStackedRangeBounds(TableXYDataset dataset, double base)",
        "public static double calculateStackTotal(TableXYDataset dataset, int item)",
        "public static Range findCumulativeRangeBounds(CategoryDataset dataset)"
      ],
      "fixed_signatures": [
        "private DatasetUtilities()",
        "public static double calculatePieDatasetTotal(PieDataset dataset)",
        "public static PieDataset createPieDatasetForRow(CategoryDataset dataset, Comparable rowKey)",
        "public static PieDataset createPieDatasetForRow(CategoryDataset dataset, int row)",
        "public static PieDataset createPieDatasetForColumn(CategoryDataset dataset, Comparable columnKey)",
        "public static PieDataset createPieDatasetForColumn(CategoryDataset dataset, int column)",
        "public static PieDataset createConsolidatedPieDataset(PieDataset source, Comparable key, double minimumPercent)",
        "public static PieDataset createConsolidatedPieDataset(PieDataset source, Comparable key, double minimumPercent, int minItems)",
        "public static CategoryDataset createCategoryDataset(String rowKeyPrefix, String columnKeyPrefix, double[][] data)",
        "public static CategoryDataset createCategoryDataset(String rowKeyPrefix, String columnKeyPrefix, Number[][] data)",
        "public static CategoryDataset createCategoryDataset(Comparable[] rowKeys, Comparable[] columnKeys, double[][] data)",
        "public static CategoryDataset createCategoryDataset(Comparable rowKey, KeyedValues rowData)",
        "public static XYDataset sampleFunction2D(Function2D f, double start, double end, int samples, Comparable seriesKey)",
        "public static XYSeries sampleFunction2DToSeries(Function2D f, double start, double end, int samples, Comparable seriesKey)",
        "public static boolean isEmptyOrNull(PieDataset dataset)",
        "public static boolean isEmptyOrNull(CategoryDataset dataset)",
        "public static boolean isEmptyOrNull(XYDataset dataset)",
        "public static Range findDomainBounds(XYDataset dataset)",
        "public static Range findDomainBounds(XYDataset dataset, boolean includeInterval)",
        "public static Range findDomainBounds(XYDataset dataset, List visibleSeriesKeys, boolean includeInterval)",
        "public static Range iterateDomainBounds(XYDataset dataset)",
        "public static Range iterateDomainBounds(XYDataset dataset, boolean includeInterval)",
        "public static Range findRangeBounds(CategoryDataset dataset)",
        "public static Range findRangeBounds(CategoryDataset dataset, boolean includeInterval)",
        "public static Range findRangeBounds(CategoryDataset dataset, List visibleSeriesKeys, boolean includeInterval)",
        "public static Range findRangeBounds(XYDataset dataset)",
        "public static Range findRangeBounds(XYDataset dataset, boolean includeInterval)",
        "public static Range findRangeBounds(XYDataset dataset, List visibleSeriesKeys, Range xRange, boolean includeInterval)",
        "public static Range iterateCategoryRangeBounds(CategoryDataset dataset, boolean includeInterval)",
        "public static Range iterateRangeBounds(CategoryDataset dataset)",
        "public static Range iterateRangeBounds(CategoryDataset dataset, boolean includeInterval)",
        "public static Range iterateToFindRangeBounds(CategoryDataset dataset, List visibleSeriesKeys, boolean includeInterval)",
        "public static Range iterateXYRangeBounds(XYDataset dataset)",
        "public static Range iterateRangeBounds(XYDataset dataset)",
        "public static Range iterateRangeBounds(XYDataset dataset, boolean includeInterval)",
        "public static Range iterateToFindDomainBounds(XYDataset dataset, List visibleSeriesKeys, boolean includeInterval)",
        "public static Range iterateToFindRangeBounds(XYDataset dataset, List visibleSeriesKeys, Range xRange, boolean includeInterval)",
        "public static Number findMinimumDomainValue(XYDataset dataset)",
        "public static Number findMaximumDomainValue(XYDataset dataset)",
        "public static Number findMinimumRangeValue(CategoryDataset dataset)",
        "public static Number findMinimumRangeValue(XYDataset dataset)",
        "public static Number findMaximumRangeValue(CategoryDataset dataset)",
        "public static Number findMaximumRangeValue(XYDataset dataset)",
        "public static Range findStackedRangeBounds(CategoryDataset dataset)",
        "public static Range findStackedRangeBounds(CategoryDataset dataset, double base)",
        "public static Range findStackedRangeBounds(CategoryDataset dataset, KeyToGroupMap map)",
        "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)",
        "public static Number findMaximumStackedRangeValue(CategoryDataset dataset)",
        "public static Range findStackedRangeBounds(TableXYDataset dataset)",
        "public static Range findStackedRangeBounds(TableXYDataset dataset, double base)",
        "public static double calculateStackTotal(TableXYDataset dataset, int item)",
        "public static Range findCumulativeRangeBounds(CategoryDataset dataset)"
      ],
      "methods": [
        {
          "buggy_method": "  public static Range iterateDomainBounds(XYDataset dataset,\n  boolean includeInterval) {\n  if (dataset == null) {\n  throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n  }\n  double minimum = Double.POSITIVE_INFINITY;\n  double maximum = Double.NEGATIVE_INFINITY;\n  int seriesCount = dataset.getSeriesCount();\n  double lvalue;\n  double uvalue;\n  if (includeInterval && dataset instanceof IntervalXYDataset) {\n  IntervalXYDataset intervalXYData = (IntervalXYDataset) dataset;\n  for (int series = 0; series < seriesCount; series++) {\n  int itemCount = dataset.getItemCount(series);\n  for (int item = 0; item < itemCount; item++) {\n  lvalue = intervalXYData.getStartXValue(series, item);\n  uvalue = intervalXYData.getEndXValue(series, item);\n  if (!Double.isNaN(lvalue)) {\n  minimum = Math.min(minimum, lvalue);\n  }\n  if (!Double.isNaN(uvalue)) {\n  maximum = Math.max(maximum, uvalue);\n  }\n  }\n  }\n  }\n  else {\n  for (int series = 0; series < seriesCount; series++) {\n  int itemCount = dataset.getItemCount(series);\n  for (int item = 0; item < itemCount; item++) {\n  lvalue = dataset.getXValue(series, item);\n  uvalue = lvalue;\n  if (!Double.isNaN(lvalue)) {\n  minimum = Math.min(minimum, lvalue);\n  maximum = Math.max(maximum, uvalue);\n  }\n  }\n  }\n  }\n  if (minimum > maximum) {\n  return null;\n  }\n  else {\n  return new Range(minimum, maximum);\n  }\n  }",
          "fixed_method": "  public static Range iterateDomainBounds(XYDataset dataset,\n  boolean includeInterval) {\n  if (dataset == null) {\n  throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n  }\n  double minimum = Double.POSITIVE_INFINITY;\n  double maximum = Double.NEGATIVE_INFINITY;\n  int seriesCount = dataset.getSeriesCount();\n  double lvalue;\n  double uvalue;\n  if (includeInterval && dataset instanceof IntervalXYDataset) {\n  IntervalXYDataset intervalXYData = (IntervalXYDataset) dataset;\n  for (int series = 0; series < seriesCount; series++) {\n  int itemCount = dataset.getItemCount(series);\n  for (int item = 0; item < itemCount; item++) {\n  double value = intervalXYData.getXValue(series, item);\n  lvalue = intervalXYData.getStartXValue(series, item);\n  uvalue = intervalXYData.getEndXValue(series, item);\n  if (!Double.isNaN(value)) {\n  minimum = Math.min(minimum, value);\n  maximum = Math.max(maximum, value);\n  }\n  if (!Double.isNaN(lvalue)) {\n  minimum = Math.min(minimum, lvalue);\n  maximum = Math.max(maximum, lvalue);\n  }\n  if (!Double.isNaN(uvalue)) {\n  minimum = Math.min(minimum, uvalue);\n  maximum = Math.max(maximum, uvalue);\n  }\n  }\n  }\n  }\n  else {\n  for (int series = 0; series < seriesCount; series++) {\n  int itemCount = dataset.getItemCount(series);\n  for (int item = 0; item < itemCount; item++) {\n  lvalue = dataset.getXValue(series, item);\n  uvalue = lvalue;\n  if (!Double.isNaN(lvalue)) {\n  minimum = Math.min(minimum, lvalue);\n  maximum = Math.max(maximum, uvalue);\n  }\n  }\n  }\n  }\n  if (minimum > maximum) {\n  return null;\n  }\n  else {\n  return new Range(minimum, maximum);\n  }\n  }",
          "diff": [
            "@@ -752,12 +752,19 @@",
            "             for (int series = 0; series < seriesCount; series++) {\n",
            "                 int itemCount = dataset.getItemCount(series);\n",
            "                 for (int item = 0; item < itemCount; item++) {\n",
            "+                    double value = intervalXYData.getXValue(series, item);\n",
            "                     lvalue = intervalXYData.getStartXValue(series, item);\n",
            "                     uvalue = intervalXYData.getEndXValue(series, item);\n",
            "+                    if (!Double.isNaN(value)) {\n",
            "+                        minimum = Math.min(minimum, value);\n",
            "+                        maximum = Math.max(maximum, value);\n",
            "+                    }\n",
            "                     if (!Double.isNaN(lvalue)) {\n",
            "                         minimum = Math.min(minimum, lvalue);\n",
            "+                        maximum = Math.max(maximum, lvalue);\n",
            "                     }\n",
            "                     if (!Double.isNaN(uvalue)) {\n",
            "+                        minimum = Math.min(minimum, uvalue);\n",
            "                         maximum = Math.max(maximum, uvalue);\n",
            "                     }\n",
            "                 }\n"
          ],
          "changed_lines": 7
        },
        {
          "buggy_method": "  public static Range iterateRangeBounds(XYDataset dataset,\n  boolean includeInterval) {\n  double minimum = Double.POSITIVE_INFINITY;\n  double maximum = Double.NEGATIVE_INFINITY;\n  int seriesCount = dataset.getSeriesCount();\n\n  \n  if (includeInterval && dataset instanceof IntervalXYDataset) {\n  \n  IntervalXYDataset ixyd = (IntervalXYDataset) dataset;\n  for (int series = 0; series < seriesCount; series++) {\n  int itemCount = dataset.getItemCount(series);\n  for (int item = 0; item < itemCount; item++) {\n  double lvalue = ixyd.getStartYValue(series, item);\n  double uvalue = ixyd.getEndYValue(series, item);\n  if (!Double.isNaN(lvalue)) {\n  minimum = Math.min(minimum, lvalue);\n  }\n  if (!Double.isNaN(uvalue)) {\n  maximum = Math.max(maximum, uvalue);\n  }\n  }\n  }\n  }\n  else if (includeInterval && dataset instanceof OHLCDataset) {\n  \n  OHLCDataset ohlc = (OHLCDataset) dataset;\n  for (int series = 0; series < seriesCount; series++) {\n  int itemCount = dataset.getItemCount(series);\n  for (int item = 0; item < itemCount; item++) {\n  double lvalue = ohlc.getLowValue(series, item);\n  double uvalue = ohlc.getHighValue(series, item);\n  if (!Double.isNaN(lvalue)) {\n  minimum = Math.min(minimum, lvalue);\n  }\n  if (!Double.isNaN(uvalue)) {\n  maximum = Math.max(maximum, uvalue);\n  }\n  }\n  }\n  }\n  else {\n  \n  for (int series = 0; series < seriesCount; series++) {\n  int itemCount = dataset.getItemCount(series);\n  for (int item = 0; item < itemCount; item++) {\n  double value = dataset.getYValue(series, item);\n  if (!Double.isNaN(value)) {\n  minimum = Math.min(minimum, value);\n  maximum = Math.max(maximum, value);\n  }\n  }\n  }\n  }\n  if (minimum == Double.POSITIVE_INFINITY) {\n  return null;\n  }\n  else {\n  return new Range(minimum, maximum);\n  }\n  }",
          "fixed_method": "  public static Range iterateRangeBounds(XYDataset dataset,\n  boolean includeInterval) {\n  double minimum = Double.POSITIVE_INFINITY;\n  double maximum = Double.NEGATIVE_INFINITY;\n  int seriesCount = dataset.getSeriesCount();\n\n  \n  if (includeInterval && dataset instanceof IntervalXYDataset) {\n  \n  IntervalXYDataset ixyd = (IntervalXYDataset) dataset;\n  for (int series = 0; series < seriesCount; series++) {\n  int itemCount = dataset.getItemCount(series);\n  for (int item = 0; item < itemCount; item++) {\n  double value = ixyd.getYValue(series, item);\n  double lvalue = ixyd.getStartYValue(series, item);\n  double uvalue = ixyd.getEndYValue(series, item);\n  if (!Double.isNaN(value)) {\n  minimum = Math.min(minimum, value);\n  maximum = Math.max(maximum, value);\n  }\n  if (!Double.isNaN(lvalue)) {\n  minimum = Math.min(minimum, lvalue);\n  maximum = Math.max(maximum, lvalue);\n  }\n  if (!Double.isNaN(uvalue)) {\n  minimum = Math.min(minimum, uvalue);\n  maximum = Math.max(maximum, uvalue);\n  }\n  }\n  }\n  }\n  else if (includeInterval && dataset instanceof OHLCDataset) {\n  \n  OHLCDataset ohlc = (OHLCDataset) dataset;\n  for (int series = 0; series < seriesCount; series++) {\n  int itemCount = dataset.getItemCount(series);\n  for (int item = 0; item < itemCount; item++) {\n  double lvalue = ohlc.getLowValue(series, item);\n  double uvalue = ohlc.getHighValue(series, item);\n  if (!Double.isNaN(lvalue)) {\n  minimum = Math.min(minimum, lvalue);\n  }\n  if (!Double.isNaN(uvalue)) {\n  maximum = Math.max(maximum, uvalue);\n  }\n  }\n  }\n  }\n  else {\n  \n  for (int series = 0; series < seriesCount; series++) {\n  int itemCount = dataset.getItemCount(series);\n  for (int item = 0; item < itemCount; item++) {\n  double value = dataset.getYValue(series, item);\n  if (!Double.isNaN(value)) {\n  minimum = Math.min(minimum, value);\n  maximum = Math.max(maximum, value);\n  }\n  }\n  }\n  }\n  if (minimum == Double.POSITIVE_INFINITY) {\n  return null;\n  }\n  else {\n  return new Range(minimum, maximum);\n  }\n  }",
          "diff": [
            "@@ -1239,12 +1246,19 @@",
            "             for (int series = 0; series < seriesCount; series++) {\n",
            "                 int itemCount = dataset.getItemCount(series);\n",
            "                 for (int item = 0; item < itemCount; item++) {\n",
            "+                    double value = ixyd.getYValue(series, item);\n",
            "                     double lvalue = ixyd.getStartYValue(series, item);\n",
            "                     double uvalue = ixyd.getEndYValue(series, item);\n",
            "+                    if (!Double.isNaN(value)) {\n",
            "+                        minimum = Math.min(minimum, value);\n",
            "+                        maximum = Math.max(maximum, value);\n",
            "+                    }\n",
            "                     if (!Double.isNaN(lvalue)) {\n",
            "                         minimum = Math.min(minimum, lvalue);\n",
            "+                        maximum = Math.max(maximum, lvalue);\n",
            "                     }\n",
            "                     if (!Double.isNaN(uvalue)) {\n",
            "+                        minimum = Math.min(minimum, uvalue);\n",
            "                         maximum = Math.max(maximum, uvalue);\n",
            "                     }\n",
            "                 }\n"
          ],
          "changed_lines": 7
        }
      ]
    }
  ]
}