{
  "bug_id": "3",
  "failed_tests": {
    "com.fasterxml.jackson.databind.deser.TestArrayDeserialization": [
      {
        "methodName": "testStringArray",
        "error": "java.lang.NullPointerException",
        "message": "",
        "fail_line": "        result = MAPPER.readValue(\" [ null ]\", String[].class);",
        "test_source": "  public void testStringArray() throws Exception {\n  final String[] STRS = new String[] {\n  \"a\", \"b\", \"abcd\", \"\", \"???\", \"\\\"quoted\\\"\", \"lf: \\n\",\n  };\n  StringWriter sw = new StringWriter();\n  JsonGenerator jg = MAPPER.getFactory().createGenerator(sw);\n  jg.writeStartArray();\n  for (String str : STRS) {\n  jg.writeString(str);\n  }\n  jg.writeEndArray();\n  jg.close();\n\n  String[] result = MAPPER.readValue(sw.toString(), String[].class);\n  assertNotNull(result);\n\n  assertEquals(STRS.length, result.length);\n  for (int i = 0; i < STRS.length; ++i) {\n  assertEquals(STRS[i], result[i]);\n  }\n\n  // [#479]: null handling was busted in 2.4.0\n  result = MAPPER.readValue(\" [ null ]\", String[].class);\n  assertNotNull(result);\n  assertEquals(1, result.length);\n  assertNull(result[0]);\n  }",
        "stack": [
          "StringArrayDeserializer.deserialize line 66, StringArrayDeserializer.deserialize line 18, ObjectMapper._readMapAndClose line 3051, ObjectMapper.readValue line 2146, TestArrayDeserialization.testStringArray line 266"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java",
      "buggy_full_code": "package com.fasterxml.jackson.databind.deser.std;\n\nimport java.io.IOException;\n\nimport com.fasterxml.jackson.core.*;\n\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\nimport com.fasterxml.jackson.databind.deser.ContextualDeserializer;\nimport com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\nimport com.fasterxml.jackson.databind.util.ObjectBuffer;\n\n\n@JacksonStdImpl\npublic final class StringArrayDeserializer extends StdDeserializer<String[]> implements ContextualDeserializer { private static final long serialVersionUID = -7589512013334920693L; public final static StringArrayDeserializer instance = new StringArrayDeserializer(); protected JsonDeserializer<String> _elementDeserializer; public StringArrayDeserializer() {\n        super(String[].class);\n        _elementDeserializer = null;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    protected StringArrayDeserializer(JsonDeserializer<?> deser) {\n        super(String[].class);\n        _elementDeserializer = (JsonDeserializer<String>) deser;\n    }\n   \n    @Override\n    public String[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {\n        \n        if (!jp.isExpectedStartArrayToken()) {\n            return handleNonArray(jp, ctxt);\n        }\n        if (_elementDeserializer != null) {\n            return _deserializeCustom(jp, ctxt);\n        }\n\n        final ObjectBuffer buffer = ctxt.leaseObjectBuffer();\n        Object[] chunk = buffer.resetAndStart();\n        \n        int ix = 0;\n        JsonToken t;\n        \n        while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {\n            \n            String value;\n            if (t == JsonToken.VALUE_STRING) {\n                value = jp.getText();\n            } else if (t == JsonToken.VALUE_NULL) {\n                value = _elementDeserializer.getNullValue();\n            } else {\n                value = _parseString(jp, ctxt);\n            }\n            if (ix >= chunk.length) {\n                chunk = buffer.appendCompletedChunk(chunk);\n                ix = 0;\n            }\n            chunk[ix++] = value;\n        }\n        String[] result = buffer.completeAndClearBuffer(chunk, ix, String.class);\n        ctxt.returnObjectBuffer(buffer);\n        return result;\n    }\n\n    \n    protected final String[] _deserializeCustom(JsonParser jp, DeserializationContext ctxt) throws IOException {\n        final ObjectBuffer buffer = ctxt.leaseObjectBuffer();\n        Object[] chunk = buffer.resetAndStart();\n        final JsonDeserializer<String> deser = _elementDeserializer;\n        \n        int ix = 0;\n        JsonToken t;\n        \n        while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {\n            \n            String value = (t == JsonToken.VALUE_NULL) ? null : deser.deserialize(jp, ctxt);\n            if (ix >= chunk.length) {\n                chunk = buffer.appendCompletedChunk(chunk);\n                ix = 0;\n            }\n            chunk[ix++] = value;\n        }\n        String[] result = buffer.completeAndClearBuffer(chunk, ix, String.class);\n        ctxt.returnObjectBuffer(buffer);\n        return result;\n    }\n    \n    @Override\n    public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException {\n        return typeDeserializer.deserializeTypedFromArray(jp, ctxt);\n    }\n\n    private final String[] handleNonArray(JsonParser jp, DeserializationContext ctxt) throws IOException {\n        \n        if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) {\n            \n            if ((jp.getCurrentToken() == JsonToken.VALUE_STRING)\n                    && ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {\n                String str = jp.getText();\n                if (str.length() == 0) {\n                    return null;\n                }\n            }\n            throw ctxt.mappingException(_valueClass);\n        }\n        return new String[] { (jp.getCurrentToken() == JsonToken.VALUE_NULL) ? null : _parseString(jp, ctxt) };\n    }\n\n    \n    @Override\n    public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException {\n        JsonDeserializer<?> deser = _elementDeserializer;\n        \n        deser = findConvertingContentDeserializer(ctxt, property, deser);\n        if (deser == null) {\n            deser = ctxt.findContextualValueDeserializer(ctxt.constructType(String.class), property);\n        } else { \n            deser = ctxt.handleSecondaryContextualization(deser, property);\n        }\n        \n        if (deser != null && this.isDefaultDeserializer(deser)) {\n            deser = null;\n        }\n        if (_elementDeserializer != deser) {\n            return new StringArrayDeserializer(deser);\n        }\n        return this;\n    }\n}\n",
      "fixed_full_code": "package com.fasterxml.jackson.databind.deser.std;\n\nimport java.io.IOException;\n\nimport com.fasterxml.jackson.core.*;\n\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\nimport com.fasterxml.jackson.databind.deser.ContextualDeserializer;\nimport com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\nimport com.fasterxml.jackson.databind.util.ObjectBuffer;\n\n\n@JacksonStdImpl\npublic final class StringArrayDeserializer extends StdDeserializer<String[]> implements ContextualDeserializer { private static final long serialVersionUID = -7589512013334920693L; public final static StringArrayDeserializer instance = new StringArrayDeserializer(); protected JsonDeserializer<String> _elementDeserializer; public StringArrayDeserializer() {\n        super(String[].class);\n        _elementDeserializer = null;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    protected StringArrayDeserializer(JsonDeserializer<?> deser) {\n        super(String[].class);\n        _elementDeserializer = (JsonDeserializer<String>) deser;\n    }\n   \n    @Override\n    public String[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {\n        \n        if (!jp.isExpectedStartArrayToken()) {\n            return handleNonArray(jp, ctxt);\n        }\n        if (_elementDeserializer != null) {\n            return _deserializeCustom(jp, ctxt);\n        }\n\n        final ObjectBuffer buffer = ctxt.leaseObjectBuffer();\n        Object[] chunk = buffer.resetAndStart();\n        \n        int ix = 0;\n        JsonToken t;\n        \n        while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {\n            \n            String value;\n            if (t == JsonToken.VALUE_STRING) {\n                value = jp.getText();\n            } else if (t == JsonToken.VALUE_NULL) {\n                value = null; \n            } else {\n                value = _parseString(jp, ctxt);\n            }\n            if (ix >= chunk.length) {\n                chunk = buffer.appendCompletedChunk(chunk);\n                ix = 0;\n            }\n            chunk[ix++] = value;\n        }\n        String[] result = buffer.completeAndClearBuffer(chunk, ix, String.class);\n        ctxt.returnObjectBuffer(buffer);\n        return result;\n    }\n\n    \n    protected final String[] _deserializeCustom(JsonParser jp, DeserializationContext ctxt) throws IOException {\n        final ObjectBuffer buffer = ctxt.leaseObjectBuffer();\n        Object[] chunk = buffer.resetAndStart();\n        final JsonDeserializer<String> deser = _elementDeserializer;\n        \n        int ix = 0;\n        JsonToken t;\n        \n        while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {\n            \n            String value = (t == JsonToken.VALUE_NULL) ? deser.getNullValue() : deser.deserialize(jp, ctxt);\n            if (ix >= chunk.length) {\n                chunk = buffer.appendCompletedChunk(chunk);\n                ix = 0;\n            }\n            chunk[ix++] = value;\n        }\n        String[] result = buffer.completeAndClearBuffer(chunk, ix, String.class);\n        ctxt.returnObjectBuffer(buffer);\n        return result;\n    }\n    \n    @Override\n    public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException {\n        return typeDeserializer.deserializeTypedFromArray(jp, ctxt);\n    }\n\n    private final String[] handleNonArray(JsonParser jp, DeserializationContext ctxt) throws IOException {\n        \n        if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) {\n            \n            if ((jp.getCurrentToken() == JsonToken.VALUE_STRING)\n                    && ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {\n                String str = jp.getText();\n                if (str.length() == 0) {\n                    return null;\n                }\n            }\n            throw ctxt.mappingException(_valueClass);\n        }\n        return new String[] { (jp.getCurrentToken() == JsonToken.VALUE_NULL) ? null : _parseString(jp, ctxt) };\n    }\n\n    \n    @Override\n    public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException {\n        JsonDeserializer<?> deser = _elementDeserializer;\n        \n        deser = findConvertingContentDeserializer(ctxt, property, deser);\n        if (deser == null) {\n            deser = ctxt.findContextualValueDeserializer(ctxt.constructType(String.class), property);\n        } else { \n            deser = ctxt.handleSecondaryContextualization(deser, property);\n        }\n        \n        if (deser != null && this.isDefaultDeserializer(deser)) {\n            deser = null;\n        }\n        if (_elementDeserializer != deser) {\n            return new StringArrayDeserializer(deser);\n        }\n        return this;\n    }\n}\n",
      "buggy_signatures": [
        "protected StringArrayDeserializer(JsonDeserializer<?> deser)",
        "public String[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException",
        "protected final String[] _deserializeCustom(JsonParser jp, DeserializationContext ctxt) throws IOException",
        "public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException",
        "private final String[] handleNonArray(JsonParser jp, DeserializationContext ctxt) throws IOException",
        "public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException"
      ],
      "fixed_signatures": [
        "protected StringArrayDeserializer(JsonDeserializer<?> deser)",
        "public String[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException",
        "protected final String[] _deserializeCustom(JsonParser jp, DeserializationContext ctxt) throws IOException",
        "public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException",
        "private final String[] handleNonArray(JsonParser jp, DeserializationContext ctxt) throws IOException",
        "public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException"
      ],
      "methods": [
        {
          "buggy_method": "  public String[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {\n  \n  if (!jp.isExpectedStartArrayToken()) {\n  return handleNonArray(jp, ctxt);\n  }\n  if (_elementDeserializer != null) {\n  return _deserializeCustom(jp, ctxt);\n  }\n\n  final ObjectBuffer buffer = ctxt.leaseObjectBuffer();\n  Object[] chunk = buffer.resetAndStart();\n  \n  int ix = 0;\n  JsonToken t;\n  \n  while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {\n  \n  String value;\n  if (t == JsonToken.VALUE_STRING) {\n  value = jp.getText();\n  } else if (t == JsonToken.VALUE_NULL) {\n  value = _elementDeserializer.getNullValue();\n  } else {\n  value = _parseString(jp, ctxt);\n  }\n  if (ix >= chunk.length) {\n  chunk = buffer.appendCompletedChunk(chunk);\n  ix = 0;\n  }\n  chunk[ix++] = value;\n  }\n  String[] result = buffer.completeAndClearBuffer(chunk, ix, String.class);\n  ctxt.returnObjectBuffer(buffer);\n  return result;\n  }",
          "fixed_method": "  public String[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {\n  \n  if (!jp.isExpectedStartArrayToken()) {\n  return handleNonArray(jp, ctxt);\n  }\n  if (_elementDeserializer != null) {\n  return _deserializeCustom(jp, ctxt);\n  }\n\n  final ObjectBuffer buffer = ctxt.leaseObjectBuffer();\n  Object[] chunk = buffer.resetAndStart();\n  \n  int ix = 0;\n  JsonToken t;\n  \n  while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {\n  \n  String value;\n  if (t == JsonToken.VALUE_STRING) {\n  value = jp.getText();\n  } else if (t == JsonToken.VALUE_NULL) {\n  value = null; \n  } else {\n  value = _parseString(jp, ctxt);\n  }\n  if (ix >= chunk.length) {\n  chunk = buffer.appendCompletedChunk(chunk);\n  ix = 0;\n  }\n  chunk[ix++] = value;\n  }\n  String[] result = buffer.completeAndClearBuffer(chunk, ix, String.class);\n  ctxt.returnObjectBuffer(buffer);\n  return result;\n  }",
          "diff": [
            "@@ -63,7 +63,7 @@",
            "             if (t == JsonToken.VALUE_STRING) {\n",
            "                 value = jp.getText();\n",
            "             } else if (t == JsonToken.VALUE_NULL) {\n",
            "-                value = _elementDeserializer.getNullValue();\n",
            "+                value = null; // since we have established that '_elementDeserializer == null' earlier\n",
            "             } else {\n",
            "                 value = _parseString(jp, ctxt);\n",
            "             }\n"
          ],
          "changed_lines": 2
        },
        {
          "buggy_method": "  protected final String[] _deserializeCustom(JsonParser jp, DeserializationContext ctxt) throws IOException {\n  final ObjectBuffer buffer = ctxt.leaseObjectBuffer();\n  Object[] chunk = buffer.resetAndStart();\n  final JsonDeserializer<String> deser = _elementDeserializer;\n  \n  int ix = 0;\n  JsonToken t;\n  \n  while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {\n  \n  String value = (t == JsonToken.VALUE_NULL) ? null : deser.deserialize(jp, ctxt);\n  if (ix >= chunk.length) {\n  chunk = buffer.appendCompletedChunk(chunk);\n  ix = 0;\n  }\n  chunk[ix++] = value;\n  }\n  String[] result = buffer.completeAndClearBuffer(chunk, ix, String.class);\n  ctxt.returnObjectBuffer(buffer);\n  return result;\n  }",
          "fixed_method": "  protected final String[] _deserializeCustom(JsonParser jp, DeserializationContext ctxt) throws IOException {\n  final ObjectBuffer buffer = ctxt.leaseObjectBuffer();\n  Object[] chunk = buffer.resetAndStart();\n  final JsonDeserializer<String> deser = _elementDeserializer;\n  \n  int ix = 0;\n  JsonToken t;\n  \n  while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {\n  \n  String value = (t == JsonToken.VALUE_NULL) ? deser.getNullValue() : deser.deserialize(jp, ctxt);\n  if (ix >= chunk.length) {\n  chunk = buffer.appendCompletedChunk(chunk);\n  ix = 0;\n  }\n  chunk[ix++] = value;\n  }\n  String[] result = buffer.completeAndClearBuffer(chunk, ix, String.class);\n  ctxt.returnObjectBuffer(buffer);\n  return result;\n  }",
          "diff": [
            "@@ -92,7 +92,7 @@",
            "         \n",
            "         while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {\n",
            "             // Ok: no need to convert Strings, but must recognize nulls\n",
            "-            String value = (t == JsonToken.VALUE_NULL) ? null : deser.deserialize(jp, ctxt);\n",
            "+            String value = (t == JsonToken.VALUE_NULL) ? deser.getNullValue() : deser.deserialize(jp, ctxt);\n",
            "             if (ix >= chunk.length) {\n",
            "                 chunk = buffer.appendCompletedChunk(chunk);\n",
            "                 ix = 0;\n"
          ],
          "changed_lines": 2
        }
      ]
    }
  ]
}
