{
  "bug_id": "5",
  "failed_tests": {
    "org.apache.commons.compress.archivers.zip.Maven221MultiVolumeTest": [
      {
        "methodName": "testRead7ZipMultiVolumeArchiveForStream",
        "error": "junit.framework.AssertionFailedError",
        "message": "shouldn't be able to read from truncated entry",
        "fail_line": "\t\tfail(\"shouldn't be able to read from truncated entry\");",
        "test_source": "  public void testRead7ZipMultiVolumeArchiveForStream() throws IOException,\n\t  URISyntaxException {\n\t\n\tURL zip = getClass().getResource(\"/apache-maven-2.2.1.zip.001\");\n\tFileInputStream archive = new FileInputStream(\n\t\tnew File(new URI(zip.toString())));\n\tZipArchiveInputStream zi = null;\n\ttry {\n\t  zi = new ZipArchiveInputStream(archive,null,false);\n\t  \n\t  // these are the entries that are supposed to be processed\n\t  // correctly without any problems\n\t  for (int i = 0; i < ENTRIES.length; i++) {\n\t\tassertEquals(ENTRIES[i], zi.getNextEntry().getName());\n\t  }\n\t  \n\t  // this is the last entry that is truncated\n\t  ArchiveEntry lastEntry = zi.getNextEntry();\n\t  assertEquals(LAST_ENTRY_NAME, lastEntry.getName());\n\t  byte [] buffer = new byte [4096];\n\t  \n\t  // before the fix, we'd get 0 bytes on this read and all\n\t  // subsequent reads thus a client application might enter\n\t  // an infinite loop after the fix, we should get an\n\t  // exception\n\t  try {\n  int read = 0;\n\t\twhile ((read = zi.read(buffer)) > 0) { }\n\t\tfail(\"shouldn't be able to read from truncated entry\");\n\t  } catch (IOException e) {\n  assertEquals(\"Truncated ZIP file\", e.getMessage());\n\t  }\n\t  \n\t  // and now we get another entry, which should also yield\n\t  // an exception\n\t  try {\n\t\tzi.getNextEntry();\n\t\tfail(\"shouldn't be able to read another entry from truncated\"\n  + \" file\");\n\t  } catch (IOException e) {\n\t\t// this is to be expected\n\t  }\n\t} finally {\n\t  if (zi != null) {\n\t\tzi.close();\n\t  }\n\t}\n  }",
        "stack": [
          "Maven221MultiVolumeTest.testRead7ZipMultiVolumeArchiveForStream line 97"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java",
      "buggy_full_code": "\npackage org.apache.commons.compress.archivers.zip;\n\nimport java.io.EOFException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PushbackInputStream;\nimport java.util.zip.CRC32;\nimport java.util.zip.DataFormatException;\nimport java.util.zip.Inflater;\nimport java.util.zip.ZipException;\n\nimport org.apache.commons.compress.archivers.ArchiveEntry;\nimport org.apache.commons.compress.archivers.ArchiveInputStream;\n\n\npublic class ZipArchiveInputStream extends ArchiveInputStream {\n\n    private static final int SHORT = 2;\n    private static final int WORD = 4;\n\n    \n    private final ZipEncoding zipEncoding;\n\n    \n    private final boolean useUnicodeExtraFields;\n\n    private final InputStream in;\n\n    private final Inflater inf = new Inflater(true);\n    private final CRC32 crc = new CRC32();\n\n    private final byte[] buf = new byte[ZipArchiveOutputStream.BUFFER_SIZE];\n\n    private ZipArchiveEntry current = null;\n    private boolean closed = false;\n    private boolean hitCentralDirectory = false;\n    private int readBytesOfEntry = 0, offsetInBuffer = 0;\n    private int bytesReadFromStream = 0;\n    private int lengthOfLastRead = 0;\n    private boolean hasDataDescriptor = false;\n\n    private static final int LFH_LEN = 30;\n    \n\n    public ZipArchiveInputStream(InputStream inputStream) {\n        this(inputStream, ZipEncodingHelper.UTF8, true);\n    }\n\n    \n    public ZipArchiveInputStream(InputStream inputStream,\n                                 String encoding,\n                                 boolean useUnicodeExtraFields) {\n        zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n        this.useUnicodeExtraFields = useUnicodeExtraFields;\n        in = new PushbackInputStream(inputStream, buf.length);\n    }\n\n    public ZipArchiveEntry getNextZipEntry() throws IOException {\n        if (closed || hitCentralDirectory) {\n            return null;\n        }\n        if (current != null) {\n            closeEntry();\n        }\n        byte[] lfh = new byte[LFH_LEN];\n        try {\n            readFully(lfh);\n        } catch (EOFException e) {\n            return null;\n        }\n        ZipLong sig = new ZipLong(lfh);\n        if (sig.equals(ZipLong.CFH_SIG)) {\n            hitCentralDirectory = true;\n            return null;\n        }\n        if (!sig.equals(ZipLong.LFH_SIG)) {\n            return null;\n        }\n\n        int off = WORD;\n        current = new ZipArchiveEntry();\n\n        int versionMadeBy = ZipShort.getValue(lfh, off);\n        off += SHORT;\n        current.setPlatform((versionMadeBy >> ZipFile.BYTE_SHIFT)\n                            & ZipFile.NIBLET_MASK);\n\n        final int generalPurposeFlag = ZipShort.getValue(lfh, off);\n        final boolean hasEFS = \n            (generalPurposeFlag & ZipArchiveOutputStream.EFS_FLAG) != 0;\n        final ZipEncoding entryEncoding =\n            hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n        hasDataDescriptor = (generalPurposeFlag & 8) != 0;\n\n        off += SHORT;\n\n        current.setMethod(ZipShort.getValue(lfh, off));\n        off += SHORT;\n\n        long time = ZipUtil.dosToJavaTime(ZipLong.getValue(lfh, off));\n        current.setTime(time);\n        off += WORD;\n\n        if (!hasDataDescriptor) {\n            current.setCrc(ZipLong.getValue(lfh, off));\n            off += WORD;\n\n            current.setCompressedSize(ZipLong.getValue(lfh, off));\n            off += WORD;\n\n            current.setSize(ZipLong.getValue(lfh, off));\n            off += WORD;\n        } else {\n            off += 3 * WORD;\n        }\n\n        int fileNameLen = ZipShort.getValue(lfh, off);\n\n        off += SHORT;\n\n        int extraLen = ZipShort.getValue(lfh, off);\n        off += SHORT;\n\n        byte[] fileName = new byte[fileNameLen];\n        readFully(fileName);\n        current.setName(entryEncoding.decode(fileName));\n\n        byte[] extraData = new byte[extraLen];\n        readFully(extraData);\n        current.setExtra(extraData);\n\n        if (!hasEFS && useUnicodeExtraFields) {\n            ZipUtil.setNameAndCommentFromExtraFields(current, fileName, null);\n        }\n        return current;\n    }\n\n    public ArchiveEntry getNextEntry() throws IOException {\n        return getNextZipEntry();\n    }\n\n    public int read(byte[] buffer, int start, int length) throws IOException {\n        if (closed) {\n            throw new IOException(\"The stream is closed\");\n        }\n        if (inf.finished() || current == null) {\n            return -1;\n        }\n\n        \n        if (start <= buffer.length && length >= 0 && start >= 0\n            && buffer.length - start >= length) {\n            if (current.getMethod() == ZipArchiveOutputStream.STORED) {\n                int csize = (int) current.getSize();\n                if (readBytesOfEntry >= csize) {\n                    return -1;\n                }\n                if (offsetInBuffer >= lengthOfLastRead) {\n                    offsetInBuffer = 0;\n                    if ((lengthOfLastRead = in.read(buf)) == -1) {\n                        return -1;\n                    }\n                    count(lengthOfLastRead);\n                    bytesReadFromStream += lengthOfLastRead;\n                }\n                int toRead = length > lengthOfLastRead\n                    ? lengthOfLastRead - offsetInBuffer\n                    : length;\n                if ((csize - readBytesOfEntry) < toRead) {\n                    toRead = csize - readBytesOfEntry;\n                }\n                System.arraycopy(buf, offsetInBuffer, buffer, start, toRead);\n                offsetInBuffer += toRead;\n                readBytesOfEntry += toRead;\n                crc.update(buffer, start, toRead);\n                return toRead;\n            }\n            if (inf.needsInput()) {\n                fill();\n                if (lengthOfLastRead > 0) {\n                    bytesReadFromStream += lengthOfLastRead;\n                }\n            }\n            int read = 0;\n            try {\n                read = inf.inflate(buffer, start, length);\n            } catch (DataFormatException e) {\n                throw new ZipException(e.getMessage());\n            }\n            if (read == 0 && inf.finished()) {\n                return -1;\n            }\n            crc.update(buffer, start, read);\n            return read;\n        }\n        throw new ArrayIndexOutOfBoundsException();\n    }\n\n    public void close() throws IOException {\n        if (!closed) {\n            closed = true;\n            in.close();\n        }\n    }\n\n    public long skip(long value) throws IOException {\n        if (value >= 0) {\n            long skipped = 0;\n            byte[] b = new byte[1024];\n            while (skipped != value) {\n                long rem = value - skipped;\n                int x = read(b, 0, (int) (b.length > rem ? rem : b.length));\n                if (x == -1) {\n                    return skipped;\n                }\n                skipped += x;\n            }\n            return skipped;\n        }\n        throw new IllegalArgumentException();\n    }\n\n    \n    public static boolean matches(byte[] signature, int length) {\n        if (length < ZipArchiveOutputStream.LFH_SIG.length) {\n            return false;\n        }\n\n        return checksig(signature, ZipArchiveOutputStream.LFH_SIG) \n            || checksig(signature, ZipArchiveOutputStream.EOCD_SIG); \n    }\n\n    private static boolean checksig(byte[] signature, byte[] expected){\n        for (int i = 0; i < expected.length; i++) {\n            if (signature[i] != expected[i]) {\n                return false;\n            }\n        }\n        return true;        \n    }\n\n    private void closeEntry() throws IOException {\n        if (closed) {\n            throw new IOException(\"The stream is closed\");\n        }\n        if (current == null) {\n            return;\n        }\n        \n        skip(Long.MAX_VALUE);\n        int inB;\n        if (current.getMethod() == ZipArchiveOutputStream.DEFLATED) {\n            inB = inf.getTotalIn();\n        } else {\n            inB = readBytesOfEntry;\n        }\n        int diff = 0;\n\n        \n        if ((diff = bytesReadFromStream - inB) != 0) {\n            ((PushbackInputStream) in).unread(buf,\n                                              lengthOfLastRead - diff, diff);\n        }\n\n        if (hasDataDescriptor) {\n            readFully(new byte[4 * WORD]);\n        }\n\n        inf.reset();\n        readBytesOfEntry = offsetInBuffer = bytesReadFromStream =\n            lengthOfLastRead = 0;\n        crc.reset();\n        current = null;\n    }\n\n    private void fill() throws IOException {\n        if (closed) {\n            throw new IOException(\"The stream is closed\");\n        }\n        if ((lengthOfLastRead = in.read(buf)) > 0) {\n            inf.setInput(buf, 0, lengthOfLastRead);\n        }\n    }\n\n    private void readFully(byte[] b) throws IOException {\n        int count = 0, x = 0;\n        while (count != b.length) {\n            count += x = in.read(b, count, b.length - count);\n            if (x == -1) {\n                throw new EOFException();\n            }\n        }\n    }\n}\n",
      "fixed_full_code": "\npackage org.apache.commons.compress.archivers.zip;\n\nimport java.io.EOFException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PushbackInputStream;\nimport java.util.zip.CRC32;\nimport java.util.zip.DataFormatException;\nimport java.util.zip.Inflater;\nimport java.util.zip.ZipException;\n\nimport org.apache.commons.compress.archivers.ArchiveEntry;\nimport org.apache.commons.compress.archivers.ArchiveInputStream;\n\n\npublic class ZipArchiveInputStream extends ArchiveInputStream {\n\n    private static final int SHORT = 2;\n    private static final int WORD = 4;\n\n    \n    private final ZipEncoding zipEncoding;\n\n    \n    private final boolean useUnicodeExtraFields;\n\n    private final InputStream in;\n\n    private final Inflater inf = new Inflater(true);\n    private final CRC32 crc = new CRC32();\n\n    private final byte[] buf = new byte[ZipArchiveOutputStream.BUFFER_SIZE];\n\n    private ZipArchiveEntry current = null;\n    private boolean closed = false;\n    private boolean hitCentralDirectory = false;\n    private int readBytesOfEntry = 0, offsetInBuffer = 0;\n    private int bytesReadFromStream = 0;\n    private int lengthOfLastRead = 0;\n    private boolean hasDataDescriptor = false;\n\n    private static final int LFH_LEN = 30;\n    \n\n    public ZipArchiveInputStream(InputStream inputStream) {\n        this(inputStream, ZipEncodingHelper.UTF8, true);\n    }\n\n    \n    public ZipArchiveInputStream(InputStream inputStream,\n                                 String encoding,\n                                 boolean useUnicodeExtraFields) {\n        zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n        this.useUnicodeExtraFields = useUnicodeExtraFields;\n        in = new PushbackInputStream(inputStream, buf.length);\n    }\n\n    public ZipArchiveEntry getNextZipEntry() throws IOException {\n        if (closed || hitCentralDirectory) {\n            return null;\n        }\n        if (current != null) {\n            closeEntry();\n        }\n        byte[] lfh = new byte[LFH_LEN];\n        try {\n            readFully(lfh);\n        } catch (EOFException e) {\n            return null;\n        }\n        ZipLong sig = new ZipLong(lfh);\n        if (sig.equals(ZipLong.CFH_SIG)) {\n            hitCentralDirectory = true;\n            return null;\n        }\n        if (!sig.equals(ZipLong.LFH_SIG)) {\n            return null;\n        }\n\n        int off = WORD;\n        current = new ZipArchiveEntry();\n\n        int versionMadeBy = ZipShort.getValue(lfh, off);\n        off += SHORT;\n        current.setPlatform((versionMadeBy >> ZipFile.BYTE_SHIFT)\n                            & ZipFile.NIBLET_MASK);\n\n        final int generalPurposeFlag = ZipShort.getValue(lfh, off);\n        final boolean hasEFS = \n            (generalPurposeFlag & ZipArchiveOutputStream.EFS_FLAG) != 0;\n        final ZipEncoding entryEncoding =\n            hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n        hasDataDescriptor = (generalPurposeFlag & 8) != 0;\n\n        off += SHORT;\n\n        current.setMethod(ZipShort.getValue(lfh, off));\n        off += SHORT;\n\n        long time = ZipUtil.dosToJavaTime(ZipLong.getValue(lfh, off));\n        current.setTime(time);\n        off += WORD;\n\n        if (!hasDataDescriptor) {\n            current.setCrc(ZipLong.getValue(lfh, off));\n            off += WORD;\n\n            current.setCompressedSize(ZipLong.getValue(lfh, off));\n            off += WORD;\n\n            current.setSize(ZipLong.getValue(lfh, off));\n            off += WORD;\n        } else {\n            off += 3 * WORD;\n        }\n\n        int fileNameLen = ZipShort.getValue(lfh, off);\n\n        off += SHORT;\n\n        int extraLen = ZipShort.getValue(lfh, off);\n        off += SHORT;\n\n        byte[] fileName = new byte[fileNameLen];\n        readFully(fileName);\n        current.setName(entryEncoding.decode(fileName));\n\n        byte[] extraData = new byte[extraLen];\n        readFully(extraData);\n        current.setExtra(extraData);\n\n        if (!hasEFS && useUnicodeExtraFields) {\n            ZipUtil.setNameAndCommentFromExtraFields(current, fileName, null);\n        }\n        return current;\n    }\n\n    public ArchiveEntry getNextEntry() throws IOException {\n        return getNextZipEntry();\n    }\n\n    public int read(byte[] buffer, int start, int length) throws IOException {\n        if (closed) {\n            throw new IOException(\"The stream is closed\");\n        }\n        if (inf.finished() || current == null) {\n            return -1;\n        }\n\n        \n        if (start <= buffer.length && length >= 0 && start >= 0\n            && buffer.length - start >= length) {\n            if (current.getMethod() == ZipArchiveOutputStream.STORED) {\n                int csize = (int) current.getSize();\n                if (readBytesOfEntry >= csize) {\n                    return -1;\n                }\n                if (offsetInBuffer >= lengthOfLastRead) {\n                    offsetInBuffer = 0;\n                    if ((lengthOfLastRead = in.read(buf)) == -1) {\n                        return -1;\n                    }\n                    count(lengthOfLastRead);\n                    bytesReadFromStream += lengthOfLastRead;\n                }\n                int toRead = length > lengthOfLastRead\n                    ? lengthOfLastRead - offsetInBuffer\n                    : length;\n                if ((csize - readBytesOfEntry) < toRead) {\n                    toRead = csize - readBytesOfEntry;\n                }\n                System.arraycopy(buf, offsetInBuffer, buffer, start, toRead);\n                offsetInBuffer += toRead;\n                readBytesOfEntry += toRead;\n                crc.update(buffer, start, toRead);\n                return toRead;\n            }\n            if (inf.needsInput()) {\n                fill();\n                if (lengthOfLastRead > 0) {\n                    bytesReadFromStream += lengthOfLastRead;\n                }\n            }\n            int read = 0;\n            try {\n                read = inf.inflate(buffer, start, length);\n            } catch (DataFormatException e) {\n                throw new ZipException(e.getMessage());\n            }\n            if (read == 0) {\n                if (inf.finished()) {\n                    return -1;\n                } else if (lengthOfLastRead == -1) {\n                    throw new IOException(\"Truncated ZIP file\");\n                }\n            }\n            crc.update(buffer, start, read);\n            return read;\n        }\n        throw new ArrayIndexOutOfBoundsException();\n    }\n\n    public void close() throws IOException {\n        if (!closed) {\n            closed = true;\n            in.close();\n        }\n    }\n\n    public long skip(long value) throws IOException {\n        if (value >= 0) {\n            long skipped = 0;\n            byte[] b = new byte[1024];\n            while (skipped != value) {\n                long rem = value - skipped;\n                int x = read(b, 0, (int) (b.length > rem ? rem : b.length));\n                if (x == -1) {\n                    return skipped;\n                }\n                skipped += x;\n            }\n            return skipped;\n        }\n        throw new IllegalArgumentException();\n    }\n\n    \n    public static boolean matches(byte[] signature, int length) {\n        if (length < ZipArchiveOutputStream.LFH_SIG.length) {\n            return false;\n        }\n\n        return checksig(signature, ZipArchiveOutputStream.LFH_SIG) \n            || checksig(signature, ZipArchiveOutputStream.EOCD_SIG); \n    }\n\n    private static boolean checksig(byte[] signature, byte[] expected){\n        for (int i = 0; i < expected.length; i++) {\n            if (signature[i] != expected[i]) {\n                return false;\n            }\n        }\n        return true;        \n    }\n\n    private void closeEntry() throws IOException {\n        if (closed) {\n            throw new IOException(\"The stream is closed\");\n        }\n        if (current == null) {\n            return;\n        }\n        \n        skip(Long.MAX_VALUE);\n        int inB;\n        if (current.getMethod() == ZipArchiveOutputStream.DEFLATED) {\n            inB = inf.getTotalIn();\n        } else {\n            inB = readBytesOfEntry;\n        }\n        int diff = 0;\n\n        \n        if ((diff = bytesReadFromStream - inB) != 0) {\n            ((PushbackInputStream) in).unread(buf,\n                                              lengthOfLastRead - diff, diff);\n        }\n\n        if (hasDataDescriptor) {\n            readFully(new byte[4 * WORD]);\n        }\n\n        inf.reset();\n        readBytesOfEntry = offsetInBuffer = bytesReadFromStream =\n            lengthOfLastRead = 0;\n        crc.reset();\n        current = null;\n    }\n\n    private void fill() throws IOException {\n        if (closed) {\n            throw new IOException(\"The stream is closed\");\n        }\n        if ((lengthOfLastRead = in.read(buf)) > 0) {\n            inf.setInput(buf, 0, lengthOfLastRead);\n        }\n    }\n\n    private void readFully(byte[] b) throws IOException {\n        int count = 0, x = 0;\n        while (count != b.length) {\n            count += x = in.read(b, count, b.length - count);\n            if (x == -1) {\n                throw new EOFException();\n            }\n        }\n    }\n}\n",
      "buggy_signatures": [
        "private final Inflater inf = new Inflater(true)",
        "private final CRC32 crc = new CRC32()",
        "public ZipArchiveInputStream(InputStream inputStream)",
        "public ZipArchiveInputStream(InputStream inputStream, String encoding, boolean useUnicodeExtraFields)",
        "public ZipArchiveEntry getNextZipEntry() throws IOException",
        "public ArchiveEntry getNextEntry() throws IOException",
        "public int read(byte[] buffer, int start, int length) throws IOException",
        "public void close() throws IOException",
        "public long skip(long value) throws IOException",
        "public static boolean matches(byte[] signature, int length)",
        "private static boolean checksig(byte[] signature, byte[] expected)",
        "private void closeEntry() throws IOException",
        "private void fill() throws IOException",
        "private void readFully(byte[] b) throws IOException"
      ],
      "fixed_signatures": [
        "private final Inflater inf = new Inflater(true)",
        "private final CRC32 crc = new CRC32()",
        "public ZipArchiveInputStream(InputStream inputStream)",
        "public ZipArchiveInputStream(InputStream inputStream, String encoding, boolean useUnicodeExtraFields)",
        "public ZipArchiveEntry getNextZipEntry() throws IOException",
        "public ArchiveEntry getNextEntry() throws IOException",
        "public int read(byte[] buffer, int start, int length) throws IOException",
        "public void close() throws IOException",
        "public long skip(long value) throws IOException",
        "public static boolean matches(byte[] signature, int length)",
        "private static boolean checksig(byte[] signature, byte[] expected)",
        "private void closeEntry() throws IOException",
        "private void fill() throws IOException",
        "private void readFully(byte[] b) throws IOException"
      ],
      "methods": [
        {
          "buggy_method": "  public int read(byte[] buffer, int start, int length) throws IOException {\n  if (closed) {\n  throw new IOException(\"The stream is closed\");\n  }\n  if (inf.finished() || current == null) {\n  return -1;\n  }\n\n  \n  if (start <= buffer.length && length >= 0 && start >= 0\n  && buffer.length - start >= length) {\n  if (current.getMethod() == ZipArchiveOutputStream.STORED) {\n  int csize = (int) current.getSize();\n  if (readBytesOfEntry >= csize) {\n  return -1;\n  }\n  if (offsetInBuffer >= lengthOfLastRead) {\n  offsetInBuffer = 0;\n  if ((lengthOfLastRead = in.read(buf)) == -1) {\n  return -1;\n  }\n  count(lengthOfLastRead);\n  bytesReadFromStream += lengthOfLastRead;\n  }\n  int toRead = length > lengthOfLastRead\n  ? lengthOfLastRead - offsetInBuffer\n  : length;\n  if ((csize - readBytesOfEntry) < toRead) {\n  toRead = csize - readBytesOfEntry;\n  }\n  System.arraycopy(buf, offsetInBuffer, buffer, start, toRead);\n  offsetInBuffer += toRead;\n  readBytesOfEntry += toRead;\n  crc.update(buffer, start, toRead);\n  return toRead;\n  }\n  if (inf.needsInput()) {\n  fill();\n  if (lengthOfLastRead > 0) {\n  bytesReadFromStream += lengthOfLastRead;\n  }\n  }\n  int read = 0;\n  try {\n  read = inf.inflate(buffer, start, length);\n  } catch (DataFormatException e) {\n  throw new ZipException(e.getMessage());\n  }\n  if (read == 0 && inf.finished()) {\n  return -1;\n  }\n  crc.update(buffer, start, read);\n  return read;\n  }\n  throw new ArrayIndexOutOfBoundsException();\n  }",
          "fixed_method": "  public int read(byte[] buffer, int start, int length) throws IOException {\n  if (closed) {\n  throw new IOException(\"The stream is closed\");\n  }\n  if (inf.finished() || current == null) {\n  return -1;\n  }\n\n  \n  if (start <= buffer.length && length >= 0 && start >= 0\n  && buffer.length - start >= length) {\n  if (current.getMethod() == ZipArchiveOutputStream.STORED) {\n  int csize = (int) current.getSize();\n  if (readBytesOfEntry >= csize) {\n  return -1;\n  }\n  if (offsetInBuffer >= lengthOfLastRead) {\n  offsetInBuffer = 0;\n  if ((lengthOfLastRead = in.read(buf)) == -1) {\n  return -1;\n  }\n  count(lengthOfLastRead);\n  bytesReadFromStream += lengthOfLastRead;\n  }\n  int toRead = length > lengthOfLastRead\n  ? lengthOfLastRead - offsetInBuffer\n  : length;\n  if ((csize - readBytesOfEntry) < toRead) {\n  toRead = csize - readBytesOfEntry;\n  }\n  System.arraycopy(buf, offsetInBuffer, buffer, start, toRead);\n  offsetInBuffer += toRead;\n  readBytesOfEntry += toRead;\n  crc.update(buffer, start, toRead);\n  return toRead;\n  }\n  if (inf.needsInput()) {\n  fill();\n  if (lengthOfLastRead > 0) {\n  bytesReadFromStream += lengthOfLastRead;\n  }\n  }\n  int read = 0;\n  try {\n  read = inf.inflate(buffer, start, length);\n  } catch (DataFormatException e) {\n  throw new ZipException(e.getMessage());\n  }\n  if (read == 0) {\n  if (inf.finished()) {\n  return -1;\n  } else if (lengthOfLastRead == -1) {\n  throw new IOException(\"Truncated ZIP file\");\n  }\n  }\n  crc.update(buffer, start, read);\n  return read;\n  }\n  throw new ArrayIndexOutOfBoundsException();\n  }",
          "diff": [
            "@@ -236,8 +236,12 @@",
            "             } catch (DataFormatException e) {\n",
            "                 throw new ZipException(e.getMessage());\n",
            "             }\n",
            "-            if (read == 0 && inf.finished()) {\n",
            "-                return -1;\n",
            "+            if (read == 0) {\n",
            "+                if (inf.finished()) {\n",
            "+                    return -1;\n",
            "+                } else if (lengthOfLastRead == -1) {\n",
            "+                    throw new IOException(\"Truncated ZIP file\");\n",
            "+                }\n",
            "             }\n",
            "             crc.update(buffer, start, read);\n",
            "             return read;\n"
          ],
          "changed_lines": 8
        }
      ]
    }
  ]
}