{
  "bug_id": "5",
  "failed_tests": {
    "com.fasterxml.jackson.databind.introspect.TestMixinMerging": [
      {
        "methodName": "testDisappearingMixins515",
        "error": "com.fasterxml.jackson.databind.JsonMappingException",
        "message": "No serializer found for class com.fasterxml.jackson.databind.introspect.TestMixinMerging$PersonImpl and no properties discovered to create BeanSerializer (to avoid exception, disable SerializationFeature.FAIL_ON_EMPTY_BEANS) )",
        "fail_line": "        assertEquals(\"{\\\"city\\\":\\\"Seattle\\\"}\", mapper.writeValueAsString(new PersonImpl()));",
        "test_source": "  public void testDisappearingMixins515() throws Exception {\n  ObjectMapper mapper = new ObjectMapper();\n  mapper.disable(MapperFeature.ALLOW_FINAL_FIELDS_AS_MUTATORS)\n  .disable(MapperFeature.AUTO_DETECT_FIELDS)\n  .disable(MapperFeature.AUTO_DETECT_GETTERS)\n  .disable(MapperFeature.AUTO_DETECT_IS_GETTERS)\n  .disable(MapperFeature.INFER_PROPERTY_MUTATORS);\n  SimpleModule module = new SimpleModule(\"Test\");\n  module.setMixInAnnotation(Person.class, PersonMixin.class);  \n  mapper.registerModule(module);\n\n  assertEquals(\"{\\\"city\\\":\\\"Seattle\\\"}\", mapper.writeValueAsString(new PersonImpl()));\n  }",
        "stack": [
          "UnknownSerializer.failForEmpty line 59, UnknownSerializer.serialize line 26, DefaultSerializerProvider.serializeValue line 114, ObjectMapper._configAndWriteValue line 2866, ObjectMapper.writeValueAsString line 2323, TestMixinMerging.testDisappearingMixins515 line 48"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "com/fasterxml/jackson/databind/introspect/AnnotatedClass.java",
      "buggy_full_code": "package com.fasterxml.jackson.databind.introspect;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.*;\nimport java.util.*;\n\nimport com.fasterxml.jackson.databind.AnnotationIntrospector;\nimport com.fasterxml.jackson.databind.introspect.ClassIntrospector.MixInResolver;\nimport com.fasterxml.jackson.databind.util.Annotations;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\n\npublic final class AnnotatedClass extends Annotated { private final static AnnotationMap[] NO_ANNOTATION_MAPS = new AnnotationMap[0]; final protected Class<?> _class; final protected List<Class<?>> _superTypes; final protected AnnotationIntrospector _annotationIntrospector; final protected MixInResolver _mixInResolver; final protected Class<?> _primaryMixIn; protected AnnotationMap _classAnnotations; protected boolean _creatorsResolved = false; protected AnnotatedConstructor _defaultConstructor; protected List<AnnotatedConstructor> _constructors; protected List<AnnotatedMethod> _creatorMethods; protected AnnotatedMethodMap _memberMethods; protected List<AnnotatedField> _fields; private AnnotatedClass(Class<?> cls, List<Class<?>> superTypes, AnnotationIntrospector aintr, MixInResolver mir, AnnotationMap classAnnotations) {\n        _class = cls;\n        _superTypes = superTypes;\n        _annotationIntrospector = aintr;\n        _mixInResolver = mir;\n        _primaryMixIn = (_mixInResolver == null) ? null\n            : _mixInResolver.findMixInClassFor(_class);\n        _classAnnotations = classAnnotations;\n    }\n\n    @Override\n    public AnnotatedClass withAnnotations(AnnotationMap ann) {\n        return new AnnotatedClass(_class, _superTypes,\n                _annotationIntrospector, _mixInResolver, ann);\n    }\n    \n    \n    public static AnnotatedClass construct(Class<?> cls, AnnotationIntrospector aintr, MixInResolver mir) {\n        return new AnnotatedClass(cls,\n                ClassUtil.findSuperTypes(cls, null), aintr, mir, null);\n    }\n\n    \n    public static AnnotatedClass constructWithoutSuperTypes(Class<?> cls, AnnotationIntrospector aintr, MixInResolver mir) {\n        return new AnnotatedClass(cls,\n                Collections.<Class<?>>emptyList(), aintr, mir, null);\n    }\n    \n    \n\n    @Override\n    public Class<?> getAnnotated() { return _class; }\n\n    @Override\n    public int getModifiers() { return _class.getModifiers(); }\n\n    @Override\n    public String getName() { return _class.getName(); }\n\n    @Override\n    public <A extends Annotation> A getAnnotation(Class<A> acls) {\n        if (_classAnnotations == null) {\n            resolveClassAnnotations();\n        }\n        return _classAnnotations.get(acls);\n    }\n\n    @Override\n    public Type getGenericType() {\n        return _class;\n    }\n\n    @Override\n    public Class<?> getRawType() {\n        return _class;\n    }\n\n    @Override\n    public Iterable<Annotation> annotations() {\n        if (_classAnnotations == null) {\n            resolveClassAnnotations();\n        }\n        return _classAnnotations.annotations();\n    }\n    \n    @Override\n    protected AnnotationMap getAllAnnotations() {\n        if (_classAnnotations == null) {\n            resolveClassAnnotations();\n        }\n        return _classAnnotations;\n    }\n    \n    \n\n    public Annotations getAnnotations() {\n        if (_classAnnotations == null) {\n            resolveClassAnnotations();\n        }\n        return _classAnnotations;\n    }\n    \n    public boolean hasAnnotations() {\n        if (_classAnnotations == null) {\n            resolveClassAnnotations();\n        }\n        return _classAnnotations.size() > 0;\n    }\n\n    public AnnotatedConstructor getDefaultConstructor() {\n        if (!_creatorsResolved) {\n            resolveCreators();\n        }\n        return _defaultConstructor;\n    }\n\n    public List<AnnotatedConstructor> getConstructors() {\n        if (!_creatorsResolved) {\n            resolveCreators();\n        }\n        return _constructors;\n    }\n\n    public List<AnnotatedMethod> getStaticMethods() {\n        if (!_creatorsResolved) {\n            resolveCreators();\n        }\n        return _creatorMethods;\n    }\n\n    public Iterable<AnnotatedMethod> memberMethods() {\n        if (_memberMethods == null) {\n            resolveMemberMethods();\n        }\n        return _memberMethods;\n    }\n\n    public int getMemberMethodCount() {\n        if (_memberMethods == null) {\n            resolveMemberMethods();\n        }\n        return _memberMethods.size();\n    }\n\n    public AnnotatedMethod findMethod(String name, Class<?>[] paramTypes) {\n        if (_memberMethods == null) {\n            resolveMemberMethods();\n        }\n        return _memberMethods.find(name, paramTypes);\n    }\n\n    public int getFieldCount() {\n        if (_fields == null) {\n            resolveFields();\n        }\n        return _fields.size();\n    }\n\n    public Iterable<AnnotatedField> fields() {\n        if (_fields == null) {\n            resolveFields();\n        }\n        return _fields;\n    }\n\n    \n\n    \n    private void resolveClassAnnotations() {\n        _classAnnotations = new AnnotationMap();\n        \n        if (_annotationIntrospector != null) {\n            \n            if (_primaryMixIn != null) {\n                _addClassMixIns(_classAnnotations, _class, _primaryMixIn);\n            }\n            \n            _addAnnotationsIfNotPresent(_classAnnotations, _class.getDeclaredAnnotations());\n    \n            \n            for (Class<?> cls : _superTypes) {\n                \n                _addClassMixIns(_classAnnotations, cls);\n                _addAnnotationsIfNotPresent(_classAnnotations, cls.getDeclaredAnnotations());\n            }\n            \n            \n            _addClassMixIns(_classAnnotations, Object.class);\n        }\n    }\n    \n    \n    private void resolveCreators() {\n        \n        List<AnnotatedConstructor> constructors = null;\n        Constructor<?>[] declaredCtors = _class.getDeclaredConstructors();\n        for (Constructor<?> ctor : declaredCtors) {\n            if (ctor.getParameterTypes().length == 0) {\n                _defaultConstructor = _constructConstructor(ctor, true);\n            } else {\n                if (constructors == null) {\n                    constructors = new ArrayList<AnnotatedConstructor>(Math.max(10, declaredCtors.length));\n                }\n                constructors.add(_constructConstructor(ctor, false));\n            }\n        }\n        if (constructors == null) {\n            _constructors = Collections.emptyList();\n        } else {\n            _constructors = constructors;\n        }\n        \n        if (_primaryMixIn != null) {\n            if (_defaultConstructor != null || !_constructors.isEmpty()) {\n                _addConstructorMixIns(_primaryMixIn);\n            }\n        }\n\n\n        \n        \n        if (_annotationIntrospector != null) {\n            if (_defaultConstructor != null) {\n                if (_annotationIntrospector.hasIgnoreMarker(_defaultConstructor)) {\n                    _defaultConstructor = null;\n                }\n            }\n            if (_constructors != null) {\n                \n                for (int i = _constructors.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_constructors.get(i))) {\n                        _constructors.remove(i);\n                    }\n                }\n            }\n        }\n        List<AnnotatedMethod> creatorMethods = null;\n        \n        \n        for (Method m : _class.getDeclaredMethods()) {\n            if (!Modifier.isStatic(m.getModifiers())) {\n                continue;\n            }\n            \n            \n            if (creatorMethods == null) {\n                creatorMethods = new ArrayList<AnnotatedMethod>(8);\n            }\n            creatorMethods.add(_constructCreatorMethod(m));\n        }\n        if (creatorMethods == null) {\n            _creatorMethods = Collections.emptyList();\n        } else {\n            _creatorMethods = creatorMethods;\n            \n            if (_primaryMixIn != null) {\n                _addFactoryMixIns(_primaryMixIn);\n            }\n            \n            if (_annotationIntrospector != null) {\n                \n                for (int i = _creatorMethods.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_creatorMethods.get(i))) {\n                        _creatorMethods.remove(i);\n                    }\n                }\n            }\n        }\n        _creatorsResolved = true;\n    }\n    \n    \n    private void resolveMemberMethods() {\n        _memberMethods = new AnnotatedMethodMap();\n        AnnotatedMethodMap mixins = new AnnotatedMethodMap();\n        \n        _addMemberMethods(_class, _memberMethods, _primaryMixIn, mixins);\n\n        \n        for (Class<?> cls : _superTypes) {\n            Class<?> mixin = (_mixInResolver == null) ? null : _mixInResolver.findMixInClassFor(cls);         \n            _addMemberMethods(cls, _memberMethods, mixin, mixins);\n        }\n        \n        if (_mixInResolver != null) {\n            Class<?> mixin = _mixInResolver.findMixInClassFor(Object.class);\n            if (mixin != null) {\n                _addMethodMixIns(_class, _memberMethods, mixin, mixins);\n            }\n        }\n\n        \n        \n        if (_annotationIntrospector != null) {\n            if (!mixins.isEmpty()) {\n                Iterator<AnnotatedMethod> it = mixins.iterator();\n                while (it.hasNext()) {\n                    AnnotatedMethod mixIn = it.next();\n                    try {\n                        Method m = Object.class.getDeclaredMethod(mixIn.getName(), mixIn.getRawParameterTypes());\n                        if (m != null) {\n                            AnnotatedMethod am = _constructMethod(m);\n                            _addMixOvers(mixIn.getAnnotated(), am, false);\n                            _memberMethods.add(am);\n                        }\n                    } catch (Exception e) { }\n                }\n            }\n        }\n    }\n    \n    \n    private void resolveFields() {\n        Map<String,AnnotatedField> foundFields = _findFields(_class, null);\n        if (foundFields == null || foundFields.size() == 0) {\n            _fields = Collections.emptyList();\n        } else {\n            _fields = new ArrayList<AnnotatedField>(foundFields.size());\n            _fields.addAll(foundFields.values());\n        }\n    }\n    \n    \n    \n    \n    protected void _addClassMixIns(AnnotationMap annotations, Class<?> toMask) {\n        if (_mixInResolver != null) {\n            _addClassMixIns(annotations, toMask, _mixInResolver.findMixInClassFor(toMask));\n        }\n    }\n\n    protected void _addClassMixIns(AnnotationMap annotations, Class<?> toMask, Class<?> mixin) {\n        if (mixin == null) {\n            return;\n        }\n        \n        _addAnnotationsIfNotPresent(annotations, mixin.getDeclaredAnnotations());\n\n        \n        for (Class<?> parent : ClassUtil.findSuperTypes(mixin, toMask)) {\n            _addAnnotationsIfNotPresent(annotations, parent.getDeclaredAnnotations());\n        }\n    }\n\n    \n\n    protected void _addConstructorMixIns(Class<?> mixin) {\n        MemberKey[] ctorKeys = null;\n        int ctorCount = (_constructors == null) ? 0 : _constructors.size();\n        for (Constructor<?> ctor : mixin.getDeclaredConstructors()) {\n            if (ctor.getParameterTypes().length == 0) {\n                if (_defaultConstructor != null) {\n                    _addMixOvers(ctor, _defaultConstructor, false);\n                }\n            } else {\n                if (ctorKeys == null) {\n                    ctorKeys = new MemberKey[ctorCount];\n                    for (int i = 0; i < ctorCount; ++i) {\n                        ctorKeys[i] = new MemberKey(_constructors.get(i).getAnnotated());\n                    }\n                }\n                MemberKey key = new MemberKey(ctor);\n\n                for (int i = 0; i < ctorCount; ++i) {\n                    if (!key.equals(ctorKeys[i])) {\n                        continue;\n                    }\n                    _addMixOvers(ctor, _constructors.get(i), true);\n                    break;\n                }\n            }\n        }\n    }\n\n    protected void _addFactoryMixIns(Class<?> mixin) {\n        MemberKey[] methodKeys = null;\n        int methodCount = _creatorMethods.size();\n\n        for (Method m : mixin.getDeclaredMethods()) {\n            if (!Modifier.isStatic(m.getModifiers())) {\n                continue;\n            }\n            if (m.getParameterTypes().length == 0) {\n                continue;\n            }\n            if (methodKeys == null) {\n                methodKeys = new MemberKey[methodCount];\n                for (int i = 0; i < methodCount; ++i) {\n                    methodKeys[i] = new MemberKey(_creatorMethods.get(i).getAnnotated());\n                }\n            }\n            MemberKey key = new MemberKey(m);\n            for (int i = 0; i < methodCount; ++i) {\n                if (!key.equals(methodKeys[i])) {\n                    continue;\n                }\n                _addMixOvers(m, _creatorMethods.get(i), true);\n                break;\n            }\n        }\n    }\n\n    \n\n    protected void _addMemberMethods(Class<?> cls, AnnotatedMethodMap methods, Class<?> mixInCls, AnnotatedMethodMap mixIns) {\n        \n        if (mixInCls != null) {\n            _addMethodMixIns(cls, methods, mixInCls, mixIns);\n        }        \n        if (cls == null) { \n            return;\n        }\n\n        \n        for (Method m : cls.getDeclaredMethods()) {\n            if (!_isIncludableMemberMethod(m)) {\n                continue;\n            }\n            AnnotatedMethod old = methods.find(m);\n            if (old == null) {\n                AnnotatedMethod newM = _constructMethod(m);\n                methods.add(newM);\n                \n                old = mixIns.remove(m);\n                if (old != null) {\n                    _addMixOvers(old.getAnnotated(), newM, false);\n                }\n            } else {\n                \n                _addMixUnders(m, old);\n\n                \n                if (old.getDeclaringClass().isInterface() && !m.getDeclaringClass().isInterface()) {\n                    methods.add(old.withMethod(m));\n                }\n            }\n        }\n    }\n\n    protected void _addMethodMixIns(Class<?> targetClass, AnnotatedMethodMap methods, Class<?> mixInCls, AnnotatedMethodMap mixIns) {\n        List<Class<?>> parents = new ArrayList<Class<?>>();\n        parents.add(mixInCls);\n        ClassUtil.findSuperTypes(mixInCls, targetClass, parents);\n        for (Class<?> mixin : parents) {\n            for (Method m : mixin.getDeclaredMethods()) {\n                if (!_isIncludableMemberMethod(m)) {\n                    continue;\n                }\n                AnnotatedMethod am = methods.find(m);\n                \n                if (am != null) {\n                    _addMixUnders(m, am);\n                    \n                } else {\n                    \n                        mixIns.add(_constructMethod(m));\n                }\n            }\n        }\n    }\n\n    \n\n    protected Map<String,AnnotatedField> _findFields(Class<?> c, Map<String,AnnotatedField> fields) {\n        \n        Class<?> parent = c.getSuperclass();\n        if (parent != null) {\n            \n            \n            fields = _findFields(parent, fields);\n            for (Field f : c.getDeclaredFields()) {\n                \n                if (!_isIncludableField(f)) {\n                    continue;\n                }\n                \n                if (fields == null) {\n                    fields = new LinkedHashMap<String,AnnotatedField>();\n                }\n                fields.put(f.getName(), _constructField(f));\n            }\n            \n            if (_mixInResolver != null) {\n                Class<?> mixin = _mixInResolver.findMixInClassFor(c);\n                if (mixin != null) {\n                    _addFieldMixIns(parent, mixin, fields);\n                }\n            }\n        }\n        return fields;\n    }\n\n    \n    protected void _addFieldMixIns(Class<?> targetClass, Class<?> mixInCls, Map<String,AnnotatedField> fields) {\n        List<Class<?>> parents = new ArrayList<Class<?>>();\n        parents.add(mixInCls);\n        ClassUtil.findSuperTypes(mixInCls, targetClass, parents);\n        for (Class<?> mixin : parents) {\n            for (Field mixinField : mixin.getDeclaredFields()) {\n                \n                if (!_isIncludableField(mixinField)) {\n                    continue;\n                }\n                String name = mixinField.getName();\n                \n                AnnotatedField maskedField = fields.get(name);\n                if (maskedField != null) {\n                    _addOrOverrideAnnotations(maskedField, mixinField.getDeclaredAnnotations());\n                }\n            }\n        }\n    }\n\n    \n\n    protected AnnotatedMethod _constructMethod(Method m) {\n        \n        if (_annotationIntrospector == null) { \n            return new AnnotatedMethod(m, _emptyAnnotationMap(), null);\n        }\n        return new AnnotatedMethod(m, _collectRelevantAnnotations(m.getDeclaredAnnotations()), null);\n    }\n\n    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor) {\n        if (_annotationIntrospector == null) { \n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        \n        \n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            \n            \n\n            Class<?> dc = ctor.getDeclaringClass();\n            \n            if (dc.isEnum() && (paramCount == paramAnns.length + 2)) {\n                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                \n                if (paramCount == (paramAnns.length + 1)) {\n                    \n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }\n\n    protected AnnotatedMethod _constructCreatorMethod(Method m) {\n        if (_annotationIntrospector == null) { \n            return new AnnotatedMethod(m, _emptyAnnotationMap(), _emptyAnnotationMaps(m.getParameterTypes().length));\n        }\n        return new AnnotatedMethod(m, _collectRelevantAnnotations(m.getDeclaredAnnotations()),\n                                   _collectRelevantAnnotations(m.getParameterAnnotations()));\n    }\n\n    protected AnnotatedField _constructField(Field f) {\n        if (_annotationIntrospector == null) { \n            return new AnnotatedField(f, _emptyAnnotationMap());\n        }\n        return new AnnotatedField(f, _collectRelevantAnnotations(f.getDeclaredAnnotations()));\n    }\n \n    private AnnotationMap _emptyAnnotationMap() {\n        return new AnnotationMap();\n    }\n\n    private AnnotationMap[] _emptyAnnotationMaps(int count) {\n        if (count == 0) {\n            return NO_ANNOTATION_MAPS;\n        }\n        AnnotationMap[] maps = new AnnotationMap[count];\n        for (int i = 0; i < count; ++i) {\n            maps[i] = _emptyAnnotationMap();\n        }\n        return maps;\n    }\n    \n    \n\n    protected boolean _isIncludableMemberMethod(Method m) {\n        if (Modifier.isStatic(m.getModifiers())) {\n            return false;\n        }\n        \n        if (m.isSynthetic() || m.isBridge()) {\n            return false;\n        }\n        \n        int pcount = m.getParameterTypes().length;\n        return (pcount <= 2);\n    }\n\n    private boolean _isIncludableField(Field f) {\n        \n        if (f.isSynthetic()) {\n            return false;\n        }\n        \n        int mods = f.getModifiers();\n        if (Modifier.isStatic(mods) || Modifier.isTransient(mods)) {\n            return false;\n        }\n        return true;\n    }\n\n    \n\n    protected AnnotationMap[] _collectRelevantAnnotations(Annotation[][] anns) {\n        int len = anns.length;\n        AnnotationMap[] result = new AnnotationMap[len];\n        for (int i = 0; i < len; ++i) {\n            result[i] = _collectRelevantAnnotations(anns[i]);\n        }\n        return result;\n    }\n\n    protected AnnotationMap _collectRelevantAnnotations(Annotation[] anns) {\n        AnnotationMap annMap = new AnnotationMap();\n        _addAnnotationsIfNotPresent(annMap, anns);\n        return annMap;\n    }\n    \n    \n    private void _addAnnotationsIfNotPresent(AnnotationMap result, Annotation[] anns) {\n        if (anns != null) {\n            List<Annotation[]> bundles = null;\n            for (Annotation ann : anns) { \n                if (_isAnnotationBundle(ann)) {\n                    if (bundles == null) {\n                        bundles = new LinkedList<Annotation[]>();\n                    }\n                    bundles.add(ann.annotationType().getDeclaredAnnotations());\n                } else { \n                    result.addIfNotPresent(ann);\n                }\n            }\n            if (bundles != null) { \n                for (Annotation[] annotations : bundles) {\n                    _addAnnotationsIfNotPresent(result, annotations);\n                }\n            }\n        }\n    }\n\n    private void _addAnnotationsIfNotPresent(AnnotatedMember target, Annotation[] anns) {\n        if (anns != null) {\n            List<Annotation[]> bundles = null;\n            for (Annotation ann : anns) { \n                if (_isAnnotationBundle(ann)) {\n                    if (bundles == null) {\n                        bundles = new LinkedList<Annotation[]>();\n                    }\n                    bundles.add(ann.annotationType().getDeclaredAnnotations());\n                } else { \n                    target.addIfNotPresent(ann);\n                }\n            }\n            if (bundles != null) { \n                for (Annotation[] annotations : bundles) {\n                    _addAnnotationsIfNotPresent(target, annotations);\n                }\n            }\n        }\n    }\n    \n    private void _addOrOverrideAnnotations(AnnotatedMember target, Annotation[] anns) {\n        if (anns != null) {\n            List<Annotation[]> bundles = null;\n            for (Annotation ann : anns) { \n                if (_isAnnotationBundle(ann)) {\n                    if (bundles == null) {\n                        bundles = new LinkedList<Annotation[]>();\n                    }\n                    bundles.add(ann.annotationType().getDeclaredAnnotations());\n                } else { \n                    target.addOrOverride(ann);\n                }\n            }\n            if (bundles != null) { \n                for (Annotation[] annotations : bundles) {\n                    _addOrOverrideAnnotations(target, annotations);\n                }\n            }\n        }\n    }\n    \n    \n    protected void _addMixOvers(Constructor<?> mixin, AnnotatedConstructor target, boolean addParamAnnotations) {\n        _addOrOverrideAnnotations(target, mixin.getDeclaredAnnotations());\n        if (addParamAnnotations) {\n            Annotation[][] pa = mixin.getParameterAnnotations();\n            for (int i = 0, len = pa.length; i < len; ++i) {\n                for (Annotation a : pa[i]) {\n                    target.addOrOverrideParam(i, a);\n                }\n            }\n        }\n    }\n\n    \n    protected void _addMixOvers(Method mixin, AnnotatedMethod target, boolean addParamAnnotations) {\n        _addOrOverrideAnnotations(target, mixin.getDeclaredAnnotations());\n        if (addParamAnnotations) {\n            Annotation[][] pa = mixin.getParameterAnnotations();\n            for (int i = 0, len = pa.length; i < len; ++i) {\n                for (Annotation a : pa[i]) {\n                    target.addOrOverrideParam(i, a);\n                }\n            }\n        }\n    }\n\n    \n    protected void _addMixUnders(Method src, AnnotatedMethod target) {\n        _addAnnotationsIfNotPresent(target, src.getDeclaredAnnotations());\n    }\n\n   private final boolean _isAnnotationBundle(Annotation ann) {\n       return (_annotationIntrospector != null) && _annotationIntrospector.isAnnotationBundle(ann);\n   }\n   \n    \n\n    @Override\n    public String toString() {\n        return \"[AnnotedClass \"+_class.getName()+\"]\";\n    }\n}\n",
      "fixed_full_code": "package com.fasterxml.jackson.databind.introspect;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.*;\nimport java.util.*;\n\nimport com.fasterxml.jackson.databind.AnnotationIntrospector;\nimport com.fasterxml.jackson.databind.introspect.ClassIntrospector.MixInResolver;\nimport com.fasterxml.jackson.databind.util.Annotations;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\n\npublic final class AnnotatedClass extends Annotated { private final static AnnotationMap[] NO_ANNOTATION_MAPS = new AnnotationMap[0]; final protected Class<?> _class; final protected List<Class<?>> _superTypes; final protected AnnotationIntrospector _annotationIntrospector; final protected MixInResolver _mixInResolver; final protected Class<?> _primaryMixIn; protected AnnotationMap _classAnnotations; protected boolean _creatorsResolved = false; protected AnnotatedConstructor _defaultConstructor; protected List<AnnotatedConstructor> _constructors; protected List<AnnotatedMethod> _creatorMethods; protected AnnotatedMethodMap _memberMethods; protected List<AnnotatedField> _fields; private AnnotatedClass(Class<?> cls, List<Class<?>> superTypes, AnnotationIntrospector aintr, MixInResolver mir, AnnotationMap classAnnotations) {\n        _class = cls;\n        _superTypes = superTypes;\n        _annotationIntrospector = aintr;\n        _mixInResolver = mir;\n        _primaryMixIn = (_mixInResolver == null) ? null\n            : _mixInResolver.findMixInClassFor(_class);\n        _classAnnotations = classAnnotations;\n    }\n\n    @Override\n    public AnnotatedClass withAnnotations(AnnotationMap ann) {\n        return new AnnotatedClass(_class, _superTypes,\n                _annotationIntrospector, _mixInResolver, ann);\n    }\n    \n    \n    public static AnnotatedClass construct(Class<?> cls, AnnotationIntrospector aintr, MixInResolver mir) {\n        return new AnnotatedClass(cls,\n                ClassUtil.findSuperTypes(cls, null), aintr, mir, null);\n    }\n\n    \n    public static AnnotatedClass constructWithoutSuperTypes(Class<?> cls, AnnotationIntrospector aintr, MixInResolver mir) {\n        return new AnnotatedClass(cls,\n                Collections.<Class<?>>emptyList(), aintr, mir, null);\n    }\n    \n    \n\n    @Override\n    public Class<?> getAnnotated() { return _class; }\n\n    @Override\n    public int getModifiers() { return _class.getModifiers(); }\n\n    @Override\n    public String getName() { return _class.getName(); }\n\n    @Override\n    public <A extends Annotation> A getAnnotation(Class<A> acls) {\n        if (_classAnnotations == null) {\n            resolveClassAnnotations();\n        }\n        return _classAnnotations.get(acls);\n    }\n\n    @Override\n    public Type getGenericType() {\n        return _class;\n    }\n\n    @Override\n    public Class<?> getRawType() {\n        return _class;\n    }\n\n    @Override\n    public Iterable<Annotation> annotations() {\n        if (_classAnnotations == null) {\n            resolveClassAnnotations();\n        }\n        return _classAnnotations.annotations();\n    }\n    \n    @Override\n    protected AnnotationMap getAllAnnotations() {\n        if (_classAnnotations == null) {\n            resolveClassAnnotations();\n        }\n        return _classAnnotations;\n    }\n    \n    \n\n    public Annotations getAnnotations() {\n        if (_classAnnotations == null) {\n            resolveClassAnnotations();\n        }\n        return _classAnnotations;\n    }\n    \n    public boolean hasAnnotations() {\n        if (_classAnnotations == null) {\n            resolveClassAnnotations();\n        }\n        return _classAnnotations.size() > 0;\n    }\n\n    public AnnotatedConstructor getDefaultConstructor() {\n        if (!_creatorsResolved) {\n            resolveCreators();\n        }\n        return _defaultConstructor;\n    }\n\n    public List<AnnotatedConstructor> getConstructors() {\n        if (!_creatorsResolved) {\n            resolveCreators();\n        }\n        return _constructors;\n    }\n\n    public List<AnnotatedMethod> getStaticMethods() {\n        if (!_creatorsResolved) {\n            resolveCreators();\n        }\n        return _creatorMethods;\n    }\n\n    public Iterable<AnnotatedMethod> memberMethods() {\n        if (_memberMethods == null) {\n            resolveMemberMethods();\n        }\n        return _memberMethods;\n    }\n\n    public int getMemberMethodCount() {\n        if (_memberMethods == null) {\n            resolveMemberMethods();\n        }\n        return _memberMethods.size();\n    }\n\n    public AnnotatedMethod findMethod(String name, Class<?>[] paramTypes) {\n        if (_memberMethods == null) {\n            resolveMemberMethods();\n        }\n        return _memberMethods.find(name, paramTypes);\n    }\n\n    public int getFieldCount() {\n        if (_fields == null) {\n            resolveFields();\n        }\n        return _fields.size();\n    }\n\n    public Iterable<AnnotatedField> fields() {\n        if (_fields == null) {\n            resolveFields();\n        }\n        return _fields;\n    }\n\n    \n\n    \n    private void resolveClassAnnotations() {\n        _classAnnotations = new AnnotationMap();\n        \n        if (_annotationIntrospector != null) {\n            \n            if (_primaryMixIn != null) {\n                _addClassMixIns(_classAnnotations, _class, _primaryMixIn);\n            }\n            \n            _addAnnotationsIfNotPresent(_classAnnotations, _class.getDeclaredAnnotations());\n    \n            \n            for (Class<?> cls : _superTypes) {\n                \n                _addClassMixIns(_classAnnotations, cls);\n                _addAnnotationsIfNotPresent(_classAnnotations, cls.getDeclaredAnnotations());\n            }\n            \n            \n            _addClassMixIns(_classAnnotations, Object.class);\n        }\n    }\n    \n    \n    private void resolveCreators() {\n        \n        List<AnnotatedConstructor> constructors = null;\n        Constructor<?>[] declaredCtors = _class.getDeclaredConstructors();\n        for (Constructor<?> ctor : declaredCtors) {\n            if (ctor.getParameterTypes().length == 0) {\n                _defaultConstructor = _constructConstructor(ctor, true);\n            } else {\n                if (constructors == null) {\n                    constructors = new ArrayList<AnnotatedConstructor>(Math.max(10, declaredCtors.length));\n                }\n                constructors.add(_constructConstructor(ctor, false));\n            }\n        }\n        if (constructors == null) {\n            _constructors = Collections.emptyList();\n        } else {\n            _constructors = constructors;\n        }\n        \n        if (_primaryMixIn != null) {\n            if (_defaultConstructor != null || !_constructors.isEmpty()) {\n                _addConstructorMixIns(_primaryMixIn);\n            }\n        }\n\n\n        \n        \n        if (_annotationIntrospector != null) {\n            if (_defaultConstructor != null) {\n                if (_annotationIntrospector.hasIgnoreMarker(_defaultConstructor)) {\n                    _defaultConstructor = null;\n                }\n            }\n            if (_constructors != null) {\n                \n                for (int i = _constructors.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_constructors.get(i))) {\n                        _constructors.remove(i);\n                    }\n                }\n            }\n        }\n        List<AnnotatedMethod> creatorMethods = null;\n        \n        \n        for (Method m : _class.getDeclaredMethods()) {\n            if (!Modifier.isStatic(m.getModifiers())) {\n                continue;\n            }\n            \n            \n            if (creatorMethods == null) {\n                creatorMethods = new ArrayList<AnnotatedMethod>(8);\n            }\n            creatorMethods.add(_constructCreatorMethod(m));\n        }\n        if (creatorMethods == null) {\n            _creatorMethods = Collections.emptyList();\n        } else {\n            _creatorMethods = creatorMethods;\n            \n            if (_primaryMixIn != null) {\n                _addFactoryMixIns(_primaryMixIn);\n            }\n            \n            if (_annotationIntrospector != null) {\n                \n                for (int i = _creatorMethods.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_creatorMethods.get(i))) {\n                        _creatorMethods.remove(i);\n                    }\n                }\n            }\n        }\n        _creatorsResolved = true;\n    }\n    \n    \n    private void resolveMemberMethods() {\n        _memberMethods = new AnnotatedMethodMap();\n        AnnotatedMethodMap mixins = new AnnotatedMethodMap();\n        \n        _addMemberMethods(_class, _memberMethods, _primaryMixIn, mixins);\n\n        \n        for (Class<?> cls : _superTypes) {\n            Class<?> mixin = (_mixInResolver == null) ? null : _mixInResolver.findMixInClassFor(cls);         \n            _addMemberMethods(cls, _memberMethods, mixin, mixins);\n        }\n        \n        if (_mixInResolver != null) {\n            Class<?> mixin = _mixInResolver.findMixInClassFor(Object.class);\n            if (mixin != null) {\n                _addMethodMixIns(_class, _memberMethods, mixin, mixins);\n            }\n        }\n\n        \n        \n        if (_annotationIntrospector != null) {\n            if (!mixins.isEmpty()) {\n                Iterator<AnnotatedMethod> it = mixins.iterator();\n                while (it.hasNext()) {\n                    AnnotatedMethod mixIn = it.next();\n                    try {\n                        Method m = Object.class.getDeclaredMethod(mixIn.getName(), mixIn.getRawParameterTypes());\n                        if (m != null) {\n                            AnnotatedMethod am = _constructMethod(m);\n                            _addMixOvers(mixIn.getAnnotated(), am, false);\n                            _memberMethods.add(am);\n                        }\n                    } catch (Exception e) { }\n                }\n            }\n        }\n    }\n    \n    \n    private void resolveFields() {\n        Map<String,AnnotatedField> foundFields = _findFields(_class, null);\n        if (foundFields == null || foundFields.size() == 0) {\n            _fields = Collections.emptyList();\n        } else {\n            _fields = new ArrayList<AnnotatedField>(foundFields.size());\n            _fields.addAll(foundFields.values());\n        }\n    }\n    \n    \n    \n    \n    protected void _addClassMixIns(AnnotationMap annotations, Class<?> toMask) {\n        if (_mixInResolver != null) {\n            _addClassMixIns(annotations, toMask, _mixInResolver.findMixInClassFor(toMask));\n        }\n    }\n\n    protected void _addClassMixIns(AnnotationMap annotations, Class<?> toMask, Class<?> mixin) {\n        if (mixin == null) {\n            return;\n        }\n        \n        _addAnnotationsIfNotPresent(annotations, mixin.getDeclaredAnnotations());\n\n        \n        for (Class<?> parent : ClassUtil.findSuperTypes(mixin, toMask)) {\n            _addAnnotationsIfNotPresent(annotations, parent.getDeclaredAnnotations());\n        }\n    }\n\n    \n\n    protected void _addConstructorMixIns(Class<?> mixin) {\n        MemberKey[] ctorKeys = null;\n        int ctorCount = (_constructors == null) ? 0 : _constructors.size();\n        for (Constructor<?> ctor : mixin.getDeclaredConstructors()) {\n            if (ctor.getParameterTypes().length == 0) {\n                if (_defaultConstructor != null) {\n                    _addMixOvers(ctor, _defaultConstructor, false);\n                }\n            } else {\n                if (ctorKeys == null) {\n                    ctorKeys = new MemberKey[ctorCount];\n                    for (int i = 0; i < ctorCount; ++i) {\n                        ctorKeys[i] = new MemberKey(_constructors.get(i).getAnnotated());\n                    }\n                }\n                MemberKey key = new MemberKey(ctor);\n\n                for (int i = 0; i < ctorCount; ++i) {\n                    if (!key.equals(ctorKeys[i])) {\n                        continue;\n                    }\n                    _addMixOvers(ctor, _constructors.get(i), true);\n                    break;\n                }\n            }\n        }\n    }\n\n    protected void _addFactoryMixIns(Class<?> mixin) {\n        MemberKey[] methodKeys = null;\n        int methodCount = _creatorMethods.size();\n\n        for (Method m : mixin.getDeclaredMethods()) {\n            if (!Modifier.isStatic(m.getModifiers())) {\n                continue;\n            }\n            if (m.getParameterTypes().length == 0) {\n                continue;\n            }\n            if (methodKeys == null) {\n                methodKeys = new MemberKey[methodCount];\n                for (int i = 0; i < methodCount; ++i) {\n                    methodKeys[i] = new MemberKey(_creatorMethods.get(i).getAnnotated());\n                }\n            }\n            MemberKey key = new MemberKey(m);\n            for (int i = 0; i < methodCount; ++i) {\n                if (!key.equals(methodKeys[i])) {\n                    continue;\n                }\n                _addMixOvers(m, _creatorMethods.get(i), true);\n                break;\n            }\n        }\n    }\n\n    \n\n    protected void _addMemberMethods(Class<?> cls, AnnotatedMethodMap methods, Class<?> mixInCls, AnnotatedMethodMap mixIns) {\n        \n        if (mixInCls != null) {\n            _addMethodMixIns(cls, methods, mixInCls, mixIns);\n        }        \n        if (cls == null) { \n            return;\n        }\n\n        \n        for (Method m : cls.getDeclaredMethods()) {\n            if (!_isIncludableMemberMethod(m)) {\n                continue;\n            }\n            AnnotatedMethod old = methods.find(m);\n            if (old == null) {\n                AnnotatedMethod newM = _constructMethod(m);\n                methods.add(newM);\n                \n                old = mixIns.remove(m);\n                if (old != null) {\n                    _addMixOvers(old.getAnnotated(), newM, false);\n                }\n            } else {\n                \n                _addMixUnders(m, old);\n\n                \n                if (old.getDeclaringClass().isInterface() && !m.getDeclaringClass().isInterface()) {\n                    methods.add(old.withMethod(m));\n                }\n            }\n        }\n    }\n\n    protected void _addMethodMixIns(Class<?> targetClass, AnnotatedMethodMap methods, Class<?> mixInCls, AnnotatedMethodMap mixIns) {\n        List<Class<?>> parents = new ArrayList<Class<?>>();\n        parents.add(mixInCls);\n        ClassUtil.findSuperTypes(mixInCls, targetClass, parents);\n        for (Class<?> mixin : parents) {\n            for (Method m : mixin.getDeclaredMethods()) {\n                if (!_isIncludableMemberMethod(m)) {\n                    continue;\n                }\n                AnnotatedMethod am = methods.find(m);\n                \n                if (am != null) {\n                    _addMixUnders(m, am);\n                    \n                } else {\n                    \n                    am = mixIns.find(m);\n                    if (am != null) {\n                        _addMixUnders(m, am);\n                    } else {\n                        mixIns.add(_constructMethod(m));\n                    }\n                }\n            }\n        }\n    }\n\n    \n\n    protected Map<String,AnnotatedField> _findFields(Class<?> c, Map<String,AnnotatedField> fields) {\n        \n        Class<?> parent = c.getSuperclass();\n        if (parent != null) {\n            \n            \n            fields = _findFields(parent, fields);\n            for (Field f : c.getDeclaredFields()) {\n                \n                if (!_isIncludableField(f)) {\n                    continue;\n                }\n                \n                if (fields == null) {\n                    fields = new LinkedHashMap<String,AnnotatedField>();\n                }\n                fields.put(f.getName(), _constructField(f));\n            }\n            \n            if (_mixInResolver != null) {\n                Class<?> mixin = _mixInResolver.findMixInClassFor(c);\n                if (mixin != null) {\n                    _addFieldMixIns(parent, mixin, fields);\n                }\n            }\n        }\n        return fields;\n    }\n\n    \n    protected void _addFieldMixIns(Class<?> targetClass, Class<?> mixInCls, Map<String,AnnotatedField> fields) {\n        List<Class<?>> parents = new ArrayList<Class<?>>();\n        parents.add(mixInCls);\n        ClassUtil.findSuperTypes(mixInCls, targetClass, parents);\n        for (Class<?> mixin : parents) {\n            for (Field mixinField : mixin.getDeclaredFields()) {\n                \n                if (!_isIncludableField(mixinField)) {\n                    continue;\n                }\n                String name = mixinField.getName();\n                \n                AnnotatedField maskedField = fields.get(name);\n                if (maskedField != null) {\n                    _addOrOverrideAnnotations(maskedField, mixinField.getDeclaredAnnotations());\n                }\n            }\n        }\n    }\n\n    \n\n    protected AnnotatedMethod _constructMethod(Method m) {\n        \n        if (_annotationIntrospector == null) { \n            return new AnnotatedMethod(m, _emptyAnnotationMap(), null);\n        }\n        return new AnnotatedMethod(m, _collectRelevantAnnotations(m.getDeclaredAnnotations()), null);\n    }\n\n    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor) {\n        if (_annotationIntrospector == null) { \n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        \n        \n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            \n            \n\n            Class<?> dc = ctor.getDeclaringClass();\n            \n            if (dc.isEnum() && (paramCount == paramAnns.length + 2)) {\n                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                \n                if (paramCount == (paramAnns.length + 1)) {\n                    \n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }\n\n    protected AnnotatedMethod _constructCreatorMethod(Method m) {\n        if (_annotationIntrospector == null) { \n            return new AnnotatedMethod(m, _emptyAnnotationMap(), _emptyAnnotationMaps(m.getParameterTypes().length));\n        }\n        return new AnnotatedMethod(m, _collectRelevantAnnotations(m.getDeclaredAnnotations()),\n                                   _collectRelevantAnnotations(m.getParameterAnnotations()));\n    }\n\n    protected AnnotatedField _constructField(Field f) {\n        if (_annotationIntrospector == null) { \n            return new AnnotatedField(f, _emptyAnnotationMap());\n        }\n        return new AnnotatedField(f, _collectRelevantAnnotations(f.getDeclaredAnnotations()));\n    }\n \n    private AnnotationMap _emptyAnnotationMap() {\n        return new AnnotationMap();\n    }\n\n    private AnnotationMap[] _emptyAnnotationMaps(int count) {\n        if (count == 0) {\n            return NO_ANNOTATION_MAPS;\n        }\n        AnnotationMap[] maps = new AnnotationMap[count];\n        for (int i = 0; i < count; ++i) {\n            maps[i] = _emptyAnnotationMap();\n        }\n        return maps;\n    }\n    \n    \n\n    protected boolean _isIncludableMemberMethod(Method m) {\n        if (Modifier.isStatic(m.getModifiers())) {\n            return false;\n        }\n        \n        if (m.isSynthetic() || m.isBridge()) {\n            return false;\n        }\n        \n        int pcount = m.getParameterTypes().length;\n        return (pcount <= 2);\n    }\n\n    private boolean _isIncludableField(Field f) {\n        \n        if (f.isSynthetic()) {\n            return false;\n        }\n        \n        int mods = f.getModifiers();\n        if (Modifier.isStatic(mods) || Modifier.isTransient(mods)) {\n            return false;\n        }\n        return true;\n    }\n\n    \n\n    protected AnnotationMap[] _collectRelevantAnnotations(Annotation[][] anns) {\n        int len = anns.length;\n        AnnotationMap[] result = new AnnotationMap[len];\n        for (int i = 0; i < len; ++i) {\n            result[i] = _collectRelevantAnnotations(anns[i]);\n        }\n        return result;\n    }\n\n    protected AnnotationMap _collectRelevantAnnotations(Annotation[] anns) {\n        AnnotationMap annMap = new AnnotationMap();\n        _addAnnotationsIfNotPresent(annMap, anns);\n        return annMap;\n    }\n    \n    \n    private void _addAnnotationsIfNotPresent(AnnotationMap result, Annotation[] anns) {\n        if (anns != null) {\n            List<Annotation[]> bundles = null;\n            for (Annotation ann : anns) { \n                if (_isAnnotationBundle(ann)) {\n                    if (bundles == null) {\n                        bundles = new LinkedList<Annotation[]>();\n                    }\n                    bundles.add(ann.annotationType().getDeclaredAnnotations());\n                } else { \n                    result.addIfNotPresent(ann);\n                }\n            }\n            if (bundles != null) { \n                for (Annotation[] annotations : bundles) {\n                    _addAnnotationsIfNotPresent(result, annotations);\n                }\n            }\n        }\n    }\n\n    private void _addAnnotationsIfNotPresent(AnnotatedMember target, Annotation[] anns) {\n        if (anns != null) {\n            List<Annotation[]> bundles = null;\n            for (Annotation ann : anns) { \n                if (_isAnnotationBundle(ann)) {\n                    if (bundles == null) {\n                        bundles = new LinkedList<Annotation[]>();\n                    }\n                    bundles.add(ann.annotationType().getDeclaredAnnotations());\n                } else { \n                    target.addIfNotPresent(ann);\n                }\n            }\n            if (bundles != null) { \n                for (Annotation[] annotations : bundles) {\n                    _addAnnotationsIfNotPresent(target, annotations);\n                }\n            }\n        }\n    }\n    \n    private void _addOrOverrideAnnotations(AnnotatedMember target, Annotation[] anns) {\n        if (anns != null) {\n            List<Annotation[]> bundles = null;\n            for (Annotation ann : anns) { \n                if (_isAnnotationBundle(ann)) {\n                    if (bundles == null) {\n                        bundles = new LinkedList<Annotation[]>();\n                    }\n                    bundles.add(ann.annotationType().getDeclaredAnnotations());\n                } else { \n                    target.addOrOverride(ann);\n                }\n            }\n            if (bundles != null) { \n                for (Annotation[] annotations : bundles) {\n                    _addOrOverrideAnnotations(target, annotations);\n                }\n            }\n        }\n    }\n    \n    \n    protected void _addMixOvers(Constructor<?> mixin, AnnotatedConstructor target, boolean addParamAnnotations) {\n        _addOrOverrideAnnotations(target, mixin.getDeclaredAnnotations());\n        if (addParamAnnotations) {\n            Annotation[][] pa = mixin.getParameterAnnotations();\n            for (int i = 0, len = pa.length; i < len; ++i) {\n                for (Annotation a : pa[i]) {\n                    target.addOrOverrideParam(i, a);\n                }\n            }\n        }\n    }\n\n    \n    protected void _addMixOvers(Method mixin, AnnotatedMethod target, boolean addParamAnnotations) {\n        _addOrOverrideAnnotations(target, mixin.getDeclaredAnnotations());\n        if (addParamAnnotations) {\n            Annotation[][] pa = mixin.getParameterAnnotations();\n            for (int i = 0, len = pa.length; i < len; ++i) {\n                for (Annotation a : pa[i]) {\n                    target.addOrOverrideParam(i, a);\n                }\n            }\n        }\n    }\n\n    \n    protected void _addMixUnders(Method src, AnnotatedMethod target) {\n        _addAnnotationsIfNotPresent(target, src.getDeclaredAnnotations());\n    }\n\n   private final boolean _isAnnotationBundle(Annotation ann) {\n       return (_annotationIntrospector != null) && _annotationIntrospector.isAnnotationBundle(ann);\n   }\n   \n    \n\n    @Override\n    public String toString() {\n        return \"[AnnotedClass \"+_class.getName()+\"]\";\n    }\n}\n",
      "buggy_signatures": [
        "public AnnotatedClass withAnnotations(AnnotationMap ann)",
        "public static AnnotatedClass construct(Class<?> cls, AnnotationIntrospector aintr, MixInResolver mir)",
        "public static AnnotatedClass constructWithoutSuperTypes(Class<?> cls, AnnotationIntrospector aintr, MixInResolver mir)",
        "public Class<?> getAnnotated()",
        "public int getModifiers()",
        "public String getName()",
        "public <A extends Annotation> A getAnnotation(Class<A> acls)",
        "public Type getGenericType()",
        "public Class<?> getRawType()",
        "public Iterable<Annotation> annotations()",
        "protected AnnotationMap getAllAnnotations()",
        "public Annotations getAnnotations()",
        "public boolean hasAnnotations()",
        "public AnnotatedConstructor getDefaultConstructor()",
        "public List<AnnotatedConstructor> getConstructors()",
        "public List<AnnotatedMethod> getStaticMethods()",
        "public Iterable<AnnotatedMethod> memberMethods()",
        "public int getMemberMethodCount()",
        "public AnnotatedMethod findMethod(String name, Class<?>[] paramTypes)",
        "public int getFieldCount()",
        "public Iterable<AnnotatedField> fields()",
        "private void resolveClassAnnotations()",
        "private void resolveCreators()",
        "private void resolveMemberMethods()",
        "private void resolveFields()",
        "protected void _addClassMixIns(AnnotationMap annotations, Class<?> toMask)",
        "protected void _addClassMixIns(AnnotationMap annotations, Class<?> toMask, Class<?> mixin)",
        "protected void _addConstructorMixIns(Class<?> mixin)",
        "protected void _addFactoryMixIns(Class<?> mixin)",
        "protected void _addMemberMethods(Class<?> cls, AnnotatedMethodMap methods, Class<?> mixInCls, AnnotatedMethodMap mixIns)",
        "protected void _addMethodMixIns(Class<?> targetClass, AnnotatedMethodMap methods, Class<?> mixInCls, AnnotatedMethodMap mixIns)",
        "protected Map<String,AnnotatedField> _findFields(Class<?> c, Map<String,AnnotatedField> fields)",
        "protected void _addFieldMixIns(Class<?> targetClass, Class<?> mixInCls, Map<String,AnnotatedField> fields)",
        "protected AnnotatedMethod _constructMethod(Method m)",
        "protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)",
        "protected AnnotatedMethod _constructCreatorMethod(Method m)",
        "protected AnnotatedField _constructField(Field f)",
        "private AnnotationMap _emptyAnnotationMap()",
        "private AnnotationMap[] _emptyAnnotationMaps(int count)",
        "protected boolean _isIncludableMemberMethod(Method m)",
        "private boolean _isIncludableField(Field f)",
        "protected AnnotationMap[] _collectRelevantAnnotations(Annotation[][] anns)",
        "protected AnnotationMap _collectRelevantAnnotations(Annotation[] anns)",
        "private void _addAnnotationsIfNotPresent(AnnotationMap result, Annotation[] anns)",
        "private void _addAnnotationsIfNotPresent(AnnotatedMember target, Annotation[] anns)",
        "private void _addOrOverrideAnnotations(AnnotatedMember target, Annotation[] anns)",
        "protected void _addMixOvers(Constructor<?> mixin, AnnotatedConstructor target, boolean addParamAnnotations)",
        "protected void _addMixOvers(Method mixin, AnnotatedMethod target, boolean addParamAnnotations)",
        "protected void _addMixUnders(Method src, AnnotatedMethod target)",
        "private final boolean _isAnnotationBundle(Annotation ann)",
        "public String toString()"
      ],
      "fixed_signatures": [
        "public AnnotatedClass withAnnotations(AnnotationMap ann)",
        "public static AnnotatedClass construct(Class<?> cls, AnnotationIntrospector aintr, MixInResolver mir)",
        "public static AnnotatedClass constructWithoutSuperTypes(Class<?> cls, AnnotationIntrospector aintr, MixInResolver mir)",
        "public Class<?> getAnnotated()",
        "public int getModifiers()",
        "public String getName()",
        "public <A extends Annotation> A getAnnotation(Class<A> acls)",
        "public Type getGenericType()",
        "public Class<?> getRawType()",
        "public Iterable<Annotation> annotations()",
        "protected AnnotationMap getAllAnnotations()",
        "public Annotations getAnnotations()",
        "public boolean hasAnnotations()",
        "public AnnotatedConstructor getDefaultConstructor()",
        "public List<AnnotatedConstructor> getConstructors()",
        "public List<AnnotatedMethod> getStaticMethods()",
        "public Iterable<AnnotatedMethod> memberMethods()",
        "public int getMemberMethodCount()",
        "public AnnotatedMethod findMethod(String name, Class<?>[] paramTypes)",
        "public int getFieldCount()",
        "public Iterable<AnnotatedField> fields()",
        "private void resolveClassAnnotations()",
        "private void resolveCreators()",
        "private void resolveMemberMethods()",
        "private void resolveFields()",
        "protected void _addClassMixIns(AnnotationMap annotations, Class<?> toMask)",
        "protected void _addClassMixIns(AnnotationMap annotations, Class<?> toMask, Class<?> mixin)",
        "protected void _addConstructorMixIns(Class<?> mixin)",
        "protected void _addFactoryMixIns(Class<?> mixin)",
        "protected void _addMemberMethods(Class<?> cls, AnnotatedMethodMap methods, Class<?> mixInCls, AnnotatedMethodMap mixIns)",
        "protected void _addMethodMixIns(Class<?> targetClass, AnnotatedMethodMap methods, Class<?> mixInCls, AnnotatedMethodMap mixIns)",
        "protected Map<String,AnnotatedField> _findFields(Class<?> c, Map<String,AnnotatedField> fields)",
        "protected void _addFieldMixIns(Class<?> targetClass, Class<?> mixInCls, Map<String,AnnotatedField> fields)",
        "protected AnnotatedMethod _constructMethod(Method m)",
        "protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)",
        "protected AnnotatedMethod _constructCreatorMethod(Method m)",
        "protected AnnotatedField _constructField(Field f)",
        "private AnnotationMap _emptyAnnotationMap()",
        "private AnnotationMap[] _emptyAnnotationMaps(int count)",
        "protected boolean _isIncludableMemberMethod(Method m)",
        "private boolean _isIncludableField(Field f)",
        "protected AnnotationMap[] _collectRelevantAnnotations(Annotation[][] anns)",
        "protected AnnotationMap _collectRelevantAnnotations(Annotation[] anns)",
        "private void _addAnnotationsIfNotPresent(AnnotationMap result, Annotation[] anns)",
        "private void _addAnnotationsIfNotPresent(AnnotatedMember target, Annotation[] anns)",
        "private void _addOrOverrideAnnotations(AnnotatedMember target, Annotation[] anns)",
        "protected void _addMixOvers(Constructor<?> mixin, AnnotatedConstructor target, boolean addParamAnnotations)",
        "protected void _addMixOvers(Method mixin, AnnotatedMethod target, boolean addParamAnnotations)",
        "protected void _addMixUnders(Method src, AnnotatedMethod target)",
        "private final boolean _isAnnotationBundle(Annotation ann)",
        "public String toString()"
      ],
      "methods": [
        {
          "buggy_method": "  protected void _addMethodMixIns(Class<?> targetClass, AnnotatedMethodMap methods, Class<?> mixInCls, AnnotatedMethodMap mixIns) {\n  List<Class<?>> parents = new ArrayList<Class<?>>();\n  parents.add(mixInCls);\n  ClassUtil.findSuperTypes(mixInCls, targetClass, parents);\n  for (Class<?> mixin : parents) {\n  for (Method m : mixin.getDeclaredMethods()) {\n  if (!_isIncludableMemberMethod(m)) {\n  continue;\n  }\n  AnnotatedMethod am = methods.find(m);\n  \n  if (am != null) {\n  _addMixUnders(m, am);\n  \n  } else {\n  \n  mixIns.add(_constructMethod(m));\n  }\n  }\n  }\n  }",
          "fixed_method": "  protected void _addMethodMixIns(Class<?> targetClass, AnnotatedMethodMap methods, Class<?> mixInCls, AnnotatedMethodMap mixIns) {\n  List<Class<?>> parents = new ArrayList<Class<?>>();\n  parents.add(mixInCls);\n  ClassUtil.findSuperTypes(mixInCls, targetClass, parents);\n  for (Class<?> mixin : parents) {\n  for (Method m : mixin.getDeclaredMethods()) {\n  if (!_isIncludableMemberMethod(m)) {\n  continue;\n  }\n  AnnotatedMethod am = methods.find(m);\n  \n  if (am != null) {\n  _addMixUnders(m, am);\n  \n  } else {\n  \n  am = mixIns.find(m);\n  if (am != null) {\n  _addMixUnders(m, am);\n  } else {\n  mixIns.add(_constructMethod(m));\n  }\n  }\n  }\n  }\n  }",
          "diff": [
            "@@ -655,7 +655,12 @@",
            "                      */\n",
            "                 } else {\n",
            "                     // Well, or, as per [Issue#515], multi-level merge within mixins...\n",
            "+                    am = mixIns.find(m);\n",
            "+                    if (am != null) {\n",
            "+                        _addMixUnders(m, am);\n",
            "+                    } else {\n",
            "                         mixIns.add(_constructMethod(m));\n",
            "+                    }\n",
            "                 }\n",
            "             }\n",
            "         }\n"
          ],
          "changed_lines": 5
        }
      ]
    }
  ]
}
