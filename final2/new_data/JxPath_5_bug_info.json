{
  "bug_id": "5",
  "failed_tests": {
    "org.apache.commons.jxpath.ri.compiler.VariableTest": [
      {
        "methodName": "testUnionOfVariableAndNode",
        "error": "org.apache.commons.jxpath.JXPathException",
        "message": "Cannot compare pointers that do not belong to the same tree: '' and '$var'",
        "fail_line": "        for (Iterator ptrs = context.iteratePointers(\"$var | /MAIN/A\"); ptrs.hasNext(); sz++) {",
        "test_source": "  public void testUnionOfVariableAndNode() throws Exception {\n  Document doc = DocumentBuilderFactory.newInstance()\n  .newDocumentBuilder().parse(\n  new InputSource(new StringReader(\n  \"<MAIN><A/><A/></MAIN>\")));\n\n  JXPathContext context = JXPathContext.newContext(doc);\n  context.getVariables().declareVariable(\"var\", \"varValue\");\n  int sz = 0;\n  for (Iterator ptrs = context.iteratePointers(\"$var | /MAIN/A\"); ptrs.hasNext(); sz++) {\n  ptrs.next();\n  }\n  assertEquals(3, sz);\n  }",
        "stack": [
          "NodePointer.compareNodePointers line 665, NodePointer.compareNodePointers line 653, NodePointer.compareNodePointers line 653, NodePointer.compareTo line 639, EvalContext.constructIterator line 176, EvalContext.hasNext line 100, VariableTest.testUnionOfVariableAndNode line 286"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/jxpath/ri/model/NodePointer.java",
      "buggy_full_code": "\npackage org.apache.commons.jxpath.ri.model;\n\nimport java.util.Locale;\n\nimport org.apache.commons.jxpath.JXPathContext;\nimport org.apache.commons.jxpath.JXPathException;\nimport org.apache.commons.jxpath.Pointer;\nimport org.apache.commons.jxpath.ri.Compiler;\nimport org.apache.commons.jxpath.ri.JXPathContextReferenceImpl;\nimport org.apache.commons.jxpath.ri.NamespaceResolver;\nimport org.apache.commons.jxpath.ri.QName;\nimport org.apache.commons.jxpath.ri.compiler.NodeNameTest;\nimport org.apache.commons.jxpath.ri.compiler.NodeTest;\nimport org.apache.commons.jxpath.ri.compiler.NodeTypeTest;\nimport org.apache.commons.jxpath.ri.model.beans.NullPointer;\n\n\npublic abstract class NodePointer implements Pointer { public static final int WHOLE_COLLECTION = Integer.MIN_VALUE; protected int index = WHOLE_COLLECTION; public static final String UNKNOWN_NAMESPACE = \"<<unknown namespace>>\"; private boolean attribute = false; private transient Object rootNode; private NamespaceResolver namespaceResolver; public static NodePointer newNodePointer( QName name, Object bean, Locale locale) {\n        NodePointer pointer = null;\n        if (bean == null) {\n            pointer = new NullPointer(name, locale);\n            return pointer;\n        }\n        \n        NodePointerFactory[] factories =\n            JXPathContextReferenceImpl.getNodePointerFactories();\n        for (int i = 0; i < factories.length; i++) {\n            pointer = factories[i].createNodePointer(name, bean, locale);\n            if (pointer != null) {\n                return pointer;\n            }\n        }\n        throw new JXPathException(\n            \"Could not allocate a NodePointer for object of \"\n                + bean.getClass());\n    }\n\n    \n    public static NodePointer newChildNodePointer( NodePointer parent, QName name, Object bean) {\n        NodePointerFactory[] factories =\n            JXPathContextReferenceImpl.getNodePointerFactories();\n        for (int i = 0; i < factories.length; i++) {\n            NodePointer pointer =\n                factories[i].createNodePointer(parent, name, bean);\n            if (pointer != null) {\n                return pointer;\n            }\n        }\n        throw new JXPathException(\n            \"Could not allocate a NodePointer for object of \"\n                + bean.getClass());\n    }\n\n    protected NodePointer parent; protected Locale locale; protected NodePointer(NodePointer parent) {\n        this.parent = parent;\n    }\n\n    protected NodePointer(NodePointer parent, Locale locale) {\n        this.parent = parent;\n        this.locale = locale;\n    }\n\n    public NamespaceResolver getNamespaceResolver() {\n        if (namespaceResolver == null && parent != null) {\n            namespaceResolver = parent.getNamespaceResolver();\n        }\n        return namespaceResolver;\n    }\n    \n    public void setNamespaceResolver(NamespaceResolver namespaceResolver) {\n        this.namespaceResolver = namespaceResolver;\n    }\n    \n    public NodePointer getParent() {\n        NodePointer pointer = parent;\n        while (pointer != null && pointer.isContainer()) {\n            pointer = pointer.getImmediateParentPointer();\n        }\n        return pointer;\n    }\n    \n    public NodePointer getImmediateParentPointer() {\n        return parent;\n    }\n\n    \n    public void setAttribute(boolean attribute) {\n        this.attribute = attribute;\n    }\n\n    \n    public boolean isAttribute() {\n        return attribute;\n    }\n\n    \n    public boolean isRoot() {\n        return parent == null;\n    }\n\n    \n    public abstract boolean isLeaf(); public boolean isNode() {\n        return !isContainer();\n    }\n     \n    \n    public boolean isContainer() {\n        return false;\n    }\n\n    \n    public int getIndex() {\n        return index;\n    }\n\n    public void setIndex(int index) {\n        this.index = index;\n    }\n\n    \n    public abstract boolean isCollection(); public abstract int getLength(); public Object getValue() {\n        NodePointer valuePointer = getValuePointer();\n        if (valuePointer != this) {\n            return valuePointer.getValue();\n        }\n        \n        return getNode();\n    }\n\n    \n    public NodePointer getValuePointer() {\n        NodePointer ivp = getImmediateValuePointer();\n        return ivp == this ? this : ivp.getValuePointer();\n    }\n\n    \n    public NodePointer getImmediateValuePointer() {\n        return this;\n    }\n    \n    \n    public boolean isActual() {\n        return index == WHOLE_COLLECTION || index >= 0 && index < getLength();\n    }\n\n    \n    public abstract QName getName(); public abstract Object getBaseValue(); public Object getNodeValue() {\n        return getNode();\n    }\n\n    \n    public Object getNode() {\n        return getValuePointer().getImmediateNode();\n    }\n    \n    public Object getRootNode() {\n        if (rootNode == null) {\n            rootNode = parent == null ? getImmediateNode() : parent.getRootNode();\n        }\n        return rootNode;\n    }\n    \n    \n    public abstract Object getImmediateNode(); public abstract void setValue(Object value); public abstract int compareChildNodePointers( NodePointer pointer1, NodePointer pointer2); public boolean testNode(NodeTest test) {\n        if (test == null) {\n            return true;\n        }\n        if (test instanceof NodeNameTest) {\n            if (isContainer()) {\n                return false;\n            }\n            NodeNameTest nodeNameTest = (NodeNameTest) test;\n            QName testName = nodeNameTest.getNodeName();\n            QName nodeName = getName();\n            if (nodeName == null) {\n                return false;\n            }\n            \n            String testPrefix = testName.getPrefix();\n            String nodePrefix = nodeName.getPrefix();\n            if (!equalStrings(testPrefix, nodePrefix)) {\n                String testNS = getNamespaceURI(testPrefix);\n                String nodeNS = getNamespaceURI(nodePrefix);\n                if (!equalStrings(testNS, nodeNS)) {\n                    return false;\n                }\n            }\n            if (nodeNameTest.isWildcard()) {\n                return true;\n            }\n            return testName.getName().equals(nodeName.getName());\n        }\n        return test instanceof NodeTypeTest\n                && ((NodeTypeTest) test).getNodeType() == Compiler.NODE_TYPE_NODE && isNode();\n    }\n\n    private static boolean equalStrings(String s1, String s2) {\n        return s1 == s2 || s1 != null && s1.equals(s2);\n    }\n\n    \n    public NodePointer createPath(JXPathContext context, Object value) {\n        setValue(value);\n        return this;\n    }\n\n    \n    public void remove() {\n        \n\n\n\n    }\n\n    \n    public NodePointer createPath(JXPathContext context) {\n        return this;\n    }\n\n    \n    public NodePointer createChild( JXPathContext context, QName name, int index, Object value) {\n        throw new JXPathException(\"Cannot create an object for path \"\n                + asPath() + \"/\" + name + \"[\" + (index + 1) + \"]\"\n                + \", operation is not allowed for this type of node\");\n    }\n\n    \n    public NodePointer createChild(JXPathContext context, QName name, int index) {\n        throw new JXPathException(\"Cannot create an object for path \"\n                + asPath() + \"/\" + name + \"[\" + (index + 1) + \"]\"\n                + \", operation is not allowed for this type of node\");\n    }\n    \n    \n    public NodePointer createAttribute(JXPathContext context, QName name) {\n        throw new JXPathException(\"Cannot create an attribute for path \"\n                + asPath() + \"/@\" + name\n                + \", operation is not allowed for this type of node\");\n    }\n\n    \n    public Locale getLocale() {\n        if (locale == null) {\n            if (parent != null) {\n                locale = parent.getLocale();\n            }\n        }\n        return locale;\n    }\n\n    \n    public boolean isLanguage(String lang) {\n        Locale loc = getLocale();\n        String name = loc.toString().replace('_', '-');\n        return name.toUpperCase().startsWith(lang.toUpperCase());\n    }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n    public NodeIterator childIterator( NodeTest test, boolean reverse, NodePointer startWith) {\n        NodePointer valuePointer = getValuePointer();\n        return valuePointer == null || valuePointer == this ? null\n                : valuePointer.childIterator(test, reverse, startWith);\n    }\n\n    \n    public NodeIterator attributeIterator(QName qname) {\n        NodePointer valuePointer = getValuePointer();\n        return valuePointer == null || valuePointer == this ? null\n                : valuePointer.attributeIterator(qname);\n    }\n\n    \n    public NodeIterator namespaceIterator() {\n        return null;\n    }\n\n    \n    public NodePointer namespacePointer(String namespace) {\n        return null;\n    }\n\n    \n    public String getNamespaceURI(String prefix) {\n        return null;\n    }\n\n    \n    public String getNamespaceURI() {\n        return null;\n    }\n\n    \n    protected boolean isDefaultNamespace(String prefix) {\n        if (prefix == null) {\n            return true;\n        }\n\n        String namespace = getNamespaceURI(prefix);\n        return namespace != null && namespace.equals(getDefaultNamespaceURI());\n    }\n\n    protected String getDefaultNamespaceURI() {\n        return null;\n    }\n\n    \n    public Pointer getPointerByID(JXPathContext context, String id) {\n        return context.getPointerByID(id);\n    }\n\n    \n    public Pointer getPointerByKey( JXPathContext context, String key, String value) {\n        return context.getPointerByKey(key, value);\n    }\n\n    \n    public String asPath() {\n        \n        \n        if (parent != null && parent.isContainer()) {\n            return parent.asPath();\n        }\n\n        StringBuffer buffer = new StringBuffer();\n        if (parent != null) {\n            buffer.append(parent.asPath());\n        }\n\n        if (buffer.length() == 0\n            || buffer.charAt(buffer.length() - 1) != '/') {\n            buffer.append('/');\n        }\n        if (attribute) {\n            buffer.append('@');\n        }\n        buffer.append(getName());\n\n        if (index != WHOLE_COLLECTION && isCollection()) {\n            buffer.append('[').append(index + 1).append(']');\n        }\n        return buffer.toString();\n    }\n\n    public Object clone() {\n        try {\n            NodePointer ptr = (NodePointer) super.clone();\n            if (parent != null) {\n                ptr.parent = (NodePointer) parent.clone();\n            }\n            return ptr;\n        }\n        catch (CloneNotSupportedException ex) {\n            \n            ex.printStackTrace();\n        }\n        return null;\n    }\n\n    public String toString() {\n        return asPath();\n    }\n\n    public int compareTo(Object object) {\n        \n        NodePointer pointer = (NodePointer) object;\n        if (parent == pointer.parent) {\n            return parent == null ? 0 : parent.compareChildNodePointers(this, pointer);\n        }\n\n        \n        int depth1 = 0;\n        NodePointer p1 = this;\n        while (p1 != null) {\n            depth1++;\n            p1 = p1.parent;\n        }\n        int depth2 = 0;\n        NodePointer p2 = pointer;\n        while (p2 != null) {\n            depth2++;\n            p2 = p2.parent;\n        }\n        return compareNodePointers(this, depth1, pointer, depth2);\n    }\n\n    private int compareNodePointers( NodePointer p1, int depth1, NodePointer p2, int depth2) {\n        if (depth1 < depth2) {\n            int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1);\n            return r == 0 ? -1 : r;\n        }\n        if (depth1 > depth2) {\n            int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2);\n            return r == 0 ? 1 : r;\n        }\n        if (p1 == null && p2 == null) {\n            return 0;\n        }\n\n        if (p1 != null && p1.equals(p2)) {\n            return 0;\n        }\n\n        if (depth1 == 1) {\n            throw new JXPathException(\n                    \"Cannot compare pointers that do not belong to the same tree: '\"\n                            + p1 + \"' and '\" + p2 + \"'\");\n        }\n        int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1);\n        if (r != 0) {\n            return r;\n        }\n\n        return p1.parent.compareChildNodePointers(p1, p2);\n    }\n\n    \n    public void printPointerChain() {\n        printDeep(this, \"\");\n    }\n\n    private static void printDeep(NodePointer pointer, String indent) {\n        if (indent.length() == 0) {\n            System.err.println(\n                \"POINTER: \"\n                    + pointer\n                    + \"(\"\n                    + pointer.getClass().getName()\n                    + \")\");\n        }\n        else {\n            System.err.println(\n                indent\n                    + \" of \"\n                    + pointer\n                    + \"(\"\n                    + pointer.getClass().getName()\n                    + \")\");\n        }\n        if (pointer.getImmediateParentPointer() != null) {\n            printDeep(pointer.getImmediateParentPointer(), indent + \"  \");\n        }\n    }\n}",
      "fixed_full_code": "\npackage org.apache.commons.jxpath.ri.model;\n\nimport java.util.Locale;\n\nimport org.apache.commons.jxpath.JXPathContext;\nimport org.apache.commons.jxpath.JXPathException;\nimport org.apache.commons.jxpath.Pointer;\nimport org.apache.commons.jxpath.ri.Compiler;\nimport org.apache.commons.jxpath.ri.JXPathContextReferenceImpl;\nimport org.apache.commons.jxpath.ri.NamespaceResolver;\nimport org.apache.commons.jxpath.ri.QName;\nimport org.apache.commons.jxpath.ri.compiler.NodeNameTest;\nimport org.apache.commons.jxpath.ri.compiler.NodeTest;\nimport org.apache.commons.jxpath.ri.compiler.NodeTypeTest;\nimport org.apache.commons.jxpath.ri.model.beans.NullPointer;\n\n\npublic abstract class NodePointer implements Pointer { public static final int WHOLE_COLLECTION = Integer.MIN_VALUE; protected int index = WHOLE_COLLECTION; public static final String UNKNOWN_NAMESPACE = \"<<unknown namespace>>\"; private boolean attribute = false; private transient Object rootNode; private NamespaceResolver namespaceResolver; public static NodePointer newNodePointer( QName name, Object bean, Locale locale) {\n        NodePointer pointer = null;\n        if (bean == null) {\n            pointer = new NullPointer(name, locale);\n            return pointer;\n        }\n        \n        NodePointerFactory[] factories =\n            JXPathContextReferenceImpl.getNodePointerFactories();\n        for (int i = 0; i < factories.length; i++) {\n            pointer = factories[i].createNodePointer(name, bean, locale);\n            if (pointer != null) {\n                return pointer;\n            }\n        }\n        throw new JXPathException(\n            \"Could not allocate a NodePointer for object of \"\n                + bean.getClass());\n    }\n\n    \n    public static NodePointer newChildNodePointer( NodePointer parent, QName name, Object bean) {\n        NodePointerFactory[] factories =\n            JXPathContextReferenceImpl.getNodePointerFactories();\n        for (int i = 0; i < factories.length; i++) {\n            NodePointer pointer =\n                factories[i].createNodePointer(parent, name, bean);\n            if (pointer != null) {\n                return pointer;\n            }\n        }\n        throw new JXPathException(\n            \"Could not allocate a NodePointer for object of \"\n                + bean.getClass());\n    }\n\n    protected NodePointer parent; protected Locale locale; protected NodePointer(NodePointer parent) {\n        this.parent = parent;\n    }\n\n    protected NodePointer(NodePointer parent, Locale locale) {\n        this.parent = parent;\n        this.locale = locale;\n    }\n\n    public NamespaceResolver getNamespaceResolver() {\n        if (namespaceResolver == null && parent != null) {\n            namespaceResolver = parent.getNamespaceResolver();\n        }\n        return namespaceResolver;\n    }\n    \n    public void setNamespaceResolver(NamespaceResolver namespaceResolver) {\n        this.namespaceResolver = namespaceResolver;\n    }\n    \n    public NodePointer getParent() {\n        NodePointer pointer = parent;\n        while (pointer != null && pointer.isContainer()) {\n            pointer = pointer.getImmediateParentPointer();\n        }\n        return pointer;\n    }\n    \n    public NodePointer getImmediateParentPointer() {\n        return parent;\n    }\n\n    \n    public void setAttribute(boolean attribute) {\n        this.attribute = attribute;\n    }\n\n    \n    public boolean isAttribute() {\n        return attribute;\n    }\n\n    \n    public boolean isRoot() {\n        return parent == null;\n    }\n\n    \n    public abstract boolean isLeaf(); public boolean isNode() {\n        return !isContainer();\n    }\n     \n    \n    public boolean isContainer() {\n        return false;\n    }\n\n    \n    public int getIndex() {\n        return index;\n    }\n\n    public void setIndex(int index) {\n        this.index = index;\n    }\n\n    \n    public abstract boolean isCollection(); public abstract int getLength(); public Object getValue() {\n        NodePointer valuePointer = getValuePointer();\n        if (valuePointer != this) {\n            return valuePointer.getValue();\n        }\n        \n        return getNode();\n    }\n\n    \n    public NodePointer getValuePointer() {\n        NodePointer ivp = getImmediateValuePointer();\n        return ivp == this ? this : ivp.getValuePointer();\n    }\n\n    \n    public NodePointer getImmediateValuePointer() {\n        return this;\n    }\n    \n    \n    public boolean isActual() {\n        return index == WHOLE_COLLECTION || index >= 0 && index < getLength();\n    }\n\n    \n    public abstract QName getName(); public abstract Object getBaseValue(); public Object getNodeValue() {\n        return getNode();\n    }\n\n    \n    public Object getNode() {\n        return getValuePointer().getImmediateNode();\n    }\n    \n    public Object getRootNode() {\n        if (rootNode == null) {\n            rootNode = parent == null ? getImmediateNode() : parent.getRootNode();\n        }\n        return rootNode;\n    }\n    \n    \n    public abstract Object getImmediateNode(); public abstract void setValue(Object value); public abstract int compareChildNodePointers( NodePointer pointer1, NodePointer pointer2); public boolean testNode(NodeTest test) {\n        if (test == null) {\n            return true;\n        }\n        if (test instanceof NodeNameTest) {\n            if (isContainer()) {\n                return false;\n            }\n            NodeNameTest nodeNameTest = (NodeNameTest) test;\n            QName testName = nodeNameTest.getNodeName();\n            QName nodeName = getName();\n            if (nodeName == null) {\n                return false;\n            }\n            \n            String testPrefix = testName.getPrefix();\n            String nodePrefix = nodeName.getPrefix();\n            if (!equalStrings(testPrefix, nodePrefix)) {\n                String testNS = getNamespaceURI(testPrefix);\n                String nodeNS = getNamespaceURI(nodePrefix);\n                if (!equalStrings(testNS, nodeNS)) {\n                    return false;\n                }\n            }\n            if (nodeNameTest.isWildcard()) {\n                return true;\n            }\n            return testName.getName().equals(nodeName.getName());\n        }\n        return test instanceof NodeTypeTest\n                && ((NodeTypeTest) test).getNodeType() == Compiler.NODE_TYPE_NODE && isNode();\n    }\n\n    private static boolean equalStrings(String s1, String s2) {\n        return s1 == s2 || s1 != null && s1.equals(s2);\n    }\n\n    \n    public NodePointer createPath(JXPathContext context, Object value) {\n        setValue(value);\n        return this;\n    }\n\n    \n    public void remove() {\n        \n\n\n\n    }\n\n    \n    public NodePointer createPath(JXPathContext context) {\n        return this;\n    }\n\n    \n    public NodePointer createChild( JXPathContext context, QName name, int index, Object value) {\n        throw new JXPathException(\"Cannot create an object for path \"\n                + asPath() + \"/\" + name + \"[\" + (index + 1) + \"]\"\n                + \", operation is not allowed for this type of node\");\n    }\n\n    \n    public NodePointer createChild(JXPathContext context, QName name, int index) {\n        throw new JXPathException(\"Cannot create an object for path \"\n                + asPath() + \"/\" + name + \"[\" + (index + 1) + \"]\"\n                + \", operation is not allowed for this type of node\");\n    }\n    \n    \n    public NodePointer createAttribute(JXPathContext context, QName name) {\n        throw new JXPathException(\"Cannot create an attribute for path \"\n                + asPath() + \"/@\" + name\n                + \", operation is not allowed for this type of node\");\n    }\n\n    \n    public Locale getLocale() {\n        if (locale == null) {\n            if (parent != null) {\n                locale = parent.getLocale();\n            }\n        }\n        return locale;\n    }\n\n    \n    public boolean isLanguage(String lang) {\n        Locale loc = getLocale();\n        String name = loc.toString().replace('_', '-');\n        return name.toUpperCase().startsWith(lang.toUpperCase());\n    }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n    public NodeIterator childIterator( NodeTest test, boolean reverse, NodePointer startWith) {\n        NodePointer valuePointer = getValuePointer();\n        return valuePointer == null || valuePointer == this ? null\n                : valuePointer.childIterator(test, reverse, startWith);\n    }\n\n    \n    public NodeIterator attributeIterator(QName qname) {\n        NodePointer valuePointer = getValuePointer();\n        return valuePointer == null || valuePointer == this ? null\n                : valuePointer.attributeIterator(qname);\n    }\n\n    \n    public NodeIterator namespaceIterator() {\n        return null;\n    }\n\n    \n    public NodePointer namespacePointer(String namespace) {\n        return null;\n    }\n\n    \n    public String getNamespaceURI(String prefix) {\n        return null;\n    }\n\n    \n    public String getNamespaceURI() {\n        return null;\n    }\n\n    \n    protected boolean isDefaultNamespace(String prefix) {\n        if (prefix == null) {\n            return true;\n        }\n\n        String namespace = getNamespaceURI(prefix);\n        return namespace != null && namespace.equals(getDefaultNamespaceURI());\n    }\n\n    protected String getDefaultNamespaceURI() {\n        return null;\n    }\n\n    \n    public Pointer getPointerByID(JXPathContext context, String id) {\n        return context.getPointerByID(id);\n    }\n\n    \n    public Pointer getPointerByKey( JXPathContext context, String key, String value) {\n        return context.getPointerByKey(key, value);\n    }\n\n    \n    public String asPath() {\n        \n        \n        if (parent != null && parent.isContainer()) {\n            return parent.asPath();\n        }\n\n        StringBuffer buffer = new StringBuffer();\n        if (parent != null) {\n            buffer.append(parent.asPath());\n        }\n\n        if (buffer.length() == 0\n            || buffer.charAt(buffer.length() - 1) != '/') {\n            buffer.append('/');\n        }\n        if (attribute) {\n            buffer.append('@');\n        }\n        buffer.append(getName());\n\n        if (index != WHOLE_COLLECTION && isCollection()) {\n            buffer.append('[').append(index + 1).append(']');\n        }\n        return buffer.toString();\n    }\n\n    public Object clone() {\n        try {\n            NodePointer ptr = (NodePointer) super.clone();\n            if (parent != null) {\n                ptr.parent = (NodePointer) parent.clone();\n            }\n            return ptr;\n        }\n        catch (CloneNotSupportedException ex) {\n            \n            ex.printStackTrace();\n        }\n        return null;\n    }\n\n    public String toString() {\n        return asPath();\n    }\n\n    public int compareTo(Object object) {\n        \n        NodePointer pointer = (NodePointer) object;\n        if (parent == pointer.parent) {\n            return parent == null ? 0 : parent.compareChildNodePointers(this, pointer);\n        }\n\n        \n        int depth1 = 0;\n        NodePointer p1 = this;\n        while (p1 != null) {\n            depth1++;\n            p1 = p1.parent;\n        }\n        int depth2 = 0;\n        NodePointer p2 = pointer;\n        while (p2 != null) {\n            depth2++;\n            p2 = p2.parent;\n        }\n        return compareNodePointers(this, depth1, pointer, depth2);\n    }\n\n    private int compareNodePointers( NodePointer p1, int depth1, NodePointer p2, int depth2) {\n        if (depth1 < depth2) {\n            int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1);\n            return r == 0 ? -1 : r;\n        }\n        if (depth1 > depth2) {\n            int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2);\n            return r == 0 ? 1 : r;\n        }\n        if (p1 == null && p2 == null) {\n            return 0;\n        }\n\n        if (p1 != null && p1.equals(p2)) {\n            return 0;\n        }\n\n        if (depth1 == 1) {\n            return 0;\n        }\n        int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1);\n        if (r != 0) {\n            return r;\n        }\n\n        return p1.parent.compareChildNodePointers(p1, p2);\n    }\n\n    \n    public void printPointerChain() {\n        printDeep(this, \"\");\n    }\n\n    private static void printDeep(NodePointer pointer, String indent) {\n        if (indent.length() == 0) {\n            System.err.println(\n                \"POINTER: \"\n                    + pointer\n                    + \"(\"\n                    + pointer.getClass().getName()\n                    + \")\");\n        }\n        else {\n            System.err.println(\n                indent\n                    + \" of \"\n                    + pointer\n                    + \"(\"\n                    + pointer.getClass().getName()\n                    + \")\");\n        }\n        if (pointer.getImmediateParentPointer() != null) {\n            printDeep(pointer.getImmediateParentPointer(), indent + \"  \");\n        }\n    }\n}",
      "buggy_signatures": [
        "public static NodePointer newChildNodePointer( NodePointer parent, QName name, Object bean)",
        "protected NodePointer parent; protected Locale locale; protected NodePointer(NodePointer parent)",
        "protected NodePointer(NodePointer parent, Locale locale)",
        "public NamespaceResolver getNamespaceResolver()",
        "public void setNamespaceResolver(NamespaceResolver namespaceResolver)",
        "public NodePointer getParent()",
        "public NodePointer getImmediateParentPointer()",
        "public void setAttribute(boolean attribute)",
        "public boolean isAttribute()",
        "public boolean isRoot()",
        "public abstract boolean isLeaf(); public boolean isNode()",
        "public boolean isContainer()",
        "public int getIndex()",
        "public void setIndex(int index)",
        "public abstract boolean isCollection(); public abstract int getLength(); public Object getValue()",
        "public NodePointer getValuePointer()",
        "public NodePointer getImmediateValuePointer()",
        "public boolean isActual()",
        "public abstract QName getName(); public abstract Object getBaseValue(); public Object getNodeValue()",
        "public Object getNode()",
        "public Object getRootNode()",
        "public abstract Object getImmediateNode(); public abstract void setValue(Object value); public abstract int compareChildNodePointers( NodePointer pointer1, NodePointer pointer2); public boolean testNode(NodeTest test)",
        "private static boolean equalStrings(String s1, String s2)",
        "public NodePointer createPath(JXPathContext context, Object value)",
        "public void remove()",
        "public NodePointer createPath(JXPathContext context)",
        "public NodePointer createChild( JXPathContext context, QName name, int index, Object value)",
        "public NodePointer createChild(JXPathContext context, QName name, int index)",
        "public NodePointer createAttribute(JXPathContext context, QName name)",
        "public Locale getLocale()",
        "public boolean isLanguage(String lang)",
        "public NodeIterator childIterator( NodeTest test, boolean reverse, NodePointer startWith)",
        "public NodeIterator attributeIterator(QName qname)",
        "public NodeIterator namespaceIterator()",
        "public NodePointer namespacePointer(String namespace)",
        "public String getNamespaceURI(String prefix)",
        "public String getNamespaceURI()",
        "protected boolean isDefaultNamespace(String prefix)",
        "protected String getDefaultNamespaceURI()",
        "public Pointer getPointerByID(JXPathContext context, String id)",
        "public Pointer getPointerByKey( JXPathContext context, String key, String value)",
        "public String asPath()",
        "public Object clone()",
        "public String toString()",
        "public int compareTo(Object object)",
        "private int compareNodePointers( NodePointer p1, int depth1, NodePointer p2, int depth2)",
        "public void printPointerChain()",
        "private static void printDeep(NodePointer pointer, String indent)"
      ],
      "fixed_signatures": [
        "public static NodePointer newChildNodePointer( NodePointer parent, QName name, Object bean)",
        "protected NodePointer parent; protected Locale locale; protected NodePointer(NodePointer parent)",
        "protected NodePointer(NodePointer parent, Locale locale)",
        "public NamespaceResolver getNamespaceResolver()",
        "public void setNamespaceResolver(NamespaceResolver namespaceResolver)",
        "public NodePointer getParent()",
        "public NodePointer getImmediateParentPointer()",
        "public void setAttribute(boolean attribute)",
        "public boolean isAttribute()",
        "public boolean isRoot()",
        "public abstract boolean isLeaf(); public boolean isNode()",
        "public boolean isContainer()",
        "public int getIndex()",
        "public void setIndex(int index)",
        "public abstract boolean isCollection(); public abstract int getLength(); public Object getValue()",
        "public NodePointer getValuePointer()",
        "public NodePointer getImmediateValuePointer()",
        "public boolean isActual()",
        "public abstract QName getName(); public abstract Object getBaseValue(); public Object getNodeValue()",
        "public Object getNode()",
        "public Object getRootNode()",
        "public abstract Object getImmediateNode(); public abstract void setValue(Object value); public abstract int compareChildNodePointers( NodePointer pointer1, NodePointer pointer2); public boolean testNode(NodeTest test)",
        "private static boolean equalStrings(String s1, String s2)",
        "public NodePointer createPath(JXPathContext context, Object value)",
        "public void remove()",
        "public NodePointer createPath(JXPathContext context)",
        "public NodePointer createChild( JXPathContext context, QName name, int index, Object value)",
        "public NodePointer createChild(JXPathContext context, QName name, int index)",
        "public NodePointer createAttribute(JXPathContext context, QName name)",
        "public Locale getLocale()",
        "public boolean isLanguage(String lang)",
        "public NodeIterator childIterator( NodeTest test, boolean reverse, NodePointer startWith)",
        "public NodeIterator attributeIterator(QName qname)",
        "public NodeIterator namespaceIterator()",
        "public NodePointer namespacePointer(String namespace)",
        "public String getNamespaceURI(String prefix)",
        "public String getNamespaceURI()",
        "protected boolean isDefaultNamespace(String prefix)",
        "protected String getDefaultNamespaceURI()",
        "public Pointer getPointerByID(JXPathContext context, String id)",
        "public Pointer getPointerByKey( JXPathContext context, String key, String value)",
        "public String asPath()",
        "public Object clone()",
        "public String toString()",
        "public int compareTo(Object object)",
        "private int compareNodePointers( NodePointer p1, int depth1, NodePointer p2, int depth2)",
        "public void printPointerChain()",
        "private static void printDeep(NodePointer pointer, String indent)"
      ],
      "methods": [
        {
          "buggy_method": "  private int compareNodePointers( NodePointer p1, int depth1, NodePointer p2, int depth2) {\n  if (depth1 < depth2) {\n  int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1);\n  return r == 0 ? -1 : r;\n  }\n  if (depth1 > depth2) {\n  int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2);\n  return r == 0 ? 1 : r;\n  }\n  if (p1 == null && p2 == null) {\n  return 0;\n  }\n\n  if (p1 != null && p1.equals(p2)) {\n  return 0;\n  }\n\n  if (depth1 == 1) {\n  throw new JXPathException(\n  \"Cannot compare pointers that do not belong to the same tree: '\"\n  + p1 + \"' and '\" + p2 + \"'\");\n  }\n  int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1);\n  if (r != 0) {\n  return r;\n  }\n\n  return p1.parent.compareChildNodePointers(p1, p2);\n  }",
          "fixed_method": "  private int compareNodePointers( NodePointer p1, int depth1, NodePointer p2, int depth2) {\n  if (depth1 < depth2) {\n  int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1);\n  return r == 0 ? -1 : r;\n  }\n  if (depth1 > depth2) {\n  int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2);\n  return r == 0 ? 1 : r;\n  }\n  if (p1 == null && p2 == null) {\n  return 0;\n  }\n\n  if (p1 != null && p1.equals(p2)) {\n  return 0;\n  }\n\n  if (depth1 == 1) {\n  return 0;\n  }\n  int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1);\n  if (r != 0) {\n  return r;\n  }\n\n  return p1.parent.compareChildNodePointers(p1, p2);\n  }",
          "diff": [
            "@@ -662,9 +662,7 @@",
            "         }\n",
            " \n",
            "         if (depth1 == 1) {\n",
            "-            throw new JXPathException(\n",
            "-                    \"Cannot compare pointers that do not belong to the same tree: '\"\n",
            "-                            + p1 + \"' and '\" + p2 + \"'\");\n",
            "+            return 0;\n",
            "         }\n",
            "         int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1);\n",
            "         if (r != 0) {\n"
          ],
          "changed_lines": 4
        }
      ]
    }
  ]
}
