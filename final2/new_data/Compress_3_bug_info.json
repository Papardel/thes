{
  "bug_id": "3",
  "failed_tests": {
    "org.apache.commons.compress.archivers.ArchiveOutputStreamTest": [
      {
        "methodName": "testFinish",
        "error": "junit.framework.AssertionFailedError",
        "message": "After putArchive should follow closeArchive",
        "fail_line": "            fail(\"After putArchive should follow closeArchive\");",
        "test_source": "  public void testFinish() throws Exception {\n  OutputStream out1 = new ByteArrayOutputStream();\n  \n  ArchiveOutputStream aos1 = factory.createArchiveOutputStream(\"zip\", out1);\n  aos1.putArchiveEntry(new ZipArchiveEntry(\"dummy\"));\n  try {\n  aos1.finish();\n  fail(\"After putArchive should follow closeArchive\");\n  } catch (IOException io) {\n  // Exception expected\n  }\n  \n  aos1 = factory.createArchiveOutputStream(\"jar\", out1);\n  aos1.putArchiveEntry(new JarArchiveEntry(\"dummy\"));\n  try {\n  aos1.finish();\n  fail(\"After putArchive should follow closeArchive\");\n  } catch (IOException io) {\n  // Exception expected\n  }\n  \n  aos1 = factory.createArchiveOutputStream(\"ar\", out1);\n  aos1.putArchiveEntry(new ArArchiveEntry(\"dummy\", 100));\n  try {\n  aos1.finish();\n  fail(\"After putArchive should follow closeArchive\");\n  } catch (IOException io) {\n  // Exception expected\n  }\n  \n  aos1 = factory.createArchiveOutputStream(\"cpio\", out1);\n  aos1.putArchiveEntry(new CpioArchiveEntry(\"dummy\"));\n  try {\n  aos1.finish();\n  fail(\"After putArchive should follow closeArchive\");\n  } catch (IOException io) {\n  // Exception expected\n  }\n  \n  aos1 = factory.createArchiveOutputStream(\"tar\", out1);\n  aos1.putArchiveEntry(new TarArchiveEntry(\"dummy\"));\n  try {\n  aos1.finish();\n  fail(\"After putArchive should follow closeArchive\");\n  } catch (IOException io) {\n  // Exception expected\n  }\n  }",
        "stack": [
          "ArchiveOutputStreamTest.testFinish line 67"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java",
      "buggy_full_code": "\npackage org.apache.commons.compress.archivers.tar;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport org.apache.commons.compress.archivers.ArchiveEntry;\nimport org.apache.commons.compress.archivers.ArchiveOutputStream;\n\n\npublic class TarArchiveOutputStream extends ArchiveOutputStream {\n    \n    public static final int LONGFILE_ERROR = 0;\n\n    \n    public static final int LONGFILE_TRUNCATE = 1;\n\n    \n    public static final int LONGFILE_GNU = 2;\n\n    private long      currSize;\n    private String    currName;\n    private long      currBytes;\n    private final byte[]    recordBuf;\n    private int       assemLen;\n    private final byte[]    assemBuf;\n    protected final TarBuffer buffer;\n    private int       longFileMode = LONGFILE_ERROR;\n\n    private boolean closed = false;\n\n    \n    \n    private final OutputStream out;\n\n    \n    public TarArchiveOutputStream(OutputStream os) {\n        this(os, TarBuffer.DEFAULT_BLKSIZE, TarBuffer.DEFAULT_RCDSIZE);\n    }\n\n    \n    public TarArchiveOutputStream(OutputStream os, int blockSize) {\n        this(os, blockSize, TarBuffer.DEFAULT_RCDSIZE);\n    }\n\n    \n    public TarArchiveOutputStream(OutputStream os, int blockSize, int recordSize) {\n        out = os;\n\n        this.buffer = new TarBuffer(os, blockSize, recordSize);\n        this.assemLen = 0;\n        this.assemBuf = new byte[recordSize];\n        this.recordBuf = new byte[recordSize];\n    }\n\n    \n    public void setLongFileMode(int longFileMode) {\n        this.longFileMode = longFileMode;\n    }\n\n\n    \n    public void finish() throws IOException {\n        writeEOFRecord();\n        writeEOFRecord();\n    }\n\n    \n    public void close() throws IOException {\n        if (!closed) {\n            finish();\n            buffer.close();\n            out.close();\n            closed = true;\n        }\n    }\n\n    \n    public int getRecordSize() {\n        return buffer.getRecordSize();\n    }\n\n    \n    public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException {\n        TarArchiveEntry entry = (TarArchiveEntry) archiveEntry;\n        if (entry.getName().length() >= TarConstants.NAMELEN) {\n\n            if (longFileMode == LONGFILE_GNU) {\n                \n                \n                TarArchiveEntry longLinkEntry = new TarArchiveEntry(TarConstants.GNU_LONGLINK,\n                                                                    TarConstants.LF_GNUTYPE_LONGNAME);\n\n                final byte[] nameBytes = entry.getName().getBytes(); \n                longLinkEntry.setSize(nameBytes.length + 1); \n                putArchiveEntry(longLinkEntry);\n                write(nameBytes);\n                write(0); \n                closeArchiveEntry();\n            } else if (longFileMode != LONGFILE_TRUNCATE) {\n                throw new RuntimeException(\"file name '\" + entry.getName()\n                                           + \"' is too long ( > \"\n                                           + TarConstants.NAMELEN + \" bytes)\");\n            }\n        }\n\n        entry.writeEntryHeader(recordBuf);\n        buffer.writeRecord(recordBuf);\n\n        currBytes = 0;\n\n        if (entry.isDirectory()) {\n            currSize = 0;\n        } else {\n            currSize = entry.getSize();\n        }\n        currName = entry.getName();\n    }\n\n    \n    public void closeArchiveEntry() throws IOException {\n        if (assemLen > 0) {\n            for (int i = assemLen; i < assemBuf.length; ++i) {\n                assemBuf[i] = 0;\n            }\n\n            buffer.writeRecord(assemBuf);\n\n            currBytes += assemLen;\n            assemLen = 0;\n        }\n\n        if (currBytes < currSize) {\n            throw new IOException(\"entry '\" + currName + \"' closed at '\"\n                                  + currBytes\n                                  + \"' before the '\" + currSize\n                                  + \"' bytes specified in the header were written\");\n        }\n    }\n\n    \n    public void write(byte[] wBuf, int wOffset, int numToWrite) throws IOException {\n        if ((currBytes + numToWrite) > currSize) {\n            throw new IOException(\"request to write '\" + numToWrite\n                                  + \"' bytes exceeds size in header of '\"\n                                  + currSize + \"' bytes for entry '\"\n                                  + currName + \"'\");\n\n            \n            \n            \n            \n            \n            \n            \n        }\n\n        if (assemLen > 0) {\n            if ((assemLen + numToWrite) >= recordBuf.length) {\n                int aLen = recordBuf.length - assemLen;\n\n                System.arraycopy(assemBuf, 0, recordBuf, 0,\n                                 assemLen);\n                System.arraycopy(wBuf, wOffset, recordBuf,\n                                 assemLen, aLen);\n                buffer.writeRecord(recordBuf);\n\n                currBytes += recordBuf.length;\n                wOffset += aLen;\n                numToWrite -= aLen;\n                assemLen = 0;\n            } else {\n                System.arraycopy(wBuf, wOffset, assemBuf, assemLen,\n                                 numToWrite);\n\n                wOffset += numToWrite;\n                assemLen += numToWrite;\n                numToWrite = 0;\n            }\n        }\n\n        \n        \n        \n        \n        \n        while (numToWrite > 0) {\n            if (numToWrite < recordBuf.length) {\n                System.arraycopy(wBuf, wOffset, assemBuf, assemLen,\n                                 numToWrite);\n\n                assemLen += numToWrite;\n\n                break;\n            }\n\n            buffer.writeRecord(wBuf, wOffset);\n\n            int num = recordBuf.length;\n\n            currBytes += num;\n            numToWrite -= num;\n            wOffset += num;\n        }\n    }\n\n    \n    private void writeEOFRecord() throws IOException {\n        for (int i = 0; i < recordBuf.length; ++i) {\n            recordBuf[i] = 0;\n        }\n\n        buffer.writeRecord(recordBuf);\n    }\n\n    \n    public void flush() throws IOException {\n        out.flush();\n    }\n\n    public ArchiveEntry createArchiveEntry(File inputFile, String entryName)\n            throws IOException {\n        return new TarArchiveEntry(inputFile, entryName);\n    }\n}\n",
      "fixed_full_code": "\npackage org.apache.commons.compress.archivers.tar;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport org.apache.commons.compress.archivers.ArchiveEntry;\nimport org.apache.commons.compress.archivers.ArchiveOutputStream;\n\n\npublic class TarArchiveOutputStream extends ArchiveOutputStream {\n    \n    public static final int LONGFILE_ERROR = 0;\n\n    \n    public static final int LONGFILE_TRUNCATE = 1;\n\n    \n    public static final int LONGFILE_GNU = 2;\n\n    private long      currSize;\n    private String    currName;\n    private long      currBytes;\n    private final byte[]    recordBuf;\n    private int       assemLen;\n    private final byte[]    assemBuf;\n    protected final TarBuffer buffer;\n    private int       longFileMode = LONGFILE_ERROR;\n\n    private boolean closed = false;\n\n    \n    private boolean haveUnclosedEntry = false;\n    \n    private final OutputStream out;\n\n    \n    public TarArchiveOutputStream(OutputStream os) {\n        this(os, TarBuffer.DEFAULT_BLKSIZE, TarBuffer.DEFAULT_RCDSIZE);\n    }\n\n    \n    public TarArchiveOutputStream(OutputStream os, int blockSize) {\n        this(os, blockSize, TarBuffer.DEFAULT_RCDSIZE);\n    }\n\n    \n    public TarArchiveOutputStream(OutputStream os, int blockSize, int recordSize) {\n        out = os;\n\n        this.buffer = new TarBuffer(os, blockSize, recordSize);\n        this.assemLen = 0;\n        this.assemBuf = new byte[recordSize];\n        this.recordBuf = new byte[recordSize];\n    }\n\n    \n    public void setLongFileMode(int longFileMode) {\n        this.longFileMode = longFileMode;\n    }\n\n\n    \n    public void finish() throws IOException {\n        if(haveUnclosedEntry) {\n            throw new IOException(\"This archives contains unclosed entries.\");\n        }\n        writeEOFRecord();\n        writeEOFRecord();\n    }\n\n    \n    public void close() throws IOException {\n        if (!closed) {\n            finish();\n            buffer.close();\n            out.close();\n            closed = true;\n        }\n    }\n\n    \n    public int getRecordSize() {\n        return buffer.getRecordSize();\n    }\n\n    \n    public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException {\n        TarArchiveEntry entry = (TarArchiveEntry) archiveEntry;\n        if (entry.getName().length() >= TarConstants.NAMELEN) {\n\n            if (longFileMode == LONGFILE_GNU) {\n                \n                \n                TarArchiveEntry longLinkEntry = new TarArchiveEntry(TarConstants.GNU_LONGLINK,\n                                                                    TarConstants.LF_GNUTYPE_LONGNAME);\n\n                final byte[] nameBytes = entry.getName().getBytes(); \n                longLinkEntry.setSize(nameBytes.length + 1); \n                putArchiveEntry(longLinkEntry);\n                write(nameBytes);\n                write(0); \n                closeArchiveEntry();\n            } else if (longFileMode != LONGFILE_TRUNCATE) {\n                throw new RuntimeException(\"file name '\" + entry.getName()\n                                           + \"' is too long ( > \"\n                                           + TarConstants.NAMELEN + \" bytes)\");\n            }\n        }\n\n        entry.writeEntryHeader(recordBuf);\n        buffer.writeRecord(recordBuf);\n\n        currBytes = 0;\n\n        if (entry.isDirectory()) {\n            currSize = 0;\n        } else {\n            currSize = entry.getSize();\n        }\n        currName = entry.getName();\n        haveUnclosedEntry = true;\n    }\n\n    \n    public void closeArchiveEntry() throws IOException {\n        if (assemLen > 0) {\n            for (int i = assemLen; i < assemBuf.length; ++i) {\n                assemBuf[i] = 0;\n            }\n\n            buffer.writeRecord(assemBuf);\n\n            currBytes += assemLen;\n            assemLen = 0;\n        }\n\n        if (currBytes < currSize) {\n            throw new IOException(\"entry '\" + currName + \"' closed at '\"\n                                  + currBytes\n                                  + \"' before the '\" + currSize\n                                  + \"' bytes specified in the header were written\");\n        }\n        haveUnclosedEntry = false;\n    }\n\n    \n    public void write(byte[] wBuf, int wOffset, int numToWrite) throws IOException {\n        if ((currBytes + numToWrite) > currSize) {\n            throw new IOException(\"request to write '\" + numToWrite\n                                  + \"' bytes exceeds size in header of '\"\n                                  + currSize + \"' bytes for entry '\"\n                                  + currName + \"'\");\n\n            \n            \n            \n            \n            \n            \n            \n        }\n\n        if (assemLen > 0) {\n            if ((assemLen + numToWrite) >= recordBuf.length) {\n                int aLen = recordBuf.length - assemLen;\n\n                System.arraycopy(assemBuf, 0, recordBuf, 0,\n                                 assemLen);\n                System.arraycopy(wBuf, wOffset, recordBuf,\n                                 assemLen, aLen);\n                buffer.writeRecord(recordBuf);\n\n                currBytes += recordBuf.length;\n                wOffset += aLen;\n                numToWrite -= aLen;\n                assemLen = 0;\n            } else {\n                System.arraycopy(wBuf, wOffset, assemBuf, assemLen,\n                                 numToWrite);\n\n                wOffset += numToWrite;\n                assemLen += numToWrite;\n                numToWrite = 0;\n            }\n        }\n\n        \n        \n        \n        \n        \n        while (numToWrite > 0) {\n            if (numToWrite < recordBuf.length) {\n                System.arraycopy(wBuf, wOffset, assemBuf, assemLen,\n                                 numToWrite);\n\n                assemLen += numToWrite;\n\n                break;\n            }\n\n            buffer.writeRecord(wBuf, wOffset);\n\n            int num = recordBuf.length;\n\n            currBytes += num;\n            numToWrite -= num;\n            wOffset += num;\n        }\n    }\n\n    \n    private void writeEOFRecord() throws IOException {\n        for (int i = 0; i < recordBuf.length; ++i) {\n            recordBuf[i] = 0;\n        }\n\n        buffer.writeRecord(recordBuf);\n    }\n\n    \n    public void flush() throws IOException {\n        out.flush();\n    }\n\n    public ArchiveEntry createArchiveEntry(File inputFile, String entryName)\n            throws IOException {\n        return new TarArchiveEntry(inputFile, entryName);\n    }\n}\n",
      "buggy_signatures": [
        "public TarArchiveOutputStream(OutputStream os)",
        "public TarArchiveOutputStream(OutputStream os, int blockSize)",
        "public TarArchiveOutputStream(OutputStream os, int blockSize, int recordSize)",
        "public void setLongFileMode(int longFileMode)",
        "public void finish() throws IOException",
        "public void close() throws IOException",
        "public int getRecordSize()",
        "public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException",
        "public void closeArchiveEntry() throws IOException",
        "public void write(byte[] wBuf, int wOffset, int numToWrite) throws IOException",
        "private void writeEOFRecord() throws IOException",
        "public void flush() throws IOException",
        "public ArchiveEntry createArchiveEntry(File inputFile, String entryName)"
      ],
      "fixed_signatures": [
        "public TarArchiveOutputStream(OutputStream os)",
        "public TarArchiveOutputStream(OutputStream os, int blockSize)",
        "public TarArchiveOutputStream(OutputStream os, int blockSize, int recordSize)",
        "public void setLongFileMode(int longFileMode)",
        "public void finish() throws IOException",
        "public void close() throws IOException",
        "public int getRecordSize()",
        "public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException",
        "public void closeArchiveEntry() throws IOException",
        "public void write(byte[] wBuf, int wOffset, int numToWrite) throws IOException",
        "private void writeEOFRecord() throws IOException",
        "public void flush() throws IOException",
        "public ArchiveEntry createArchiveEntry(File inputFile, String entryName)"
      ],
      "methods": [
        {
          "buggy_method": "  public void finish() throws IOException {\n  writeEOFRecord();\n  writeEOFRecord();\n  }",
          "fixed_method": "  public void finish() throws IOException {\n  if(haveUnclosedEntry) {\n  throw new IOException(\"This archives contains unclosed entries.\");\n  }\n  writeEOFRecord();\n  writeEOFRecord();\n  }",
          "diff": [
            "@@ -109,6 +110,9 @@",
            "      * @throws IOException on error\n",
            "      */\n",
            "     public void finish() throws IOException {\n",
            "+        if(haveUnclosedEntry) {\n",
            "+            throw new IOException(\"This archives contains unclosed entries.\");\n",
            "+        }\n",
            "         writeEOFRecord();\n",
            "         writeEOFRecord();\n",
            "     }\n"
          ],
          "changed_lines": 3
        },
        {
          "buggy_method": "  public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException {\n  TarArchiveEntry entry = (TarArchiveEntry) archiveEntry;\n  if (entry.getName().length() >= TarConstants.NAMELEN) {\n\n  if (longFileMode == LONGFILE_GNU) {\n  \n  \n  TarArchiveEntry longLinkEntry = new TarArchiveEntry(TarConstants.GNU_LONGLINK,\n  TarConstants.LF_GNUTYPE_LONGNAME);\n\n  final byte[] nameBytes = entry.getName().getBytes(); \n  longLinkEntry.setSize(nameBytes.length + 1); \n  putArchiveEntry(longLinkEntry);\n  write(nameBytes);\n  write(0); \n  closeArchiveEntry();\n  } else if (longFileMode != LONGFILE_TRUNCATE) {\n  throw new RuntimeException(\"file name '\" + entry.getName()\n  + \"' is too long ( > \"\n  + TarConstants.NAMELEN + \" bytes)\");\n  }\n  }\n\n  entry.writeEntryHeader(recordBuf);\n  buffer.writeRecord(recordBuf);\n\n  currBytes = 0;\n\n  if (entry.isDirectory()) {\n  currSize = 0;\n  } else {\n  currSize = entry.getSize();\n  }\n  currName = entry.getName();\n  }",
          "fixed_method": "  public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException {\n  TarArchiveEntry entry = (TarArchiveEntry) archiveEntry;\n  if (entry.getName().length() >= TarConstants.NAMELEN) {\n\n  if (longFileMode == LONGFILE_GNU) {\n  \n  \n  TarArchiveEntry longLinkEntry = new TarArchiveEntry(TarConstants.GNU_LONGLINK,\n  TarConstants.LF_GNUTYPE_LONGNAME);\n\n  final byte[] nameBytes = entry.getName().getBytes(); \n  longLinkEntry.setSize(nameBytes.length + 1); \n  putArchiveEntry(longLinkEntry);\n  write(nameBytes);\n  write(0); \n  closeArchiveEntry();\n  } else if (longFileMode != LONGFILE_TRUNCATE) {\n  throw new RuntimeException(\"file name '\" + entry.getName()\n  + \"' is too long ( > \"\n  + TarConstants.NAMELEN + \" bytes)\");\n  }\n  }\n\n  entry.writeEntryHeader(recordBuf);\n  buffer.writeRecord(recordBuf);\n\n  currBytes = 0;\n\n  if (entry.isDirectory()) {\n  currSize = 0;\n  } else {\n  currSize = entry.getSize();\n  }\n  currName = entry.getName();\n  haveUnclosedEntry = true;\n  }",
          "diff": [
            "@@ -184,6 +188,7 @@",
            "             currSize = entry.getSize();\n",
            "         }\n",
            "         currName = entry.getName();\n",
            "+        haveUnclosedEntry = true;\n",
            "     }\n",
            " \n",
            "     /**\n"
          ],
          "changed_lines": 1
        },
        {
          "buggy_method": "  public void closeArchiveEntry() throws IOException {\n  if (assemLen > 0) {\n  for (int i = assemLen; i < assemBuf.length; ++i) {\n  assemBuf[i] = 0;\n  }\n\n  buffer.writeRecord(assemBuf);\n\n  currBytes += assemLen;\n  assemLen = 0;\n  }\n\n  if (currBytes < currSize) {\n  throw new IOException(\"entry '\" + currName + \"' closed at '\"\n  + currBytes\n  + \"' before the '\" + currSize\n  + \"' bytes specified in the header were written\");\n  }\n  }",
          "fixed_method": "  public void closeArchiveEntry() throws IOException {\n  if (assemLen > 0) {\n  for (int i = assemLen; i < assemBuf.length; ++i) {\n  assemBuf[i] = 0;\n  }\n\n  buffer.writeRecord(assemBuf);\n\n  currBytes += assemLen;\n  assemLen = 0;\n  }\n\n  if (currBytes < currSize) {\n  throw new IOException(\"entry '\" + currName + \"' closed at '\"\n  + currBytes\n  + \"' before the '\" + currSize\n  + \"' bytes specified in the header were written\");\n  }\n  haveUnclosedEntry = false;\n  }",
          "diff": [
            "@@ -214,6 +219,7 @@",
            "                                   + \"' before the '\" + currSize\n",
            "                                   + \"' bytes specified in the header were written\");\n",
            "         }\n",
            "+        haveUnclosedEntry = false;\n",
            "     }\n",
            " \n",
            "     /**\n"
          ],
          "changed_lines": 1
        }
      ]
    }
  ]
}