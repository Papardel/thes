{
  "bug_id": "4",
  "failed_tests": {
    "org.apache.commons.cli.OptionsTest": [
      {
        "methodName": "testMissingOptionsException",
        "error": "junit.framework.ComparisonFailure",
        "message": "expected:<[Missing required options: ]fx> but was:<[]fx>",
        "fail_line": "            assertEquals(\"Missing required options: fx\", e.getMessage());",
        "test_source": "  public void testMissingOptionsException() throws ParseException {\n  Options options = new Options();\n  options.addOption(OptionBuilder.isRequired().create(\"f\"));\n  options.addOption(OptionBuilder.isRequired().create(\"x\"));\n  try {\n  new PosixParser().parse(options, new String[0]);\n  fail(\"Expected MissingOptionException to be thrown\");\n  } catch (MissingOptionException e) {\n  assertEquals(\"Missing required options: fx\", e.getMessage());\n  }\n  }",
        "stack": [
          "OptionsTest.testMissingOptionsException line 116"
        ]
      },
      {
        "methodName": "testMissingOptionException",
        "error": "junit.framework.ComparisonFailure",
        "message": "expected:<[Missing required option: ]f> but was:<[]f>",
        "fail_line": "            assertEquals(\"Missing required option: f\", e.getMessage());",
        "test_source": "  public void testMissingOptionException() throws ParseException {\n  Options options = new Options();\n  options.addOption(OptionBuilder.isRequired().create(\"f\"));\n  try {\n  new PosixParser().parse(options, new String[0]);\n  fail(\"Expected MissingOptionException to be thrown\");\n  } catch (MissingOptionException e) {\n  assertEquals(\"Missing required option: f\", e.getMessage());\n  }\n  }",
        "stack": [
          "OptionsTest.testMissingOptionException line 104"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/cli/Parser.java",
      "buggy_full_code": "\npackage org.apache.commons.cli;\n\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Properties;\n\n\npublic abstract class Parser implements CommandLineParser {\n\n    \n    private CommandLine cmd;\n\n    \n    private Options options;\n\n    \n    private List requiredOptions;\n\n    \n    protected abstract String[] flatten(Options opts, String[] arguments, \n                                        boolean stopAtNonOption);\n\n    \n    public CommandLine parse(Options options, String[] arguments)\n                      throws ParseException\n    {\n        return parse(options, arguments, null, false);\n    }\n\n    \n    public CommandLine parse(Options options, String[] arguments, \n                             Properties properties)\n        throws ParseException\n    {\n        return parse(options, arguments, properties, false);\n    }\n\n    \n    public CommandLine parse(Options options, String[] arguments, \n                             boolean stopAtNonOption)\n        throws ParseException\n    {\n        return parse(options, arguments, null, stopAtNonOption);\n    }\n\n    \n    public CommandLine parse(Options options, String[] arguments, \n                             Properties properties, boolean stopAtNonOption)\n        throws ParseException\n    {\n        \n        this.options = options;\n\n        \n        for (Iterator it = options.helpOptions().iterator(); it.hasNext();) {\n            Option opt = (Option) it.next();\n            opt.clearValues();\n        }\n\n        requiredOptions = options.getRequiredOptions();\n        cmd = new CommandLine();\n\n        boolean eatTheRest = false;\n\n        if (arguments == null)\n        {\n            arguments = new String[0];\n        }\n\n        List tokenList = Arrays.asList(flatten(this.options, \n                                               arguments, \n                                               stopAtNonOption));\n\n        ListIterator iterator = tokenList.listIterator();\n\n        \n        while (iterator.hasNext())\n        {\n            String t = (String) iterator.next();\n\n            \n            if (\"--\".equals(t))\n            {\n                eatTheRest = true;\n            }\n\n            \n            else if (\"-\".equals(t))\n            {\n                if (stopAtNonOption)\n                {\n                    eatTheRest = true;\n                }\n                else\n                {\n                    cmd.addArg(t);\n                }\n            }\n\n            \n            else if (t.startsWith(\"-\"))\n            {\n                if (stopAtNonOption && !options.hasOption(t))\n                {\n                    eatTheRest = true;\n                    cmd.addArg(t);\n                }\n                else\n                {\n                    processOption(t, iterator);\n                }\n            }\n\n            \n            else\n            {\n                cmd.addArg(t);\n\n                if (stopAtNonOption)\n                {\n                    eatTheRest = true;\n                }\n            }\n\n            \n            if (eatTheRest)\n            {\n                while (iterator.hasNext())\n                {\n                    String str = (String) iterator.next();\n\n                    \n                    if (!\"--\".equals(str))\n                    {\n                        cmd.addArg(str);\n                    }\n                }\n            }\n        }\n\n        processProperties(properties);\n        checkRequiredOptions();\n\n        return cmd;\n    }\n\n    \n    private void processProperties(Properties properties)\n    {\n        if (properties == null)\n        {\n            return;\n        }\n\n        for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n        {\n            String option = e.nextElement().toString();\n\n            if (!cmd.hasOption(option))\n            {\n                Option opt = options.getOption(option);\n\n                \n                String value = properties.getProperty(option);\n\n                if (opt.hasArg())\n                {\n                    if ((opt.getValues() == null)\n                        || (opt.getValues().length == 0))\n                    {\n                        try\n                        {\n                            opt.addValue(value);\n                        }\n                        catch (RuntimeException exp)\n                        {\n                            \n                        }\n                    }\n                }\n                else if (!(\"yes\".equalsIgnoreCase(value) \n                           || \"true\".equalsIgnoreCase(value)\n                           || \"1\".equalsIgnoreCase(value)))\n                {\n                    \n                    \n                    break;\n                }\n\n                cmd.addOption(opt);\n            }\n        }\n    }\n\n    \n    private void checkRequiredOptions()\n        throws MissingOptionException\n    {\n        \n        \n        if (requiredOptions.size() > 0)\n        {\n            Iterator iter = requiredOptions.iterator();\n            StringBuffer buff = new StringBuffer();\n\n\n            \n            while (iter.hasNext())\n            {\n                buff.append(iter.next());\n            }\n\n            throw new MissingOptionException(buff.toString());\n        }\n    }\n\n    \n    public void processArgs(Option opt, ListIterator iter)\n        throws ParseException\n    {\n        \n        while (iter.hasNext())\n        {\n            String str = (String) iter.next();\n\n            \n            if (options.hasOption(str) && str.startsWith(\"-\"))\n            {\n                iter.previous();\n                break;\n            }\n\n            \n            try\n            {\n                opt.addValue( Util.stripLeadingAndTrailingQuotes(str) );\n            }\n            catch (RuntimeException exp)\n            {\n                iter.previous();\n                break;\n            }\n        }\n\n        if ((opt.getValues() == null) && !opt.hasOptionalArg())\n        {\n            throw new MissingArgumentException(\"Missing argument for option:\"\n                                               + opt.getKey());\n        }\n    }\n\n    \n    private void processOption(String arg, ListIterator iter)\n        throws ParseException\n    {\n        boolean hasOption = options.hasOption(arg);\n\n        \n        if (!hasOption)\n        {\n            throw new UnrecognizedOptionException(\"Unrecognized option: \" \n                                                  + arg);\n        }\n        \n        \n        final Option opt = options.getOption(arg);\n\n        \n        \n        if (opt.isRequired())\n        {\n            requiredOptions.remove(opt.getKey());\n        }\n\n        \n        \n        if (options.getOptionGroup(opt) != null)\n        {\n            OptionGroup group = options.getOptionGroup(opt);\n\n            if (group.isRequired())\n            {\n                requiredOptions.remove(group);\n            }\n\n            group.setSelected(opt);\n        }\n\n        \n        if (opt.hasArg())\n        {\n            processArgs(opt, iter);\n        }\n\n\n        \n        cmd.addOption(opt);\n    }\n}\n",
      "fixed_full_code": "\npackage org.apache.commons.cli;\n\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Properties;\n\n\npublic abstract class Parser implements CommandLineParser {\n\n    \n    private CommandLine cmd;\n\n    \n    private Options options;\n\n    \n    private List requiredOptions;\n\n    \n    protected abstract String[] flatten(Options opts, String[] arguments, \n                                        boolean stopAtNonOption);\n\n    \n    public CommandLine parse(Options options, String[] arguments)\n                      throws ParseException\n    {\n        return parse(options, arguments, null, false);\n    }\n\n    \n    public CommandLine parse(Options options, String[] arguments, \n                             Properties properties)\n        throws ParseException\n    {\n        return parse(options, arguments, properties, false);\n    }\n\n    \n    public CommandLine parse(Options options, String[] arguments, \n                             boolean stopAtNonOption)\n        throws ParseException\n    {\n        return parse(options, arguments, null, stopAtNonOption);\n    }\n\n    \n    public CommandLine parse(Options options, String[] arguments, \n                             Properties properties, boolean stopAtNonOption)\n        throws ParseException\n    {\n        \n        this.options = options;\n\n        \n        for (Iterator it = options.helpOptions().iterator(); it.hasNext();) {\n            Option opt = (Option) it.next();\n            opt.clearValues();\n        }\n\n        requiredOptions = options.getRequiredOptions();\n        cmd = new CommandLine();\n\n        boolean eatTheRest = false;\n\n        if (arguments == null)\n        {\n            arguments = new String[0];\n        }\n\n        List tokenList = Arrays.asList(flatten(this.options, \n                                               arguments, \n                                               stopAtNonOption));\n\n        ListIterator iterator = tokenList.listIterator();\n\n        \n        while (iterator.hasNext())\n        {\n            String t = (String) iterator.next();\n\n            \n            if (\"--\".equals(t))\n            {\n                eatTheRest = true;\n            }\n\n            \n            else if (\"-\".equals(t))\n            {\n                if (stopAtNonOption)\n                {\n                    eatTheRest = true;\n                }\n                else\n                {\n                    cmd.addArg(t);\n                }\n            }\n\n            \n            else if (t.startsWith(\"-\"))\n            {\n                if (stopAtNonOption && !options.hasOption(t))\n                {\n                    eatTheRest = true;\n                    cmd.addArg(t);\n                }\n                else\n                {\n                    processOption(t, iterator);\n                }\n            }\n\n            \n            else\n            {\n                cmd.addArg(t);\n\n                if (stopAtNonOption)\n                {\n                    eatTheRest = true;\n                }\n            }\n\n            \n            if (eatTheRest)\n            {\n                while (iterator.hasNext())\n                {\n                    String str = (String) iterator.next();\n\n                    \n                    if (!\"--\".equals(str))\n                    {\n                        cmd.addArg(str);\n                    }\n                }\n            }\n        }\n\n        processProperties(properties);\n        checkRequiredOptions();\n\n        return cmd;\n    }\n\n    \n    private void processProperties(Properties properties)\n    {\n        if (properties == null)\n        {\n            return;\n        }\n\n        for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n        {\n            String option = e.nextElement().toString();\n\n            if (!cmd.hasOption(option))\n            {\n                Option opt = options.getOption(option);\n\n                \n                String value = properties.getProperty(option);\n\n                if (opt.hasArg())\n                {\n                    if ((opt.getValues() == null)\n                        || (opt.getValues().length == 0))\n                    {\n                        try\n                        {\n                            opt.addValue(value);\n                        }\n                        catch (RuntimeException exp)\n                        {\n                            \n                        }\n                    }\n                }\n                else if (!(\"yes\".equalsIgnoreCase(value) \n                           || \"true\".equalsIgnoreCase(value)\n                           || \"1\".equalsIgnoreCase(value)))\n                {\n                    \n                    \n                    break;\n                }\n\n                cmd.addOption(opt);\n            }\n        }\n    }\n\n    \n    private void checkRequiredOptions()\n        throws MissingOptionException\n    {\n        \n        \n        if (requiredOptions.size() > 0)\n        {\n            Iterator iter = requiredOptions.iterator();\n            StringBuffer buff = new StringBuffer(\"Missing required option\");\n            buff.append(requiredOptions.size() == 1 ? \"\" : \"s\");\n            buff.append(\": \");\n\n\n            \n            while (iter.hasNext())\n            {\n                buff.append(iter.next());\n            }\n\n            throw new MissingOptionException(buff.toString());\n        }\n    }\n\n    \n    public void processArgs(Option opt, ListIterator iter)\n        throws ParseException\n    {\n        \n        while (iter.hasNext())\n        {\n            String str = (String) iter.next();\n\n            \n            if (options.hasOption(str) && str.startsWith(\"-\"))\n            {\n                iter.previous();\n                break;\n            }\n\n            \n            try\n            {\n                opt.addValue( Util.stripLeadingAndTrailingQuotes(str) );\n            }\n            catch (RuntimeException exp)\n            {\n                iter.previous();\n                break;\n            }\n        }\n\n        if ((opt.getValues() == null) && !opt.hasOptionalArg())\n        {\n            throw new MissingArgumentException(\"Missing argument for option:\"\n                                               + opt.getKey());\n        }\n    }\n\n    \n    private void processOption(String arg, ListIterator iter)\n        throws ParseException\n    {\n        boolean hasOption = options.hasOption(arg);\n\n        \n        if (!hasOption)\n        {\n            throw new UnrecognizedOptionException(\"Unrecognized option: \" \n                                                  + arg);\n        }\n        \n        \n        final Option opt = options.getOption(arg);\n\n        \n        \n        if (opt.isRequired())\n        {\n            requiredOptions.remove(opt.getKey());\n        }\n\n        \n        \n        if (options.getOptionGroup(opt) != null)\n        {\n            OptionGroup group = options.getOptionGroup(opt);\n\n            if (group.isRequired())\n            {\n                requiredOptions.remove(group);\n            }\n\n            group.setSelected(opt);\n        }\n\n        \n        if (opt.hasArg())\n        {\n            processArgs(opt, iter);\n        }\n\n\n        \n        cmd.addOption(opt);\n    }\n}\n",
      "buggy_signatures": [
        "protected abstract String[] flatten(Options opts, String[] arguments, boolean stopAtNonOption)",
        "public CommandLine parse(Options options, String[] arguments)",
        "public CommandLine parse(Options options, String[] arguments, Properties properties)",
        "public CommandLine parse(Options options, String[] arguments, boolean stopAtNonOption)",
        "public CommandLine parse(Options options, String[] arguments, Properties properties, boolean stopAtNonOption)",
        "private void processProperties(Properties properties)",
        "private void checkRequiredOptions()",
        "public void processArgs(Option opt, ListIterator iter)",
        "private void processOption(String arg, ListIterator iter)"
      ],
      "fixed_signatures": [
        "protected abstract String[] flatten(Options opts, String[] arguments, boolean stopAtNonOption)",
        "public CommandLine parse(Options options, String[] arguments)",
        "public CommandLine parse(Options options, String[] arguments, Properties properties)",
        "public CommandLine parse(Options options, String[] arguments, boolean stopAtNonOption)",
        "public CommandLine parse(Options options, String[] arguments, Properties properties, boolean stopAtNonOption)",
        "private void processProperties(Properties properties)",
        "private void checkRequiredOptions()",
        "public void processArgs(Option opt, ListIterator iter)",
        "private void processOption(String arg, ListIterator iter)"
      ],
      "methods": [
        {
          "buggy_method": "  private void checkRequiredOptions()\n  throws MissingOptionException\n  {\n  \n  \n  if (requiredOptions.size() > 0)\n  {\n  Iterator iter = requiredOptions.iterator();\n  StringBuffer buff = new StringBuffer();\n\n\n  \n  while (iter.hasNext())\n  {\n  buff.append(iter.next());\n  }\n\n  throw new MissingOptionException(buff.toString());\n  }\n  }",
          "fixed_method": "  private void checkRequiredOptions()\n  throws MissingOptionException\n  {\n  \n  \n  if (requiredOptions.size() > 0)\n  {\n  Iterator iter = requiredOptions.iterator();\n  StringBuffer buff = new StringBuffer(\"Missing required option\");\n  buff.append(requiredOptions.size() == 1 ? \"\" : \"s\");\n  buff.append(\": \");\n\n\n  \n  while (iter.hasNext())\n  {\n  buff.append(iter.next());\n  }\n\n  throw new MissingOptionException(buff.toString());\n  }\n  }",
          "diff": [
            "@@ -295,7 +295,9 @@",
            "         if (requiredOptions.size() > 0)\n",
            "         {\n",
            "             Iterator iter = requiredOptions.iterator();\n",
            "-            StringBuffer buff = new StringBuffer();\n",
            "+            StringBuffer buff = new StringBuffer(\"Missing required option\");\n",
            "+            buff.append(requiredOptions.size() == 1 ? \"\" : \"s\");\n",
            "+            buff.append(\": \");\n",
            " \n",
            " \n",
            "             // loop through the required options\n"
          ],
          "changed_lines": 4
        }
      ]
    }
  ]
}