{
  "bug_id": "3",
  "failed_tests": {
    "org.apache.commons.math3.util.MathArraysTest": [
      {
        "methodName": "testLinearCombinationWithSingleElementArray",
        "error": "java.lang.ArrayIndexOutOfBoundsException",
        "message": "Index 1 out of bounds for length 1",
        "fail_line": "        Assert.assertEquals(a[0] * b[0], MathArrays.linearCombination(a, b), 0d);",
        "test_source": "  public void testLinearCombinationWithSingleElementArray() {\n  final double[] a = { 1.23456789 };\n  final double[] b = { 98765432.1 };\n\n  Assert.assertEquals(a[0] * b[0], MathArrays.linearCombination(a, b), 0d);\n  }",
        "stack": [
          "MathArrays.linearCombination line 846, MathArraysTest.testLinearCombinationWithSingleElementArray line 591"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/math3/util/MathArrays.java",
      "buggy_full_code": "\n\npackage org.apache.commons.math3.util;\n\nimport java.lang.reflect.Array;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\n\nimport org.apache.commons.math3.Field;\nimport org.apache.commons.math3.exception.DimensionMismatchException;\nimport org.apache.commons.math3.exception.MathArithmeticException;\nimport org.apache.commons.math3.exception.MathIllegalArgumentException;\nimport org.apache.commons.math3.exception.MathInternalError;\nimport org.apache.commons.math3.exception.NoDataException;\nimport org.apache.commons.math3.exception.NonMonotonicSequenceException;\nimport org.apache.commons.math3.exception.NotPositiveException;\nimport org.apache.commons.math3.exception.NotStrictlyPositiveException;\nimport org.apache.commons.math3.exception.NullArgumentException;\nimport org.apache.commons.math3.exception.util.LocalizedFormats;\n\n\npublic class MathArrays { private static final int SPLIT_FACTOR = 0x8000001; private MathArrays() {}\n\n    \n    public interface Function { double evaluate(double[] array); double evaluate(double[] array, int startIndex, int numElements); } public static double[] scale(double val, final double[] arr) {\n        double[] newArr = new double[arr.length];\n        for (int i = 0; i < arr.length; i++) {\n            newArr[i] = arr[i] * val;\n        }\n        return newArr;\n    }\n\n    \n    public static void scaleInPlace(double val, final double[] arr) {\n        for (int i = 0; i < arr.length; i++) {\n            arr[i] *= val;\n        }\n    }\n\n    \n    public static double[] ebeAdd(double[] a, double[] b) throws DimensionMismatchException {\n        if (a.length != b.length) {\n            throw new DimensionMismatchException(a.length, b.length);\n        }\n\n        final double[] result = a.clone();\n        for (int i = 0; i < a.length; i++) {\n            result[i] += b[i];\n        }\n        return result;\n    }\n    \n    public static double[] ebeSubtract(double[] a, double[] b) throws DimensionMismatchException {\n        if (a.length != b.length) {\n            throw new DimensionMismatchException(a.length, b.length);\n        }\n\n        final double[] result = a.clone();\n        for (int i = 0; i < a.length; i++) {\n            result[i] -= b[i];\n        }\n        return result;\n    }\n    \n    public static double[] ebeMultiply(double[] a, double[] b) throws DimensionMismatchException {\n        if (a.length != b.length) {\n            throw new DimensionMismatchException(a.length, b.length);\n        }\n\n        final double[] result = a.clone();\n        for (int i = 0; i < a.length; i++) {\n            result[i] *= b[i];\n        }\n        return result;\n    }\n    \n    public static double[] ebeDivide(double[] a, double[] b) throws DimensionMismatchException {\n        if (a.length != b.length) {\n            throw new DimensionMismatchException(a.length, b.length);\n        }\n\n        final double[] result = a.clone();\n        for (int i = 0; i < a.length; i++) {\n            result[i] /= b[i];\n        }\n        return result;\n    }\n\n    \n    public static double distance1(double[] p1, double[] p2) {\n        double sum = 0;\n        for (int i = 0; i < p1.length; i++) {\n            sum += FastMath.abs(p1[i] - p2[i]);\n        }\n        return sum;\n    }\n\n    \n    public static int distance1(int[] p1, int[] p2) {\n      int sum = 0;\n      for (int i = 0; i < p1.length; i++) {\n          sum += FastMath.abs(p1[i] - p2[i]);\n      }\n      return sum;\n    }\n\n    \n    public static double distance(double[] p1, double[] p2) {\n        double sum = 0;\n        for (int i = 0; i < p1.length; i++) {\n            final double dp = p1[i] - p2[i];\n            sum += dp * dp;\n        }\n        return FastMath.sqrt(sum);\n    }\n\n    \n    public static double distance(int[] p1, int[] p2) {\n      double sum = 0;\n      for (int i = 0; i < p1.length; i++) {\n          final double dp = p1[i] - p2[i];\n          sum += dp * dp;\n      }\n      return FastMath.sqrt(sum);\n    }\n\n    \n    public static double distanceInf(double[] p1, double[] p2) {\n        double max = 0;\n        for (int i = 0; i < p1.length; i++) {\n            max = FastMath.max(max, FastMath.abs(p1[i] - p2[i]));\n        }\n        return max;\n    }\n\n    \n    public static int distanceInf(int[] p1, int[] p2) {\n        int max = 0;\n        for (int i = 0; i < p1.length; i++) {\n            max = FastMath.max(max, FastMath.abs(p1[i] - p2[i]));\n        }\n        return max;\n    }\n\n    \n    public static enum OrderDirection { INCREASING, DECREASING } public static <T extends Comparable<? super T>> boolean isMonotonic(T[] val, OrderDirection dir, boolean strict) {\n        T previous = val[0];\n        final int max = val.length;\n        for (int i = 1; i < max; i++) {\n            final int comp;\n            switch (dir) {\n            case INCREASING:\n                comp = previous.compareTo(val[i]);\n                if (strict) {\n                    if (comp >= 0) {\n                        return false;\n                    }\n                } else {\n                    if (comp > 0) {\n                        return false;\n                    }\n                }\n                break;\n            case DECREASING:\n                comp = val[i].compareTo(previous);\n                if (strict) {\n                    if (comp >= 0) {\n                        return false;\n                    }\n                } else {\n                    if (comp > 0) {\n                       return false;\n                    }\n                }\n                break;\n            default:\n                \n                throw new MathInternalError();\n            }\n\n            previous = val[i];\n        }\n        return true;\n    }\n\n    \n    public static boolean isMonotonic(double[] val, OrderDirection dir, boolean strict) {\n        return checkOrder(val, dir, strict, false);\n    }\n\n    \n    public static boolean checkOrder(double[] val, OrderDirection dir, boolean strict, boolean abort) throws NonMonotonicSequenceException {\n        double previous = val[0];\n        final int max = val.length;\n\n        int index;\n        ITEM:\n        for (index = 1; index < max; index++) {\n            switch (dir) {\n            case INCREASING:\n                if (strict) {\n                    if (val[index] <= previous) {\n                        break ITEM;\n                    }\n                } else {\n                    if (val[index] < previous) {\n                        break ITEM;\n                    }\n                }\n                break;\n            case DECREASING:\n                if (strict) {\n                    if (val[index] >= previous) {\n                        break ITEM;\n                    }\n                } else {\n                    if (val[index] > previous) {\n                        break ITEM;\n                    }\n                }\n                break;\n            default:\n                \n                throw new MathInternalError();\n            }\n\n            previous = val[index];\n        }\n\n        if (index == max) {\n            \n            return true;\n        }\n\n        \n        if (abort) {\n            throw new NonMonotonicSequenceException(val[index], previous, index, dir, strict);\n        } else {\n            return false;\n        }\n    }\n\n    \n    public static void checkOrder(double[] val, OrderDirection dir, boolean strict) throws NonMonotonicSequenceException {\n        checkOrder(val, dir, strict, true);\n    }\n\n    \n    public static void checkOrder(double[] val) throws NonMonotonicSequenceException {\n        checkOrder(val, OrderDirection.INCREASING, true);\n    }\n\n    \n    public static void checkRectangular(final long[][] in) throws NullArgumentException, DimensionMismatchException {\n        MathUtils.checkNotNull(in);\n        for (int i = 1; i < in.length; i++) {\n            if (in[i].length != in[0].length) {\n                throw new DimensionMismatchException(\n                        LocalizedFormats.DIFFERENT_ROWS_LENGTHS,\n                        in[i].length, in[0].length);\n            }\n        }\n    }\n\n    \n    public static void checkPositive(final double[] in) throws NotStrictlyPositiveException {\n        for (int i = 0; i < in.length; i++) {\n            if (in[i] <= 0) {\n                throw new NotStrictlyPositiveException(in[i]);\n            }\n        }\n    }\n\n    \n    public static void checkNonNegative(final long[] in) throws NotPositiveException {\n        for (int i = 0; i < in.length; i++) {\n            if (in[i] < 0) {\n                throw new NotPositiveException(in[i]);\n            }\n        }\n    }\n\n    \n    public static void checkNonNegative(final long[][] in) throws NotPositiveException {\n        for (int i = 0; i < in.length; i ++) {\n            for (int j = 0; j < in[i].length; j++) {\n                if (in[i][j] < 0) {\n                    throw new NotPositiveException(in[i][j]);\n                }\n            }\n        }\n    }\n\n    \n    public static double safeNorm(double[] v) {\n        double rdwarf = 3.834e-20;\n        double rgiant = 1.304e+19;\n        double s1 = 0;\n        double s2 = 0;\n        double s3 = 0;\n        double x1max = 0;\n        double x3max = 0;\n        double floatn = v.length;\n        double agiant = rgiant / floatn;\n        for (int i = 0; i < v.length; i++) {\n            double xabs = Math.abs(v[i]);\n            if (xabs < rdwarf || xabs > agiant) {\n                if (xabs > rdwarf) {\n                    if (xabs > x1max) {\n                        double r = x1max / xabs;\n                        s1= 1 + s1 * r * r;\n                        x1max = xabs;\n                    } else {\n                        double r = xabs / x1max;\n                        s1 += r * r;\n                    }\n                } else {\n                    if (xabs > x3max) {\n                        double r = x3max / xabs;\n                        s3= 1 + s3 * r * r;\n                        x3max = xabs;\n                    } else {\n                        if (xabs != 0) {\n                            double r = xabs / x3max;\n                            s3 += r * r;\n                        }\n                    }\n                }\n            } else {\n                s2 += xabs * xabs;\n            }\n        }\n        double norm;\n        if (s1 != 0) {\n            norm = x1max * Math.sqrt(s1 + (s2 / x1max) / x1max);\n        } else {\n            if (s2 == 0) {\n                norm = x3max * Math.sqrt(s3);\n            } else {\n                if (s2 >= x3max) {\n                    norm = Math.sqrt(s2 * (1 + (x3max / s2) * (x3max * s3)));\n                } else {\n                    norm = Math.sqrt(x3max * ((s2 / x3max) + (x3max * s3)));\n                }\n            }\n        }\n        return norm;\n    }\n\n    \n    public static void sortInPlace(double[] x, double[] ... yList) throws DimensionMismatchException, NullArgumentException {\n        sortInPlace(x, OrderDirection.INCREASING, yList);\n    }\n\n    \n    public static void sortInPlace(double[] x, final OrderDirection dir, double[] ... yList) throws NullArgumentException, DimensionMismatchException {\n\n        \n        if (x == null) {\n            throw new NullArgumentException();\n        }\n\n        final int yListLen = yList.length;\n        final int len = x.length;\n\n        for (int j = 0; j < yListLen; j++) {\n            final double[] y = yList[j];\n            if (y == null) {\n                throw new NullArgumentException();\n            }\n            if (y.length != len) {\n                throw new DimensionMismatchException(y.length, len);\n            }\n        }\n\n        \n        final List<Pair<Double, Integer>> list\n            = new ArrayList<Pair<Double, Integer>>(len);\n        for (int i = 0; i < len; i++) {\n            list.add(new Pair<Double, Integer>(x[i], i));\n        }\n\n        \n        final Comparator<Pair<Double, Integer>> comp\n            = dir == MathArrays.OrderDirection.INCREASING ?\n            new Comparator<Pair<Double, Integer>>() {\n            public int compare(Pair<Double, Integer> o1, Pair<Double, Integer> o2) {\n                return o1.getKey().compareTo(o2.getKey());\n            }\n        } : new Comparator<Pair<Double,Integer>>() {\n            public int compare(Pair<Double, Integer> o1, Pair<Double, Integer> o2) {\n                return o2.getKey().compareTo(o1.getKey());\n            }\n        };\n\n        \n        Collections.sort(list, comp);\n\n        \n        \n        \n        final int[] indices = new int[len];\n        for (int i = 0; i < len; i++) {\n            final Pair<Double, Integer> e = list.get(i);\n            x[i] = e.getKey();\n            indices[i] = e.getValue();\n        }\n\n        \n        \n        for (int j = 0; j < yListLen; j++) {\n            \n            final double[] yInPlace = yList[j];\n            final double[] yOrig = yInPlace.clone();\n\n            for (int i = 0; i < len; i++) {\n                yInPlace[i] = yOrig[indices[i]];\n            }\n        }\n    }\n\n    \n     public static int[] copyOf(int[] source) {\n         return copyOf(source, source.length);\n     }\n\n    \n     public static double[] copyOf(double[] source) {\n         return copyOf(source, source.length);\n     }\n\n    \n    public static int[] copyOf(int[] source, int len) {\n         final int[] output = new int[len];\n         System.arraycopy(source, 0, output, 0, FastMath.min(len, source.length));\n         return output;\n     }\n\n    \n    public static double[] copyOf(double[] source, int len) {\n         final double[] output = new double[len];\n         System.arraycopy(source, 0, output, 0, FastMath.min(len, source.length));\n         return output;\n     }\n\n    \n    public static double linearCombination(final double[] a, final double[] b) throws DimensionMismatchException {\n        final int len = a.length;\n        if (len != b.length) {\n            throw new DimensionMismatchException(len, b.length);\n        }\n\n            \n\n        final double[] prodHigh = new double[len];\n        double prodLowSum = 0;\n\n        for (int i = 0; i < len; i++) {\n            final double ai = a[i];\n            final double ca = SPLIT_FACTOR * ai;\n            final double aHigh = ca - (ca - ai);\n            final double aLow = ai - aHigh;\n\n            final double bi = b[i];\n            final double cb = SPLIT_FACTOR * bi;\n            final double bHigh = cb - (cb - bi);\n            final double bLow = bi - bHigh;\n            prodHigh[i] = ai * bi;\n            final double prodLow = aLow * bLow - (((prodHigh[i] -\n                                                    aHigh * bHigh) -\n                                                   aLow * bHigh) -\n                                                  aHigh * bLow);\n            prodLowSum += prodLow;\n        }\n\n\n        final double prodHighCur = prodHigh[0];\n        double prodHighNext = prodHigh[1];\n        double sHighPrev = prodHighCur + prodHighNext;\n        double sPrime = sHighPrev - prodHighNext;\n        double sLowSum = (prodHighNext - (sHighPrev - sPrime)) + (prodHighCur - sPrime);\n\n        final int lenMinusOne = len - 1;\n        for (int i = 1; i < lenMinusOne; i++) {\n            prodHighNext = prodHigh[i + 1];\n            final double sHighCur = sHighPrev + prodHighNext;\n            sPrime = sHighCur - prodHighNext;\n            sLowSum += (prodHighNext - (sHighCur - sPrime)) + (sHighPrev - sPrime);\n            sHighPrev = sHighCur;\n        }\n\n        double result = sHighPrev + (prodLowSum + sLowSum);\n\n        if (Double.isNaN(result)) {\n            \n            \n            result = 0;\n            for (int i = 0; i < len; ++i) {\n                result += a[i] * b[i];\n            }\n        }\n\n        return result;\n    }\n\n    \n    public static double linearCombination(final double a1, final double b1, final double a2, final double b2) {\n\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n\n        \n        final double ca1        = SPLIT_FACTOR * a1;\n        final double a1High     = ca1 - (ca1 - a1);\n        final double a1Low      = a1 - a1High;\n        final double cb1        = SPLIT_FACTOR * b1;\n        final double b1High     = cb1 - (cb1 - b1);\n        final double b1Low      = b1 - b1High;\n\n        \n        final double prod1High  = a1 * b1;\n        final double prod1Low   = a1Low * b1Low - (((prod1High - a1High * b1High) - a1Low * b1High) - a1High * b1Low);\n\n        \n        final double ca2        = SPLIT_FACTOR * a2;\n        final double a2High     = ca2 - (ca2 - a2);\n        final double a2Low      = a2 - a2High;\n        final double cb2        = SPLIT_FACTOR * b2;\n        final double b2High     = cb2 - (cb2 - b2);\n        final double b2Low      = b2 - b2High;\n\n        \n        final double prod2High  = a2 * b2;\n        final double prod2Low   = a2Low * b2Low - (((prod2High - a2High * b2High) - a2Low * b2High) - a2High * b2Low);\n\n        \n        final double s12High    = prod1High + prod2High;\n        final double s12Prime   = s12High - prod2High;\n        final double s12Low     = (prod2High - (s12High - s12Prime)) + (prod1High - s12Prime);\n\n        \n        \n        double result = s12High + (prod1Low + prod2Low + s12Low);\n\n        if (Double.isNaN(result)) {\n            \n            \n            result = a1 * b1 + a2 * b2;\n        }\n\n        return result;\n    }\n\n    \n    public static double linearCombination(final double a1, final double b1, final double a2, final double b2, final double a3, final double b3) {\n\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n\n        \n        final double ca1        = SPLIT_FACTOR * a1;\n        final double a1High     = ca1 - (ca1 - a1);\n        final double a1Low      = a1 - a1High;\n        final double cb1        = SPLIT_FACTOR * b1;\n        final double b1High     = cb1 - (cb1 - b1);\n        final double b1Low      = b1 - b1High;\n\n        \n        final double prod1High  = a1 * b1;\n        final double prod1Low   = a1Low * b1Low - (((prod1High - a1High * b1High) - a1Low * b1High) - a1High * b1Low);\n\n        \n        final double ca2        = SPLIT_FACTOR * a2;\n        final double a2High     = ca2 - (ca2 - a2);\n        final double a2Low      = a2 - a2High;\n        final double cb2        = SPLIT_FACTOR * b2;\n        final double b2High     = cb2 - (cb2 - b2);\n        final double b2Low      = b2 - b2High;\n\n        \n        final double prod2High  = a2 * b2;\n        final double prod2Low   = a2Low * b2Low - (((prod2High - a2High * b2High) - a2Low * b2High) - a2High * b2Low);\n\n        \n        final double ca3        = SPLIT_FACTOR * a3;\n        final double a3High     = ca3 - (ca3 - a3);\n        final double a3Low      = a3 - a3High;\n        final double cb3        = SPLIT_FACTOR * b3;\n        final double b3High     = cb3 - (cb3 - b3);\n        final double b3Low      = b3 - b3High;\n\n        \n        final double prod3High  = a3 * b3;\n        final double prod3Low   = a3Low * b3Low - (((prod3High - a3High * b3High) - a3Low * b3High) - a3High * b3Low);\n\n        \n        final double s12High    = prod1High + prod2High;\n        final double s12Prime   = s12High - prod2High;\n        final double s12Low     = (prod2High - (s12High - s12Prime)) + (prod1High - s12Prime);\n\n        \n        final double s123High   = s12High + prod3High;\n        final double s123Prime  = s123High - prod3High;\n        final double s123Low    = (prod3High - (s123High - s123Prime)) + (s12High - s123Prime);\n\n        \n        \n        double result = s123High + (prod1Low + prod2Low + prod3Low + s12Low + s123Low);\n\n        if (Double.isNaN(result)) {\n            \n            \n            result = a1 * b1 + a2 * b2 + a3 * b3;\n        }\n\n        return result;\n    }\n\n    \n    public static double linearCombination(final double a1, final double b1, final double a2, final double b2, final double a3, final double b3, final double a4, final double b4) {\n\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n\n        \n        final double ca1        = SPLIT_FACTOR * a1;\n        final double a1High     = ca1 - (ca1 - a1);\n        final double a1Low      = a1 - a1High;\n        final double cb1        = SPLIT_FACTOR * b1;\n        final double b1High     = cb1 - (cb1 - b1);\n        final double b1Low      = b1 - b1High;\n\n        \n        final double prod1High  = a1 * b1;\n        final double prod1Low   = a1Low * b1Low - (((prod1High - a1High * b1High) - a1Low * b1High) - a1High * b1Low);\n\n        \n        final double ca2        = SPLIT_FACTOR * a2;\n        final double a2High     = ca2 - (ca2 - a2);\n        final double a2Low      = a2 - a2High;\n        final double cb2        = SPLIT_FACTOR * b2;\n        final double b2High     = cb2 - (cb2 - b2);\n        final double b2Low      = b2 - b2High;\n\n        \n        final double prod2High  = a2 * b2;\n        final double prod2Low   = a2Low * b2Low - (((prod2High - a2High * b2High) - a2Low * b2High) - a2High * b2Low);\n\n        \n        final double ca3        = SPLIT_FACTOR * a3;\n        final double a3High     = ca3 - (ca3 - a3);\n        final double a3Low      = a3 - a3High;\n        final double cb3        = SPLIT_FACTOR * b3;\n        final double b3High     = cb3 - (cb3 - b3);\n        final double b3Low      = b3 - b3High;\n\n        \n        final double prod3High  = a3 * b3;\n        final double prod3Low   = a3Low * b3Low - (((prod3High - a3High * b3High) - a3Low * b3High) - a3High * b3Low);\n\n        \n        final double ca4        = SPLIT_FACTOR * a4;\n        final double a4High     = ca4 - (ca4 - a4);\n        final double a4Low      = a4 - a4High;\n        final double cb4        = SPLIT_FACTOR * b4;\n        final double b4High     = cb4 - (cb4 - b4);\n        final double b4Low      = b4 - b4High;\n\n        \n        final double prod4High  = a4 * b4;\n        final double prod4Low   = a4Low * b4Low - (((prod4High - a4High * b4High) - a4Low * b4High) - a4High * b4Low);\n\n        \n        final double s12High    = prod1High + prod2High;\n        final double s12Prime   = s12High - prod2High;\n        final double s12Low     = (prod2High - (s12High - s12Prime)) + (prod1High - s12Prime);\n\n        \n        final double s123High   = s12High + prod3High;\n        final double s123Prime  = s123High - prod3High;\n        final double s123Low    = (prod3High - (s123High - s123Prime)) + (s12High - s123Prime);\n\n        \n        final double s1234High  = s123High + prod4High;\n        final double s1234Prime = s1234High - prod4High;\n        final double s1234Low   = (prod4High - (s1234High - s1234Prime)) + (s123High - s1234Prime);\n\n        \n        \n        double result = s1234High + (prod1Low + prod2Low + prod3Low + prod4Low + s12Low + s123Low + s1234Low);\n\n        if (Double.isNaN(result)) {\n            \n            \n            result = a1 * b1 + a2 * b2 + a3 * b3 + a4 * b4;\n        }\n\n        return result;\n    }\n\n    \n    public static boolean equals(float[] x, float[] y) {\n        if ((x == null) || (y == null)) {\n            return !((x == null) ^ (y == null));\n        }\n        if (x.length != y.length) {\n            return false;\n        }\n        for (int i = 0; i < x.length; ++i) {\n            if (!Precision.equals(x[i], y[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public static boolean equalsIncludingNaN(float[] x, float[] y) {\n        if ((x == null) || (y == null)) {\n            return !((x == null) ^ (y == null));\n        }\n        if (x.length != y.length) {\n            return false;\n        }\n        for (int i = 0; i < x.length; ++i) {\n            if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public static boolean equals(double[] x, double[] y) {\n        if ((x == null) || (y == null)) {\n            return !((x == null) ^ (y == null));\n        }\n        if (x.length != y.length) {\n            return false;\n        }\n        for (int i = 0; i < x.length; ++i) {\n            if (!Precision.equals(x[i], y[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public static boolean equalsIncludingNaN(double[] x, double[] y) {\n        if ((x == null) || (y == null)) {\n            return !((x == null) ^ (y == null));\n        }\n        if (x.length != y.length) {\n            return false;\n        }\n        for (int i = 0; i < x.length; ++i) {\n            if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n     \n     public static double[] normalizeArray(double[] values, double normalizedSum) throws MathIllegalArgumentException, MathArithmeticException {\n         if (Double.isInfinite(normalizedSum)) {\n             throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZE_INFINITE);\n         }\n         if (Double.isNaN(normalizedSum)) {\n             throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZE_NAN);\n         }\n         double sum = 0d;\n         final int len = values.length;\n         double[] out = new double[len];\n         for (int i = 0; i < len; i++) {\n             if (Double.isInfinite(values[i])) {\n                 throw new MathIllegalArgumentException(LocalizedFormats.INFINITE_ARRAY_ELEMENT, values[i], i);\n             }\n             if (!Double.isNaN(values[i])) {\n                 sum += values[i];\n             }\n         }\n         if (sum == 0) {\n             throw new MathArithmeticException(LocalizedFormats.ARRAY_SUMS_TO_ZERO);\n         }\n         for (int i = 0; i < len; i++) {\n             if (Double.isNaN(values[i])) {\n                 out[i] = Double.NaN;\n             } else {\n                 out[i] = values[i] * normalizedSum / sum;\n             }\n         }\n         return out;\n     }\n\n     \n     public static <T> T[] buildArray(final Field<T> field, final int length) {\n         @SuppressWarnings(\"unchecked\") \n         T[] array = (T[]) Array.newInstance(field.getRuntimeClass(), length);\n         Arrays.fill(array, field.getZero());\n         return array;\n     }\n\n     \n     @SuppressWarnings(\"unchecked\")\n    public static <T> T[][] buildArray(final Field<T> field, final int rows, final int columns) {\n         final T[][] array;\n         if (columns < 0) {\n             T[] dummyRow = buildArray(field, 0);\n             array = (T[][]) Array.newInstance(dummyRow.getClass(), rows);\n         } else {\n             array = (T[][]) Array.newInstance(field.getRuntimeClass(),\n                                               new int[] {\n                                                   rows, columns\n                                               });\n             for (int i = 0; i < rows; ++i) {\n                 Arrays.fill(array[i], field.getZero());\n             }\n         }\n         return array;\n     }\n\n     \n     public static double[] convolve(double[] x, double[] h) throws NullArgumentException, NoDataException {\n         MathUtils.checkNotNull(x);\n         MathUtils.checkNotNull(h);\n\n         final int xLen = x.length;\n         final int hLen = h.length;\n\n         if (xLen == 0 || hLen == 0) {\n             throw new NoDataException();\n         }\n\n         \n         final int totalLength = xLen + hLen - 1;\n         final double[] y = new double[totalLength];\n\n         \n         for (int n = 0; n < totalLength; n++) {\n             double yn = 0;\n             int k = FastMath.max(0, n + 1 - xLen);\n             int j = n - k;\n             while (k < hLen && j >= 0) {\n                 yn += x[j--] * h[k++];\n             }\n             y[n] = yn;\n         }\n\n         return y;\n     }\n}\n",
      "fixed_full_code": "\n\npackage org.apache.commons.math3.util;\n\nimport java.lang.reflect.Array;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\n\nimport org.apache.commons.math3.Field;\nimport org.apache.commons.math3.exception.DimensionMismatchException;\nimport org.apache.commons.math3.exception.MathArithmeticException;\nimport org.apache.commons.math3.exception.MathIllegalArgumentException;\nimport org.apache.commons.math3.exception.MathInternalError;\nimport org.apache.commons.math3.exception.NoDataException;\nimport org.apache.commons.math3.exception.NonMonotonicSequenceException;\nimport org.apache.commons.math3.exception.NotPositiveException;\nimport org.apache.commons.math3.exception.NotStrictlyPositiveException;\nimport org.apache.commons.math3.exception.NullArgumentException;\nimport org.apache.commons.math3.exception.util.LocalizedFormats;\n\n\npublic class MathArrays { private static final int SPLIT_FACTOR = 0x8000001; private MathArrays() {}\n\n    \n    public interface Function { double evaluate(double[] array); double evaluate(double[] array, int startIndex, int numElements); } public static double[] scale(double val, final double[] arr) {\n        double[] newArr = new double[arr.length];\n        for (int i = 0; i < arr.length; i++) {\n            newArr[i] = arr[i] * val;\n        }\n        return newArr;\n    }\n\n    \n    public static void scaleInPlace(double val, final double[] arr) {\n        for (int i = 0; i < arr.length; i++) {\n            arr[i] *= val;\n        }\n    }\n\n    \n    public static double[] ebeAdd(double[] a, double[] b) throws DimensionMismatchException {\n        if (a.length != b.length) {\n            throw new DimensionMismatchException(a.length, b.length);\n        }\n\n        final double[] result = a.clone();\n        for (int i = 0; i < a.length; i++) {\n            result[i] += b[i];\n        }\n        return result;\n    }\n    \n    public static double[] ebeSubtract(double[] a, double[] b) throws DimensionMismatchException {\n        if (a.length != b.length) {\n            throw new DimensionMismatchException(a.length, b.length);\n        }\n\n        final double[] result = a.clone();\n        for (int i = 0; i < a.length; i++) {\n            result[i] -= b[i];\n        }\n        return result;\n    }\n    \n    public static double[] ebeMultiply(double[] a, double[] b) throws DimensionMismatchException {\n        if (a.length != b.length) {\n            throw new DimensionMismatchException(a.length, b.length);\n        }\n\n        final double[] result = a.clone();\n        for (int i = 0; i < a.length; i++) {\n            result[i] *= b[i];\n        }\n        return result;\n    }\n    \n    public static double[] ebeDivide(double[] a, double[] b) throws DimensionMismatchException {\n        if (a.length != b.length) {\n            throw new DimensionMismatchException(a.length, b.length);\n        }\n\n        final double[] result = a.clone();\n        for (int i = 0; i < a.length; i++) {\n            result[i] /= b[i];\n        }\n        return result;\n    }\n\n    \n    public static double distance1(double[] p1, double[] p2) {\n        double sum = 0;\n        for (int i = 0; i < p1.length; i++) {\n            sum += FastMath.abs(p1[i] - p2[i]);\n        }\n        return sum;\n    }\n\n    \n    public static int distance1(int[] p1, int[] p2) {\n      int sum = 0;\n      for (int i = 0; i < p1.length; i++) {\n          sum += FastMath.abs(p1[i] - p2[i]);\n      }\n      return sum;\n    }\n\n    \n    public static double distance(double[] p1, double[] p2) {\n        double sum = 0;\n        for (int i = 0; i < p1.length; i++) {\n            final double dp = p1[i] - p2[i];\n            sum += dp * dp;\n        }\n        return FastMath.sqrt(sum);\n    }\n\n    \n    public static double distance(int[] p1, int[] p2) {\n      double sum = 0;\n      for (int i = 0; i < p1.length; i++) {\n          final double dp = p1[i] - p2[i];\n          sum += dp * dp;\n      }\n      return FastMath.sqrt(sum);\n    }\n\n    \n    public static double distanceInf(double[] p1, double[] p2) {\n        double max = 0;\n        for (int i = 0; i < p1.length; i++) {\n            max = FastMath.max(max, FastMath.abs(p1[i] - p2[i]));\n        }\n        return max;\n    }\n\n    \n    public static int distanceInf(int[] p1, int[] p2) {\n        int max = 0;\n        for (int i = 0; i < p1.length; i++) {\n            max = FastMath.max(max, FastMath.abs(p1[i] - p2[i]));\n        }\n        return max;\n    }\n\n    \n    public static enum OrderDirection { INCREASING, DECREASING } public static <T extends Comparable<? super T>> boolean isMonotonic(T[] val, OrderDirection dir, boolean strict) {\n        T previous = val[0];\n        final int max = val.length;\n        for (int i = 1; i < max; i++) {\n            final int comp;\n            switch (dir) {\n            case INCREASING:\n                comp = previous.compareTo(val[i]);\n                if (strict) {\n                    if (comp >= 0) {\n                        return false;\n                    }\n                } else {\n                    if (comp > 0) {\n                        return false;\n                    }\n                }\n                break;\n            case DECREASING:\n                comp = val[i].compareTo(previous);\n                if (strict) {\n                    if (comp >= 0) {\n                        return false;\n                    }\n                } else {\n                    if (comp > 0) {\n                       return false;\n                    }\n                }\n                break;\n            default:\n                \n                throw new MathInternalError();\n            }\n\n            previous = val[i];\n        }\n        return true;\n    }\n\n    \n    public static boolean isMonotonic(double[] val, OrderDirection dir, boolean strict) {\n        return checkOrder(val, dir, strict, false);\n    }\n\n    \n    public static boolean checkOrder(double[] val, OrderDirection dir, boolean strict, boolean abort) throws NonMonotonicSequenceException {\n        double previous = val[0];\n        final int max = val.length;\n\n        int index;\n        ITEM:\n        for (index = 1; index < max; index++) {\n            switch (dir) {\n            case INCREASING:\n                if (strict) {\n                    if (val[index] <= previous) {\n                        break ITEM;\n                    }\n                } else {\n                    if (val[index] < previous) {\n                        break ITEM;\n                    }\n                }\n                break;\n            case DECREASING:\n                if (strict) {\n                    if (val[index] >= previous) {\n                        break ITEM;\n                    }\n                } else {\n                    if (val[index] > previous) {\n                        break ITEM;\n                    }\n                }\n                break;\n            default:\n                \n                throw new MathInternalError();\n            }\n\n            previous = val[index];\n        }\n\n        if (index == max) {\n            \n            return true;\n        }\n\n        \n        if (abort) {\n            throw new NonMonotonicSequenceException(val[index], previous, index, dir, strict);\n        } else {\n            return false;\n        }\n    }\n\n    \n    public static void checkOrder(double[] val, OrderDirection dir, boolean strict) throws NonMonotonicSequenceException {\n        checkOrder(val, dir, strict, true);\n    }\n\n    \n    public static void checkOrder(double[] val) throws NonMonotonicSequenceException {\n        checkOrder(val, OrderDirection.INCREASING, true);\n    }\n\n    \n    public static void checkRectangular(final long[][] in) throws NullArgumentException, DimensionMismatchException {\n        MathUtils.checkNotNull(in);\n        for (int i = 1; i < in.length; i++) {\n            if (in[i].length != in[0].length) {\n                throw new DimensionMismatchException(\n                        LocalizedFormats.DIFFERENT_ROWS_LENGTHS,\n                        in[i].length, in[0].length);\n            }\n        }\n    }\n\n    \n    public static void checkPositive(final double[] in) throws NotStrictlyPositiveException {\n        for (int i = 0; i < in.length; i++) {\n            if (in[i] <= 0) {\n                throw new NotStrictlyPositiveException(in[i]);\n            }\n        }\n    }\n\n    \n    public static void checkNonNegative(final long[] in) throws NotPositiveException {\n        for (int i = 0; i < in.length; i++) {\n            if (in[i] < 0) {\n                throw new NotPositiveException(in[i]);\n            }\n        }\n    }\n\n    \n    public static void checkNonNegative(final long[][] in) throws NotPositiveException {\n        for (int i = 0; i < in.length; i ++) {\n            for (int j = 0; j < in[i].length; j++) {\n                if (in[i][j] < 0) {\n                    throw new NotPositiveException(in[i][j]);\n                }\n            }\n        }\n    }\n\n    \n    public static double safeNorm(double[] v) {\n        double rdwarf = 3.834e-20;\n        double rgiant = 1.304e+19;\n        double s1 = 0;\n        double s2 = 0;\n        double s3 = 0;\n        double x1max = 0;\n        double x3max = 0;\n        double floatn = v.length;\n        double agiant = rgiant / floatn;\n        for (int i = 0; i < v.length; i++) {\n            double xabs = Math.abs(v[i]);\n            if (xabs < rdwarf || xabs > agiant) {\n                if (xabs > rdwarf) {\n                    if (xabs > x1max) {\n                        double r = x1max / xabs;\n                        s1= 1 + s1 * r * r;\n                        x1max = xabs;\n                    } else {\n                        double r = xabs / x1max;\n                        s1 += r * r;\n                    }\n                } else {\n                    if (xabs > x3max) {\n                        double r = x3max / xabs;\n                        s3= 1 + s3 * r * r;\n                        x3max = xabs;\n                    } else {\n                        if (xabs != 0) {\n                            double r = xabs / x3max;\n                            s3 += r * r;\n                        }\n                    }\n                }\n            } else {\n                s2 += xabs * xabs;\n            }\n        }\n        double norm;\n        if (s1 != 0) {\n            norm = x1max * Math.sqrt(s1 + (s2 / x1max) / x1max);\n        } else {\n            if (s2 == 0) {\n                norm = x3max * Math.sqrt(s3);\n            } else {\n                if (s2 >= x3max) {\n                    norm = Math.sqrt(s2 * (1 + (x3max / s2) * (x3max * s3)));\n                } else {\n                    norm = Math.sqrt(x3max * ((s2 / x3max) + (x3max * s3)));\n                }\n            }\n        }\n        return norm;\n    }\n\n    \n    public static void sortInPlace(double[] x, double[] ... yList) throws DimensionMismatchException, NullArgumentException {\n        sortInPlace(x, OrderDirection.INCREASING, yList);\n    }\n\n    \n    public static void sortInPlace(double[] x, final OrderDirection dir, double[] ... yList) throws NullArgumentException, DimensionMismatchException {\n\n        \n        if (x == null) {\n            throw new NullArgumentException();\n        }\n\n        final int yListLen = yList.length;\n        final int len = x.length;\n\n        for (int j = 0; j < yListLen; j++) {\n            final double[] y = yList[j];\n            if (y == null) {\n                throw new NullArgumentException();\n            }\n            if (y.length != len) {\n                throw new DimensionMismatchException(y.length, len);\n            }\n        }\n\n        \n        final List<Pair<Double, Integer>> list\n            = new ArrayList<Pair<Double, Integer>>(len);\n        for (int i = 0; i < len; i++) {\n            list.add(new Pair<Double, Integer>(x[i], i));\n        }\n\n        \n        final Comparator<Pair<Double, Integer>> comp\n            = dir == MathArrays.OrderDirection.INCREASING ?\n            new Comparator<Pair<Double, Integer>>() {\n            public int compare(Pair<Double, Integer> o1, Pair<Double, Integer> o2) {\n                return o1.getKey().compareTo(o2.getKey());\n            }\n        } : new Comparator<Pair<Double,Integer>>() {\n            public int compare(Pair<Double, Integer> o1, Pair<Double, Integer> o2) {\n                return o2.getKey().compareTo(o1.getKey());\n            }\n        };\n\n        \n        Collections.sort(list, comp);\n\n        \n        \n        \n        final int[] indices = new int[len];\n        for (int i = 0; i < len; i++) {\n            final Pair<Double, Integer> e = list.get(i);\n            x[i] = e.getKey();\n            indices[i] = e.getValue();\n        }\n\n        \n        \n        for (int j = 0; j < yListLen; j++) {\n            \n            final double[] yInPlace = yList[j];\n            final double[] yOrig = yInPlace.clone();\n\n            for (int i = 0; i < len; i++) {\n                yInPlace[i] = yOrig[indices[i]];\n            }\n        }\n    }\n\n    \n     public static int[] copyOf(int[] source) {\n         return copyOf(source, source.length);\n     }\n\n    \n     public static double[] copyOf(double[] source) {\n         return copyOf(source, source.length);\n     }\n\n    \n    public static int[] copyOf(int[] source, int len) {\n         final int[] output = new int[len];\n         System.arraycopy(source, 0, output, 0, FastMath.min(len, source.length));\n         return output;\n     }\n\n    \n    public static double[] copyOf(double[] source, int len) {\n         final double[] output = new double[len];\n         System.arraycopy(source, 0, output, 0, FastMath.min(len, source.length));\n         return output;\n     }\n\n    \n    public static double linearCombination(final double[] a, final double[] b) throws DimensionMismatchException {\n        final int len = a.length;\n        if (len != b.length) {\n            throw new DimensionMismatchException(len, b.length);\n        }\n\n        if (len == 1) {\n            \n            return a[0] * b[0];\n        }\n\n        final double[] prodHigh = new double[len];\n        double prodLowSum = 0;\n\n        for (int i = 0; i < len; i++) {\n            final double ai = a[i];\n            final double ca = SPLIT_FACTOR * ai;\n            final double aHigh = ca - (ca - ai);\n            final double aLow = ai - aHigh;\n\n            final double bi = b[i];\n            final double cb = SPLIT_FACTOR * bi;\n            final double bHigh = cb - (cb - bi);\n            final double bLow = bi - bHigh;\n            prodHigh[i] = ai * bi;\n            final double prodLow = aLow * bLow - (((prodHigh[i] -\n                                                    aHigh * bHigh) -\n                                                   aLow * bHigh) -\n                                                  aHigh * bLow);\n            prodLowSum += prodLow;\n        }\n\n\n        final double prodHighCur = prodHigh[0];\n        double prodHighNext = prodHigh[1];\n        double sHighPrev = prodHighCur + prodHighNext;\n        double sPrime = sHighPrev - prodHighNext;\n        double sLowSum = (prodHighNext - (sHighPrev - sPrime)) + (prodHighCur - sPrime);\n\n        final int lenMinusOne = len - 1;\n        for (int i = 1; i < lenMinusOne; i++) {\n            prodHighNext = prodHigh[i + 1];\n            final double sHighCur = sHighPrev + prodHighNext;\n            sPrime = sHighCur - prodHighNext;\n            sLowSum += (prodHighNext - (sHighCur - sPrime)) + (sHighPrev - sPrime);\n            sHighPrev = sHighCur;\n        }\n\n        double result = sHighPrev + (prodLowSum + sLowSum);\n\n        if (Double.isNaN(result)) {\n            \n            \n            result = 0;\n            for (int i = 0; i < len; ++i) {\n                result += a[i] * b[i];\n            }\n        }\n\n        return result;\n    }\n\n    \n    public static double linearCombination(final double a1, final double b1, final double a2, final double b2) {\n\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n\n        \n        final double ca1        = SPLIT_FACTOR * a1;\n        final double a1High     = ca1 - (ca1 - a1);\n        final double a1Low      = a1 - a1High;\n        final double cb1        = SPLIT_FACTOR * b1;\n        final double b1High     = cb1 - (cb1 - b1);\n        final double b1Low      = b1 - b1High;\n\n        \n        final double prod1High  = a1 * b1;\n        final double prod1Low   = a1Low * b1Low - (((prod1High - a1High * b1High) - a1Low * b1High) - a1High * b1Low);\n\n        \n        final double ca2        = SPLIT_FACTOR * a2;\n        final double a2High     = ca2 - (ca2 - a2);\n        final double a2Low      = a2 - a2High;\n        final double cb2        = SPLIT_FACTOR * b2;\n        final double b2High     = cb2 - (cb2 - b2);\n        final double b2Low      = b2 - b2High;\n\n        \n        final double prod2High  = a2 * b2;\n        final double prod2Low   = a2Low * b2Low - (((prod2High - a2High * b2High) - a2Low * b2High) - a2High * b2Low);\n\n        \n        final double s12High    = prod1High + prod2High;\n        final double s12Prime   = s12High - prod2High;\n        final double s12Low     = (prod2High - (s12High - s12Prime)) + (prod1High - s12Prime);\n\n        \n        \n        double result = s12High + (prod1Low + prod2Low + s12Low);\n\n        if (Double.isNaN(result)) {\n            \n            \n            result = a1 * b1 + a2 * b2;\n        }\n\n        return result;\n    }\n\n    \n    public static double linearCombination(final double a1, final double b1, final double a2, final double b2, final double a3, final double b3) {\n\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n\n        \n        final double ca1        = SPLIT_FACTOR * a1;\n        final double a1High     = ca1 - (ca1 - a1);\n        final double a1Low      = a1 - a1High;\n        final double cb1        = SPLIT_FACTOR * b1;\n        final double b1High     = cb1 - (cb1 - b1);\n        final double b1Low      = b1 - b1High;\n\n        \n        final double prod1High  = a1 * b1;\n        final double prod1Low   = a1Low * b1Low - (((prod1High - a1High * b1High) - a1Low * b1High) - a1High * b1Low);\n\n        \n        final double ca2        = SPLIT_FACTOR * a2;\n        final double a2High     = ca2 - (ca2 - a2);\n        final double a2Low      = a2 - a2High;\n        final double cb2        = SPLIT_FACTOR * b2;\n        final double b2High     = cb2 - (cb2 - b2);\n        final double b2Low      = b2 - b2High;\n\n        \n        final double prod2High  = a2 * b2;\n        final double prod2Low   = a2Low * b2Low - (((prod2High - a2High * b2High) - a2Low * b2High) - a2High * b2Low);\n\n        \n        final double ca3        = SPLIT_FACTOR * a3;\n        final double a3High     = ca3 - (ca3 - a3);\n        final double a3Low      = a3 - a3High;\n        final double cb3        = SPLIT_FACTOR * b3;\n        final double b3High     = cb3 - (cb3 - b3);\n        final double b3Low      = b3 - b3High;\n\n        \n        final double prod3High  = a3 * b3;\n        final double prod3Low   = a3Low * b3Low - (((prod3High - a3High * b3High) - a3Low * b3High) - a3High * b3Low);\n\n        \n        final double s12High    = prod1High + prod2High;\n        final double s12Prime   = s12High - prod2High;\n        final double s12Low     = (prod2High - (s12High - s12Prime)) + (prod1High - s12Prime);\n\n        \n        final double s123High   = s12High + prod3High;\n        final double s123Prime  = s123High - prod3High;\n        final double s123Low    = (prod3High - (s123High - s123Prime)) + (s12High - s123Prime);\n\n        \n        \n        double result = s123High + (prod1Low + prod2Low + prod3Low + s12Low + s123Low);\n\n        if (Double.isNaN(result)) {\n            \n            \n            result = a1 * b1 + a2 * b2 + a3 * b3;\n        }\n\n        return result;\n    }\n\n    \n    public static double linearCombination(final double a1, final double b1, final double a2, final double b2, final double a3, final double b3, final double a4, final double b4) {\n\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n\n        \n        final double ca1        = SPLIT_FACTOR * a1;\n        final double a1High     = ca1 - (ca1 - a1);\n        final double a1Low      = a1 - a1High;\n        final double cb1        = SPLIT_FACTOR * b1;\n        final double b1High     = cb1 - (cb1 - b1);\n        final double b1Low      = b1 - b1High;\n\n        \n        final double prod1High  = a1 * b1;\n        final double prod1Low   = a1Low * b1Low - (((prod1High - a1High * b1High) - a1Low * b1High) - a1High * b1Low);\n\n        \n        final double ca2        = SPLIT_FACTOR * a2;\n        final double a2High     = ca2 - (ca2 - a2);\n        final double a2Low      = a2 - a2High;\n        final double cb2        = SPLIT_FACTOR * b2;\n        final double b2High     = cb2 - (cb2 - b2);\n        final double b2Low      = b2 - b2High;\n\n        \n        final double prod2High  = a2 * b2;\n        final double prod2Low   = a2Low * b2Low - (((prod2High - a2High * b2High) - a2Low * b2High) - a2High * b2Low);\n\n        \n        final double ca3        = SPLIT_FACTOR * a3;\n        final double a3High     = ca3 - (ca3 - a3);\n        final double a3Low      = a3 - a3High;\n        final double cb3        = SPLIT_FACTOR * b3;\n        final double b3High     = cb3 - (cb3 - b3);\n        final double b3Low      = b3 - b3High;\n\n        \n        final double prod3High  = a3 * b3;\n        final double prod3Low   = a3Low * b3Low - (((prod3High - a3High * b3High) - a3Low * b3High) - a3High * b3Low);\n\n        \n        final double ca4        = SPLIT_FACTOR * a4;\n        final double a4High     = ca4 - (ca4 - a4);\n        final double a4Low      = a4 - a4High;\n        final double cb4        = SPLIT_FACTOR * b4;\n        final double b4High     = cb4 - (cb4 - b4);\n        final double b4Low      = b4 - b4High;\n\n        \n        final double prod4High  = a4 * b4;\n        final double prod4Low   = a4Low * b4Low - (((prod4High - a4High * b4High) - a4Low * b4High) - a4High * b4Low);\n\n        \n        final double s12High    = prod1High + prod2High;\n        final double s12Prime   = s12High - prod2High;\n        final double s12Low     = (prod2High - (s12High - s12Prime)) + (prod1High - s12Prime);\n\n        \n        final double s123High   = s12High + prod3High;\n        final double s123Prime  = s123High - prod3High;\n        final double s123Low    = (prod3High - (s123High - s123Prime)) + (s12High - s123Prime);\n\n        \n        final double s1234High  = s123High + prod4High;\n        final double s1234Prime = s1234High - prod4High;\n        final double s1234Low   = (prod4High - (s1234High - s1234Prime)) + (s123High - s1234Prime);\n\n        \n        \n        double result = s1234High + (prod1Low + prod2Low + prod3Low + prod4Low + s12Low + s123Low + s1234Low);\n\n        if (Double.isNaN(result)) {\n            \n            \n            result = a1 * b1 + a2 * b2 + a3 * b3 + a4 * b4;\n        }\n\n        return result;\n    }\n\n    \n    public static boolean equals(float[] x, float[] y) {\n        if ((x == null) || (y == null)) {\n            return !((x == null) ^ (y == null));\n        }\n        if (x.length != y.length) {\n            return false;\n        }\n        for (int i = 0; i < x.length; ++i) {\n            if (!Precision.equals(x[i], y[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public static boolean equalsIncludingNaN(float[] x, float[] y) {\n        if ((x == null) || (y == null)) {\n            return !((x == null) ^ (y == null));\n        }\n        if (x.length != y.length) {\n            return false;\n        }\n        for (int i = 0; i < x.length; ++i) {\n            if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public static boolean equals(double[] x, double[] y) {\n        if ((x == null) || (y == null)) {\n            return !((x == null) ^ (y == null));\n        }\n        if (x.length != y.length) {\n            return false;\n        }\n        for (int i = 0; i < x.length; ++i) {\n            if (!Precision.equals(x[i], y[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public static boolean equalsIncludingNaN(double[] x, double[] y) {\n        if ((x == null) || (y == null)) {\n            return !((x == null) ^ (y == null));\n        }\n        if (x.length != y.length) {\n            return false;\n        }\n        for (int i = 0; i < x.length; ++i) {\n            if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n     \n     public static double[] normalizeArray(double[] values, double normalizedSum) throws MathIllegalArgumentException, MathArithmeticException {\n         if (Double.isInfinite(normalizedSum)) {\n             throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZE_INFINITE);\n         }\n         if (Double.isNaN(normalizedSum)) {\n             throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZE_NAN);\n         }\n         double sum = 0d;\n         final int len = values.length;\n         double[] out = new double[len];\n         for (int i = 0; i < len; i++) {\n             if (Double.isInfinite(values[i])) {\n                 throw new MathIllegalArgumentException(LocalizedFormats.INFINITE_ARRAY_ELEMENT, values[i], i);\n             }\n             if (!Double.isNaN(values[i])) {\n                 sum += values[i];\n             }\n         }\n         if (sum == 0) {\n             throw new MathArithmeticException(LocalizedFormats.ARRAY_SUMS_TO_ZERO);\n         }\n         for (int i = 0; i < len; i++) {\n             if (Double.isNaN(values[i])) {\n                 out[i] = Double.NaN;\n             } else {\n                 out[i] = values[i] * normalizedSum / sum;\n             }\n         }\n         return out;\n     }\n\n     \n     public static <T> T[] buildArray(final Field<T> field, final int length) {\n         @SuppressWarnings(\"unchecked\") \n         T[] array = (T[]) Array.newInstance(field.getRuntimeClass(), length);\n         Arrays.fill(array, field.getZero());\n         return array;\n     }\n\n     \n     @SuppressWarnings(\"unchecked\")\n    public static <T> T[][] buildArray(final Field<T> field, final int rows, final int columns) {\n         final T[][] array;\n         if (columns < 0) {\n             T[] dummyRow = buildArray(field, 0);\n             array = (T[][]) Array.newInstance(dummyRow.getClass(), rows);\n         } else {\n             array = (T[][]) Array.newInstance(field.getRuntimeClass(),\n                                               new int[] {\n                                                   rows, columns\n                                               });\n             for (int i = 0; i < rows; ++i) {\n                 Arrays.fill(array[i], field.getZero());\n             }\n         }\n         return array;\n     }\n\n     \n     public static double[] convolve(double[] x, double[] h) throws NullArgumentException, NoDataException {\n         MathUtils.checkNotNull(x);\n         MathUtils.checkNotNull(h);\n\n         final int xLen = x.length;\n         final int hLen = h.length;\n\n         if (xLen == 0 || hLen == 0) {\n             throw new NoDataException();\n         }\n\n         \n         final int totalLength = xLen + hLen - 1;\n         final double[] y = new double[totalLength];\n\n         \n         for (int n = 0; n < totalLength; n++) {\n             double yn = 0;\n             int k = FastMath.max(0, n + 1 - xLen);\n             int j = n - k;\n             while (k < hLen && j >= 0) {\n                 yn += x[j--] * h[k++];\n             }\n             y[n] = yn;\n         }\n\n         return y;\n     }\n}\n",
      "buggy_signatures": [
        "public interface Function { double evaluate(double[] array); double evaluate(double[] array, int startIndex, int numElements); } public static double[] scale(double val, final double[] arr)",
        "public static void scaleInPlace(double val, final double[] arr)",
        "public static double[] ebeAdd(double[] a, double[] b) throws DimensionMismatchException",
        "public static double[] ebeSubtract(double[] a, double[] b) throws DimensionMismatchException",
        "public static double[] ebeMultiply(double[] a, double[] b) throws DimensionMismatchException",
        "public static double[] ebeDivide(double[] a, double[] b) throws DimensionMismatchException",
        "public static double distance1(double[] p1, double[] p2)",
        "public static int distance1(int[] p1, int[] p2)",
        "public static double distance(double[] p1, double[] p2)",
        "public static double distance(int[] p1, int[] p2)",
        "public static double distanceInf(double[] p1, double[] p2)",
        "public static int distanceInf(int[] p1, int[] p2)",
        "public static enum OrderDirection { INCREASING, DECREASING } public static <T extends Comparable<? super T>> boolean isMonotonic(T[] val, OrderDirection dir, boolean strict)",
        "public static boolean isMonotonic(double[] val, OrderDirection dir, boolean strict)",
        "public static boolean checkOrder(double[] val, OrderDirection dir, boolean strict, boolean abort) throws NonMonotonicSequenceException",
        "public static void checkOrder(double[] val, OrderDirection dir, boolean strict) throws NonMonotonicSequenceException",
        "public static void checkOrder(double[] val) throws NonMonotonicSequenceException",
        "public static void checkRectangular(final long[][] in) throws NullArgumentException, DimensionMismatchException",
        "public static void checkPositive(final double[] in) throws NotStrictlyPositiveException",
        "public static void checkNonNegative(final long[] in) throws NotPositiveException",
        "public static void checkNonNegative(final long[][] in) throws NotPositiveException",
        "public static double safeNorm(double[] v)",
        "public static void sortInPlace(double[] x, double[] ... yList) throws DimensionMismatchException, NullArgumentException",
        "public static void sortInPlace(double[] x, final OrderDirection dir, double[] ... yList) throws NullArgumentException, DimensionMismatchException",
        "public int compare(Pair<Double, Integer> o1, Pair<Double, Integer> o2)",
        "public int compare(Pair<Double, Integer> o1, Pair<Double, Integer> o2)",
        "public static int[] copyOf(int[] source)",
        "public static double[] copyOf(double[] source)",
        "public static int[] copyOf(int[] source, int len)",
        "public static double[] copyOf(double[] source, int len)",
        "public static double linearCombination(final double[] a, final double[] b) throws DimensionMismatchException",
        "public static double linearCombination(final double a1, final double b1, final double a2, final double b2)",
        "public static double linearCombination(final double a1, final double b1, final double a2, final double b2, final double a3, final double b3)",
        "public static double linearCombination(final double a1, final double b1, final double a2, final double b2, final double a3, final double b3, final double a4, final double b4)",
        "public static boolean equals(float[] x, float[] y)",
        "public static boolean equalsIncludingNaN(float[] x, float[] y)",
        "public static boolean equals(double[] x, double[] y)",
        "public static boolean equalsIncludingNaN(double[] x, double[] y)",
        "public static double[] normalizeArray(double[] values, double normalizedSum) throws MathIllegalArgumentException, MathArithmeticException",
        "public static <T> T[] buildArray(final Field<T> field, final int length)",
        "public static <T> T[][] buildArray(final Field<T> field, final int rows, final int columns)",
        "public static double[] convolve(double[] x, double[] h) throws NullArgumentException, NoDataException"
      ],
      "fixed_signatures": [
        "public interface Function { double evaluate(double[] array); double evaluate(double[] array, int startIndex, int numElements); } public static double[] scale(double val, final double[] arr)",
        "public static void scaleInPlace(double val, final double[] arr)",
        "public static double[] ebeAdd(double[] a, double[] b) throws DimensionMismatchException",
        "public static double[] ebeSubtract(double[] a, double[] b) throws DimensionMismatchException",
        "public static double[] ebeMultiply(double[] a, double[] b) throws DimensionMismatchException",
        "public static double[] ebeDivide(double[] a, double[] b) throws DimensionMismatchException",
        "public static double distance1(double[] p1, double[] p2)",
        "public static int distance1(int[] p1, int[] p2)",
        "public static double distance(double[] p1, double[] p2)",
        "public static double distance(int[] p1, int[] p2)",
        "public static double distanceInf(double[] p1, double[] p2)",
        "public static int distanceInf(int[] p1, int[] p2)",
        "public static enum OrderDirection { INCREASING, DECREASING } public static <T extends Comparable<? super T>> boolean isMonotonic(T[] val, OrderDirection dir, boolean strict)",
        "public static boolean isMonotonic(double[] val, OrderDirection dir, boolean strict)",
        "public static boolean checkOrder(double[] val, OrderDirection dir, boolean strict, boolean abort) throws NonMonotonicSequenceException",
        "public static void checkOrder(double[] val, OrderDirection dir, boolean strict) throws NonMonotonicSequenceException",
        "public static void checkOrder(double[] val) throws NonMonotonicSequenceException",
        "public static void checkRectangular(final long[][] in) throws NullArgumentException, DimensionMismatchException",
        "public static void checkPositive(final double[] in) throws NotStrictlyPositiveException",
        "public static void checkNonNegative(final long[] in) throws NotPositiveException",
        "public static void checkNonNegative(final long[][] in) throws NotPositiveException",
        "public static double safeNorm(double[] v)",
        "public static void sortInPlace(double[] x, double[] ... yList) throws DimensionMismatchException, NullArgumentException",
        "public static void sortInPlace(double[] x, final OrderDirection dir, double[] ... yList) throws NullArgumentException, DimensionMismatchException",
        "public int compare(Pair<Double, Integer> o1, Pair<Double, Integer> o2)",
        "public int compare(Pair<Double, Integer> o1, Pair<Double, Integer> o2)",
        "public static int[] copyOf(int[] source)",
        "public static double[] copyOf(double[] source)",
        "public static int[] copyOf(int[] source, int len)",
        "public static double[] copyOf(double[] source, int len)",
        "public static double linearCombination(final double[] a, final double[] b) throws DimensionMismatchException",
        "public static double linearCombination(final double a1, final double b1, final double a2, final double b2)",
        "public static double linearCombination(final double a1, final double b1, final double a2, final double b2, final double a3, final double b3)",
        "public static double linearCombination(final double a1, final double b1, final double a2, final double b2, final double a3, final double b3, final double a4, final double b4)",
        "public static boolean equals(float[] x, float[] y)",
        "public static boolean equalsIncludingNaN(float[] x, float[] y)",
        "public static boolean equals(double[] x, double[] y)",
        "public static boolean equalsIncludingNaN(double[] x, double[] y)",
        "public static double[] normalizeArray(double[] values, double normalizedSum) throws MathIllegalArgumentException, MathArithmeticException",
        "public static <T> T[] buildArray(final Field<T> field, final int length)",
        "public static <T> T[][] buildArray(final Field<T> field, final int rows, final int columns)",
        "public static double[] convolve(double[] x, double[] h) throws NullArgumentException, NoDataException"
      ],
      "methods": [
        {
          "buggy_method": "  public static double linearCombination(final double[] a, final double[] b) throws DimensionMismatchException {\n  final int len = a.length;\n  if (len != b.length) {\n  throw new DimensionMismatchException(len, b.length);\n  }\n\n  \n\n  final double[] prodHigh = new double[len];\n  double prodLowSum = 0;\n\n  for (int i = 0; i < len; i++) {\n  final double ai = a[i];\n  final double ca = SPLIT_FACTOR * ai;\n  final double aHigh = ca - (ca - ai);\n  final double aLow = ai - aHigh;\n\n  final double bi = b[i];\n  final double cb = SPLIT_FACTOR * bi;\n  final double bHigh = cb - (cb - bi);\n  final double bLow = bi - bHigh;\n  prodHigh[i] = ai * bi;\n  final double prodLow = aLow * bLow - (((prodHigh[i] -\n  aHigh * bHigh) -\n  aLow * bHigh) -\n  aHigh * bLow);\n  prodLowSum += prodLow;\n  }\n\n\n  final double prodHighCur = prodHigh[0];\n  double prodHighNext = prodHigh[1];\n  double sHighPrev = prodHighCur + prodHighNext;\n  double sPrime = sHighPrev - prodHighNext;\n  double sLowSum = (prodHighNext - (sHighPrev - sPrime)) + (prodHighCur - sPrime);\n\n  final int lenMinusOne = len - 1;\n  for (int i = 1; i < lenMinusOne; i++) {\n  prodHighNext = prodHigh[i + 1];\n  final double sHighCur = sHighPrev + prodHighNext;\n  sPrime = sHighCur - prodHighNext;\n  sLowSum += (prodHighNext - (sHighCur - sPrime)) + (sHighPrev - sPrime);\n  sHighPrev = sHighCur;\n  }\n\n  double result = sHighPrev + (prodLowSum + sLowSum);\n\n  if (Double.isNaN(result)) {\n  \n  \n  result = 0;\n  for (int i = 0; i < len; ++i) {\n  result += a[i] * b[i];\n  }\n  }\n\n  return result;\n  }",
          "fixed_method": "  public static double linearCombination(final double[] a, final double[] b) throws DimensionMismatchException {\n  final int len = a.length;\n  if (len != b.length) {\n  throw new DimensionMismatchException(len, b.length);\n  }\n\n  if (len == 1) {\n  \n  return a[0] * b[0];\n  }\n\n  final double[] prodHigh = new double[len];\n  double prodLowSum = 0;\n\n  for (int i = 0; i < len; i++) {\n  final double ai = a[i];\n  final double ca = SPLIT_FACTOR * ai;\n  final double aHigh = ca - (ca - ai);\n  final double aLow = ai - aHigh;\n\n  final double bi = b[i];\n  final double cb = SPLIT_FACTOR * bi;\n  final double bHigh = cb - (cb - bi);\n  final double bLow = bi - bHigh;\n  prodHigh[i] = ai * bi;\n  final double prodLow = aLow * bLow - (((prodHigh[i] -\n  aHigh * bHigh) -\n  aLow * bHigh) -\n  aHigh * bLow);\n  prodLowSum += prodLow;\n  }\n\n\n  final double prodHighCur = prodHigh[0];\n  double prodHighNext = prodHigh[1];\n  double sHighPrev = prodHighCur + prodHighNext;\n  double sPrime = sHighPrev - prodHighNext;\n  double sLowSum = (prodHighNext - (sHighPrev - sPrime)) + (prodHighCur - sPrime);\n\n  final int lenMinusOne = len - 1;\n  for (int i = 1; i < lenMinusOne; i++) {\n  prodHighNext = prodHigh[i + 1];\n  final double sHighCur = sHighPrev + prodHighNext;\n  sPrime = sHighCur - prodHighNext;\n  sLowSum += (prodHighNext - (sHighCur - sPrime)) + (sHighPrev - sPrime);\n  sHighPrev = sHighCur;\n  }\n\n  double result = sHighPrev + (prodLowSum + sLowSum);\n\n  if (Double.isNaN(result)) {\n  \n  \n  result = 0;\n  for (int i = 0; i < len; ++i) {\n  result += a[i] * b[i];\n  }\n  }\n\n  return result;\n  }",
          "diff": [
            "@@ -818,7 +818,10 @@",
            "             throw new DimensionMismatchException(len, b.length);\n",
            "         }\n",
            " \n",
            "+        if (len == 1) {\n",
            "             // Revert to scalar multiplication.\n",
            "+            return a[0] * b[0];\n",
            "+        }\n",
            " \n",
            "         final double[] prodHigh = new double[len];\n",
            "         double prodLowSum = 0;\n"
          ],
          "changed_lines": 3
        }
      ]
    }
  ]
}
