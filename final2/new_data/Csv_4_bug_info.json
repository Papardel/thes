{
  "bug_id": "4",
  "failed_tests": {
    "org.apache.commons.csv.CSVParserTest": [
      {
        "methodName": "testNoHeaderMap",
        "error": "java.lang.NullPointerException",
        "message": "",
        "fail_line": "        Assert.assertNull(parser.getHeaderMap());",
        "test_source": "  public void testNoHeaderMap() throws Exception {\n  final CSVParser parser = CSVParser.parse(\"a,b,c\\n1,2,3\\nx,y,z\", CSVFormat.DEFAULT);\n  Assert.assertNull(parser.getHeaderMap());\n  }",
        "stack": [
          "CSVParser.getHeaderMap line 288, CSVParserTest.testNoHeaderMap line 670"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/csv/CSVParser.java",
      "buggy_full_code": "\n\npackage org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Token.Type.TOKEN; import java.io.Closeable; import java.io.File; import java.io.FileReader; import java.io.IOException; import java.io.InputStreamReader; import java.io.Reader; import java.io.StringReader; import java.net.URL; import java.nio.charset.Charset; import java.util.ArrayList; import java.util.Iterator; import java.util.LinkedHashMap; import java.util.List; import java.util.Map; import java.util.NoSuchElementException; public final class CSVParser implements Iterable<CSVRecord>, Closeable { public static CSVParser parse(File file, final CSVFormat format) throws IOException {\n        Assertions.notNull(file, \"file\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new FileReader(file), format);\n    }\n\n    \n    public static CSVParser parse(String string, final CSVFormat format) throws IOException {\n        Assertions.notNull(string, \"string\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new StringReader(string), format);\n    }\n\n    \n    public static CSVParser parse(URL url, Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(url, \"url\");\n        Assertions.notNull(charset, \"charset\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new InputStreamReader(url.openStream(),\n                             charset == null ? Charset.forName(\"UTF-8\") : charset), format);\n    }\n\n    \n\n    private final CSVFormat format; private final Map<String, Integer> headerMap; private final Lexer lexer; private final List<String> record = new ArrayList<String>(); private long recordNumber; private final Token reusableToken = new Token(); public CSVParser(final Reader reader, final CSVFormat format) throws IOException {\n        Assertions.notNull(reader, \"reader\");\n        Assertions.notNull(format, \"format\");\n\n        format.validate();\n        this.format = format;\n        this.lexer = new Lexer(format, new ExtendedBufferedReader(reader));\n        this.headerMap = this.initializeHeader();\n    }\n\n    private void addRecordValue() {\n        final String input = this.reusableToken.content.toString();\n        final String nullString = this.format.getNullString();\n        if (nullString == null) {\n            this.record.add(input);\n        } else {\n            this.record.add(input.equalsIgnoreCase(nullString) ? null : input);\n        }\n    }\n\n    \n    public void close() throws IOException {\n        if (this.lexer != null) {\n            this.lexer.close();\n        }\n    }\n\n    \n    public long getCurrentLineNumber() {\n        return this.lexer.getCurrentLineNumber();\n    }\n\n    \n    public Map<String, Integer> getHeaderMap() {\n        return new LinkedHashMap<String, Integer>(this.headerMap);\n    }\n\n    \n    public long getRecordNumber() {\n        return this.recordNumber;\n    }\n\n    \n    public List<CSVRecord> getRecords() throws IOException {\n        final List<CSVRecord> records = new ArrayList<CSVRecord>();\n        CSVRecord rec;\n        while ((rec = this.nextRecord()) != null) {\n            records.add(rec);\n        }\n        return records;\n    }\n\n    \n    private Map<String, Integer> initializeHeader() throws IOException {\n        Map<String, Integer> hdrMap = null;\n        final String[] formatHeader = this.format.getHeader();\n        if (formatHeader != null) {\n            hdrMap = new LinkedHashMap<String, Integer>();\n\n            String[] header = null;\n            if (formatHeader.length == 0) {\n                \n                final CSVRecord record = this.nextRecord();\n                if (record != null) {\n                    header = record.values();\n                }\n            } else {\n                if (this.format.getSkipHeaderRecord()) {\n                    this.nextRecord();\n                }\n                header = formatHeader;\n            }\n\n            \n            if (header != null) {\n                for (int i = 0; i < header.length; i++) {\n                    hdrMap.put(header[i], Integer.valueOf(i));\n                }\n            }\n        }\n        return hdrMap;\n    }\n\n    public boolean isClosed() {\n        return this.lexer.isClosed();\n    }\n\n    \n    public Iterator<CSVRecord> iterator() {\n        return new Iterator<CSVRecord>() {\n            private CSVRecord current; private CSVRecord getNextRecord() {\n                try {\n                    return CSVParser.this.nextRecord();\n                } catch (final IOException e) {\n                    \n                    throw new RuntimeException(e);\n                }\n            }\n\n            public boolean hasNext() {\n                if (CSVParser.this.isClosed()) {\n                    return false;\n                }\n                if (this.current == null) {\n                    this.current = this.getNextRecord();\n                }\n\n                return this.current != null;\n            }\n\n            public CSVRecord next() {\n                if (CSVParser.this.isClosed()) {\n                    throw new NoSuchElementException(\"CSVParser has been closed\");\n                }\n                CSVRecord next = this.current;\n                this.current = null;\n\n                if (next == null) {\n                    \n                    next = this.getNextRecord();\n                    if (next == null) {\n                        throw new NoSuchElementException(\"No more CSV records available\");\n                    }\n                }\n\n                return next;\n            }\n\n            public void remove() {\n                throw new UnsupportedOperationException();\n            }\n        };\n    }\n\n    \n    CSVRecord nextRecord() throws IOException {\n        CSVRecord result = null;\n        this.record.clear();\n        StringBuilder sb = null;\n        do {\n            this.reusableToken.reset();\n            this.lexer.nextToken(this.reusableToken);\n            switch (this.reusableToken.type) {\n            case TOKEN:\n                this.addRecordValue();\n                break;\n            case EORECORD:\n                this.addRecordValue();\n                break;\n            case EOF:\n                if (this.reusableToken.isReady) {\n                    this.addRecordValue();\n                }\n                break;\n            case INVALID:\n                throw new IOException(\"(line \" + this.getCurrentLineNumber() + \") invalid parse sequence\");\n            case COMMENT: \n                if (sb == null) { \n                    sb = new StringBuilder();\n                } else {\n                    sb.append(Constants.LF);\n                }\n                sb.append(this.reusableToken.content);\n                this.reusableToken.type = TOKEN; \n                break;\n            }\n        } while (this.reusableToken.type == TOKEN);\n\n        if (!this.record.isEmpty()) {\n            this.recordNumber++;\n            final String comment = sb == null ? null : sb.toString();\n            result = new CSVRecord(this.record.toArray(new String[this.record.size()]), this.headerMap, comment,\n                    this.recordNumber);\n        }\n        return result;\n    }\n\n}\n",
      "fixed_full_code": "\n\npackage org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Token.Type.TOKEN; import java.io.Closeable; import java.io.File; import java.io.FileReader; import java.io.IOException; import java.io.InputStreamReader; import java.io.Reader; import java.io.StringReader; import java.net.URL; import java.nio.charset.Charset; import java.util.ArrayList; import java.util.Iterator; import java.util.LinkedHashMap; import java.util.List; import java.util.Map; import java.util.NoSuchElementException; public final class CSVParser implements Iterable<CSVRecord>, Closeable { public static CSVParser parse(File file, final CSVFormat format) throws IOException {\n        Assertions.notNull(file, \"file\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new FileReader(file), format);\n    }\n\n    \n    public static CSVParser parse(String string, final CSVFormat format) throws IOException {\n        Assertions.notNull(string, \"string\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new StringReader(string), format);\n    }\n\n    \n    public static CSVParser parse(URL url, Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(url, \"url\");\n        Assertions.notNull(charset, \"charset\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new InputStreamReader(url.openStream(),\n                             charset == null ? Charset.forName(\"UTF-8\") : charset), format);\n    }\n\n    \n\n    private final CSVFormat format; private final Map<String, Integer> headerMap; private final Lexer lexer; private final List<String> record = new ArrayList<String>(); private long recordNumber; private final Token reusableToken = new Token(); public CSVParser(final Reader reader, final CSVFormat format) throws IOException {\n        Assertions.notNull(reader, \"reader\");\n        Assertions.notNull(format, \"format\");\n\n        format.validate();\n        this.format = format;\n        this.lexer = new Lexer(format, new ExtendedBufferedReader(reader));\n        this.headerMap = this.initializeHeader();\n    }\n\n    private void addRecordValue() {\n        final String input = this.reusableToken.content.toString();\n        final String nullString = this.format.getNullString();\n        if (nullString == null) {\n            this.record.add(input);\n        } else {\n            this.record.add(input.equalsIgnoreCase(nullString) ? null : input);\n        }\n    }\n\n    \n    public void close() throws IOException {\n        if (this.lexer != null) {\n            this.lexer.close();\n        }\n    }\n\n    \n    public long getCurrentLineNumber() {\n        return this.lexer.getCurrentLineNumber();\n    }\n\n    \n    public Map<String, Integer> getHeaderMap() {\n        return this.headerMap == null ? null : new LinkedHashMap<String, Integer>(this.headerMap);\n    }\n\n    \n    public long getRecordNumber() {\n        return this.recordNumber;\n    }\n\n    \n    public List<CSVRecord> getRecords() throws IOException {\n        final List<CSVRecord> records = new ArrayList<CSVRecord>();\n        CSVRecord rec;\n        while ((rec = this.nextRecord()) != null) {\n            records.add(rec);\n        }\n        return records;\n    }\n\n    \n    private Map<String, Integer> initializeHeader() throws IOException {\n        Map<String, Integer> hdrMap = null;\n        final String[] formatHeader = this.format.getHeader();\n        if (formatHeader != null) {\n            hdrMap = new LinkedHashMap<String, Integer>();\n\n            String[] header = null;\n            if (formatHeader.length == 0) {\n                \n                final CSVRecord record = this.nextRecord();\n                if (record != null) {\n                    header = record.values();\n                }\n            } else {\n                if (this.format.getSkipHeaderRecord()) {\n                    this.nextRecord();\n                }\n                header = formatHeader;\n            }\n\n            \n            if (header != null) {\n                for (int i = 0; i < header.length; i++) {\n                    hdrMap.put(header[i], Integer.valueOf(i));\n                }\n            }\n        }\n        return hdrMap;\n    }\n\n    public boolean isClosed() {\n        return this.lexer.isClosed();\n    }\n\n    \n    public Iterator<CSVRecord> iterator() {\n        return new Iterator<CSVRecord>() {\n            private CSVRecord current; private CSVRecord getNextRecord() {\n                try {\n                    return CSVParser.this.nextRecord();\n                } catch (final IOException e) {\n                    \n                    throw new RuntimeException(e);\n                }\n            }\n\n            public boolean hasNext() {\n                if (CSVParser.this.isClosed()) {\n                    return false;\n                }\n                if (this.current == null) {\n                    this.current = this.getNextRecord();\n                }\n\n                return this.current != null;\n            }\n\n            public CSVRecord next() {\n                if (CSVParser.this.isClosed()) {\n                    throw new NoSuchElementException(\"CSVParser has been closed\");\n                }\n                CSVRecord next = this.current;\n                this.current = null;\n\n                if (next == null) {\n                    \n                    next = this.getNextRecord();\n                    if (next == null) {\n                        throw new NoSuchElementException(\"No more CSV records available\");\n                    }\n                }\n\n                return next;\n            }\n\n            public void remove() {\n                throw new UnsupportedOperationException();\n            }\n        };\n    }\n\n    \n    CSVRecord nextRecord() throws IOException {\n        CSVRecord result = null;\n        this.record.clear();\n        StringBuilder sb = null;\n        do {\n            this.reusableToken.reset();\n            this.lexer.nextToken(this.reusableToken);\n            switch (this.reusableToken.type) {\n            case TOKEN:\n                this.addRecordValue();\n                break;\n            case EORECORD:\n                this.addRecordValue();\n                break;\n            case EOF:\n                if (this.reusableToken.isReady) {\n                    this.addRecordValue();\n                }\n                break;\n            case INVALID:\n                throw new IOException(\"(line \" + this.getCurrentLineNumber() + \") invalid parse sequence\");\n            case COMMENT: \n                if (sb == null) { \n                    sb = new StringBuilder();\n                } else {\n                    sb.append(Constants.LF);\n                }\n                sb.append(this.reusableToken.content);\n                this.reusableToken.type = TOKEN; \n                break;\n            }\n        } while (this.reusableToken.type == TOKEN);\n\n        if (!this.record.isEmpty()) {\n            this.recordNumber++;\n            final String comment = sb == null ? null : sb.toString();\n            result = new CSVRecord(this.record.toArray(new String[this.record.size()]), this.headerMap, comment,\n                    this.recordNumber);\n        }\n        return result;\n    }\n\n}\n",
      "buggy_signatures": [
        "static org.apache.commons.csv.Token.Type.TOKEN; import java.io.Closeable; import java.io.File; import java.io.FileReader; import java.io.IOException; import java.io.InputStreamReader; import java.io.Reader; import java.io.StringReader; import java.net.URL; import java.nio.charset.Charset; import java.util.ArrayList; import java.util.Iterator; import java.util.LinkedHashMap; import java.util.List; import java.util.Map; import java.util.NoSuchElementException; public final class CSVParser implements Iterable<CSVRecord>, Closeable { public static CSVParser parse(File file, final CSVFormat format) throws IOException",
        "public static CSVParser parse(String string, final CSVFormat format) throws IOException",
        "public static CSVParser parse(URL url, Charset charset, final CSVFormat format) throws IOException",
        "private void addRecordValue()",
        "public void close() throws IOException",
        "public long getCurrentLineNumber()",
        "public Map<String, Integer> getHeaderMap()",
        "public long getRecordNumber()",
        "public List<CSVRecord> getRecords() throws IOException",
        "private Map<String, Integer> initializeHeader() throws IOException",
        "public boolean isClosed()",
        "public Iterator<CSVRecord> iterator()",
        "private CSVRecord current; private CSVRecord getNextRecord()",
        "public boolean hasNext()",
        "public CSVRecord next()",
        "public void remove()"
      ],
      "fixed_signatures": [
        "static org.apache.commons.csv.Token.Type.TOKEN; import java.io.Closeable; import java.io.File; import java.io.FileReader; import java.io.IOException; import java.io.InputStreamReader; import java.io.Reader; import java.io.StringReader; import java.net.URL; import java.nio.charset.Charset; import java.util.ArrayList; import java.util.Iterator; import java.util.LinkedHashMap; import java.util.List; import java.util.Map; import java.util.NoSuchElementException; public final class CSVParser implements Iterable<CSVRecord>, Closeable { public static CSVParser parse(File file, final CSVFormat format) throws IOException",
        "public static CSVParser parse(String string, final CSVFormat format) throws IOException",
        "public static CSVParser parse(URL url, Charset charset, final CSVFormat format) throws IOException",
        "private void addRecordValue()",
        "public void close() throws IOException",
        "public long getCurrentLineNumber()",
        "public Map<String, Integer> getHeaderMap()",
        "public long getRecordNumber()",
        "public List<CSVRecord> getRecords() throws IOException",
        "private Map<String, Integer> initializeHeader() throws IOException",
        "public boolean isClosed()",
        "public Iterator<CSVRecord> iterator()",
        "private CSVRecord current; private CSVRecord getNextRecord()",
        "public boolean hasNext()",
        "public CSVRecord next()",
        "public void remove()"
      ],
      "methods": [
        {
          "buggy_method": "  public Map<String, Integer> getHeaderMap() {\n  return new LinkedHashMap<String, Integer>(this.headerMap);\n  }",
          "fixed_method": "  public Map<String, Integer> getHeaderMap() {\n  return this.headerMap == null ? null : new LinkedHashMap<String, Integer>(this.headerMap);\n  }",
          "diff": [
            "@@ -285,7 +285,7 @@",
            "      * @return a copy of the header map that iterates in column order.\n",
            "      */\n",
            "     public Map<String, Integer> getHeaderMap() {\n",
            "-        return new LinkedHashMap<String, Integer>(this.headerMap);\n",
            "+        return this.headerMap == null ? null : new LinkedHashMap<String, Integer>(this.headerMap);\n",
            "     }\n",
            " \n",
            "     /**\n"
          ],
          "changed_lines": 2
        }
      ]
    }
  ]
}
