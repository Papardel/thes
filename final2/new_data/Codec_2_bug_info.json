{
  "bug_id": "2",
  "failed_tests": {
    "org.apache.commons.codec.binary.Base64InputStreamTest": [
      {
        "methodName": "testBase64EmptyInputStream",
        "error": "junit.framework.AssertionFailedError",
        "message": "EOF expected:<-1> but was:<13>",
        "fail_line": "        testByteByByte(emptyEncoded, emptyDecoded, 76, CRLF);",
        "test_source": "  public void testBase64EmptyInputStream() throws Exception {\n  byte[] emptyEncoded = new byte[0];\n  byte[] emptyDecoded = new byte[0];\n  testByteByByte(emptyEncoded, emptyDecoded, 76, CRLF);\n  testByChunk(emptyEncoded, emptyDecoded, 76, CRLF);\n  }",
        "stack": [
          "Base64InputStreamTest.testByteByByte line 142, Base64InputStreamTest.testBase64EmptyInputStream line 53"
        ]
      }
    ],
    "org.apache.commons.codec.binary.Base64OutputStreamTest": [
      {
        "methodName": "testBase64EmptyOutputStream",
        "error": "junit.framework.AssertionFailedError",
        "message": "Streaming base64 encode",
        "fail_line": "        testByteByByte(emptyEncoded, emptyDecoded, 76, CRLF);",
        "test_source": "  public void testBase64EmptyOutputStream() throws Exception {\n  byte[] emptyEncoded = new byte[0];\n  byte[] emptyDecoded = new byte[0];\n  testByteByByte(emptyEncoded, emptyDecoded, 76, CRLF);\n  testByChunk(emptyEncoded, emptyDecoded, 76, CRLF);\n  }  ",
        "stack": [
          "Base64OutputStreamTest.testByteByByte line 142, Base64OutputStreamTest.testBase64EmptyOutputStream line 53"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/codec/binary/Base64.java",
      "buggy_full_code": "\n\npackage org.apache.commons.codec.binary;\n\nimport org.apache.commons.codec.BinaryDecoder;\nimport org.apache.commons.codec.BinaryEncoder;\nimport org.apache.commons.codec.DecoderException;\nimport org.apache.commons.codec.EncoderException;\n\nimport java.io.UnsupportedEncodingException;\nimport java.math.BigInteger;\n\n\npublic class Base64 implements BinaryEncoder, BinaryDecoder {\n    \n    static final int CHUNK_SIZE = 76;\n\n    \n    static final byte[] CHUNK_SEPARATOR = {'\\r','\\n'};\n\n    \n    private static final byte[] STANDARD_ENCODE_TABLE = {\n            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n            'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n            'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'\n    };\n\n        \n    private static final byte[] URL_SAFE_ENCODE_TABLE = {\n            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n            'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n            'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-', '_'\n    };\n\n    \n    private static final byte PAD = '=';\n\n    \n    private static final byte[] DECODE_TABLE = {\n            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n            -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, 62, -1, 63, 52, 53, 54,\n            55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4,\n            5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,\n            24, 25, -1, -1, -1, -1, 63, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34,\n            35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51\n    };\n\n    \n    private static final int MASK_6BITS = 0x3f;\n\n    \n    private static final int MASK_8BITS = 0xff;\n\n    \n    \n    \n\n    \n    private final byte[] encodeTable;\n\n    \n    private final int lineLength;\n\n    \n    private final byte[] lineSeparator;\n\n    \n    private final int decodeSize;\n\n    \n    private final int encodeSize;\n\n    \n    private byte[] buf;\n\n    \n    private int pos;\n\n    \n    private int readPos;\n\n    \n    private int currentLinePos;\n\n    \n    private int modulus;\n\n    \n    private boolean eof;\n\n    \n    private int x;\n\n    \n    public Base64() {\n        this(false);\n    }\n\n    \n    public Base64(boolean urlSafe) {\n        this(CHUNK_SIZE, CHUNK_SEPARATOR, urlSafe);\n    }\n\n    \n    public Base64(int lineLength) {\n        this(lineLength, CHUNK_SEPARATOR);\n    }\n\n    \n    public Base64(int lineLength, byte[] lineSeparator) {\n        this(lineLength, lineSeparator, false);\n    }\n\n    \n    public Base64(int lineLength, byte[] lineSeparator, boolean urlSafe) {\n        this.lineLength = lineLength;\n        this.lineSeparator = new byte[lineSeparator.length];\n        System.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);\n        if (lineLength > 0) {\n            this.encodeSize = 4 + lineSeparator.length;\n        } else {\n            this.encodeSize = 4;\n        }\n        this.decodeSize = this.encodeSize - 1;\n        if (containsBase64Byte(lineSeparator)) {\n            String sep;\n            try {\n                sep = new String(lineSeparator, \"UTF-8\");\n            } catch (UnsupportedEncodingException uee) {\n                sep = new String(lineSeparator);\n            }\n            throw new IllegalArgumentException(\"lineSeperator must not contain base64 characters: [\" + sep + \"]\");\n        }\n        this.encodeTable = urlSafe ? URL_SAFE_ENCODE_TABLE : STANDARD_ENCODE_TABLE;\n    }\n\n    \n    public boolean isUrlSafe() {\n        return this.encodeTable == URL_SAFE_ENCODE_TABLE;\n    }\n\n    \n    boolean hasData() {\n        return this.buf != null;\n    }\n\n    \n    int avail() {\n        return buf != null ? pos - readPos : 0;\n    }\n\n    \n    private void resizeBuf() {\n        if (buf == null) {\n            buf = new byte[8192];\n            pos = 0;\n            readPos = 0;\n        } else {\n            byte[] b = new byte[buf.length * 2];\n            System.arraycopy(buf, 0, b, 0, buf.length);\n            buf = b;\n        }\n    }\n\n    \n    int readResults(byte[] b, int bPos, int bAvail) {\n        if (buf != null) {\n            int len = Math.min(avail(), bAvail);\n            if (buf != b) {\n                System.arraycopy(buf, readPos, b, bPos, len);\n                readPos += len;\n                if (readPos >= pos) {\n                    buf = null;\n                }\n            } else {\n                \n                \n                buf = null;\n            }\n            return len;\n        }\n        return eof ? -1 : 0;\n    }\n\n    \n    void setInitialBuffer(byte[] out, int outPos, int outAvail) {\n        \n        \n        if (out != null && out.length == outAvail) {\n            buf = out;\n            pos = outPos;\n            readPos = outPos;\n        }\n    }\n\n    \n    void encode(byte[] in, int inPos, int inAvail) {\n        if (eof) {\n            return;\n        }\n        \n        \n        if (inAvail < 0) {\n            eof = true;\n            if (buf == null || buf.length - pos < encodeSize) {\n                resizeBuf();\n            }\n            switch (modulus) {\n                case 1:\n                    buf[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\n                    buf[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n                    \n                    if (encodeTable == STANDARD_ENCODE_TABLE) {\n                        buf[pos++] = PAD;\n                        buf[pos++] = PAD;\n                    }\n                    break;\n\n                case 2:\n                    buf[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\n                    buf[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\n                    buf[pos++] = encodeTable[(x << 2) & MASK_6BITS];\n                    \n                    if (encodeTable == STANDARD_ENCODE_TABLE) {\n                        buf[pos++] = PAD;\n                    }\n                    break;\n            }\n            if (lineLength > 0) {\n                System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n                pos += lineSeparator.length;\n            }\n        } else {\n            for (int i = 0; i < inAvail; i++) {\n                if (buf == null || buf.length - pos < encodeSize) {\n                    resizeBuf();\n                }\n                modulus = (++modulus) % 3;\n                int b = in[inPos++];\n                if (b < 0) { b += 256; }\n                x = (x << 8) + b;\n                if (0 == modulus) {\n                    buf[pos++] = encodeTable[(x >> 18) & MASK_6BITS];\n                    buf[pos++] = encodeTable[(x >> 12) & MASK_6BITS];\n                    buf[pos++] = encodeTable[(x >> 6) & MASK_6BITS];\n                    buf[pos++] = encodeTable[x & MASK_6BITS];\n                    currentLinePos += 4;\n                    if (lineLength > 0 && lineLength <= currentLinePos) {\n                        System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n                        pos += lineSeparator.length;\n                        currentLinePos = 0;\n                    }\n                }\n            }\n        }\n    }\n\n        \n    void decode(byte[] in, int inPos, int inAvail) {\n        if (eof) {\n            return;\n        }\n        if (inAvail < 0) {\n            eof = true;\n        }\n        for (int i = 0; i < inAvail; i++) {\n            if (buf == null || buf.length - pos < decodeSize) {\n                resizeBuf();\n            }\n            byte b = in[inPos++];\n            if (b == PAD) {\n                \n                eof = true;\n                break;\n            } else {\n                if (b >= 0 && b < DECODE_TABLE.length) {\n                    int result = DECODE_TABLE[b];\n                    if (result >= 0) {\n                        modulus = (++modulus) % 4;\n                        x = (x << 6) + result;\n                        if (modulus == 0) {\n                            buf[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n                            buf[pos++] = (byte) ((x >> 8) & MASK_8BITS);\n                            buf[pos++] = (byte) (x & MASK_8BITS);\n                        }\n                    }\n                }\n            }\n        }\n\n        \n        \n        \n        if (eof && modulus != 0) {\n            x = x << 6;\n            switch (modulus) {\n                case 2:\n                    x = x << 6;\n                    buf[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n                    break;\n                case 3:\n                    buf[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n                    buf[pos++] = (byte) ((x >> 8) & MASK_8BITS);\n                    break;\n            }\n        }\n    }\n\n    \n    public static boolean isBase64(byte octet) {\n        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);\n    }\n\n    \n    public static boolean isArrayByteBase64(byte[] arrayOctet) {\n        for (int i = 0; i < arrayOctet.length; i++) {\n            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    private static boolean containsBase64Byte(byte[] arrayOctet) {\n        for (int i = 0; i < arrayOctet.length; i++) {\n            if (isBase64(arrayOctet[i])) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    \n    public static byte[] encodeBase64(byte[] binaryData) {\n        return encodeBase64(binaryData, false);\n    }\n\n    \n    public static byte[] encodeBase64URLSafe(byte[] binaryData) {\n        return encodeBase64(binaryData, false, true);\n    }\n    \n\n    \n    public static byte[] encodeBase64Chunked(byte[] binaryData) {\n        return encodeBase64(binaryData, true);\n    }\n\n    \n    public Object decode(Object pObject) throws DecoderException {\n        if (!(pObject instanceof byte[])) {\n            throw new DecoderException(\"Parameter supplied to Base64 decode is not a byte[]\");\n        }\n        return decode((byte[]) pObject);\n    }\n\n    \n    public byte[] decode(byte[] pArray) {\n        return decodeBase64(pArray);\n    }\n\n    \n    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        return encodeBase64(binaryData, isChunked, false);\n    }\n\n    \n    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {\n        if (binaryData == null || binaryData.length == 0) {\n            return binaryData;\n        }\n        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\n        long len = (binaryData.length * 4) / 3;\n        long mod = len % 4;\n        if (mod != 0) {\n            len += 4 - mod;\n        }\n        if (isChunked) {\n            len += (1 + (len / CHUNK_SIZE)) * CHUNK_SEPARATOR.length;\n        }\n        if (len > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        byte[] buf = new byte[(int) len];\n        b64.setInitialBuffer(buf, 0, buf.length);\n        b64.encode(binaryData, 0, binaryData.length);\n        b64.encode(binaryData, 0, -1); \n        \n        if (b64.buf != buf) {\n            b64.readResults(buf, 0, buf.length);\n        }\n        \n        \n        if (urlSafe && b64.pos < buf.length) {\n            byte[] smallerBuf = new byte[b64.pos];\n            System.arraycopy(buf, 0, smallerBuf, 0, b64.pos);\n            buf = smallerBuf;\n        }\n        return buf;\n    }\n\n    \n    public static byte[] decodeBase64(byte[] base64Data) {\n        if (base64Data == null || base64Data.length == 0) {\n            return base64Data;\n        }\n        Base64 b64 = new Base64();\n        long len = (base64Data.length * 3) / 4;\n        byte[] buf = new byte[(int) len];\n        b64.setInitialBuffer(buf, 0, buf.length);\n        b64.decode(base64Data, 0, base64Data.length);\n        b64.decode(base64Data, 0, -1); \n        \n        \n        byte[] result = new byte[b64.pos];\n        b64.readResults(result, 0, result.length);\n        return result;\n    }\n\n    \n    static byte[] discardWhitespace(byte[] data) {\n        byte groomedData[] = new byte[data.length];\n        int bytesCopied = 0;\n        for (int i = 0; i < data.length; i++) {\n            switch (data[i]) {\n                case ' ' :\n                case '\\n' :\n                case '\\r' :\n                case '\\t' :\n                    break;\n                default :\n                    groomedData[bytesCopied++] = data[i];\n            }\n        }\n        byte packedData[] = new byte[bytesCopied];\n        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);\n        return packedData;\n    }\n\n\n    \n    private static boolean isWhiteSpace(byte byteToCheck) {\n        switch (byteToCheck) {\n            case ' ' :\n            case '\\n' :\n            case '\\r' :\n            case '\\t' :\n                return true;\n            default :\n                return false;\n        }\n    }\n\n    \n    static byte[] discardNonBase64(byte[] data) {\n        byte groomedData[] = new byte[data.length];\n        int bytesCopied = 0;\n        for (int i = 0; i < data.length; i++) {\n            if (isBase64(data[i])) {\n                groomedData[bytesCopied++] = data[i];\n            }\n        }\n        byte packedData[] = new byte[bytesCopied];\n        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);\n        return packedData;\n    }\n\n    \n\n    \n    public Object encode(Object pObject) throws EncoderException {\n        if (!(pObject instanceof byte[])) {\n            throw new EncoderException(\"Parameter supplied to Base64 encode is not a byte[]\");\n        }\n        return encode((byte[]) pObject);\n    }\n\n    \n    public byte[] encode(byte[] pArray) {\n        return encodeBase64(pArray, false, isUrlSafe());\n    }\n\n    \n    \n    public static BigInteger decodeInteger(byte[] pArray) {\n        return new BigInteger(1, decodeBase64(pArray));\n    }\n\n    \n    public static byte[] encodeInteger(BigInteger bigInt) {\n        if(bigInt == null)  {\n            throw new NullPointerException(\"encodeInteger called with null parameter\");\n        }\n        return encodeBase64(toIntegerBytes(bigInt), false);\n    }\n\n    \n     static byte[] toIntegerBytes(BigInteger bigInt) {\n        int bitlen = bigInt.bitLength();\n        \n        bitlen = ((bitlen + 7) >> 3) << 3;\n        byte[] bigBytes = bigInt.toByteArray();\n\n        if(((bigInt.bitLength() % 8) != 0) &&\n            (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {\n            return bigBytes;\n        }\n        \n        int startSrc = 0;\n        int len = bigBytes.length;\n\n        \n        if((bigInt.bitLength() % 8) == 0) {\n            startSrc = 1;\n            len--;\n        }\n        int startDst = bitlen / 8 - len; \n        byte[] resizedBytes = new byte[bitlen / 8];\n        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);\n        return resizedBytes;\n    }\n}\n",
      "fixed_full_code": "\n\npackage org.apache.commons.codec.binary;\n\nimport org.apache.commons.codec.BinaryDecoder;\nimport org.apache.commons.codec.BinaryEncoder;\nimport org.apache.commons.codec.DecoderException;\nimport org.apache.commons.codec.EncoderException;\n\nimport java.io.UnsupportedEncodingException;\nimport java.math.BigInteger;\n\n\npublic class Base64 implements BinaryEncoder, BinaryDecoder {\n    \n    static final int CHUNK_SIZE = 76;\n\n    \n    static final byte[] CHUNK_SEPARATOR = {'\\r','\\n'};\n\n    \n    private static final byte[] STANDARD_ENCODE_TABLE = {\n            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n            'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n            'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'\n    };\n\n        \n    private static final byte[] URL_SAFE_ENCODE_TABLE = {\n            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n            'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n            'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-', '_'\n    };\n\n    \n    private static final byte PAD = '=';\n\n    \n    private static final byte[] DECODE_TABLE = {\n            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n            -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, 62, -1, 63, 52, 53, 54,\n            55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4,\n            5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,\n            24, 25, -1, -1, -1, -1, 63, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34,\n            35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51\n    };\n\n    \n    private static final int MASK_6BITS = 0x3f;\n\n    \n    private static final int MASK_8BITS = 0xff;\n\n    \n    \n    \n\n    \n    private final byte[] encodeTable;\n\n    \n    private final int lineLength;\n\n    \n    private final byte[] lineSeparator;\n\n    \n    private final int decodeSize;\n\n    \n    private final int encodeSize;\n\n    \n    private byte[] buf;\n\n    \n    private int pos;\n\n    \n    private int readPos;\n\n    \n    private int currentLinePos;\n\n    \n    private int modulus;\n\n    \n    private boolean eof;\n\n    \n    private int x;\n\n    \n    public Base64() {\n        this(false);\n    }\n\n    \n    public Base64(boolean urlSafe) {\n        this(CHUNK_SIZE, CHUNK_SEPARATOR, urlSafe);\n    }\n\n    \n    public Base64(int lineLength) {\n        this(lineLength, CHUNK_SEPARATOR);\n    }\n\n    \n    public Base64(int lineLength, byte[] lineSeparator) {\n        this(lineLength, lineSeparator, false);\n    }\n\n    \n    public Base64(int lineLength, byte[] lineSeparator, boolean urlSafe) {\n        this.lineLength = lineLength;\n        this.lineSeparator = new byte[lineSeparator.length];\n        System.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);\n        if (lineLength > 0) {\n            this.encodeSize = 4 + lineSeparator.length;\n        } else {\n            this.encodeSize = 4;\n        }\n        this.decodeSize = this.encodeSize - 1;\n        if (containsBase64Byte(lineSeparator)) {\n            String sep;\n            try {\n                sep = new String(lineSeparator, \"UTF-8\");\n            } catch (UnsupportedEncodingException uee) {\n                sep = new String(lineSeparator);\n            }\n            throw new IllegalArgumentException(\"lineSeperator must not contain base64 characters: [\" + sep + \"]\");\n        }\n        this.encodeTable = urlSafe ? URL_SAFE_ENCODE_TABLE : STANDARD_ENCODE_TABLE;\n    }\n\n    \n    public boolean isUrlSafe() {\n        return this.encodeTable == URL_SAFE_ENCODE_TABLE;\n    }\n\n    \n    boolean hasData() {\n        return this.buf != null;\n    }\n\n    \n    int avail() {\n        return buf != null ? pos - readPos : 0;\n    }\n\n    \n    private void resizeBuf() {\n        if (buf == null) {\n            buf = new byte[8192];\n            pos = 0;\n            readPos = 0;\n        } else {\n            byte[] b = new byte[buf.length * 2];\n            System.arraycopy(buf, 0, b, 0, buf.length);\n            buf = b;\n        }\n    }\n\n    \n    int readResults(byte[] b, int bPos, int bAvail) {\n        if (buf != null) {\n            int len = Math.min(avail(), bAvail);\n            if (buf != b) {\n                System.arraycopy(buf, readPos, b, bPos, len);\n                readPos += len;\n                if (readPos >= pos) {\n                    buf = null;\n                }\n            } else {\n                \n                \n                buf = null;\n            }\n            return len;\n        }\n        return eof ? -1 : 0;\n    }\n\n    \n    void setInitialBuffer(byte[] out, int outPos, int outAvail) {\n        \n        \n        if (out != null && out.length == outAvail) {\n            buf = out;\n            pos = outPos;\n            readPos = outPos;\n        }\n    }\n\n    \n    void encode(byte[] in, int inPos, int inAvail) {\n        if (eof) {\n            return;\n        }\n        \n        \n        if (inAvail < 0) {\n            eof = true;\n            if (buf == null || buf.length - pos < encodeSize) {\n                resizeBuf();\n            }\n            switch (modulus) {\n                case 1:\n                    buf[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\n                    buf[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n                    \n                    if (encodeTable == STANDARD_ENCODE_TABLE) {\n                        buf[pos++] = PAD;\n                        buf[pos++] = PAD;\n                    }\n                    break;\n\n                case 2:\n                    buf[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\n                    buf[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\n                    buf[pos++] = encodeTable[(x << 2) & MASK_6BITS];\n                    \n                    if (encodeTable == STANDARD_ENCODE_TABLE) {\n                        buf[pos++] = PAD;\n                    }\n                    break;\n            }\n            if (lineLength > 0 && pos > 0) {\n                System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n                pos += lineSeparator.length;\n            }\n        } else {\n            for (int i = 0; i < inAvail; i++) {\n                if (buf == null || buf.length - pos < encodeSize) {\n                    resizeBuf();\n                }\n                modulus = (++modulus) % 3;\n                int b = in[inPos++];\n                if (b < 0) { b += 256; }\n                x = (x << 8) + b;\n                if (0 == modulus) {\n                    buf[pos++] = encodeTable[(x >> 18) & MASK_6BITS];\n                    buf[pos++] = encodeTable[(x >> 12) & MASK_6BITS];\n                    buf[pos++] = encodeTable[(x >> 6) & MASK_6BITS];\n                    buf[pos++] = encodeTable[x & MASK_6BITS];\n                    currentLinePos += 4;\n                    if (lineLength > 0 && lineLength <= currentLinePos) {\n                        System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n                        pos += lineSeparator.length;\n                        currentLinePos = 0;\n                    }\n                }\n            }\n        }\n    }\n\n        \n    void decode(byte[] in, int inPos, int inAvail) {\n        if (eof) {\n            return;\n        }\n        if (inAvail < 0) {\n            eof = true;\n        }\n        for (int i = 0; i < inAvail; i++) {\n            if (buf == null || buf.length - pos < decodeSize) {\n                resizeBuf();\n            }\n            byte b = in[inPos++];\n            if (b == PAD) {\n                \n                eof = true;\n                break;\n            } else {\n                if (b >= 0 && b < DECODE_TABLE.length) {\n                    int result = DECODE_TABLE[b];\n                    if (result >= 0) {\n                        modulus = (++modulus) % 4;\n                        x = (x << 6) + result;\n                        if (modulus == 0) {\n                            buf[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n                            buf[pos++] = (byte) ((x >> 8) & MASK_8BITS);\n                            buf[pos++] = (byte) (x & MASK_8BITS);\n                        }\n                    }\n                }\n            }\n        }\n\n        \n        \n        \n        if (eof && modulus != 0) {\n            x = x << 6;\n            switch (modulus) {\n                case 2:\n                    x = x << 6;\n                    buf[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n                    break;\n                case 3:\n                    buf[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n                    buf[pos++] = (byte) ((x >> 8) & MASK_8BITS);\n                    break;\n            }\n        }\n    }\n\n    \n    public static boolean isBase64(byte octet) {\n        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);\n    }\n\n    \n    public static boolean isArrayByteBase64(byte[] arrayOctet) {\n        for (int i = 0; i < arrayOctet.length; i++) {\n            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    private static boolean containsBase64Byte(byte[] arrayOctet) {\n        for (int i = 0; i < arrayOctet.length; i++) {\n            if (isBase64(arrayOctet[i])) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    \n    public static byte[] encodeBase64(byte[] binaryData) {\n        return encodeBase64(binaryData, false);\n    }\n\n    \n    public static byte[] encodeBase64URLSafe(byte[] binaryData) {\n        return encodeBase64(binaryData, false, true);\n    }\n    \n\n    \n    public static byte[] encodeBase64Chunked(byte[] binaryData) {\n        return encodeBase64(binaryData, true);\n    }\n\n    \n    public Object decode(Object pObject) throws DecoderException {\n        if (!(pObject instanceof byte[])) {\n            throw new DecoderException(\"Parameter supplied to Base64 decode is not a byte[]\");\n        }\n        return decode((byte[]) pObject);\n    }\n\n    \n    public byte[] decode(byte[] pArray) {\n        return decodeBase64(pArray);\n    }\n\n    \n    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        return encodeBase64(binaryData, isChunked, false);\n    }\n\n    \n    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {\n        if (binaryData == null || binaryData.length == 0) {\n            return binaryData;\n        }\n        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\n        long len = (binaryData.length * 4) / 3;\n        long mod = len % 4;\n        if (mod != 0) {\n            len += 4 - mod;\n        }\n        if (isChunked) {\n            len += (1 + (len / CHUNK_SIZE)) * CHUNK_SEPARATOR.length;\n        }\n        if (len > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        byte[] buf = new byte[(int) len];\n        b64.setInitialBuffer(buf, 0, buf.length);\n        b64.encode(binaryData, 0, binaryData.length);\n        b64.encode(binaryData, 0, -1); \n        \n        if (b64.buf != buf) {\n            b64.readResults(buf, 0, buf.length);\n        }\n        \n        \n        if (urlSafe && b64.pos < buf.length) {\n            byte[] smallerBuf = new byte[b64.pos];\n            System.arraycopy(buf, 0, smallerBuf, 0, b64.pos);\n            buf = smallerBuf;\n        }\n        return buf;\n    }\n\n    \n    public static byte[] decodeBase64(byte[] base64Data) {\n        if (base64Data == null || base64Data.length == 0) {\n            return base64Data;\n        }\n        Base64 b64 = new Base64();\n        long len = (base64Data.length * 3) / 4;\n        byte[] buf = new byte[(int) len];\n        b64.setInitialBuffer(buf, 0, buf.length);\n        b64.decode(base64Data, 0, base64Data.length);\n        b64.decode(base64Data, 0, -1); \n        \n        \n        byte[] result = new byte[b64.pos];\n        b64.readResults(result, 0, result.length);\n        return result;\n    }\n\n    \n    static byte[] discardWhitespace(byte[] data) {\n        byte groomedData[] = new byte[data.length];\n        int bytesCopied = 0;\n        for (int i = 0; i < data.length; i++) {\n            switch (data[i]) {\n                case ' ' :\n                case '\\n' :\n                case '\\r' :\n                case '\\t' :\n                    break;\n                default :\n                    groomedData[bytesCopied++] = data[i];\n            }\n        }\n        byte packedData[] = new byte[bytesCopied];\n        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);\n        return packedData;\n    }\n\n\n    \n    private static boolean isWhiteSpace(byte byteToCheck) {\n        switch (byteToCheck) {\n            case ' ' :\n            case '\\n' :\n            case '\\r' :\n            case '\\t' :\n                return true;\n            default :\n                return false;\n        }\n    }\n\n    \n    static byte[] discardNonBase64(byte[] data) {\n        byte groomedData[] = new byte[data.length];\n        int bytesCopied = 0;\n        for (int i = 0; i < data.length; i++) {\n            if (isBase64(data[i])) {\n                groomedData[bytesCopied++] = data[i];\n            }\n        }\n        byte packedData[] = new byte[bytesCopied];\n        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);\n        return packedData;\n    }\n\n    \n\n    \n    public Object encode(Object pObject) throws EncoderException {\n        if (!(pObject instanceof byte[])) {\n            throw new EncoderException(\"Parameter supplied to Base64 encode is not a byte[]\");\n        }\n        return encode((byte[]) pObject);\n    }\n\n    \n    public byte[] encode(byte[] pArray) {\n        return encodeBase64(pArray, false, isUrlSafe());\n    }\n\n    \n    \n    public static BigInteger decodeInteger(byte[] pArray) {\n        return new BigInteger(1, decodeBase64(pArray));\n    }\n\n    \n    public static byte[] encodeInteger(BigInteger bigInt) {\n        if(bigInt == null)  {\n            throw new NullPointerException(\"encodeInteger called with null parameter\");\n        }\n        return encodeBase64(toIntegerBytes(bigInt), false);\n    }\n\n    \n     static byte[] toIntegerBytes(BigInteger bigInt) {\n        int bitlen = bigInt.bitLength();\n        \n        bitlen = ((bitlen + 7) >> 3) << 3;\n        byte[] bigBytes = bigInt.toByteArray();\n\n        if(((bigInt.bitLength() % 8) != 0) &&\n            (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {\n            return bigBytes;\n        }\n        \n        int startSrc = 0;\n        int len = bigBytes.length;\n\n        \n        if((bigInt.bitLength() % 8) == 0) {\n            startSrc = 1;\n            len--;\n        }\n        int startDst = bitlen / 8 - len; \n        byte[] resizedBytes = new byte[bitlen / 8];\n        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);\n        return resizedBytes;\n    }\n}\n",
      "buggy_signatures": [
        "public Base64()",
        "public Base64(boolean urlSafe)",
        "public Base64(int lineLength)",
        "public Base64(int lineLength, byte[] lineSeparator)",
        "public Base64(int lineLength, byte[] lineSeparator, boolean urlSafe)",
        "public boolean isUrlSafe()",
        "private void resizeBuf()",
        "public static boolean isBase64(byte octet)",
        "public static boolean isArrayByteBase64(byte[] arrayOctet)",
        "private static boolean containsBase64Byte(byte[] arrayOctet)",
        "public static byte[] encodeBase64(byte[] binaryData)",
        "public static byte[] encodeBase64URLSafe(byte[] binaryData)",
        "public static byte[] encodeBase64Chunked(byte[] binaryData)",
        "public Object decode(Object pObject) throws DecoderException",
        "public byte[] decode(byte[] pArray)",
        "public static byte[] encodeBase64(byte[] binaryData, boolean isChunked)",
        "public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe)",
        "public static byte[] decodeBase64(byte[] base64Data)",
        "static byte[] discardWhitespace(byte[] data)",
        "private static boolean isWhiteSpace(byte byteToCheck)",
        "static byte[] discardNonBase64(byte[] data)",
        "public Object encode(Object pObject) throws EncoderException",
        "public byte[] encode(byte[] pArray)",
        "public static BigInteger decodeInteger(byte[] pArray)",
        "public static byte[] encodeInteger(BigInteger bigInt)",
        "static byte[] toIntegerBytes(BigInteger bigInt)"
      ],
      "fixed_signatures": [
        "public Base64()",
        "public Base64(boolean urlSafe)",
        "public Base64(int lineLength)",
        "public Base64(int lineLength, byte[] lineSeparator)",
        "public Base64(int lineLength, byte[] lineSeparator, boolean urlSafe)",
        "public boolean isUrlSafe()",
        "private void resizeBuf()",
        "public static boolean isBase64(byte octet)",
        "public static boolean isArrayByteBase64(byte[] arrayOctet)",
        "private static boolean containsBase64Byte(byte[] arrayOctet)",
        "public static byte[] encodeBase64(byte[] binaryData)",
        "public static byte[] encodeBase64URLSafe(byte[] binaryData)",
        "public static byte[] encodeBase64Chunked(byte[] binaryData)",
        "public Object decode(Object pObject) throws DecoderException",
        "public byte[] decode(byte[] pArray)",
        "public static byte[] encodeBase64(byte[] binaryData, boolean isChunked)",
        "public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe)",
        "public static byte[] decodeBase64(byte[] base64Data)",
        "static byte[] discardWhitespace(byte[] data)",
        "private static boolean isWhiteSpace(byte byteToCheck)",
        "static byte[] discardNonBase64(byte[] data)",
        "public Object encode(Object pObject) throws EncoderException",
        "public byte[] encode(byte[] pArray)",
        "public static BigInteger decodeInteger(byte[] pArray)",
        "public static byte[] encodeInteger(BigInteger bigInt)",
        "static byte[] toIntegerBytes(BigInteger bigInt)"
      ],
      "methods": [
        {
          "buggy_method": "  private void resizeBuf() {\n  if (buf == null) {\n  buf = new byte[8192];\n  pos = 0;\n  readPos = 0;\n  } else {\n  byte[] b = new byte[buf.length * 2];\n  System.arraycopy(buf, 0, b, 0, buf.length);\n  buf = b;\n  }\n  }",
          "fixed_method": "  private void resizeBuf() {\n  if (buf == null) {\n  buf = new byte[8192];\n  pos = 0;\n  readPos = 0;\n  } else {\n  byte[] b = new byte[buf.length * 2];\n  System.arraycopy(buf, 0, b, 0, buf.length);\n  buf = b;\n  }\n  }",
          "diff": [
            "@@ -443,7 +443,7 @@",
            "                     }\n",
            "                     break;\n",
            "             }\n",
            "-            if (lineLength > 0) {\n",
            "+            if (lineLength > 0 && pos > 0) {\n",
            "                 System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n",
            "                 pos += lineSeparator.length;\n",
            "             }\n"
          ],
          "changed_lines": 2
        }
      ]
    }
  ]
}