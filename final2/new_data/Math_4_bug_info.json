{
  "bug_id": "4",
  "failed_tests": {
    "org.apache.commons.math3.geometry.euclidean.threed.SubLineTest": [
      {
        "methodName": "testIntersectionNotIntersecting",
        "error": "java.lang.NullPointerException",
        "message": "",
        "fail_line": "        Assert.assertNull(sub1.intersection(sub2, true));",
        "test_source": "  public void testIntersectionNotIntersecting() throws MathIllegalArgumentException {\n  SubLine sub1 = new SubLine(new Vector3D(1, 1, 1), new Vector3D(1.5, 1, 1));\n  SubLine sub2 = new SubLine(new Vector3D(2, 3, 0), new Vector3D(2, 3, 0.5));\n  Assert.assertNull(sub1.intersection(sub2, true));\n  Assert.assertNull(sub1.intersection(sub2, false));\n  }",
        "stack": [
          "Line.getAbscissa line 114, Line.toSubSpace line 129, SubLine.intersection line 116, SubLineTest.testIntersectionNotIntersecting line 160"
        ]
      }
    ],
    "org.apache.commons.math3.geometry.euclidean.twod.SubLineTest": [
      {
        "methodName": "testIntersectionParallel",
        "error": "java.lang.NullPointerException",
        "message": "",
        "fail_line": "        Assert.assertNull(sub1.intersection(sub2, true));",
        "test_source": "  public void testIntersectionParallel() {\n  final SubLine sub1 = new SubLine(new Vector2D(0, 1), new Vector2D(0, 2));\n  final SubLine sub2 = new SubLine(new Vector2D(66, 3), new Vector2D(66, 4));\n  Assert.assertNull(sub1.intersection(sub2, true));\n  Assert.assertNull(sub1.intersection(sub2, false));\n  }",
        "stack": [
          "Line.toSubSpace line 182, SubLine.intersection line 120, SubLineTest.testIntersectionParallel line 151"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/math3/geometry/euclidean/threed/SubLine.java",
      "buggy_full_code": "\npackage org.apache.commons.math3.geometry.euclidean.threed;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.math3.exception.MathIllegalArgumentException;\nimport org.apache.commons.math3.geometry.euclidean.oned.Interval;\nimport org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet;\nimport org.apache.commons.math3.geometry.euclidean.oned.Vector1D;\nimport org.apache.commons.math3.geometry.partitioning.Region.Location;\n\n\npublic class SubLine { private final Line line; private final IntervalsSet remainingRegion; public SubLine(final Line line, final IntervalsSet remainingRegion) {\n        this.line            = line;\n        this.remainingRegion = remainingRegion;\n    }\n\n    \n    public SubLine(final Vector3D start, final Vector3D end) throws MathIllegalArgumentException {\n        this(new Line(start, end), buildIntervalSet(start, end));\n    }\n\n    \n    public SubLine(final Segment segment) throws MathIllegalArgumentException {\n        this(segment.getLine(), buildIntervalSet(segment.getStart(), segment.getEnd()));\n    }\n\n    \n    public List<Segment> getSegments() {\n\n        final List<Interval> list = remainingRegion.asList();\n        final List<Segment> segments = new ArrayList<Segment>();\n\n        for (final Interval interval : list) {\n            final Vector3D start = line.toSpace(new Vector1D(interval.getInf()));\n            final Vector3D end   = line.toSpace(new Vector1D(interval.getSup()));\n            segments.add(new Segment(start, end, line));\n        }\n\n        return segments;\n\n    }\n\n    \n    public Vector3D intersection(final SubLine subLine, final boolean includeEndPoints) {\n\n        \n        Vector3D v1D = line.intersection(subLine.line);\n\n        \n        Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));\n\n        \n        Location loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));\n\n        if (includeEndPoints) {\n            return ((loc1 != Location.OUTSIDE) && (loc2 != Location.OUTSIDE)) ? v1D : null;\n        } else {\n            return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE)) ? v1D : null;\n        }\n\n    }\n\n    \n    private static IntervalsSet buildIntervalSet(final Vector3D start, final Vector3D end) throws MathIllegalArgumentException {\n        final Line line = new Line(start, end);\n        return new IntervalsSet(line.toSubSpace(start).getX(),\n                                line.toSubSpace(end).getX());\n    }\n\n}\n",
      "fixed_full_code": "\npackage org.apache.commons.math3.geometry.euclidean.threed;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.math3.exception.MathIllegalArgumentException;\nimport org.apache.commons.math3.geometry.euclidean.oned.Interval;\nimport org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet;\nimport org.apache.commons.math3.geometry.euclidean.oned.Vector1D;\nimport org.apache.commons.math3.geometry.partitioning.Region.Location;\n\n\npublic class SubLine { private final Line line; private final IntervalsSet remainingRegion; public SubLine(final Line line, final IntervalsSet remainingRegion) {\n        this.line            = line;\n        this.remainingRegion = remainingRegion;\n    }\n\n    \n    public SubLine(final Vector3D start, final Vector3D end) throws MathIllegalArgumentException {\n        this(new Line(start, end), buildIntervalSet(start, end));\n    }\n\n    \n    public SubLine(final Segment segment) throws MathIllegalArgumentException {\n        this(segment.getLine(), buildIntervalSet(segment.getStart(), segment.getEnd()));\n    }\n\n    \n    public List<Segment> getSegments() {\n\n        final List<Interval> list = remainingRegion.asList();\n        final List<Segment> segments = new ArrayList<Segment>();\n\n        for (final Interval interval : list) {\n            final Vector3D start = line.toSpace(new Vector1D(interval.getInf()));\n            final Vector3D end   = line.toSpace(new Vector1D(interval.getSup()));\n            segments.add(new Segment(start, end, line));\n        }\n\n        return segments;\n\n    }\n\n    \n    public Vector3D intersection(final SubLine subLine, final boolean includeEndPoints) {\n\n        \n        Vector3D v1D = line.intersection(subLine.line);\n        if (v1D == null) {\n            return null;\n        }\n\n        \n        Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));\n\n        \n        Location loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));\n\n        if (includeEndPoints) {\n            return ((loc1 != Location.OUTSIDE) && (loc2 != Location.OUTSIDE)) ? v1D : null;\n        } else {\n            return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE)) ? v1D : null;\n        }\n\n    }\n\n    \n    private static IntervalsSet buildIntervalSet(final Vector3D start, final Vector3D end) throws MathIllegalArgumentException {\n        final Line line = new Line(start, end);\n        return new IntervalsSet(line.toSubSpace(start).getX(),\n                                line.toSubSpace(end).getX());\n    }\n\n}\n",
      "buggy_signatures": [
        "public class SubLine { private final Line line; private final IntervalsSet remainingRegion; public SubLine(final Line line, final IntervalsSet remainingRegion)",
        "public SubLine(final Vector3D start, final Vector3D end) throws MathIllegalArgumentException",
        "public SubLine(final Segment segment) throws MathIllegalArgumentException",
        "public List<Segment> getSegments()",
        "public Vector3D intersection(final SubLine subLine, final boolean includeEndPoints)",
        "private static IntervalsSet buildIntervalSet(final Vector3D start, final Vector3D end) throws MathIllegalArgumentException"
      ],
      "fixed_signatures": [
        "public class SubLine { private final Line line; private final IntervalsSet remainingRegion; public SubLine(final Line line, final IntervalsSet remainingRegion)",
        "public SubLine(final Vector3D start, final Vector3D end) throws MathIllegalArgumentException",
        "public SubLine(final Segment segment) throws MathIllegalArgumentException",
        "public List<Segment> getSegments()",
        "public Vector3D intersection(final SubLine subLine, final boolean includeEndPoints)",
        "private static IntervalsSet buildIntervalSet(final Vector3D start, final Vector3D end) throws MathIllegalArgumentException"
      ],
      "methods": [
        {
          "buggy_method": "  public Vector3D intersection(final SubLine subLine, final boolean includeEndPoints) {\n\n  \n  Vector3D v1D = line.intersection(subLine.line);\n\n  \n  Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));\n\n  \n  Location loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));\n\n  if (includeEndPoints) {\n  return ((loc1 != Location.OUTSIDE) && (loc2 != Location.OUTSIDE)) ? v1D : null;\n  } else {\n  return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE)) ? v1D : null;\n  }\n\n  }",
          "fixed_method": "  public Vector3D intersection(final SubLine subLine, final boolean includeEndPoints) {\n\n  \n  Vector3D v1D = line.intersection(subLine.line);\n  if (v1D == null) {\n  return null;\n  }\n\n  \n  Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));\n\n  \n  Location loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));\n\n  if (includeEndPoints) {\n  return ((loc1 != Location.OUTSIDE) && (loc2 != Location.OUTSIDE)) ? v1D : null;\n  } else {\n  return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE)) ? v1D : null;\n  }\n\n  }",
          "diff": [
            "@@ -111,6 +111,9 @@",
            " \n",
            "         // compute the intersection on infinite line\n",
            "         Vector3D v1D = line.intersection(subLine.line);\n",
            "+        if (v1D == null) {\n",
            "+            return null;\n",
            "+        }\n",
            " \n",
            "         // check location of point with respect to first sub-line\n",
            "         Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));\n"
          ],
          "changed_lines": 3
        }
      ]
    },
    {
      "name": "org/apache/commons/math3/geometry/euclidean/twod/SubLine.java",
      "buggy_full_code": "\npackage org.apache.commons.math3.geometry.euclidean.twod;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.math3.geometry.euclidean.oned.Euclidean1D;\nimport org.apache.commons.math3.geometry.euclidean.oned.Interval;\nimport org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet;\nimport org.apache.commons.math3.geometry.euclidean.oned.OrientedPoint;\nimport org.apache.commons.math3.geometry.euclidean.oned.Vector1D;\nimport org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane;\nimport org.apache.commons.math3.geometry.partitioning.BSPTree;\nimport org.apache.commons.math3.geometry.partitioning.Hyperplane;\nimport org.apache.commons.math3.geometry.partitioning.Region;\nimport org.apache.commons.math3.geometry.partitioning.Region.Location;\nimport org.apache.commons.math3.geometry.partitioning.Side;\nimport org.apache.commons.math3.geometry.partitioning.SubHyperplane;\nimport org.apache.commons.math3.util.FastMath;\n\n\npublic class SubLine extends AbstractSubHyperplane<Euclidean2D, Euclidean1D> { public SubLine(final Hyperplane<Euclidean2D> hyperplane, final Region<Euclidean1D> remainingRegion) {\n        super(hyperplane, remainingRegion);\n    }\n\n    \n    public SubLine(final Vector2D start, final Vector2D end) {\n        super(new Line(start, end), buildIntervalSet(start, end));\n    }\n\n    \n    public SubLine(final Segment segment) {\n        super(segment.getLine(), buildIntervalSet(segment.getStart(), segment.getEnd()));\n    }\n\n    \n    public List<Segment> getSegments() {\n\n        final Line line = (Line) getHyperplane();\n        final List<Interval> list = ((IntervalsSet) getRemainingRegion()).asList();\n        final List<Segment> segments = new ArrayList<Segment>();\n\n        for (final Interval interval : list) {\n            final Vector2D start = line.toSpace(new Vector1D(interval.getInf()));\n            final Vector2D end   = line.toSpace(new Vector1D(interval.getSup()));\n            segments.add(new Segment(start, end, line));\n        }\n\n        return segments;\n\n    }\n\n    \n    public Vector2D intersection(final SubLine subLine, final boolean includeEndPoints) {\n\n        \n        Line line1 = (Line) getHyperplane();\n        Line line2 = (Line) subLine.getHyperplane();\n\n        \n        Vector2D v2D = line1.intersection(line2);\n\n        \n        Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D));\n\n        \n        Location loc2 = subLine.getRemainingRegion().checkPoint(line2.toSubSpace(v2D));\n\n        if (includeEndPoints) {\n            return ((loc1 != Location.OUTSIDE) && (loc2 != Location.OUTSIDE)) ? v2D : null;\n        } else {\n            return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE)) ? v2D : null;\n        }\n\n    }\n\n    \n    private static IntervalsSet buildIntervalSet(final Vector2D start, final Vector2D end) {\n        final Line line = new Line(start, end);\n        return new IntervalsSet(line.toSubSpace(start).getX(),\n                                line.toSubSpace(end).getX());\n    }\n\n    \n    @Override\n    protected AbstractSubHyperplane<Euclidean2D, Euclidean1D> buildNew(final Hyperplane<Euclidean2D> hyperplane, final Region<Euclidean1D> remainingRegion) {\n        return new SubLine(hyperplane, remainingRegion);\n    }\n\n    \n    @Override\n    public Side side(final Hyperplane<Euclidean2D> hyperplane) {\n\n        final Line    thisLine  = (Line) getHyperplane();\n        final Line    otherLine = (Line) hyperplane;\n        final Vector2D crossing  = thisLine.intersection(otherLine);\n\n        if (crossing == null) {\n            \n            final double global = otherLine.getOffset(thisLine);\n            return (global < -1.0e-10) ? Side.MINUS : ((global > 1.0e-10) ? Side.PLUS : Side.HYPER);\n        }\n\n        \n        final boolean direct = FastMath.sin(thisLine.getAngle() - otherLine.getAngle()) < 0;\n        final Vector1D x = thisLine.toSubSpace(crossing);\n        return getRemainingRegion().side(new OrientedPoint(x, direct));\n\n    }\n\n    \n    @Override\n    public SplitSubHyperplane<Euclidean2D> split(final Hyperplane<Euclidean2D> hyperplane) {\n\n        final Line    thisLine  = (Line) getHyperplane();\n        final Line    otherLine = (Line) hyperplane;\n        final Vector2D crossing  = thisLine.intersection(otherLine);\n\n        if (crossing == null) {\n            \n            final double global = otherLine.getOffset(thisLine);\n            return (global < -1.0e-10) ?\n                   new SplitSubHyperplane<Euclidean2D>(null, this) :\n                   new SplitSubHyperplane<Euclidean2D>(this, null);\n        }\n\n        \n        final boolean direct = FastMath.sin(thisLine.getAngle() - otherLine.getAngle()) < 0;\n        final Vector1D x      = thisLine.toSubSpace(crossing);\n        final SubHyperplane<Euclidean1D> subPlus  = new OrientedPoint(x, !direct).wholeHyperplane();\n        final SubHyperplane<Euclidean1D> subMinus = new OrientedPoint(x,  direct).wholeHyperplane();\n\n        final BSPTree<Euclidean1D> splitTree = getRemainingRegion().getTree(false).split(subMinus);\n        final BSPTree<Euclidean1D> plusTree  = getRemainingRegion().isEmpty(splitTree.getPlus()) ?\n                                               new BSPTree<Euclidean1D>(Boolean.FALSE) :\n                                               new BSPTree<Euclidean1D>(subPlus, new BSPTree<Euclidean1D>(Boolean.FALSE),\n                                                                        splitTree.getPlus(), null);\n        final BSPTree<Euclidean1D> minusTree = getRemainingRegion().isEmpty(splitTree.getMinus()) ?\n                                               new BSPTree<Euclidean1D>(Boolean.FALSE) :\n                                               new BSPTree<Euclidean1D>(subMinus, new BSPTree<Euclidean1D>(Boolean.FALSE),\n                                                                        splitTree.getMinus(), null);\n\n        return new SplitSubHyperplane<Euclidean2D>(new SubLine(thisLine.copySelf(), new IntervalsSet(plusTree)),\n                                                   new SubLine(thisLine.copySelf(), new IntervalsSet(minusTree)));\n\n    }\n\n}\n",
      "fixed_full_code": "\npackage org.apache.commons.math3.geometry.euclidean.twod;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.math3.geometry.euclidean.oned.Euclidean1D;\nimport org.apache.commons.math3.geometry.euclidean.oned.Interval;\nimport org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet;\nimport org.apache.commons.math3.geometry.euclidean.oned.OrientedPoint;\nimport org.apache.commons.math3.geometry.euclidean.oned.Vector1D;\nimport org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane;\nimport org.apache.commons.math3.geometry.partitioning.BSPTree;\nimport org.apache.commons.math3.geometry.partitioning.Hyperplane;\nimport org.apache.commons.math3.geometry.partitioning.Region;\nimport org.apache.commons.math3.geometry.partitioning.Region.Location;\nimport org.apache.commons.math3.geometry.partitioning.Side;\nimport org.apache.commons.math3.geometry.partitioning.SubHyperplane;\nimport org.apache.commons.math3.util.FastMath;\n\n\npublic class SubLine extends AbstractSubHyperplane<Euclidean2D, Euclidean1D> { public SubLine(final Hyperplane<Euclidean2D> hyperplane, final Region<Euclidean1D> remainingRegion) {\n        super(hyperplane, remainingRegion);\n    }\n\n    \n    public SubLine(final Vector2D start, final Vector2D end) {\n        super(new Line(start, end), buildIntervalSet(start, end));\n    }\n\n    \n    public SubLine(final Segment segment) {\n        super(segment.getLine(), buildIntervalSet(segment.getStart(), segment.getEnd()));\n    }\n\n    \n    public List<Segment> getSegments() {\n\n        final Line line = (Line) getHyperplane();\n        final List<Interval> list = ((IntervalsSet) getRemainingRegion()).asList();\n        final List<Segment> segments = new ArrayList<Segment>();\n\n        for (final Interval interval : list) {\n            final Vector2D start = line.toSpace(new Vector1D(interval.getInf()));\n            final Vector2D end   = line.toSpace(new Vector1D(interval.getSup()));\n            segments.add(new Segment(start, end, line));\n        }\n\n        return segments;\n\n    }\n\n    \n    public Vector2D intersection(final SubLine subLine, final boolean includeEndPoints) {\n\n        \n        Line line1 = (Line) getHyperplane();\n        Line line2 = (Line) subLine.getHyperplane();\n\n        \n        Vector2D v2D = line1.intersection(line2);\n        if (v2D == null) {\n            return null;\n        }\n\n        \n        Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D));\n\n        \n        Location loc2 = subLine.getRemainingRegion().checkPoint(line2.toSubSpace(v2D));\n\n        if (includeEndPoints) {\n            return ((loc1 != Location.OUTSIDE) && (loc2 != Location.OUTSIDE)) ? v2D : null;\n        } else {\n            return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE)) ? v2D : null;\n        }\n\n    }\n\n    \n    private static IntervalsSet buildIntervalSet(final Vector2D start, final Vector2D end) {\n        final Line line = new Line(start, end);\n        return new IntervalsSet(line.toSubSpace(start).getX(),\n                                line.toSubSpace(end).getX());\n    }\n\n    \n    @Override\n    protected AbstractSubHyperplane<Euclidean2D, Euclidean1D> buildNew(final Hyperplane<Euclidean2D> hyperplane, final Region<Euclidean1D> remainingRegion) {\n        return new SubLine(hyperplane, remainingRegion);\n    }\n\n    \n    @Override\n    public Side side(final Hyperplane<Euclidean2D> hyperplane) {\n\n        final Line    thisLine  = (Line) getHyperplane();\n        final Line    otherLine = (Line) hyperplane;\n        final Vector2D crossing  = thisLine.intersection(otherLine);\n\n        if (crossing == null) {\n            \n            final double global = otherLine.getOffset(thisLine);\n            return (global < -1.0e-10) ? Side.MINUS : ((global > 1.0e-10) ? Side.PLUS : Side.HYPER);\n        }\n\n        \n        final boolean direct = FastMath.sin(thisLine.getAngle() - otherLine.getAngle()) < 0;\n        final Vector1D x = thisLine.toSubSpace(crossing);\n        return getRemainingRegion().side(new OrientedPoint(x, direct));\n\n    }\n\n    \n    @Override\n    public SplitSubHyperplane<Euclidean2D> split(final Hyperplane<Euclidean2D> hyperplane) {\n\n        final Line    thisLine  = (Line) getHyperplane();\n        final Line    otherLine = (Line) hyperplane;\n        final Vector2D crossing  = thisLine.intersection(otherLine);\n\n        if (crossing == null) {\n            \n            final double global = otherLine.getOffset(thisLine);\n            return (global < -1.0e-10) ?\n                   new SplitSubHyperplane<Euclidean2D>(null, this) :\n                   new SplitSubHyperplane<Euclidean2D>(this, null);\n        }\n\n        \n        final boolean direct = FastMath.sin(thisLine.getAngle() - otherLine.getAngle()) < 0;\n        final Vector1D x      = thisLine.toSubSpace(crossing);\n        final SubHyperplane<Euclidean1D> subPlus  = new OrientedPoint(x, !direct).wholeHyperplane();\n        final SubHyperplane<Euclidean1D> subMinus = new OrientedPoint(x,  direct).wholeHyperplane();\n\n        final BSPTree<Euclidean1D> splitTree = getRemainingRegion().getTree(false).split(subMinus);\n        final BSPTree<Euclidean1D> plusTree  = getRemainingRegion().isEmpty(splitTree.getPlus()) ?\n                                               new BSPTree<Euclidean1D>(Boolean.FALSE) :\n                                               new BSPTree<Euclidean1D>(subPlus, new BSPTree<Euclidean1D>(Boolean.FALSE),\n                                                                        splitTree.getPlus(), null);\n        final BSPTree<Euclidean1D> minusTree = getRemainingRegion().isEmpty(splitTree.getMinus()) ?\n                                               new BSPTree<Euclidean1D>(Boolean.FALSE) :\n                                               new BSPTree<Euclidean1D>(subMinus, new BSPTree<Euclidean1D>(Boolean.FALSE),\n                                                                        splitTree.getMinus(), null);\n\n        return new SplitSubHyperplane<Euclidean2D>(new SubLine(thisLine.copySelf(), new IntervalsSet(plusTree)),\n                                                   new SubLine(thisLine.copySelf(), new IntervalsSet(minusTree)));\n\n    }\n\n}\n",
      "buggy_signatures": [
        "public class SubLine extends AbstractSubHyperplane<Euclidean2D, Euclidean1D> { public SubLine(final Hyperplane<Euclidean2D> hyperplane, final Region<Euclidean1D> remainingRegion)",
        "public SubLine(final Vector2D start, final Vector2D end)",
        "public SubLine(final Segment segment)",
        "public List<Segment> getSegments()",
        "public Vector2D intersection(final SubLine subLine, final boolean includeEndPoints)",
        "private static IntervalsSet buildIntervalSet(final Vector2D start, final Vector2D end)",
        "protected AbstractSubHyperplane<Euclidean2D, Euclidean1D> buildNew(final Hyperplane<Euclidean2D> hyperplane, final Region<Euclidean1D> remainingRegion)",
        "public Side side(final Hyperplane<Euclidean2D> hyperplane)",
        "public SplitSubHyperplane<Euclidean2D> split(final Hyperplane<Euclidean2D> hyperplane)"
      ],
      "fixed_signatures": [
        "public class SubLine extends AbstractSubHyperplane<Euclidean2D, Euclidean1D> { public SubLine(final Hyperplane<Euclidean2D> hyperplane, final Region<Euclidean1D> remainingRegion)",
        "public SubLine(final Vector2D start, final Vector2D end)",
        "public SubLine(final Segment segment)",
        "public List<Segment> getSegments()",
        "public Vector2D intersection(final SubLine subLine, final boolean includeEndPoints)",
        "private static IntervalsSet buildIntervalSet(final Vector2D start, final Vector2D end)",
        "protected AbstractSubHyperplane<Euclidean2D, Euclidean1D> buildNew(final Hyperplane<Euclidean2D> hyperplane, final Region<Euclidean1D> remainingRegion)",
        "public Side side(final Hyperplane<Euclidean2D> hyperplane)",
        "public SplitSubHyperplane<Euclidean2D> split(final Hyperplane<Euclidean2D> hyperplane)"
      ],
      "methods": [
        {
          "buggy_method": "  public Vector2D intersection(final SubLine subLine, final boolean includeEndPoints) {\n\n  \n  Line line1 = (Line) getHyperplane();\n  Line line2 = (Line) subLine.getHyperplane();\n\n  \n  Vector2D v2D = line1.intersection(line2);\n\n  \n  Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D));\n\n  \n  Location loc2 = subLine.getRemainingRegion().checkPoint(line2.toSubSpace(v2D));\n\n  if (includeEndPoints) {\n  return ((loc1 != Location.OUTSIDE) && (loc2 != Location.OUTSIDE)) ? v2D : null;\n  } else {\n  return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE)) ? v2D : null;\n  }\n\n  }",
          "fixed_method": "  public Vector2D intersection(final SubLine subLine, final boolean includeEndPoints) {\n\n  \n  Line line1 = (Line) getHyperplane();\n  Line line2 = (Line) subLine.getHyperplane();\n\n  \n  Vector2D v2D = line1.intersection(line2);\n  if (v2D == null) {\n  return null;\n  }\n\n  \n  Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D));\n\n  \n  Location loc2 = subLine.getRemainingRegion().checkPoint(line2.toSubSpace(v2D));\n\n  if (includeEndPoints) {\n  return ((loc1 != Location.OUTSIDE) && (loc2 != Location.OUTSIDE)) ? v2D : null;\n  } else {\n  return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE)) ? v2D : null;\n  }\n\n  }",
          "diff": [
            "@@ -115,6 +115,9 @@",
            " \n",
            "         // compute the intersection on infinite line\n",
            "         Vector2D v2D = line1.intersection(line2);\n",
            "+        if (v2D == null) {\n",
            "+            return null;\n",
            "+        }\n",
            " \n",
            "         // check location of point with respect to first sub-line\n",
            "         Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D));\n"
          ],
          "changed_lines": 3
        }
      ]
    }
  ]
}
